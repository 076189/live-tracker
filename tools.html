<!DOCTYPE html>
<html>
<head>
    <title>Live Tracker (Tools)</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="manifest-tools.json">
<link rel="apple-touch-icon" href="icons/apple-icon-180.png"> <meta name="apple-mobile-web-app-capable" content="yes">
    <style>
    /* --- CSS Styles (Includes Audit/Suspension styles) --- */
    /* Basic Reset & Font */
    body, html { margin: 0; padding: 0; box-sizing: border-box; }
    *, *:before, *:after { box-sizing: inherit; }
    body { font-family: Arial, sans-serif; padding: 20px; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; background-color: #f4f4f4; flex-direction: column; }
    /* Containers */
    .login-container, .app-container { background-color: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); text-align: center; margin: 20px auto; width: 90%; max-width: 800px; }
    .login-container { min-width: 300px; max-width: 400px; }
    /* Headings and Text */
    h1, h2, h3, h4 { margin-top: 0; color: #333; }
    h1 { margin-bottom: 20px; } h2 { margin-bottom: 20px; } h3 { margin-bottom: 15px; }
    h4 { margin-top: 25px; border-top: 1px solid #ccc; padding-top: 15px; margin-bottom: 10px; text-align: center; }
    .welcome-message { font-size: 1.2em; color: #555; margin-bottom: 20px; text-align: center;} /* Added text-align center */
    .description-text { font-size: 0.9em; color: #666; margin-top: 5px; margin-bottom: 15px; text-align: center; } /* Default center */
    .status-message { margin-top: 10px; text-align: center; min-height: 1em; font-weight: bold; }
    .export-reminder-message { display: none; padding: 10px 15px; margin-bottom: 20px; border-radius: 4px; border: 1px solid #ffeeba; background-color: #fff3cd; color: #856404; font-weight: bold; text-align: center; }
    .security-warning { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 10px 15px; margin: 15px 0; border-radius: 4px; font-size: 0.9em; text-align: left; }
    /* Button Styles & Grouping */
    .blue-button, .reset-button, .danger-button, .secondary-button, button.clear-btn, button { /* Combined base styles */
        padding: 10px 20px; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; margin-right: 10px; margin-bottom: 10px; display: inline-block; transition: background-color 0.2s ease, opacity 0.2s ease; vertical-align: middle;
        background-color: #007bff; /* Default blue */
    }
     button:hover, .blue-button:hover { background-color: #0056b3; } /* Default hover */
    .reset-button { background-color: #ffc107; color: black; border: 1px solid #d39e00; } .reset-button:hover { background-color: #e0a800; }
    .danger-button { background-color: #dc3545; } .danger-button:hover { background-color: #c82333; }
    .secondary-button { background-color: #6c757d; font-size: 0.9em; padding: 6px 12px;} .secondary-button:hover { background-color: #5a6268; }
     button.clear-btn { background-color: #ffc107; color: black; } /* From ibusdest */
     button.clear-btn:hover { background-color: #e0a800; }
    .blue-button:last-of-type, .reset-button:last-of-type, .danger-button:last-of-type, .secondary-button:last-of-type, button.clear-btn:last-of-type { margin-right: 0; } /* Handle last button margin */

    /* --- Disabled Button Style --- */
    button:disabled, .blue-button:disabled, .reset-button:disabled, .danger-button:disabled, .secondary-button:disabled, .clear-btn:disabled {
         background-color: #cccccc !important; /* Use important to override specifics if needed */
         border-color: #cccccc !important;
         color: #666666 !important;
         cursor: not-allowed;
         opacity: 0.7;
    }
     button:disabled:hover, .blue-button:disabled:hover, .reset-button:disabled:hover, .danger-button:disabled:hover, .secondary-button:disabled:hover, .clear-btn:disabled:hover {
         background-color: #cccccc !important; /* Prevent hover effect */
         border-color: #cccccc !important;
         color: #666666 !important;
     }
    /* --- End Disabled Button Style --- */

    /* --- Prune Button Specific Styles --- */
    .prune-button { background-color: #dc3545; border-color: #dc3545; }
    .prune-button:hover:not(:disabled) { background-color: #c82333; border-color: #bd2130; }
    /* Disabled state handled by general rule */
    /* --- End Prune Button Styles --- */

    .main-actions-container { margin-bottom: 25px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
    /* Forms & Inputs */
    .form-group, .settings-group { margin-bottom: 15px; text-align: left; }
    .form-group label, .settings-group label { display: block; margin-bottom: 5px; font-weight: bold; }
    .form-group-inline { display: flex; align-items: center; text-align: left; margin-bottom: 15px;}
    .form-group-inline input[type="checkbox"] { width: auto; margin-right: 8px; height: 1em; margin-bottom: 0;}
    .form-group-inline label { font-weight: normal; margin-bottom: 0; }
    fieldset { border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-bottom: 20px; margin-top: 20px; /* Added margin-top */}
    legend { font-weight: bold; padding: 0 5px; color: #555; }
    input[type="text"], input[type="password"], input[type="time"], input[type="number"], select, textarea { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; margin-bottom: 10px; font-size: 1em; font-family: inherit; line-height: 1.4; }
    textarea { /* Specific textarea adjustments if needed */ }

    /* Reduce specificity for buttons inside sections - CHECK IF MORE SELECTORS NEEDED */
    #add-curtailment-form button, #manual-fleet-form button,
    #settings-form fieldset button, .settings-group button,
    #data-actions .action-group button,
    #manage-curtailments-section button,
    #temp-overrides-section button, /* Added for new sections */
    #sequence-heading-section button, /* Added for new sections */
    #final-destinations-section fieldset button /* Added for new sections (more specific for fieldset) */
     {
         width: auto; display: inline-block; margin: 10px 10px 0 0;
    }
    /* Special case for backup/restore buttons spacing */
    #data-actions .action-group button { display: inline-block; margin: 5px; }

    /* Section/Form Styles */
    .section { margin-top: 20px; padding: 20px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9; text-align: left; margin-bottom: 20px; }
    /* Specific section IDs inherit from .section but can override */
    #add-curtailment-form, #manual-fleet-form, #settings-form, #data-actions,
    #manage-curtailments-section, #view-auto-tmp-section,
    #temp-overrides-section, #sequence-heading-section, #final-destinations-section /* Added new sections */
    { /* Inherits from .section */ }

    /* Specific Section Headings */
    #add-curtailment-form h3, #manual-fleet-form h3, #settings-form h2, #data-actions h3,
    #manage-curtailments-section h3, #view-auto-tmp-section h2,
    #temp-overrides-section h2, #sequence-heading-section h2, #final-destinations-section h2 /* Added new sections (using H2) */
    {
         margin-top: 0; text-align: center; margin-bottom: 15px; border: none; padding: 0;
    }
    #temp-overrides-section h3, #sequence-heading-section h3, #final-destinations-section h3 { /* Styles for H3 within new sections */
        margin-top: 20px; margin-bottom: 10px; color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px;
    }

    /* Add New User Form Container Styling Update */
    .add-user-form-container { padding: 10px 0; margin-bottom: 20px; }
    .add-user-form-container h4 { margin-top: 0; text-align: center; border: none; padding: 0; margin-bottom: 15px; }
    .add-user-form-container .form-group { margin-bottom: 10px; }
    .add-user-form-container button { display: block; width: 100%; max-width: 200px; margin: 15px auto 0 auto; }
    .add-user-form-container .status-message { margin-top: 15px; }

    /* User Management Table */
    #user-list-container {
        overflow-x: auto; /* Keep horizontal scrolling enabled as a fallback */
        max-width: 100%;
        margin-bottom: 15px;
    }
    /* CSS for the last column (Actions) */

#user-management-table th:last-child { /* Actions Header */
    text-align: center;
    vertical-align: middle;
    min-width: 120px; /* Or desired width */
    position: sticky; /* Keep sticky */
    top: 0;
    z-index: 10;
    background-color: #f0f0f0; /* Ensure background matches other headers */
}

#user-management-table td:last-child { /* Actions Cell */
    vertical-align: middle; /* Align button group vertically */
    width: 120px; /* Match header width if desired */
}

/* Action Buttons within Table */
#user-management-table tbody td:last-child button {
    display: block;
    width: 100%;
    margin: 0 auto 5px auto; /* Center buttons horizontally */
    padding: 5px 8px;
    font-size: 0.85em;
    box-sizing: border-box;
}
#user-management-table tbody td:last-child button:last-child {
    margin-bottom: 0;
}

/* Optional: Specific button coloring within the table */
#user-management-table .suspend-user-btn { /* Applied via JS now */
    background-color: #ffc107; color: black; border: 1px solid #d39e00;
}
#user-management-table .suspend-user-btn:hover { background-color: #e0a800; }

#user-management-table .unsuspend-user-btn { /* Applied via JS now */
    background-color: #28a745;
}
 #user-management-table .unsuspend-user-btn:hover { background-color: #218838; }
    /* --- End Permissions Cell Styling --- */

    /* Stack Action Buttons */
    #user-management-table tbody td:last-child {
         white-space: normal;
         min-width: 100px; /* Give actions buttons a minimum space */
    }
    #user-management-table tbody td:last-child button { display: block; width: 100%; margin-bottom: 5px; margin-right: 0; margin-left: 0; box-sizing: border-box; }
    #user-management-table tbody td:last-child button:last-child { margin-bottom: 0; }

    /* Manual Fleet Specific */
    .revert-section, .reset-all-section { margin-top: 25px; border-top: 1px dashed #ccc; padding-top: 20px; text-align: center; }
    #manual-assignments-display { text-align: left; max-height: 150px; overflow-y: auto; border: 1px solid #eee; padding: 10px; background-color: white; font-size: 0.9em; line-height: 1.4; margin-bottom: 20px; }
    #manual-assignments-display div { padding: 4px 2px; border-bottom: 1px dotted #f0f0f0; }
    #manual-assignments-display div:last-child { border-bottom: none; }
    #manual-assignments-display strong { display: inline-block; min-width: 90px; font-weight: bold; margin-right: 5px;}
    #manual-fleet-form .filter-controls input[type="text"] { width: auto; padding: 5px 8px; font-size: 0.9em; margin-bottom: 0; box-sizing: border-box; }

    /* --- Modal Styles --- */
     .modal-overlay {
        position: fixed; /* Takes it out of normal flow, relative to viewport */
        top: 0;
        left: 0;
        width: 100%;    /* Covers full width */
        height: 100%;   /* Covers full height */
        background-color: rgba(0, 0, 0, 0.6); /* Dimmed background */
        display: flex; /* Enables flexbox for centering */
        justify-content: center; /* Centers the modal box horizontally */
        align-items: center;    /* Centers the modal box vertically */
        z-index: 1000; /* Ensure it's on top of other content */
     }
     .modal-box { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); text-align: left; width: 90%; max-width: 400px; max-height: 80%; display: flex; flex-direction: column; overflow: hidden; }
     .modal-box h3 { margin-top: 0; text-align: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; flex-shrink: 0; }
     .modal-box label { margin-bottom: 8px; }
     .modal-box input[type="password"] { margin-bottom: 5px;}
     .modal-buttons { text-align: right; margin-top: auto; padding-top: 15px; border-top: 1px solid #eee; flex-shrink: 0; }
     .modal-buttons button { margin-left: 10px; } .modal-buttons .cancel-button { background-color: #6c757d; } .modal-buttons .cancel-button:hover { background-color: #5a6268; }

    /* Utility */
    .hidden { display: none; }
    #app-container > div:has(#logout-button) { text-align: center; } /* Center logout div */
    #manual-fleet-form div > .description-text { text-align: left; margin-top: 5px; } /* Left align specific desc */

    /* Backup/Restore Action Group */
    .action-group { text-align: center; margin-bottom: 20px; border-top: 1px solid #eee; padding-top: 15px; }
    .action-group:first-of-type { border-top: none; padding-top: 0; }
    .action-group h4 { margin-top: 0; margin-bottom: 10px; padding: 0; border: none; color: #555; font-size: 1.1em; }
    .action-group p.description-text { margin-top: 8px; margin-bottom: 0; text-align: center; } /* Ensure centered */

    /* --- Table Styles (Generic) --- */
    .table-container { overflow-x: auto; margin-top: 15px; }
    table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
    table th, table td { border: 1px solid #ddd; padding: 8px; text-align: left; vertical-align: middle; }
    table th { background-color: #f2f2f2; white-space: nowrap; }
    table td { word-break: break-word; }

    /* Manage Curtailments Table Specifics */
    #manage-curtailments-table th:first-child, #manage-curtailments-table td:first-child { text-align: center; width: 40px; visibility: visible; }
    #manage-curtailments-table input[type="checkbox"] { cursor: pointer; }
    .delete-selected-container { text-align: center; margin-top: 20px; }

    /* Auto TMP Table Specifics */
    #auto-tmp-table th:nth-child(1), #auto-tmp-table td:nth-child(1) { width: 80px; } /* Route */
    #auto-tmp-table th:nth-child(2), #auto-tmp-table td:nth-child(2) { width: 120px; } /* Fleet */
    #auto-tmp-table th:nth-child(3), #auto-tmp-table td:nth-child(3) { width: 120px; } /* Reg */
    #auto-tmp-table th:nth-child(4), #auto-tmp-table td:nth-child(4) { width: 120px; } /* Date Logged */
     /* --- Auto TMP Table Filter Row Styles --- */
     #auto-tmp-table thead tr.filter-row td { background-color: #f4f4f4; position: sticky; top: 30px; /* Adjust based on header row height */ z-index: 1; padding: 4px 8px; vertical-align: top; text-align: center; border-top: 1px solid #ccc; }
     #auto-tmp-table thead tr.filter-row select { padding: 3px 5px; font-size: 0.9em; width: 95%; max-width: 180px; box-sizing: border-box; margin-top: 2px; }

    /* Audit Log Styles */
    #admin-audit-log { margin-top: 20px; } #audit-log-display { max-height: 400px; overflow-y: auto; border: 1px solid #eee; padding: 10px; background-color: #fff; font-family: monospace; font-size: 0.85em; text-align: left; line-height: 1.4; } #audit-log-display div { border-bottom: 1px dotted #f0f0f0; padding: 4px 2px; } #audit-log-display div:last-child { border-bottom: none; }
    #audit-log-display .log-timestamp { color: #6c757d; display: inline-block; min-width: 150px;}
    #audit-log-display .log-user { color: #007bff; font-weight: bold; margin: 0 5px;}
    #audit-log-display .log-action { color: #28a745; }
    #audit-log-display .log-details { color: #555; margin-left: 10px; font-size: 0.9em; white-space: pre-wrap; word-break: break-all; display: inline; }
    #audit-log-controls { text-align: right; margin-bottom: 10px; } #clear-audit-log-btn { font-size: 0.8em; padding: 4px 8px; }


    /* --- Styles for Merged Sections (Temp Overrides, Sequence Headings, Final Destinations) --- */
    .override-section { border-top: 1px dashed #eee; padding-top: 15px; margin-top: 20px; }
    .override-group { margin-bottom: 15px; }

    /* Override List Styles */
    #overrides-list { max-height: 300px; overflow-y: auto; border: 1px solid #eee; padding: 10px; background-color: #fff; margin-top: 10px;}
    #overrides-list div, #active-sequence-headings-list div { /* Applied to both lists */
        display: flex; justify-content: space-between; align-items: center; padding: 8px 5px; border-bottom: 1px dotted #eee; flex-wrap: wrap; gap: 10px;
    }
    #overrides-list div:last-child, #active-sequence-headings-list div:last-child { border-bottom: none; }
    #overrides-list div span, #active-sequence-headings-list div span { /* Applied to both lists */
        flex-grow: 1; margin-right: 10px; text-align: left; word-break: break-word; min-width: 150px;
    }
    #overrides-list div span strong { display: inline-block; min-width: 150px; font-family: monospace; color: #17a2b8; }
    #overrides-list div span strong.global-key { color: #dc3545; font-weight: bold; }
    #overrides-list div span span.dest-dir { font-weight: bold; color: #6c757d; margin-left: 8px; }
    #overrides-list div span em { color: #999; font-style: italic; }
    #overrides-list button, #active-sequence-headings-list button { /* Applied to both lists */
        flex-shrink: 0; margin-left: auto; padding: 5px 10px; font-size: 0.9em;
    }
    /* Specifics for Sequence Heading List */
    #active-sequence-headings-list div span { font-size: 0.95em; }
    #active-sequence-headings-list div span strong { color: #333; font-family: Arial, sans-serif; font-weight: bold; min-width: 60px;}
    #active-sequence-headings-list div span .heading-dir { font-style: italic; color: #555; margin-right: 5px;}
    #active-sequence-headings-list div input[type="checkbox"] { /* Style checkbox */
        margin-right: 10px; flex-shrink: 0; cursor: pointer; vertical-align: middle; height: 1.1em; width: 1.1em;
    }
    #active-sequence-headings-list .select-all-container {
        padding: 8px 5px; border-bottom: 1px solid #ccc; text-align: left; font-weight: bold; font-size: 0.9em;
    }
    #active-sequence-headings-list .select-all-container input[type="checkbox"] { margin-right: 5px; }
     #active-sequence-headings-list .select-all-container label { display: inline; font-weight: bold; cursor: pointer; vertical-align: middle; }

    /* --- Styles for Final Destinations Section --- */
    .dest-editor-controls { border-bottom: 1px solid #ddd; margin-bottom: 15px; padding-bottom: 15px; display: flex; flex-wrap: wrap; gap: 15px; align-items: flex-end; }
    .dest-editor-controls > div { flex: 1 1 200px; min-width: 180px; }
    .dest-editor-controls label { margin-bottom: 3px; font-size: 0.9em; }
    .dest-editor-controls input[type="text"] { margin-bottom: 0; width: 100%; }
    .dest-editor-controls button { margin: 0 0 0 10px; flex-shrink: 0; }
    .dest-filter-buttons { margin-bottom: 15px; text-align: center; border-bottom: 1px solid #ddd; padding-bottom: 15px;}
    .dest-filter-buttons span { margin-right: 10px; font-weight: bold;}
    .dest-filter-buttons button { font-size: 0.9em; padding: 6px 12px; background-color: #e9ecef; color: #495057; border: 1px solid #ced4da; margin: 0 2px;}
    .dest-filter-buttons button.active { background-color: #007bff; color: white; border-color: #007bff;}
    .dest-filter-buttons button:hover:not(.active) { background-color: #d7dbdf; }
    #dest-editor-routes { max-height: 400px; overflow-y: auto; border: 1px solid #eee; padding: 10px; background-color: white; margin-bottom: 15px; }
    .dest-route-section { border: 1px solid #ccc; border-radius: 4px; padding: 15px; margin-bottom: 15px; background-color: #fdfdfd; }
    .dest-route-section.filtered-out { display: none; }
    .dest-route-section h4 { margin-top: 0; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; border: none; padding: 0; flex-wrap: wrap; gap: 5px; }
    .dest-route-section h4 span { font-size: 1.1em; color: #333; flex-shrink: 0; margin-right: 10px;}
    .dest-route-section .route-actions { display: flex; flex-wrap: wrap; gap: 5px; align-items: center; margin-left: auto;}
    .dest-route-section .route-actions button { margin-left: 5px; }
    .dest-route-section textarea { font-family: monospace; font-size: 0.95em; line-height: 1.4; width: 100%; box-sizing: border-box; }
    .prefill-status { font-size: 0.8em; color: #666; margin-left: 10px; font-style: italic; display: inline-block; min-height: 1em;}
    .dest-save-actions { text-align: center; margin-top: 15px;}
    .filter-placeholder { text-align: center; font-style: italic; color: #666; padding: 10px; }
    .bulk-input-section { margin-top: 20px; padding-top: 20px; border-top: 1px dashed #ccc; }
    .bulk-input-section textarea { height: 150px; font-family: monospace; }
    .bulk-input-section div { text-align: center; }

    /* --- Styles for Sequence Heading Override Section Layout --- */
    #sequence-heading-section .override-group { display: flex; flex-wrap: wrap; gap: 10px 20px; align-items: flex-start; }
    #sequence-heading-section .override-group > div { flex: 1 1 200px; min-width: 180px; }
    #sequence-heading-section .override-group > div label { margin-bottom: 3px; }
    #sequence-heading-section .override-group > div input[type="text"] { margin-bottom: 5px; }
    #sequence-heading-section .action-buttons { text-align: center; width: 100%; margin-top: 10px; }
    #sequence-heading-section .action-buttons button { margin-bottom: 0; }

    /* --- Access Denied Message Style (from ibusdest) --- */
    #access-denied-message {
        color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 15px 20px; margin: 30px auto; border-radius: 8px; text-align: center; font-weight: bold; max-width: 600px;
    }
/* --- Styles for Smaller Screens (Mobile) --- */
@media (max-width: 767px) {
    body {
        padding: 10px; /* Reduce body padding */
         -webkit-text-size-adjust: 100%; /* Prevent iOS font size adjustments */
    }

     /* Adjust container padding/width */
     .login-container, .app-container {
         padding: 15px;
         width: 100%;
         max-width: 100%;
     }
     .section {
         padding: 15px;
     }

     /* Stack main action buttons */
     .main-actions-container {
         flex-direction: column;
         align-items: stretch; /* Make buttons full width */
     }
     .main-actions-container button {
         width: 100%;
         margin-right: 0;
     }

     /* Improve form layout */
     .form-group label, .settings-group label {
         margin-bottom: 3px;
         font-size: 0.9em;
     }
     input[type="text"], input[type="password"], input[type="time"], input[type="number"], select, textarea {
         padding: 8px;
         font-size: 16px; /* Set to 16px to help prevent iOS auto-zoom on focus */
     }
      /* Ensure buttons in forms are easily tappable */
     #add-curtailment-form button, #manual-fleet-form button,
     #settings-form fieldset button, .settings-group button,
     #data-actions .action-group button,
     #manage-curtailments-section button,
     #temp-overrides-section button,
     #sequence-heading-section button,
     #final-destinations-section fieldset button {
        padding: 12px 15px; /* Larger padding */
        width: 100%; /* Make buttons full width in sections */
        margin: 10px 0 0 0; /* Adjust margin */
     }
     #data-actions .action-group button {
         width: auto; /* Keep backup/restore buttons inline */
     }

/* Force table rows to be visible on mobile, just in case */
#user-management-table tbody tr {
    display: table-row !important;
    visibility: visible !important;
}

     /* Make tables responsive */
     .table-container {
         /* No changes needed here, overflow-x: auto handles horizontal scroll */
     }
     /* Tighter Table Styles for Mobile */
     table {
         font-size: 0.75em; /* Even smaller base font */
     }
     table th, table td {
         padding: 3px 4px; /* Further reduce cell padding */
         white-space: normal !important; /* Ensure wrapping */
         vertical-align: top;
         line-height: 1.3; /* Adjust line height slightly for smaller font */
     }

     /* Specific User Management Table Adjustments */
     #user-management-table th, #user-management-table td {
          font-size: 1em; /* Relative to the table's 0.75em */
     }
     #user-management-table .permissions-cell { /* Target permissions cell */
          font-size: 0.9em; /* Make permission text slightly smaller */
          line-height: 1.2;
     }
      #user-management-table .permissions-cell label {
          margin-left: 3px; /* Space between checkbox and label */
      }
     #user-management-table th:last-child,
     #user-management-table td:last-child { /* Actions column */
        min-width: 65px; /* Further reduce min-width */
        width: auto;
        padding: 3px; /* Reduce padding for action cell */
        text-align: center; /* Center action buttons */
     }
      #user-management-table tbody td:last-child button {
          padding: 5px; /* Slightly smaller button padding */
          font-size: 0.9em; /* Relative font size for buttons */
          min-width: 60px; /* Ensure button text fits */
      }

     /* Modal adjustments */
     .modal-box {
         width: 95%;
         padding: 15px;
     }
     .modal-buttons button {
          padding: 10px 15px;
     }

     /* Adjust Final Destination Editor */
     .dest-editor-controls {
         flex-direction: column;
         align-items: stretch;
         gap: 10px;
     }
     .dest-editor-controls button {
         width: 100%;
         margin: 5px 0 0 0;
     }
     .dest-route-section h4 {
         flex-direction: column;
         align-items: flex-start;
     }
      .dest-route-section .route-actions {
         width: 100%;
         margin-left: 0;
         margin-top: 10px;
         justify-content: space-between;
      }
      .dest-route-section .route-actions button {
          flex-grow: 1; /* Allow buttons to grow */
          margin: 0 2px;
      }
}
</style>
</head>
<body>
    <div id="login-container" class="login-container">
        <h2>Live Tracker Tools Login</h2>
        <form onsubmit="login(); return false;" autocomplete="off">
            <div class="form-group"> <label for="username">Username:</label> <input type="text" id="username" name="username" required autocomplete="off"> </div>
            <div class="form-group"> <label for="password">Password:</label> <input type="password" id="password" name="password" required autocomplete="off"> </div>
            <div class="form-group-inline"> <input type="checkbox" id="stayLoggedInCheckbox" name="stayLoggedIn"> <label for="stayLoggedInCheckbox">Stay logged in</label> </div>
            <div class="form-group" style="text-align: center;"> <button type="submit" class="blue-button">Login</button> <p id="login-error" style="color: red; margin-top: 10px; min-height: 1em;"></p> </div>
        </form>
    </div>

    <div id="app-container" class="app-container hidden">

        <h1>Live Tracker Tools</h1>
        <p id="welcome-message" class="welcome-message"></p>
        <div id="export-reminder" class="export-reminder-message"></div>

        <div class="security-warning">
            <strong>Security Warning:</strong> This application handles sensitive operations (like password management and user roles) directly in the browser. This is insecure and should be implemented with a proper server-side backend for production use.
        </div>

        <div id="main-actions-container" class="main-actions-container">
    <button id="toggle-add-curtailment" onclick="showSection('add-curtailment-form')" class="blue-button hidden" data-permission="canManageCurtailments">Add New Curtailment</button>
    <button id="toggle-manual-fleet" onclick="showSection('manual-fleet-form')" class="blue-button hidden" data-permission="canManageFleet">Assign / View Manual Fleet</button>
    <button id="view-all-curtailments-btn" onclick="showSection('manage-curtailments-section')" class="blue-button hidden">View All Curtailments</button> <button id="toggle-temp-overrides" onclick="showSection('temp-overrides-section')" class="blue-button hidden" data-permission="canManageOverrides">Temporary Overrides</button>
    <button id="toggle-sequence-headings" onclick="showSection('sequence-heading-section')" class="blue-button hidden" data-permission="canManageSeqHeadings">Sequence Headings</button>
    <button id="toggle-final-destinations" onclick="showSection('final-destinations-section')" class="blue-button hidden" data-permission="canManageFinalDests">Final Destinations</button>

    <button id="toggle-backup-restore" onclick="showSection('data-actions')" class="blue-button hidden" data-permission="canBackupRestore">Backup &amp; Restore</button>
    <button id="toggle-settings" onclick="showSection('settings-form')" class="blue-button hidden">Settings</button> </div>

        <div style="text-align: center; margin-bottom: 20px;">
            <button id="go-back-button" class="blue-button secondary-button hidden" onclick="goBackToMainView()">← Go Back to Menu</button>
        </div>

        <div id="add-curtailment-form" class="section hidden">
            <h3>Add New Curtailment</h3>
            <div class="form-group"> <label for="route">Route Number:</label> <input type="text" id="route" required placeholder="e.g., 184" autocomplete="off"></div>
            <div class="form-group"> <label for="regNumber">Bus Registration:</label> <input type="text" id="regNumber" required placeholder="e.g., AB12CDE" autocomplete="off"></div>
            <div class="form-group"> <label for="curtailedDestination">Curtailed Destination:</label> <input type="text" id="curtailedDestination" required placeholder="e.g., Arnos Grove Station" autocomplete="off"></div>
            <div class="form-group"> <label for="curtailmentTimeInput">Time Logged (HH:MM):</label> <input type="time" id="curtailmentTimeInput" required autocomplete="off"></div>
            <button type="button" onclick="addCurtailment()" class="blue-button" data-permission="canManageCurtailments">Add Curtailment</button>
<p id="add-curtailment-message" class="status-message" style="color: green;"></p>
        </div>

        <div id="manual-fleet-form" class="section hidden">
            <h3>Assign / View Manual Fleet Number</h3>
            <div class="form-group"> <label for="manualRegNumber">Bus Registration:</label> <input type="text" id="manualRegNumber" placeholder="e.g., AB12CDE" autocomplete="off"></div>
            <div class="form-group"> <label for="manualFleetNumber">Real Fleet Number:</label> <input type="text" id="manualFleetNumber" placeholder="e.g., VH45161, 9001" autocomplete="off"></div>
            <button type="button" onclick="assignManualFleetNumber()" class="blue-button" data-permission="canManageFleet">Assign Fleet Number</button>
<p id="assign-status" class="status-message" style="color: green;"></p>

            <div style="margin-top: 25px; padding-top: 15px; border-top: 1px solid #eee; text-align: center;">
                <button id="view-auto-tmp-btn" type="button" onclick="showSection('view-auto-tmp-section')" class="blue-button">View Auto-Generated Assignments</button>
                <p class="description-text">View a table of registrations with system-assigned TMP / ERR numbers.</p>
            </div>

            <h4>Current Manual Assignments</h4>
            <div class="filter-controls" style="margin-bottom: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                <input type="text" id="manual-reg-filter" placeholder="Filter by Registration..." style="flex: 1; min-width: 150px; padding: 5px 8px; margin-bottom: 0; font-size: 0.9em;" oninput="displayManualAssignments()" autocomplete="off">
                <input type="text" id="manual-fleet-filter" placeholder="Filter by Fleet No..." style="flex: 1; min-width: 150px; padding: 5px 8px; margin-bottom: 0; font-size: 0.9em;" oninput="displayManualAssignments()" autocomplete="off">
            </div>
            <div id="manual-assignments-display">Loading...</div>
            <div class="revert-section hidden">
    <label for="revertRegNumber">Registration to Revert:</label>
    <input type="text" id="revertRegNumber" placeholder="e.g., AB12CDE" autocomplete="off">
    <button type="button" onclick="revertToTMP()" class="danger-button" data-permission="canManageFleet">Revert to Auto TMP</button> <p id="revert-status" class="status-message"></p>
</div>

            <div class="reset-all-section hidden">
    <h4>Reset All Assignments</h4> <button type="button" id="reset-tmp-button" onclick="resetTMPMap()" class="reset-button" data-permission="canManageFleet">Reset ALL TMP Assignments</button> <p class="description-text">Clears the stored Registration -> TMP map. Requires password.</p>
</div>
        </div>

        <div id="manage-curtailments-section" class="section hidden">
              <h3>View / Manage Curtailments</h3>
              <div id="manage-curtailments-controls" style="text-align: right; margin-bottom: 10px;">
                  </div>
              <div class="table-container">
                  <table id="manage-curtailments-table">
                      <thead>
                          <tr>
                              <th style="visibility: hidden;"> <input type="checkbox" id="select-all-curtailments-checkbox" class="hidden" onchange="handleSelectAllCurtailments()">
                              </th>
                              <th>Route</th>
                              <th>Fleet</th>
                              <th>Registration</th>
                              <th>Destination</th>
                              <th>Time Logged</th>
                          </tr>
                      </thead>
                      <tbody id="manage-curtailments-tbody">
                          <tr><td colspan="6">Loading...</td></tr>
                      </tbody>
                  </table>
              </div>
              <div class="delete-selected-container hidden">
                  <button type="button" id="delete-selected-curtailments-btn" onclick="deleteSelectedCurtailments()" class="danger-button hidden" data-permission="canManageCurtailments">Delete Selected</button>
              </div>
              <p id="manage-curtailments-message" class="status-message"></p>
        </div>

        <div id="view-auto-tmp-section" class="section hidden">
            <h2>Auto-Generated Fleet Assignments (TMP/ERR)</h2>
            <p id="auto-tmp-table-message" class="status-message"></p>
            <div class="table-container">
                <table id="auto-tmp-table">
                     <thead>
                         <tr>
                             <th>Route</th>
                             <th>Fleet (TMP/ERR)</th>
                             <th>Registration</th>
                             <th>Date Logged</th>
                         </tr>
                         <tr class="filter-row">
                             <td><select id="auto-tmp-filter-route" onchange="applyAndSaveAutoTmpFilters()"><option value="">All</option></select></td>
                             <td><select id="auto-tmp-filter-fleet" onchange="applyAndSaveAutoTmpFilters()"><option value="">All</option></select></td>
                             <td><select id="auto-tmp-filter-reg" onchange="applyAndSaveAutoTmpFilters()"><option value="">All</option></select></td>
                             <td><select id="auto-tmp-filter-date" onchange="applyAndSaveAutoTmpFilters()"><option value="">All</option></select></td>
                         </tr>
                     </thead>
                     <tbody id="auto-tmp-tbody">
                         </tbody>
                </table>
            </div>
        </div>

        <div id="settings-form" class="section hidden">
          <h2>Settings</h2>

          <fieldset id="change-my-password-section">
              <legend>Change My Password</legend>
              <div class="form-group">
                  <label for="current-password">Current Password:</label>
                  <input type="password" id="current-password" required autocomplete="current-password">
              </div>
              <div class="form-group">
                  <label for="new-password">New Password:</label>
                  <input type="password" id="new-password" required autocomplete="new-password">
              </div>
              <div class="form-group">
                  <label for="confirm-new-password">Confirm New Password:</label>
                  <input type="password" id="confirm-new-password" required autocomplete="new-password">
              </div>
              <button type="button" onclick="changeMyPassword()" class="blue-button">Change Password</button>
              <p id="change-password-message" class="status-message"></p>
          </fieldset>

          <fieldset id="tracker-settings-section" class="hidden" data-permission="canManageSettings">
              <legend>Tracker Settings</legend> <div class="settings-group">
                  <label for="setting-debounce">Curtailment Debounce (Minutes):</label>
                  <input type="number" id="setting-debounce" min="0" step="1" value="60"> <p class="description-text" style="text-align:left;">Prevents identical curtailments being logged too quickly.</p>
              </div>
              <div class="settings-group">
                  <label for="setting-timeout">Vehicle Timeout (Minutes):</label>
                  <input type="number" id="setting-timeout" min="1" step="1" value="30"> <p class="description-text" style="text-align:left;">The amount of time a bus stays in the tracker page after it stops polling.</p>
              </div>
              <div class="settings-group">
                  <label for="setting-auto-logout">Auto Logout (Minutes, 0=disable):</label>
                  <input type="number" id="setting-auto-logout" min="0" step="1" value="30"> <p class="description-text" style="text-align:left;">Automatically logs out after inactivity (unless 'Stay logged in' is checked).</p>
              </div>
              <button type="button" onclick="saveTrackerSettings()" class="blue-button">Save Tracker Settings</button> <p id="tracker-settings-message" class="status-message"></p>
          </fieldset>

          <fieldset id="admin-user-management" class="hidden" data-permission="canManageUsers">
              <legend>User Management</legend> <div class="add-user-form-container">
                  <h4>Add New User</h4>
                  <div class="form-group">
                      <label for="add-username">New Username:</label>
                      <input type="text" id="add-username" autocomplete="off"> </div>
                  <div class="form-group">
                      <label for="add-user-password">New Password:</label>
                      <input type="password" id="add-user-password" autocomplete="new-password"> </div>
                  <div class="form-group">
                      <label for="add-user-role">Role:</label>
                      <select id="add-user-role"> <option value="user" selected>User</option>
                          <option value="moderator">Moderator</option>
                          <option value="admin">Admin</option>
                      </select>
                  </div>
                  <button type="button" onclick="addUser()" class="blue-button">Add User</button> <p id="add-user-message" class="status-message"></p>
              </div>
              <h4 style="margin-top: 30px;">Manage Existing Users</h4>
              <div id="user-list-container" style="overflow-x: auto;">
                  <table id="user-management-table">
                      <thead>
                          <tr>
                              <th>Username</th>
                              <th>Role</th>
                              <th>Status</th>
                              <th class="permissions-header">Permissions</th>
                              <th>Actions</th>
                          </tr>
                      </thead>
                      <tbody id="user-management-tbody"></tbody>
                  </table>
              </div>
              <p id="user-management-message" class="status-message"></p>
          </fieldset>

          <fieldset id="admin-audit-log" class="hidden" data-permission="canViewAuditLog">
              <legend>Admin Audit Log</legend>
              <div id="audit-log-controls">
                  <button type="button" id="clear-audit-log-btn" onclick="clearAuditLog()" class="danger-button secondary-button" data-permission="canViewAuditLog">Clear Log</button>
              </div>
              <div id="audit-log-display"><p>Loading audit log...</p></div>
              <p id="audit-log-message" class="status-message"></p>
          </fieldset>
      </div>

        <div id="data-actions" class="section hidden">
              <h3>Backup &amp; Restore</h3>
              <div class="action-group"> <h4>Export All</h4>
    <button type="button" id="export-all-data-button" onclick="exportAllData()" class="blue-button" data-permission="canBackupRestore">Export ALL Data</button> <p id="export-all-status" class="status-message"></p>
    <p class="description-text">Exports all data types (Curtailments, Fleet/TMP, Headings, Destinations) as separate files.</p>
</div>
<div class="action-group">
    <h4>Curtailments</h4>
    <button type="button" id="export-curtailments-button" onclick="exportCurtailments()" class="blue-button" data-permission="canBackupRestore">Export ALL</button> <button type="button" id="import-curtailments-button" onclick="document.getElementById('import-file-curtailments').click()" class="blue-button" data-permission="canBackupRestore">Import ALL</button> <input type="file" id="import-file-curtailments" accept=".json" class="hidden">
    <p class="description-text">Save/load curtailments. Import MERGES new entries into existing data (ignores duplicate timestamps).</p> <p id="curtailments-backup-status" class="status-message"></p>
    <button type="button" id="prune-curtailments-button" onclick="pruneOldCurtailments()" class="blue-button prune-button" disabled data-permission="canManageCurtailments">Prune Old Curtailments</button> <p id="prune-status-message" class="status-message"></p>
    <p class="description-text" id="prune-description-text">Permanently delete curtailment records older than approx. 6 months.</p>
</div>
<div class="action-group">
    <h4>Fleet / TMP</h4>
    <button type="button" id="export-tmp-button" onclick="exportTmpMap()" class="blue-button" data-permission="canBackupRestore">Export ALL</button> <button type="button" id="import-tmp-button" onclick="document.getElementById('import-file-tmp').click()" class="blue-button" data-permission="canBackupRestore">Import ALL</button> <input type="file" id="import-file-tmp" accept=".json" class="hidden">
    <p class="description-text">Save/load Reg -> Fleet/TMP map. Import MERGES map (adds new & OVERWRITES existing regs).</p> <p id="tmp-backup-status" class="status-message"></p>
</div>
<div class="action-group">
    <h4>Sequence Headings</h4>
    <button type="button" id="export-seq-headings-button" onclick="exportSequenceHeadings()" class="blue-button" data-permission="canBackupRestore">Export All</button> <button type="button" id="import-seq-headings-button" onclick="document.getElementById('import-file-seq-headings').click()" class="blue-button" data-permission="canBackupRestore">Import All</button> <input type="file" id="import-file-seq-headings" accept=".json" class="hidden">
    <p class="description-text">Save/load manual Route Sequence Headings. Import MERGES headings (OVERWRITES existing routes).</p> <p id="seq-headings-backup-status" class="status-message"></p>
</div>
<div class="action-group">
    <h4>Final Destinations</h4>
    <button type="button" id="export-final-dest-button" onclick="exportFinalDestinations()" class="blue-button" data-permission="canBackupRestore">Export</button> <button type="button" id="import-final-dest-button" onclick="document.getElementById('import-file-final-dest').click()" class="blue-button" data-permission="canBackupRestore">Import</button> <input type="file" id="import-file-final-dest" accept=".json" class="hidden">
    <p class="description-text">Save/load official Final Destinations. Import MERGES destinations into existing lists (ignores duplicates).</p> <p id="final-dest-backup-status" class="status-message"></p>
</div>
        </div>

        <div id="temp-overrides-section" class="section hidden">
            <h2>Temporary Destination Overrides</h2>
            <p class="description-text" data-role-text="Admin or Moderator">Overrides apply in order: Specific Bus (Directional) &gt; Route (Directional) &gt; Global.</p>
            <div class="form-section">
                <h3>1. Specific Bus Override (Directional)</h3>
                <p class="description-text" data-role-text="Admin">Set a temporary destination for a single bus registration, specific to its direction. Leave a direction blank if not needed. Requires Admin role.</p>
                <div class="override-group">
                    <label for="override-reg">Bus Registration:</label>
                    <input type="text" id="override-reg" placeholder="e.g., AB12CDE" autocomplete="off" data-permission="canManageOverrides">
                </div>
                <div class="override-group">
                    <label for="override-dest-dir1">New Destination for Direction 1:</label>
                    <input type="text" id="override-dest-dir1" placeholder="e.g., Towards Terminus A" autocomplete="off" data-permission="canManageOverrides">
                </div>
                <div class="override-group">
                    <label for="override-dest-dir2">New Destination for Direction 2:</label>
                    <input type="text" id="override-dest-dir2" placeholder="e.g., Towards Terminus B" autocomplete="off" data-permission="canManageOverrides">
                </div>
                <div style="text-align: center;">
                    <button type="button" onclick="setRegistrationOverride()" data-permission="canManageOverrides">Set / Update Specific Override</button>
                    <p id="specific-status" class="status-message" style="color: green;"></p>
                </div>
            </div>
            <div class="form-section override-section">
                <h3>2. Route-Wide Directional Override</h3>
                <p class="description-text" data-role-text="Admin">Set specific temporary iBus destination overrides for each direction of a route. Leave a direction blank if no override is needed for it. Requires Admin role.</p>
                <div class="override-group">
                    <label for="route-override-id">Route:</label>
                    <input type="text" id="route-override-id" placeholder="e.g., 92 or N263" autocomplete="off" data-permission="canManageOverrides">
                </div>
                <div class="override-group">
                    <label for="route-override-dest-dir1">New Destination for Direction 1:</label>
                    <input type="text" id="route-override-dest-dir1" placeholder="e.g., Ealing Hospital" autocomplete="off" data-permission="canManageOverrides">
                </div>
                <div class="override-group">
                    <label for="route-override-dest-dir2">New Destination for Direction 2:</label>
                    <input type="text" id="route-override-dest-dir2" placeholder="e.g., Brent Park Tesco" autocomplete="off" data-permission="canManageOverrides">
                </div>
                <div style="text-align: center;">
                    <button type="button" onclick="setRouteOverride()" data-permission="canManageOverrides">Set / Update Directional Route Override</button>
                      <p id="route-status" class="status-message" style="color: green;"></p>
                  </div>
            </div>
            <div class="form-section override-section">
                <h3>3. Global Override</h3>
                <p class="description-text" data-role-text="Moderator or Admin">Set a temporary destination override message for ALL buses on ALL routes (unless overridden above). Requires Moderator or Admin role.</p>
                <div class="override-group">
                    <label for="global-override-dest">Global Message to Display:</label>
                    <input type="text" id="global-override-dest" placeholder="e.g., Check Service Updates" autocomplete="off" data-permission="canManageOverrides">
                </div>
                <div style="text-align: center;">
                    <button type="button" onclick="setGlobalOverride()" data-permission="canManageOverrides">Set Global Override</button>
                    <button type="button" onclick="clearGlobalOverride()" class="danger-button" data-permission="canManageOverrides">Clear Global Override</button>
                      <p id="global-status" class="status-message" style="color: green;"></p>
                  </div>
            </div>
            <div class="list-section override-section">
                <h3>Current Active Temporary Overrides</h3>
                <input type="text" id="filter-overrides" placeholder="Filter list by Reg, Route, or Destination..." autocomplete="off">
                <div id="overrides-list"><p>Loading overrides...</p></div>
            </div>
        </div>

        <div id="sequence-heading-section" class="section hidden">
          <h2>Set Route Sequence Headings</h2>
          <p class="description-text"> Manually set the 'Towards...' destination shown in the Route Sequence headings on the tracker page.
              This overrides the automatically detected name. Requires 'Manage Sequence Headings' permission to Set, Clear or Remove Selected.
          </p>
          <div class="form-section">
              <div class="override-group">
                  <div>
                      <label for="seq-heading-route-id">Route ID:</label>
                      <input type="text" id="seq-heading-route-id" placeholder="e.g., 184" oninput="loadCurrentSequenceHeadings()" autocomplete="off" data-permission="canManageSeqHeadings">
                  </div>
                  <div>
                      <label for="seq-heading-outbound">Outbound Destination:</label>
                      <input type="text" id="seq-heading-outbound" placeholder="e.g., Barnet, Chesterfield Rd" autocomplete="off" data-permission="canManageSeqHeadings">
                  </div>
                  <div>
                      <label for="seq-heading-inbound">Inbound Destination:</label>
                      <input type="text" id="seq-heading-inbound" placeholder="e.g., Turnpike Lane Station" autocomplete="off" data-permission="canManageSeqHeadings">
                  </div>
              </div>
              <div class="action-buttons">
                  <button type="button" onclick="setRouteSequenceHeadings()" class="blue-button" data-permission="canManageSeqHeadings">Set Headings for Route</button>
                  <button type="button" onclick="clearRouteSequenceHeadings()" class="danger-button" data-permission="canManageSeqHeadings">Clear Headings for Route</button>
              </div>
              <p id="seq-heading-status" class="status-message" style="color: green;"></p>
          </div>
          <div class="list-section override-section" style="margin-top: 30px;">
              <h3>Current Active Sequence Heading Overrides</h3>
              <div id="active-sequence-headings-list" style="max-height: 250px; overflow-y: auto; border: 1px solid #eee; padding: 10px; background-color: #fff; margin-bottom: 15px;">
                  <p>Loading...</p>
              </div>
              <div style="text-align: center;">
                  <button type="button" id="remove-selected-headings-btn" onclick="removeSelectedSequenceHeadings()" class="danger-button hidden" data-permission="canManageSeqHeadings">Remove Selected Headings</button>
                  <p id="remove-headings-status" class="status-message" style="color: green;"></p>
              </div>
          </div>
      </div>

        <div id="final-destinations-section" class="section hidden">
          <h2>Manage Final Destinations</h2>
          <fieldset id="final-destinations-fieldset">
              <legend>Official Route Termini</legend>
              <p class="description-text"> Define official iBus terminus points for routes below to improve automatic curtailment detection on the tracker pages. Requires 'Manage Final Destinations' permission to Save / Edit / Add / Remove / Suggest.
                  The list shows known TfL routes plus any you've manually added or previously saved.
                  Use the filter to find a route. Click 'Suggest Termini' to attempt to fetch suggestions from TfL (requires internet, may be blocked by browser if running locally). Add / remove routes manually if needed. Click 'Save All' when done.
                  Use the Bulk Input section below to add / update multiple routes at once.
              </p>
              <div class="dest-editor-controls">
                  <div>
                      <label for="dest-filter-input">Filter Individual Route List:</label>
                      <input type="text" id="dest-filter-input" placeholder="Enter route number..." autocomplete="off"> </div>
                  <div>
                      <label for="add-dest-route">Route to Add Manually:</label>
                      <input type="text" id="add-dest-route" placeholder="e.g., 999" autocomplete="off" data-permission="canManageFinalDests">
                  </div>
                  <button type="button" onclick="addDestRouteSectionManual()" class="blue-button secondary-button" data-permission="canManageFinalDests">Add Manually</button>
              </div>
              <div class="dest-filter-buttons">
                  <span>Show:</span>
                  <button type="button" id="filter-btn-all" class="active" onclick="setDestFilterState('all')">All Routes</button>
                  <button type="button" id="filter-btn-edited" onclick="setDestFilterState('edited')">Edited / Saved</button>
                  <button type="button" id="filter-btn-empty" onclick="setDestFilterState('empty')">Empty</button>
              </div>
              <div id="dest-editor-routes" style="max-height: 400px; overflow-y: auto; border: 1px solid #eee; padding: 10px; background-color: white; margin-bottom: 15px;">
                  <p>Loading routes...</p>
                  </div>
              <div class="bulk-input-section">
                  <h3>Bulk Input / Update</h3>
                  <p class="description-text"> Enter destinations here, one per line, using the format <code>ROUTE: Destination Text</code>. Existing destinations for a route will be replaced by the entries provided here for that route. Requires 'Manage Final Destinations' permission.
                  </p>
                  <textarea id="bulk-dest-input" placeholder="Example:&#10;184: Barnet, Chesterfield Rd&#10;184: Turnpike Lane Station&#10;92: Ealing Hospital&#10;92: Brent Park Tesco" autocomplete="off" data-permission="canManageFinalDests"></textarea>
                  <div>
                      <button type="button" id="process-bulk-dest-button" onclick="processBulkInput()" class="blue-button" data-permission="canManageFinalDests">Process Bulk Input</button>
                      <p id="bulk-dest-status" class="status-message"></p>
                  </div>
              </div>
              <div class="dest-save-actions">
                  <button type="button" id="save-dest-button" onclick="saveAllFinalDestinations()" class="blue-button" data-permission="canManageFinalDests">Save All Final Destinations</button>
                  <p id="dest-editor-message" class="status-message" style="color: green;"></p>
              </div>
          </fieldset>
      </div>
        <div style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px; text-align: center;">
            <button type="button" id="logout-button" onclick="logout()" class="blue-button" style="background-color: #6c757d;">Logout</button>
        </div>
<div id="set-password-modal" class="modal-overlay hidden">
        <div class="modal-box">
            <h3 id="set-password-modal-title">Set New Password</h3>
            <input type="hidden" id="set-password-username"> <div class="form-group">
                <label for="set-new-password">New Password:</label>
                <input type="password" id="set-new-password" required autocomplete="new-password">
            </div>
            <div class="form-group">
                <label for="set-confirm-password">Confirm New Password:</label>
                <input type="password" id="set-confirm-password" required autocomplete="new-password">
            </div>
            <p id="set-password-modal-error" style="color: red; min-height: 1em; margin-top: 5px;"></p>
            <div class="modal-buttons">
                <button type="button" onclick="hideSetPasswordModal()" class="blue-button cancel-button">Cancel</button>
                <button type="button" onclick="confirmSetPassword()" class="blue-button">Set Password</button>
            </div>
        </div>
    </div>

    </div> <div id="password-modal" class="modal-overlay hidden">
         <div class="modal-box">
             <h3>Confirm Action</h3>
             <label for="confirm-password" id="password-modal-prompt">Please enter your password to confirm:</label>
             <input type="password" id="confirm-password" name="confirm-password" required autocomplete="new-password">
             <p id="password-modal-error" style="color: red; min-height: 1em; margin-top: 5px;"></p>
             <div class="modal-buttons">
                 <button type="button" onclick="cancelModalAction()" class="blue-button cancel-button">Cancel</button>
                 <button type="button" onclick="handleModalConfirm()" class="blue-button">Confirm</button>
             </div>
         </div>
    </div>

    <script>
    /* jshint esversion: 11, browser: true */ // Add JSHint directives
// --- Start of Merged JavaScript (Part 1) ---
console.log("DEBUG: Merged Script execution started. (Tools + iBusDest Features)");

// --- Constants ---
// --- Add this near the top with other constants ---
const PERMISSIONS_LIST = [
    { key: 'canManageCurtailments', label: 'Manage Curtailments (Add/Delete)' },
    { key: 'canManageFleet', label: 'Manage Fleet/TMP Assignments' },
    { key: 'canManageOverrides', label: 'Manage Temp Overrides' },
    { key: 'canManageSeqHeadings', label: 'Manage Sequence Headings' },
    { key: 'canManageFinalDests', label: 'Manage Final Destinations' },
    { key: 'canManageUsers', label: 'Manage Users (Add/Edit/Suspend/Delete)' },
    { key: 'canManageSettings', label: 'Manage Global Settings' },
    { key: 'canBackupRestore', label: 'Perform Backup/Restore' },
    { key: 'canViewAuditLog', label: 'View Audit Log' }
];
const usersStorageKey = 'liveTrackerUsers';
const tmpMapKey = "tmpRegistrationMap";
const settingsKey = "trackerGlobalSettings";
const defaultSettings = {
    debounceMinutes: 60, // From tools.html
    timeoutMinutes: 30,  // From tools.html
    autoLogoutMinutes: 30 // Common default
};
const lastExportKey = 'lastCurtailmentExportTimestamp'; // From tools.html
const tmpGenerationInfoKey = "tmpGenerationInfo"; // From tools.html
const sequenceHeadingOverrideBaseKey = 'sequenceHeadingOverrides_'; // From ibusdest.html
const routeDestinationSettingsKey = 'routeDestinationSettings'; // From ibusdest.html & tools.html
const destinationOverrideKey = 'destinationOverrides'; // From ibusdest.html (For Temp Overrides)
const auditLogKey = 'actionAuditLog'; // From tools.html
const MAX_AUDIT_LOG_ENTRIES = 500; // From tools.html
const lastCurtailmentPruneTimestampKey = 'lastCurtailmentPruneTimestamp'; // From tools.html

// --- Global Variables ---
let users = {};
let isLoggedIn = false;
let currentUsername = null;
let sessionTimerId = null;
let currentAutoTmpData = []; // For Auto TMP table filtering (tools.html)
let currentModalAction = null; // For password modal (tools.html)
let currentFinalDestFilter = 'all'; // For Final Destination editor filter state (ibusdest.html)

// --- Add this new helper function ---

/**
 * Checks if the currently logged-in user has a specific permission.
 * Admins are assumed to have all permissions.
 * @param {string} permissionKey - The key of the permission to check (e.g., 'canManageFleet').
 * @returns {boolean} True if the user has the permission, false otherwise.
 */
function hasPermission(permissionKey) {
    // Ensure user is logged in and data exists
    if (!isLoggedIn || !currentUsername || !users || !users[currentUsername]) {
        // console.warn(`hasPermission check failed: User not logged in or data missing.`);
        return false;
    }

    const userData = users[currentUsername];

    // Admins always have permission
    if (userData.role === 'admin') {
        // console.log(`hasPermission check for '${permissionKey}': Granted (Admin role).`);
        return true;
    }

// --- Add these three new functions ---

/**
 * Opens the modal for setting a new password for a specific user.
 * @param {string} username - The username of the user to modify.
 */
function openSetPasswordModal(username) {
    console.log(`DEBUG: openSetPasswordModal called for user: ${username}`);
    // Permission Check (redundant if button is disabled, but good practice)
    if (!hasPermission('canManageUsers')) {
        alert('Permission Denied: Cannot set user passwords.');
        return;
    }
    if (username === 'Ryan') { // Prevent changing default admin password this way
        alert("Cannot change password for the default admin user via this interface.");
        return;
    }

    const modal = getElement('set-password-modal');
    const title = getElement('set-password-modal-title');
    const usernameInput = getElement('set-password-username'); // Hidden input
    const newPassInput = getElement('set-new-password');
    const confirmPassInput = getElement('set-confirm-password');
    const errorMsg = getElement('set-password-modal-error');

    if (!modal || !title || !usernameInput || !newPassInput || !confirmPassInput || !errorMsg) {
        console.error("DEBUG: Set password modal elements missing.");
        alert("UI Error: Cannot open password dialog.");
        return;
    }

    // Store the username we are editing in the hidden input
    usernameInput.value = username;

    // Reset modal state before showing
    title.textContent = `Set New Password for ${username}`;
    newPassInput.value = '';
    confirmPassInput.value = '';
    errorMsg.textContent = '';

    // Show the modal
    modal.classList.remove('hidden');
    newPassInput.focus(); // Focus on the new password field for convenience
}

/**
 * Hides the set password modal and clears its fields.
 */
function hideSetPasswordModal() {
    const modal = getElement('set-password-modal');
    if (modal) {
        modal.classList.add('hidden');
    }
    // Clear fields when hiding for security/cleanup
    const usernameInput = getElement('set-password-username');
    const newPassInput = getElement('set-new-password');
    const confirmPassInput = getElement('set-confirm-password');
    const errorMsg = getElement('set-password-modal-error');
    if(usernameInput) usernameInput.value = '';
    if(newPassInput) newPassInput.value = '';
    if(confirmPassInput) confirmPassInput.value = '';
    if(errorMsg) errorMsg.textContent = '';
    console.log("DEBUG: Set password modal hidden.");
}

/**
 * Handles the confirmation action when setting a password from the modal.
 * Validates input and updates the user's password if valid.
 */
function confirmSetPassword() {
    console.log("DEBUG: confirmSetPassword called.");
    // Get references to modal elements and the main status message area
    const usernameInput = getElement('set-password-username');
    const newPassInput = getElement('set-new-password');
    const confirmPassInput = getElement('set-confirm-password');
    const errorMsg = getElement('set-password-modal-error'); // Error message inside the modal
    const userMsg = getElement('user-management-message'); // Main status message on the settings page

    // Ensure all elements are present
    if (!usernameInput || !newPassInput || !confirmPassInput || !errorMsg || !userMsg) {
        console.error("DEBUG: Confirm set password elements missing.");
        alert("UI Error: Cannot confirm password change.");
        return;
    }

    const username = usernameInput.value; // Get username from hidden input
    const newPass = newPassInput.value;
    const confirmPass = confirmPassInput.value;
    errorMsg.textContent = ''; // Clear previous modal errors

    // --- Input Validation ---
    if (!username) {
        errorMsg.textContent = "Error: Target username missing.";
        console.error("DEBUG: Target username missing in confirmSetPassword.");
        return;
    }
    if (!users[username]) { // Check if user still exists
        errorMsg.textContent = `Error: User ${username} not found.`;
        console.error(`DEBUG: User ${username} not found during password set confirmation.`);
        return;
    }
    if (!newPass) {
        errorMsg.textContent = "New password cannot be empty.";
        newPassInput.focus();
        return;
    }
    if (newPass.length < 6) { // Enforce minimum length
        errorMsg.textContent = "Password must be at least 6 characters.";
        newPassInput.focus();
        return;
    }
    if (newPass !== confirmPass) { // Check if passwords match
        errorMsg.textContent = "Passwords do not match.";
        confirmPassInput.focus();
        return;
    }
    // --- End Validation ---

    // Update user object in memory
    console.log(`DEBUG: Setting new password for ${username}`);
    users[username].pass = newPass;
    saveUsersToStorage(); // Save the updated users object to localStorage
    logAdminAction("User Password Set", { targetUser: username }); // Log the action

    // Provide feedback on the main page and close the modal
    userMsg.textContent = `Password for ${username} updated successfully.`;
    userMsg.style.color = 'green';
    setTimeout(() => { if(userMsg) userMsg.textContent = ''; }, 4000); // Clear message after delay

    hideSetPasswordModal(); // Close the modal
}

// --- IMPORTANT: Delete the old changeOtherUserPassword function ---
// Find and remove the entire function definition for changeOtherUserPassword(username)

    // Check specific permission for non-admins
    // Ensure permissions object exists and the key is explicitly true
    const permissionValue = userData.permissions && userData.permissions[permissionKey];
    const granted = permissionValue === true; // Strict check for true

    // console.log(`hasPermission check for '${permissionKey}': Role=${userData.role}, Value=${permissionValue}, Granted=${granted}`);
    return granted;
}

// --- Storage Helpers (from tools.html) ---
function loadFromStorage(key, defaultValue = {}) {
    // console.log(`DEBUG: loadFromStorage called for key: ${key}`);
    try {
        const data = localStorage.getItem(key);
        if (data) {
            const parsed = JSON.parse(data);
            if (key === auditLogKey && !Array.isArray(parsed)) { console.warn(`Audit log data for key ${key} is not an array...`); return defaultValue; }
            // Improved type checking
            if ((typeof parsed === typeof defaultValue && parsed !== null) || (Array.isArray(parsed) && Array.isArray(defaultValue)) || (defaultValue === null && parsed === null)) {
                return parsed;
            } else {
                console.warn(`DEBUG: Data type mismatch or unexpected null for key ${key}. Expected type similar to default (${typeof defaultValue}), got ${typeof parsed}. Returning default.`);
                return defaultValue;
            }
        }
        return defaultValue;
    } catch (e) {
        console.error(`DEBUG: Error loading ${key}:`, e);
        // Specific handling for audit log which expects an array
        if (key === auditLogKey && Array.isArray(defaultValue)) { return []; }
        return defaultValue;
    }
}
function saveToStorage(key, data) {
    // console.log(`DEBUG: saveToStorage called for key: ${key}`);
    try {
        const stringifiedData = JSON.stringify(data);
        localStorage.setItem(key, stringifiedData);
    } catch (e) {
        console.error(`DEBUG: Error saving ${key}:`, e);
        // Avoid alerting for audit log errors
        if (key !== auditLogKey) {
            alert(`Error saving data for ${key}. Data might be lost or storage might be full.`);
        } else {
             console.error("Could not save audit log entry.");
        }
    }
}
function saveUsersToStorage() { // Specific user saving function
    console.log("DEBUG: saveUsersToStorage function called.");
    try {
        if (typeof users === 'object' && users !== null) {
            localStorage.setItem(usersStorageKey, JSON.stringify(users));
        } else {
            console.error("DEBUG: Attempted to save non-object as users. Resetting to default.");
            setDefaultUsers(); // Fallback to ensure valid structure
        }
    } catch (e) {
        console.error("DEBUG: Error saving users:", e);
        alert("Error: Could not save user data.");
    }
}

// --- Audit Log Function (from tools.html) ---
function logAdminAction(action, details = {}) {
    console.log(`DEBUG: logAdminAction called - Action: ${action}, User: ${currentUsername}, LoggedIn: ${isLoggedIn}`);
    let effectiveUsername = currentUsername;
    let isActionAllowedWhenLoggedOut = ['Login Failed (Password)', 'Login Failed (Suspended)', 'Login Failed (Unknown User)'].includes(action);

    // Check if user is logged in, allow specific actions if logged out
    if (!isLoggedIn && !isActionAllowedWhenLoggedOut) {
        console.warn(`DEBUG: logAdminAction - Skipping log for action '${action}' because user is not logged in.`);
        return;
    }
    // Determine username for failed login attempts
    if (!isLoggedIn && isActionAllowedWhenLoggedOut) {
        effectiveUsername = currentUsername || details?.targetUser || 'Unknown'; // Attempt to get target user if available
        console.warn(`DEBUG: logAdminAction - Logging failed login attempt for user: ${effectiveUsername}`);
    }
    // Ensure we have a username to log against
    if (!effectiveUsername) {
        console.warn(`DEBUG: logAdminAction - Skipping log for action '${action}' because effective username could not be determined.`);
        return;
    }

    const userRole = users[effectiveUsername]?.role || 'N/A';
    // Define actions that don't necessarily require privileges or occur during login/logout
    const alwaysLogActions = ['Login Success', 'Login Failed (Password)', 'Login Failed (Suspended)', 'Login Failed (Unknown User)', 'Logout'];
    const requiresPrivilege = !alwaysLogActions.includes(action);

    // Check if the action requires privileges and if the user has them
    if (requiresPrivilege && !['admin', 'moderator'].includes(userRole)) {
        // Allow specific actions by standard users if needed in the future
        const allowedNonPrivilegedActions = ['Curtailment Added', 'Fleet Assigned']; // Example - currently these check role internally too
        if (!allowedNonPrivilegedActions.includes(action)) {
             console.warn(`DEBUG: logAdminAction - Skipping log for action '${action}' by user '${effectiveUsername}' due to insufficient role ('${userRole}').`);
             return;
         }
    }

    // Proceed with logging
    try {
        const timestamp = Date.now();
        const logEntry = {
            timestamp,
            user: effectiveUsername,
            action,
            details: typeof details === 'string' ? { message: details } : details // Ensure details is an object
        };

        let log = loadFromStorage(auditLogKey, []);
        if (!Array.isArray(log)) {
            console.warn("Audit log retrieved from storage was not an array. Resetting log.");
            log = [];
        }

        log.unshift(logEntry); // Add new entry to the beginning
        if (log.length > MAX_AUDIT_LOG_ENTRIES) {
            log = log.slice(0, MAX_AUDIT_LOG_ENTRIES); // Limit log size
        }

        saveToStorage(auditLogKey, log);
        console.log(`AUDIT: User '${logEntry.user}' - Action: '${action}'`, details);
    } catch (error) {
        console.error("Error writing audit log:", error);
    }
}

// --- ADD THIS HELPER FUNCTION ---
// (Place it near other helpers like getElement, loadFromStorage, etc.)

function escapeHtml(unsafe) {
    // Handle null or undefined input gracefully
    if (unsafe === null || typeof unsafe === 'undefined') {
        return ''; // Return an empty string
    }
    // Ensure the input is treated as a string before replacing
    const str = String(unsafe);
    // Perform HTML escaping
    return str.replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&#039;");
}
// --- END of escapeHtml function ---

// --- DOM Element Refs (Merged List) ---
console.log("DEBUG: Getting Combined DOM refs");
function getElement(id) { return document.getElementById(id); }

// Auth & Main Containers
const loginContainer = getElement('login-container');
const appContainer = getElement('app-container');
const loginError = getElement('login-error');
const welcomeMessageElement = getElement('welcome-message');
const logoutButton = getElement('logout-button');
const exportReminderDiv = getElement('export-reminder'); // tools
const accessDeniedMessageDiv = getElement('access-denied-message'); // Merged - For ibusdest access check

// Navigation
const mainActionsContainer = getElement('main-actions-container');
const goBackButton = getElement('go-back-button');

// --- Section Containers (Tools Original) ---
const addCurtailmentForm = getElement('add-curtailment-form');
const manualFleetForm = getElement('manual-fleet-form');
const settingsForm = getElement('settings-form');
const dataActionsSection = getElement('data-actions');
const manageCurtailmentsSection = getElement('manage-curtailments-section');
const viewAutoTmpSection = getElement('view-auto-tmp-section');

// --- Section Containers (Merged from iBusDest) ---
const tempOverridesSection = getElement('temp-overrides-section');
const sequenceHeadingSection = getElement('sequence-heading-section');
const finalDestinationsSection = getElement('final-destinations-section');

// --- Main Action Buttons (Tools Original) ---
const toggleAddCurtailmentButton = getElement('toggle-add-curtailment');
const toggleManualFleetButton = getElement('toggle-manual-fleet');
const viewAllCurtailmentsButton = getElement('view-all-curtailments-btn');
const toggleBackupRestoreButton = getElement('toggle-backup-restore');
const toggleSettingsButton = getElement('toggle-settings');

// --- Main Action Buttons (Merged from iBusDest) ---
const toggleTempOverridesButton = getElement('toggle-temp-overrides');
const toggleSequenceHeadingsButton = getElement('toggle-sequence-headings');
const toggleFinalDestinationsButton = getElement('toggle-final-destinations');

// --- Add Curtailment Elements (Tools Original) ---
const addCurtailmentMessage = getElement('add-curtailment-message');
const routeInput = getElement('route');
const regNumberInput = getElement('regNumber');
const curtailedDestinationInput = getElement('curtailedDestination');
const curtailmentTimeInput = getElement('curtailmentTimeInput');

// --- Manual Fleet Elements (Tools Original) ---
const manualRegNumberInput = getElement('manualRegNumber');
const manualFleetNumberInput = getElement('manualFleetNumber');
const assignStatusElement = getElement('assign-status');
const manualAssignmentsDisplay = getElement('manual-assignments-display');
const revertRegNumberInput = getElement('revertRegNumber');
const revertStatusElement = getElement('revert-status');
const revertSection = document.querySelector('#manual-fleet-form .revert-section'); // Assuming unique within this section
const resetTmpButton = getElement('reset-tmp-button');
const resetAllSection = document.querySelector('#manual-fleet-form .reset-all-section'); // Assuming unique
const viewAutoTmpBtn = getElement('view-auto-tmp-btn');
const manualRegFilterInput = getElement('manual-reg-filter');
const manualFleetFilterInput = getElement('manual-fleet-filter');

// --- Manage Curtailments Elements (Tools Original) ---
const manageCurtailmentsTableBody = getElement('manage-curtailments-tbody');
const selectAllCheckbox = getElement('select-all-curtailments-checkbox');
const deleteSelectedButton = getElement('delete-selected-curtailments-btn');
const manageCurtailmentsMessage = getElement('manage-curtailments-message');
const deleteSelectedContainer = document.querySelector('.delete-selected-container'); // Assuming unique

// --- Auto TMP Table Elements (Tools Original) ---
const autoTmpTableBody = getElement('auto-tmp-tbody');
const autoTmpTableMessage = getElement('auto-tmp-table-message');
const autoTmpFilterRoute = getElement('auto-tmp-filter-route');
const autoTmpFilterFleet = getElement('auto-tmp-filter-fleet');
const autoTmpFilterReg = getElement('auto-tmp-filter-reg');
const autoTmpFilterDate = getElement('auto-tmp-filter-date');

// --- Backup/Restore Elements (Tools Original) ---
const exportAllDataButton = getElement('export-all-data-button');
const exportAllStatus = getElement('export-all-status');
const importCurtailmentsInput = getElement('import-file-curtailments');
const curtailmentsBackupStatus = getElement('curtailments-backup-status');
const importTmpInput = getElement('import-file-tmp');
const tmpBackupStatus = getElement('tmp-backup-status');
const importSeqHeadingsInput = getElement('import-file-seq-headings'); // Now potentially used by both original and merged import logic
const seqHeadingsBackupStatus = getElement('seq-headings-backup-status');
const importFinalDestInput = getElement('import-file-final-dest'); // Now potentially used by both original and merged import logic
const finalDestBackupStatus = getElement('final-dest-backup-status');
const pruneCurtailmentsButton = getElement('prune-curtailments-button');
const pruneStatusMessage = getElement('prune-status-message');
const pruneDescriptionText = getElement('prune-description-text');

// --- Settings Elements (Tools Original) ---
const changeMyPasswordSection = getElement('change-my-password-section');
const trackerSettingsSection = getElement('tracker-settings-section');
const adminUserManagementSection = getElement('admin-user-management');
const adminAuditLogSection = getElement('admin-audit-log');
const settingsDebounceInput = getElement('setting-debounce');
const settingsTimeoutInput = getElement('setting-timeout');
const settingsAutoLogoutInput = getElement('setting-auto-logout');
const trackerSettingsMessage = getElement('tracker-settings-message');
const currentPasswordInput = getElement('current-password');
const newPasswordInput = getElement('new-password');
const confirmNewPasswordInput = getElement('confirm-new-password');
const changePasswordMessage = getElement('change-password-message');
const addUsernameInput = getElement('add-username');
const addUserPasswordInput = getElement('add-user-password');
const addUserRoleSelect = getElement('add-user-role');
const addUserMessage = getElement('add-user-message');
const userManagementTbody = getElement('user-management-tbody');
const userManagementMessage = getElement('user-management-message');
const auditLogDisplay = getElement('audit-log-display');
const auditLogMessage = getElement('audit-log-message');
const clearAuditLogButton = getElement('clear-audit-log-btn');

// --- Modals (Tools Original - only password modal kept) ---
const passwordModal = getElement('password-modal');
const passwordModalInput = getElement('confirm-password');
const passwordModalError = getElement('password-modal-error');
const passwordModalPrompt = getElement('password-modal-prompt');

// --- Temporary Override Elements (Merged from iBusDest) ---
const regInput = getElement('override-reg'); // Note: Potentially confusing name clash with regNumberInput from Add Curtailment - check usage
const specificDestDir1Input = getElement('override-dest-dir1');
const specificDestDir2Input = getElement('override-dest-dir2');
const specificStatusMsg = getElement('specific-status');
const routeIdInput = getElement('route-override-id'); // Note: Potentially confusing name clash with routeInput from Add Curtailment - check usage
const routeDestDir1Input = getElement('route-override-dest-dir1');
const routeDestDir2Input = getElement('route-override-dest-dir2');
const routeStatusMsg = getElement('route-status');
const globalDestInput = getElement('global-override-dest');
const globalStatusMsg = getElement('global-status');
const overridesListDiv = getElement('overrides-list');
const filterInput = getElement('filter-overrides'); // Filter for temp overrides list

// --- Sequence Heading Elements (Merged from iBusDest) ---
const seqHeadingRouteIdInput = getElement('seq-heading-route-id');
const seqHeadingOutboundInput = getElement('seq-heading-outbound');
const seqHeadingInboundInput = getElement('seq-heading-inbound');
const seqHeadingStatusMsg = getElement('seq-heading-status');
const activeHeadingsListDiv = getElement('active-sequence-headings-list');
const removeSelectedHeadingsBtn = getElement('remove-selected-headings-btn');
const removeHeadingsStatusMsg = getElement('remove-headings-status');

// --- Final Destination Elements (Merged from iBusDest) ---
const addDestRouteInput = getElement('add-dest-route');
const destFilterInput = getElement('dest-filter-input'); // Filter for final destinations editor
const destEditorRoutesContainer = getElement('dest-editor-routes');
const destEditorMessage = getElement('dest-editor-message');
const destFilterButtons = document.querySelectorAll('.dest-filter-buttons button'); // NodeList
const bulkDestInput = getElement('bulk-dest-input');
const bulkDestStatus = getElement('bulk-dest-status');
const saveDestButton = getElement('save-dest-button');
const processBulkDestButton = getElement('process-bulk-dest-button');

console.log("DEBUG: Combined DOM refs obtained.");


// --- Auth, Timer, Basic UI (from tools.html, handles roles/suspension) ---
function loadUsers() {
    console.log("DEBUG: loadUsers function called.");
    try {
        const storedData = localStorage.getItem(usersStorageKey);
        if (storedData) {
            let parsedUsers = JSON.parse(storedData);
            if (typeof parsedUsers !== 'object' || parsedUsers === null || Array.isArray(parsedUsers)) {
                console.warn("DEBUG: Invalid user data structure in localStorage. Resetting to default.");
                setDefaultUsers(); return;
            }
            if (!parsedUsers.Ryan?.pass || !parsedUsers.Ryan?.role) {
                console.warn("DEBUG: Resetting users: Incomplete default admin user 'Ryan'.");
                setDefaultUsers(); return;
            }
            let structureUpdated = false;
            Object.keys(parsedUsers).forEach(username => {
                const userData = parsedUsers[username];
                if (typeof userData !== 'object' || userData === null) {
                    console.warn(`DEBUG: Removing invalid user entry for key: ${username}`);
                    delete parsedUsers[username]; structureUpdated = true;
                } else {
                    // Ensure structure consistency (add defaults if missing)
                    if (userData.permissions === undefined) { userData.permissions = {}; structureUpdated = true; }
                    if (userData.isSuspended === undefined) { userData.isSuspended = false; structureUpdated = true; }
                    if (typeof userData.pass !== 'string' || typeof userData.role !== 'string') {
                        console.warn(`DEBUG: User data for '${username}' is missing pass or role. Keeping entry but potential issue.`);
                    }
                }
            });
            users = parsedUsers;
            if (structureUpdated) {
                console.log("DEBUG: Saving updated user structure after validation.");
                saveUsersToStorage();
            }
        } else {
            console.log("DEBUG: loadUsers - No user data found in localStorage, setting defaults.");
            setDefaultUsers();
        }
    } catch (e) {
        console.error("DEBUG: Error loading or parsing users:", e);
        console.log("DEBUG: Resetting to default users due to error.");
        setDefaultUsers();
    }
    console.log("DEBUG: loadUsers finished.");
}
function setDefaultUsers() {
    console.log("DEBUG: setDefaultUsers called.");
    users = { 'Ryan': { pass: 'password', role: 'admin', permissions: {}, isSuspended: false } };
    saveUsersToStorage();
    console.log("DEBUG: Default users set and saved.");
}
function checkLogin() {
    console.log("DEBUG: --- checkLogin ---");
    loadUsers(); // Ensure users are loaded
    try {
        const storedUser = localStorage.getItem('loggedInUser');
        const storedLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
        let isLoginStateValid = false;

        if (storedLoggedIn && storedUser && users && users[storedUser]) {
            if (!users[storedUser].isSuspended) {
                isLoginStateValid = true;
                console.log(`DEBUG: Valid persistent login found for user: ${storedUser}`);
            } else {
                console.log(`DEBUG: Persistent login found for suspended user: ${storedUser}. Invalidating session.`);
            }
        } else {
            console.log(`DEBUG: No valid persistent login state found. StoredUser: ${storedUser}, StoredLoggedIn: ${storedLoggedIn}`);
        }

        if (isLoginStateValid) {
            isLoggedIn = true; currentUsername = storedUser;
            showApp(); // Proceed to show the main application view
        } else {
            // Clear invalid/old login state
            console.log("DEBUG: Clearing potentially invalid login state from storage.");
            isLoggedIn = false; currentUsername = null;
            localStorage.removeItem('isLoggedIn'); localStorage.removeItem('loggedInUser');
            sessionStorage.removeItem('bypassAutoLogout'); // Also clear session flag
            showLogin(); // Show the login screen
        }
    } catch (e) {
        // Catch errors during login check process
        console.error("DEBUG: Error during checkLogin:", e);
        isLoggedIn = false; currentUsername = null;
        // Attempt to clear storage even on error
        localStorage.removeItem('isLoggedIn'); localStorage.removeItem('loggedInUser');
        sessionStorage.removeItem('bypassAutoLogout');
        showLogin(); // Show login screen as fallback
    }
    console.log("DEBUG: --- checkLogin finished ---");
}
function login() {
    console.log("DEBUG: --- login ---");
    const usernameInputEl = getElement('username');
    const passwordInputEl = getElement('password');
    const stayLoggedInCheckbox = getElement('stayLoggedInCheckbox');
    const loginErrorEl = getElement('login-error');

    // Basic validation of elements
    if (!usernameInputEl || !passwordInputEl || !stayLoggedInCheckbox || !loginErrorEl) {
        console.error("DEBUG: Login form elements missing.");
        if (loginErrorEl) loginErrorEl.textContent = 'Login UI error.'; return;
    }

    const usernameInput = usernameInputEl.value.trim();
    const passwordInput = passwordInputEl.value; // Don't trim password
    const stayLoggedIn = stayLoggedInCheckbox.checked;

    loginErrorEl.textContent = ''; // Clear previous errors

    // Ensure users are loaded
    if (Object.keys(users).length === 0) {
        console.log("DEBUG: Users object empty, attempting reload.");
        loadUsers();
        if (Object.keys(users).length === 0) {
            loginErrorEl.textContent = 'Login service unavailable. Cannot load users.';
            console.error("DEBUG: Cannot login, users object still empty after reload."); return;
        }
    }

    // Check if user exists
    if (!Object.prototype.hasOwnProperty.call(users, usernameInput)) {
        loginErrorEl.textContent = 'Invalid username or password.';
        const tempUsernameForLog = usernameInput || 'Empty Username'; // Avoid logging null/empty directly
        logAdminAction("Login Failed (Unknown User)", { targetUser: tempUsernameForLog });
        isLoggedIn = false; currentUsername = null; return;
    }

    const userData = users[usernameInput];

    // Check password
    if (userData.pass === passwordInput) {
        // Check suspension status
        if (userData.isSuspended) {
            loginErrorEl.textContent = 'Account suspended. Please contact an administrator.';
            logAdminAction("Login Failed (Suspended)", { targetUser: usernameInput });
            isLoggedIn = false; currentUsername = null; return;
        }

        // Login successful
        console.log(`DEBUG: Login successful for user: ${usernameInput}`);
        isLoggedIn = true; currentUsername = usernameInput;
        logAdminAction("Login Success");

        // Set persistent login state in localStorage
        localStorage.setItem('isLoggedIn', 'true'); localStorage.setItem('loggedInUser', usernameInput);

        // Handle "Stay logged in" - affects session timer
        if (stayLoggedIn) {
            console.log("DEBUG: Setting bypassAutoLogout flag in sessionStorage.");
            sessionStorage.setItem('bypassAutoLogout', 'true');
        } else {
            console.log("DEBUG: Removing bypassAutoLogout flag from sessionStorage.");
            sessionStorage.removeItem('bypassAutoLogout');
        }

        showApp(); // Show the main application

    } else {
        // Incorrect password
        loginErrorEl.textContent = 'Invalid username or password.';
        logAdminAction("Login Failed (Password)", { targetUser: usernameInput });
        isLoggedIn = false; currentUsername = null;
        // Ensure bypass flag is removed on failed attempt
        sessionStorage.removeItem('bypassAutoLogout');
    }
    console.log("DEBUG: --- login finished ---");
}
function logout() {
    console.log("DEBUG: --- logout ---");
    if (isLoggedIn && currentUsername) { logAdminAction("Logout"); }
    else { console.log("DEBUG: Logout called but user was not logged in."); }

    if (sessionTimerId) { clearTimeout(sessionTimerId); sessionTimerId = null; console.log("DEBUG: Session timer cleared."); }

    localStorage.setItem('isLoggedIn', 'false'); localStorage.removeItem('loggedInUser');
    isLoggedIn = false; currentUsername = null;
    sessionStorage.removeItem('bypassAutoLogout'); // Clear session bypass on logout

    console.log("DEBUG: Cleared login state from storage and globals.");
    showLogin(); // Show login screen
    console.log("DEBUG: --- logout finished ---");
}
function logoutAfterSession() {
    console.log("DEBUG: --- logoutAfterSession Timer Fired ---");
    if (isLoggedIn) {
        const settings = loadFromStorage(settingsKey, defaultSettings);
        const logoutMinutes = settings.autoLogoutMinutes || defaultSettings.autoLogoutMinutes;
        alert(`Session expired due to inactivity after ${logoutMinutes} minutes. Please log in again.`);
        console.log(`DEBUG: Logging out due to session timeout (${logoutMinutes} min).`);
        logout();
    } else { console.log("DEBUG: Session timer fired, but user already logged out."); }
}
function startSessionTimer() {
    if (sessionTimerId) { clearTimeout(sessionTimerId); sessionTimerId = null; console.log("DEBUG: Cleared existing session timer."); }
    if (!isLoggedIn) { console.log("DEBUG: User not logged in, session timer not started."); return; }

    const bypassAutoLogout = sessionStorage.getItem('bypassAutoLogout') === 'true';
    if (bypassAutoLogout) { console.log("DEBUG: 'Stay logged in' is active, session timer bypassed."); return; }

    const settings = loadFromStorage(settingsKey, defaultSettings);
    let logoutMinutes = defaultSettings.autoLogoutMinutes; // Start with default
    // Use saved setting if valid number >= 0
    if (typeof settings.autoLogoutMinutes === 'number' && settings.autoLogoutMinutes >= 0) {
        logoutMinutes = settings.autoLogoutMinutes;
    } else { console.warn(`DEBUG: Invalid autoLogoutMinutes setting (${settings.autoLogoutMinutes}). Using default: ${logoutMinutes}`); }

    if (logoutMinutes <= 0) { console.log("DEBUG: Auto logout is disabled (duration <= 0). Timer not started."); return; }

    const logoutMilliseconds = logoutMinutes * 60 * 1000;
    console.log(`DEBUG: Starting session timer for ${logoutMinutes} minutes (${logoutMilliseconds} ms).`);
    sessionTimerId = setTimeout(logoutAfterSession, logoutMilliseconds);
}

// --- SPA Navigation & UI State (Merged & Updated) ---
function showApp() {
    console.log("DEBUG: --- showApp ---");
    try {
        // Initial login/suspension check (unchanged)
        if (!isLoggedIn || !currentUsername || !users || !users[currentUsername] || users[currentUsername].isSuspended) {
            console.warn("DEBUG: showApp called but login state is invalid or user suspended. Forcing logout.");
            logout(); return;
        }

        // Hide login, show app (unchanged)
        if (loginContainer) loginContainer.classList.add('hidden');
        if (accessDeniedMessageDiv) accessDeniedMessageDiv.classList.add('hidden');
        if (appContainer) appContainer.classList.remove('hidden');

        // Welcome message (unchanged)
        if (welcomeMessageElement) { welcomeMessageElement.textContent = `Welcome, ${currentUsername}!`; }

        // Export Reminder logic (unchanged)
        if (exportReminderDiv) { /* ... existing reminder logic ... */ }

        // Reset view state
        goBackToMainView(false);

        // *** UPDATED: Show/Hide Main Menu Buttons Based on Permissions ***
        if (mainActionsContainer) {
            const mainButtons = mainActionsContainer.querySelectorAll('button'); // Get all buttons
            mainButtons.forEach(button => {
                const requiredPermission = button.dataset.permission; // Get permission key from data-permission attribute
                if (requiredPermission) {
                    // Hide button if user does NOT have the required permission
                    button.classList.toggle('hidden', !hasPermission(requiredPermission));
                    console.log(`DEBUG: Button ${button.id || button.textContent.slice(0,10)} - ReqPerm: ${requiredPermission}, HasPerm: ${hasPermission(requiredPermission)}, Hidden: ${!hasPermission(requiredPermission)}`);
                } else {
                    // Handle buttons WITHOUT data-permission attribute
                    // Keep 'View All Curtailments' and 'Settings' always visible after login
                    if (button.id === 'view-all-curtailments-btn' || button.id === 'toggle-settings') {
                         button.classList.remove('hidden');
                    } else {
                         // Optionally hide other buttons without permission by default if necessary
                         // button.classList.add('hidden');
                    }
                }
            });

             // Optional Text Adjustment based on permissions
            if (viewAllCurtailmentsButton) {
                 viewAllCurtailmentsButton.textContent = hasPermission('canManageCurtailments') ? 'View / Manage Curtailments' : 'View All Curtailments';
            }

        } else {
            console.error("DEBUG: showApp - mainActionsContainer not found!");
        }
        // *** END UPDATED BUTTON LOGIC ***

        // Update enabled/disabled state AFTER visibility is set
        updateElementRoles(mainActionsContainer);

        startSessionTimer(); // Start inactivity timer (unchanged)

    } catch (e) {
        console.error("DEBUG: Critical error in showApp:", e);
        if (welcomeMessageElement) welcomeMessageElement.textContent = 'Application Error. Please reload.';
        if (!isLoggedIn) { logout(); }
    }
    console.log("DEBUG: --- showApp finished ---");
}
function showLogin(showAccessDenied = false) { // Added flag from ibusdest merge
    console.log(`DEBUG: --- showLogin (showAccessDenied: ${showAccessDenied}) ---`);
    try {
        if (sessionTimerId) { clearTimeout(sessionTimerId); sessionTimerId = null; console.log("DEBUG: Session timer cleared on showing login."); }
        sessionStorage.removeItem('bypassAutoLogout'); // Clear session flag

        if (loginContainer) loginContainer.classList.remove('hidden');
        if (appContainer) appContainer.classList.add('hidden');
        if (accessDeniedMessageDiv) { accessDeniedMessageDiv.classList.toggle('hidden', !showAccessDenied); }

        // Clear login form and error messages
        if (welcomeMessageElement) welcomeMessageElement.textContent = '';
        if (loginError) loginError.textContent = '';
        const usernameInputEl = getElement('username'); if(usernameInputEl) usernameInputEl.value = '';
        const passwordInputEl = getElement('password'); if(passwordInputEl) passwordInputEl.value = '';
        const stayLoggedInCheckbox = getElement('stayLoggedInCheckbox'); if(stayLoggedInCheckbox) stayLoggedInCheckbox.checked = false;

        // Hide password modal if it was somehow left open
        if (passwordModal) passwordModal.classList.add('hidden');
        // Hide export reminder
        if (exportReminderDiv) exportReminderDiv.style.display = 'none';

        // Ensure all app sections are hidden
        goBackToMainView(false);

    } catch (e) {
        console.error("DEBUG: Error during showLogin:", e);
        document.body.innerHTML = '<p style="color:red; padding: 20px;">Error loading login screen. Please refresh the page.</p>';
    }
    console.log("DEBUG: --- showLogin finished ---");
}
// --- Replace the existing updateElementRoles function with this version ---

/**
 * Updates the enabled/disabled state and tooltip titles of elements based on
 * the current user's role and specific permissions (using data-permission attribute).
 * @param {HTMLElement} container - The container element within which to update roles/permissions.
 */
function updateElementRoles(container) {
    if (!container) { console.warn("DEBUG: updateElementRoles - Container not found."); return;}
    if (!isLoggedIn || !currentUsername || !users[currentUsername]) { console.warn("DEBUG: updateElementRoles - Cannot update roles, user not logged in."); return; }

    const userData = users[currentUsername];
    const userRole = userData.role;
    const isAdmin = userRole === 'admin';
    const isModOrAdmin = isAdmin || userRole === 'moderator';
    // console.log(`DEBUG: updateElementRoles - Updating roles within container: ${container.id || container.tagName}, UserRole: ${userRole}`);

    // Find elements with data-role OR data-permission attribute *within the specified container*
    const elements = container.querySelectorAll('[data-role], [data-permission]');

    elements.forEach(el => {
        const requiredRole = el.dataset.role; // 'admin', 'mod-admin', 'admin-only' etc.
        const requiredPermission = el.dataset.permission; // e.g., 'canManageFleet'
        let hasRequiredAccess = false;
        let accessDeniedReason = "Access Denied."; // Default reason

        // *** PERMISSION CHECK LOGIC ***
        if (requiredPermission) {
            // 1. Check specific permission first if data-permission is set
            hasRequiredAccess = hasPermission(requiredPermission); // Use the new helper function
            if (!hasRequiredAccess) {
                 accessDeniedReason = `Required permission: ${requiredPermission}`;
            }
        } else if (requiredRole) {
            // 2. Fallback to role check if data-permission is not set but data-role is
            if ((requiredRole === 'admin' || requiredRole === 'admin-only') && isAdmin) {
                hasRequiredAccess = true;
            } else if (requiredRole === 'mod-admin' && isModOrAdmin) {
                hasRequiredAccess = true;
            } else if (!requiredRole) { // If data-role is empty, assume accessible
                 hasRequiredAccess = true;
            }
            if (!hasRequiredAccess) {
                 accessDeniedReason = `Required role: ${requiredRole}`;
            }
        } else {
             // 3. If neither attribute is set, assume accessible by default
             hasRequiredAccess = true;
        }
        // *** END PERMISSION CHECK LOGIC ***


        // Apply disabled state and title attributes to form elements
        if (['BUTTON', 'INPUT', 'TEXTAREA', 'SELECT'].includes(el.tagName)) {
            // Special handling for prune button - let its specific function handle combined logic
            if (el.id === 'prune-curtailments-button') {
                updatePruneButtonState(); // This handles role AND time logic
            } else {
                // Standard enable/disable based on access check
                el.disabled = !hasRequiredAccess;

                // Update title attribute to explain disabled state IF disabled
                if (!hasRequiredAccess) {
                    // Add reason to title only if it's not already there
                    if (el.title?.includes('Required ') === false) {
                        el.title = el.title ? `${el.title} (${accessDeniedReason})` : accessDeniedReason;
                    }
                } else {
                    // If access IS granted, remove role/permission-related part from title if present
                    if (el.title?.includes("Required ")) {
                        el.title = el.title.replace(/\s*\([^)]*Required [^)]*\)/g, '').trim();
                        if(el.title === "") el.removeAttribute('title'); // Remove title if empty
                    }
                }
            }
        } else if (el.tagName === 'FIELDSET' || el.tagName === 'DIV') {
            // Optionally hide entire divs/fieldsets based on access - currently only disabling controls *within* them
            // el.classList.toggle('hidden', !hasRequiredAccess);
        }
    });
    // console.log(`DEBUG: updateElementRoles - Finished updating roles within ${container.id || container.tagName}`);
}

function goBackToMainView(logAction = true) {
    if (logAction) { console.log("DEBUG: goBackToMainView called."); }

    // List ALL section variables here
    const allSections = [
        addCurtailmentForm, manualFleetForm, settingsForm, dataActionsSection,
        manageCurtailmentsSection, viewAutoTmpSection,
        tempOverridesSection, sequenceHeadingSection, finalDestinationsSection, // Merged sections
        goBackButton // Also hide the back button itself
    ];
    allSections.forEach(sec => { if (sec) sec.classList.add('hidden'); });

    if (mainActionsContainer) mainActionsContainer.classList.remove('hidden');

    // List ALL status message variables here
    const statusMessages = [
         addCurtailmentMessage, assignStatusElement, revertStatusElement,
         manageCurtailmentsMessage, autoTmpTableMessage,
         curtailmentsBackupStatus, tmpBackupStatus, seqHeadingsBackupStatus, finalDestBackupStatus, pruneStatusMessage, exportAllStatus,
         trackerSettingsMessage, changePasswordMessage, addUserMessage, userManagementMessage, auditLogMessage,
         specificStatusMsg, routeStatusMsg, globalStatusMsg, // Merged status messages
         seqHeadingStatusMsg, removeHeadingsStatusMsg, destEditorMessage, bulkDestStatus // Merged status messages
     ];
    statusMessages.forEach(el => { if (el) el.textContent = ''; });

    if (logAction) { console.log("DEBUG: Returned to main menu view."); }
}

// --- Curtailment Functions (from tools.html) ---
function addCurtailment() {
    // *** ADD Permission Check ***
    if (!hasPermission('canManageCurtailments')) {
        alert('Permission Denied: Cannot add curtailments.');
        console.warn(`DEBUG: addCurtailment denied for user '${currentUsername}'. Missing permission 'canManageCurtailments'.`);
        return;
    }
    // Element check
    if (!routeInput || !regNumberInput || !curtailedDestinationInput || !curtailmentTimeInput || !addCurtailmentMessage) { alert('Error: Could not find necessary form elements.'); console.error("DEBUG: addCurtailment missing required DOM elements."); return; }
    // Input values
    const route = routeInput.value.trim().toUpperCase(); const regNumber = regNumberInput.value.trim().toUpperCase();
    const destination = curtailedDestinationInput.value.trim(); const timeString = curtailmentTimeInput.value.trim();
    addCurtailmentMessage.textContent = ''; // Clear status

    // Validation
    if (!route || !regNumber || !destination || !timeString) { alert('Please fill in all fields: Route, Registration, Destination, and Time.'); addCurtailmentMessage.textContent = 'All fields are required.'; addCurtailmentMessage.style.color = 'red'; return; }

    // Time parsing
    let logDate = new Date(); const timeParts = timeString.match(/^(\d{2}):(\d{2})$/);
    if (timeParts) {
        const hours = parseInt(timeParts[1], 10); const minutes = parseInt(timeParts[2], 10);
        if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) { logDate.setHours(hours, minutes, 0, 0); }
        else { alert('Invalid Time.'); addCurtailmentMessage.textContent = 'Invalid time format.'; addCurtailmentMessage.style.color = 'red'; return; }
    } else { alert('Invalid Time Format.'); addCurtailmentMessage.textContent = 'Invalid time format (HH:MM).'; addCurtailmentMessage.style.color = 'red'; return; }

    const storageKey = `curtailedBusesArray_${route}`;
    const newEntry = { route: route, regNumber: regNumber, curtailedDestination: destination, curtailmentTime: logDate.toLocaleString('en-GB', {}), timestamp: logDate.getTime() };

    // Save logic
    try {
        let curtailments = loadFromStorage(storageKey, []); if (!Array.isArray(curtailments)) { console.warn(`DEBUG: Data for key ${storageKey} was not an array. Resetting.`); curtailments = []; }
        curtailments.push(newEntry); saveToStorage(storageKey, curtailments);

        logAdminAction("Curtailment Added", { route: route, reg: regNumber, dest: destination, time: newEntry.curtailmentTime });

        addCurtailmentMessage.textContent = `Curtailment for ${regNumber} on route ${route} added successfully!`; addCurtailmentMessage.style.color = 'green';
        // Clear inputs
        routeInput.value = ''; regNumberInput.value = ''; curtailedDestinationInput.value = ''; curtailmentTimeInput.value = ''; routeInput.focus();
        setTimeout(() => { if (addCurtailmentMessage) addCurtailmentMessage.textContent = ''; }, 3000);
    } catch (e) { console.error("DEBUG: Error saving curtailment:", e); alert('An error occurred while saving the curtailment.'); addCurtailmentMessage.textContent = 'Error saving curtailment.'; addCurtailmentMessage.style.color = 'red'; }
}
function populateManageCurtailmentsTable() {
    console.log("DEBUG: populateManageCurtailmentsTable called.");
    if (!isLoggedIn || !manageCurtailmentsTableBody) { console.warn("DEBUG: Cannot populate curtailments table - not logged in or table body missing."); if (manageCurtailmentsTableBody) manageCurtailmentsTableBody.innerHTML = '<tr><td colspan="6">Error: Table cannot be loaded.</td></tr>'; return; }
    manageCurtailmentsTableBody.innerHTML = '<tr><td colspan="6">Loading curtailment data...</td></tr>';
    if (manageCurtailmentsMessage) manageCurtailmentsMessage.textContent = '';

    setTimeout(() => { // Allow UI update before potentially long loop
        try {
            let allCurtailmentEntries = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith("curtailedBusesArray_")) {
                    const routeData = loadFromStorage(key, []);
                    if (Array.isArray(routeData)) {
                        routeData.forEach(item => {
                            if (item && typeof item === 'object' && item.regNumber) {
                                // Ensure timestamp is valid number, attempt parse if needed
                                if (typeof item.timestamp !== 'number' || item.timestamp <= 0) {
                                    try {
                                        if (item.curtailmentTime) { // Attempt to parse from old string format
                                            const parts = item.curtailmentTime.match(/(\d{2})\/(\d{2})\/(\d{4}),?\s*(\d{2}):(\d{2})/);
                                            item.timestamp = parts ? new Date(Date.UTC(parts[3], parts[2] - 1, parts[1], parts[4], parts[5])).getTime() : (Date.parse(item.curtailmentTime) || 0);
                                        } else { item.timestamp = 0; }
                                        if(isNaN(item.timestamp)) item.timestamp = 0; // Ensure it's a number or 0
                                    } catch (parseError) { console.warn(`Error parsing date for curtailment item:`, item, parseError); item.timestamp = 0; }
                                }
                                // Add only if timestamp is valid
                                if (typeof item.timestamp === 'number' && item.timestamp > 0) { allCurtailmentEntries.push({ ...item, originalKey: key }); }
                                else { console.warn("Skipping curtailment entry due to invalid/missing timestamp:", item); }
                            } else { console.warn("Skipping invalid curtailment entry:", item); }
                        });
                    } else { console.warn(`DEBUG: Data for key ${key} was not an array.`); }
                }
            }
            allCurtailmentEntries.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); // Sort newest first

            let tableHtml = ''; const canManage = ['admin', 'moderator'].includes(users[currentUsername]?.role);
            const escapeHtml = (unsafe) => { if (unsafe === null || typeof unsafe === 'undefined') return 'N/A'; return String(unsafe).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); };

            if (allCurtailmentEntries.length === 0) { tableHtml = '<tr><td colspan="6">No curtailments recorded.</td></tr>'; }
            else {
                allCurtailmentEntries.forEach(item => {
                    const displayTime = item.timestamp ? new Date(item.timestamp).toLocaleString('en-GB', {}) : 'Invalid Date';
                    let fleetNumber = 'N/A'; if (typeof getTMPForRegistration === 'function') { fleetNumber = getTMPForRegistration(item.regNumber); }
                    // Conditionally show checkbox based on role
                    const checkboxCell = canManage ? `<td><input type="checkbox" class="curtailment-checkbox" data-key="${escapeHtml(item.originalKey)}" data-timestamp="${item.timestamp}"></td>` : '<td></td>'; // Empty cell if not manager
                    tableHtml += `<tr>${checkboxCell}<td>${escapeHtml(item.route)}</td><td>${escapeHtml(fleetNumber)}</td><td>${escapeHtml(item.regNumber)}</td><td>${escapeHtml(item.curtailedDestination)}</td><td>${escapeHtml(displayTime)}</td></tr>`;
                });
            }
            manageCurtailmentsTableBody.innerHTML = tableHtml;

            // Show/hide management controls based on role and data presence
            const showManagementControls = canManage && allCurtailmentEntries.length > 0;
            if (selectAllCheckbox) { selectAllCheckbox.classList.toggle('hidden', !showManagementControls); selectAllCheckbox.checked = false; selectAllCheckbox.disabled = !showManagementControls; const headerCell = selectAllCheckbox.closest('th'); if (headerCell) headerCell.style.visibility = showManagementControls ? 'visible' : 'hidden'; }
            if (deleteSelectedButton) { deleteSelectedButton.classList.toggle('hidden', !showManagementControls); deleteSelectedButton.disabled = true; } // Start disabled until items selected
            if (deleteSelectedContainer) { deleteSelectedContainer.classList.toggle('hidden', !showManagementControls); }
            // Ensure checkbox cells visibility matches header
             manageCurtailmentsTableBody.querySelectorAll('tr td:first-child').forEach(td => { td.style.visibility = canManage ? 'visible' : 'hidden'; });
             // Add event listeners to enable/disable delete button
             if(canManage) {
                 manageCurtailmentsTableBody.querySelectorAll('.curtailment-checkbox').forEach(cb => {
                     cb.addEventListener('change', () => {
                         const anyChecked = manageCurtailmentsTableBody.querySelectorAll('.curtailment-checkbox:checked').length > 0;
                         if(deleteSelectedButton) deleteSelectedButton.disabled = !anyChecked;
                         if(selectAllCheckbox) selectAllCheckbox.checked = manageCurtailmentsTableBody.querySelectorAll('.curtailment-checkbox:not(:checked)').length === 0;
                     });
                 });
             }

        } catch (e) { console.error("DEBUG: Error populating curtailments table:", e); manageCurtailmentsTableBody.innerHTML = '<tr><td colspan="6" style="color:red;">Error loading curtailment data. Please try again.</td></tr>'; }
    }, 10);
}
function handleSelectAllCurtailments() {
     if (!selectAllCheckbox || !manageCurtailmentsTableBody) { console.warn("DEBUG: Cannot handle select all - checkbox or table body missing."); return; }
     const isChecked = selectAllCheckbox.checked; const checkboxes = manageCurtailmentsTableBody.querySelectorAll('.curtailment-checkbox'); checkboxes.forEach(cb => { if (!cb.disabled) { cb.checked = isChecked; } });
     if(deleteSelectedButton) deleteSelectedButton.disabled = !isChecked; // Enable/disable delete based on select all
     console.log(`DEBUG: Set all curtailment checkboxes to ${isChecked}.`);
}
// --- Modify deleteSelectedCurtailments ---
function deleteSelectedCurtailments() {
    // *** ADD Permission Check ***
    if (!hasPermission('canManageCurtailments')) {
        alert('Permission Denied: Cannot delete curtailments.');
        console.warn(`DEBUG: deleteSelectedCurtailments denied for user '${currentUsername}'. Missing permission 'canManageCurtailments'.`);
        return;
    }
    if (!manageCurtailmentsTableBody || !manageCurtailmentsMessage) { alert("Error: Cannot perform deletion - UI elements missing."); console.error("DEBUG: deleteSelectedCurtailments missing table body or message element."); return; }

    const selectedCheckboxes = manageCurtailmentsTableBody.querySelectorAll('.curtailment-checkbox:checked');
    if (selectedCheckboxes.length === 0) { alert("No curtailments selected for deletion."); return; }

    if (!confirm(`Are you sure you want to permanently delete the ${selectedCheckboxes.length} selected curtailment entries? This action cannot be undone.`)) { console.log("DEBUG: Deletion cancelled by user."); return; }

    manageCurtailmentsMessage.textContent = 'Deleting selected entries...'; manageCurtailmentsMessage.style.color = 'orange';
    let deletedCount = 0; let errorOccurred = false; const entriesToDelete = {}; // Group by storage key

    // Collect entries to delete, grouped by their original storage key
    selectedCheckboxes.forEach(cb => { const key = cb.dataset.key; const timestamp = parseInt(cb.dataset.timestamp, 10); if (key && !isNaN(timestamp)) { if (!entriesToDelete[key]) { entriesToDelete[key] = new Set(); } entriesToDelete[key].add(timestamp); } else { console.warn("DEBUG: Skipping checkbox with invalid data:", cb.dataset); errorOccurred = true; } });

    // Process deletions key by key
    try {
        for (const key in entriesToDelete) {
            if (Object.prototype.hasOwnProperty.call(entriesToDelete, key)) {
                const timestampsToDelete = entriesToDelete[key]; let data = loadFromStorage(key, []);
                if (!Array.isArray(data)) { console.error(`DEBUG: Data for key ${key} is not an array.`); errorOccurred = true; continue; } // Skip if data invalid

                const initialLength = data.length;
                // Filter out items whose timestamp is in the set to delete
                const updatedData = data.filter(item => !(typeof item.timestamp === 'number' && timestampsToDelete.has(item.timestamp)));
                const numDeletedForKey = initialLength - updatedData.length;

                if (numDeletedForKey > 0) {
                    if (updatedData.length === 0) {
                        // If all entries for this key are deleted, remove the key itself
                        console.log(`DEBUG: Removing empty storage key: ${key}`); localStorage.removeItem(key);
                    } else {
                        // Otherwise, save the filtered array back
                        saveToStorage(key, updatedData);
                    }
                    deletedCount += numDeletedForKey; console.log(`DEBUG: Deleted ${numDeletedForKey} entries from key ${key}.`);
                } else if (numDeletedForKey < 0) { console.error(`DEBUG: Negative deletion count for key ${key}, logic error?`); errorOccurred = true; }
            }
        }
        if (deletedCount > 0) { logAdminAction("Curtailments Deleted", { count: deletedCount }); }

        // Update status message
        if (errorOccurred) { manageCurtailmentsMessage.textContent = `Deletion completed with errors. ${deletedCount} entries removed. Check console log.`; manageCurtailmentsMessage.style.color = 'red'; }
        else { manageCurtailmentsMessage.textContent = `Successfully deleted ${deletedCount} curtailment(s).`; manageCurtailmentsMessage.style.color = 'green'; }

        populateManageCurtailmentsTable(); // Refresh table after deletion
    } catch (e) { console.error("DEBUG: Error during curtailment deletion process:", e); manageCurtailmentsMessage.textContent = 'An unexpected error occurred during deletion.'; manageCurtailmentsMessage.style.color = 'red'; errorOccurred = true; }
    finally { setTimeout(() => { if (manageCurtailmentsMessage) manageCurtailmentsMessage.textContent = ''; }, 5000); if (selectAllCheckbox) selectAllCheckbox.checked = false; if(deleteSelectedButton) deleteSelectedButton.disabled = true; } // Reset select all and disable delete btn
}

// --- Manual Fleet Functions (from tools.html) ---
function displayManualAssignments() {
    console.log("DEBUG: displayManualAssignments called.");
    if (!manualAssignmentsDisplay || !manualRegFilterInput || !manualFleetFilterInput) { console.error("DEBUG: Missing elements required for displayManualAssignments."); if (manualAssignmentsDisplay) manualAssignmentsDisplay.innerHTML = '<p style="color: red;">Error: UI components missing.</p>'; return; }
    if (!isLoggedIn) { manualAssignmentsDisplay.innerHTML = '<p>Please log in to view assignments.</p>'; return; }

    const regFilter = manualRegFilterInput.value.trim().toUpperCase(); const fleetFilter = manualFleetFilterInput.value.trim().toUpperCase();
    manualAssignmentsDisplay.innerHTML = 'Loading...';

    try {
        const tmpMap = loadFromStorage(tmpMapKey, {}); let manualEntries = [];
        // Ensure tmpMap is an object before iterating
        if (typeof tmpMap === 'object' && tmpMap !== null) {
            for (const registration in tmpMap) { if (Object.prototype.hasOwnProperty.call(tmpMap, registration)) { const fleetNumber = tmpMap[registration]; // Check if it's NOT auto-generated
                 if (typeof fleetNumber === 'string' && !fleetNumber.startsWith('TMP') && !fleetNumber.startsWith('ERR')) { manualEntries.push({ reg: registration, fleet: fleetNumber }); } } }
        } else { console.warn("DEBUG: TMP map data retrieved from storage is invalid."); manualAssignmentsDisplay.innerHTML = '<p style="color: red;">Error: Could not load assignment data.</p>'; return; }

        // Filter based on input fields
        const filteredEntries = manualEntries.filter(entry => { const regMatch = !regFilter || (entry.reg || '').toUpperCase().includes(regFilter); const fleetMatch = !fleetFilter || (entry.fleet || '').toUpperCase().includes(fleetFilter); return regMatch && fleetMatch; });

        // Sort by fleet number (numerically if possible, then fallback)
        filteredEntries.sort((a, b) => (a.fleet || '').localeCompare(b.fleet || '', undefined, { numeric: true, sensitivity: 'base' }));

        if (filteredEntries.length === 0) { if (manualEntries.length === 0) { manualAssignmentsDisplay.innerHTML = '<p>No manual fleet assignments found.</p>'; } else { manualAssignmentsDisplay.innerHTML = '<p>No assignments match the current filter.</p>'; } }
        else { let html = ''; filteredEntries.forEach(entry => { const safeFleet = entry.fleet.replace(/</g, "&lt;").replace(/>/g, "&gt;"); const safeReg = entry.reg.replace(/</g, "&lt;").replace(/>/g, "&gt;"); html += `<div><strong>${safeFleet}:</strong> ${safeReg}</div>`; }); manualAssignmentsDisplay.innerHTML = html; }
    } catch (e) { console.error("DEBUG: Error displaying manual assignments:", e); manualAssignmentsDisplay.innerHTML = '<p style="color: red;">An error occurred while loading assignments.</p>'; }
}
function assignManualFleetNumber() {
    console.log("DEBUG: assignManualFleetNumber called.");
    if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) { alert('Access Denied.'); console.warn(`DEBUG: assignManualFleetNumber denied for user '${currentUsername}'.`); return; }
    if (!manualRegNumberInput || !manualFleetNumberInput || !assignStatusElement) { alert('Error: Could not find necessary form elements.'); console.error("DEBUG: assignManualFleetNumber missing required DOM elements."); return; }

    const registration = manualRegNumberInput.value.trim().toUpperCase(); const fleetNumber = manualFleetNumberInput.value.trim(); // Don't uppercase fleet
    assignStatusElement.textContent = '';

    if (!registration || !fleetNumber) { alert('Please provide both Bus Registration and Real Fleet Number.'); assignStatusElement.textContent = 'Both fields are required.'; assignStatusElement.style.color = 'red'; return; }

    // Warn if assigning something that looks like auto-generated
    if (fleetNumber.startsWith('TMP') || fleetNumber.startsWith('ERR')) { if (!confirm(`The fleet number "${fleetNumber}" looks like an automatically generated number. Are you sure you want to assign this manually?`)) { console.log("DEBUG: Manual assignment of TMP/ERR cancelled by user."); return; } }

    try {
        let tmpMap = loadFromStorage(tmpMapKey, {}); if (typeof tmpMap !== 'object' || tmpMap === null) { console.warn("DEBUG: TMP map data invalid, resetting to empty object."); tmpMap = {}; }

        const previousValue = tmpMap[registration];
        // Check if the value is actually changing
        if (previousValue === fleetNumber) { assignStatusElement.textContent = `No change: ${registration} is already assigned to ${fleetNumber}.`; assignStatusElement.style.color = 'orange'; setTimeout(() => { if (assignStatusElement) assignStatusElement.textContent = ''; }, 4000); return; }

        tmpMap[registration] = fleetNumber; // Set/overwrite the value
        saveToStorage(tmpMapKey, tmpMap); // Save the updated map

        logAdminAction("Fleet Assigned", { reg: registration, fleet: fleetNumber, previous: previousValue || 'N/A' });

        assignStatusElement.textContent = `Successfully assigned Fleet Number ${fleetNumber} to Registration ${registration}.`; assignStatusElement.style.color = 'green';
        // Clear inputs and refresh list
        manualRegNumberInput.value = ''; manualFleetNumberInput.value = ''; displayManualAssignments(); manualRegNumberInput.focus();
        setTimeout(() => { if (assignStatusElement) assignStatusElement.textContent = ''; }, 4000); // Clear message after delay
    } catch (err) { console.error("DEBUG: Error assigning manual fleet number:", err); alert(`An error occurred: ${err.message}`); assignStatusElement.textContent = `Error saving assignment: ${err.message}`; assignStatusElement.style.color = 'red'; }
}
function getTMPForRegistration(registration) { // Used by curtailment table, needs to work
    if (!registration || typeof registration !== 'string' || registration.trim() === '') { return 'TMP????'; } // Default if invalid input
    const cleanReg = registration.trim().toUpperCase();
    try {
        let tmpMap = loadFromStorage(tmpMapKey, {}); if (typeof tmpMap !== 'object' || tmpMap === null) { console.warn("DEBUG: Invalid tmpMap loaded in getTMPForRegistration. Resetting."); tmpMap = {}; }

        // 1. Check if already exists in map
        if (Object.prototype.hasOwnProperty.call(tmpMap, cleanReg)) { return tmpMap[cleanReg]; }

        // 2. Generate a new TMP number if not found
        let attempt = 0; const maxAttempts = 100; let uniqueTMP = null; let generatedValue;
        while (uniqueTMP === null && attempt < maxAttempts) { const inputForHash = attempt === 0 ? cleanReg : `${cleanReg}_${attempt}`; // Add attempt number if first hash collided
            generatedValue = generateTMPNumber(inputForHash); if (!isTMPValueUsed(tmpMap, generatedValue, cleanReg)) { uniqueTMP = generatedValue; // Found a unique one
            } else { attempt++; } }

        let finalValueToAssign;
        if (uniqueTMP !== null) {
            finalValueToAssign = uniqueTMP; // Assign the generated TMP
        } else {
            // Fallback if too many collisions (unlikely but possible)
            console.warn(`DEBUG: Max TMP generation attempts reached for ${cleanReg}. Assigning fallback ERR number.`);
            finalValueToAssign = `ERR${Math.floor(1000 + Math.random() * 9000)}`; // Generate random ERR
            // Extremely unlikely, but double-check the random ERR isn't used
            if (isTMPValueUsed(tmpMap, finalValueToAssign, cleanReg)) { finalValueToAssign = `ERR${Math.floor(1000 + Math.random() * 9000)}`; }
        }

        // 3. Save the newly generated TMP/ERR to the map
        tmpMap[cleanReg] = finalValueToAssign; saveToStorage(tmpMapKey, tmpMap);

        // 4. Optionally save generation info (for Auto TMP table)
        try { let generationInfo = loadFromStorage(tmpGenerationInfoKey, {}); if (typeof generationInfo !== 'object' || generationInfo === null) { generationInfo = {}; } generationInfo[cleanReg] = { type: finalValueToAssign.startsWith('TMP') ? 'TMP' : 'ERR', timestamp: Date.now() }; saveToStorage(tmpGenerationInfoKey, generationInfo); } catch (e) { console.error("Error saving TMP generation info:", e); }

        return finalValueToAssign;
    } catch (e) { console.error(`DEBUG: Error in getTMPForRegistration for '${cleanReg}':`, e); return 'ERR????'; // Error fallback
    }
}
/* jshint bitwise: false */ function generateTMPNumber(reg) { const s = 12345, c = reg + s.toString(); let h = 0; if (c.length === 0) return "TMP0000"; for (let i = 0; i < c.length; i++) { const t = c.charCodeAt(i); h = ((h << 5) - h) + t; h |= 0; } return `TMP${Math.abs(h % 10000).toString().padStart(4, "0")}`; } /* jshint bitwise: true */
function isTMPValueUsed(map, val, currReg) { for (const r in map) { if (Object.prototype.hasOwnProperty.call(map, r) && r !== currReg && map[r] === val) { return true; } } return false; }
function revertToTMP() {
     if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin permissions required to revert.'); return; } if (!revertRegNumberInput || !revertStatusElement) { console.error("Revert UI elements missing."); return; } const reg = revertRegNumberInput.value.trim().toUpperCase(); if (revertStatusElement) revertStatusElement.textContent = ''; if (!reg) { alert("Please enter a Registration number to revert."); return; } let map = loadFromStorage(tmpMapKey, {}); if (typeof map !== 'object' || map === null) map = {}; if (!Object.prototype.hasOwnProperty.call(map, reg)) { if (revertStatusElement) { revertStatusElement.textContent = `${reg} not found in the assignment map.`; revertStatusElement.style.color='orange'; setTimeout(() => revertStatusElement.textContent = '', 4000); } return; } const current = map[reg]; // Check if it's ALREADY auto-generated
      if (typeof current === 'string' && (current.startsWith('TMP') || current.startsWith('ERR'))) { if (revertStatusElement) { revertStatusElement.textContent = `${reg} already has an auto-generated number (${current}). No action taken.`; revertStatusElement.style.color='orange'; setTimeout(() => revertStatusElement.textContent = '', 4000); } return; } if (confirm(`This will remove the manual fleet number for ${reg} and allow an automatic TMP/ERR number to be generated next time it's needed. Continue?`)) { try { const removedValue = map[reg]; delete map[reg]; // Remove the manual entry
           saveToStorage(tmpMapKey, map); logAdminAction("Fleet Reverted", { reg, removedValue: removedValue }); if (revertStatusElement) { revertStatusElement.textContent = `Manual assignment for ${reg} removed.`; revertStatusElement.style.color = 'green'; } if (revertRegNumberInput) revertRegNumberInput.value = ''; displayManualAssignments(); // Refresh list
           setTimeout(() => { if(revertStatusElement) revertStatusElement.textContent = ''; }, 4000); } catch (err) { if (revertStatusElement) { revertStatusElement.textContent = `Error reverting: ${err.message}`; revertStatusElement.style.color = 'red'; } } }
}

// --- End of Merged JavaScript (Part 1) ---
// --- Start of Merged JavaScript (Part 2) ---

// --- Auto TMP Table Population & Filtering (from tools.html) ---

/**
 * Populates the Auto TMP table with data, sorts it, stores it globally,
 * then updates filters and applies them.
 */
function populateAutoTmpTable() {
    console.log("DEBUG: populateAutoTmpTable called.");
    if (!isLoggedIn || !autoTmpTableBody) {
        console.warn("DEBUG: Cannot populate auto TMP table - not logged in or table body missing.");
        if (autoTmpTableBody) autoTmpTableBody.innerHTML = '<tr><td colspan="4">Error: Table cannot be loaded.</td></tr>'; // Colspan 4 now
        return;
    }

    autoTmpTableBody.innerHTML = '<tr><td colspan="4">Loading auto-generated assignments...</td></tr>'; // Colspan 4 now
    if (autoTmpTableMessage) autoTmpTableMessage.textContent = '';
    currentAutoTmpData = []; // Clear previous full dataset

    setTimeout(() => { // Allow UI update before processing
        try {
            const tmpMap = loadFromStorage(tmpMapKey, {});
            const infoMap = loadFromStorage(tmpGenerationInfoKey, {}); // Load generation info (route/timestamp)
            let rawEntries = [];

            if (typeof tmpMap === 'object' && tmpMap !== null) {
                for (const registration in tmpMap) {
                    if (Object.prototype.hasOwnProperty.call(tmpMap, registration)) {
                        const fleetValue = tmpMap[registration];
                        // Filter for only TMP or ERR entries
                        if (typeof fleetValue === 'string' && (fleetValue.startsWith('TMP') || fleetValue.startsWith('ERR'))) {
                            const info = infoMap[registration] || {}; // Get associated info or empty object
                            const entryTimestamp = info.timestamp || 0; // Use timestamp from info, default 0
                            // Use route from info if available, else try to find from latest curtailment? (Complex) -> Stick to N/A for now if not in info
                            const entryRoute = info.route || 'N/A';
                            const displayDate = entryTimestamp ? new Date(entryTimestamp).toLocaleDateString('en-GB') : 'N/A'; // DD/MM/YYYY

                            rawEntries.push({
                                registration: registration,
                                fleet: fleetValue,
                                route: entryRoute, // Use route from generation info
                                timestamp: entryTimestamp,
                                displayDate: displayDate // Store formatted date
                            });
                        }
                    }
                }
            } else {
                throw new Error("Could not load TMP map data.");
            }

            // Sort the full dataset: Primary: Fleet (numeric asc), Secondary: Reg (alpha asc)
            rawEntries.sort((a, b) => {
                const fleetA = a.fleet || '';
                const fleetB = b.fleet || '';
                // Extract numbers for sorting, treat non-numeric as very large
                const numA = parseInt(fleetA.replace(/[^0-9]/g, ''), 10);
                const numB = parseInt(fleetB.replace(/[^0-9]/g, ''), 10);
                const valA = isNaN(numA) ? Infinity : numA;
                const valB = isNaN(numB) ? Infinity : numB;

                if (valA !== valB) return valA - valB; // Sort by number first
                return (a.registration || '').localeCompare(b.registration || ''); // Then by registration
            });

            currentAutoTmpData = rawEntries; // Store the fully sorted data globally

            // Initial population of table rows from the full dataset
            let tableHtml = '';
             const escapeHtml = (unsafe) => { if (unsafe === null || typeof unsafe === 'undefined') return 'N/A'; return String(unsafe).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); };
             if (currentAutoTmpData.length === 0) {
                tableHtml = '<tr><td colspan="4">No auto-generated assignments found.</td></tr>';
            } else {
                 currentAutoTmpData.forEach(entry => {
                     tableHtml += `
                         <tr>
                             <td>${escapeHtml(entry.route)}</td>
                             <td>${escapeHtml(entry.fleet)}</td>
                             <td>${escapeHtml(entry.registration)}</td>
                             <td>${escapeHtml(entry.displayDate)}</td>
                         </tr>`;
                 });
            }
            autoTmpTableBody.innerHTML = tableHtml;

            // Populate filters based on the full dataset and apply initial view
            // Reset dropdowns before populating options based on potentially filtered data
            [autoTmpFilterRoute, autoTmpFilterFleet, autoTmpFilterReg, autoTmpFilterDate].forEach(sel => { if(sel) sel.value = ""; });
            updateAutoTmpFiltersAndTable(); // Update filter dropdowns based on the full data set

        } catch (e) {
            console.error("DEBUG: Error populating auto TMP table:", e);
            autoTmpTableBody.innerHTML = '<tr><td colspan="4" style="color:red;">Error loading data. Please check console.</td></tr>'; // Colspan 4
             if (autoTmpTableMessage) { autoTmpTableMessage.textContent = 'Error loading assignments.'; autoTmpTableMessage.style.color = 'red'; }
        }
    }, 10);
}

/**
 * Helper function to populate a single filter dropdown with unique options.
 * @param {HTMLSelectElement} selectElement - The select dropdown element.
 * @param {Set<string>} optionsSet - A Set containing the unique string options.
 * @param {string} currentValue - The currently selected value to preserve.
 * @param {string} [sortType='alpha'] - Sorting type ('alpha', 'numeric', 'date-desc').
 */
function populateFilterWithOptions(selectElement, optionsSet, currentValue, sortType = 'alpha') {
    if (!selectElement) return;

    // Clear existing options (keep the first "All" option)
    while (selectElement.options.length > 1) { selectElement.remove(1); }

    // Filter out 'N/A' and convert Set to array for sorting
    let sortedOptions = [...optionsSet].filter(opt => opt !== null && typeof opt !== 'undefined' && opt !== 'N/A');

    // Sort options based on type
    if (sortType === 'numeric') {
         sortedOptions.sort((a, b) => {
             const numA = parseInt(String(a).replace(/[^0-9]/g, ''), 10);
             const numB = parseInt(String(b).replace(/[^0-9]/g, ''), 10);
             const valA = isNaN(numA) ? Infinity : numA;
             const valB = isNaN(numB) ? Infinity : numB;
             return valA - valB;
         });
    } else if (sortType === 'date-desc') {
         sortedOptions.sort((a, b) => {
             try { // Handle potential parsing errors
                 const partsA = String(a).split('/'); // DD/MM/YYYY
                 const dateA = new Date(partsA[2], partsA[1] - 1, partsA[0]); // Month is 0-indexed
                 const partsB = String(b).split('/');
                 const dateB = new Date(partsB[2], partsB[1] - 1, partsB[0]);
                 if (isNaN(dateA.getTime())) return 1; // Put invalid dates last
                 if (isNaN(dateB.getTime())) return -1;
                 return dateB - dateA; // Sort descending (newest first)
             } catch (e) { return 0; } // Don't change order on error
         });
    } else { // Default 'alpha' sort
         sortedOptions.sort((a, b) => String(a).localeCompare(String(b)));
    }

    // Add new sorted options
    sortedOptions.forEach(optionValue => {
        selectElement.add(new Option(optionValue, optionValue));
    });

    // Restore the intended selection for this dropdown, if it exists in the new options
    if (currentValue && [...selectElement.options].some(opt => opt.value === currentValue)) {
        selectElement.value = currentValue;
    } else {
         selectElement.value = ""; // Default to "All" if value not found or empty
    }
}

/**
 * Updates filter dropdown options based on the current selections applied to the full dataset,
 * then applies the visual filtering to the table rows.
 */
function updateAutoTmpFiltersAndTable() {
    console.log("DEBUG: updateAutoTmpFiltersAndTable called");

    if (!autoTmpFilterRoute || !autoTmpFilterFleet || !autoTmpFilterReg || !autoTmpFilterDate) {
        console.warn("DEBUG: Auto TMP filter elements not all found.");
        return;
    }

    // 1. Get current filter values *before* repopulating dropdowns
    const currentFilters = {
        route: autoTmpFilterRoute.value,
        fleet: autoTmpFilterFleet.value,
        reg: autoTmpFilterReg.value,
        date: autoTmpFilterDate.value
    };
    console.log("DEBUG: Current filter values:", currentFilters);

    // 2. Helper function to get available options for one column,
    // considering the selections in OTHER columns applied to the FULL dataset.
    const getOptionsFor = (columnToPopulate, currentFilters) => {
        const tempFilters = {...currentFilters};
        // When getting options for a column, DON'T filter by that column itself
        delete tempFilters[columnToPopulate];

        // Filter the global data based on *other* active filters
        const relevantData = currentAutoTmpData.filter(entry => {
            const routeMatch = !tempFilters.route || entry.route === tempFilters.route;
            const fleetMatch = !tempFilters.fleet || entry.fleet === tempFilters.fleet;
            const regMatch = !tempFilters.reg || entry.registration === tempFilters.reg;
            const dateMatch = !tempFilters.date || entry.displayDate === tempFilters.date;
            return routeMatch && fleetMatch && regMatch && dateMatch;
        });

        // Extract the unique values for the target column from this relevant subset
        let key; // Map filter key to data key
        if (columnToPopulate === 'reg') key = 'registration';
        else if (columnToPopulate === 'date') key = 'displayDate';
        else key = columnToPopulate; // 'route', 'fleet'

        return new Set(relevantData.map(e => e[key]));
    };

    // 3. Extract unique options for *each* filter dropdown based on other filters
    const options = {
        route: getOptionsFor('route', currentFilters),
        fleet: getOptionsFor('fleet', currentFilters),
        reg: getOptionsFor('reg', currentFilters),
        date: getOptionsFor('date', currentFilters)
    };

    // 4. Repopulate *all* filter dropdowns with their respective options,
    // preserving the currently selected value for each.
    populateFilterWithOptions(autoTmpFilterRoute, options.route, currentFilters.route);
    populateFilterWithOptions(autoTmpFilterFleet, options.fleet, currentFilters.fleet, 'numeric');
    populateFilterWithOptions(autoTmpFilterReg, options.reg, currentFilters.reg);
    populateFilterWithOptions(autoTmpFilterDate, options.date, currentFilters.date, 'date-desc');

    // 5. Filter the visible table rows based on the final filter values
    filterAutoTmpTable();
}

/**
 * Applies the current filter selections to VISUALLY hide/show Auto TMP table rows.
 * Updates the visible count message.
 */
function filterAutoTmpTable() {
    console.log("DEBUG: filterAutoTmpTable (display update) called.");
    const tableBody = autoTmpTableBody;
    const msgElement = autoTmpTableMessage;

    if (!tableBody || !autoTmpFilterRoute || !autoTmpFilterFleet || !autoTmpFilterReg || !autoTmpFilterDate) {
        console.warn("DEBUG: Filter elements or table body missing for filtering auto TMP table display.");
        if(msgElement) msgElement.textContent = 'Error: UI elements missing for filtering.';
        return;
    }

    // Get the definitive filter values currently set in the dropdowns
    const filters = {
        route: autoTmpFilterRoute.value,
        fleet: autoTmpFilterFleet.value,
        reg: autoTmpFilterReg.value,
        date: autoTmpFilterDate.value
    };

    const rows = tableBody.querySelectorAll("tr");
    let visibleCount = 0;
    let hasActiveFilter = !!(filters.route || filters.fleet || filters.reg || filters.date);

    rows.forEach(row => {
        if (row.cells.length === 4) { // Check if it's a data row
            const routeCell = row.cells[0]?.textContent || '';
            const fleetCell = row.cells[1]?.textContent || '';
            const regCell = row.cells[2]?.textContent || '';
            const dateCell = row.cells[3]?.textContent || '';

            // Check if row matches all active filters
            const routeMatch = !filters.route || routeCell === filters.route;
            const fleetMatch = !filters.fleet || fleetCell === filters.fleet;
            const regMatch = !filters.reg || regCell === filters.reg;
            const dateMatch = !filters.date || dateCell === filters.date;

            const showRow = routeMatch && fleetMatch && regMatch && dateMatch;
            row.style.display = showRow ? "" : "none"; // Show or hide row
            if (showRow) visibleCount++;

        } else if (row.cells.length === 1 && row.cells[0].getAttribute('colspan') === "4") {
             // Hide placeholder rows ("Loading...", "No data") initially
            row.style.display = 'none';
        }
    });

    // Handle "No results" message display
    const noDataRow = Array.from(rows).find(r => r.cells.length === 1 && r.cells[0].getAttribute('colspan') === "4");
    if (noDataRow) {
        if (visibleCount === 0 && currentAutoTmpData.length > 0) { // Show "No match" only if data exists but filters hide all
            noDataRow.cells[0].textContent = "No assignments match current filters.";
            noDataRow.cells[0].style.color = 'orange';
            noDataRow.style.display = ""; // Show this specific placeholder
        } else if (visibleCount === 0 && currentAutoTmpData.length === 0) { // Show default if no data ever
            noDataRow.cells[0].textContent = "No auto-generated assignments found.";
             noDataRow.cells[0].style.color = ''; // Reset color
            noDataRow.style.display = ""; // Show this specific placeholder
        }
        // If visibleCount > 0, the placeholder remains hidden (display='none' set above)
    }

    // Update count display message
    if (msgElement) {
        // Using total count from the globally stored full data
        msgElement.textContent = `${visibleCount} / 9999 Auto Assignments ${hasActiveFilter ? '(Filtered)' : ''}`;
        msgElement.style.color = ''; // Reset color
    }
}

/**
 * Called by the onchange event of the filter selects.
 * Updates the filters and table display. Filters are NOT saved persistently.
 */
function applyAndSaveAutoTmpFilters() {
    console.log("DEBUG: applyAndSaveAutoTmpFilters called (will update filters and table).");
    // Removed saving state to localStorage
    updateAutoTmpFiltersAndTable(); // This now handles updating options and filtering display
}

// --- Password Modal & Confirmation Logic (from tools.html) ---

function resetTMPMap() { // Initiates the modal for resetting TMP
    if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin permissions required to reset the TMP map.'); return; }
    if (confirm('DANGER: This will permanently clear ALL automatically generated and manually assigned Fleet/TMP numbers. Are you sure?')) {
         // Set up and show modal for TMP reset
         if (!passwordModal || !passwordModalInput || !passwordModalError || !passwordModalPrompt) {
             alert("Error: Password dialog UI elements missing."); return;
         }
         currentModalAction = 'resetTMP'; // Set the action
         passwordModalPrompt.textContent = 'Please enter your password to confirm TMP map reset:'; // Set prompt text
         passwordModalInput.value = ''; // Clear password field
         passwordModalError.textContent = ''; // Clear previous errors
         passwordModal.classList.remove('hidden'); // Show modal
         passwordModalInput.focus(); // Focus password input
    }
}

// Handles password confirmation for multiple potential actions
function handleModalConfirm() {
    console.log(`DEBUG: handleModalConfirm called for action: ${currentModalAction}`);
    if (!isLoggedIn || !currentUsername || !users[currentUsername]) {
        if (passwordModalError) passwordModalError.textContent = 'Error: Cannot verify user.';
        return;
    }
     if (!passwordModalInput || !passwordModalError || !passwordModal || !passwordModalPrompt) {
        console.error("DEBUG: Password modal elements missing in handleModalConfirm");
        return;
     }
     const enteredPassword = passwordModalInput.value;
     const correctPassword = users[currentUsername].pass;

     if (enteredPassword === correctPassword) {
        console.log("DEBUG: Password correct.");
        passwordModal.classList.add('hidden'); // Hide modal first

        // Execute the stored action
        if (currentModalAction === 'resetTMP') {
            console.log("DEBUG: Executing resetTMP action.");
            try {
                localStorage.removeItem(tmpMapKey);
                localStorage.removeItem(tmpGenerationInfoKey); // Also clear generation info
                // Verify clearance
                if (localStorage.getItem(tmpMapKey) === null && localStorage.getItem(tmpGenerationInfoKey) === null) {
                    logAdminAction("TMP Map Reset");
                    alert('TMP map cleared successfully.');
                     // Refresh relevant UI if visible
                    if (manualFleetForm && !manualFleetForm.classList.contains('hidden')) { displayManualAssignments(); }
                    if (viewAutoTmpSection && !viewAutoTmpSection.classList.contains('hidden')) { populateAutoTmpTable(); }
                } else {
                    alert('ERROR: Failed to verify TMP map clearance!'); // Should not happen
                }
            } catch (e) {
                alert("An error occurred while clearing the TMP map.");
                console.error("Error executing TMP reset:", e);
            }
        } else if (currentModalAction === 'pruneCurtailments') {
            console.log("DEBUG: Executing pruneCurtailments action (logic in Part 3).");
            executePruning(); // Call the actual pruning logic function (defined in Part 3)
        } else {
            console.error(`DEBUG: Unknown modal action: ${currentModalAction}`);
        }

        currentModalAction = null; // Clear the action after execution

     } else {
        console.warn("DEBUG: Incorrect password entered.");
        passwordModalError.textContent = 'Incorrect password.';
        passwordModalInput.focus();
        passwordModalInput.select(); // Select text for easy re-entry
     }
}

// Handles cancelling the password modal action
function cancelModalAction() {
    console.log("DEBUG: cancelModalAction called.");
    if (passwordModal) passwordModal.classList.add('hidden');
    if (passwordModalInput) passwordModalInput.value = '';
    if (passwordModalError) passwordModalError.textContent = '';
    currentModalAction = null; // Clear the pending action
}

// --- Settings Section Logic (from tools.html) ---
function loadTrackerSettings() { // Used for admin settings section
    const s = loadFromStorage(settingsKey, defaultSettings);
    if (settingsDebounceInput) settingsDebounceInput.value = s.debounceMinutes ?? defaultSettings.debounceMinutes;
    if (settingsTimeoutInput) settingsTimeoutInput.value = s.timeoutMinutes ?? defaultSettings.timeoutMinutes;
    if (settingsAutoLogoutInput) settingsAutoLogoutInput.value = s.autoLogoutMinutes ?? defaultSettings.autoLogoutMinutes;
}
function saveTrackerSettings() {
    if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin privileges required.'); return; }
    if (!settingsDebounceInput || !settingsTimeoutInput || !settingsAutoLogoutInput || !trackerSettingsMessage) { console.error("Tracker settings elements missing."); return;}
    // Parse values, ensure they are valid numbers
    const d = parseInt(settingsDebounceInput.value, 10), t = parseInt(settingsTimeoutInput.value, 10), a = parseInt(settingsAutoLogoutInput.value, 10);
    trackerSettingsMessage.textContent = ''; // Clear status
    if (isNaN(d) || d < 0) { alert("Invalid Debounce value. Must be 0 or greater."); return; }
    if (isNaN(t) || t < 1) { alert("Invalid Timeout value. Must be 1 or greater."); return; }
    if (isNaN(a) || a < 0) { alert("Invalid Auto Logout value. Must be 0 (disabled) or greater."); return; }

    const oldS = loadFromStorage(settingsKey, defaultSettings); // Get old settings for audit log
    const newS = { debounceMinutes: d, timeoutMinutes: t, autoLogoutMinutes: a };
    saveToStorage(settingsKey, newS); // Save new settings

    logAdminAction("Tracker Settings Saved", { old: oldS, new: newS }); // Log the change
    trackerSettingsMessage.textContent = "Tracker settings saved!"; trackerSettingsMessage.style.color = "green";
    startSessionTimer(); // Restart timer with new value if applicable
    setTimeout(() => { if(trackerSettingsMessage) trackerSettingsMessage.textContent = ""; }, 3000);
}
function changeMyPassword() {
    if (!isLoggedIn || !currentUsername) { alert("Not logged in."); return; }
    if (!currentPasswordInput || !newPasswordInput || !confirmNewPasswordInput || !changePasswordMessage) { console.error("Change password elements missing."); return;}
    const curr = currentPasswordInput.value, newP = newPasswordInput.value, conf = confirmNewPasswordInput.value;
    changePasswordMessage.textContent = ''; // Clear status

    if (!curr || !newP || !conf) { changePasswordMessage.textContent = "Please fill all password fields."; changePasswordMessage.style.color='red'; return; }
    if (newP.length < 6) { changePasswordMessage.textContent = "New password must be at least 6 characters."; changePasswordMessage.style.color='red'; return; }
    if (newP !== conf) { changePasswordMessage.textContent = "New passwords do not match."; changePasswordMessage.style.color='red'; return; }
    if (users[currentUsername].pass !== curr) { changePasswordMessage.textContent = "Incorrect current password."; changePasswordMessage.style.color='red'; return; }
    if (newP === curr) { changePasswordMessage.textContent = "New password cannot be the same as the old password."; changePasswordMessage.style.color='red'; return; }

    // All checks passed, update password
    users[currentUsername].pass = newP;
    saveUsersToStorage(); // Save the updated user object
    logAdminAction("Password Changed", { user: currentUsername }); // Log action

    changePasswordMessage.textContent = "Password changed successfully!"; changePasswordMessage.style.color = "green";
    // Clear fields
    currentPasswordInput.value = ''; newPasswordInput.value = ''; confirmNewPasswordInput.value = '';
    setTimeout(() => { if(changePasswordMessage) changePasswordMessage.textContent = ''; }, 4000);

    sortedUsernames.forEach(un => {
        const uData = users[un];
        const tr = userManagementTbody.insertRow();
        tr.insertCell().textContent = un; // Username

        // Role Cell
        const roleC = tr.insertCell();
        if (un === 'Ryan') { // Cannot change default admin role
            roleC.textContent = uData.role;
        } else {
            const sel = document.createElement('select');
            sel.id = `role-select-${un}`;
            sel.innerHTML = `<option value="user" ${uData.role === 'user' ? 'selected' : ''}>User</option><option value="moderator" ${uData.role === 'moderator' ? 'selected' : ''}>Moderator</option><option value="admin" ${uData.role === 'admin' ? 'selected' : ''}>Admin</option>`;
            sel.onchange = () => changeUserRole(un, sel.value);
            roleC.appendChild(sel);
console.log(`--- Dropdown 'onchange' triggered for user: ${un} ---`);
    const selectedValue = sel.value; // Get value inside handler
    console.log(`--- New selected value: ${selectedValue} ---`);
    console.log(`--- Checking typeof changeUserRole just before call: ${typeof changeUserRole} ---`); // Check if function exists here
        }

        // Status Cell
        const statusC = tr.insertCell();
        const statusT = uData.isSuspended ? 'Suspended' : 'Active';
        const statusCls = uData.isSuspended ? 'status-suspended' : 'status-active';
        statusC.innerHTML = `<span class="${statusCls}">${statusT}</span>`;

        // *** Create the Permissions Cell and add checkboxes ***
        const permC = tr.insertCell();
        permC.className = 'permissions-cell';
        // --- LOGGING STEP 5 (Optional, keep if debugging) ---
        // console.log(`DEBUG: displayUserManagement - Creating permissions cell for ${un}`);

        PERMISSIONS_LIST.forEach((perm, permIndex) => {
            // --- LOGGING STEP 6 (Optional, keep if debugging) ---
            // console.log(`DEBUG: displayUserManagement - Adding checkbox ${permIndex + 1}/${PERMISSIONS_LIST.length} for permission: ${perm.key}`);

            const permDiv = document.createElement('div'); // Create a div for each permission line
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `perm-${un}-${perm.key}`;
            // Ensure we check against the actual permission value, default to false if undefined
            checkbox.checked = uData.permissions[perm.key] === true;
            checkbox.dataset.permissionKey = perm.key; // Store key for saving
            checkbox.disabled = (un === 'Ryan'); // Disable checkbox for default admin 'Ryan'

            // Add the onchange handler only if the checkbox is not disabled
            if (!checkbox.disabled) {
                 checkbox.onchange = () => saveUserPermissions(un); // Call save function on change
            }

            const label = document.createElement('label');
            label.htmlFor = checkbox.id;
            label.textContent = perm.label; // Use the label from PERMISSIONS_LIST

            permDiv.appendChild(checkbox); // Add checkbox to the div
            permDiv.appendChild(label);    // Add label to the div
            permC.appendChild(permDiv);    // Add the div to the table cell

            // --- LOGGING STEP 7 (Optional, keep if debugging) ---
            // console.log(`DEBUG: displayUserManagement - Appended checkbox for ${perm.key}`);
        });
        // --- LOGGING STEP 8 (Optional, keep if debugging) ---
        // console.log(`DEBUG: displayUserManagement - Finished adding checkboxes for ${un}`);
        // *** END Permissions Cell logic ***

        // Actions Cell
        const actC = tr.insertCell();
        if (un !== 'Ryan') { // No actions for default admin
            const btnP = document.createElement('button'); btnP.textContent = 'Set Password'; btnP.className = 'blue-button'; btnP.type = 'button'; console.log(`[${un}] Checking typeof openSetPasswordModal before assigning onclick:`, typeof openSetPasswordModal); btnP.onclick = () => openSetPasswordModal(un); actC.appendChild(btnP);
            const btnS = document.createElement('button'); btnS.textContent = uData.isSuspended ? 'Unsuspend' : 'Suspend'; btnS.className = uData.isSuspended ? 'unsuspend-user-btn' : 'suspend-user-btn'; btnS.type = 'button'; btnS.onclick = () => toggleUserSuspension(un); actC.appendChild(btnS);
            const btnD = document.createElement('button'); btnD.textContent = 'Delete'; btnD.className = 'danger-button delete-user-btn'; btnD.type = 'button'; btnD.onclick = () => deleteUser(un); actC.appendChild(btnD);
        } else { actC.textContent = 'N/A'; }
    });
}
// --- Modify addUser function ---
function addUser() {
    if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert("Admin privileges required."); return;}
    if (!addUsernameInput || !addUserPasswordInput || !addUserRoleSelect || !addUserMessage) { console.error("Add user elements missing."); return;}
    const newU = addUsernameInput.value.trim(), newP = addUserPasswordInput.value, newR = addUserRoleSelect.value;
    addUserMessage.textContent = ''; // Clear status

    if (!newU || !newP) { addUserMessage.textContent = "Username and Password required."; addUserMessage.style.color='red'; return; }
    if (newP.length < 6) { addUserMessage.textContent = "Password must be at least 6 characters."; addUserMessage.style.color='red'; return; }
    if (Object.prototype.hasOwnProperty.call(users, newU)) { addUserMessage.textContent = "Username already exists."; addUserMessage.style.color='red'; return; }
    if (!['user', 'admin', 'moderator'].includes(newR)) { addUserMessage.textContent = "Invalid role selected."; addUserMessage.style.color='red'; return; }

    // *** ADDED: Initialize permissions object ***
    const initialPermissions = {};
    PERMISSIONS_LIST.forEach(perm => {
        // Optionally grant some permissions by default based on role
        // Example: Grant curtailment management to new moderators/admins
        if (perm.key === 'canManageCurtailments' && (newR === 'admin' || newR === 'moderator')) {
             initialPermissions[perm.key] = true;
        } else {
             initialPermissions[perm.key] = false; // Default to false
        }
        // Add more role-based defaults here if needed
    });
    // *** END ADDED ***

    // Add user with permissions
    users[newU] = {
        pass: newP,
        role: newR,
        permissions: initialPermissions, // Use initialized permissions
        isSuspended: false
    };
    saveUsersToStorage(); // Save updated user list
    logAdminAction("User Added", { newUser: newU, role: newR }); // Log action

    addUserMessage.textContent = `User "${newU}" added successfully.`; addUserMessage.style.color = "green";
    // Clear form and refresh table
    addUsernameInput.value = ''; addUserPasswordInput.value = ''; addUserRoleSelect.value = 'user';
    displayUserManagement(); // Refresh the user list table
    setTimeout(() => { if(addUserMessage) addUserMessage.textContent = ''; }, 4000);
}
function changeUserRole(username, newRole) {
     if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert("Admin privileges required."); return; }
     if (username === 'Ryan') { alert("Cannot change the default admin role."); displayUserManagement(); return; } // Prevent changing default admin
     if (!Object.prototype.hasOwnProperty.call(users, username)) { alert(`User ${username} not found.`); return; } // User must exist
     if (!['user', 'admin', 'moderator'].includes(newRole)) { alert("Invalid role selected."); return; } // Role must be valid

}
function saveUserPermissions(username) {
    console.log(`DEBUG: saveUserPermissions called for user: ${username}`);

    // Security Check: Ensure current user is admin
    if (!isLoggedIn || !users[currentUsername] || users[currentUsername].role !== 'admin') {
        alert("Admin privileges required to change permissions.");
        // Re-render table to revert checkbox state if user somehow bypassed disabled state
        displayUserManagement();
        return;
    }

    // Find the user and ensure their data structure is correct
    if (!users[username]) {
        console.error(`DEBUG: User ${username} not found.`);
        alert(`Error: User ${username} not found.`);
        return;
    }
    if (!users[username].permissions || typeof users[username].permissions !== 'object') {
        console.warn(`DEBUG: Permissions object missing for ${username}. Initializing.`);
        users[username].permissions = {}; // Initialize if somehow missing
        // Initialize all known permissions to false if the object was missing
        PERMISSIONS_LIST.forEach(perm => {
             users[username].permissions[perm.key] = false;
        });
    }

    const newPermissions = {};
    let changesMade = false;

    // Find all checkboxes for this user and update the newPermissions object
    PERMISSIONS_LIST.forEach(perm => {
        const checkbox = document.getElementById(`perm-${username}-${perm.key}`);
        if (checkbox) {
            const newValue = checkbox.checked;
            // Check if the value has actually changed
            if (users[username].permissions[perm.key] !== newValue) {
                changesMade = true;
            }
            newPermissions[perm.key] = newValue;
        } else {
            console.warn(`DEBUG: Checkbox for permission ${perm.key} not found for user ${username}.`);
            // Keep existing value if checkbox not found, or default to false? Let's keep existing.
            newPermissions[perm.key] = users[username].permissions[perm.key] || false;
        }
    });

    // Only save if changes were actually detected
    if (changesMade) {
        console.log(`DEBUG: Saving updated permissions for ${username}:`, newPermissions);
        const oldPermissions = { ...users[username].permissions }; // Copy old for logging
        users[username].permissions = newPermissions; // Update user object
        saveUsersToStorage(); // Save the entire users object

        logAdminAction("User Permissions Changed", { targetUser: username, old: oldPermissions, new: newPermissions });

        // Optional: Provide visual feedback (e.g., flash row color)
        const row = userManagementTbody.querySelector(`tr input[id='perm-${username}-canManageCurtailments']`)?.closest('tr');
        if (row) {
            row.style.backgroundColor = '#d4edda'; // Light green flash
            setTimeout(() => { row.style.backgroundColor = ''; }, 1000);
        }
        if (userManagementMessage) {
             userManagementMessage.textContent = `Permissions updated for ${username}.`;
             userManagementMessage.style.color = 'green';
             setTimeout(() => { if (userManagementMessage) userManagementMessage.textContent = ''; }, 3000);
        }

    } else {
        console.log(`DEBUG: No permission changes detected for ${username}. No save needed.`);
    }
}

// --- Modify the 'Permissions Cell' part within displayUserManagement function ---
/**
 * Opens the modal for setting a new password for a specific user.
 * @param {string} username - The username of the user to modify.
 */
function openSetPasswordModal(username) {
    console.log(`DEBUG: openSetPasswordModal called for user: ${username}`);
    // Permission Check (redundant if button is disabled, but good practice)
    if (!hasPermission('canManageUsers')) {
        alert('Permission Denied: Cannot set user passwords.');
        return;
    }
    if (username === 'Ryan') { // Prevent changing default admin password this way
        alert("Cannot change password for the default admin user via this interface.");
        return;
    }

    const modal = getElement('set-password-modal');
    const title = getElement('set-password-modal-title');
    const usernameInput = getElement('set-password-username'); // Hidden input
    const newPassInput = getElement('set-new-password');
    const confirmPassInput = getElement('set-confirm-password');
    const errorMsg = getElement('set-password-modal-error');

    if (!modal || !title || !usernameInput || !newPassInput || !confirmPassInput || !errorMsg) {
        console.error("DEBUG: Set password modal elements missing.");
        alert("UI Error: Cannot open password dialog.");
        return;
    }

    // Store the username we are editing in the hidden input
    usernameInput.value = username;

    // Reset modal state before showing
    title.textContent = `Set New Password for ${username}`;
    newPassInput.value = '';
    confirmPassInput.value = '';
    errorMsg.textContent = '';

    // Show the modal
    modal.classList.remove('hidden');
    newPassInput.focus(); // Focus on the new password field for convenience
}
function displayUserManagement() {
    // Use getElement to ensure userManagementTbody is defined in this scope if not global
    const userManagementTbody = getElement('user-management-tbody');
console.log("--- Inside displayUserManagement ---");
    console.log("Value of isLoggedIn:", isLoggedIn);
    console.log("Value of currentUsername:", currentUsername);
    console.log("Value of users[currentUsername]?.role:", users[currentUsername]?.role);
    console.log("Value of userManagementTbody:", userManagementTbody); // <<< Does this show null?
    console.log("--- Checking condition ---");
console.log("--- Checking condition parts ---");
    const check1_isLoggedIn = !isLoggedIn;
    const check2_isAdmin = users[currentUsername]?.role !== 'admin';
    const check3_tbodyMissing = !userManagementTbody;
    console.log("Condition Part 1 (!isLoggedIn):", check1_isLoggedIn, "(Should be false)");
    console.log("Condition Part 2 (role !== 'admin'):", check2_isAdmin, "(Should be false)");
    console.log("Condition Part 3 (!userManagementTbody):", check3_tbodyMissing, "(Should be false)");
    const overallCondition = check1_isLoggedIn || check2_isAdmin || check3_tbodyMissing;
    console.log("Overall Condition Result:", overallCondition, "(Should be false)");
    console.log("--- End Checking condition parts ---");
    if (!hasPermission('canManageUsers') || !userManagementTbody) {
        console.warn("User management cannot be displayed.");
        if (userManagementTbody) userManagementTbody.innerHTML = '<tr><td colspan="6">Admin privileges required to view user management.</td></tr>'; // Adjust colspan if needed (was 6 before, depends on final columns)
        return;
    }
    userManagementTbody.innerHTML = ''; // Clear existing rows
    // Use getElement to ensure userManagementMessage is defined in this scope if not global
    const userManagementMessage = getElement('user-management-message');
    if (userManagementMessage) userManagementMessage.textContent = ''; // Clear status

    const sortedUsernames = Object.keys(users).sort((a, b) => {
        if (a === 'Ryan') return -1; if (b === 'Ryan') return 1; return a.localeCompare(b);
    });

    sortedUsernames.forEach(un => {
        const uData = users[un];
        // Ensure user data has a permissions object
        if (!uData.permissions || typeof uData.permissions !== 'object') {
            uData.permissions = {}; // Initialize if missing
            // Initialize all defined permissions to false if needed
            PERMISSIONS_LIST.forEach(p => {
                if (uData.permissions[p.key] === undefined) {
                    uData.permissions[p.key] = false;
                }
            });
        }

        const tr = userManagementTbody.insertRow();
        tr.insertCell().textContent = un; // Username

        // Role Cell
        const roleC = tr.insertCell();
        if (un === 'Ryan') {
            roleC.textContent = uData.role;
        } else {
            const sel = document.createElement('select');
sel.id = `role-select-${un}`;
sel.innerHTML = `<option value="user" ${uData.role === 'user' ? 'selected' : ''}>User</option><option value="moderator" ${uData.role === 'moderator' ? 'selected' : ''}>Moderator</option><option value="admin" ${uData.role === 'admin' ? 'selected' : ''}>Admin</option>`;

// --- Replace the previous onchange handler with THIS simple one: ---
sel.onchange = function() { // Using function() just to be safe with 'this' if needed later
    console.log(`--- SIMPLE onchange fired for: ${un}. New value: ${this.value}`);
    alert(`Role changed for ${un} to ${this.value}!`); // Simple alert
};
// --- End of simple handler ---

roleC.appendChild(sel);
        }

        // Status Cell
        const statusC = tr.insertCell();
        const statusT = uData.isSuspended ? 'Suspended' : 'Active';
        const statusCls = uData.isSuspended ? 'status-suspended' : 'status-active';
        statusC.innerHTML = `<span class="${statusCls}">${statusT}</span>`;

        // Permissions Cell
        const permC = tr.insertCell();
        permC.className = 'permissions-cell';
        PERMISSIONS_LIST.forEach(perm => {
            const permDiv = document.createElement('div');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `perm-${un}-${perm.key}`;
            checkbox.checked = !!uData.permissions[perm.key]; // Ensure boolean check
            checkbox.dataset.permissionKey = perm.key; // Store key for saving
            checkbox.disabled = (un === 'Ryan'); // Disable checkbox for default admin 'Ryan'
            if (!checkbox.disabled) {
                checkbox.onchange = () => saveUserPermissions(un); // Assumes saveUserPermissions is defined before this
            }
            const label = document.createElement('label');
            label.htmlFor = checkbox.id;
            label.textContent = perm.label;
            permDiv.appendChild(checkbox);
            permDiv.appendChild(label);
            permC.appendChild(permDiv);
        });

        // Actions Cell
        const actC = tr.insertCell();
        if (un !== 'Ryan') {
            const btnP = document.createElement('button'); btnP.textContent = 'Set Password'; btnP.className = 'blue-button'; btnP.type = 'button';
            btnP.onclick = () => openSetPasswordModal(un); actC.appendChild(btnP); // Assumes openSetPasswordModal is defined before this
            const btnS = document.createElement('button'); btnS.textContent = uData.isSuspended ? 'Unsuspend' : 'Suspend'; btnS.className = uData.isSuspended ? 'unsuspend-user-btn' : 'suspend-user-btn'; btnS.type = 'button';
            btnS.onclick = () => toggleUserSuspension(un); actC.appendChild(btnS); // Assumes toggleUserSuspension is defined before this
            const btnD = document.createElement('button'); btnD.textContent = 'Delete'; btnD.className = 'danger-button delete-user-btn'; btnD.type = 'button';
            btnD.onclick = () => deleteUser(un); actC.appendChild(btnD); // Assumes deleteUser is defined before this
        } else { actC.textContent = 'N/A'; }
    });
} // <-- Make sure this closing brace is the end
function deleteUser(username) {
    if (!hasPermission('canManageUsers') || !userManagementTbody) { alert("Admin privileges required."); return; }
    if (username === 'Ryan') { alert("Cannot delete the default admin user."); return; } // Protect default admin
    if (!Object.prototype.hasOwnProperty.call(users, username)) { alert(`User ${username} not found.`); return; } // User must exist

    if (confirm(`DELETE user '${username}'? This action cannot be undone.`)) {
        const delData = { role: users[username].role, suspended: users[username].isSuspended }; // Capture data for log
        delete users[username]; // Remove user from object
        saveUsersToStorage(); // Save updated user list
        logAdminAction("User Deleted", { deletedUser: username, details: delData }); // Log action

        if(userManagementMessage) { userManagementMessage.textContent = `User '${username}' deleted.`; userManagementMessage.style.color='green'; }
        displayUserManagement(); // Refresh the user list table
        setTimeout(() => { if(userManagementMessage) userManagementMessage.textContent = ''; }, 4000);
    }
}
function toggleUserSuspension(username) {
     console.log(`DEBUG: toggleUserSuspension: ${username}`);
     if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { console.warn("DEBUG: Suspension toggle denied."); alert("Admin privileges required."); return; }
     if (username === 'Ryan') { alert("Cannot suspend the default admin user."); return; } // Protect default admin
     if (!Object.prototype.hasOwnProperty.call(users, username)) { alert(`User ${username} not found.`); return; } // User must exist

     const user = users[username];
     const action = user.isSuspended ? "unsuspend" : "suspend";
     if (confirm(`${action.charAt(0).toUpperCase() + action.slice(1)} user ${username}?`)) {
         user.isSuspended = !user.isSuspended; // Toggle suspension status
         saveUsersToStorage(); // Save changes
         logAdminAction(`User ${action}ed`, { targetUser: username }); // Log action

         if(userManagementMessage) { userManagementMessage.textContent = `User "${username}" ${action}ed.`; userManagementMessage.style.color = "green"; }
         displayUserManagement(); // Refresh table to show new status/button text
         setTimeout(() => { if (userManagementMessage) userManagementMessage.textContent = ''; }, 4000);
     }
}



// Ensure this function is defined in your <script> block

console.log("TEST LOG: Defining showSection NOW"); // Keeping your existing console logs
console.log("TEST LOG --- Defining showSection Function ---");
function showSection(sectionId) {
    console.log(`DEBUG: --- showSection called for sectionId: ${sectionId} ---`);

    // 1. Initial login/suspension checks
    if (!isLoggedIn || !currentUsername || !users[currentUsername] || users[currentUsername].isSuspended) {
        console.warn("DEBUG: showSection called but login state is invalid or user suspended. Forcing logout.");
        logout(); // Ensure logout if state is bad
        return;
    }

    // 2. Get the target section element
    const sectionElement = getElement(sectionId);
    if (!sectionElement) {
        console.error(`DEBUG: showSection - Target section element with ID '${sectionId}' not found.`);
        alert(`Error: The section '${sectionId}' could not be found. Please check the HTML or contact support.`);
        goBackToMainView(); // Go to a safe state
        return;
    }

    // 3. Define access rules for sections (permissions)
    const sectionAccessRules = {
        // Public / View-only sections (visible to all logged-in users)
        'manage-curtailments-section': () => true,
        'view-auto-tmp-section': () => true, // <<< This is the section for your request
        'settings-form': () => true,         // The settings page itself is visible; content within is permissioned

        // Permission-controlled sections
        'add-curtailment-form': () => hasPermission('canManageCurtailments'),
        'manual-fleet-form': () => hasPermission('canManageFleet'),
        'data-actions': () => hasPermission('canBackupRestore'),
        'temp-overrides-section': () => hasPermission('canManageOverrides'),
        'sequence-heading-section': () => hasPermission('canManageSeqHeadings'),
        'final-destinations-section': () => hasPermission('canManageFinalDests')
    };

    // 4. Check if the user can access the requested section
    let canAccess = false;
    if (sectionAccessRules.hasOwnProperty(sectionId)) {
        canAccess = sectionAccessRules[sectionId]();
        console.log(`DEBUG: showSection - Access check for ${sectionId}: Allowed = ${canAccess}`);
    } else {
        console.warn(`DEBUG: showSection - No access rule defined for sectionId: ${sectionId}. Denying access by default.`);
        alert(`Error: Access rules for section '${sectionId}' are not defined. Please contact support.`);
        goBackToMainView(); // Go to a safe state
        return;
    }

    if (!canAccess) {
        console.warn(`DEBUG: showSection - Access DENIED for sectionId: ${sectionId} by user ${currentUsername}.`);
        const friendlySectionName = sectionId.replace(/-/g, ' ').replace(/\b(section|form)\b/gi, '').trim();
        alert(`Access Denied: You do not have permission to view the '${friendlySectionName}' page.`);
        // If access is denied, we don't necessarily want to navigate away from the current view if they are already in a section.
        // The button triggering this should ideally be hidden/disabled by `updateElementRoles` if there's no permission.
        return;
    }

    // 5. Hide the main menu buttons container
    if (mainActionsContainer) mainActionsContainer.classList.add('hidden');

    // 6. *** KEY CHANGE: Explicitly hide ALL other main sections ***
    // This list should include all variables pointing to your main section divs
    const allKnownMainSections = [
        addCurtailmentForm, manualFleetForm, settingsForm, dataActionsSection,
        manageCurtailmentsSection, viewAutoTmpSection, // viewAutoTmpSection is in this list
        tempOverridesSection, sequenceHeadingSection, finalDestinationsSection
    ];

    allKnownMainSections.forEach(sec => {
        if (sec && sec.id !== sectionId) { // Important: Don't hide the section we are about to show
            sec.classList.add('hidden');
        }
    });
    // *** END OF KEY CHANGE ***

    // 7. Show the target section and the "Go Back" button
    sectionElement.classList.remove('hidden');
    if (goBackButton) goBackButton.classList.remove('hidden');

    // 8. Update UI elements (like button disabled states) within the now-visible section based on roles/permissions
    updateElementRoles(sectionElement);

    // 9. Clear status messages from all relevant areas to prevent stale messages
    const statusMessages = [
        addCurtailmentMessage, assignStatusElement, revertStatusElement,
        manageCurtailmentsMessage, autoTmpTableMessage,
        curtailmentsBackupStatus, tmpBackupStatus, seqHeadingsBackupStatus, finalDestBackupStatus, pruneStatusMessage, exportAllStatus,
        trackerSettingsMessage, changePasswordMessage, addUserMessage, userManagementMessage, auditLogMessage,
        specificStatusMsg, routeStatusMsg, globalStatusMsg,
        seqHeadingStatusMsg, removeHeadingsStatusMsg, destEditorMessage, bulkDestStatus
    ];
    statusMessages.forEach(el => { if (el) el.textContent = ''; });

    // 10. Perform section-specific initialization (e.g., populate tables, clear forms)
    console.log(`DEBUG: Initialising content for section ${sectionId}.`);
    try {
        switch (sectionId) {
            case 'add-curtailment-form':
                if (hasPermission('canManageCurtailments')) {
                    if(routeInput) routeInput.value = '';
                    if(regNumberInput) regNumberInput.value = '';
                    if(curtailedDestinationInput) curtailedDestinationInput.value = '';
                    if(curtailmentTimeInput) curtailmentTimeInput.value = '';
                    if(routeInput) routeInput.focus();
                }
                break;
            case 'manual-fleet-form':
                displayManualAssignments();
                if (revertSection) revertSection.classList.toggle('hidden', !hasPermission('canManageFleet'));
                if (resetAllSection) resetAllSection.classList.toggle('hidden', !hasPermission('canManageFleet'));
                if (hasPermission('canManageFleet')) {
                    if(manualRegNumberInput) manualRegNumberInput.value = '';
                    if(manualFleetNumberInput) manualFleetNumberInput.value = '';
                    if(revertRegNumberInput) revertRegNumberInput.value = '';
                    if(manualRegNumberInput) manualRegNumberInput.focus();
                }
                break;
            case 'manage-curtailments-section':
                populateManageCurtailmentsTable();
                break;
            case 'view-auto-tmp-section': // <<< For your request
                populateAutoTmpTable();   // This populates the Auto TMP table
                break;
            case 'settings-form':
                if (changeMyPasswordSection) changeMyPasswordSection.classList.remove('hidden');
                // Show/hide subsections based on permissions
                if (trackerSettingsSection) trackerSettingsSection.classList.toggle('hidden', !hasPermission('canManageSettings'));
                if (adminUserManagementSection) adminUserManagementSection.classList.toggle('hidden', !hasPermission('canManageUsers'));
                if (adminAuditLogSection) adminAuditLogSection.classList.toggle('hidden', !hasPermission('canViewAuditLog'));

                // Load data for subsections only if permission is granted
                if (hasPermission('canManageSettings')) { loadTrackerSettings(); }
                if (hasPermission('canManageUsers')) {
                    displayUserManagement();
                    if (addUsernameInput) addUsernameInput.value = '';
                    if (addUserPasswordInput) addUserPasswordInput.value = '';
                    if (addUserRoleSelect) addUserRoleSelect.value = 'user';
                }
                if (hasPermission('canViewAuditLog')) { displayAuditLog(); }
                console.log("--- Checking Settings Sub-sections (from showSection) ---"); // Your log
                console.log("Element trackerSettingsSection:", trackerSettingsSection);
                console.log("Element adminUserManagementSection:", adminUserManagementSection);
                console.log("Element adminAuditLogSection:", adminAuditLogSection);
                console.log("Permission canManageSettings:", hasPermission('canManageSettings'));
                console.log("Permission canManageUsers:", hasPermission('canManageUsers'));
                console.log("Permission canViewAuditLog:", hasPermission('canViewAuditLog'));
                console.log("--- End Settings Checks (from showSection) ---");
                break;
            case 'data-actions':
                updatePruneButtonState(); // Update prune button based on role and time
                break;
            case 'temp-overrides-section':
                displayOverrides();
                if(filterInput) filterInput.value = ''; // Clear temp overrides filter input
                if (hasPermission('canManageOverrides')) { // Clear input fields
                    if(regInput) regInput.value = '';
                    if(specificDestDir1Input) specificDestDir1Input.value = '';
                    if(specificDestDir2Input) specificDestDir2Input.value = '';
                    if(routeIdInput) routeIdInput.value = ''; // This is 'route-override-id'
                    if(routeDestDir1Input) routeDestDir1Input.value = '';
                    if(routeDestDir2Input) routeDestDir2Input.value = '';
                    if(globalDestInput) globalDestInput.value = '';
                }
                break;
            case 'sequence-heading-section':
                displayActiveSequenceHeadings();
                if (hasPermission('canManageSeqHeadings')) { // Clear input fields
                    if(seqHeadingRouteIdInput) seqHeadingRouteIdInput.value = '';
                    if(seqHeadingOutboundInput) seqHeadingOutboundInput.value = '';
                    if(seqHeadingInboundInput) seqHeadingInboundInput.value = '';
                }
                break;
            case 'final-destinations-section':
                populateDestEditor();
                if(destFilterInput) destFilterInput.value = ''; // Clear dest editor filter input
                setDestFilterState('all'); // Reset dest editor button filter to 'All'
                if (hasPermission('canManageFinalDests')) { // Clear input fields
                    if(addDestRouteInput) addDestRouteInput.value = '';
                    if(bulkDestInput) bulkDestInput.value = '';
                }
                break;
            default:
                console.warn(`DEBUG: showSection - No specific initialization logic defined for sectionId: ${sectionId}`);
        }
    } catch (initError) {
        console.error(`DEBUG: Error during initialization of section ${sectionId}:`, initError);
        const friendlySectionName = sectionId.replace(/-/g, ' ').replace(/\b(section|form)\b/gi, '').trim();
        alert(`An error occurred while loading the ${friendlySectionName} page. Please try again or contact support.`);
        goBackToMainView(); // Attempt to return to a stable main menu view
    }
    console.log(`DEBUG: --- showSection for ${sectionId} finished successfully ---`);
}

// --- Audit Log Display/Clear (from tools.html) ---
function displayAuditLog() {
    console.log("DEBUG: displayAuditLog called.");
    if (!hasPermission('canViewAuditLog') || !auditLogDisplay) { console.warn("DEBUG: Cannot display audit log - Permission denied or element missing."); if (auditLogDisplay) auditLogDisplay.innerHTML = '<p>Log cannot be displayed.</p>'; return; }
    auditLogDisplay.innerHTML = ''; if (auditLogMessage) auditLogMessage.textContent = ''; // Clear previous

    try {
        const log = loadFromStorage(auditLogKey, []); if (!Array.isArray(log)) { auditLogDisplay.innerHTML = '<p>Log data is corrupted or not an array.</p>'; console.error("DEBUG: Audit log data is not an array:", log); return; }
        if (log.length === 0) { auditLogDisplay.innerHTML = '<p>Audit log is empty.</p>'; }
        else {
             const escapeHtml = (unsafe) => { if (unsafe === null || typeof unsafe === 'undefined') return ''; return String(unsafe).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); };
             log.forEach(entry => {
                 const logDiv = document.createElement('div'); const time = new Date(entry.timestamp).toLocaleString('en-GB', {});
                 const user = entry.user || 'N/A'; const action = entry.action || '?'; let detailsText = '';
                 // Format details object for display
                 if (entry.details && typeof entry.details === 'object' && Object.keys(entry.details).length > 0) { try { detailsText = JSON.stringify(entry.details, null, 2); } catch { detailsText = '[Unserializable Details]'; } }
                 else if (typeof entry.details === 'string') { detailsText = entry.details; }
                 const safeTime = escapeHtml(time); const safeUser = escapeHtml(user); const safeAction = escapeHtml(action); const safeDetails = escapeHtml(detailsText);
                 logDiv.innerHTML = `<span class="log-timestamp">[${safeTime}]</span> <span class="log-user">${safeUser}</span> <span class="log-action">${safeAction}</span><span class="log-details">${safeDetails ? ` ${safeDetails}` : ''}</span>`;
                 auditLogDisplay.appendChild(logDiv);
             });
        }
    } catch (e) { console.error("DEBUG: Error displaying audit log:", e); auditLogDisplay.innerHTML = '<p style="color:red;">Error displaying log content.</p>'; }
}
function clearAuditLog() {
    console.log("DEBUG: clearAuditLog called.");
    if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert("Admin privileges required."); return;}
    if (confirm("Are you sure you want to clear the ENTIRE Audit Log? This action cannot be undone.")) {
        try {
            localStorage.removeItem(auditLogKey); // Remove the log from storage
            logAdminAction("Audit Log Cleared"); // Log the clearing action itself
            if (auditLogMessage) { auditLogMessage.textContent = "Audit Log cleared successfully."; auditLogMessage.style.color = 'green'; }
            displayAuditLog(); // Refresh the display (will show empty)
            setTimeout(() => { if(auditLogMessage) auditLogMessage.textContent = ''; }, 4000);
        } catch (e) { console.error("Error clearing audit log:", e); if (auditLogMessage) { auditLogMessage.textContent = "Error clearing log."; auditLogMessage.style.color = 'red'; } }
    }
}

// --- End of Merged JavaScript (Part 2) ---
// --- Start of Merged JavaScript (Part 3) ---

// --- Backup & Restore Section Functions (from tools.html, with updated import logic) ---

/**
 * Updates the enabled/disabled state and description text of the Prune button.
 * Now also called by updateElementRoles to ensure state is correct based on role AND time.
 */
function updatePruneButtonState() {
    if (!pruneCurtailmentsButton) {
        console.warn("DEBUG: Prune button not found, cannot update state.");
        return;
    }
    const descElement = pruneDescriptionText; // Use ref defined earlier

    // Always disable and set description if user is not admin
    if (!isLoggedIn || !users[currentUsername] || users[currentUsername].role !== 'admin') {
        pruneCurtailmentsButton.disabled = true;
        pruneCurtailmentsButton.removeAttribute('title'); // Remove any leftover title
        if (descElement) descElement.textContent = 'Admin privileges required for pruning.';
        return;
    }

    // If admin, check time constraint
    const SIX_MONTHS_MS = 182 * 24 * 60 * 60 * 1000; // Approx 6 months (182 days)
    let lastPruneTimestamp = parseInt(loadFromStorage(lastCurtailmentPruneTimestampKey, 0), 10);
    const now = Date.now();

    // Set virtual timestamp if never pruned before, to start the countdown
    if (lastPruneTimestamp === 0) {
        console.log("DEBUG: Pruning never performed. Setting virtual start date to today to begin 6-month countdown.");
        lastPruneTimestamp = now; // Use current time as the virtual "last prune"
        saveToStorage(lastCurtailmentPruneTimestampKey, lastPruneTimestamp); // Save this virtual timestamp
    }

    const timeSinceLastPrune = now - lastPruneTimestamp;
    // isEnabled is true ONLY if time since last (real or virtual) is >= 6 months
    const isEnabled = timeSinceLastPrune >= SIX_MONTHS_MS;

    pruneCurtailmentsButton.disabled = !isEnabled;
    pruneCurtailmentsButton.removeAttribute('title'); // Ensure no default browser title

    // Update description text based on enabled state
    if (descElement) {
        if (isEnabled) {
            descElement.textContent = "Permanently delete curtailment records older than 6 months."; // Removed 'approx'
        } else {
            const timeRemainingMs = SIX_MONTHS_MS - timeSinceLastPrune;
            const daysRemaining = Math.ceil(timeRemainingMs / (24 * 60 * 60 * 1000));
            const displayDays = Math.max(1, daysRemaining); // Show at least 1 day remaining
            const lastDateStr = new Date(lastPruneTimestamp).toLocaleDateString('en-GB');
            // Removed 'approx' from the description text
            descElement.textContent = `Pruning available in ${displayDays} day(s). (Last effective prune date: ${lastDateStr})`;
        }
    }
    console.log(`DEBUG: Prune button state updated. Enabled: ${isEnabled}. Last (real or virtual) prune: ${new Date(lastPruneTimestamp).toISOString()}`);
}

// pruneOldCurtailments() - Initiates modal (Defined in Part 2)

/**
 * Executes the actual pruning logic after password confirmation via modal.
 */

// --- Add this missing function definition ---

/**
 * Initiates the process for pruning old curtailment records.
 * Checks permissions and time constraints before showing the password confirmation modal.
 */
function pruneOldCurtailments() {
    console.log("DEBUG: pruneOldCurtailments called.");

    // 1. Permission Check
    if (!hasPermission('canManageCurtailments')) {
        alert('Permission Denied: Cannot prune curtailments.');
        console.warn(`DEBUG: pruneOldCurtailments denied for user '${currentUsername}'. Missing permission 'canManageCurtailments'.`);
        return; // Stop execution if permission denied
    }

    // 2. Time Constraint Check (Ensure pruning is allowed)
    const SIX_MONTHS_MS = 182 * 24 * 60 * 60 * 1000; // Approx 6 months
    let lastPruneTimestamp = parseInt(loadFromStorage(lastCurtailmentPruneTimestampKey, 0), 10);
    const now = Date.now();
    // Ensure a virtual timestamp exists if never pruned before
    if (lastPruneTimestamp === 0) {
        lastPruneTimestamp = now; // Use current time as the virtual "last prune"
        saveToStorage(lastCurtailmentPruneTimestampKey, lastPruneTimestamp);
    }
    const timeSinceLastPrune = now - lastPruneTimestamp;
    if (timeSinceLastPrune < SIX_MONTHS_MS) {
        alert(`Pruning is only allowed approximately every 6 months. Please wait longer.`);
        console.log("DEBUG: Pruning attempt blocked due to time constraint.");
        return; // Stop if not enough time has passed
    }

    // 3. User Confirmation
    if (confirm('DANGER: This will permanently delete curtailment records older than 6 months. This action cannot be undone. Are you sure?')) {
        // 4. Show Password Modal
        if (!passwordModal || !passwordModalInput || !passwordModalError || !passwordModalPrompt) {
            alert("Error: Password dialog UI elements missing.");
            console.error("DEBUG: Password modal elements missing for prune confirmation.");
            return;
        }
        currentModalAction = 'pruneCurtailments'; // Set the action for the modal confirmation
        passwordModalPrompt.textContent = 'Please enter your password to confirm pruning old curtailments:';
        passwordModalInput.value = '';
        passwordModalError.textContent = '';
        passwordModal.classList.remove('hidden');
        passwordModalInput.focus();
        console.log("DEBUG: Password modal shown for prune confirmation.");
    } else {
        console.log("DEBUG: Pruning cancelled by user confirmation.");
    }
}

// Reminder: The actual pruning logic is in executePruning(), which is called by handleModalConfirm()
// after the password modal is successfully submitted.

function executePruning() {
     console.log("DEBUG: executePruning called.");
     if (pruneStatusMessage) { pruneStatusMessage.textContent = "Pruning old records..."; pruneStatusMessage.style.color = "orange"; }
     if (pruneCurtailmentsButton) pruneCurtailmentsButton.disabled = true; // Ensure button is disabled during processing

     const SIX_MONTHS_MS = 182 * 24 * 60 * 60 * 1000;
     const cutoffTimestamp = Date.now() - SIX_MONTHS_MS;
     let totalDeletedCount = 0; let totalKeptCount = 0; let errorOccurred = false;

     console.log(`DEBUG: Pruning records older than timestamp: ${cutoffTimestamp} (${new Date(cutoffTimestamp).toISOString()})`);

     // Use try...finally to ensure status message clears and button state updates
     try {
         const keysToProcess = [];
         for (let i = 0; i < localStorage.length; i++) {
             const key = localStorage.key(i);
             if (key && key.startsWith("curtailedBusesArray_")) { keysToProcess.push(key); }
         }
         console.log(`DEBUG: Found ${keysToProcess.length} curtailment keys to process.`);

         keysToProcess.forEach(key => {
             try {
                 let data = loadFromStorage(key, []); if (!Array.isArray(data)) { console.warn(`DEBUG: Invalid data format for key ${key}. Skipping.`); return; } // Skip this key
                 const initialCount = data.length;
                 // Filter keeping only items with a valid timestamp >= cutoff
                 const keptData = data.filter(item => item && typeof item.timestamp === 'number' && item.timestamp >= cutoffTimestamp);
                 const deletedForKey = initialCount - keptData.length;

                 if (deletedForKey > 0) {
                     totalDeletedCount += deletedForKey; totalKeptCount += keptData.length;
                     if (keptData.length === 0) { localStorage.removeItem(key); console.log(`DEBUG: Pruned ${deletedForKey} entries from ${key} and removed key.`); }
                     else { saveToStorage(key, keptData); console.log(`DEBUG: Pruned ${deletedForKey} entries from ${key}. Kept ${keptData.length}.`); }
                 } else { totalKeptCount += initialCount; } // All were kept
             } catch (innerError) { console.error(`DEBUG: Error processing key ${key} during prune:`, innerError); errorOccurred = true; }
         });

         // Log and update UI after processing all keys
         const pruneTime = Date.now(); // Use actual time of prune completion
         saveToStorage(lastCurtailmentPruneTimestampKey, pruneTime); // Update the timestamp for next countdown

         if (totalDeletedCount > 0) { logAdminAction("Curtailments Pruned", { deletedCount: totalDeletedCount, cutoff: new Date(cutoffTimestamp).toISOString() }); }

         // Update status message
         if (pruneStatusMessage) {
             if(errorOccurred) { pruneStatusMessage.textContent = `Pruning finished with errors. Removed ${totalDeletedCount} old record(s). Check console.`; pruneStatusMessage.style.color = "red"; }
             else if (totalDeletedCount > 0) { pruneStatusMessage.textContent = `Pruning complete. Removed ${totalDeletedCount} old record(s).`; pruneStatusMessage.style.color = "green"; }
             else { pruneStatusMessage.textContent = "No old records found to prune."; pruneStatusMessage.style.color = "green"; }
         }

     } catch (e) { console.error("DEBUG: Critical error during pruning process:", e); if (pruneStatusMessage) { pruneStatusMessage.textContent = "A critical error occurred during pruning."; pruneStatusMessage.style.color = "red"; } errorOccurred = true; }
     finally {
         updatePruneButtonState(); // Update button state based on the new timestamp/errors
         setTimeout(() => { if (pruneStatusMessage) pruneStatusMessage.textContent = ''; }, 5000);
     }
}

/**
 * Initiates export for all data types sequentially. (from tools.html)
 */
function exportAllData() {
    console.log("DEBUG: exportAllData called.");
    if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) { alert('Access Denied. Moderator or Admin required.'); console.warn(`DEBUG: exportAllData denied for user '${currentUsername}'.`); return; }
    if (exportAllStatus) { exportAllStatus.textContent = 'Initiating all exports...'; exportAllStatus.style.color = 'orange'; }

    // Call existing export functions sequentially
    // User will get multiple download prompts and individual status messages/alerts
    try {
        console.log("DEBUG: Exporting Curtailments..."); exportCurtailments();
        console.log("DEBUG: Exporting Fleet/TMP Map..."); exportTmpMap();
        console.log("DEBUG: Exporting Sequence Headings..."); exportSequenceHeadings();
        console.log("DEBUG: Exporting Final Destinations..."); exportFinalDestinations();

        if (exportAllStatus) { exportAllStatus.textContent = 'Export All process initiated. Check downloads/individual status messages.'; exportAllStatus.style.color = 'green'; setTimeout(() => { if (exportAllStatus) exportAllStatus.textContent = ''; }, 5000); }
        logAdminAction("Data Exported (All Types)");

    } catch (e) { console.error("Error during exportAllData sequence:", e); if (exportAllStatus) { exportAllStatus.textContent = 'Error occurred during Export All sequence. Check console.'; exportAllStatus.style.color = 'red'; setTimeout(() => { if (exportAllStatus) exportAllStatus.textContent = ''; }, 5000); } alert("An error occurred during the Export All process. Some files may not have exported."); }
}

// Helper function for generating timestamped filenames
function generateTimestampedFilename(baseName, extension = "json") {
    const now = new Date();
    const day = now.getDate().toString().padStart(2, '0');
    const month = (now.getMonth() + 1).toString().padStart(2, '0'); // Month is 0-indexed
    const year = now.getFullYear().toString().slice(-2); // Last 2 digits of year
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const seconds = now.getSeconds().toString().padStart(2, '0');
    const timestamp = `${day}${month}${year}-${hours}${minutes}${seconds}`;
    return `${baseName}_${timestamp}.${extension}`;
}

// Helper function for triggering downloads
function triggerDownload(filename, data) {
     const json = JSON.stringify(data, null, 2); // Pretty print JSON
     const blob = new Blob([json], { type: "application/json" });
     const url = URL.createObjectURL(blob);
     const a = document.createElement("a");
     a.href = url;
     a.download = filename;
     document.body.appendChild(a); // Required for Firefox
     a.click();
     document.body.removeChild(a); // Clean up
     URL.revokeObjectURL(url); // Free up memory
}

function exportCurtailments() {
     if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) { alert('Access Denied.'); return; }
     if (curtailmentsBackupStatus) curtailmentsBackupStatus.textContent = ''; let allCurtailments = {}, found = 0;
     try {
         for (let i = 0; i < localStorage.length; i++) { const k = localStorage.key(i); if (k?.startsWith("curtailedBusesArray_")) { const r = k.replace("curtailedBusesArray_", ""); const d = loadFromStorage(k, []); if (Array.isArray(d) && d.length > 0) { allCurtailments[r] = d; found++; } } }
     } catch (e) { if (curtailmentsBackupStatus) { curtailmentsBackupStatus.textContent = 'Error gathering data.'; curtailmentsBackupStatus.style.color='red'; } console.error("Error gathering curtailments:", e); return; }

     if (found === 0) { if (curtailmentsBackupStatus) { curtailmentsBackupStatus.textContent = 'No data found to export.'; curtailmentsBackupStatus.style.color='orange';} alert("No curtailment data to export."); return; }

     try {
         const filename = generateTimestampedFilename("ToolsBackup_Curtailments");
         triggerDownload(filename, allCurtailments);
         logAdminAction("Data Exported", { type: "Curtailments", routesExported: found });
         if (curtailmentsBackupStatus) { curtailmentsBackupStatus.textContent = 'Export successful!'; curtailmentsBackupStatus.style.color='green'; setTimeout(() => { if(curtailmentsBackupStatus) curtailmentsBackupStatus.textContent = ''; }, 4000); }
         try { localStorage.setItem(lastExportKey, Date.now().toString()); if (exportReminderDiv) exportReminderDiv.style.display = 'none'; } catch (e) { console.warn("Could not save last export timestamp");}
     } catch (e) { if (curtailmentsBackupStatus) { curtailmentsBackupStatus.textContent = 'Error exporting file.'; curtailmentsBackupStatus.style.color='red';} alert("Error exporting curtailments."); console.error("Error exporting curtailments:", e); }
}
function handleCurtailmentImport(file) { // MERGE version
    if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin Denied.'); if (importCurtailmentsInput) importCurtailmentsInput.value = ''; return; }
    if (!file) { alert("No file selected."); return; }
    if (curtailmentsBackupStatus) curtailmentsBackupStatus.textContent = '';
    if (!file.name.toLowerCase().endsWith('.json')) { alert("Invalid file type. Please select a JSON file."); return; }

    const r = new FileReader();
    r.onload = function (e) {
        try {
            const imp = JSON.parse(e.target.result);
            if (typeof imp !== 'object' || imp === null || Array.isArray(imp)) { throw new Error("Not valid JSON object (expecting Route -> Array mapping)."); }

            if (!confirm("Importing will MERGE curtailment data.\nNew entries (by timestamp) will be added to existing routes.\nExisting entries with the same timestamp will NOT be overwritten.\nContinue?")) {
                if (importCurtailmentsInput) importCurtailmentsInput.value = ''; return;
            }

            let impC = 0, addedCount = 0, skippedDupes = 0, skippedInvalid = 0, routesProcessed = 0;
            const impKeys = Object.keys(imp);

            for (const route of impKeys) {
                const key = `curtailedBusesArray_${route}`; const importedRouteData = imp[route];
                if (!Array.isArray(importedRouteData)) { console.warn(`Skipping route ${route}: data not an array.`); continue; } routesProcessed++;
                let existingData = loadFromStorage(key, []); if (!Array.isArray(existingData)) { console.warn(`Existing data for route ${route} invalid. Starting fresh.`); existingData = []; }
                const existingTimestamps = new Set(existingData.map(item => item.timestamp).filter(ts => typeof ts === 'number')); // Ensure only numbers in set
                const validImportedEntries = [];

                importedRouteData.forEach(item => { // Validate each imported item
                    if (item && item.route && item.regNumber && item.curtailedDestination && (item.curtailmentTime || item.timestamp)) {
                        if (!item.timestamp || typeof item.timestamp !== 'number' || isNaN(item.timestamp) || item.timestamp <= 0) {
                            if (item.curtailmentTime) { // Attempt parse from string if timestamp missing/invalid
                                try { const parts = item.curtailmentTime.match(/(\d{2})\/(\d{2})\/(\d{4}),?\s*(\d{2}):(\d{2})/); item.timestamp = parts ? new Date(Date.UTC(parts[3], parts[2] - 1, parts[1], parts[4], parts[5])).getTime() : (Date.parse(item.curtailmentTime) || 0); if (isNaN(item.timestamp) || item.timestamp <= 0) { skippedInvalid++; return; } }
                                catch (parseError) { skippedInvalid++; return; }
                            } else { skippedInvalid++; return; } // Skip if no valid timestamp source
                        }
                        // Add if timestamp is valid and unique
                        if (existingTimestamps.has(item.timestamp)) { skippedDupes++; }
                        else { validImportedEntries.push(item); existingTimestamps.add(item.timestamp); } // Add to set to prevent dupes from within file
                    } else { skippedInvalid++; } // Skip invalid structure
                });

                if (validImportedEntries.length > 0) { // Combine and save if new entries were added
                    const mergedData = [...existingData, ...validImportedEntries];
                    mergedData.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); // Sort descending
                    saveToStorage(key, mergedData); addedCount += validImportedEntries.length;
                }
                impC++;
            }
            let msg = `Merge complete for ${impC} route(s).\nAdded ${addedCount} new unique curtailment(s).\n`;
            if (skippedDupes > 0) msg += `Skipped ${skippedDupes} duplicate entry/entries (same timestamp).\n`;
            if (skippedInvalid > 0) msg += `Skipped ${skippedInvalid} invalid/incomplete entry/entries.\n`;
            logAdminAction("Data Merged", { type: "Curtailments", routesProcessed: impC, added: addedCount, skippedDupes: skippedDupes, skippedInvalid: skippedInvalid, fileName: file.name });
            if (curtailmentsBackupStatus) { curtailmentsBackupStatus.textContent = 'Merge complete.'; curtailmentsBackupStatus.style.color='green'; setTimeout(() => curtailmentsBackupStatus.textContent = '', 4000); } alert(msg);
            if (manageCurtailmentsSection && !manageCurtailmentsSection.classList.contains('hidden')) { populateManageCurtailmentsTable(); } // Refresh table if visible
        } catch (err) { console.error("Curtailment Import/Merge Error:", err); if (curtailmentsBackupStatus) { curtailmentsBackupStatus.textContent = `Import Error: ${err.message}`; curtailmentsBackupStatus.style.color='red'; } alert("Import Error: " + err.message); }
        finally { if (importCurtailmentsInput) importCurtailmentsInput.value = ''; } // Clear file input
    };
    r.onerror = function () { if (curtailmentsBackupStatus) { curtailmentsBackupStatus.textContent = 'File Read Error.'; curtailmentsBackupStatus.style.color='red'; } alert("Error reading file."); if (importCurtailmentsInput) importCurtailmentsInput.value = ''; };
    r.readAsText(file);
}
function exportTmpMap() {
console.log("--- RUNNING ENHANCED exportTmpMap ---");
    // Permission checks (keep as is)
    if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) { alert('Access Denied.'); return; }
    if (tmpBackupStatus) tmpBackupStatus.textContent = '';
    console.log("DEBUG: Starting enhanced TMP Map export...");

    try {
        const tmpMap = loadFromStorage(tmpMapKey, {}); // Load Reg -> Fleet map
        const infoMap = loadFromStorage(tmpGenerationInfoKey, {}); // Load Reg -> {route, timestamp} map
        const dataToExport = {}; // Object to hold the combined data
        let exportedCount = 0;

        if (typeof tmpMap === 'object' && tmpMap !== null && Object.keys(tmpMap).length > 0) {
            // Loop through all registrations in the main map
            for (const reg in tmpMap) {
                if (Object.prototype.hasOwnProperty.call(tmpMap, reg)) {
                    const fleetValue = tmpMap[reg];
                    const regInfo = infoMap[reg] || {}; // Get info for this reg, or empty object if not found

                    // Create an entry with all details
                    dataToExport[reg] = {
                        fleet: fleetValue,
                        route: regInfo.route || null, // Use saved route or null
                        timestamp: regInfo.timestamp || null // Use saved timestamp or null
                    };
                    exportedCount++;
                }
            }
        }

        if (exportedCount === 0) {
            // No data found message (keep as is)
            if (tmpBackupStatus) { tmpBackupStatus.textContent = 'No data found to export.'; tmpBackupStatus.style.color='orange';}
            alert("No Fleet/TMP data to export.");
            return;
        }

        // Export the combined data
        const filename = generateTimestampedFilename("ToolsBackup_FleetTMP"); // New filename indicates richer format
        triggerDownload(filename, dataToExport);
        logAdminAction("Data Exported", { type: "Fleet/TMP (Enhanced)", count: exportedCount });
        if (tmpBackupStatus) { tmpBackupStatus.textContent = 'Enhanced export successful!'; tmpBackupStatus.style.color='green'; setTimeout(() => { if (tmpBackupStatus) tmpBackupStatus.textContent = ''; }, 4000); }

    } catch (e) {
        // Error handling (keep as is)
        if (tmpBackupStatus) { tmpBackupStatus.textContent = 'Export error.'; tmpBackupStatus.style.color='red';}
        alert("Export error: " + e.message);
        console.error("Error exporting enhanced TMP map:", e);
    }
}
function handleTmpImport(file) { // MERGE version - Enhanced Format
    // Permission checks, file checks (keep as is)
    if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin Denied.'); if (importTmpInput) importTmpInput.value = ''; return; }
    if (!file) { alert("No file selected."); return; }
    if (tmpBackupStatus) tmpBackupStatus.textContent = '';
    if (!file.name.toLowerCase().endsWith('.json')) { alert("Invalid file type..."); if (importTmpInput) importTmpInput.value = ''; return; }

    console.log("DEBUG: Starting enhanced TMP Map import...");

    const r = new FileReader();
    r.onload = function (e) {
        try {
            const importedData = JSON.parse(e.target.result);
            // Validate imported data structure (expecting an object)
            if (typeof importedData !== 'object' || importedData === null || Array.isArray(importedData)) {
                throw new Error("Imported file is not a valid JSON object (expecting Registration -> {fleet, route, timestamp} mapping).");
            }

            const regsToProcess = Object.keys(importedData);
            if (regsToProcess.length === 0) {
                throw new Error("No registration entries found in the imported file.");
            }

            // Confirmation dialog (keep as is, maybe update text slightly)
            if (!confirm(`Importing will MERGE the Fleet/TMP map AND associated Route/Date info.\nData from the file will OVERWRITE existing entries for the same registration.\n(${regsToProcess.length} registrations found).\nContinue?`)) {
                if (importTmpInput) importTmpInput.value = ''; return;
            }

            // Load existing data
            let existingTmpMap = loadFromStorage(tmpMapKey, {});
            if (typeof existingTmpMap !== 'object' || existingTmpMap === null) { existingTmpMap = {}; }
            let existingInfoMap = loadFromStorage(tmpGenerationInfoKey, {});
            if (typeof existingInfoMap !== 'object' || existingInfoMap === null) { existingInfoMap = {}; }

            let importedCount = 0;
            let updatedInfoCount = 0;

            // Process each registration from the imported file
            for (const reg in importedData) {
                if (Object.prototype.hasOwnProperty.call(importedData, reg)) {
                    const entryData = importedData[reg];
                    const upperReg = reg.toUpperCase(); // Use uppercase for consistency

                    // Check if the imported entry has the expected structure (at least a 'fleet' string)
                    if (typeof entryData === 'object' && entryData !== null && typeof entryData.fleet === 'string') {
                        // Update/Add to the main Fleet/TMP map
                        existingTmpMap[upperReg] = entryData.fleet;
                        importedCount++;

                        // Update/Add to the Generation Info map if route or timestamp exists
                        if (entryData.route || entryData.timestamp) {
                            // Determine type based on fleet prefix (or set to 'Manual'/'Imported' if needed)
                            const type = entryData.fleet.startsWith('TMP') ? 'TMP' : (entryData.fleet.startsWith('ERR') ? 'ERR' : 'Manual');
                            existingInfoMap[upperReg] = {
                                type: type,
                                route: entryData.route || null,
                                timestamp: entryData.timestamp || null
                            };
                            updatedInfoCount++;
                        } else {
                            // Optional: If the imported entry for a REG has NO route/date,
                            // you might want to remove any old route/date info for that REG.
                            // delete existingInfoMap[upperReg];
                            console.warn(`Imported data for ${upperReg} lacks route/timestamp info.`);
                        }
                    } else {
                        console.warn(`Skipping invalid entry for registration ${reg}. Expected object with 'fleet' property.`);
                    }
                }
            }

            // Save BOTH maps back to localStorage if any valid entries were processed
            if (importedCount > 0) {
                saveToStorage(tmpMapKey, existingTmpMap);
                saveToStorage(tmpGenerationInfoKey, existingInfoMap);

                logAdminAction("Data Merged", { type: "Fleet/TMP (Enhanced)", importedRegs: importedCount, updatedInfo: updatedInfoCount, fileName: file.name });
                if (tmpBackupStatus) { tmpBackupStatus.textContent = 'Enhanced merge complete!'; tmpBackupStatus.style.color='green'; setTimeout(() => tmpBackupStatus.textContent = '', 4000); }
                alert(`Merged ${importedCount} assignments. Associated route/date info updated for ${updatedInfoCount}.`);

                // Refresh relevant UI if visible
                if (manualFleetForm && !manualFleetForm.classList.contains('hidden')) { displayManualAssignments(); }
                if (viewAutoTmpSection && !viewAutoTmpSection.classList.contains('hidden')) { populateAutoTmpTable(); } // Refresh Auto TMP table

            } else {
                alert("No valid assignments could be imported from the file.");
                if (tmpBackupStatus) { tmpBackupStatus.textContent = 'Import failed: No valid data.'; tmpBackupStatus.style.color = 'red'; }
            }

        } catch (err) {
            // Error handling (keep as is)
            console.error("Enhanced TMP Import/Merge Error:", err);
            if (tmpBackupStatus) { tmpBackupStatus.textContent = `Import Error: ${err.message}`; tmpBackupStatus.style.color='red';}
            alert("Import error: " + err.message);
        } finally {
            if (importTmpInput) importTmpInput.value = '';
        }
    };
    r.onerror = function () { /* ... keep error handling ... */ };
    r.readAsText(file);
}
function exportSequenceHeadings() {
     if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) { alert('Access Denied.'); return; }
     if (seqHeadingsBackupStatus) seqHeadingsBackupStatus.textContent = ''; let allHeadings = {}, found = 0;
     try { for (let i = 0; i < localStorage.length; i++) { const k = localStorage.key(i); if (k?.startsWith(sequenceHeadingOverrideBaseKey)) { const r = k.substring(sequenceHeadingOverrideBaseKey.length); const d = loadFromStorage(k, null); if (d && typeof d === 'object') { allHeadings[r] = d; found++; } } } }
     catch (e) { if (seqHeadingsBackupStatus) { seqHeadingsBackupStatus.textContent = 'Error gathering data.'; seqHeadingsBackupStatus.style.color='red';} console.error("Error gathering headings:", e); return; }
     if (found === 0) { if (seqHeadingsBackupStatus) { seqHeadingsBackupStatus.textContent = 'No data found to export.'; seqHeadingsBackupStatus.style.color='orange';} alert("No sequence headings found to export."); return; }
     try { const filename = generateTimestampedFilename("ToolsBackup_SeqHeadings"); triggerDownload(filename, allHeadings); logAdminAction("Data Exported", { type: "Sequence Headings", count: found }); if (seqHeadingsBackupStatus) { seqHeadingsBackupStatus.textContent = 'Export successful!'; seqHeadingsBackupStatus.style.color='green'; setTimeout(() => seqHeadingsBackupStatus.textContent = '', 4000); } }
     catch (e) { if (seqHeadingsBackupStatus) { seqHeadingsBackupStatus.textContent = 'Export error.'; seqHeadingsBackupStatus.style.color='red';} alert("Export error."); console.error("Error exporting headings:", e);}
}
function handleSequenceHeadingsImport(file) { // MERGE version
    if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin Denied.'); if (importSeqHeadingsInput) importSeqHeadingsInput.value = ''; return; }
    if (!file) { alert("No file selected."); return; }
    if (seqHeadingsBackupStatus) seqHeadingsBackupStatus.textContent = '';
    if (!file.name.toLowerCase().endsWith('.json')) { alert("Invalid file type."); if (importSeqHeadingsInput) importSeqHeadingsInput.value = ''; return; }

    const r = new FileReader();
    r.onload = function (e) {
        try {
            let importedData = JSON.parse(e.target.result); if (typeof importedData !== 'object' || importedData === null || Array.isArray(importedData)) { throw new Error("Not valid map/object format (expecting Route -> {outbound, inbound} mapping)."); }
            let validRoutes = 0, invalidRoutes = 0;
            for (const rt in importedData) { if (Object.prototype.hasOwnProperty.call(importedData, rt)) { const d = importedData[rt]; if (typeof d === 'object' && d !== null && (typeof d.outbound === 'string' || typeof d.inbound === 'string')) { if (d.outbound !== undefined && typeof d.outbound !== 'string') d.outbound = String(d.outbound); if (d.inbound !== undefined && typeof d.inbound !== 'string') d.inbound = String(d.inbound); validRoutes++; } else { console.warn(`Removing invalid heading data for route ${rt}.`); delete importedData[rt]; invalidRoutes++; } } }
            if (invalidRoutes > 0) { alert(`Warning: Skipped ${invalidRoutes} invalid route entries.`); } if (validRoutes === 0) { throw new Error("No valid entries found."); }

            if (!confirm(`Importing will MERGE sequence headings.\nHeadings from file will OVERWRITE existing ones for the same route.\n(${validRoutes} valid routes found).\nContinue?`)) {
                 if (importSeqHeadingsInput) importSeqHeadingsInput.value = ''; return;
            }

            let routesMerged = 0;
            for (const rt in importedData) { if (Object.prototype.hasOwnProperty.call(importedData, rt)) { const key = sequenceHeadingOverrideBaseKey + rt; const importedRouteHeadings = importedData[rt]; let existingHeadings = loadFromStorage(key, {}); if (typeof existingHeadings !== 'object' || existingHeadings === null) { existingHeadings = {}; } const mergedHeadings = Object.assign({}, existingHeadings, importedRouteHeadings); // Imported overwrites existing for same key (inbound/outbound)
                  if ((!mergedHeadings.outbound || mergedHeadings.outbound.trim() === '') && (!mergedHeadings.inbound || mergedHeadings.inbound.trim() === '')) { localStorage.removeItem(key); } else { saveToStorage(key, mergedHeadings); routesMerged++; } } }

            logAdminAction("Data Merged", { type: "Sequence Headings", routesProcessed: validRoutes, routesSaved: routesMerged, fileName: file.name });
            if (seqHeadingsBackupStatus) { seqHeadingsBackupStatus.textContent = 'Merge complete!'; seqHeadingsBackupStatus.style.color='green'; setTimeout(() => seqHeadingsBackupStatus.textContent = '', 4000); } alert(`Merged sequence headings for ${routesMerged} route(s).`);
            // Refresh UI if the sequence heading section is currently visible
             if (sequenceHeadingSection && !sequenceHeadingSection.classList.contains('hidden') && typeof displayActiveSequenceHeadings === 'function') { displayActiveSequenceHeadings(); }
        } catch (err) { console.error("Sequence Heading Import/Merge Error:", err); if (seqHeadingsBackupStatus) { seqHeadingsBackupStatus.textContent = `Import Error: ${err.message}`; seqHeadingsBackupStatus.style.color='red';} alert("Import error: " + err.message); }
        finally { if (importSeqHeadingsInput) importSeqHeadingsInput.value = ''; }
    };
    r.onerror = function () { if (seqHeadingsBackupStatus) { seqHeadingsBackupStatus.textContent = 'File Read Error.'; seqHeadingsBackupStatus.style.color='red'; } alert("Error reading file."); if (importSeqHeadingsInput) importSeqHeadingsInput.value = ''; };
    r.readAsText(file);
}
function exportFinalDestinations() {
     if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) { alert('Access Denied.'); return; }
     if (finalDestBackupStatus) finalDestBackupStatus.textContent = '';
     try { const data = loadFromStorage(routeDestinationSettingsKey, {}); if (typeof data !== 'object' || data === null || Object.keys(data).length === 0) { if (finalDestBackupStatus) { finalDestBackupStatus.textContent = 'No data found to export.'; finalDestBackupStatus.style.color='orange';} alert("No final destination data to export."); return; } const count = Object.keys(data).length; const filename = generateTimestampedFilename("ToolsBackup_FinalDests"); triggerDownload(filename, data); logAdminAction("Data Exported", { type: "Final Destinations", count }); if (finalDestBackupStatus) { finalDestBackupStatus.textContent = 'Export successful!'; finalDestBackupStatus.style.color='green'; setTimeout(() => finalDestBackupStatus.textContent = '', 4000); } }
     catch (e) { if (finalDestBackupStatus) { finalDestBackupStatus.textContent = 'Export error.'; finalDestBackupStatus.style.color='red';} alert("Error exporting."); console.error("Error exporting final destinations:", e);}
}
function handleFinalDestinationsImport(file) { // MERGE version
    if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin Denied.'); if (importFinalDestInput) importFinalDestInput.value = ''; return; }
    if (!file) { alert("No file selected."); return; }
    if (finalDestBackupStatus) finalDestBackupStatus.textContent = '';
    if (!file.name.toLowerCase().endsWith('.json')) { alert("Invalid file type."); if (importFinalDestInput) importFinalDestInput.value = ''; return; }

    const r = new FileReader();
    r.onload = function (e) {
        try {
            const importedData = JSON.parse(e.target.result); if (typeof importedData !== 'object' || importedData === null || Array.isArray(importedData)) { throw new Error("Not valid map/object format (expecting Route -> Array)."); }
            let validRoutes = 0, invalidRoutes = 0, invalidEntries = 0;
            for (const rt in importedData) { if (Object.prototype.hasOwnProperty.call(importedData, rt)) { if (!Array.isArray(importedData[rt])) { console.warn(`Removing invalid dest data for route ${rt}: Not an array.`); delete importedData[rt]; invalidRoutes++; } else { const originalLength = importedData[rt].length; importedData[rt] = importedData[rt].filter(dest => typeof dest === 'string' && dest.trim().length > 0); const removedCount = originalLength - importedData[rt].length; if (removedCount > 0) { invalidEntries += removedCount; console.warn(`Removed ${removedCount} invalid dests for route ${rt}.`); } if (importedData[rt].length > 0) { validRoutes++; } else { console.warn(`Removing route ${rt}: no valid dests.`); delete importedData[rt]; invalidRoutes++; } } } }
            if (invalidRoutes > 0 || invalidEntries > 0) { alert(`Warning: Skipped ${invalidRoutes} invalid routes and ${invalidEntries} invalid dest entries.`); } if (validRoutes === 0) { throw new Error("No valid Route -> Destination Array entries found."); }

            if (!confirm(`Importing will MERGE final destinations.\nDestinations from file will be ADDED to existing lists (duplicates ignored).\n(${validRoutes} valid routes found).\nContinue?`)) {
                if (importFinalDestInput) importFinalDestInput.value = ''; return;
            }

            let existingSettings = loadFromStorage(routeDestinationSettingsKey, {}); if (typeof existingSettings !== 'object' || existingSettings === null) { existingSettings = {}; }
            let routesTouched = 0, destinationsAdded = 0;

            for (const routeId in importedData) { if (Object.prototype.hasOwnProperty.call(importedData, routeId)) { routesTouched++; const importedDests = importedData[routeId]; const existingDests = existingSettings[routeId] || []; if (!Array.isArray(existingDests)) { console.warn(`Existing data for ${routeId} not array. Overwriting.`); existingSettings[routeId] = importedDests; destinationsAdded += importedDests.length; continue; } const combinedSet = new Set(existingDests.map(d => d.toLowerCase())); let addedForRoute = 0; importedDests.forEach(impDest => { if (!combinedSet.has(impDest.toLowerCase())) { existingDests.push(impDest); combinedSet.add(impDest.toLowerCase()); addedForRoute++; } }); destinationsAdded += addedForRoute; existingSettings[routeId] = existingDests.sort((a,b) => a.localeCompare(b)); } }

            saveToStorage(routeDestinationSettingsKey, existingSettings);
            logAdminAction("Data Merged", { type: "Final Destinations", routesProcessed: validRoutes, routesTouched: routesTouched, destinationsAdded: destinationsAdded, fileName: file.name });
            if (finalDestBackupStatus) { finalDestBackupStatus.textContent = 'Merge complete!'; finalDestBackupStatus.style.color='green'; setTimeout(() => finalDestBackupStatus.textContent = '', 4000); } alert(`Merged final destinations. Added ${destinationsAdded} new unique destinations across ${routesTouched} route(s).`);
            // Refresh UI if visible
             if (finalDestinationsSection && !finalDestinationsSection.classList.contains('hidden') && typeof populateDestEditor === 'function') { populateDestEditor(); }
        } catch (err) { console.error("Final Destination Import/Merge Error:", err); if (finalDestBackupStatus) { finalDestBackupStatus.textContent = `Import Error: ${err.message}`; finalDestBackupStatus.style.color='red'; } alert("Import error: " + err.message); }
        finally { if (importFinalDestInput) importFinalDestInput.value = ''; }
    };
    r.onerror = function () { if (finalDestBackupStatus) { finalDestBackupStatus.textContent = 'File Read Error.'; finalDestBackupStatus.style.color='red';} alert("Error reading file."); if (importFinalDestInput) importFinalDestInput.value = ''; };
    r.readAsText(file);
}


// --- Temporary Override Functions (Copied from iBusDest) ---
// (displayOverrides, setRegistrationOverride, setRouteOverride, setGlobalOverride, clearGlobalOverride, removeOverride)
// These functions should now work within the tools.html context using shared helpers/globals
// --- Replace the incomplete 'function displayOverrides' line with this complete function ---

/**
 * Displays the list of currently active temporary destination overrides.
 * Filters the list based on the filter input field.
 * Adds permission attributes to remove buttons.
 */
function displayOverrides() {
    // Get references to UI elements
    const overridesListDiv = getElement('overrides-list');
    const filterInput = getElement('filter-overrides'); // Filter input for this list

    // Ensure elements exist
    if (!overridesListDiv || !filterInput) {
        console.warn("DEBUG: Override display elements missing (list or filter input).");
        if (overridesListDiv) overridesListDiv.innerHTML = '<p style="color:red;">UI Error: List display unavailable.</p>';
        return;
    }

    // Load current overrides from storage
    const overrides = loadFromStorage(destinationOverrideKey, {});
    overridesListDiv.innerHTML = ''; // Clear previous list content
    const filterText = filterInput.value.trim().toUpperCase(); // Get filter text
    let itemsDisplayed = 0; // Counter for visible items

    // --- Display Global Override (if set and matches filter) ---
    if (overrides.hasOwnProperty('*')) {
        const globalDest = overrides['*'] || ''; // Default to empty string
        const globalDestUpper = globalDest.toUpperCase();
        // Check if filter is empty OR 'GLOBAL OVERRIDE' matches OR the destination text matches
        if (!filterText || 'GLOBAL OVERRIDE'.includes(filterText) || globalDestUpper.includes(filterText)) {
            const itemDiv = document.createElement('div');
            itemDiv.dataset.key = '*'; // Store key for removal

            const textSpan = document.createElement('span');
            // Use escapeHtml for safety
            textSpan.innerHTML = `<strong class="global-key">GLOBAL OVERRIDE:</strong> ${escapeHtml(globalDest)}`;

            const removeBtn = document.createElement('button');
            removeBtn.textContent = 'Remove';
            removeBtn.className = 'danger-button'; // Style as danger
            removeBtn.type = 'button';
            removeBtn.onclick = () => removeOverride('*'); // Call remove function with '*' key
            // Add the required permission attribute
            removeBtn.setAttribute('data-permission', 'canManageOverrides');

            itemDiv.appendChild(textSpan);
            itemDiv.appendChild(removeBtn);
            overridesListDiv.appendChild(itemDiv);
            itemsDisplayed++;
        }
    }

    // --- Display Other Overrides (Reg/Route, sorted) ---
    const otherKeys = Object.keys(overrides).filter(k => k !== '*').sort(); // Get non-global keys and sort them

    otherKeys.forEach(key => {
        const value = overrides[key];
        let matchesFilter = false;
        let itemHTML = ''; // HTML content for the override display
        const keyUpper = key.toUpperCase();

        // Basic check if key looks like a registration number (improve regex if needed)
        const isReg = /^[A-Z]{1,3}\d{1,4}$|^[A-Z]{2}\d{2}[A-Z]{3}$|^[A-Z]\d{1,3}[A-Z]{3}$/i.test(key);
        const prefix = isReg ? 'Reg ' : 'Route '; // Prefix for clarity

        // Check if the value is the directional object {dir1: '...', dir2: '...'}
        if (typeof value === 'object' && value !== null && value.hasOwnProperty('dir1') && value.hasOwnProperty('dir2')) {
            const destDir1 = value.dir1 || ''; // Default to empty string
            const destDir2 = value.dir2 || '';
            const destDir1Upper = destDir1.toUpperCase();
            const destDir2Upper = destDir2.toUpperCase();

            // Check if the key OR either destination matches the filter text
            matchesFilter = !filterText || keyUpper.includes(filterText) || destDir1Upper.includes(filterText) || destDir2Upper.includes(filterText);

            if (matchesFilter) {
                // Format display string, using escapeHtml for safety
                const dir1Display = destDir1 ? escapeHtml(destDir1) : '<em>(Not Set)</em>';
                const dir2Display = destDir2 ? escapeHtml(destDir2) : '<em>(Not Set)</em>';
                itemHTML = `<strong>${prefix}${escapeHtml(key)}:</strong> <span class="dest-dir">Dir 1:</span> ${dir1Display} | <span class="dest-dir">Dir 2:</span> ${dir2Display}`;
            }
        }
        // Add handling here if you need to support older simple string overrides (unlikely if using newer functions)
        // else if (typeof value === 'string') { ... }

        // If the item matches the filter, create and add its display element
        if (matchesFilter) {
            const itemDiv = document.createElement('div');
            itemDiv.dataset.key = key; // Store key for removal

            const textSpan = document.createElement('span');
            textSpan.innerHTML = itemHTML; // Set the formatted HTML

            const removeBtn = document.createElement('button');
            removeBtn.textContent = 'Remove';
            removeBtn.className = 'danger-button';
            removeBtn.type = 'button';
            removeBtn.onclick = () => removeOverride(key); // Call remove function with specific key
            // Add the required permission attribute
            removeBtn.setAttribute('data-permission', 'canManageOverrides');

            itemDiv.appendChild(textSpan);
            itemDiv.appendChild(removeBtn);
            overridesListDiv.appendChild(itemDiv);
            itemsDisplayed++;
        }
    });

    // Display message if no overrides are shown (either none exist or filter hides all)
    if (itemsDisplayed === 0) {
        overridesListDiv.innerHTML = filterText
            ? '<p class="filter-placeholder">No overrides match your filter.</p>'
            : '<p>No destination overrides currently set.</p>';
    } else {
        // If items were displayed, run updateElementRoles on the list container
        // This ensures the dynamically added remove buttons get the correct enabled/disabled state
        updateElementRoles(overridesListDiv);
    }
}
function setRegistrationOverride() { /* ... Implementation from iBusDest ... */
    // Permission already checked by button state via updateElementRoles
    const reg = regInput.value.trim().toUpperCase(); // Use specific ref for this section
    const destDir1 = specificDestDir1Input.value.trim();
    const destDir2 = specificDestDir2Input.value.trim();
    if(specificStatusMsg) specificStatusMsg.textContent = '';
    if (!reg) { alert('Please enter the Bus Registration.'); regInput.focus(); return; }
    if (!destDir1 && !destDir2) { alert('Please enter a destination for at least one direction.'); specificDestDir1Input.focus(); return; }
    // Basic format check (optional, example)
     // if (!/^[A-Z]{1,3}\d{1,4}$|^[A-Z]{2}\d{2}[A-Z]{3}$|^[A-Z]\d{1,3}[A-Z]{3}$/i.test(reg)) { alert('Invalid registration format.'); regInput.focus(); return; }
    try {
        let overrides = loadFromStorage(destinationOverrideKey, {});
        overrides[reg] = { dir1: destDir1, dir2: destDir2 }; // Store as object
        saveToStorage(destinationOverrideKey, overrides);
        if(specificStatusMsg) { specificStatusMsg.textContent = `Directional override updated for ${reg}.`; specificStatusMsg.style.color = 'green'; setTimeout(() => { if(specificStatusMsg) specificStatusMsg.textContent = ''; }, 4000); }
        regInput.value = ''; specificDestDir1Input.value = ''; specificDestDir2Input.value = ''; // Clear inputs
        regInput.focus(); displayOverrides(); // Refresh list
    } catch (e) { console.error("Error setting registration override:", e); if(specificStatusMsg) { specificStatusMsg.textContent = "Error saving override."; specificStatusMsg.style.color = 'red'; } }
}
function setRouteOverride() { /* ... Implementation from iBusDest ... */
    // Permission check by button state
    const routeId = routeIdInput.value.trim().toUpperCase(); // Use specific ref
    const destDir1 = routeDestDir1Input.value.trim();
    const destDir2 = routeDestDir2Input.value.trim();
    if(routeStatusMsg) routeStatusMsg.textContent = '';
    if (!routeId) { alert('Please enter the Route.'); routeIdInput.focus(); return; }
    if (!destDir1 && !destDir2) { alert('Please enter a destination for at least one direction.'); routeDestDir1Input.focus(); return; }
    // Basic format check (optional)
     // if (!/^[A-Z0-9]+$/i.test(routeId) || routeId.length > 5) { alert('Invalid Route ID format.'); routeIdInput.focus(); return; }
    try {
        let overrides = loadFromStorage(destinationOverrideKey, {});
        overrides[routeId] = { dir1: destDir1, dir2: destDir2 }; // Store as object
        saveToStorage(destinationOverrideKey, overrides);
        if(routeStatusMsg) { routeStatusMsg.textContent = `Directional override updated for Route ${routeId}.`; routeStatusMsg.style.color = 'green'; setTimeout(() => { if(routeStatusMsg) routeStatusMsg.textContent = ''; }, 4000); }
        routeIdInput.value = ''; routeDestDir1Input.value = ''; routeDestDir2Input.value = ''; // Clear inputs
        routeIdInput.focus(); displayOverrides(); // Refresh list
    } catch (e) { console.error("Error setting route override:", e); if(routeStatusMsg) { routeStatusMsg.textContent = "Error saving override."; routeStatusMsg.style.color = 'red'; } }
}
function setGlobalOverride() { /* ... Implementation from iBusDest ... */
    // Permission check by button state
    const dest = globalDestInput.value.trim();
    if(globalStatusMsg) globalStatusMsg.textContent = '';
    if (!dest) { alert('Please enter the Global Message/Destination.'); globalDestInput.focus(); return; }
    try {
        let overrides = loadFromStorage(destinationOverrideKey, {});
        overrides['*'] = dest; // Use '*' as key for global
        saveToStorage(destinationOverrideKey, overrides);
        if(globalStatusMsg) { globalStatusMsg.textContent = `Global override set to "${dest}".`; globalStatusMsg.style.color = 'green'; setTimeout(() => { if(globalStatusMsg) globalStatusMsg.textContent = ''; }, 4000); }
        globalDestInput.value = ''; // Clear input
        displayOverrides(); // Refresh list
    } catch (e) { console.error("Error setting global override:", e); if(globalStatusMsg) { globalStatusMsg.textContent = "Error saving override."; globalStatusMsg.style.color = 'red'; } }
}
function clearGlobalOverride() { /* ... Implementation from iBusDest ... */
    // Permission check by button state
    if (!confirm(`Are you sure you want to remove the Global destination override?`)) { return; }
    removeOverride('*'); // Call the common remove function
}
// --- Replace the existing removeOverride function ---
function removeOverride(keyToRemove) {
    // *** ADDED Permission Check ***
    if (!hasPermission('canManageOverrides')) {
        alert('Permission Denied: Cannot remove overrides.');
        console.warn(`DEBUG: removeOverride denied for user '${currentUsername}'. Missing permission 'canManageOverrides'.`);
        return;
    }

    // Confirmation prompt
    // Use slightly different confirmation for global vs specific
    const confirmMessage = keyToRemove === '*'
        ? `Are you sure you want to remove the Global destination override?`
        : `Are you sure you want to remove the override for "${keyToRemove}"?`;

    if (!confirm(confirmMessage)) {
        console.log(`DEBUG: Removal of override for key "${keyToRemove}" cancelled by user.`);
        return; // Stop if user cancels
    }

    const overrides = loadFromStorage(destinationOverrideKey, {});
    // Clear relevant status message(s)
    [specificStatusMsg, routeStatusMsg, globalStatusMsg].forEach(el => { if(el) el.textContent = ''; });

    try {
        if (overrides.hasOwnProperty(keyToRemove)) {
            const removedValue = overrides[keyToRemove]; // Get value for logging
            delete overrides[keyToRemove]; // Remove the key from the object
            saveToStorage(destinationOverrideKey, overrides); // Save the modified object
            logAdminAction("Override Removed", { key: keyToRemove, removedValue: removedValue }); // Log action
            console.log(`Override removed for key: ${keyToRemove}.`);

            // Show status message in the appropriate place
            if (keyToRemove === '*' && globalStatusMsg) {
                globalStatusMsg.textContent = 'Global override removed.';
                globalStatusMsg.style.color = 'green';
                setTimeout(() => { if(globalStatusMsg) globalStatusMsg.textContent = ''; }, 4000);
            } else if (keyToRemove !== '*') {
                 // For specific/route overrides, just refreshing the list is usually enough feedback
                 console.log(`Specific/Route override removed for ${keyToRemove}. List refreshed.`);
                 // Optionally add a temporary message to specificStatusMsg or routeStatusMsg if needed
            }
            displayOverrides(); // Refresh list is the main feedback
        } else {
            // Key wasn't found in the overrides object
            console.warn(`Override key "${keyToRemove}" not found.`);
            if(keyToRemove === '*' && globalStatusMsg) {
                globalStatusMsg.textContent = 'No Global override was set.';
                globalStatusMsg.style.color = 'orange';
                setTimeout(() => { if(globalStatusMsg) globalStatusMsg.textContent = ''; }, 4000);
            } else {
                 // Optionally alert if a specific/route key wasn't found, though unlikely if triggered from list
                 // alert(`Override for "${keyToRemove}" not found.`);
            }
        }
    } catch(e) {
        console.error("Error removing override:", e);
        alert("Error removing override.");
        // Display error in a relevant status message if possible
        if (globalStatusMsg) { // Use global as a fallback
             globalStatusMsg.textContent = "Error removing override.";
             globalStatusMsg.style.color = 'red';
        }
    }
}


// --- Sequence Heading Functions (Copied from iBusDest) ---
// (loadCurrentSequenceHeadings, setRouteSequenceHeadings, clearRouteSequenceHeadings, displayActiveSequenceHeadings, handleSelectAllHeadings, removeSelectedSequenceHeadings)
// These should work using shared helpers and globals
function loadCurrentSequenceHeadings() { /* ... Implementation from iBusDest ... */
    const routeId = seqHeadingRouteIdInput.value.trim().toUpperCase();
    // Clear outputs if routeId is cleared
    if (!routeId) { seqHeadingOutboundInput.value = ''; seqHeadingInboundInput.value = ''; return; }
    const key = sequenceHeadingOverrideBaseKey + routeId;
    const savedHeadings = loadFromStorage(key, null); // Load specific key
    if (savedHeadings && typeof savedHeadings === 'object') {
         seqHeadingOutboundInput.value = savedHeadings.outbound || '';
         seqHeadingInboundInput.value = savedHeadings.inbound || '';
    } else { // No saved data or invalid format
         seqHeadingOutboundInput.value = '';
         seqHeadingInboundInput.value = '';
    }
}
function setRouteSequenceHeadings() { /* ... Implementation from iBusDest ... */
    // Permission check by button state
    const routeId = seqHeadingRouteIdInput.value.trim().toUpperCase();
    const outbound = seqHeadingOutboundInput.value.trim();
    const inbound = seqHeadingInboundInput.value.trim();
    if(seqHeadingStatusMsg) seqHeadingStatusMsg.textContent = '';
    if (!routeId) { alert("Please enter a Route ID."); seqHeadingRouteIdInput.focus(); return; }
    if (!outbound && !inbound) { alert("Please enter at least one heading (Outbound or Inbound)."); seqHeadingOutboundInput.focus(); return; }
    try {
        const key = sequenceHeadingOverrideBaseKey + routeId;
        const headings = { outbound: outbound, inbound: inbound };
        saveToStorage(key, headings);
        if(seqHeadingStatusMsg) { seqHeadingStatusMsg.textContent = `Headings for Route ${routeId} saved.`; seqHeadingStatusMsg.style.color = 'green'; setTimeout(() => { if(seqHeadingStatusMsg) seqHeadingStatusMsg.textContent = ''; }, 3000); }
        // Don't clear inputs, allow edits
        displayActiveSequenceHeadings(); // Refresh the list
    } catch (e) { console.error("Error setting sequence headings:", e); if(seqHeadingStatusMsg) { seqHeadingStatusMsg.textContent = "Error saving headings."; seqHeadingStatusMsg.style.color = 'red'; } }
}
function clearRouteSequenceHeadings() { /* ... Implementation from iBusDest ... */
    // Permission check by button state (Admin only)
    const routeId = seqHeadingRouteIdInput.value.trim().toUpperCase();
    if(seqHeadingStatusMsg) seqHeadingStatusMsg.textContent = '';
    if (!routeId) { alert("Please enter a Route ID to clear headings for."); seqHeadingRouteIdInput.focus(); return; }
    const key = sequenceHeadingOverrideBaseKey + routeId;
    if (!localStorage.getItem(key)) { // Check if override actually exists
        if(seqHeadingStatusMsg) { seqHeadingStatusMsg.textContent = `No saved headings found for Route ${routeId}.`; seqHeadingStatusMsg.style.color = 'orange'; setTimeout(() => { if(seqHeadingStatusMsg) seqHeadingStatusMsg.textContent = ''; }, 3000); }
        return;
    }
    if (!confirm(`Are you sure you want to clear the manually set sequence headings for Route ${routeId}?`)) { return; }
    try {
        localStorage.removeItem(key); // Remove the specific override
        if(seqHeadingStatusMsg) { seqHeadingStatusMsg.textContent = `Headings cleared for Route ${routeId}.`; seqHeadingStatusMsg.style.color = 'green'; setTimeout(() => { if(seqHeadingStatusMsg) seqHeadingStatusMsg.textContent = ''; }, 3000); }
        // Clear inputs only if they currently match the cleared route
        if (seqHeadingRouteIdInput.value.trim().toUpperCase() === routeId) {
             seqHeadingOutboundInput.value = ''; seqHeadingInboundInput.value = '';
        }
        displayActiveSequenceHeadings(); // Refresh the list
    } catch (e) { console.error("Error clearing sequence headings:", e); if(seqHeadingStatusMsg) { seqHeadingStatusMsg.textContent = "Error clearing headings."; seqHeadingStatusMsg.style.color = 'red'; } }
}
function displayActiveSequenceHeadings() { /* ... Implementation from iBusDest ... */
    if (!activeHeadingsListDiv) { console.error("DEBUG: Active sequence headings list div not found."); return; }
    activeHeadingsListDiv.innerHTML = ''; // Clear previous list
    if(removeHeadingsStatusMsg) removeHeadingsStatusMsg.textContent = ''; // Clear status

    let activeOverrides = [];
    try {
        for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); if (key && key.startsWith(sequenceHeadingOverrideBaseKey)) { const routeId = key.substring(sequenceHeadingOverrideBaseKey.length); const data = loadFromStorage(key, null); if (data && typeof data === 'object' && ( (data.outbound && data.outbound.trim()) || (data.inbound && data.inbound.trim()) )) { activeOverrides.push({ routeId: routeId, data: data }); } else if (data) { localStorage.removeItem(key); } } } // Auto-clean empty entries
    } catch (e) { console.error("DEBUG: Error reading localStorage for sequence headings:", e); activeHeadingsListDiv.innerHTML = '<p style="color: red;">Error loading overrides list.</p>'; if (removeSelectedHeadingsBtn) removeSelectedHeadingsBtn.classList.add('hidden'); return; }

    activeOverrides.sort((a, b) => a.routeId.localeCompare(b.routeId, undefined, { numeric: true }));
    const isAdmin = isLoggedIn && users[currentUsername]?.role === 'admin';

    if (activeOverrides.length === 0) { activeHeadingsListDiv.innerHTML = '<p>No active sequence heading overrides found.</p>'; if (removeSelectedHeadingsBtn) removeSelectedHeadingsBtn.classList.add('hidden'); }
    else {
        if (isAdmin) { // Add "Select All" only for admins
            const selectAllDiv = document.createElement('div'); selectAllDiv.className = 'select-all-container'; selectAllDiv.innerHTML = `<input type="checkbox" id="select-all-headings-cb" onchange="handleSelectAllHeadings(this.checked)" title="Select/Deselect All"><label for="select-all-headings-cb">Select All</label>`; activeHeadingsListDiv.appendChild(selectAllDiv);
        }
        activeOverrides.forEach(item => { // Add list items
            const itemDiv = document.createElement('div'); const checkboxHTML = isAdmin ? `<input type="checkbox" class="heading-override-checkbox" data-routeid="${item.routeId}" title="Select Route ${item.routeId}">` : ''; const outboundText = item.data.outbound ? item.data.outbound : '<em>(Not Set)</em>'; const inboundText = item.data.inbound ? item.data.inbound : '<em>(Not Set)</em>';
            itemDiv.innerHTML = `${checkboxHTML}<span><strong>Route ${item.routeId}:</strong><span class="heading-dir">Out:</span> ${outboundText} | <span class="heading-dir">In:</span> ${inboundText}</span>`; activeHeadingsListDiv.appendChild(itemDiv);
        });
        if (removeSelectedHeadingsBtn) { // Show/hide remove button
            removeSelectedHeadingsBtn.classList.toggle('hidden', !isAdmin); removeSelectedHeadingsBtn.disabled = !isAdmin;
        }
    }
}
function handleSelectAllHeadings(isChecked) { /* ... Implementation from iBusDest ... */
    if (!activeHeadingsListDiv) return;
    const checkboxes = activeHeadingsListDiv.querySelectorAll('.heading-override-checkbox');
    checkboxes.forEach(cb => cb.checked = isChecked);
     // Enable/disable remove button based on selection (if admin)
     if (removeSelectedHeadingsBtn && users[currentUsername]?.role === 'admin') {
         removeSelectedHeadingsBtn.disabled = !isChecked;
     }
}
function removeSelectedSequenceHeadings() { /* ... Implementation from iBusDest ... */
    if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert("Admin privileges required."); return; }
    if (!activeHeadingsListDiv || !removeHeadingsStatusMsg) { console.error("DEBUG: Missing elements for heading removal."); return;}
    const selectedCheckboxes = activeHeadingsListDiv.querySelectorAll('.heading-override-checkbox:checked');
    if (selectedCheckboxes.length === 0) { alert("Please select at least one heading override to remove."); return; }
    if (!confirm(`Are you sure you want to remove the selected ${selectedCheckboxes.length} sequence heading override(s)?`)) { return; }

    console.log(`DEBUG: Removing ${selectedCheckboxes.length} selected sequence heading overrides.`);
    removeHeadingsStatusMsg.textContent = 'Removing...'; removeHeadingsStatusMsg.style.color = 'orange';
    let removedCount = 0; let errorOccurred = false;
    try {
        selectedCheckboxes.forEach(checkbox => { const routeId = checkbox.dataset.routeid; if (routeId) { const key = sequenceHeadingOverrideBaseKey + routeId; localStorage.removeItem(key); removedCount++; console.log(`DEBUG: Removed heading override for route ${routeId}`); } else { console.warn("DEBUG: Found selected checkbox without routeId data."); } });
    } catch (e) { console.error("DEBUG: Error during heading removal:", e); errorOccurred = true; }
    finally {
        if (errorOccurred) { removeHeadingsStatusMsg.textContent = `Error occurred. ${removedCount} removed.`; removeHeadingsStatusMsg.style.color = 'red'; }
        else { removeHeadingsStatusMsg.textContent = `${removedCount} heading override(s) removed.`; removeHeadingsStatusMsg.style.color = 'green'; }
        displayActiveSequenceHeadings(); // Refresh list
        // Clear form if removed route was loaded
        const currentRouteIdInForm = seqHeadingRouteIdInput.value.trim().toUpperCase(); if (currentRouteIdInForm) { let formWasCleared = false; selectedCheckboxes.forEach(checkbox => { if (checkbox.dataset.routeid === currentRouteIdInForm) { seqHeadingOutboundInput.value = ''; seqHeadingInboundInput.value = ''; formWasCleared = true; } }); if (formWasCleared) console.log(`DEBUG: Cleared form inputs.`); }
        const selectAllCb = document.getElementById('select-all-headings-cb'); if (selectAllCb) selectAllCb.checked = false; // Uncheck select all
        if (removeSelectedHeadingsBtn) removeSelectedHeadingsBtn.disabled = true; // Disable remove button
        setTimeout(() => { if(removeHeadingsStatusMsg) removeHeadingsStatusMsg.textContent = ''; }, 4000);
    }
}

/**
 * Creates the HTML structure for a single route in the Final Destinations editor.
 * @param {string} routeId - The route ID.
 * @param {string[]} [destinations=[]] - Array of saved destinations for this route.
 */
function createRouteSectionElement(routeId, destinations = []) {
    // Ensure the main container exists
    if (!destEditorRoutesContainer) {
         console.error("DEBUG: createRouteSectionElement - destEditorRoutesContainer not found!");
         return;
    }
    // Don't add if a section for this route already exists
    if (destEditorRoutesContainer.querySelector(`[data-routeid="${routeId}"]`)) {
         console.log(`DEBUG: createRouteSectionElement - Section for ${routeId} already exists.`);
         return;
    }

    const sectionDiv = document.createElement('div');
    sectionDiv.className = 'dest-route-section';
    sectionDiv.dataset.routeid = routeId;

    const heading = document.createElement('h4');
    const routeLabel = document.createElement('span');
    routeLabel.textContent = `Route ${routeId}:`;
    heading.appendChild(routeLabel);

    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'route-actions';

    const prefillBtn = document.createElement('button');
    prefillBtn.textContent = 'Suggest Termini';
    prefillBtn.title = 'Attempt to fetch termini from TfL API';
    prefillBtn.className = 'blue-button secondary-button';
    prefillBtn.type = 'button';
    prefillBtn.setAttribute('data-permission', 'canManageFinalDests'); // Add permission
    const statusSpan = document.createElement('span');
    statusSpan.className = 'prefill-status';
    prefillBtn.onclick = (event) => {
        if (!hasPermission('canManageFinalDests')) { alert('Permission denied.'); return; }
        fetchAndSuggestTermini(routeId, textarea, statusSpan);
    };
    actionsDiv.appendChild(prefillBtn);
    actionsDiv.appendChild(statusSpan);

    const removeBtn = document.createElement('button');
    removeBtn.textContent = 'Remove';
    removeBtn.title = 'Remove this route section';
    removeBtn.className = 'danger-button secondary-button';
    removeBtn.type = 'button';
    removeBtn.setAttribute('data-permission', 'canManageFinalDests'); // Add permission
    removeBtn.onclick = () => {
         if (!hasPermission('canManageFinalDests')) { alert('Permission denied.'); return; }
         removeDestRouteSection(routeId);
    };
    actionsDiv.appendChild(removeBtn);

    heading.appendChild(actionsDiv);

    const textarea = document.createElement('textarea');
    textarea.rows = 3;
    textarea.value = Array.isArray(destinations) ? destinations.join('\n') : '';
    textarea.placeholder = 'Enter final destinations, one per line';
    textarea.setAttribute('aria-label', `Final destinations for route ${routeId}`);
    textarea.setAttribute('data-permission', 'canManageFinalDests'); // Add permission

    sectionDiv.appendChild(heading);
    sectionDiv.appendChild(textarea);

    // Remove "Loading..." or placeholder if present
    const initialMsg = destEditorRoutesContainer.querySelector('p.filter-placeholder, p:only-child');
     if (initialMsg && (initialMsg.textContent.startsWith("Loading") || initialMsg.classList.contains("filter-placeholder"))) {
        initialMsg.remove();
    }

    destEditorRoutesContainer.appendChild(sectionDiv); // Add the new section

    // Apply roles/permissions to the newly added elements within this section
    updateElementRoles(sectionDiv);
    console.log(`DEBUG: Created route section element for ${routeId}`);
}

// --- Final Destination Functions (Copied from iBusDest) ---
// (populateDestEditor, createRouteSectionElement, addDestRouteSectionManual, removeDestRouteSection, filterDestSections, fetchAndSuggestTermini, saveAllFinalDestinations, processBulkInput, setDestFilterState)
// These should work using shared helpers and globals
// --- Find and Replace the existing populateDestEditor function ---

/**
 * Populates the Final Destinations editor section with route sections.
 * Creates sections for known TfL routes and any routes already saved in settings.
 */
function populateDestEditor() {
    // Use the correct variable name for the container
    if (!destEditorRoutesContainer || !destFilterInput) {
        console.error("DEBUG: Destination editor elements not found (container or filter input).");
        if (destEditorRoutesContainer) destEditorRoutesContainer.innerHTML = '<p style="color:red;">UI Error: Cannot load editor.</p>';
        return;
    }
    console.log("DEBUG: Populating destination editor...");
    destEditorRoutesContainer.innerHTML = '<p>Loading routes...</p>'; // Clear and show loading

    try {
        const savedSettings = loadFromStorage(routeDestinationSettingsKey, {});
        // Use the same extensive list from ibusdest.html or adjust as needed
        const KNOWN_TFL_BUS_ROUTES = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "80", "81", "83", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "100", "101", "102", "103", "104", "105", "106", "107", "108", "109", "110", "111", "112", "113", "114", "115", "116", "117", "119", "120", "121", "122", "123", "124", "125", "126", "127", "128", "129", "130", "131", "132", "133", "134", "135", "136", "137", "138", "139", "140", "141", "142", "143", "144", "145", "146", "147", "148", "149", "150", "151", "152", "153", "154", "155", "156", "157", "158", "159", "160", "161", "162", "163", "164", "165", "166", "167", "169", "170", "171", "172", "173", "174", "175", "176", "177", "178", "179", "180", "181", "182", "183", "184", "185", "186", "187", "188", "189", "190", "191", "192", "193", "194", "195", "196", "197", "198", "199", "200", "201", "202", "203", "204", "205", "206", "207", "208", "209", "210", "211", "212", "213", "214", "215", "216", "217", "218", "219", "220", "221", "222", "223", "224", "225", "226", "227", "228", "229", "230", "231", "232", "233", "234", "235", "236", "237", "238", "240", "241", "242", "243", "244", "245", "246", "247", "248", "249", "250", "251", "252", "253", "254", "255", "256", "257", "258", "259", "260", "261", "262", "263", "264", "265", "266", "267", "268", "269", "270", "272", "273", "274", "275", "276", "277", "278", "279", "280", "281", "282", "283", "284", "285", "286", "287", "288", "289", "290", "291", "292", "293", "294", "295", "296", "297", "298", "299", "300", "301", "302", "303", "304", "306", "307", "308", "309", "310", "312", "313", "314", "315", "316", "317", "318", "319", "320", "321", "322", "323", "324", "325", "326", "327", "328", "329", "330", "331", "333", "335", "336", "337", "339", "340", "341", "343", "344", "345", "346", "349", "350", "352", "353", "354", "355", "356", "357", "358", "359", "360", "362", "363", "364", "365", "366", "367", "368", "370", "371", "372", "375", "376", "377", "378", "379", "380", "381", "382", "383", "384", "385", "386", "388", "389", "390", "393", "394", "395", "396", "397", "398", "399", "401", "403", "404", "405", "406", "407", "410", "411", "412", "413", "415", "417", "418", "419", "422", "423", "424", "425", "427", "428", "430", "432", "433", "434", "436", "439", "440", "444", "450", "452", "453", "456", "460", "462", "463", "464", "465", "466", "467", "468", "469", "470", "472", "473", "474", "476", "481", "482", "483", "484", "485", "486", "487", "488", "490", "491", "492", "493", "496", "498", "499", "533", "601", "602", "603", "605", "606", "608", "612", "613", "616", "617", "618", "621", "624", "625", "626", "627", "628", "629", "631", "632", "633", "634", "635", "638", "639", "640", "642", "643", "645", "646", "649", "650", "651", "652", "653", "654", "655", "656", "657", "658", "660", "661", "662", "663", "664", "665", "667", "669", "670", "671", "672", "673", "674", "675", "677", "678", "679", "681", "683", "684", "685", "686", "687", "688", "689", "690", "696", "697", "698", "699", "969", "A10", "B11", "B12", "B13", "B14", "B15", "B16", "C1", "C3", "C10", "C11", "D3", "D6", "D7", "D8", "E1", "E2", "E3", "E5", "E6", "E7", "E8", "E9", "E10", "E11", "EL1", "EL2", "EL3", "G1", "H2", "H3", "H9", "H10", "H11", "H12", "H13", "H17", "H18", "H19", "H20", "H22", "H25", "H26", "H28", "H32", "H37", "H91", "H98", "K1", "K2", "K3", "K4", "K5", "P4", "P5", "P12", "P13", "R1", "R2", "R3", "R4", "R5", "R7", "R8", "R9", "R10", "R11", "R68", "R70", "S1", "S2", "S3", "S4", "SCS", "SL1", "SL2", "SL3", "SL4", "SL5", "SL6", "SL7", "SL8", "SL9", "SL10", "U1", "U2", "U3", "U4", "U5", "U7", "U9", "U10", "W3", "W4", "W5", "W6", "W7", "W8", "W9", "W11", "W12", "W13", "W14", "W15", "W16", "W19", "N1", "N2", "N3", "N5", "N7", "N8", "N9", "N11", "N15", "N18", "N19", "N20", "N21", "N22", "N25", "N26", "N27", "N28", "N29", "N31", "N32", "N33", "N38", "N41", "N44", "N53", "N55", "N63", "N65", "N68", "N72", "N73", "N74", "N83", "N86", "N87", "N89", "N91", "N97", "N98", "N109", "N113", "N133", "N136", "N137", "N140", "N155", "N171", "N199", "N205", "N207", "N242", "N250", "N253", "N254", "N263", "N266", "N277", "N279", "N343", "N381", "N550", "N551"];
        const knownRoutes = KNOWN_TFL_BUS_ROUTES;
        // Combine known routes with routes already saved in settings
        const routeIdsToShow = new Set([...knownRoutes, ...Object.keys(savedSettings)]);
        // Sort numerically/alphabetically
        const sortedRouteIds = [...routeIdsToShow].sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

        if (sortedRouteIds.length === 0) {
            destEditorRoutesContainer.innerHTML = '<p class="filter-placeholder">No routes found or saved.</p>';
            return;
        }
        // Create sections for each route
        sortedRouteIds.forEach(routeId => {
            const savedDestinations = savedSettings[routeId] || [];
            createRouteSectionElement(routeId, savedDestinations); // This function creates the inner elements
        });
        filterDestSections(); // Apply current filter state after populating
        console.log("DEBUG: Destination editor populated.");
    } catch (e) {
        console.error("DEBUG: Error populating destination editor:", e);
        destEditorRoutesContainer.innerHTML = '<p style="color:red;">Error loading destination editor.</p>';
    }
}
const initialMsg = destEditorRoutesContainer
function addDestRouteSectionManual() { /* ... Implementation from iBusDest ... */
     // Permission check by button state
     if (!addDestRouteInput || !destEditorRoutesContainer) return; const routeId = addDestRouteInput.value.trim().toUpperCase(); if (!routeId) { alert('Please enter a Route to add.'); addDestRouteInput.focus(); return; } if (!/^[A-Z0-9]+$/i.test(routeId) || routeId.length > 5) { alert(`Route "${routeId}" looks invalid.`); addDestRouteInput.focus(); return; } if (destEditorRoutesContainer.querySelector(`[data-routeid="${routeId}"]`)) { alert(`Section for Route ${routeId} already exists or is listed.`); destEditorRoutesContainer.querySelector(`[data-routeid="${routeId}"]`)?.scrollIntoView({behavior: "smooth"}); return; } createRouteSectionElement(routeId, []); addDestRouteInput.value = ''; const newSection = destEditorRoutesContainer.querySelector(`[data-routeid="${routeId}"]`); newSection?.scrollIntoView({behavior: "smooth"}); newSection?.querySelector('textarea')?.focus(); filterDestSections(); // Refresh filter state
}
function removeDestRouteSection(routeId) { /* ... Implementation from iBusDest ... */
     // Permission check by button state
     if (!destEditorRoutesContainer) return; if (!confirm(`Remove section for Route ${routeId}? Unsaved changes for this route will be lost. This only removes it from the view until 'Save All' is clicked.`)) { return; } const section = destEditorRoutesContainer.querySelector(`[data-routeid="${routeId}"]`); if (section) { section.remove(); filterDestSections(); } // Remove from DOM and refresh filter count/placeholder
}
function filterDestSections() { /* ... Implementation from iBusDest (with corrected 'edited' logic) ... */
    console.log(`DEBUG: filterDestSections called. Current Button Filter: ${currentFinalDestFilter}`);
    if (!destEditorRoutesContainer || !destFilterInput) { console.error("DEBUG: Filter sections - Required elements missing."); return; }
    const filterText = destFilterInput.value.trim().toUpperCase(); // Textbox filter
    const sections = destEditorRoutesContainer.querySelectorAll('.dest-route-section');
    let visibleCount = 0;
    const savedSettings = loadFromStorage(routeDestinationSettingsKey, {}); // Load saved data ONCE per filter run

    sections.forEach(section => {
        const routeId = section.dataset.routeid;
        const textarea = section.querySelector('textarea');
        const currentText = textarea ? textarea.value.trim() : ''; // Current text in editor
        // Get saved text as a comparable string
        const savedDestinationsArray = savedSettings[routeId];
        const savedText = Array.isArray(savedDestinationsArray) ? savedDestinationsArray.join('\n').trim() : '';
        let show = false;
        if (!routeId) { section.classList.add('filtered-out'); return; }

        const routeIdUpper = routeId.toUpperCase();
        const matchesTextFilter = !filterText || routeIdUpper.includes(filterText); // Textbox filter match

        switch (currentFinalDestFilter) { // Button filter state
            case 'all': show = matchesTextFilter; break;
            case 'edited': const hasSavedData = savedText !== ''; show = matchesTextFilter && hasSavedData; break; // Show if matches text AND has saved data
            case 'empty': const isEmpty = currentText === ''; show = matchesTextFilter && isEmpty; break; // Show if matches text AND is currently empty
            default: show = matchesTextFilter; break;
        }
        section.classList.toggle('filtered-out', !show); if(show) visibleCount++;
    });
    // Handle placeholder display
    let placeholder = destEditorRoutesContainer.querySelector('p.filter-placeholder');
    if (visibleCount === 0) { if (!placeholder) { placeholder = document.createElement('p'); placeholder.className = 'filter-placeholder'; if (destEditorRoutesContainer.firstChild) { destEditorRoutesContainer.insertBefore(placeholder, destEditorRoutesContainer.firstChild); } else { destEditorRoutesContainer.appendChild(placeholder); } } placeholder.textContent = (filterText || currentFinalDestFilter !== 'all') ? 'No routes match current filter.' : 'No routes defined.'; placeholder.style.display = ''; }
    else if (placeholder) { placeholder.style.display = 'none'; }
}
async function fetchAndSuggestTermini(routeId, textareaElement, statusSpanElement) { /* ... Implementation from iBusDest ... */
     // Permission check by button state
     if (!routeId || !textareaElement || !statusSpanElement) return;
     statusSpanElement.textContent = 'Fetching...'; statusSpanElement.style.color = 'orange'; textareaElement.disabled = true;
     try {
         const apiUrl = `https://api.tfl.gov.uk/Line/${routeId}/Route/Sequence/all`; const response = await fetch(apiUrl);
         if (!response.ok) { throw new Error(response.status === 404 ? `Route ${routeId} not found` : `API Error ${response.status}`); }
         const data = await response.json(); const termini = new Set();
         if (data.stopPointSequences && Array.isArray(data.stopPointSequences)) { data.stopPointSequences.forEach(seq => { if (seq.stopPoint && Array.isArray(seq.stopPoint) && seq.stopPoint.length > 0) { const lastStop = seq.stopPoint[seq.stopPoint.length - 1]?.name; const destName = seq.destinationName || lastStop; if (destName) termini.add(destName); } }); }
         if (termini.size > 0) { const suggestedText = `# Suggested termini for Route ${routeId}:\n` + [...termini].join('\n'); textareaElement.value = suggestedText + (textareaElement.value ? '\n# ---\n' + textareaElement.value : ''); statusSpanElement.textContent = 'Suggestions loaded.'; statusSpanElement.style.color = 'green'; }
         else { statusSpanElement.textContent = 'No suggestions found.'; statusSpanElement.style.color = 'orange'; }
     } catch (error) { console.error(`Error fetching termini for ${routeId}:`, error); statusSpanElement.textContent = `Error: ${error.message}`; statusSpanElement.style.color = 'red'; }
     finally { textareaElement.disabled = false; setTimeout(() => { if(statusSpanElement) statusSpanElement.textContent = ''; }, 4000); }
}
function saveAllFinalDestinations() { /* ... Implementation from iBusDest ... */
    // Permission check by button state
    if (!destEditorRoutesContainer || !destEditorMessage) { return; } try { const routeSections = destEditorRoutesContainer.querySelectorAll('.dest-route-section'); const newSettingsToSave = {}; routeSections.forEach(section => { const routeId = section.dataset.routeid; const textarea = section.querySelector('textarea'); if (routeId && textarea) { const destinations = textarea.value.split('\n').map(line => line.replace(/#.*$/, '').trim()) // Remove comments, trim
            .filter(line => line.length > 0); // Filter out empty lines
            if (destinations.length > 0) { newSettingsToSave[routeId] = destinations; } // Only save if there are destinations
            else { console.log(`DEBUG: Route ${routeId} has no destinations, removing from saved data.`); } // Log removal of empty routes implicitly }
         } });
         saveToStorage(routeDestinationSettingsKey, newSettingsToSave); // Save the compiled object
         destEditorMessage.textContent = "Final destinations saved!"; destEditorMessage.style.color = "green"; console.log("Final destinations saved:", newSettingsToSave);
         filterDestSections(); // Refresh filter state, e.g., 'edited' might change
         setTimeout(() => { if(destEditorMessage) destEditorMessage.textContent = ""; }, 3000);
     } catch (e) { console.error("Error saving final destinations:", e); destEditorMessage.textContent = "Error saving."; destEditorMessage.style.color = "red"; }
}
function processBulkInput() { /* ... Implementation from iBusDest ... */
      // Permission check by button state
      if (!bulkDestInput || !bulkDestStatus || !destEditorRoutesContainer) return; const lines = bulkDestInput.value.split('\n'); let processedCount = 0; let errorCount = 0; bulkDestStatus.textContent = 'Processing...'; bulkDestStatus.style.color = 'orange'; const changes = {}; // Group changes by route
      lines.forEach(line => { const cleanLine = line.replace(/#.*$/, '').trim(); if (!cleanLine) return; const parts = cleanLine.match(/^([A-Z0-9]+):\s*(.*)$/i); // Match ROUTE: Destination
           if (parts && parts.length === 3) { const routeId = parts[1].toUpperCase(); const destination = parts[2].trim(); if (destination) { if (!changes[routeId]) { changes[routeId] = []; } changes[routeId].push(destination); processedCount++; } else { console.warn(`Bulk input: Skipping empty destination for route ${routeId}`); errorCount++; } } else { console.warn(`Bulk input: Skipping invalid line format: "${line}"`); errorCount++; } });
      if (processedCount === 0 && errorCount === 0) { bulkDestStatus.textContent = 'No valid input found.'; return; }
      // Apply changes to the textareas
      Object.keys(changes).forEach(routeId => { let section = destEditorRoutesContainer.querySelector(`[data-routeid="${routeId}"]`); if (!section) { createRouteSectionElement(routeId, changes[routeId]); // Create section if it doesn't exist
          console.log(`DEBUG: Created section for route ${routeId} via bulk input.`); } else { const textarea = section.querySelector('textarea'); if (textarea) { textarea.value = changes[routeId].join('\n'); } // Replace content
          } });
      bulkDestStatus.textContent = `Processed ${processedCount} entries. ${errorCount > 0 ? `Skipped ${errorCount} invalid lines.` : ''} Review changes above, then click 'Save All'.`; bulkDestStatus.style.color = errorCount > 0 ? 'orange' : 'green';
      filterDestSections(); // Apply filter to potentially show new/edited sections
      bulkDestInput.value = ''; // Clear bulk input after processing
}
function setDestFilterState(state) { /* ... Implementation from iBusDest ... */
      currentFinalDestFilter = state; destFilterButtons.forEach(btn => { btn.classList.toggle('active', btn.id === `filter-btn-${state}`); }); filterDestSections(); // Re-apply filters
}


// --- Event Listeners (Merged) ---
console.log("DEBUG: Adding combined event listeners.");
// File Import Listeners (from tools.html)
if (importCurtailmentsInput) importCurtailmentsInput.addEventListener('change', function () { if (this.files?.length > 0) handleCurtailmentImport(this.files[0]); });
if (importTmpInput) importTmpInput.addEventListener('change', function () { if (this.files?.length > 0) handleTmpImport(this.files[0]); });
if (importSeqHeadingsInput) importSeqHeadingsInput.addEventListener('change', function () { if (this.files?.length > 0) handleSequenceHeadingsImport(this.files[0]); });
if (importFinalDestInput) importFinalDestInput.addEventListener('change', function () { if (this.files?.length > 0) handleFinalDestinationsImport(this.files[0]); });

// Password Modal Listener (from tools.html)
if (passwordModalInput) passwordModalInput.addEventListener('keydown', function (e) { if (e.key === 'Enter') { e.preventDefault(); handleModalConfirm(); } });

// Manage Curtailments Select All (from tools.html)
if (selectAllCheckbox) selectAllCheckbox.addEventListener('change', handleSelectAllCurtailments);

// Audit Log Clear Button (from tools.html)
if (clearAuditLogButton) { clearAuditLogButton.addEventListener('click', clearAuditLog); } else { console.error("DEBUG: Clear Audit Log Button not found!"); }

// Filter Input Listeners (from ibusdest.html)
if (filterInput) { filterInput.addEventListener('input', displayOverrides); } // Temp overrides filter
if(destFilterInput) { destFilterInput.addEventListener('input', filterDestSections); } // Final destinations filter

// Note: Other event listeners (like button clicks) are handled by `onclick` attributes in the HTML.
// Listeners for dynamically added elements (like remove buttons in lists, dest section buttons) are added when those elements are created.

// --- Initial Load (from tools.html) ---
console.log("DEBUG: Attempting to add DOMContentLoaded listener...");
document.addEventListener('DOMContentLoaded', () => {
    console.log("DEBUG: DOMContentLoaded event fired.");
    // Check essential containers exist
    const loginContainerRef = getElement('login-container');
    const appContainerRef = getElement('app-container');
    if (!loginContainerRef || !appContainerRef || !getElement('main-actions-container') || !getElement('go-back-button')) {
        console.error("DEBUG: CRITICAL ERROR: Essential containers or buttons missing.");
        document.body.innerHTML = '<p style="color:red; padding:20px;">Page loading error: Core UI elements missing. Please check the HTML structure.</p>';
        return;
    }
    console.log("DEBUG: DOMContentLoaded - Calling checkLogin...");
    checkLogin(); // Checks login status and shows login or app view
    console.log("DEBUG: DOMContentLoaded - checkLogin finished.");
});
console.log("DEBUG: DOMContentLoaded listener attached.");

console.log('--- DEBUG: SCRIPT END REACHED (Merged Tools + iBusDest) ---');
// --- End of Merged JavaScript (Part 3) ---
    </script>
</body>
</html>
