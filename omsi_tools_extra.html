<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMSI Tools - Extra Modules</title>
    <head>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.1/jspdf.plugin.autotable.min.js">    </script>
    <link rel="manifest" href="/live-tracker/manifest-omsi.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OMSI Extra Tools">
    <meta name="theme-color" content="#2c3e50">
    <link rel="apple-touch-icon" href="/live-tracker/assets/icons/apple-touch-icon-180x180.png">
    <style>
        @font-face {
            font-family: 'NJFont Medium Web';
            src: url('fonts/NJFont-Medium.ttf') format('truetype'); /* Relative path */
            font-weight: normal;font-style: normal;font-display: swap;
        }
        body {
            font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            margin:0;
        }
        .page-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }
        #top-menu-bar_extra {
            background-color: rgba(0,0,0,0.25); padding: 0.75rem; border-radius: 0.5rem;
            margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center; display: none; /* Initially hidden, shown by JS after login */
        }
        .menu-button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin: 0.25rem;
        }
        .menu-button:hover { background-color: #2980b9; }
        .tool-content-section {
            display: none; /* Initially hidden, shown by JS */
            background-color: rgba(0,0,0,0.15); padding: 1.5rem;
            border-radius: 0.5rem; margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        #auth-section { /* Applied .section styles to auth-section */
             margin-bottom: 1.5rem; background-color: rgba(0,0,0,0.15); padding: 1.5rem;
             border-radius: 0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #current-profile-display-container {
            text-align: center; margin-bottom: 1.5rem; padding: 0.75rem;
            background-color: rgba(255,255,255,0.05); border-radius: 0.25rem; display: none; /* Initially hidden */
        }
        #current-profile-display { font-size: 0.9rem; opacity: 0.9; font-style: italic;}
        h1 { font-size: 2rem; margin-bottom: 1.5rem; font-weight: normal; text-align: center; color: #ffffff; }
        h2 { font-size: 1.5rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: normal; border-bottom: 1px solid #7f8c8d; padding-bottom: 0.25rem;}
        h3.subsection-title { font-size: 1.25rem; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: normal; color: #e0e0e0; border-bottom: 1px solid rgba(127,140,141,0.5); padding-bottom: 0.2rem;}
        .subsection {
            background-color: rgba(0,0,0,0.1); padding: 1rem; border-radius: 0.375rem;
            margin-top: 1rem; margin-bottom: 1rem; border: 1px solid rgba(127,140,141,0.2);
        }
        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;}
        .form-field-group { margin-bottom: 1rem; }
        label { display: block; margin-bottom: 0.25rem; font-size: 0.85rem; color: #bdc3c7; }
        input[type="text"], input[type="email"], input[type="password"], input[type="time"],
        input[type="color"], input[type="number"], input[type="date"], input[type="datetime-local"],
        select, textarea {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e; color: #ecf0f1; font-size:0.9rem; box-sizing: border-box;
        }
        input[type="date"]::-webkit-calendar-picker-indicator,
        input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            filter: invert(0.8); cursor:pointer;
        }
        select option { background-color: #34495e; color: #ecf0f1; }
        .button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.5rem 0.8rem;
            border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin-right: 0.5rem; margin-top:0.5rem;
            display: inline-block;
            text-align: center;
            vertical-align: middle;
        }
        .button:hover { background-color: #2980b9; }
        .button.secondary { background-color: #e74c3c; }
        .button.secondary:hover { background-color: #c0392b; }
        .button.save { background-color: #27ae60; }
        .button.save:hover { background-color: #229954; }
        .button.tertiary { background-color: #f39c12; }
        .button.tertiary:hover { background-color: #e67e22; }
        .button.neutral { background-color: #7f8c8d; }
        .button.neutral:hover { background-color: #95a5a6; color: #2c3e50; }
        .button.small-action { padding: 0.2rem 0.4rem; font-size: 0.8rem; margin: 0 0.15rem; line-height: 1; min-width: 20px; text-align:center; font-weight: bold;}

        .schedule-generator-input {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e; color: #ecf0f1; font-size: 0.9rem;
        }

        /* Master Stop List Styles */
        #masterStopListUL_extra li.master-stop-list-item {
            display: grid;
            grid-template-columns: 2.5fr 1.5fr 1fr;
            gap: 1rem; padding: 0.75rem 0.5rem;
            border-bottom: 1px solid #34495e;
            transition: background-color 0.15s ease-in-out; align-items: start;
        }
        #masterStopListUL_extra li.master-stop-list-item:last-child { border-bottom: none; }
        .master-stop-original-info .stop-name-master { font-weight: bold; color: #ecf0f1; font-size: 1.05em; }
        .master-stop-original-info .stop-direction-master { font-size: 0.85em; color: #95a5a6; margin-bottom: 0.3rem; }
        .master-stop-original-info .stop-id-master { font-weight: normal; color: #bdc3c7; font-size: 0.95em; }
        .master-stop-original-info .stop-details-grid { display: grid; grid-template-columns: auto 1fr; gap: 0.2rem 0.8rem; font-size: 0.85em; margin-top: 0.4rem; }
        .master-stop-original-info .detail-label { font-weight: normal; color: #bdc3c7; opacity: 0.8; }
        .master-stop-original-info .detail-value { color: #ecf0f1; }
        .master-stop-original-info .detail-value.status-closed { color: #e74c3c; font-weight: bold; }
        .master-stop-original-info .detail-value.status-open { color: #2ecc71; }
        .master-stop-original-info .serving-routes-container { margin-top: 0.4rem; margin-bottom: 0.2rem; display: flex; flex-wrap: wrap; gap: 0.3em; padding: 0.25rem 0;}
        .master-stop-new-id-section label { font-size: 0.8em; display: block; margin-bottom: 0.2em; color: #bdc3c7; }
        .master-list-new-id-input { margin-bottom: 0.25rem; }
        .master-list-row-warning { font-size: 0.8em; color: #f39c12; min-height: 1.2em; margin-top: 0.25rem; }
        .master-stop-actions { margin-top: 0rem; padding-top: 0rem; border-top: none; display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-start; }
        .master-stop-actions .button { width: 100%; margin: 0; }
        .route-tile-tools-list {
            display: inline-block; padding: 0.2em 0.55em; margin-right: 0.3em; margin-bottom: 0.3em;
            border-radius: 0.25rem; font-size: 0.8em; font-weight: bold; color: white;
            text-align: center; line-height: 1.3; min-width: 28px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.25); vertical-align: middle;
        }
        #newStopIdAvailability_extra { font-size: 0.8em; min-height: 1.1em; margin-top: 0.25rem; }

        /* Selectable Route Tiles for Global Deletion & RPD Profile Tiles */
        .selectable-route-tile-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
            padding: 0.25rem 0;
        }
        .selectable-route-tile {
            display: inline-block;
            padding: 0.4em 0.8em;
            border-radius: 0.25rem;
            font-size: 0.9em;
            font-weight: bold;
            text-align: center;
            line-height: 1.4;
            min-width: 40px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .selectable-route-tile:hover {
            transform: translateY(-1px);
        }
        .selectable-route-tile.selected {
            border-color: #f1c40f !important;
            box-shadow: 0 0 8px 1px #f1c40f !important;
        }

        /* Styles for duplicate stop name/direction results */
        #duplicateStopsByNameDirResults_extra ul { list-style: none; padding-left: 0; }
        #duplicateStopsByNameDirResults_extra li { margin-bottom: 0rem; }
        .duplicate-set-to-merge {
            border: 1px solid #4a5568;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            border-radius: 0.25rem;
            background-color: rgba(0,0,0,0.05);
        }
        .duplicate-set-to-merge p { margin-bottom: 0.35rem; }
        .duplicate-set-to-merge .stop-id-options label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.9em;
            cursor: pointer;
        }
         .duplicate-set-to-merge .stop-id-options input[type="radio"] {
            margin-right: 0.35em;
            vertical-align: middle;
        }

        /* --- START: Route Schedule Generator Styles --- */
        #rsg-stop-sequence-list-extra li {
            display: flex;
            flex-direction: column; 
            padding: 0.6rem 0.5rem;
            border-bottom: 1px solid #4A5568;
            background-color: rgba(255,255,255,0.03);
            cursor: grab; 
        }
        #rsg-stop-sequence-list-extra li:active {
            cursor: grabbing;
            background-color: rgba(255,255,255,0.07);
        }
        #rsg-stop-sequence-list-extra li.rsg-dragging-placeholder {
            opacity: 0.5;
            background-color: #567a9a; 
            border: 1px dashed #ecf0f1;
        }
        #rsg-stop-sequence-list-extra li:last-child {
            border-bottom: none;
        }

        .rsg-li-main-content {
            display: flex;
            justify-content: space-between;
            align-items: center; 
            width: 100%;
            margin-bottom: 0.5rem; 
        }

        #rsg-stop-sequence-list-extra .rsg-stop-info {
            flex-grow: 1; 
            margin-right: 1rem; 
        }
        #rsg-stop-sequence-list-extra .rsg-stop-name {
            font-weight: bold;
        }
        #rsg-stop-sequence-list-extra .rsg-stop-id {
            font-size: 0.85em; color: #bdc3c7; margin-left: 0.5em;
        }
        #rsg-stop-sequence-list-extra .rsg-stop-actions {
            display: flex;
            align-items: center; 
            gap: 0.5rem;
        }
        #rsg-stop-sequence-list-extra .rsg-stop-actions button {
            padding: 0.15rem 0.35rem;
            font-size: 0.75rem;
            line-height: 1; 
        }
        #rsg-stop-sequence-list-extra .rsg-time-adjustment-input {
            width: 70px;
            padding: 0.25rem;
            font-size: 0.85em;
            text-align: center;
        }
        
        .rsg-copy-adjustment-buttons-container {
            display: flex;
            flex-wrap: wrap; 
            gap: 0.4rem;     
            margin-top: 0.5rem; 
            align-items: center; 
            width: 100%; 
            padding-top: 0.3rem; 
            border-top: 1px solid rgba(127,140,141,0.15); 
        }
        .rsg-copy-adjustment-buttons-container .button.copy-adj-button {
            font-size: 0.7em; 
            padding: 0.2em 0.5em; 
            line-height: 1.3;   
            white-space: nowrap; 
            margin: 0; 
            background-color: #546E7A; 
            color: white; 
        }
        .rsg-copy-adjustment-buttons-container .button.copy-adj-button:hover {
            background-color: #607D8B;
        }
        
        #rsg-selectable-profiles-container-extra label { /* Style for checkbox labels */
            color: #ecf0f1;
            font-size: 0.85em;
            cursor: pointer;
        }
        #rsg-selectable-profiles-container-extra input[type="checkbox"] {
            margin-right: 5px;
            vertical-align: middle;
        }

        /* --- END: Route Schedule Generator Styles --- */

        #rsg-stop-search-results-extra {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            background-color: #34495e;
            margin-top: 0.25rem;
        }
        #rsg-stop-search-results-extra .rsg-search-result-item {
            padding: 0.5rem 0.6rem;
            cursor: pointer;
            border-bottom: 1px solid #2c3e50;
        }
        #rsg-stop-search-results-extra .rsg-search-result-item:last-child {
            border-bottom: none;
        }
        #rsg-stop-search-results-extra .rsg-search-result-item:hover {
            background-color: #4a6a80;
        }
        #rsg-stop-search-results-extra .rsg-search-stop-name {
            font-weight: bold; display: block;
        }
        #rsg-stop-search-results-extra .rsg-search-stop-details {
            font-size: 0.8em; color: #bdc3c7; display: block; margin-top:0.1em;
        }
        #rsg-stop-search-results-extra .rsg-search-serving-routes {
            margin-top: 0.3em;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        .rpd-profile-tile {
            background-color: #4A5568; 
            color: white;
        }
        
        /* Styles for RSG Modal */
        .rsg-modal {
            position: fixed; 
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); 
            z-index: 1050; 
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .rsg-modal-content {
            background: linear-gradient(145deg, #3a506b, #2c3e50); 
            color: #ecf0f1;
            padding: 20px 25px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px; 
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            border: 1px solid #4a6a80;
        }

        .rsg-modal-content h4 {
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1.3em;
            color: #ffffff;
            border-bottom: 1px solid #567a9a;
            padding-bottom: 0.5rem;
        }

        .rsg-modal-content .form-field-group {
            margin-bottom: 1rem;
        }
        .rsg-modal-content label {
            font-size: 0.9em;
        }
        .rsg-modal-content input.schedule-generator-input {
            background-color: #2c3e50; 
            border-color: #567a9a;
        }

        .rsg-modal-actions {
            margin-top: 1.5rem;
            text-align: right;
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
        .rsg-modal-actions .button {
            margin-top: 0; 
        }
    </style>
</head>
<body>
    <div class="page-container">
        <h1>OMSI Tools - Extra Modules</h1>

        <div id="auth-section" class="section">
            <h2>Admin Login</h2>
            <div id="login-form-container_extra">
                <form id="adminLoginForm_extra">
                    <div class="form-grid" style="grid-template-columns: 1fr;">
                        <div><label for="inputEmail_extra">Email</label><input type="email" id="inputEmail_extra" autocomplete="email"></div>
                        <div><label for="inputPassword_extra">Password</label><input type="password" id="inputPassword_extra" autocomplete="current-password"></div>
                    </div>
                    <button id="loginButton_extra" type="submit" class="button">Login</button>
                </form>
                <p id="auth-status_extra" style="margin-top: 0.5em; color: #f1c40f;"></p>
            </div>
            <div id="logout-container_extra" style="display:none;">
                <p>Logged in as: <span id="loggedInUserEmail_extra"></span></p>
                <button id="logoutButton_extra" class="button secondary">Logout</button>
            </div>
        </div>

        <div id="current-profile-display-container" style="display:none;">
            <p id="current-profile-display">Today's Auto Profile: (determining...)</p>
        </div>

        <div id="top-menu-bar_extra" style="display:none;">
            <div id="main-menu-buttons_extra">
                <button class="menu-button" data-section="day-profile-override-section_extra">Day Profile Override</button>
                <button class="menu-button" data-section="stop-manager-tool-section_extra">Stop Management & Creation</button>
                <button class="menu-button" data-section="global-route-deletion-section_extra">Global Route Deletion</button>
                <button class="menu-button" data-section="route-schedule-generator-section_extra">Route Schedule Generator</button>
                <button class="menu-button" data-section="route-profile-deletion-section_extra">Route Profile Deletion</button>
                <button class="menu-button" data-section="service-analyzer-section_extra">Service Analyzer</button>
                <button class="menu-button" data-section="timetable-exporter-section_extra">Timetable Exporter</button>
            </div>
        </div>

        <div id="tool-sections-wrapper_extra">

<div id="timetable-exporter-section_extra" class="tool-content-section section" style="display:none;">
    <h2>Route Timetable Exporter</h2>
    <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
        Select a route to download its full timetable as an Excel (.xlsx) file.
        The file will contain separate sheets for each Operating Profile and Destination combination.
    </p>
    <div class="subsection">
        <h3 class="subsection-title">Select Route</h3>
        <div class="form-grid" style="grid-template-columns: 3fr 1fr; align-items: end;">
            <div>
                <label for="tte-routeName-select-extra">Route Name (Select or Type):</label>
                <select id="tte-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                    <option value="">-- Select Route --</option>
                    {/* Options will be populated by JavaScript */}
                </select>
                <input type="text" id="tte-routeName-input-extra" class="schedule-generator-input" placeholder="Or Type Route Name">
            </div>
            <div>
                <button id="tte-downloadTimetable-button-extra" class="button save" style="width:100%;">Download Timetable</button>
            </div>
        </div>
        <p id="tte-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
    </div>
</div>

            <div id="service-analyzer-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Service Analyzer</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity:0.8;">
                    Analyze stop coverage and view all routes serving a stop.
                </p>
                <div class="form-grid" style="grid-template-columns: 2fr 1fr; align-items: end;">
                        <div>
                            <label for="service-analyzer-stop-select-extra">Stop Name/ID (Select or Type):</label>
                            <select id="service-analyzer-stop-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Stop --</option>
                            </select>
                            <input type="text" id="service-analyzer-stop-input-extra" class="schedule-generator-input" placeholder="Or Type Stop Name/ID">
                        </div>
                        </div>
                            
                    <div id="service-analyzer-stop-summary-extra" style="margin-top:1rem; min-height:3em; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border: 1px solid rgba(127,140,141,0.2);">Select a stop and click "Analyze Stop".</div>
                </div>
              
            <div id="day-profile-override-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Operational Day Profile Override</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Use this tool to manually set a specific operating profile for an upcoming date, overriding the automatic calculation. Changes are saved immediately.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">Select Date and Override Profile</h3>
                    <div class="form-grid" style="grid-template-columns: 1fr 2fr 1fr; align-items: end; gap: 1rem;">
                        <div>
                            <label for="overrideDate_extra">Select Date:</label>
                            <input type="date" id="overrideDate_extra" class="schedule-generator-input">
                        </div>
                        <div>
                            <label for="overrideProfile_extra">Override Profile String:</label>
                            <input type="text" id="overrideProfile_extra" class="schedule-generator-input" placeholder="e.g., Su, MFSch, CustomHoliday">
                        </div>
                        <div>
                            <button id="setOverrideButton_extra" class="button save">Set Override</button>
                        </div>
                    </div>
                    <div style="margin-top: 1rem;">
                        <p style="font-size: 0.85em;">Normally for <span id="selectedDateDisplay_extra" style="font-weight:bold;">(select a date)</span>, the auto-profile would be: <strong id="autoProfileForSelectedDate_extra">(calculating...)</strong></p>
                        <p style="font-size: 0.85em;">Current override for selected date: <strong id="currentOverrideForSelectedDate_extra">(none)</strong></p>
                        <button id="clearOverrideButton_extra" class="button secondary" style="display:none; margin-top:0.5em;">Clear Override for This Date</button>
                    </div>
                    <p id="overrideStatusMessage_extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
                </div>
                <div class="subsection" style="margin-top: 2rem;">
                    <h3 class="subsection-title">Currently Active Overrides (Next 30 Days)</h3>
                    <div id="activeOverridesList_extra" style="max-height: 200px; overflow-y: auto; background-color: rgba(0,0,0,0.05); padding: 0.5rem; border-radius: 0.25rem;">
                        <p>Loading active overrides...</p>
                    </div>
                </div>
            </div>

            <div id="stop-manager-tool-section_extra" class="tool-content-section section" style="display:none;">
                 <h2>Stop Management & Creation (Live Updates)</h2>
                <div class="subsection">
                    <h3 class="subsection-title">Add New Stop Details</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        Define a new stop. The Stop ID will be auto-suggested based on format (inferred or randomly chosen based on name) and existing stop patterns. You can edit the suggested ID.
                        A placeholder schedule entry will be added to make it available in selectors. The Stop ID must be unique. Changes are saved directly to Firebase.
                    </p>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                        <div>
                            <label for="inputNewStopName_extra">New Stop Name (influences ID suggestion)</label>
                            <input type="text" id="inputNewStopName_extra" class="schedule-generator-input" placeholder="e.g., Yaddlethorpe Crossroads" autocomplete="off">
                        </div>
                        <div>
                             <label for="selectNewStopIdFormat_extra">System-Determined ID Format</label>
                             <select id="selectNewStopIdFormat_extra" class="schedule-generator-input" disabled>
                                <option value="NUM">Numeric (e.g., 101-99999)</option>
                                <option value="BP">BP Prefix (e.g., BP1-BP99999)</option>
                                <option value="LE">LE Prefix (e.g., LE1-LE99999)</option>
                                <option value="RO">RO Prefix (e.g., RO1-RO99999)</option>
                            </select>
                        </div>
                        <div>
                            <label for="inputNewStopId_extra">New Stop ID (auto-suggested, editable)</label>
                            <input type="text" id="inputNewStopId_extra" class="schedule-generator-input" placeholder="e.g., BP101" autocomplete="off">
                            <p id="newStopIdAvailability_extra"></p>
                        </div>
                        <div>
                            <label for="inputNewStopDirection_extra">New Stop Direction (Towards)</label>
                            <input type="text" id="inputNewStopDirection_extra" class="schedule-generator-input" placeholder="e.g., Ashby" autocomplete="off">
                        </div>
                    </div>
                     <p id="addNewStopStatus_extra" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                    <div style="margin-top: 1rem;">
                        <button id="buttonAddNewStop_extra" class="button save">Add New Stop Details (Live)</button>
                    </div>
                </div>

                <div class="subsection"> <h3 class="subsection-title">Bulk Merge or Add Stops (via Excel File)</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        This tool will <strong style="color: #f1c40f;">REPLACE ALL EXISTING STOPS AND SCHEDULES</strong> with data derived from the uploaded Excel file.
                        <br>- The system will attempt to generate unique StopIDs based on StopName. If a StopID is provided in Column A, it will be used (must be unique within the file).
                        <br>- LineName(s) from Excel will be used to create placeholder schedule entries for each stop.
                        <br><b>Expected Excel columns:</b>
                        <br>Column A: <b>StopID</b> (Optional - if blank, system generates. If provided, must be unique in the file.)
                        <br>Column B: <b>StopName</b> (Required)
                        <br>Column C: <b>Direction</b> (Optional - "Towards" text)
                        <br>Column D: <b>LineName(s)</b> (Optional - comma-separated, e.g., "9, 12, 34". Defaults to "INFO_ONLY".)
                        <br><i>The first row of the sheet should contain data, not headers.</i>
                        All changes are saved directly to Firebase. <strong style="color: #e74c3c;">USE WITH EXTREME CAUTION.</strong>
                    </p>
                    <div class="form-field-group">
                        <label for="fileInputBulkAddStops_extra" class="button neutral" style="display: inline-block; margin-bottom: 0.5rem; background-color: #546E7A; cursor:pointer;">Choose Excel File (.xlsx, .xls)</label>
                        <input type="file" id="fileInputBulkAddStops_extra" accept=".xlsx, .xls" style="display: none;">
                        <p id="fileNameBulkAddStops_extra" style="font-size: 0.85em; margin-top: 0.25rem; min-height: 1.2em;">No file selected.</p>
                    </div>
                    <p id="bulkAddNewStopsStatus_extra" style="min-height:1.2em; margin-top: 0.75rem; white-space: pre-line;"></p>
                    <div style="margin-top: 1rem;">
                        <button id="buttonBulkAddNewStops_extra" class="button tertiary">Replace All Stops & Schedules from File (Live)</button> </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Master List of Unique Stops (with ID Change Capability)</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.75rem;">
                        View and edit stop details. You can also propose new Stop IDs for existing stops.
                        All proposed Stop ID changes are applied in bulk using the button at the bottom of this list.
                        Other actions (Edit Name / Direction, Delete, Open / Close) are immediate for that specific stop.
                    </p>
                    <div class="form-grid" style="grid-template-columns: 1fr auto auto auto; gap: 0.75rem; margin-bottom: 0.5rem;">
                        <input type="text" id="masterStopListFilterInput_extra" class="schedule-generator-input" placeholder="Filter by Stop ID, Name, Route, Status...">
                        <button id="refreshMasterStopListButton_extra" class="button neutral">Refresh List</button>
                        <button id="exportUniqueStopsButton_extra" class="button" style="background-color: #00796B;">Export Stops</button>
                        <button id="findDuplicateStopsByNameDirButton_extra" class="button tertiary">Find Duplicates (Name / Direction)</button>
                    </div>
                    <div id="duplicateStopsByNameDirResults_extra" style="margin-bottom: 0.75rem; padding: 0.5rem; background-color: rgba(0,0,0,0.1); border-radius: 0.25rem; min-height: 1.5em; font-size: 0.85em;">
                        Click "Find Duplicates (Name/Dir)" to check. </div>
                    <div id="masterStopListContainer_extra" class="subsection" style="padding: 0.5rem; background-color: rgba(0,0,0,0.05); margin-top:0;">
                        <ul id="masterStopListUL_extra" style="list-style: none; padding: 0;"></ul> </div>
                    <p id="masterStopListStatus_extra" style="text-align: center; margin-top: 0.5rem; min-height: 1.2em;">Click "Refresh List" to load stops.</p>

                    <div class="subsection" style="margin-top: 1.5rem; text-align: center;">
                        <button id="applyMasterListStopIdChangesButton_extra" class="button save" style="padding: 0.8rem 1.5rem;">Apply All Stop ID Changes from List (Live)</button>
                        <p id="masterListApplyChangesStatus_extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
                    </div>
                </div>
            </div>

            <div id="global-route-deletion-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Global Route Deletion (Live)</h2>
                <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                    Click on route tiles below to select them for deletion. This will remove ALL of their schedule entries from ALL stops in the live schedule.
                    It will also remove their global custom colour and any stop-specific colour overrides for the selected routes.
                    <strong>This action is highly destructive and directly modifies live data.</strong>
                </p>
                <div class="form-field-group">
                    <label>Select Route(s) to Delete Globally by clicking tiles:</label>
                    <div id="globalRouteDeletionListContainer_el_extra" class="subsection" style="max-height: 300px; overflow-y: auto; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border: 1px solid rgba(127,140,141,0.2);">
                        <p>Loading routes...</p> </div>
                </div>
                <button id="deleteEntireRouteButton_el_extra" class="button secondary" style="margin-top: 0.5rem;">Delete Selected Route(s) (Live)</button>
                <p id="deleteEntireRouteStatusMessage_el_extra" style="min-height:1.2em; margin-top:0.75rem;"></p>
            </div>

            <div id="route-profile-deletion-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Selective Route Profile Deletion</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    This tool allows you to delete specific operating profiles for a chosen route.
                    You can optionally narrow this down to a particular destination. Deleting a profile here will remove
                    all its associated schedule entries from the live data for the specified route/destination combination.
                    <strong>This action is highly destructive. Please double-check your selections.</strong>
                </p>

                <div class="subsection">
                    <h3 class="subsection-title">1. Selection Criteria</h3>
                    <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem 1.5rem; align-items: end;">
                        <div>
                            <label for="rpd-route-name-select-extra">Route Name (Select or Type):</label>
                            <select id="rpd-route-name-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Route --</option>
                                </select>
                            <input type="text" id="rpd-route-name-input-extra" class="schedule-generator-input" placeholder="Or Type Route Name">
                        </div>
                        <div>
                            <label for="rpd-destination-name-select-extra">Destination Name (Optional - Select or Type):</label>
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <select id="rpd-destination-name-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem; flex-grow:1;" disabled>
                                    <option value="">-- Optional: All Destinations --</option>
                                     </select>
                                <button id="rpd-clear-destination-button-extra" class="button small-action neutral" title="Clear Destination Filter (Show All Destinations for Route)" style="display:none; padding: 0.4rem 0.6rem; margin-bottom:0.25rem; line-height: 1.5;">âœ•</button>
                            </div>
                            <input type="text" id="rpd-destination-name-input-extra" class="schedule-generator-input" placeholder="Or Type Destination (Leave Blank for All)" disabled>
                        </div>
                    </div>
                </div>

                <div class="subsection" style="margin-top:1.5rem;">
                    <h3 class="subsection-title">2. Select Profile(s) to Delete</h3>
                    <div class="form-field-group">
                        <label style="margin-bottom:0.5rem; display:block;">Available Profiles for Selected Criteria (Click tiles to select for deletion):</label>
                        <div id="rpd-profile-list-container-extra" class="subsection" style="min-height: 60px; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border: 1px solid rgba(127,140,141,0.2);">
                            <p style="font-size:0.85em; opacity:0.7;">Select a route to see available profiles.</p>
                            </div>
                    </div>
                </div>

                <div class="subsection" style="margin-top:1.5rem;">
                    <h3 class="subsection-title">3. Execute Deletion</h3>
                    <button id="rpd-delete-profiles-button-extra" class="button secondary" style="margin-top: 0.5rem;">Delete Selected Profile(s) (Live)</button>
                    <p id="rpd-status-message-extra" style="min-height:1.2em; margin-top:0.75rem; font-weight:bold;"></p>
                </div>
            </div>
            
            <div id="route-schedule-generator-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Route Schedule Generator</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Create or modify a schedule for a route. Saved configurations can be loaded, or you can copy stops from an existing route.
                </p>
                <div class="subsection"> <h3 class="subsection-title">1. Route & Profile Definition</h3>
                    <p style="font-size:0.8em; margin-bottom:0.75em; opacity:0.7;">
                        Select Route, Profile, and Destination. System will try to load a saved configuration or pull from existing schedule. If Operating Profile is left blank, a default may be used for initial display.
                    </p>
                
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr; gap: 1rem 1.5rem;">
                        <div class="form-field-group">
                            <label for="rsg-routeName-select-extra">Route Name (Select or Type New):</label>
                            <select id="rsg-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Existing Route --</option>
                            </select>
                            <input type="text" id="rsg-routeName-input-extra" class="schedule-generator-input" placeholder="Or Type New Route Name">
                        </div>
                        <div class="form-field-group">
                            <label for="rsg-destinationName-select-extra">Destination Name (Select for Route or Type New):</label>
                            <select id="rsg-destinationName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Route First --</option>
                            </select>
                            <input type="text" id="rsg-destinationName-input-extra" class="schedule-generator-input" placeholder="Or Type New Destination Name">
                        </div>
                    </div>
                
                    <div class="form-field-group" style="margin-top: 1rem;">
                        <label style="display: block; margin-bottom: 0.5rem;">Operating Profile(s) (Select all that apply):</label>
                        <div id="rsg-selectable-profiles-container-extra" class="subsection" style="margin-top: 0.25rem; padding: 0.75rem; background-color: rgba(0,0,0,0.07); border-radius: 0.25rem; min-height: 80px; /*max-height and overflow-y removed*/ display: flex; flex-wrap: wrap; gap: 0.5rem 1rem;">
                            <p id="rsg-profiles-placeholder-extra" style="font-size: 0.8em; opacity: 0.7;">Loading profiles...</p>
                        </div>
                    </div>
                
                    <div class="form-field-group" style="margin-top: 0.75rem;">
                        <label style="font-size: 0.9em; color: #bdc3c7;">Currently Selected & Active:</label>
                        <p id="rsg-selected-profiles-display-extra" style="padding: 0.5rem; background-color: rgba(0,0,0,0.15); border-radius: 0.25rem; min-height: 1.5em; color: #ecf0f1; font-weight: bold; border: 1px solid rgba(127,140,141,0.3);"></p>
                    </div>
                
                    <div style="margin-top: 0.5rem;">
                        <button id="rsg-clear-profile-checkboxes-button-extra" class="button neutral" style="margin-left:0; padding: 0.4rem 0.8rem; font-size: 0.85em;">Clear Selected Profiles</button>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">2. Define Stop Sequence & Timings</h3>
                    <button id="rsg-open-copy-modal-button-extra" class="button neutral" style="margin-bottom: 0.5rem;">Copy Stops From Another Route/Profile...</button>
                    <div class="form-field-group">
                        <label for="rsg-stop-search-input-extra">Search and Add Stop to Sequence:</label>
                        <input type="text" id="rsg-stop-search-input-extra" class="schedule-generator-input" placeholder="Type to search stops by name or ID...">
                        <div id="rsg-stop-search-results-extra"></div>
                    </div>

                    <label>Stop Sequence (Drag to reorder. First stop times, subsequent stops are adjustments in minutes from previous):</label>
                    <div id="rsg-stop-sequence-container-extra" class="subsection" style="padding:0.5rem; background-color:rgba(0,0,0,0.05); min-height: 100px;">
                        <ul id="rsg-stop-sequence-list-extra" style="list-style: none; padding: 0;">
                            </ul>
                        <p id="rsg-stop-sequence-placeholder-extra" style="text-align:center; opacity:0.7; padding:1rem;">Add stops using the search, copy from another route, or load a configuration.</p>
                    </div>
                     <div class="form-field-group" id="rsg-first-stop-times-container-extra" style="display:none;">
                        <label for="rsg-first-stop-times-input-extra">Departure Times for First Stop (HH:MM, comma/tab/semicolon separated):</label>
                        <textarea id="rsg-first-stop-times-input-extra" class="schedule-generator-input" rows="2" placeholder="07:00, 07:15; 07:30   08:00"></textarea>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">3. Generate & Add to Working Schedule</h3>
                    <button id="rsg-generate-schedule-button-extra" class="button save">Generate Schedule Preview</button>
                    <button id="rsg-save-configuration-button-extra" class="button" style="background-color: #546E7A; margin-left:0.5rem;">Save Current Configuration</button>
                    <button id="rsg-add-to-working-schedule-button-extra" class="button tertiary" style="display:none; margin-left:0.5rem;">Add Generated to Working Schedule</button>
                    <p id="rsg-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
                    <div id="rsg-schedule-preview-container-extra" class="subsection" style="margin-top:1rem; max-height:300px; overflow-y:auto; display:none;">
                        <h4>Preview of Generated Schedule Entries:</h4>
                        <table id="rsg-preview-table-extra" style="width:100%; font-size:0.85em; border-collapse:collapse;">
                            <thead>
                                <tr>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Stop ID</th>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Stop Name</th>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Time</th>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Route</th>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Dest</th>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Profile</th>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Offset</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Saved Configurations</h3>
                    <div id="rsg-saved-configs-list-extra" style="padding: 0.5em; background-color: rgba(0,0,0,0.05); border: 1px solid rgba(127,140,141,0.2); border-radius: 0.25rem;">
                        <p id="rsg-no-saved-configs-message-extra" style="padding: 0.5em; text-align: center; opacity: 0.7;">No configurations saved yet.</p>
                        </div>
                    <p id="rsg-load-status-message-extra" style="min-height:1.2em; margin-top:0.5em; font-size:0.85em;"></p>
                </div>

            </div> </div> </div> <div id="rsg-save-config-modal-extra" class="rsg-modal" style="display:none;">
        <div class="rsg-modal-content">
            <h4 style="margin-top:0;">Save Configuration As</h4>
            <div class="form-field-group">
                <label for="rsg-config-name-input-extra">Configuration Name:</label>
                <input type="text" id="rsg-config-name-input-extra" class="schedule-generator-input" placeholder="e.g., 4_Skippingdale_MFSch">
            </div>
            <div class="rsg-modal-actions">
                <button id="rsg-save-config-confirm-button-extra" class="button save">Save</button>
                <button id="rsg-save-config-cancel-button-extra" class="button neutral">Cancel</button>
            </div>
            <p id="rsg-save-config-modal-status-extra" style="min-height:1.2em; margin-top:0.75em; font-size:0.85em;"></p>
        </div>
    </div>

    <div id="rsg-copy-modal-extra" style="position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 1000; justify-content: center; align-items: center; display: none;">
        <div style="background: linear-gradient(135deg, #3a506b, #2c3e50); color: #ecf0f1; padding: 25px; border-radius: 8px; width: 90%; max-width: 550px; box-shadow: 0 5px 20px rgba(0,0,0,0.4); border: 1px solid #4a6a80;">
            <h3 class="subsection-title" style="margin-top:0; padding-bottom: 0.5rem; border-color: #567a9a;">Copy Stops From Source</h3>
            <p style="font-size:0.85em; margin-bottom:1.5rem; opacity:0.9;">
                Select the source Route, Operating Profile, and Destination from which to copy the stop sequence, time adjustments, and first stop departure times.
            </p>
            <div class="form-field-group">
                <label for="rsg-copy-source-routeName-select-extra">Source Route Name:</label>
                <select id="rsg-copy-source-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                    <option value="">-- Select Source Route --</option>
                </select>
                <input type="text" id="rsg-copy-source-routeName-input-extra" class="schedule-generator-input" placeholder="Or Type Source Route Name">
            </div>
            <div class="form-field-group">
                <label for="rsg-copy-source-operatingProfile-input-extra">Source Operating Profile:</label>
                <input type="text" id="rsg-copy-source-operatingProfile-input-extra" class="schedule-generator-input" placeholder="Enter Source Operating Profile (e.g., MF, Sa)">
            </div>
            <div class="form-field-group">
                <label for="rsg-copy-source-destinationName-select-extra">Source Destination Name:</label>
                <select id="rsg-copy-source-destinationName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                    <option value="">-- Select Source Route First --</option>
                </select>
                <input type="text" id="rsg-copy-source-destinationName-input-extra" class="schedule-generator-input" placeholder="Or Type Source Destination Name">
            </div>
            <p id="rsg-copy-modal-status-extra" style="min-height:1.2em; margin-top: 0.75rem; font-weight:bold;"></p>
            <div style="margin-top: 1.5rem; text-align: right; display: flex; justify-content: flex-end; gap: 0.5rem;">
                <button id="rsg-copy-modal-cancel-button-extra" class="button neutral">Cancel</button>
                <button id="rsg-copy-modal-action-button-extra" class="button save">Copy Data</button>
            </div>
    </div>


<script type="module">
      // Firebase App initialization (content unchanged)
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s", // Replace with your actual Firebase API Key
        authDomain: "omsi-c5505.firebaseapp.com", // Replace with your actual Firebase Auth Domain
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app", // Replace with your actual Firebase Database URL
        projectId: "omsi-c5505", // Replace with your actual Firebase Project ID
        storageBucket: "omsi-c5505.appspot.com", // Replace with your actual Firebase Storage Bucket
        messagingSenderId: "503595375440", // Replace with your actual Firebase Messaging Sender ID
        appId: "1:503595375440:web:356be6684b77ff5909ea55", // Replace with your actual Firebase App ID
        measurementId: "G-VN7X65V3F9" // Replace with your actual Firebase Measurement ID
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);

      window.firebaseOMSI = {
          database: database, auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut
      };
      console.log("Firebase Initialized for OMSI Tools Extra.");
      document.dispatchEvent(new CustomEvent('firebaseReady', { detail: window.firebaseOMSI }));
    </script>

<script>
// --- Global State Variables ---
        let rsg_configKeyToRename_extra = null;
        let currentUser_extra = null;
        let pageSpecificSettings = {};
        let ukBankHolidaysData_extra = { dates: [], titles: {} };
        const schoolHolidayDateRanges_extra = [];
        let currentWorkingSchedule_extra = []; // This will be populated by flattening the new structure on load
        let closedStopIDs_extra = [];
        let globalCustomRouteColours_extra = {};
        let stopSpecificRouteColours_extra = {};
        let uniqueStopsMasterList_extra = [];
        let processedExcelStopsData_extra = [];
        let rsg_selectedStops_extra = [];
        let rsg_generatedPreviewEntries_extra = [];
        let rsg_loadedConfigs_extra = {};
        let rsg_lastLoadedRouteName_extra = null;
        let rsg_lastLoadedDestName_extra = null;
        let rsg_lastLoadedOpProfile_extra = null;
        let rsg_draggedItemIndex_extra = null;


        // --- Firebase Path Constants ---
        const FB_PATH_PAGE_EXTRA_SETTINGS = '/settings/extraModulesPageSettings';
        const FB_PATH_OPERATIONAL_OVERRIDES = '/operationalOverrides';
        // Replaced FB_PATH_LIVE_SCHEDULE_DATA with FB_PATH_SCHEDULES_BY_ROUTE
        const FB_PATH_SCHEDULES_BY_ROUTE = '/liveSchedule/schedulesByRoute'; // New path for structured schedule data
        const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
        const FB_PATH_APPSTATE_LAST_UPDATED = '/appState/scheduleLastUpdated';
        const FB_PATH_APPSTATE_CLOSED_STOPS = '/appState/closedStopIDs';
        const FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS = '/settings/customRouteColours';
        const FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS = '/settings/stopSpecificRouteColours';
        const FB_PATH_RSG_CONFIGS = '/rsgConfigs';


        // --- DOM Elements ---
        const tteRouteNameSelect_el_extra = document.getElementById('tte-routeName-select-extra');
        const tteRouteNameInput_el_extra = document.getElementById('tte-routeName-input-extra');
        const tteDownloadTimetableButton_el_extra = document.getElementById('tte-downloadTimetable-button-extra');
        const tteStatusMessage_el_extra = document.getElementById('tte-status-message-extra');
        const authSection_el_extra = document.getElementById('auth-section');
        const loginFormContainer_el_extra = document.getElementById('login-form-container_extra');
        const adminLoginForm_el_extra = document.getElementById('adminLoginForm_extra');
        const inputEmail_el_extra = document.getElementById('inputEmail_extra');
        const inputPassword_el_extra = document.getElementById('inputPassword_extra');
        const authStatus_el_extra = document.getElementById('auth-status_extra');
        const logoutContainer_el_extra = document.getElementById('logout-container_extra');
        const loggedInUserEmailDisplay_el_extra = document.getElementById('loggedInUserEmail_extra');
        const topMenuBar_el_extra = document.getElementById('top-menu-bar_extra');
        const toolSectionsWrapper_el_extra = document.getElementById('tool-sections-wrapper_extra');
        const currentProfileDisplayContainer_el = document.getElementById('current-profile-display-container');
        const currentProfileDisplayElement_el = document.getElementById('current-profile-display');
        // Day Profile Override
        const overrideDateInput_el_extra = document.getElementById('overrideDate_extra');
        const overrideProfileInput_el_extra = document.getElementById('overrideProfile_extra');
        const setOverrideButton_el_extra = document.getElementById('setOverrideButton_extra');
        const clearOverrideButton_el_extra = document.getElementById('clearOverrideButton_extra');
        const overrideStatusMessage_el_extra = document.getElementById('overrideStatusMessage_extra');
        const selectedDateDisplay_el_extra = document.getElementById('selectedDateDisplay_extra');
        const autoProfileForSelectedDate_el_extra = document.getElementById('autoProfileForSelectedDate_extra');
        const currentOverrideForSelectedDate_el_extra = document.getElementById('currentOverrideForSelectedDate_extra');
        const activeOverridesList_el_extra = document.getElementById('activeOverridesList_extra');
        // Stop Management & Creation
        const selectNewStopIdFormat_el_extra = document.getElementById('selectNewStopIdFormat_extra');
        const inputNewStopId_el_extra = document.getElementById('inputNewStopId_extra');
        const newStopIdAvailability_el_extra = document.getElementById('newStopIdAvailability_extra');
        const inputNewStopName_el_extra = document.getElementById('inputNewStopName_extra');
        const inputNewStopDirection_el_extra = document.getElementById('inputNewStopDirection_extra');
        const buttonAddNewStop_el_extra = document.getElementById('buttonAddNewStop_extra');
        const addNewStopStatus_el_extra = document.getElementById('addNewStopStatus_extra');
        const fileInputBulkAddStops_el_extra = document.getElementById('fileInputBulkAddStops_extra');
        const fileNameBulkAddStops_el_extra = document.getElementById('fileNameBulkAddStops_extra');
        const buttonBulkAddNewStops_el_extra = document.getElementById('buttonBulkAddNewStops_extra');
        const bulkAddNewStopsStatus_el_extra = document.getElementById('bulkAddNewStopsStatus_extra');
        const masterStopListFilterInput_el_extra = document.getElementById('masterStopListFilterInput_extra');
        const refreshMasterStopListButton_el_extra = document.getElementById('refreshMasterStopListButton_extra');
        const masterStopListUL_el_extra = document.getElementById('masterStopListUL_extra');
        const masterStopListStatus_el_extra = document.getElementById('masterStopListStatus_extra');
        const applyMasterListStopIdChangesButton_el_extra = document.getElementById('applyMasterListStopIdChangesButton_extra');
        const masterListApplyChangesStatus_el_extra = document.getElementById('masterListApplyChangesStatus_extra');
        const exportUniqueStopsButton_el_extra = document.getElementById('exportUniqueStopsButton_extra');
        const findDuplicateStopsByNameDirButton_el_extra = document.getElementById('findDuplicateStopsByNameDirButton_extra');
        const duplicateStopsByNameDirResults_el_extra = document.getElementById('duplicateStopsByNameDirResults_extra');
        // Global Route Deletion
        const globalRouteDeletionListContainer_el_extra = document.getElementById('globalRouteDeletionListContainer_el_extra');
        const deleteEntireRouteButton_el_extra = document.getElementById('deleteEntireRouteButton_el_extra');
        const deleteEntireRouteStatusMessage_el_extra = document.getElementById('deleteEntireRouteStatusMessage_el_extra');
        // Route Schedule Generator (RSG)
        const rsgRouteNameSelect_el_extra = document.getElementById('rsg-routeName-select-extra');
        const rsgRouteNameInput_el_extra = document.getElementById('rsg-routeName-input-extra');
        //const rsgOperatingProfileInput_el_extra = document.getElementById('rsg-operatingProfile-input-extra');
        const rsgDestinationNameSelect_el_extra = document.getElementById('rsg-destinationName-select-extra');
        const rsgDestinationNameInput_el_extra = document.getElementById('rsg-destinationName-input-extra');
        const rsgStopSearchInput_el_extra = document.getElementById('rsg-stop-search-input-extra');
        const rsgStopSearchResults_el_extra = document.getElementById('rsg-stop-search-results-extra');
        const rsgStopSequenceList_el_extra = document.getElementById('rsg-stop-sequence-list-extra');
        const rsgStopSequencePlaceholder_el_extra = document.getElementById('rsg-stop-sequence-placeholder-extra');
        const rsgFirstStopTimesContainer_el_extra = document.getElementById('rsg-first-stop-times-container-extra');
        const rsgFirstStopTimesInput_el_extra = document.getElementById('rsg-first-stop-times-input-extra');
        const rsgGenerateScheduleButton_el_extra = document.getElementById('rsg-generate-schedule-button-extra');
        const rsgSaveConfigurationButton_el_extra = document.getElementById('rsg-save-configuration-button-extra');
        const rsgAddToWorkingScheduleButton_el_extra = document.getElementById('rsg-add-to-working-schedule-button-extra');
        const rsgStatusMessage_el_extra = document.getElementById('rsg-status-message-extra');
        const rsgSchedulePreviewContainer_el_extra = document.getElementById('rsg-schedule-preview-container-extra');
        const rsgPreviewTableBody_el_extra = document.getElementById('rsg-preview-table-extra')?.getElementsByTagName('tbody')[0];
        const rsgOpenCopyModalButton_el_extra = document.getElementById('rsg-open-copy-modal-button-extra');
        const rsgCopyModal_el_extra = document.getElementById('rsg-copy-modal-extra');
        const rsgCopySourceRouteNameSelect_el_extra = document.getElementById('rsg-copy-source-routeName-select-extra');
        const rsgCopySourceRouteNameInput_el_extra = document.getElementById('rsg-copy-source-routeName-input-extra');
        const rsgCopySourceOpProfileInput_el_extra = document.getElementById('rsg-copy-source-operatingProfile-input-extra');
        const rsgCopySourceDestNameSelect_el_extra = document.getElementById('rsg-copy-source-destinationName-select-extra');
        const rsgCopySourceDestNameInput_el_extra = document.getElementById('rsg-copy-source-destinationName-input-extra');
        const rsgCopyModalStatus_el_extra = document.getElementById('rsg-copy-modal-status-extra');
        const rsgCopyModalCancelButton_el_extra = document.getElementById('rsg-copy-modal-cancel-button-extra');
        const rsgCopyModalActionButton_el_extra = document.getElementById('rsg-copy-modal-action-button-extra');
        // Route Profile Deletion (RPD) - NEW
        const rpdRouteSelect_el_extra = document.getElementById('rpd-route-name-select-extra');
        const rpdRouteInput_el_extra = document.getElementById('rpd-route-name-input-extra');
        const rpdDestinationSelect_el_extra = document.getElementById('rpd-destination-name-select-extra');
        const rpdDestinationInput_el_extra = document.getElementById('rpd-destination-name-input-extra');
        const rpdClearDestinationButton_el_extra = document.getElementById('rpd-clear-destination-button-extra');
        const rpdProfileListContainer_el_extra = document.getElementById('rpd-profile-list-container-extra');
        const rpdDeleteProfilesButton_el_extra = document.getElementById('rpd-delete-profiles-button-extra');
        const rpdStatusMessage_el_extra = document.getElementById('rpd-status-message-extra');


        // --- Helper Functions ---
        function sanitizeFirebaseKey(text) {
            if (typeof text !== 'string') return '';
            // Replace forbidden characters with an underscore
            // Firebase forbids '.', '#', '$', '[', ']'
            return text.replace(/[.#$[\]]/g, '_');
        }

        function getYYYYMMDD_ExtraPage(dateSource) { const d = dateSource ? new Date(dateSource) : new Date(); const year = d.getFullYear(); const month = String(d.getMonth() + 1).padStart(2, '0'); const day = String(d.getDate()).padStart(2, '0'); return `${year}-${month}-${day}`; }
        function formatDateToDDMonthYYYY_ExtraPage(dateStringYYYYMMDD) { if (!dateStringYYYYMMDD || !/^\d{4}-\d{2}-\d{2}$/.test(dateStringYYYYMMDD)) return "Invalid Date"; const [year, month, day] = dateStringYYYYMMDD.split('-'); const dateObj = new Date(year, month - 1, day); const options = { day: '2-digit', month: 'long', year: 'numeric' }; return dateObj.toLocaleDateString('en-GB', options); }
        function getUniqueStopsFromSchedule_ExtraPage() { if (!currentWorkingSchedule_extra || currentWorkingSchedule_extra.length === 0) return []; const stopsMap = new Map(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID && !stopsMap.has(entry.stopID.toUpperCase())) { stopsMap.set(entry.stopID.toUpperCase(), { stopID: entry.stopID, stopName: entry.stopName || "Unknown Name", direction: entry.direction || "No Direction" }); } }); return Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase())); }
        function parseLineName_ExtraPage(lineNameStr) { const name = String(lineNameStr || "").toUpperCase().trim(); const numericPrefixRegex = new RegExp(/^(\d+)([A-Z]*)$/); const alphaNumericRegex = new RegExp(/^([A-Z]+)(\d+)?([A-Z]*)$/); const numericPrefixMatch = name.match(numericPrefixRegex); if (numericPrefixMatch) return { type: 'numeric', number: parseInt(numericPrefixMatch[1], 10), suffix: numericPrefixMatch[2] || '', original: name }; const alphaNumericMatch = name.match(alphaNumericRegex); if (alphaNumericMatch) return { type: 'alpha', prefix: alphaNumericMatch[1], number: alphaNumericMatch[2] ? parseInt(alphaNumericMatch[2], 10) : null, suffix: alphaNumericMatch[3] || '', original: name }; return { type: 'other', original: name }; }
        function compareLineNames_ExtraPage(lineAStr, lineBStr) { const parsedA = parseLineName_ExtraPage(lineAStr); const parsedB = parseLineName_ExtraPage(lineBStr); if (parsedA.type === 'numeric' && parsedB.type === 'alpha') return -1; if (parsedA.type === 'alpha' && parsedB.type === 'numeric') return 1; if (parsedA.type === 'numeric' && parsedB.type === 'numeric') { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type === 'alpha' && parsedB.type === 'alpha') { const prefixCompare = parsedA.prefix.localeCompare(parsedB.prefix); if (prefixCompare !== 0) return prefixCompare; if (parsedA.number === null && parsedB.number !== null) return -1; if (parsedA.number !== null && parsedB.number === null) return 1; if (parsedA.number !== null && parsedB.number !== null) { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; } return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type !== 'other' && parsedB.type === 'other') return -1; if (parsedA.type === 'other' && parsedB.type !== 'other') return 1; return (parsedA.original || "").localeCompare(parsedB.original || ""); }
        const initialRouteColourMapForTools_extra = {}; const DEFAULT_ROUTE_COLOUR_TOOLS_extra = "#73809C"; const NIGHT_BUS_BLUE_COLOR_extra = (initialRouteColourMapForTools_extra["NIGHT_DEFAULT"] || "#4CDBE6").toUpperCase();
        function getRouteTileColour_ExtraPage(lineName, stopID = null) { const upName = String(lineName || "").toUpperCase(); if (stopID && stopSpecificRouteColours_extra[stopID.toUpperCase()] && stopSpecificRouteColours_extra[stopID.toUpperCase()][upName]) { return stopSpecificRouteColours_extra[stopID.toUpperCase()][upName]; } if (globalCustomRouteColours_extra[upName]) return globalCustomRouteColours_extra[upName]; if (initialRouteColourMapForTools_extra[upName]) return initialRouteColourMapForTools_extra[upName]; if (upName.startsWith("N")) return globalCustomRouteColours_extra["NIGHT_DEFAULT"] || NIGHT_BUS_BLUE_COLOR_extra; if (upName.startsWith("SL")) return globalCustomRouteColours_extra["SL_DEFAULT"] || "#D32F2F"; return DEFAULT_ROUTE_COLOUR_TOOLS_extra; }
        function getTextColourForBackground_ExtraPage(hex) { if(!hex || hex.length < 7) return '#FFFFFF'; const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16); return ((0.299*r + 0.587*g + 0.114*b)/255) > 0.5 ? '#000000' : '#FFFFFF'; }
        async function fetchBankHolidays_ExtraPage() { try { const response = await fetch('https://www.gov.uk/bank-holidays.json'); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); if (data['england-and-wales'] && data['england-and-wales'].events) { const events = data['england-and-wales'].events; ukBankHolidaysData_extra = { dates: events.map(event => event.date), titles: events.reduce((acc, event) => { acc[event.date] = event.title; return acc; }, {}) }; } else { ukBankHolidaysData_extra = { dates: [], titles: {} }; } } catch (error) { console.error("ExtraPage: Failed to fetch UK bank holidays:", error); ukBankHolidaysData_extra = { dates: [], titles: {} }; if(currentProfileDisplayElement_el) currentProfileDisplayElement_el.textContent = "Today's Auto Profile: (Bank Hol. check failed)"; } updateCurrentProfileDisplay_ExtraPage(); }
        function isSchoolHolidayPeriod_ExtraPage(dateObject) { if (!schoolHolidayDateRanges_extra || schoolHolidayDateRanges_extra.length === 0) return false; const checkTime = dateObject.getTime(); for (const range of schoolHolidayDateRanges_extra) { try { const startTime = new Date(range.start + "T00:00:00").getTime(); const endTime = new Date(range.end + "T23:59:59").getTime(); if (checkTime >= startTime && checkTime <= endTime) return true; } catch (e) { console.error("Invalid date in schoolHolidayDateRanges_extra:", range, e); } } return false; }
        function getOperatingCodesForDate_ExtraPage(dateObject) { const n = dateObject; const dOW = n.getDay(); const todayDateString = `${n.getFullYear()}-${String(n.getMonth()+1).padStart(2,'0')}-${String(n.getDate()).padStart(2,'0')}`; let dateCodes = new Set(); let isBankHolidayToday = false; if (ukBankHolidaysData_extra && ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(todayDateString)) { const holidayTitle = ukBankHolidaysData_extra.titles[todayDateString] || ""; isBankHolidayToday = true; if (holidayTitle.toLowerCase().includes("good friday")) dateCodes.add("Sa"); else dateCodes.add("Su"); } if (!isBankHolidayToday) { const isSchHol = isSchoolHolidayPeriod_ExtraPage(n); const schoolSuffix = isSchHol ? "NSD" : "Sch"; let dayCode = ""; switch (dOW) { case 0: dayCode="Su"; break; case 1: dayCode="Mo"; break; case 2: dayCode="Tu"; break; case 3: dayCode="We"; break; case 4: dayCode="Th"; break; case 5: dayCode="Fr"; break; case 6: dayCode="Sa"; break; } dateCodes.add(dayCode); if (dOW >= 1 && dOW <= 5) { dateCodes.add(dayCode + schoolSuffix); dateCodes.add("MF" + schoolSuffix); dateCodes.add("MF"); } if ((dOW === 6 || dOW === 0) && isSchHol) dateCodes.add(dayCode + "NSD"); if (isSchHol) dateCodes.add("SchoolHoliday"); } else { const isSchHolOnBH = isSchoolHolidayPeriod_ExtraPage(n); if (isSchHolOnBH) { dateCodes.add("SchoolHoliday"); if(dateCodes.has("Sa")) dateCodes.add("SaNSD"); if(dateCodes.has("Su") && !dateCodes.has("Sa")) dateCodes.add("SuNSD");} } return Array.from(dateCodes); }

        async function updateCurrentProfileDisplay_ExtraPage() {
    const now = new Date();
    const todayDateString = getYYYYMMDD_ExtraPage(now); // Helper function to get YYYY-MM-DD
    let profileDisplayText = "";
    let serviceTypeDisplay = ""; // Used for bank holiday descriptions
    let operatingCodes = [];
    let isOverridden = false;
    let finalDisplayLabel = "Today's Auto Profile:"; // Default label

    // Attempt to fetch override for today's date if Firebase is available and user is logged in
    if (window.firebaseOMSI && window.firebaseOMSI.database && currentUser_extra) {
        const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
        try {
            const overrideSnap = await dbGet(dbChild(dbRef(database), `${FB_PATH_OPERATIONAL_OVERRIDES}/${todayDateString}`));
            if (overrideSnap.exists()) {
                const overrideProfileValue = overrideSnap.val();
                profileDisplayText = `${overrideProfileValue} (Manual Override)`;
                // For an override, the 'operatingCodes' might simply be the override string itself,
                // or you might choose to display nothing for codes.
                operatingCodes = [overrideProfileValue];
                isOverridden = true;
                finalDisplayLabel = "Today's Profile:"; // Change label if overridden
            }
        } catch (error) {
            console.error("Error fetching today's override for profile display:", error);
            // If fetching override fails, proceed with automatic calculation
        }
    }

    if (!isOverridden) {
        // --- This is your existing logic for automatic profile calculation ---
        let isBankHol = false;
        if (ukBankHolidaysData_extra && ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(todayDateString)) {
            const holidayTitle = ukBankHolidaysData_extra.titles[todayDateString] || "Bank Holiday";
            isBankHol = true;
            if (holidayTitle.toLowerCase().includes("good friday")) {
                profileDisplayText = "Good Friday";
                serviceTypeDisplay = "(Sat Service)";
            } else {
                profileDisplayText = holidayTitle;
                serviceTypeDisplay = "(Sun Service)";
            }
        }

        let dayName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][now.getDay()];

        if (!isBankHol) {
            profileDisplayText = dayName;
            if (isSchoolHolidayPeriod_ExtraPage(now)) { // Ensure isSchoolHolidayPeriod_ExtraPage is defined
                profileDisplayText += " (School Hol)";
            }
        } else {
            profileDisplayText += ` ${serviceTypeDisplay} - Observed on a ${dayName}`;
            if (isSchoolHolidayPeriod_ExtraPage(now)) {
                profileDisplayText += " (School Hol Period)";
            }
        }
        operatingCodes = getOperatingCodesForDate_ExtraPage(now); // Calculate actual codes
        // --- End of existing logic for automatic profile calculation ---
    }

    // Update the display element
    if (currentProfileDisplayElement_el) {
        if (isOverridden) {
            // Display for an overridden profile
            currentProfileDisplayElement_el.textContent = `${finalDisplayLabel} ${profileDisplayText}`;
        } else {
            // Display for an automatically calculated profile
            currentProfileDisplayElement_el.textContent = `${finalDisplayLabel} ${profileDisplayText} [Codes: ${operatingCodes.join(', ')}]`;
        }
    }
}

        // --- Day Profile Override Functions ---
        async function loadAndDisplayOverrides_ExtraPage() { if (!activeOverridesList_el_extra || !window.firebaseOMSI) return; activeOverridesList_el_extra.innerHTML = '<p>Loading active overrides...</p>'; const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const snapshot = await dbGet(dbChild(dbRef(database), FB_PATH_OPERATIONAL_OVERRIDES)); let html = ""; if (snapshot.exists()) { const overrides = snapshot.val(); const today = new Date(); today.setHours(0,0,0,0); const thirtyDaysLater = new Date(today); thirtyDaysLater.setDate(today.getDate() + 30); const relevantOverrides = []; for (const dateKey in overrides) { if (/^\d{4}-\d{2}-\d{2}$/.test(dateKey)) { const overrideDate = new Date(dateKey + "T00:00:00"); if (overrideDate >= today && overrideDate <= thirtyDaysLater) { relevantOverrides.push({ date: dateKey, profile: overrides[dateKey] }); } } } relevantOverrides.sort((a,b) => a.date.localeCompare(b.date)); if (relevantOverrides.length > 0) { html = "<ul>"; relevantOverrides.forEach(ov => { html += `<li><strong>${formatDateToDDMonthYYYY_ExtraPage(ov.date)}:</strong> ${ov.profile}</li>`; }); html += "</ul>"; } else { html = "<p>No overrides set for the next 30 days.</p>"; } } else { html = "<p>No overrides currently set in the system.</p>"; } activeOverridesList_el_extra.innerHTML = html; } catch (error) { console.error("Error loading overrides:", error); activeOverridesList_el_extra.innerHTML = "<p>Error loading overrides.</p>"; } }
        async function updateSelectedDateInfo_ExtraPage() { if (!overrideDateInput_el_extra || !selectedDateDisplay_el_extra || !autoProfileForSelectedDate_el_extra || !currentOverrideForSelectedDate_el_extra || !clearOverrideButton_el_extra) return; const selectedDateStr = overrideDateInput_el_extra.value; clearOverrideButton_el_extra.style.display = 'none'; if (!selectedDateStr) { selectedDateDisplay_el_extra.textContent = "(select a date)"; autoProfileForSelectedDate_el_extra.textContent = "(select a date)"; currentOverrideForSelectedDate_el_extra.textContent = "(select a date)"; return; } selectedDateDisplay_el_extra.textContent = formatDateToDDMonthYYYY_ExtraPage(selectedDateStr); const dateObj = new Date(selectedDateStr + "T00:00:00"); const autoCodes = getOperatingCodesForDate_ExtraPage(dateObj); autoProfileForSelectedDate_el_extra.textContent = autoCodes.join(', ') || "N/A"; if (window.firebaseOMSI) { const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const overrideSnap = await dbGet(dbChild(dbRef(database), `${FB_PATH_OPERATIONAL_OVERRIDES}/${selectedDateStr}`)); if (overrideSnap.exists()) { currentOverrideForSelectedDate_el_extra.textContent = overrideSnap.val(); currentOverrideForSelectedDate_el_extra.style.color = "#f1c40f"; clearOverrideButton_el_extra.style.display = 'inline-block'; } else { currentOverrideForSelectedDate_el_extra.textContent = "(none)"; currentOverrideForSelectedDate_el_extra.style.color = ""; } } catch (error) { console.error("Error fetching override for selected date:", error); currentOverrideForSelectedDate_el_extra.textContent = "(error fetching)"; } } }
        async function handleSetOverride_ExtraPage() { if (!currentUser_extra || !overrideDateInput_el_extra || !overrideProfileInput_el_extra || !overrideStatusMessage_el_extra || !window.firebaseOMSI) { if (overrideStatusMessage_el_extra) overrideStatusMessage_el_extra.textContent = "Error: System not ready or not logged in."; return; } const dateKey = overrideDateInput_el_extra.value; const profile = overrideProfileInput_el_extra.value.trim(); if (!dateKey) { overrideStatusMessage_el_extra.textContent = "Please select a date."; overrideStatusMessage_el_extra.style.color="#e74c3c"; return; } if (!profile) { overrideStatusMessage_el_extra.textContent = "Please enter an override profile string."; overrideStatusMessage_el_extra.style.color="#e74c3c"; return; } const { database, dbSet, dbRef } = window.firebaseOMSI; try {
            await dbSet(dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${dateKey}`), profile);
            overrideStatusMessage_el_extra.textContent = `Override for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)} set to "${profile}".`;
            overrideStatusMessage_el_extra.style.color="#2ecc71";
            loadAndDisplayOverrides_ExtraPage();
            updateSelectedDateInfo_ExtraPage();
            if (dateKey === getYYYYMMDD_ExtraPage(new Date())) { // If today's date was overridden
                await updateCurrentProfileDisplay_ExtraPage();    // REFRESH THE DISPLAY
            }
        } catch (error) {
            console.error("Error setting override:", error);
            overrideStatusMessage_el_extra.textContent = "Error setting override: " + error.message;
            overrideStatusMessage_el_extra.style.color="#e74c3c";
        } }
        async function handleClearOverride_ExtraPage() { if (!currentUser_extra || !overrideDateInput_el_extra || !overrideStatusMessage_el_extra || !window.firebaseOMSI) return; const dateKey = overrideDateInput_el_extra.value; if (!dateKey) { overrideStatusMessage_el_extra.textContent = "Please select a date to clear its override."; overrideStatusMessage_el_extra.style.color="#e74c3c"; return; } if (!confirm(`Are you sure you want to clear the override for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)}?`)) { overrideStatusMessage_el_extra.textContent = "Clear override cancelled."; overrideStatusMessage_el_extra.style.color="#7f8c8d"; return; } const { database, dbRemove, dbRef } = window.firebaseOMSI; // ... (inside handleClearOverride_ExtraPage)
        try {
            await dbRemove(dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${dateKey}`));
            overrideStatusMessage_el_extra.textContent = `Override for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)} cleared.`;
            overrideStatusMessage_el_extra.style.color="#2ecc71";
            loadAndDisplayOverrides_ExtraPage();
            updateSelectedDateInfo_ExtraPage();
            if (dateKey === getYYYYMMDD_ExtraPage(new Date())) { // If today's date override was cleared
                await updateCurrentProfileDisplay_ExtraPage();    // REFRESH THE DISPLAY
            }
        } catch (error) {
            console.error("Error clearing override:", error);
            overrideStatusMessage_el_extra.textContent = "Error clearing override: " + error.message;
            overrideStatusMessage_el_extra.style.color="#e74c3c";
        } }


        // --- Ancillary Data Save Function ---
        async function updateAncillaryScheduleData_ExtraPage() {
            if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available for ancillary data update.");
            const { database, dbSet, dbUpdate, dbRef } = window.firebaseOMSI;

            // 1. Regenerate uniqueBusStops from the current in-memory flat schedule
            const stopsMap = new Map();
            currentWorkingSchedule_extra.forEach(row => {
                if (row.stopID && !stopsMap.has(row.stopID.toUpperCase())) {
                    stopsMap.set(row.stopID.toUpperCase(), { stopID: row.stopID, stopName: row.stopName, direction: row.direction });
                }
            });
            const finalUniqueStops = Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase()));

            try {
                console.log("Attempting to save unique bus stops (ancillary)...");
                await dbSet(dbRef(database, FB_PATH_LIVE_UNIQUE_STOPS), finalUniqueStops);
                console.log("Unique bus stops saved. Attempting to save last updated timestamp (ancillary)...");
                await dbUpdate(dbRef(database), { [FB_PATH_APPSTATE_LAST_UPDATED]: new Date().toISOString() });
                console.log("Ancillary schedule data (unique stops, timestamp) updated.");
            } catch (error) {
                console.error("Error saving ancillary schedule data:", error);
                // Decide if this error should be propagated or just logged
                throw error; // Propagate for now
            }
        }

        // --- REBUILDS ENTIRE SCHEDULE in new structured format ---
        async function rebuildAndSaveEntireScheduleToFirebase_ExtraPage(flatScheduleDataToSave) {
    if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available.");
    const { database, dbSet, dbRef } = window.firebaseOMSI;

    console.log("Rebuilding entire schedule into new nested structure (in memory)...");
    const newSchedulesByRoute = {}; // This object will be built in memory first
    flatScheduleDataToSave.forEach(entry => {
        if (!entry.lineName || !entry.OperatingProfile || !entry.destinationName) {
            console.warn("Skipping entry with missing route/profile/destination:", entry);
            return;
        }
        const saneRoute = sanitizeFirebaseKey(entry.lineName);
        const saneProfile = sanitizeFirebaseKey(entry.OperatingProfile);
        const saneDest = sanitizeFirebaseKey(entry.destinationName);

        if (!newSchedulesByRoute[saneRoute]) newSchedulesByRoute[saneRoute] = {};
        if (!newSchedulesByRoute[saneRoute][saneProfile]) newSchedulesByRoute[saneRoute][saneProfile] = {};
        if (!newSchedulesByRoute[saneRoute][saneProfile][saneDest]) newSchedulesByRoute[saneRoute][saneProfile][saneDest] = { entries: [] };
        
        const entryForStorage = { ...entry };
        // Ensure these key fields are present in the stored entry, even if they were part of the key structure
        entryForStorage.lineName = entry.lineName;
        entryForStorage.OperatingProfile = entry.OperatingProfile;
        entryForStorage.destinationName = entry.destinationName;

        newSchedulesByRoute[saneRoute][saneProfile][saneDest].entries.push(entryForStorage);
    });

    // Sort entries within each R/P/D for consistency
    for (const routeKey in newSchedulesByRoute) {
        for (const profileKey in newSchedulesByRoute[routeKey]) {
            for (const destKey in newSchedulesByRoute[routeKey][profileKey]) {
                newSchedulesByRoute[routeKey][profileKey][destKey].entries.sort((a, b) => {
                    const timeA = (a.scheduledTime || "9999").replace(':', ''); // Use a sortable time format
                    const timeB = (b.scheduledTime || "9999").replace(':', '');
                    const timeCompare = timeA.localeCompare(timeB);
                    if (timeCompare !== 0) return timeCompare;
                    // Optional: Add secondary sort criteria if needed, e.g., by stopName or internalId
                    return (a.stopName || "").localeCompare(b.stopName || "");
                });
            }
        }
    }
    
    try {
        console.log(`Attempting to save schedule to Firebase using PER-ROUTE writes. Total routes: ${Object.keys(newSchedulesByRoute).length}`);
        
        const writePromises = [];

        // Clear the entire schedulesByRoute path first to ensure a clean slate.
        // This is a single delete operation for the parent path.
        console.log(`Clearing existing data at ${FB_PATH_SCHEDULES_BY_ROUTE} before writing new data...`);
        await dbSet(dbRef(database, FB_PATH_SCHEDULES_BY_ROUTE), null);
        console.log(`Path ${FB_PATH_SCHEDULES_BY_ROUTE} cleared.`);

        // Now write each route's data individually
        for (const saneRoute in newSchedulesByRoute) {
            if (Object.hasOwnProperty.call(newSchedulesByRoute, saneRoute)) { // Ensure it's an own property
                const routeData = newSchedulesByRoute[saneRoute];
                const routePath = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}`;
                console.log(`Writing data for route: ${saneRoute} to path: ${routePath}`);
                writePromises.push(dbSet(dbRef(database, routePath), routeData));
            }
        }

        await Promise.all(writePromises);
        console.log("Entire schedule saved successfully to Firebase using per-route writes.");

        // After a full rebuild, also update ancillary data
        await updateAncillaryScheduleData_ExtraPage(); // Uses the global currentWorkingSchedule_extra

    } catch (error) {
        console.error("Error saving entire rebuilt schedule with per-route writes:", error);
        // This error will be propagated to the calling function (e.g., handleBulkAddStops_ExtraPage)
        // which should then inform the user via its status message element.
        throw error; 
    }
}


        // --- Stop Management Functions ---
        function getBaseStopName_ExtraPage(fullStopName) { if (!fullStopName) return ""; let baseName = String(fullStopName).trim(); baseName = baseName.replace(/\s*\(Stand [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\(Bay [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\(Stop [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\([A-Z0-9]\)\s*$/i, ''); baseName = baseName.replace(/\s*-\s*Bay\s*[A-Z0-9]+\s*$/i,''); baseName = baseName.replace(/\s*Stop\s*[A-Z0-9]+\s*$/i,''); return baseName.trim(); }
        function getRandomIdFormat_ExtraPage() { const formats = ["NUM", "BP", "LE", "RO"]; return formats[Math.floor(Math.random() * formats.length)]; }
        function generateUniqueStopId_ExtraPage(format, stopName = "", allExistingStopIDsSet) { const targetBaseName = getBaseStopName_ExtraPage(stopName).toUpperCase(); let prefix = ""; let numericRegex; let baseStartNumber = 1; const MAX_NUMERIC_PART = 99999; switch (format) { case "NUM": prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; case "BP": prefix = "BP"; numericRegex = /^BP(\d+)$/; baseStartNumber = 1; break; case "LE": prefix = "LE"; numericRegex = /^LE(\d+)$/; baseStartNumber = 1; break; case "RO": prefix = "RO"; numericRegex = /^RO(\d+)$/; baseStartNumber = 1; break; default: console.warn(`generateUniqueStopId_ExtraPage: Unknown format "${format}", defaulting to NUM.`); format="NUM"; prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; if (/^[A-Z]+$/.test(format)) {prefix = format.toUpperCase(); numericRegex = new RegExp(`^${prefix}(\\d+)$`); baseStartNumber = 1;} break; } let highestNumInNameSequence = 0; let nameSpecificSequenceFound = false; if (targetBaseName && currentWorkingSchedule_extra) { currentWorkingSchedule_extra.forEach(entry => { if (entry.stopName && entry.stopID) { const existingEntryBaseName = getBaseStopName_ExtraPage(entry.stopName).toUpperCase(); if (existingEntryBaseName === targetBaseName) { const match = entry.stopID.toUpperCase().match(numericRegex); if (match && match[1]) { const numPart = parseInt(match[1], 10); if (!isNaN(numPart) && numPart <= MAX_NUMERIC_PART && numPart > highestNumInNameSequence) { highestNumInNameSequence = numPart; } nameSpecificSequenceFound = true; } } } }); } let nextNumInSequence = nameSpecificSequenceFound ? highestNumInNameSequence + 1 : baseStartNumber; if (format === "NUM" && nextNumInSequence < 101) nextNumInSequence = 101; if (baseStartNumber > MAX_NUMERIC_PART) { console.warn(`Suggest ID (single): Base start ${baseStartNumber} for ${format} exceeds MAX. Fallback.`); return prefix + "MAX_S_ERR" + Math.floor(Math.random()*1000); } let attempts = 0; const maxAttempts = MAX_NUMERIC_PART + 2000; let candidateId = ""; while (attempts < maxAttempts) { if (nextNumInSequence > MAX_NUMERIC_PART) { console.warn(`Suggest ID (single): All numbers up to ${MAX_NUMERIC_PART} exhausted for ${prefix}, base ${targetBaseName}. Fallback.`); let fA = 0, fId; do { fId = prefix + "RND" + String(Date.now()).slice(-3) + (Math.floor(Math.random()*900)+100); fA++; if (fA > 50) return prefix + "FB_FAIL" + Math.floor(Math.random()*1000); } while (allExistingStopIDsSet.has(fId.toUpperCase())); return fId; } candidateId = prefix + nextNumInSequence; if (!allExistingStopIDsSet.has(candidateId.toUpperCase())) return candidateId; nextNumInSequence++; attempts++; } console.warn(`CRITICAL: Could not generate unique Stop ID for ${format}, name: "${stopName}". Final fallback.`); let fA2 = 0, fId2; do { fId2 = prefix + "ULTRA_FB" + String(Date.now()).slice(-5) + (Math.floor(Math.random()*90)+10); fA2++; if (fA2 > 50) return prefix + "ULTRA_CRIT_FAIL" + Math.floor(Math.random()*100); } while (allExistingStopIDsSet.has(fId2.toUpperCase())); return fId2; }
        function autoGenerateAndSetNewStopId_ExtraPage() { if (!currentUser_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !selectNewStopIdFormat_el_extra) return; const currentStopName = inputNewStopName_el_extra.value.trim(); if (!currentStopName) { inputNewStopId_el_extra.value = ""; selectNewStopIdFormat_el_extra.selectedIndex = 0; if(addNewStopStatus_el_extra) {addNewStopStatus_el_extra.textContent = "Enter stop name for ID suggestion."; addNewStopStatus_el_extra.style.color = "";} if (newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = ''; return; } const actualBaseName = getBaseStopName_ExtraPage(currentStopName).toUpperCase(); let formatToUse = null; if (actualBaseName && currentWorkingSchedule_extra && currentWorkingSchedule_extra.length > 0) { for (const existingEntry of currentWorkingSchedule_extra) { if (existingEntry.stopID && existingEntry.stopName) { const existingEntryBaseName = getBaseStopName_ExtraPage(existingEntry.stopName).toUpperCase(); if (existingEntryBaseName === actualBaseName) { const existingId = existingEntry.stopID.toUpperCase(); if (existingId.startsWith("BP") && /BP\d+/.test(existingId)) formatToUse = "BP"; else if (existingId.startsWith("LE") && /LE\d+/.test(existingId)) formatToUse = "LE"; else if (existingId.startsWith("RO") && /RO\d+/.test(existingId)) formatToUse = "RO"; else if (/^\d+$/.test(existingId) && parseInt(existingId, 10) >= 100) formatToUse = "NUM"; if (formatToUse) break; } } } } if (!formatToUse) formatToUse = getRandomIdFormat_ExtraPage(); selectNewStopIdFormat_el_extra.value = formatToUse; const allCurrentScheduleIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase())); const suggestedId = generateUniqueStopId_ExtraPage(formatToUse, currentStopName, allCurrentScheduleIDs); inputNewStopId_el_extra.value = suggestedId; inputNewStopId_el_extra.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })); if (addNewStopStatus_el_extra) { addNewStopStatus_el_extra.textContent = `Auto-suggested ID: ${suggestedId} (Format: "${formatToUse}").`; addNewStopStatus_el_extra.style.color = '#bdc3c7'; } }
        async function handleAddStopDetails_ExtraPage() {
            if (!currentUser_extra || !addNewStopStatus_el_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !inputNewStopDirection_el_extra) return;
            const newStopID = inputNewStopId_el_extra.value.trim().toUpperCase();
            const newStopName = inputNewStopName_el_extra.value.trim();
            const newStopDirection = inputNewStopDirection_el_extra.value.trim();
            if (!newStopID) { addNewStopStatus_el_extra.textContent = "New Stop ID is required."; addNewStopStatus_el_extra.style.color = '#e74c3c'; inputNewStopId_el_extra.focus(); return; }
            if (!/^[A-Z0-9]+$/.test(newStopID)) { addNewStopStatus_el_extra.textContent = "Stop ID: A-Z, 0-9 only."; addNewStopStatus_el_extra.style.color = '#e74c3c'; inputNewStopId_el_extra.focus(); return; }
            if (!newStopName) { addNewStopStatus_el_extra.textContent = "New Stop Name is required."; addNewStopStatus_el_extra.style.color = '#e74c3c'; inputNewStopName_el_extra.focus(); return; }
            const existingStopIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase()));
            if (existingStopIDs.has(newStopID)) { addNewStopStatus_el_extra.textContent = `Stop ID "${newStopID}" already exists.`; if(newStopIdAvailability_el_extra){ newStopIdAvailability_el_extra.textContent = 'ID already exists.'; newStopIdAvailability_el_extra.style.color = '#e74c3c'; } inputNewStopId_el_extra.focus(); return; }
            const newStopDefinitionForFlatList = {
                internalId: `${newStopID}_definition_${Date.now()}`, // Unique internal ID for processing the flat list
                stopID: newStopID,
                stopName: newStopName,
                direction: newStopDirection
                // No lineName, destinationName, scheduledTime, OperatingProfile, DayOffset
            };
            currentWorkingSchedule_extra.push(newStopDefinitionForFlatList);
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
                addNewStopStatus_el_extra.textContent = `Stop "${newStopID} - ${newStopName}" definition placeholder added. Save successful.`;
                addNewStopStatus_el_extra.style.color = '#2ecc71';
                inputNewStopId_el_extra.value = ''; inputNewStopName_el_extra.value = ''; inputNewStopDirection_el_extra.value = '';
                if(newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = '';
                if(selectNewStopIdFormat_el_extra) selectNewStopIdFormat_el_extra.selectedIndex = 0;
                autoGenerateAndSetNewStopId_ExtraPage();
                renderUIDependentElements_ExtraPage();
            } catch (error) {
                console.error("Error adding new stop definition:", error);
                addNewStopStatus_el_extra.textContent = "Error saving stop definition: " + error.message;
                addNewStopStatus_el_extra.style.color = '#e74c3c';
                // currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => entry.internalId !== placeholderEntry.internalId); // placeholderEntry was not defined here
                currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => entry.internalId !== newStopDefinitionForFlatList.internalId);

            }
        }
        function generateUniqueStopId_ExtraPage_BulkAware(format, stopName, newlyGeneratedIDsInBatchSet, baseNameAndFormatToGeneratedNumericPartsMap) { const targetBaseName = getBaseStopName_ExtraPage(stopName).toUpperCase(); let prefix = ""; let numericRegex; let baseStartNumber = 1; const MAX_NUMERIC_PART = 99999; switch (format) { case "NUM": prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; case "BP": prefix = "BP"; numericRegex = /^BP(\d+)$/; baseStartNumber = 1; break; case "LE": prefix = "LE"; numericRegex = /^LE(\d+)$/; baseStartNumber = 1; break; case "RO": prefix = "RO"; numericRegex = /^RO(\d+)$/; baseStartNumber = 1; break; default: console.warn(`generateUniqueStopId_ExtraPage_BulkAware (Replace Mode): Unknown format "${format}" for "${stopName}". Defaulting to NUM.`); format = "NUM"; prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; } const keyForMap = `${targetBaseName}_${format}`; if (!baseNameAndFormatToGeneratedNumericPartsMap.has(keyForMap)) { baseNameAndFormatToGeneratedNumericPartsMap.set(keyForMap, new Set()); } const numericPartsForThisGroup = baseNameAndFormatToGeneratedNumericPartsMap.get(keyForMap); let highestNumInGroup = 0; numericPartsForThisGroup.forEach(numStr => { const num = parseInt(numStr, 10); if (!isNaN(num) && num > highestNumInGroup) highestNumInGroup = num; }); let nextNumInSequence = highestNumInGroup > 0 ? highestNumInGroup + 1 : baseStartNumber; if (format === "NUM" && nextNumInSequence < 101) nextNumInSequence = 101; if (baseStartNumber > MAX_NUMERIC_PART) { console.warn(`BulkAware (Replace): Base start ${baseStartNumber} for ${format} exceeds MAX. Fallback.`); return prefix + "B_MAX_S_ERR" + Math.floor(Math.random()*1000); } let attempts = 0; const maxAttempts = MAX_NUMERIC_PART + 2000; let candidateId = ""; while (attempts < maxAttempts) { if (nextNumInSequence > MAX_NUMERIC_PART) { console.warn(`BulkAware (Replace): All numbers up to ${MAX_NUMERIC_PART} exhausted for ${prefix}, base ${targetBaseName}. Fallback.`); let fA = 0, fId; do { fId = prefix + "BRND" + String(Date.now()).slice(-4) + (Math.floor(Math.random()*900)+100); fA++; if (fA > 50) return prefix + "B_FB_FAIL" + Math.floor(Math.random()*1000); } while (newlyGeneratedIDsInBatchSet.has(fId.toUpperCase())); return fId; } candidateId = prefix + nextNumInSequence; if (!newlyGeneratedIDsInBatchSet.has(candidateId.toUpperCase())) { const match = candidateId.match(numericRegex); if(match && match[1]) numericPartsForThisGroup.add(match[1]); return candidateId; } nextNumInSequence++; attempts++; } console.warn(`CRITICAL_BULK (Replace): Could not generate unique Stop ID for ${format}, name: "${stopName}". Final fallback.`); let fA2 = 0, fId2; do { fId2 = prefix + "B_ULTRA_FB" + String(Date.now()).slice(-5) + (Math.floor(Math.random()*9000)+1000); fA2++; if (fA2 > 50) throw new Error("Bulk Fallback ID gen failed catastrophically."); } while (newlyGeneratedIDsInBatchSet.has(fId2.toUpperCase())); return fId2; }
        async function handleBulkAddStops_ExtraPage() {
            if (!currentUser_extra) { alert("Log in."); if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="Not logged in."; bulkAddNewStopsStatus_el_extra.style.color="#e74c3c";} return; }
            const stopsToProcessFromExcel = processedExcelStopsData_extra;
            if (!stopsToProcessFromExcel || stopsToProcessFromExcel.length === 0) { if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="No Excel data processed."; bulkAddNewStopsStatus_el_extra.style.color="#f1c40f";} return; }
            if (!confirm(`DANGER! This will DELETE ALL existing schedules and then add ${stopsToProcessFromExcel.length} stop definition(s) from Excel. This action CANNOT BE UNDONE. Proceed?`)) { if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="Bulk replace operation cancelled."; bulkAddNewStopsStatus_el_extra.style.color="#7f8c8d";} return; }
            if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = `Replacing all stops with ${stopsToProcessFromExcel.length} definitions from file...`; bulkAddNewStopsStatus_el_extra.style.color = '#f1c40f'; }
            let newFlatScheduleEntries = []; const newlyGeneratedOrUsedIDsInThisBatch = new Set(); const baseNameToFormatMapForThisBatch = new Map(); const baseNameAndFormatToGeneratedNumericPartsMap = new Map(); let errorsEncountered = 0; let totalPlaceholdersCreated = 0; let uniqueStopIDsAddedCount = 0; let statusMessages = [`Starting bulk replacement (Excel rows: ${stopsToProcessFromExcel.length})...\n`];
            for (const stopData of stopsToProcessFromExcel) {
                const excelStopName = (stopData.stopName || "").trim(); const excelDirection = (stopData.direction || "").trim(); const excelUserProvidedStopID = (stopData.userProvidedStopID || "").trim(); const excelBaseName = getBaseStopName_ExtraPage(excelStopName).toUpperCase();
                let excelLineNames = (stopData.lineNameInput && stopData.lineNameInput.trim() !== "") ? stopData.lineNameInput.split(',').map(ln => ln.trim().toUpperCase()).filter(ln => ln !== "") : ["INFO_ONLY"];
                if (excelLineNames.length === 0) excelLineNames = ["INFO_ONLY"];
                if (!excelStopName && !excelUserProvidedStopID) { statusMessages.push(`Row ${stopData.originalLineNumber}: Skipped. StopName or StopID required.`); errorsEncountered++; continue; }
                let finalStopID = ""; let idSourceMessage = ""; let chosenFormatForThisStop = "";
                if (excelUserProvidedStopID) { 
                    const providedIDUpper = excelUserProvidedStopID.toUpperCase();
                    if (!/^[A-Z0-9]+$/.test(providedIDUpper)) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Provided StopID "${excelUserProvidedStopID}" invalid chars. Skipped.`); errorsEncountered++; continue; }
                    if (newlyGeneratedOrUsedIDsInThisBatch.has(providedIDUpper)) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Provided StopID "${excelUserProvidedStopID}" is duplicated within this Excel file. Skipped.`); errorsEncountered++; continue; }
                    finalStopID = excelUserProvidedStopID; idSourceMessage = "user-provided";
                    if (finalStopID.startsWith("BP")) chosenFormatForThisStop = "BP"; else if (finalStopID.startsWith("LE")) chosenFormatForThisStop = "LE"; else if (finalStopID.startsWith("RO")) chosenFormatForThisStop = "RO"; else if (/^\d+$/.test(finalStopID)) chosenFormatForThisStop = "NUM"; else chosenFormatForThisStop = "Custom";
                } else { if (baseNameToFormatMapForThisBatch.has(excelBaseName)) { chosenFormatForThisStop = baseNameToFormatMapForThisBatch.get(excelBaseName); } else { chosenFormatForThisStop = getRandomIdFormat_ExtraPage(); baseNameToFormatMapForThisBatch.set(excelBaseName, chosenFormatForThisStop); } finalStopID = generateUniqueStopId_ExtraPage_BulkAware(chosenFormatForThisStop, excelStopName, newlyGeneratedOrUsedIDsInThisBatch, baseNameAndFormatToGeneratedNumericPartsMap); idSourceMessage = `auto-gen (${chosenFormatForThisStop})`; }
                if (!finalStopID) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Failed to obtain a final StopID. Skipped.`); errorsEncountered++; continue;}
                newlyGeneratedOrUsedIDsInThisBatch.add(finalStopID.toUpperCase()); uniqueStopIDsAddedCount++;
                excelLineNames.forEach(ln => {
                    newFlatScheduleEntries.push({
                        internalId: `${finalStopID}_${ln.replace(/[^A-Z0-9]/ig, '')}_phReplace_${Date.now()}_${newFlatScheduleEntries.length}`,
                        stopID: finalStopID, stopName: excelStopName, direction: excelDirection, lineName: ln,
                        destinationName: "To Be Defined", OperatingProfile: "AllDays", scheduledTime: "00:00", DayOffset: "0"
                    });
                    totalPlaceholdersCreated++;
                });
                statusMessages.push(`Row ${stopData.originalLineNumber}: Processed "${excelStopName}" -> ID: ${finalStopID} [${idSourceMessage}]. Routes: ${excelLineNames.join(', ')}.`);
            }
            let finalSummaryParts = []; if (totalPlaceholdersCreated > 0) finalSummaryParts.push(`Prepared ${totalPlaceholdersCreated} placeholder schedule entries for ${uniqueStopIDsAddedCount} unique StopIDs from the file.`); if (errorsEncountered > 0) finalSummaryParts.push(`${errorsEncountered} row(s) from Excel skipped due to errors.`); if (newFlatScheduleEntries.length === 0 && errorsEncountered === 0) finalSummaryParts.push("No valid stop definitions found in the file to process."); statusMessages.push("\n--- Summary ---\n" + finalSummaryParts.join('\n')); if (bulkAddNewStopsStatus_el_extra) bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n');
            if (errorsEncountered > 0 && newFlatScheduleEntries.length > 0) { if (!confirm(`There were ${errorsEncountered} error(s) processing rows. However, ${newFlatScheduleEntries.length} placeholder entries are ready to REPLACE the entire schedule. Proceed?`)) { statusMessages.push("Bulk replacement aborted by user due to errors."); if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; } return; } statusMessages.push("Attempting to save successfully processed entries..."); }
            else if (newFlatScheduleEntries.length === 0) { if (bulkAddNewStopsStatus_el_extra) bulkAddNewStopsStatus_el_extra.style.color = errorsEncountered > 0 ? '#e74c3c' : '#f1c40f'; return; }
            currentWorkingSchedule_extra = newFlatScheduleEntries; closedStopIDs_extra = []; stopSpecificRouteColours_extra = {};
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
                await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                statusMessages.push(`\nSuccessfully REPLACED all schedules. Added ${totalPlaceholdersCreated} placeholder entries for ${uniqueStopIDsAddedCount} StopIDs to Firebase in the new structure.`);
                if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#2ecc71'; }
                if (fileInputBulkAddStops_el_extra) fileInputBulkAddStops_el_extra.value = '';
                if (fileNameBulkAddStops_el_extra) fileNameBulkAddStops_el_extra.textContent = 'No file selected.';
                processedExcelStopsData_extra = []; renderUIDependentElements_ExtraPage();
            } catch (error) {
                statusMessages.push("\nDATABASE ERROR: Error saving replaced schedule to Firebase!");
                if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; }
                console.error("Error bulk replacing stops and saving to Firebase:", error);
            }
        }
        function handleExcelFileForBulkAdd_ExtraPage(event) { const file = event.target.files[0]; if (!fileInputBulkAddStops_el_extra || !fileNameBulkAddStops_el_extra || !bulkAddNewStopsStatus_el_extra) return; if (!file) { fileNameBulkAddStops_el_extra.textContent = "No file selected."; processedExcelStopsData_extra = []; return; } fileNameBulkAddStops_el_extra.textContent = `Processing ${file.name}...`; bulkAddNewStopsStatus_el_extra.textContent = ""; processedExcelStopsData_extra = []; const reader = new FileReader(); reader.onload = function(e) { try { const data = new Uint8Array(e.target.result); const workbook = XLSX.read(data, {type: 'array'}); const firstSheetName = workbook.SheetNames[0]; const worksheet = workbook.Sheets[firstSheetName]; const jsonData = XLSX.utils.sheet_to_json(worksheet, {header:1, defval:''}); if (jsonData.length === 0) { bulkAddNewStopsStatus_el_extra.textContent = "Excel file empty or no data."; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileNameBulkAddStops_el_extra.textContent = `Error: ${file.name} is empty.`; fileInputBulkAddStops_el_extra.value = ''; return; } let validEntries = 0; let tempProcessedData = []; jsonData.forEach((row, index) => { if (!Array.isArray(row) || row.every(cell => String(cell).trim() === '')) return; const userProvidedStopID = String(row[0] || "").trim(); const stopName = String(row[1] || "").trim(); const direction = String(row[2] || "").trim(); const lineNameInput = String(row[3] || "").trim(); if (!stopName && !userProvidedStopID) { console.warn(`Skipping Excel row ${index + 1}: StopName and StopID both missing.`); return; } tempProcessedData.push({ originalLineNumber: index + 1, userProvidedStopID: userProvidedStopID, stopName: stopName, direction: direction, lineNameInput: lineNameInput }); validEntries++; }); processedExcelStopsData_extra = tempProcessedData; if (validEntries > 0) { fileNameBulkAddStops_el_extra.textContent = `${file.name} (${validEntries} valid rows ready).`; bulkAddNewStopsStatus_el_extra.textContent = `${validEntries} stop definitions processed. Ready for Bulk Replace operation.`; bulkAddNewStopsStatus_el_extra.style.color = '#2ecc71'; } else { fileNameBulkAddStops_el_extra.textContent = `No valid data in ${file.name}.`; bulkAddNewStopsStatus_el_extra.textContent = "No valid definitions (StopName/StopID required)."; bulkAddNewStopsStatus_el_extra.style.color = '#f1c40f'; fileInputBulkAddStops_el_extra.value = ''; } } catch (error) { console.error("Error processing Excel:", error); fileNameBulkAddStops_el_extra.textContent = `Error processing ${file.name}.`; bulkAddNewStopsStatus_el_extra.textContent = "Error processing Excel: " + error.message; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileInputBulkAddStops_el_extra.value = ''; } }; reader.onerror = () => { fileNameBulkAddStops_el_extra.textContent = "Error reading file."; bulkAddNewStopsStatus_el_extra.textContent = "Could not read file."; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileInputBulkAddStops_el_extra.value = ''; }; reader.readAsArrayBuffer(file); }
        
function populateMasterStopList_ExtraPage() {
            if (!masterStopListUL_el_extra || !masterStopListStatus_el_extra) return;
            uniqueStopsMasterList_extra = getUniqueStopsFromSchedule_ExtraPage(); // Ensure this gets unique stops with stopID, stopName, direction
            const filterText = masterStopListFilterInput_el_extra.value.toLowerCase().trim();
            masterStopListUL_el_extra.innerHTML = '';
            let displayedCount = 0;

            if (uniqueStopsMasterList_extra.length === 0) {
                masterStopListStatus_el_extra.textContent = 'No unique stops loaded.';
                return;
            }

            uniqueStopsMasterList_extra.forEach(stop => {
                if (!stop || !stop.stopID) return;

                // --- Logic to get serving routes for the current stop (needed for filtering) ---
                const routeNamesForThisStop = new Set();
                currentWorkingSchedule_extra.forEach(entry => {
                    if (entry.stopID === stop.stopID && entry.lineName) {
                        routeNamesForThisStop.add(entry.lineName);
                    }
                });
                const servingRouteNamesArray = Array.from(routeNamesForThisStop);
                // --- End of logic to get serving routes ---

                const stopIdLower = stop.stopID.toLowerCase();
                const stopNameLower = (stop.stopName || "").toLowerCase();
                const stopDirectionLower = (stop.direction || "").toLowerCase();
                const isClosed = closedStopIDs_extra.includes(stop.stopID.toUpperCase());
                const closureStatus = isClosed ? "Closed" : "Open";

                // --- Updated Filter Logic ---
                if (filterText) {
                    const matchesStopId = stopIdLower.includes(filterText);
                    const matchesStopName = stopNameLower.includes(filterText);
                    const matchesDirection = stopDirectionLower.includes(filterText);
                    const matchesStatus = closureStatus.toLowerCase().includes(filterText);
                    const matchesRoute = servingRouteNamesArray.some(routeName => 
                        routeName.toLowerCase().includes(filterText)
                    );

                    if (!(matchesStopId || matchesStopName || matchesDirection || matchesStatus || matchesRoute)) {
                        return; // Skip this stop if it doesn't match any criteria
                    }
                }
                // --- End of Updated Filter Logic ---

                displayedCount++;
                const li = document.createElement('li');
                li.classList.add('master-stop-list-item');
                li.dataset.originalStopid = stop.stopID;

                const originalInfoDiv = document.createElement('div');
                originalInfoDiv.classList.add('master-stop-original-info');

                let originalContent = `<span class="stop-name-master">${stop.stopName}</span><br>
                                   <span class="stop-direction-master">Towards: ${stop.direction || 'N/A'}</span><br>
                                   <span class="stop-id-master">Stop ID: ${stop.stopID}</span>`;

                // For display, sort the route names (already done in original code if 'servingRoutesData' was used for display)
                const sortedRouteNamesForDisplay = [...servingRouteNamesArray].sort(compareLineNames_ExtraPage);

                if (sortedRouteNamesForDisplay.length > 0) {
                    originalContent += `<div class="serving-routes-container" style="margin-top:0.3rem;">`;
                    sortedRouteNamesForDisplay.slice(0, 10).forEach(lineName => { // Show up to 10 routes directly
                        const bgColor = getRouteTileColour_ExtraPage(lineName, stop.stopID);
                        const textColor = getTextColourForBackground_ExtraPage(bgColor);
                        originalContent += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor}; font-size:0.7em; padding:0.15em 0.4em;">${lineName}</span>`;
                    });
                    if (sortedRouteNamesForDisplay.length > 10) {
                        originalContent += `<span style="font-size:0.7em; opacity:0.8;">...and ${sortedRouteNamesForDisplay.length - 10} more.</span>`;
                    }
                    originalContent += `</div>`;
                }
                originalInfoDiv.innerHTML = originalContent;

                const newIdSectionDiv = document.createElement('div');
                newIdSectionDiv.classList.add('master-stop-new-id-section');
                const newIdLabel = document.createElement('label');
                newIdLabel.textContent = 'Propose New ID (optional):';
                const newIdInput = document.createElement('input');
                newIdInput.type = 'text';
                newIdInput.classList.add('schedule-generator-input', 'master-list-new-id-input');
                newIdInput.dataset.originalId = stop.stopID;
                newIdInput.placeholder = "Enter new ID, then Apply Bulk";
                newIdInput.value = stop.stopID; // Pre-fill with current ID

                const warningP = document.createElement('p');
                warningP.classList.add('master-list-row-warning');

                newIdInput.addEventListener('input', () => {
                    const enteredID = newIdInput.value.trim().toUpperCase();
                    warningP.textContent = ''; // Clear previous warning
                    warningP.style.color = '#f39c12'; // Default warning color

                    if (!enteredID) return; // No input, no message
                    if (enteredID === stop.stopID.toUpperCase()) return; // No change, no message

                    if (!/^[A-Z0-9]+$/.test(enteredID)) {
                        warningP.textContent = 'Invalid chars in ID.';
                        return;
                    }
                    // Check against all current stopIDs in the master list AND other proposed new IDs on the page
                    const allCurrentAndProposedIDs = new Set(uniqueStopsMasterList_extra.map(s => s.stopID.toUpperCase()));
                    document.querySelectorAll('.master-list-new-id-input').forEach(inp => {
                        if (inp !== newIdInput) { // Don't check against itself
                            const otherProposed = inp.value.trim().toUpperCase();
                            if (otherProposed && otherProposed !== inp.dataset.originalId.toUpperCase()) { // If it's a valid proposed change
                                allCurrentAndProposedIDs.add(otherProposed);
                            }
                        }
                    });

                    if (allCurrentAndProposedIDs.has(enteredID)) {
                        warningP.textContent = 'ID taken or proposed elsewhere!';
                    } else {
                        warningP.textContent = 'New ID available.';
                        warningP.style.color = '#2ecc71'; // Success color
                    }
                });

                newIdSectionDiv.appendChild(newIdLabel);
                newIdSectionDiv.appendChild(newIdInput);
                newIdSectionDiv.appendChild(warningP);

                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('master-stop-actions');

                const editBtn = document.createElement('button');
                editBtn.className = 'button small-action';
                editBtn.textContent = 'Edit Name / Direction';
                editBtn.addEventListener('click', () => handleEditStopFromMasterList_ExtraPage(stop.stopID, stop.stopName, stop.direction));

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'button small-action secondary';
                deleteBtn.textContent = 'Delete Stop';
                deleteBtn.addEventListener('click', () => handleDeleteStopFromMasterList_ExtraPage(stop.stopID));

                const toggleBtn = document.createElement('button');
                toggleBtn.className = `button small-action ${isClosed ? "save" : "secondary"}`; // 'save' (green) for Reopen
                toggleBtn.textContent = isClosed ? "Reopen Stop" : "Close Stop";
                toggleBtn.addEventListener('click', () => handleToggleStopStatusFromMasterList_ExtraPage(stop.stopID));

                actionsDiv.appendChild(editBtn);
                actionsDiv.appendChild(deleteBtn);
                actionsDiv.appendChild(toggleBtn);

                li.appendChild(originalInfoDiv);
                li.appendChild(newIdSectionDiv);
                li.appendChild(actionsDiv);
                masterStopListUL_el_extra.appendChild(li);
            });

            masterStopListStatus_el_extra.textContent = `Showing ${displayedCount} of ${uniqueStopsMasterList_extra.length} unique stops. ${filterText ? `Filter active: "${filterText}"` : ''}`;
        }
        async function handleEditStopFromMasterList_ExtraPage(stopID, currentName, currentDirection) {
            if (!currentUser_extra) { alert("Log in to edit stop details."); return; } if (!window.firebaseOMSI) { alert("Firebase not available."); return; }
            const newStopNameInput = prompt(`Editing Stop: ${stopID}\nNew Stop Name (current: "${currentName}"):`, currentName);
            if (newStopNameInput === null) { if(masterListApplyChangesStatus_el_extra) masterListApplyChangesStatus_el_extra.textContent = `Edit cancelled for ${stopID}.`; return; }
            const newStopName = newStopNameInput.trim();
            const newDirectionInput = prompt(`Editing Stop: ${stopID}\nNew "Towards" text (current: "${currentDirection}"):`, currentDirection);
            if (newDirectionInput === null) { if(masterListApplyChangesStatus_el_extra) masterListApplyChangesStatus_el_extra.textContent = `Edit cancelled for ${stopID}.`; return; }
            const newDirection = newDirectionInput.trim();
            const nameChanged = newStopName !== currentName.trim(); const directionChanged = newDirection !== currentDirection.trim();
            if (!nameChanged && !directionChanged) { alert(`No changes made to Stop ID "${stopID}".`); if(masterListApplyChangesStatus_el_extra) masterListApplyChangesStatus_el_extra.textContent = `No changes made to ${stopID}.`; return; }
            if (masterListApplyChangesStatus_el_extra) { masterListApplyChangesStatus_el_extra.textContent = `Updating details for stop ${stopID}...`; masterListApplyChangesStatus_el_extra.style.color = "#f1c40f"; }
            let affectedEntryCount = 0; const affectedRPDPathKeys = new Set(); 
            currentWorkingSchedule_extra.forEach(entry => {
                if (entry.stopID && entry.stopID.toUpperCase() === stopID.toUpperCase()) {
                    if (nameChanged) entry.stopName = newStopName;
                    if (directionChanged) entry.direction = newDirection;
                    affectedEntryCount++;
                    if (entry.lineName && entry.OperatingProfile && entry.destinationName) {
                        const saneRoute = sanitizeFirebaseKey(entry.lineName); const saneProfile = sanitizeFirebaseKey(entry.OperatingProfile); const saneDest = sanitizeFirebaseKey(entry.destinationName);
                        affectedRPDPathKeys.add(`${saneRoute}/${saneProfile}/${saneDest}`);
                    }
                }
            });
            if (affectedEntryCount === 0) { alert(`No schedule entries found for Stop ID "${stopID}" to update.`); if (masterListApplyChangesStatus_el_extra) masterListApplyChangesStatus_el_extra.textContent = ""; return; }
            const { database, dbSet, dbRef } = window.firebaseOMSI; const writePromises = [];
            try {
                console.log(`Targeted Update: Updating ${affectedRPDPathKeys.size} R/P/D paths for edited stop ${stopID}.`);
                affectedRPDPathKeys.forEach(rpdPathKey => {
                    const entriesForThisRPD = currentWorkingSchedule_extra.filter(entry => {
                        if (!entry.lineName || !entry.OperatingProfile || !entry.destinationName) return false;
                        const entrySaneRoute = sanitizeFirebaseKey(entry.lineName); const entrySaneProfile = sanitizeFirebaseKey(entry.OperatingProfile); const entrySaneDest = sanitizeFirebaseKey(entry.destinationName);
                        return `${entrySaneRoute}/${entrySaneProfile}/${entrySaneDest}` === rpdPathKey;
                    });
                    entriesForThisRPD.sort((a, b) => { const timeA = (a.scheduledTime || "99:99").replace(':', ''); const timeB = (b.scheduledTime || "99:99").replace(':', ''); const timeCompare = timeA.localeCompare(timeB); if (timeCompare !== 0) return timeCompare; return (a.internalId || "").localeCompare(b.internalId || ""); });
                    const specificFirebasePath = `${FB_PATH_SCHEDULES_BY_ROUTE}/${rpdPathKey}/entries`;
                    console.log(`Targeted Update: Pushing update for ${entriesForThisRPD.length} entries to: ${specificFirebasePath}`);
                    writePromises.push(dbSet(dbRef(database, specificFirebasePath), entriesForThisRPD));
                });
                await Promise.all(writePromises);
                console.log(`Targeted Update: Successfully updated affected R/P/D paths for stop ${stopID}.`);
                await updateAncillaryScheduleData_ExtraPage();
                alert(`Details for Stop ID "${stopID}" updated (${affectedEntryCount} entries, ${affectedRPDPathKeys.size} configs).`);
                if (masterListApplyChangesStatus_el_extra) { masterListApplyChangesStatus_el_extra.textContent = `Stop ${stopID} details updated.`; masterListApplyChangesStatus_el_extra.style.color = "#2ecc71"; }
                renderUIDependentElements_ExtraPage();
            } catch (error) {
                console.error(`Error updating stop ${stopID} details:`, error);
                alert(`Error saving edits for stop ${stopID}: ${error.message}. Refresh advised.`);
                if (masterListApplyChangesStatus_el_extra) { masterListApplyChangesStatus_el_extra.textContent = `Error updating ${stopID}: ${error.message}`; masterListApplyChangesStatus_el_extra.style.color = "#e74c3c"; }
            }
        }
        async function handleDeleteStopFromMasterList_ExtraPage(stopIdToRemove) {
            if (!currentUser_extra) { alert("Log in."); return; }
            const stopDetails = uniqueStopsMasterList_extra.find(s => s.stopID === stopIdToRemove);
            const stopNameToConfirm = stopDetails ? `${stopDetails.stopName} (${stopIdToRemove})` : stopIdToRemove;
            if (!confirm(`ARE YOU SURE?\nRemove stop "${stopNameToConfirm}" and ALL its schedule entries from Firebase?`)) return;
            const initialLength = currentWorkingSchedule_extra.length;
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(e => e.stopID.toUpperCase() !== stopIdToRemove.toUpperCase());
            const removedCount = initialLength - currentWorkingSchedule_extra.length;
            const closedIdx = closedStopIDs_extra.indexOf(stopIdToRemove.toUpperCase()); if (closedIdx > -1) closedStopIDs_extra.splice(closedIdx, 1);
            if (stopSpecificRouteColours_extra[stopIdToRemove.toUpperCase()]) delete stopSpecificRouteColours_extra[stopIdToRemove.toUpperCase()];
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
                await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                alert(`Stop "${stopNameToConfirm}" and ${removedCount} entries removed.`);
                renderUIDependentElements_ExtraPage();
            } catch (error) { alert("Error deleting stop: " + error.message); }
        }
        async function handleToggleStopStatusFromMasterList_ExtraPage(stopID) { if (!currentUser_extra) { alert("Log in."); return; } const stopIdUpper = stopID.toUpperCase(); const idx = closedStopIDs_extra.indexOf(stopIdUpper); if (idx === -1) closedStopIDs_extra.push(stopIdUpper); else closedStopIDs_extra.splice(idx, 1); try { await saveClosedStopsToFirebase_ExtraPage(); const status = idx === -1 ? "closed" : "reopened"; alert(`Stop "${stopID}" marked ${status}.`); populateMasterStopList_ExtraPage(); } catch (error) { alert("Error saving status: " + error.message); if (idx === -1) closedStopIDs_extra.pop(); else closedStopIDs_extra.splice(idx, 0, stopIdUpper); } }
        async function handleApplyMasterListStopIdChangesButton_ExtraPage() {
            if (!currentUser_extra || !masterStopListUL_el_extra || !masterListApplyChangesStatus_el_extra) return;
            masterListApplyChangesStatus_el_extra.textContent = "Processing ID changes..."; masterListApplyChangesStatus_el_extra.style.color = '#f1c40f';
            const idChangeProposals = []; const allInputs = masterStopListUL_el_extra.querySelectorAll('.master-list-new-id-input'); let hasErrors = false; const newProposedIDsInThisBatch = new Set();
            allInputs.forEach(input => { 
                const originalId = input.dataset.originalId; const newId = input.value.trim().toUpperCase(); const warningElement = input.parentElement.querySelector('.master-list-row-warning'); if (warningElement) warningElement.textContent = ''; if (newId && newId !== originalId.toUpperCase()) { if (!/^[A-Z0-9]+$/.test(newId)) { if(warningElement) warningElement.textContent = "Invalid chars!"; hasErrors = true; return; } if (newProposedIDsInThisBatch.has(newId)) { if(warningElement) warningElement.textContent = "Duplicate New ID!"; hasErrors = true; return; } const existingStopConflict = currentWorkingSchedule_extra.some(e => e.stopID.toUpperCase() === newId && !Array.from(allInputs).some(inp => inp.dataset.originalId.toUpperCase() === newId)); if (existingStopConflict) { if(warningElement) warningElement.textContent = "Conflicts existing ID!"; hasErrors = true; return; } idChangeProposals.push({ originalId: originalId, newId: newId }); newProposedIDsInThisBatch.add(newId); }
            });
            if (hasErrors) { masterListApplyChangesStatus_el_extra.textContent = "Errors in proposed IDs. Correct and retry."; masterListApplyChangesStatus_el_extra.style.color = '#e74c3c'; return; }
            if (idChangeProposals.length === 0) { masterListApplyChangesStatus_el_extra.textContent = "No Stop ID changes proposed."; masterListApplyChangesStatus_el_extra.style.color = '#7f8c8d'; return; }
            if (!confirm(`Apply ${idChangeProposals.length} Stop ID changes to Firebase?`)) { masterListApplyChangesStatus_el_extra.textContent = "Bulk ID change cancelled."; masterListApplyChangesStatus_el_extra.style.color = '#7f8c8d'; return; }
            let actualUpdateCount = 0; const originalToNewIdMap = new Map(idChangeProposals.map(p => [p.originalId.toUpperCase(), p.newId]));
            currentWorkingSchedule_extra.forEach(entry => { const originalEntryStopIDUpper = entry.stopID.toUpperCase(); if (originalToNewIdMap.has(originalEntryStopIDUpper)) { entry.stopID = originalToNewIdMap.get(originalEntryStopIDUpper); actualUpdateCount++; } });
            const updatedClosedStopIDs = new Set(); closedStopIDs_extra.forEach(closedId => { updatedClosedStopIDs.add(originalToNewIdMap.get(closedId.toUpperCase()) || closedId); }); closedStopIDs_extra = Array.from(updatedClosedStopIDs);
            const updatedStopSpecificColours = {}; for (const oldStopIdKey in stopSpecificRouteColours_extra) { updatedStopSpecificColours[originalToNewIdMap.get(oldStopIdKey.toUpperCase()) || oldStopIdKey] = stopSpecificRouteColours_extra[oldStopIdKey]; } stopSpecificRouteColours_extra = updatedStopSpecificColours;
            if (actualUpdateCount > 0 || idChangeProposals.some(p => closedStopIDs_extra.includes(p.newId.toUpperCase()) || stopSpecificRouteColours_extra[p.newId.toUpperCase()])) {
                try {
                    await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra); 
                    await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                    masterListApplyChangesStatus_el_extra.textContent = `Applied ${idChangeProposals.length} Stop ID change(s) (${actualUpdateCount} entries).`; masterListApplyChangesStatus_el_extra.style.color = '#2ecc71';
                    renderUIDependentElements_ExtraPage();
                } catch (error) { console.error("Error applying bulk ID changes:", error); masterListApplyChangesStatus_el_extra.textContent = "Error saving bulk ID changes: " + error.message; masterListApplyChangesStatus_el_extra.style.color = '#e74c3c'; alert("Critical error saving bulk Stop ID changes. Data inconsistent. Refresh."); }
            } else { masterListApplyChangesStatus_el_extra.textContent = "No schedule entries affected by proposed changes."; masterListApplyChangesStatus_el_extra.style.color = '#f1c40f'; }
        }
        function findDuplicateStopsByNameAndDirection_ExtraPage() { if (!currentUser_extra) { alert("Please log in."); if (duplicateStopsByNameDirResults_el_extra) duplicateStopsByNameDirResults_el_extra.textContent = "Please log in."; return; } if (!duplicateStopsByNameDirResults_el_extra) { console.error("Result display element not found."); return; } duplicateStopsByNameDirResults_el_extra.innerHTML = "<p>Checking for duplicates...</p>"; duplicateStopsByNameDirResults_el_extra.style.color = "#f1c40f"; const stopsToCheck = getUniqueStopsFromSchedule_ExtraPage(); if (!stopsToCheck || stopsToCheck.length === 0) { duplicateStopsByNameDirResults_el_extra.textContent = "No stops loaded."; return; } const signatureMap = new Map(); stopsToCheck.forEach(stop => { if (stop.stopName && stop.stopID) { const name = stop.stopName.trim().toLowerCase(); const direction = (stop.direction || "").trim().toLowerCase(); const signature = `${name}|${direction}`; if (!signatureMap.has(signature)) signatureMap.set(signature, []); signatureMap.get(signature).push({id: stop.stopID, name: stop.stopName, direction: stop.direction}); } }); let duplicateSets = []; signatureMap.forEach((stops, signature) => { if (stops.length > 1) { duplicateSets.push({ signature: signature, name: stops[0].name, direction: stops[0].direction || "", stops: stops.map(s => ({ id: s.id, entryCount: currentWorkingSchedule_extra.filter(entry => entry.stopID === s.id).length })).sort((a,b) => b.entryCount - a.id.localeCompare(b.id)) }); } }); if (duplicateSets.length === 0) { duplicateStopsByNameDirResults_el_extra.textContent = "No duplicate stops found (name & direction)."; duplicateStopsByNameDirResults_el_extra.style.color = "#2ecc71"; } else { let html = `<p>${duplicateSets.length} set(s) of duplicate stops found:</p><ul>`; duplicateSets.forEach((set, index) => { html += `<li class="duplicate-set-to-merge">`; html += `<p><strong>Name:</strong> "${set.name}", <strong>Direction:</strong> "${set.direction || '(None)'}"</p>`; html += `<p>Conflicting StopIDs (select one to keep):</p><div class="stop-id-options">`; set.stops.forEach((stop, radioIndex) => { const radioName = `master_for_set_${index}`; const isChecked = radioIndex === 0 ? "checked" : ""; html += `<label><input type="radio" name="${radioName}" value="${stop.id}" ${isChecked}> ${stop.id} (${stop.entryCount} entries)</label><br>`; }); html += `</div></li>`; }); html += `</ul><button id="mergeDuplicateStopsButton_extra" class="button save" style="margin-top:1rem;">Merge Selected Duplicates</button>`; html += `<p id="mergeDuplicateStopsStatus_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>`; duplicateStopsByNameDirResults_el_extra.innerHTML = html; duplicateStopsByNameDirResults_el_extra.style.color = "#e74c3c"; const mergeButton = document.getElementById('mergeDuplicateStopsButton_extra'); if (mergeButton) mergeButton.addEventListener('click', handleMergeDuplicateStops_ExtraPage); } }
        async function handleMergeDuplicateStops_ExtraPage() {
            if (!currentUser_extra) { alert("Log in."); return; }
            const mergeStatusEl = document.getElementById('mergeDuplicateStopsStatus_extra'); if (!mergeStatusEl) return;
            mergeStatusEl.textContent = "Processing merges..."; mergeStatusEl.style.color = "#f1c40f";
            const duplicateSetElements = duplicateStopsByNameDirResults_el_extra.querySelectorAll('.duplicate-set-to-merge'); if (duplicateSetElements.length === 0) { mergeStatusEl.textContent = "No duplicate sets found."; return; }
            let changesMade = false; let totalEntriesReassigned = 0; let stopIDsMergedAwayOverall = new Set();
            for (let i = 0; i < duplicateSetElements.length; i++) { 
                const radioName = `master_for_set_${i}`; const selectedRadio = duplicateStopsByNameDirResults_el_extra.querySelector(`input[name="${radioName}"]:checked`); if (!selectedRadio) continue; const masterStopID = selectedRadio.value; const masterStopDetails = uniqueStopsMasterList_extra.find(s => s.stopID === masterStopID) || currentWorkingSchedule_extra.find(e => e.stopID === masterStopID); if (!masterStopDetails) continue; const masterStopName = masterStopDetails.stopName; const masterStopDirection = masterStopDetails.direction; const allRadiosInSet = duplicateStopsByNameDirResults_el_extra.querySelectorAll(`input[name="${radioName}"]`); const stopIDsInThisSet = Array.from(allRadiosInSet).map(radio => radio.value); const stopIDsToMergeAway = stopIDsInThisSet.filter(id => id !== masterStopID); if (stopIDsToMergeAway.length > 0) { changesMade = true; stopIDsToMergeAway.forEach(idToMerge => { stopIDsMergedAwayOverall.add(idToMerge.toUpperCase()); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === idToMerge) { entry.stopID = masterStopID; entry.stopName = masterStopName; entry.direction = masterStopDirection; totalEntriesReassigned++; } }); }); }
            }
            if (!changesMade) { mergeStatusEl.textContent = "No merges selected."; mergeStatusEl.style.color = "#7f8c8d"; return; }
            closedStopIDs_extra = closedStopIDs_extra.filter(id => !stopIDsMergedAwayOverall.has(id.toUpperCase())); stopIDsMergedAwayOverall.forEach(idToMergeUpper => { if (stopSpecificRouteColours_extra[idToMergeUpper]) delete stopSpecificRouteColours_extra[idToMergeUpper]; });
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra); 
                await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                mergeStatusEl.textContent = `Merged duplicates. ${totalEntriesReassigned} entries reassigned.`; mergeStatusEl.style.color = "#2ecc71";
                renderUIDependentElements_ExtraPage(); findDuplicateStopsByNameAndDirection_ExtraPage();
            } catch (error) { console.error("Error saving merged stops:", error); mergeStatusEl.textContent = "Error saving merged stops: " + error.message; mergeStatusEl.style.color = "#e74c3c"; alert("CRITICAL: Error saving merged stops. Data inconsistent. Refresh."); }
        }
        async function saveClosedStopsToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; const fbClosedObject = {}; closedStopIDs_extra.forEach(id => { if (typeof id === 'string') fbClosedObject[id.toUpperCase()] = true; }); await dbSet(dbRef(database, FB_PATH_APPSTATE_CLOSED_STOPS), fbClosedObject); console.log("Closed stops saved (Extra)."); }
        async function saveGlobalColoursToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; await dbSet(dbRef(database, FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS), globalCustomRouteColours_extra); console.log("Global route colours saved (Extra)."); }
        async function saveStopSpecificColoursToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; await dbSet(dbRef(database, FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS), stopSpecificRouteColours_extra); console.log("Stop-specific colours saved (Extra)."); }

        // --- Global Route Deletion Functions ---
        function populateGlobalRouteToDeleteList_ExtraPage() { if (!globalRouteDeletionListContainer_el_extra) return; globalRouteDeletionListContainer_el_extra.innerHTML = ''; if (!currentWorkingSchedule_extra || currentWorkingSchedule_extra.length === 0) { globalRouteDeletionListContainer_el_extra.innerHTML = '<p>No routes loaded.</p>'; return; } const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName).filter(Boolean))].sort(compareLineNames_ExtraPage); if (uniqueRoutes.length === 0) { globalRouteDeletionListContainer_el_extra.innerHTML = '<p>No valid routes to list.</p>'; return; } const tileContainer = document.createElement('div'); tileContainer.className = 'selectable-route-tile-container'; uniqueRoutes.forEach(lineName => { const tile = document.createElement('span'); tile.className = 'selectable-route-tile'; tile.textContent = lineName; tile.dataset.lineName = lineName; const bgColor = getRouteTileColour_ExtraPage(lineName); tile.style.backgroundColor = bgColor; tile.style.color = getTextColourForBackground_ExtraPage(bgColor); tile.setAttribute('role', 'checkbox'); tile.setAttribute('aria-checked', 'false'); tile.tabIndex = 0; tile.addEventListener('click', () => { const isSelected = tile.classList.toggle('selected'); tile.setAttribute('aria-checked', isSelected.toString()); }); tile.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); tile.click(); }}); tileContainer.appendChild(tile); }); globalRouteDeletionListContainer_el_extra.appendChild(tileContainer); }
        async function handleDeleteEntireRouteGlobally_ExtraPage() {
            if (!currentUser_extra || !deleteEntireRouteStatusMessage_el_extra || !globalRouteDeletionListContainer_el_extra) return;
            const selectedTiles = globalRouteDeletionListContainer_el_extra.querySelectorAll('.selectable-route-tile.selected');
            if (selectedTiles.length === 0) { deleteEntireRouteStatusMessage_el_extra.textContent = "Select route(s) to delete."; deleteEntireRouteStatusMessage_el_extra.style.color = '#f1c40f'; return; }
            const routesToDelete = Array.from(selectedTiles).map(t => t.dataset.lineName);
            if (!confirm(`EXTREME CAUTION!\nDelete ALL data for route(s): ${routesToDelete.join(', ')} from Firebase? CANNOT BE UNDONE.`)) { deleteEntireRouteStatusMessage_el_extra.textContent = "Global deletion cancelled."; return; }
            deleteEntireRouteStatusMessage_el_extra.textContent = `Deleting route(s): ${routesToDelete.join(', ')}...`; deleteEntireRouteStatusMessage_el_extra.style.color = '#f1c40f';
            const { database, dbRemove, dbRef } = window.firebaseOMSI; let firebaseRemovalPromises = [];
            routesToDelete.forEach(routeNameToDelete => {
                const saneRouteName = sanitizeFirebaseKey(routeNameToDelete);
                const routePath = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRouteName}`;
                firebaseRemovalPromises.push(dbRemove(dbRef(database, routePath)));
            });
            const originalScheduleLength = currentWorkingSchedule_extra.length;
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry =>
                !(entry.lineName && routesToDelete.map(r => r.toUpperCase()).includes(entry.lineName.toUpperCase()))
            );
            const scheduleEntriesRemovedCount = originalScheduleLength - currentWorkingSchedule_extra.length;
            let globalColoursRemoved = false; routesToDelete.forEach(route => { if (globalCustomRouteColours_extra[route.toUpperCase()]) { delete globalCustomRouteColours_extra[route.toUpperCase()]; globalColoursRemoved = true; } });
            let specificColoursNeedSave = false; Object.keys(stopSpecificRouteColours_extra).forEach(stopID => { routesToDelete.forEach(route => { if (stopSpecificRouteColours_extra[stopID] && stopSpecificRouteColours_extra[stopID][route.toUpperCase()]) { delete stopSpecificRouteColours_extra[stopID][route.toUpperCase()]; if (Object.keys(stopSpecificRouteColours_extra[stopID]).length === 0) delete stopSpecificRouteColours_extra[stopID]; specificColoursNeedSave = true; } }); });
            try {
                await Promise.all(firebaseRemovalPromises); 
                if (globalColoursRemoved) await saveGlobalColoursToFirebase_ExtraPage();
                if (specificColoursNeedSave) await saveStopSpecificColoursToFirebase_ExtraPage();
                await updateAncillaryScheduleData_ExtraPage(); 
                deleteEntireRouteStatusMessage_el_extra.textContent = `Route(s) ${routesToDelete.join(', ')} deleted. ${scheduleEntriesRemovedCount} entries removed.`;
                deleteEntireRouteStatusMessage_el_extra.style.color = '#2ecc71';
                renderUIDependentElements_ExtraPage();
            } catch (error) {
                console.error("Error deleting route(s) globally:", error);
                deleteEntireRouteStatusMessage_el_extra.textContent = "Error saving deletions: " + error.message;
                deleteEntireRouteStatusMessage_el_extra.style.color = '#e74c3c';
                alert("Critical error saving global route deletions. Data inconsistent. Refresh.");
            }
        }

        // ++ Route Profile Deletion Functions (NEW SECTION) ++
        /**
         * @description Populates the route select dropdown for the Route Profile Deletion tool.
         */
        function rpd_populateRouteSelect_ExtraPage() {
            if (!rpdRouteSelect_el_extra || !rpdRouteInput_el_extra) return;
            const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))]
                .filter(Boolean)
                .sort(compareLineNames_ExtraPage);

            const currentInputValue = rpdRouteInput_el_extra.value.trim();
            rpdRouteSelect_el_extra.innerHTML = '<option value="">-- Select Route --</option>';
            uniqueRoutes.forEach(route => {
                const opt = document.createElement('option');
                opt.value = route;
                opt.textContent = route;
                rpdRouteSelect_el_extra.appendChild(opt);
            });

            const matchedRoute = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
            if (matchedRoute) {
                rpdRouteSelect_el_extra.value = matchedRoute;
            } else if (currentInputValue) {
                rpdRouteSelect_el_extra.value = ""; 
            }
            // Chain updates
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Handles changes to the route name input field for RPD.
         */
        function rpd_handleRouteNameInputChange_ExtraPage() {
            if (!rpdRouteInput_el_extra || !rpdRouteSelect_el_extra) return;
            const typedRouteUpper = rpdRouteInput_el_extra.value.trim().toUpperCase();
            const matchedOption = Array.from(rpdRouteSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper);

            if (matchedOption) {
                rpdRouteSelect_el_extra.value = matchedOption.value;
                if (rpdRouteInput_el_extra.value !== matchedOption.value) {
                    rpdRouteInput_el_extra.value = matchedOption.value;
                }
            } else {
                rpdRouteSelect_el_extra.value = ""; 
            }
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Handles changes to the route name select dropdown for RPD.
         */
        function rpd_handleRouteNameSelectChange_ExtraPage() {
            if (!rpdRouteSelect_el_extra || !rpdRouteInput_el_extra) return;
            rpdRouteInput_el_extra.value = rpdRouteSelect_el_extra.value;
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Populates the destination select dropdown for RPD based on selected route.
         */
        function rpd_populateDestinationSelect_ExtraPage() {
            if (!rpdDestinationSelect_el_extra || !rpdDestinationInput_el_extra || !rpdRouteInput_el_extra) return;

            const selectedRoute = rpdRouteInput_el_extra.value.trim().toUpperCase();
            const currentDestInputValue = rpdDestinationInput_el_extra.value.trim();

            rpdDestinationSelect_el_extra.innerHTML = '<option value="">-- Optional: All Destinations --</option>'; // Modified default text

            if (!selectedRoute) {
                rpdDestinationInput_el_extra.value = ""; 
                rpdDestinationSelect_el_extra.disabled = true;
                rpdDestinationInput_el_extra.disabled = true;
                if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = 'none';
                rpd_populateProfileList_ExtraPage(); 
                return;
            }

            rpdDestinationSelect_el_extra.disabled = false;
            rpdDestinationInput_el_extra.disabled = false;

            const uniqueDestinations = [...new Set(
                currentWorkingSchedule_extra
                    .filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName)
                    .map(e => e.destinationName)
            )].sort();

            if (uniqueDestinations.length > 0) {
                uniqueDestinations.forEach(dest => {
                    const opt = document.createElement('option');
                    opt.value = dest;
                    opt.textContent = dest;
                    rpdDestinationSelect_el_extra.appendChild(opt);
                });
                const matchedDest = uniqueDestinations.find(d => d === currentDestInputValue);
                if (matchedDest) {
                    rpdDestinationSelect_el_extra.value = matchedDest;
                } else {
                     rpdDestinationSelect_el_extra.value = ""; // Default to "All Destinations" if typed value doesn't match
                }
            } else {
                 rpdDestinationSelect_el_extra.innerHTML = '<option value="">-- No Specific Destinations --</option>';
                 rpdDestinationInput_el_extra.value = ""; // Clear input if no destinations exist
            }
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }
        
        /**
         * @description Handles changes to the destination name input field for RPD.
         */
        function rpd_handleDestinationNameInputChange_ExtraPage() {
            if (!rpdDestinationInput_el_extra || !rpdDestinationSelect_el_extra) return;
            const typedDest = rpdDestinationInput_el_extra.value.trim();
            const matchedOption = Array.from(rpdDestinationSelect_el_extra.options).find(opt => opt.value === typedDest);

            if (matchedOption) {
                rpdDestinationSelect_el_extra.value = matchedOption.value;
                if (rpdDestinationInput_el_extra.value !== matchedOption.value) {
                   rpdDestinationInput_el_extra.value = matchedOption.value;
                }
            } else {
                rpdDestinationSelect_el_extra.value = ""; // If typing something not in list, clear select to imply "All Destinations" or new
            }
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }

        /**
         * @description Handles changes to the destination name select dropdown for RPD.
         */
        function rpd_handleDestinationNameSelectChange_ExtraPage() {
            if (!rpdDestinationSelect_el_extra || !rpdDestinationInput_el_extra) return;
            rpdDestinationInput_el_extra.value = rpdDestinationSelect_el_extra.value; // Sync input with select
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }
        
        /**
         * @description Clears the destination selection for RPD.
         */
        function rpd_handleClearDestination_ExtraPage() {
            if (!rpdDestinationInput_el_extra || !rpdDestinationSelect_el_extra || !rpdClearDestinationButton_el_extra) return;
            rpdDestinationInput_el_extra.value = "";
            rpdDestinationSelect_el_extra.value = ""; // This will select "-- Optional: All Destinations --"
            rpdClearDestinationButton_el_extra.style.display = 'none';
            rpd_populateProfileList_ExtraPage(); 
        }

        /**
         * @description Fetches and displays available profiles for selection based on route and optional destination.
         */
        async function rpd_populateProfileList_ExtraPage() {
            if (!rpdProfileListContainer_el_extra || !rpdRouteInput_el_extra || !rpdDestinationInput_el_extra || !window.firebaseOMSI) {
                if (rpdProfileListContainer_el_extra) rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; opacity:0.7;">Required elements missing for profile listing.</p>';
                return;
            }

            const routeName = rpdRouteInput_el_extra.value.trim();
            const destinationName = rpdDestinationInput_el_extra.value.trim(); // This is the specific destination, if selected

            rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; opacity:0.7;">Select a route to see available profiles.</p>';

            if (!routeName) {
                return; 
            }

            rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; color:#f1c40f;">Loading profiles...</p>';

            // Use currentWorkingSchedule_extra to derive profiles to ensure original casing and relevance
            let profilesOfInterest = currentWorkingSchedule_extra.filter(entry => {
                if (entry.lineName !== routeName) return false;
                if (destinationName && entry.destinationName !== destinationName) return false; // Filter by dest if specified
                return true; // Passes if route matches, and dest matches (if dest was specified)
            });

            let availableOriginalProfileNames = [...new Set(profilesOfInterest.map(e => e.OperatingProfile))].sort();

            if (availableOriginalProfileNames.length === 0) {
                if (destinationName) {
                    rpdProfileListContainer_el_extra.innerHTML = `<p style="font-size:0.85em; color:#f1c40f;">No profiles found for route "${routeName}" with destination "${destinationName}".</p>`;
                } else {
                    rpdProfileListContainer_el_extra.innerHTML = `<p style="font-size:0.85em; color:#f1c40f;">No profiles found for route "${routeName}".</p>`;
                }
                return;
            }

            let html = '<div class="selectable-route-tile-container" style="margin-top:0.5rem;">'; 
            availableOriginalProfileNames.forEach(profileName => {
                html += `
                    <label class="selectable-route-tile rpd-profile-tile" style="background-color: #4A5568; color: white; border-color: transparent;" tabindex="0">
                        <input type="checkbox" class="rpd-profile-checkbox sr-only" value="${profileName}">
                        ${profileName}
                    </label>
                `;
            });
            html += '</div>';
            rpdProfileListContainer_el_extra.innerHTML = html;

            rpdProfileListContainer_el_extra.querySelectorAll('.rpd-profile-tile').forEach(tile => {
                const checkbox = tile.querySelector('.rpd-profile-checkbox');
                const toggleSelection = () => {
                    checkbox.checked = !checkbox.checked;
                    tile.classList.toggle('selected', checkbox.checked); 
                    tile.style.borderColor = checkbox.checked ? '#f1c40f' : 'transparent'; // Visual feedback
                    tile.setAttribute('aria-checked', checkbox.checked.toString());
                };
                tile.addEventListener('click', toggleSelection);
                tile.addEventListener('keydown', (e) => {
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        toggleSelection();
                    }
                });
            });
        }


        /**
         * @description Handles the deletion of selected route profiles.
         */
        async function handleDeleteRouteProfiles_ExtraPage() {
            if (!currentUser_extra || !window.firebaseOMSI) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Not logged in or Firebase not available."; rpdStatusMessage_el_extra.style.color = "#e74c3c";}
                return;
            }

            const routeName = rpdRouteInput_el_extra.value.trim();
            const destinationName = rpdDestinationInput_el_extra.value.trim(); // Optional, if empty means all destinations
            const selectedProfileCheckboxes = rpdProfileListContainer_el_extra.querySelectorAll('.rpd-profile-checkbox:checked');

            if (!routeName) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Please select a route."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}
                return;
            }
            if (selectedProfileCheckboxes.length === 0) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Please select at least one profile to delete."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}
                return;
            }

            const profilesToDeleteOriginalNames = Array.from(selectedProfileCheckboxes).map(cb => cb.value);
            const saneRoute = sanitizeFirebaseKey(routeName);
            const saneDest = destinationName ? sanitizeFirebaseKey(destinationName) : null;

            let confirmMessage = `ARE YOU SURE?\nThis will delete ALL schedule entries for:\nRoute: "${routeName}"`;
            if (saneDest) {
                confirmMessage += `\nDestination: "${destinationName}"`;
            } else {
                confirmMessage += ` (across ALL its destinations)`;
            }
            confirmMessage += `\nFor Operating Profile(s): ${profilesToDeleteOriginalNames.join(', ')}\n\nThis action CANNOT BE UNDONE.`;

            if (!confirm(confirmMessage)) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Profile deletion cancelled."; rpdStatusMessage_el_extra.style.color = "";}
                return;
            }

            if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Deleting profiles from Firebase..."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}

            const { database, dbRemove, dbRef } = window.firebaseOMSI;
            const removalPromises = [];

            profilesToDeleteOriginalNames.forEach(profileName => {
                const saneProfile = sanitizeFirebaseKey(profileName);
                let pathToDelete;
                if (saneDest) { // Delete specific destination under profile
                    pathToDelete = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}/${saneProfile}/${saneDest}`;
                } else { // Delete entire profile node for the route
                    pathToDelete = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}/${saneProfile}`;
                }
                console.log("Firebase path marked for deletion:", pathToDelete);
                removalPromises.push(dbRemove(dbRef(database, pathToDelete)));
            });

            try {
                await Promise.all(removalPromises);
                console.log("Firebase removal operations complete for selected profiles.");

                const originalLength = currentWorkingSchedule_extra.length;
                currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
                    const routeMatch = entry.lineName === routeName;
                    const profileMatch = profilesToDeleteOriginalNames.includes(entry.OperatingProfile);
                    // If saneDest is specified, entry must match it. If saneDest is null, destination doesn't matter for removal of whole profile.
                    const destMatch = saneDest ? (entry.destinationName === destinationName) : true;
                    
                    return !(routeMatch && profileMatch && destMatch);
                });
                const removedCount = originalLength - currentWorkingSchedule_extra.length;
                console.log(`${removedCount} entries removed from local currentWorkingSchedule_extra.`);

                await updateAncillaryScheduleData_ExtraPage();

                if(rpdStatusMessage_el_extra) {
                    rpdStatusMessage_el_extra.textContent = `Successfully deleted ${profilesToDeleteOriginalNames.length} profile(s) (${removedCount} schedule entries affected) for route "${routeName}"${saneDest ? ' and destination "' + destinationName + '"' : ' (all destinations for those profiles)'}. Ancillary data updated.`;
                    rpdStatusMessage_el_extra.style.color = "#2ecc71";
                }
                
                rpd_populateProfileList_ExtraPage(); // Refresh profile list
                renderUIDependentElements_ExtraPage(); 

            } catch (error) {
                console.error("Error deleting route profiles:", error);
                if(rpdStatusMessage_el_extra) {
                    rpdStatusMessage_el_extra.textContent = "Error deleting profiles from Firebase: " + error.message;
                    rpdStatusMessage_el_extra.style.color = "#e74c3c";
                }
                alert("Failed to delete profiles from Firebase. Data might be inconsistent. It's recommended to reload data from Firebase or review carefully.");
            }
        }
        // ++ END Route Profile Deletion Functions ++




        // ++ Route Schedule Generator Functions START ++
const RSG_OPERATING_PROFILES_LIST = [
    "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su",
    "MF",
    "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MFSch",
    "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MFNSD",
    "Christmas Day", "Boxing Day", "New Years Day"
];

const RSG_PROFILE_GROUPS_TO_MANAGE = [
    { individuals: ["Mo", "Tu", "We", "Th", "Fr"], groupProfile: "MF" },
    { individuals: ["MoSch", "TuSch", "WeSch", "ThSch", "FrSch"], groupProfile: "MFSch" },
    { individuals: ["MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"], groupProfile: "MFNSD" }
];

const RSG_PROFILE_INCOMPATIBILITY_RULES = {
    "Mo": ["MoSch", "MoNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MoSch": ["Mo", "MoNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MoNSD": ["Mo", "MoSch", "MF", "MFSch", "MFNSD", "AllDays"],
    "Tu": ["TuSch", "TuNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "TuSch": ["Tu", "TuNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "We": ["WeSch", "WeNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "Th": ["ThSch", "ThNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "Fr": ["FrSch", "FrNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MF": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MFSch", "MFNSD", "AllDays"],
    "MFSch": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MF", "MFNSD", "AllDays"],
    "MFNSD": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MF", "MFSch", "AllDays"],
    "Sa": ["SaNSD", "AllDays"],
    "SaNSD": ["Sa", "AllDays"],
    "Su": ["SuNSD", "AllDays"],
    "SuNSD": ["Su", "AllDays"],
    "AllDays": RSG_OPERATING_PROFILES_LIST.filter(p => p !== "AllDays"),
    "SchoolHoliday": ["AllDays", "MFSch", "MFNSD", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"],
    "BankHoliday": ["AllDays", "MFSch", "MFNSD", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"]
};

for (const keyProfile_extra in RSG_PROFILE_INCOMPATIBILITY_RULES) {
    RSG_PROFILE_INCOMPATIBILITY_RULES[keyProfile_extra].forEach(disabledProfile_extra => {
        if (!RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra]) {
            RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra] = [];
        }
        if (!RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra].includes(keyProfile_extra)) {
            RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra].push(keyProfile_extra);
        }
    });
}

const MASTER_VALID_PROFILE_COMBINATIONS_LIST_EXTRA = [
    "Mo", "Mo,Tu", "Mo,Tu,We", "Mo,Tu,We,Th", "Mo,Tu,We,Th,Sa", "Mo,Tu,We,Th,Sa,Su",
    "Mo,Tu,We,Th,Su", "Mo,Tu,We,Fr", "Mo,Tu,We,Fr,Sa", "Mo,Tu,We,Fr,Sa,Su",
    "Mo,Tu,We,Fr,Su", "Mo,Tu,We,Sa", "Mo,Tu,We,Sa,Su", "Mo,Tu,We,Su", "Mo,Tu,Th",
    "Mo,Tu,Th,Sa", "Mo,Tu,Th,Sa,Su", "Mo,Tu,Th,Su", "Mo,Tu,Fr", "Mo,Tu,Fr,Sa",
    "Mo,Tu,Fr,Sa,Su", "Mo,Tu,Fr,Su", "Mo,Tu,Sa", "Mo,Tu,Sa,Su", "Mo,Tu,Su", "Mo,We",
    "Mo,We,Th", "Mo,We,Th,Fr", "Mo,We,Th,Fr,Sa", "Mo,We,Th,Fr,Sa,Su", "Mo,We,Th,Fr,Su",
    "Mo,We,Th,Sa", "Mo,We,Th,Sa,Su", "Mo,We,Th,Su", "Mo,We,Fr", "Mo,We,Fr,Sa",
    "Mo,We,Fr,Sa,Su", "Mo,We,Fr,Su", "Mo,We,Sa", "Mo,We,Sa,Su", "Mo,We,Su", "Mo,Th",
    "Mo,Th,Fr", "Mo,Th,Fr,Sa", "Mo,Th,Fr,Sa,Su", "Mo,Th,Fr,Su", "Mo,Th,Sa",
    "Mo,Th,Sa,Su", "Mo,Th,Su", "Mo,Fr", "Mo,Fr,Sa", "Mo,Fr,Sa,Su", "Mo,Fr,Su", "Mo,Sa",
    "Mo,Sa,Su", "Mo,Su",
    "MoSch", "MoSch,TuSch", "MoSch,TuSch,WeSch", "MoSch,TuSch,WeSch,ThSch", "MoSch,TuSch,WeSch,FrSch",
    "MoSch,TuSch,ThSch", "MoSch,TuSch,ThSch,FrSch", "MoSch,TuSch,FrSch", "MoSch,WeSch",
    "MoSch,WeSch,ThSch", "MoSch,WeSch,ThSch,FrSch", "MoSch,WeSch,FrSch", "MoSch,ThSch",
    "MoSch,ThSch,FrSch", "MoSch,FrSch",
    "MoNSD", "MoNSD,TuNSD", "MoNSD,TuNSD,WeNSD", "MoNSD,TuNSD,WeNSD,ThNSD", "MoNSD,TuNSD,WeNSD,FrNSD",
    "MoNSD,TuNSD,ThNSD", "MoNSD,TuNSD,ThNSD,FrNSD", "MoNSD,TuNSD,FrNSD", "MoNSD,WeNSD",
    "MoNSD,WeNSD,ThNSD", "MoNSD,WeNSD,ThNSD,FrNSD", "MoNSD,WeNSD,FrNSD", "MoNSD,ThNSD",
    "MoNSD,ThNSD,FrNSD", "MoNSD,FrNSD",
    "Tu", "Tu,We", "Tu,We,Th", "Tu,We,Th,Fr", "Tu,We,Th,Fr,Sa", "Tu,We,Th,Fr,Sa,Su",
    "Tu,We,Th,Fr,Su", "Tu,We,Th,Sa", "Tu,We,Th,Sa,Su", "Tu,We,Th,Su", "Tu,We,Fr",
    "Tu,We,Fr,Sa", "Tu,We,Fr,Sa,Su", "Tu,We,Fr,Su", "Tu,We,Sa", "Tu,We,Sa,Su", "Tu,We,Su",
    "Tu,Th", "Tu,Th,Fr", "Tu,Th,Fr,Sa", "Tu,Th,Fr,Sa,Su", "Tu,Th,Fr,Su", "Tu,Th,Sa",
    "Tu,Th,Sa,Su", "Tu,Th,Su", "Tu,Fr", "Tu,Fr,Sa", "Tu,Fr,Sa,Su", "Tu,Fr,Su", "Tu,Sa",
    "Tu,Sa,Su", "Tu,Su",
    "TuSch", "TuSch,WeSch", "TuSch,WeSch,ThSch", "TuSch,WeSch,FrSch", "TuSch,ThSch", "TuSch,ThSch,FrSch",
    "TuSch,FrSch",
    "TuNSD", "TuNSD,WeNSD", "TuNSD,WeNSD,ThNSD", "TuNSD,WeNSD,ThNSD,FrNSD", "TuNSD,WeNSD,FrNSD",
    "TuNSD,ThNSD", "TuNSD,ThNSD,FrNSD", "TuNSD,FrNSD",
    "We", "We,Th", "We,Th,Fr", "We,Th,Fr,Sa", "We,Th,Fr,Sa,Su", "We,Th,Fr,Su", "We,Th,Sa",
    "We,Th,Sa,Su", "We,Th,Su", "We,Fr", "We,Fr,Sa", "We,Fr,Sa,Su", "We,Fr,Su", "We,Sa",
    "We,Sa,Su", "We,Su",
    "WeSch", "WeSch,ThSch", "WeSch,ThSch,FrSch", "WeSch,FrSch",
    "WeNSD", "WeNSD,ThNSD", "WeNSD,ThNSD,FrNSD", "WeNSD,FrNSD",
    "Th", "Th,Fr", "Th,Fr,Sa", "Th,Fr,Sa,Su", "Th,Fr,Su", "Th,Sa", "Th,Sa,Su", "Th,Su",
    "ThSch", "ThSch,FrSch",
    "ThNSD", "ThNSD,FrNSD",
    "Fr", "Fr,Sa", "Fr,Sa,Su", "Fr,Su",
    "FrSch", "FrNSD",
    "MF", "MF,Sa", "MF,Sa,Su", "MF,Su",
    "MFSch", "MFNSD",
    "Sa", "Sa,Su",
    "Su",
    "Christmas Day",
    "Boxing Day",
    "New Years Day"
];

// Helper function to create a canonical string (sorted, comma-separated)
function rsg_getCanonicalProfileString(profileArray) {
    if (!Array.isArray(profileArray)) return "";
    return profileArray.map(p => String(p).trim()).sort((a,b) => a.localeCompare(b)).join(',');
}

const VALID_PROFILE_COMBINATIONS_SET = new Set(
    MASTER_VALID_PROFILE_COMBINATIONS_LIST_EXTRA.map(s => rsg_getCanonicalProfileString(s.split(',')))
);

function rsg_showSaveConfigModal_ExtraPage() {
    const routeName = rsgRouteNameInput_el_extra.value.trim();
    const destName = rsgDestinationNameInput_el_extra.value.trim();
    const opProfiles = rsg_getSelectedOpProfilesString_ExtraPage(); // This returns "MF, Sa", "Su", etc.

    if (!routeName || !destName || !opProfiles) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route, Destination, and at least one Operating Profile must be selected to suggest a name for saving.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    // Sanitize route and destination parts for the default name
    const defaultNameRoute = routeName.replace(/[^a-zA-Z0-9\s-]/g, '').trim() || "Route";
    const defaultNameDest = destName.replace(/[^a-zA-Z0-9\s-]/g, '').trim() || "Dest";
    const defaultNameProfile = opProfiles || "Profile"; 
    // If you want to be extra safe and sanitize it lightly (allowing letters, numbers, spaces, commas):
    // const defaultNameProfile = opProfiles.replace(/[^a-zA-Z0-9\s,]/g, '').trim() || "Profile";


    const defaultConfigName = `${defaultNameRoute} to ${defaultNameDest} - ${defaultNameProfile}`;

    const configNameInput = document.getElementById('rsg-config-name-input-extra');
    const modal = document.getElementById('rsg-save-config-modal-extra');
    const modalStatus = document.getElementById('rsg-save-config-modal-status-extra');

    if (configNameInput) configNameInput.value = defaultConfigName;
    if (modalStatus) modalStatus.textContent = '';
    if (modal) modal.style.display = 'flex';
}

function rsg_hideSaveConfigModal_ExtraPage() {
    const modal = document.getElementById('rsg-save-config-modal-extra');
    if (modal) modal.style.display = 'none';
}

async function rsg_performSaveConfiguration_ExtraPage() {
    const configNameInput = document.getElementById('rsg-config-name-input-extra');
    const modalStatus = document.getElementById('rsg-save-config-modal-status-extra');
    if (!configNameInput || !modalStatus) return;

    const userDefinedConfigName = configNameInput.value.trim();
    if (!userDefinedConfigName) {
        modalStatus.textContent = "Configuration name cannot be empty.";
        modalStatus.style.color = "#e74c3c";
        return;
    }

    // Sanitize the user-defined name to create a safe Firebase key
    const firebaseKey = sanitizeFirebaseKey(userDefinedConfigName); 
    if (!firebaseKey) { // sanitizeFirebaseKey might return empty if input is only invalid chars
        modalStatus.textContent = "Invalid configuration name (results in empty key). Please use different characters.";
        modalStatus.style.color = "#e74c3c";
        return;
    }

    // Gather current RSG state
    const routeName = rsgRouteNameInput_el_extra.value.trim();
    const destinationName = rsgDestinationNameInput_el_extra.value.trim();
    const operatingProfile = rsg_getSelectedOpProfilesString_ExtraPage(); // Comma-separated, sorted
    const stopSequence = rsg_selectedStops_extra;
    const firstStopTimes = rsgFirstStopTimesInput_el_extra.value.trim();

    if (!routeName || !destinationName || !operatingProfile || stopSequence.length === 0 || !firstStopTimes) {
        modalStatus.textContent = "Cannot save: Route, Destination, Profile, Stop Sequence, and First Stop Times are all required.";
        modalStatus.style.color = "#e74c3c";
        return;
    }

    const configurationToSave = {
        userDisplayName: userDefinedConfigName, // Store the original user-facing name
        routeName: routeName,
        destinationName: destinationName,
        operatingProfile: operatingProfile,
        stopSequence: JSON.parse(JSON.stringify(stopSequence)), // Deep copy
        firstStopTimes: firstStopTimes,
        lastSaved: new Date().toISOString()
    };

    modalStatus.textContent = `Saving configuration "${userDefinedConfigName}"...`;
    modalStatus.style.color = "#f1c40f";

    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        const fullSavePath = `${FB_PATH_RSG_CONFIGS}/${firebaseKey}`;
console.log("Attempting to save RSG configuration to Firebase path:", fullSavePath); // <<< ADD THIS LOG
await dbSet(dbRef(database, fullSavePath), configurationToSave);
        
        rsg_loadedConfigs_extra[firebaseKey] = configurationToSave; // Update local cache
        rsg_renderSavedConfigsList_ExtraPage(); // Refresh the displayed list

        modalStatus.textContent = `Configuration "${userDefinedConfigName}" saved successfully!`;
        modalStatus.style.color = "#2ecc71";
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Configuration "${userDefinedConfigName}" saved.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
        }
        setTimeout(rsg_hideSaveConfigModal_ExtraPage, 1500); // Close modal after success
    } catch (error) {
        console.error("Error saving RSG configuration to Firebase:", error);
        modalStatus.textContent = "Error saving configuration: " + error.message;
        modalStatus.style.color = "#e74c3c";
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Error saving configuration.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
    }
}

async function rsg_performRenameConfiguration_ExtraPage(configKeyToRename, newDisplayName) {
    const statusElement = document.getElementById('rsg-load-status-message-extra'); // Use the status message for the saved configs list

    if (!configKeyToRename) {
        if (statusElement) {
            statusElement.textContent = "Error: No configuration key provided for renaming.";
            statusElement.style.color = "#e74c3c";
        }
        console.error("rsg_performRenameConfiguration_ExtraPage: configKeyToRename is missing.");
        return;
    }

    // newDisplayName is assumed to be non-empty and trimmed by the caller
    // If it could still be empty, an additional check here would be good. For now, we assume caller handles it.

    const configToUpdate = rsg_loadedConfigs_extra[configKeyToRename];
    if (!configToUpdate) {
        if (statusElement) {
            statusElement.textContent = "Error: Original configuration data could not be found. Cannot rename.";
            statusElement.style.color = "#e74c3c";
        }
        console.error(`Failed to find config data for key: ${configKeyToRename} in rsg_loadedConfigs_extra.`);
        return;
    }

    if (statusElement) {
        statusElement.textContent = `Renaming configuration to "${newDisplayName}"...`;
        statusElement.style.color = "#f1c40f";
    }

    const updatedConfigData = {
        ...configToUpdate,
        userDisplayName: newDisplayName, // Already trimmed by caller
        lastSaved: new Date().toISOString()
    };

    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        await dbSet(dbRef(database, `${FB_PATH_RSG_CONFIGS}/${configKeyToRename}`), updatedConfigData);
        rsg_loadedConfigs_extra[configKeyToRename] = updatedConfigData; // Update local cache
        rsg_renderSavedConfigsList_ExtraPage(); // Refresh the displayed list

        if (statusElement) {
            statusElement.textContent = `Configuration successfully renamed to "${newDisplayName}"!`;
            statusElement.style.color = "#2ecc71";
        }
        // No modal to hide anymore for this process
    } catch (error) {
        console.error("Error renaming RSG configuration in Firebase:", error);
        if (statusElement) {
            statusElement.textContent = "Error renaming configuration: " + error.message;
            statusElement.style.color = "#e74c3c";
        }
    }
}

function toTitleCase_rsg(str) {
    if (!str || typeof str !== 'string') return "";
    // This will convert "LAKESIDE" to "Lakeside", "HIGH STREET" to "High Street", etc.
    return str.replace(/\w\S*/g, function(txt){
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
}

function rsg_renderSavedConfigsList_ExtraPage() {
    const container = document.getElementById('rsg-saved-configs-list-extra');
    // const placeholder was handled in the previous step (dynamically created if needed)
    if (!container) {
        console.error("RSG Saved Configs: Container element 'rsg-saved-configs-list-extra' not found.");
        return;
    }

    container.innerHTML = ''; // Clear previous list content first

    const configKeys = Object.keys(rsg_loadedConfigs_extra);

    if (configKeys.length === 0) {
        const p = document.createElement('p');
        p.id = "rsg-no-saved-configs-message-extra";
        p.style.padding = "0.5em";
        p.style.textAlign = "center";
        p.style.opacity = "0.7";
        p.textContent = "No configurations saved yet.";
        container.appendChild(p);
        return; 
    }

    const configsByRoute = {};
    configKeys.forEach(key => {
        const configData = rsg_loadedConfigs_extra[key];
        const routeName = configData.routeName || "Unknown Route";
        if (!configsByRoute[routeName]) {
            configsByRoute[routeName] = [];
        }
        configsByRoute[routeName].push({
            key: key,
            data: configData
        });
    });

    const sortedRouteNames = Object.keys(configsByRoute).sort(compareLineNames_ExtraPage);

    sortedRouteNames.forEach(routeName => {
        const routeHeading = document.createElement('h4');
        routeHeading.textContent = `Route ${routeName}:`; // Grouping still by actual routeName
        routeHeading.style.marginTop = "0.8em";
        routeHeading.style.marginBottom = "0.4em";
        routeHeading.style.fontSize = "1.1em";
        routeHeading.style.borderBottom = "1px solid rgba(127,140,141,0.3)";
        routeHeading.style.paddingBottom = "0.2em";
        if (container.children.length > 0) {
            routeHeading.style.marginTop = "1.2em";
        }
        container.appendChild(routeHeading);

        const configsForThisRoute = configsByRoute[routeName];

        configsForThisRoute.sort((a, b) => {
            // Sort by userDisplayName (the name shown in the list) primarily
            const nameA = (a.data.userDisplayName || a.key).toLowerCase();
            const nameB = (b.data.userDisplayName || b.key).toLowerCase();
            const nameCompare = nameA.localeCompare(nameB);
            if (nameCompare !== 0) return nameCompare;

            const destA = a.data.destinationName || "";
            const destB = b.data.destinationName || "";
            return destA.localeCompare(destB); // Secondary sort by destination if names are same
        });

        configsForThisRoute.forEach(configItem => {
            const configKey = configItem.key;
            const configData = configItem.data;
            
            // This is the name the user sets/sees in the list now
            const originalUserDisplayName = configData.userDisplayName || configKey; 

            // Keep constructing the descriptive parameter string for the tooltip
            const routeNameForDesc = configData.routeName || "N/A";
            let destinationNameForDesc = configData.destinationName || "N/A";
            if (destinationNameForDesc !== "N/A") {
                destinationNameForDesc = toTitleCase_rsg(destinationNameForDesc);
            }
            let operatingProfileForDesc = configData.operatingProfile || "N/A";
            if (operatingProfileForDesc !== "N/A" && typeof operatingProfileForDesc === 'string') {
                operatingProfileForDesc = operatingProfileForDesc.split(',')
                                             .map(p => p.trim())
                                             .join(', ');
            }
            const descriptiveParametersString = `${routeNameForDesc} to ${destinationNameForDesc} - ${operatingProfileForDesc}`;

            const itemDiv = document.createElement('div');
            itemDiv.style.padding = "0.4em 0.6em";
            itemDiv.style.marginBottom = "0.3em";
            itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)";
            itemDiv.style.borderRadius = "0.25rem";
            itemDiv.style.display = "flex";
            itemDiv.style.justifyContent = "space-between";
            itemDiv.style.alignItems = "center";
            itemDiv.addEventListener('mouseover', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.1)");
            itemDiv.addEventListener('mouseout', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)");
            // Updated tooltip: "Load" action refers to the displayed name, parameters shown for detail
            itemDiv.title = `Load: ${originalUserDisplayName}\n(Parameters: ${descriptiveParametersString})\n(Key: ${configKey})`;

            const nameSpan = document.createElement('span');
            nameSpan.textContent = originalUserDisplayName; // << KEY CHANGE: Display the user-set name
            nameSpan.style.flexGrow = "1";
            nameSpan.style.cursor = "pointer";
            nameSpan.addEventListener('click', () => rsg_handleLoadSelectedConfig_ExtraPage(configKey));

            const actionButtonsDiv = document.createElement('div');
            actionButtonsDiv.style.display = 'flex';
            actionButtonsDiv.style.alignItems = 'center';

            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Rename';
            renameBtn.classList.add('button', 'small-action', 'neutral');
            renameBtn.style.marginRight = "0.3em";
            renameBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const statusElement = document.getElementById('rsg-load-status-message-extra');
                if (statusElement) statusElement.textContent = "";

                // Prompt message now refers to the currently displayed name.
                // Pre-fill with that same name.
                const newNameFromPrompt = prompt(`Enter new name for configuration currently named "${originalUserDisplayName}":`, originalUserDisplayName);

                if (newNameFromPrompt === null) {
                    if (statusElement) {
                        statusElement.textContent = "Rename cancelled by user.";
                        statusElement.style.color = "";
                    }
                } else if (newNameFromPrompt.trim() === "") {
                    if (statusElement) {
                        statusElement.textContent = "Rename aborted: Configuration name cannot be empty.";
                        statusElement.style.color = "#e74c3c";
                    }
                } else if (newNameFromPrompt.trim() === originalUserDisplayName) { 
                    if (statusElement) {
                        statusElement.textContent = "Rename cancelled: The name is the same as the current saved name.";
                        statusElement.style.color = ""; 
                    }
                } else {
                    rsg_performRenameConfiguration_ExtraPage(configKey, newNameFromPrompt.trim());
                }
            });
            actionButtonsDiv.appendChild(renameBtn);

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'âœ•';
            deleteBtn.classList.add('button', 'small-action', 'secondary');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                rsg_handleDeleteSavedConfig_ExtraPage(configKey, originalUserDisplayName);
            });
            actionButtonsDiv.appendChild(deleteBtn);

            itemDiv.appendChild(nameSpan);
            itemDiv.appendChild(actionButtonsDiv);
            container.appendChild(itemDiv);
        });
    });
}

async function rsg_handleDeleteSavedConfig_ExtraPage(configKey, displayName) {
    if (!confirm(`Are you sure you want to delete the saved configuration: "${displayName}"? This cannot be undone.`)) {
        return;
    }
    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        alert("Firebase not available."); return;
    }
    const { database, dbRemove, dbRef } = window.firebaseOMSI;
    try {
        await dbRemove(dbRef(database, `<span class="math-inline">\{FB\_PATH\_RSG\_CONFIGS\}/</span>{configKey}`));
        delete rsg_loadedConfigs_extra[configKey]; // Remove from local cache
        rsg_renderSavedConfigsList_ExtraPage(); // Refresh the list
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Configuration "${displayName}" deleted.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
        }
    } catch (error) {
        console.error(`Error deleting configuration "${displayName}":`, error);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error deleting configuration: ${error.message}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
    }
}

function rsg_handleLoadSelectedConfig_ExtraPage(configKey) {
    const configData = rsg_loadedConfigs_extra[configKey];
    const loadStatusMsg = document.getElementById('rsg-load-status-message-extra');

    if (!configData) {
        if (loadStatusMsg) loadStatusMsg.textContent = "Error: Could not find configuration data for " + configKey;
        console.error("Could not find config data for key:", configKey);
        return;
    }

    rsgRouteNameInput_el_extra.value = configData.routeName || "";
    rsgDestinationNameInput_el_extra.value = configData.destinationName || "";
    
    // Set checkboxes based on the loaded operatingProfile string
    rsg_setCheckedProfiles_ExtraPage(configData.operatingProfile || "");

    rsg_selectedStops_extra = JSON.parse(JSON.stringify(configData.stopSequence || []));
    rsgFirstStopTimesInput_el_extra.value = configData.firstStopTimes || "";

    // Update last loaded state variables
    rsg_lastLoadedRouteName_extra = configData.routeName || "";
    rsg_lastLoadedDestName_extra = configData.destinationName || "";
    rsg_lastLoadedOpProfile_extra = configData.operatingProfile || "";

    rsg_renderStopSequence_ExtraPage();
    rsg_resetPreviewState(`Loaded configuration: "${configData.userDisplayName || configKey}". Generate preview if needed.`, "success");
    if (loadStatusMsg) loadStatusMsg.textContent = `Loaded: "${configData.userDisplayName || configKey}"`;

    // Manually trigger change events on route and destination selects to update dependent dropdowns
    rsgRouteNameInput_el_extra.dispatchEvent(new Event('blur')); // Or 'change' if blur doesn't trigger chained updates
    setTimeout(() => { // Allow route change to process before destination
         rsgDestinationNameInput_el_extra.dispatchEvent(new Event('blur'));
    },50);
}

function getDaySortOrder_ExtraPage(profile) {
    if (!profile) return 9999;
    const p = String(profile).toUpperCase().replace(/\s+/g, ''); 
    const has = (keywords) => keywords.some(kw => p.includes(kw));
    let baseScore = 9000;

    if (has(["MONDAY", "MO"])) baseScore = 100;
    else if (has(["TUESDAY", "TU"])) baseScore = 200;
    else if (has(["WEDNESDAY", "WE"])) baseScore = 300;
    else if (has(["THURSDAY", "TH"])) baseScore = 400;
    else if (has(["FRIDAY", "FR"]) && !p.includes("GOODFRIDAY")) baseScore = 500;
    else if (has(["MON-FRI", "MONTOFRI", "WEEKDAY", "MF"])) baseScore = 600; 
    else if (has(["SATURDAY", "SA"]) && !p.includes("GOODFRIDAY")) baseScore = 700; 
    else if (has(["SUNDAY", "SU"])) baseScore = 800;

    if (baseScore < 9000) { 
        if (has(["SCH"])) return baseScore + 1;    
        if (has(["NSD"])) return baseScore + 2;    
        return baseScore; 
    }
    // Specific holiday scores (ensure these match what's in RSG_OPERATING_PROFILES_LIST if they are standalone)
    if (has(["CHRISTMASDAY"])) return 9030; // Example scores
    if (has(["BOXINGDAY"])) return 9040;
    if (has(["NEWYEARSDAY"])) return 9050;
    // Removed GoodFriday, SchoolHoliday, BankHoliday, AllDays from here if they are no longer primary types

    if (String(profile).includes(',')) { // For sorting already combined strings if needed elsewhere
        const parts = String(profile).split(',');
        let minScoreForParts = 9999;
        for (const part of parts) {
            minScoreForParts = Math.min(minScoreForParts, getDaySortOrder_ExtraPage(part.trim())); 
        }
        return minScoreForParts;
    }
    return baseScore; 
}

function rsg_populateProfileCheckboxes_ExtraPage() {
    const container = document.getElementById('rsg-selectable-profiles-container-extra');
    const placeholder = document.getElementById('rsg-profiles-placeholder-extra');
    if (!container) {
        console.error("RSG Profile checkbox container not found!");
        return;
    }
    container.innerHTML = ''; 

    if (RSG_OPERATING_PROFILES_LIST.length === 0 && placeholder) {
        placeholder.textContent = "No profiles defined to display.";
        container.appendChild(placeholder);
        return;
    }

    RSG_OPERATING_PROFILES_LIST.forEach(profileValue => {
        const wrapper = document.createElement('div');
        wrapper.style.display = 'inline-flex'; 
        wrapper.style.alignItems = 'center';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        const safeProfileId = profileValue.replace(/[^a-zA-Z0-9_-]/g, '');
        checkbox.id = `rsg-profile-cb-${safeProfileId}-extra`;
        checkbox.value = profileValue;
        checkbox.name = 'rsgOperatingProfileCheckbox_extra';
        checkbox.classList.add('rsg-profile-checkbox'); 

        checkbox.addEventListener('change', rsg_handleProfileSelectionChange_ExtraPage);

        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.textContent = profileValue;
        label.style.marginLeft = "4px"; 
        label.style.cursor = "pointer";
        label.style.color = "#ecf0f1"; 

        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        container.appendChild(wrapper);
    });
    // DO NOT call rsg_handleProfileSelectionChange_ExtraPage or rsg_updateDisabledProfileCheckboxes_ExtraPage here.
    // The initial state will be set after the first call to rsg_loadOrPullConfiguration_ExtraPage from showExtraPageSection.
}

function populateTimetableExporterRouteSelect_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !currentWorkingSchedule_extra) {
        console.warn("Timetable Exporter: Route select element or schedule data not available.");
        return;
    }
    const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName).filter(Boolean))].sort(compareLineNames_ExtraPage);
    
    const currentInputValue = tteRouteNameInput_el_extra ? tteRouteNameInput_el_extra.value.trim() : "";
    
    tteRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Route --</option>';
    uniqueRoutes.forEach(route => {
        const opt = document.createElement('option');
        opt.value = route;
        opt.textContent = route;
        tteRouteNameSelect_el_extra.appendChild(opt);
    });

    if (currentInputValue) {
        const matchedOption = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
        tteRouteNameSelect_el_extra.value = matchedOption ? matchedOption : "";
    } else {
        tteRouteNameSelect_el_extra.value = "";
    }
}

// --- Helper Functions for PDF Timetable Generation ---

// Helper to convert HH:MM time string to absolute minutes from start of day
function getAbsMinutes(timeStr, dayOffset = 0) {
    // Check if timeStr is valid and in HH:MM format
    if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {
        // console.warn("getAbsMinutes: Invalid timeStr provided:", timeStr);
        return null; 
    }
    const parts = timeStr.split(':');
    if (parts.length !== 2) {
        // console.warn("getAbsMinutes: timeStr not in HH:MM format:", timeStr);
        return null;
    }

    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    
    // Ensure hours and minutes are valid numbers
    if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
        // console.warn("getAbsMinutes: Invalid hours or minutes in timeStr:", timeStr);
        return null;
    }

    // Ensure dayOffset is treated as a number, default to 0 if NaN or invalid
    const numericDayOffset = parseInt(dayOffset, 10);
    const validDayOffset = isNaN(numericDayOffset) ? 0 : numericDayOffset;
    
    return (validDayOffset * 1440) + (hours * 60) + minutes;
}

// ... (rest of your helper functions like formatTimeForDisplay, determineCanonicalStopSequence, analyzeAndSummarizeTimes) ...

// ... (and then your main handleDownloadTimetable_ExtraPage function) ...

async function handleDownloadTimetable_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !tteRouteNameInput_el_extra || !tteStatusMessage_el_extra) {
        console.warn("Timetable Exporter: Essential UI elements are missing for download.");
        if(tteStatusMessage_el_extra) {
             tteStatusMessage_el_extra.textContent = "Initialization error. Try refreshing.";
             tteStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const routeName = tteRouteNameInput_el_extra.value.trim() || tteRouteNameSelect_el_extra.value;

    if (!routeName) {
        tteStatusMessage_el_extra.textContent = "Please select or enter a route name.";
        tteStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    if (!currentUser_extra || typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined' || typeof window.jspdf.jsPDF.API.autoTable === 'undefined') {
        tteStatusMessage_el_extra.textContent = "Error: PDF library not ready or not logged in.";
        tteStatusMessage_el_extra.style.color = "#e74c3c";
        console.error("jsPDF or jsPDF-AutoTable not correctly loaded. window.jspdf:", window.jspdf);
        return;
    }

    tteStatusMessage_el_extra.textContent = `Processing PDF timetable for route: ${routeName}...`;
    tteStatusMessage_el_extra.style.color = "#3498db";

    try {
        const routeEntries = currentWorkingSchedule_extra.filter(e => e.lineName === routeName);
        if (routeEntries.length === 0) {
            tteStatusMessage_el_extra.textContent = `No schedule data found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'landscape',
            unit: 'pt',
            format: 'a4'
        });
        let isFirstTableInPDF = true;

        const uniqueProfileDestPairs = new Map();
        routeEntries.forEach(e => {
            if (e.OperatingProfile && e.destinationName) {
                uniqueProfileDestPairs.set(`${e.OperatingProfile}|${e.destinationName}`, true);
            }
        });

        if (uniqueProfileDestPairs.size === 0) {
            tteStatusMessage_el_extra.textContent = `No operating profile/destination combinations found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }
        
        const sortedPairs = Array.from(uniqueProfileDestPairs.keys()).sort((a,b) => {
            const [profA, destA] = a.split('|');
            const [profB, destB] = b.split('|');
            const profCompare = profA.localeCompare(profB);
            if (profCompare !== 0) return profCompare;
            return destA.localeCompare(destB);
        });

        let tablesAddedToPDF = 0;

        for (const pair of sortedPairs) {
            const [opProfile, destName] = pair.split('|');
            let specificEntries = routeEntries.filter(e =>
                e.OperatingProfile === opProfile && e.destinationName === destName
            );

            if (specificEntries.length === 0) continue;

            specificEntries.sort((a, b) => {
                const dayOffsetA = parseInt(a.DayOffset || 0);
                const dayOffsetB = parseInt(b.DayOffset || 0);
                if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
                const timeA = (a.scheduledTime || "99:99").replace(':', '');
                const timeB = (b.scheduledTime || "99:99").replace(':', '');
                return timeA.localeCompare(timeB);
            });

            const trips = segmentEntriesIntoTrips_forTimetable(specificEntries);
            if (trips.length === 0) continue;

            const stopOrderMap = new Map();
            let globalStopIndexForOrdering = 0;
            trips.forEach(trip => { // Use all trips to define the superset of stops in order
                trip.forEach(entry => {
                    if (!entry.stopID || !entry.scheduledTime) return;
                    const currentStopTimeAbsVal = (parseInt(entry.DayOffset || 0) * 1440) +
                                             parseInt(entry.scheduledTime.split(':')[0]) * 60 +
                                             parseInt(entry.scheduledTime.split(':')[1]);
                    if (!stopOrderMap.has(entry.stopID)) {
                        stopOrderMap.set(entry.stopID, {
                            stopID: entry.stopID, name: entry.stopName, direction: entry.direction,
                            earliestTimeAbs: currentStopTimeAbsVal, 
                            firstSeenIndex: globalStopIndexForOrdering++
                        });
                    }
                });
            });
            const canonicalStopSequence = Array.from(stopOrderMap.values()).sort((a,b) => a.firstSeenIndex - b.firstSeenIndex);

            if (canonicalStopSequence.length === 0) continue;

            const tableHead = [["Stop ID", "Stop Name", "Stop Aim"]];
            trips.forEach((trip, index) => {
                tableHead[0].push(trip[0] ? `${trip[0].scheduledTime}` : `Trip ${index + 1}`);
            });

            const tableBody = [];
            canonicalStopSequence.forEach(stopInfo => {
                const row = [stopInfo.stopID || "", stopInfo.name || "", stopInfo.direction || ""];
                trips.forEach(trip => {
                    const entryForStopInTrip = trip.find(e => e.stopID === stopInfo.stopID);
                    row.push(entryForStopInTrip ? entryForStopInTrip.scheduledTime : "-");
                });
                tableBody.push(row);
            });

            if (tableBody.length > 0) {
                if (!isFirstTableInPDF) {
                    doc.addPage('a4', 'landscape');
                }
                isFirstTableInPDF = false;

                doc.setFontSize(14);
                doc.text(`Route: ${routeName}`, 40, 40);
                doc.setFontSize(11);
                doc.text(`Direction: Towards ${destName}`, 40, 55); // Adjusted Y for spacing
                doc.text(`Operating Profile: ${opProfile}`, 40, 70); // Adjusted Y for spacing

                doc.autoTable({
                    head: tableHead,
                    body: tableBody,
                    startY: 85, // Adjusted startY
                    theme: 'grid',
                    styles: { fontSize: 6, cellPadding: 1.5, overflow: 'visible' }, // 'ellipsize' or 'visible' or 'linebreak'
                    headStyles: { fillColor: [44, 62, 80], textColor: 255, fontSize: 7, fontStyle: 'bold', halign: 'center' },
                    columnStyles: {
                        0: { cellWidth: 50, fontStyle: 'bold' }, 
                        1: { cellWidth: 120 },
                        2: { cellWidth: 100 },
                        // For time columns, you might let them auto-adjust or set a small fixed width if many
                    },
                    margin: { top: 25, right: 30, bottom: 30, left: 40 }, // Adjusted top margin
                    tableWidth: 'auto',
                });
                tablesAddedToPDF++;
            }
        }

        if (tablesAddedToPDF > 0) {
            doc.save(`${sanitizeFirebaseKey(routeName)}_Timetable.pdf`);
            tteStatusMessage_el_extra.textContent = `Timetable PDF for ${routeName} generated successfully!`;
            tteStatusMessage_el_extra.style.color = "#2ecc71";
        } else {
            tteStatusMessage_el_extra.textContent = `No valid trip data found to generate PDF for route ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
        }

    } catch (error) {
        console.error("Error generating PDF timetable:", error);
        tteStatusMessage_el_extra.textContent = "Error generating PDF: " + error.message;
        tteStatusMessage_el_extra.style.color = "#e74c3c";
    }
}

// --- Helper function to segment entries into individual trips for PDF Timetable ---
// --- Helper function to segment entries into individual trips for PDF Timetable ---
// --- Helper function to segment entries into individual trips for PDF Timetable ---
// --- Helper function to segment entries into individual trips for PDF Timetable ---
function segmentEntriesIntoTrips_forTimetable(profileDestEntries, minStopsPerTripHeuristic = 1) { // <-- SET TO 200
    const allTrips = [];
    if (!profileDestEntries || profileDestEntries.length === 0) {
        return allTrips;
    }

    profileDestEntries.sort((a, b) => {
        const dayOffsetA = parseInt(a.DayOffset || 0);
        const dayOffsetB = parseInt(b.DayOffset || 0);
        if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
        const timeA = (a.scheduledTime || "99:99").replace(':', '');
        const timeB = (b.scheduledTime || "99:99").replace(':', '');
        return timeA.localeCompare(timeB);
    });

    let currentTrip = [];
    let previousStopTimeInAbsoluteMinutes = -1;
    let firstStopTimeOfCurrentLogicalTrip = -1;

    const rpdContext = profileDestEntries.length > 0 ? `(Route: ${profileDestEntries[0].lineName}, Profile: ${profileDestEntries[0].OperatingProfile}, Dest: ${profileDestEntries[0].destinationName})` : "";

    for (let i = 0; i < profileDestEntries.length; i++) {
        const entry = profileDestEntries[i];
        if (!entry.stopID || !entry.scheduledTime) continue;

        const currentStopTimeInAbsoluteMinutes =
            (parseInt(entry.DayOffset || 0) * 1440) +
            parseInt(entry.scheduledTime.split(':')[0]) * 60 +
            parseInt(entry.scheduledTime.split(':')[1]);

        if (currentTrip.length === 0) { 
            firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes;
        }
        
        if (currentTrip.length > 0) {
            // Condition 1: Time goes backward
            if (currentStopTimeInAbsoluteMinutes < previousStopTimeInAbsoluteMinutes) {
                console.log(`TRIP SPLIT (Time Regression) ${rpdContext}: Prev Stop ${currentTrip[currentTrip.length-1].stopID} (${currentTrip[currentTrip.length-1].scheduledTime} Day ${currentTrip[currentTrip.length-1].DayOffset || 0} / Abs: ${previousStopTimeInAbsoluteMinutes}), Curr Stop ${entry.stopID} (${entry.scheduledTime} Day ${entry.DayOffset || 0} / Abs: ${currentStopTimeInAbsoluteMinutes})`);
                allTrips.push([...currentTrip]); 
                currentTrip = []; 
                firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes; 
            } 
            // Condition 2: The STARTING STOP OF THE CURRENT TRIP is seen again
            // This condition is now very unlikely to be met with minStopsPerTripHeuristic = 9000
            else if (entry.stopID === currentTrip[0].stopID && 
                     currentTrip.length >= minStopsPerTripHeuristic && 
                     currentStopTimeInAbsoluteMinutes !== firstStopTimeOfCurrentLogicalTrip
                    ) {
                console.log(`TRIP SPLIT (Current Trip Start Stop Repeat) ${rpdContext}: Curr Stop ${entry.stopID} at ${entry.scheduledTime} (Abs: ${currentStopTimeInAbsoluteMinutes}), CurrentTripStartStopID: ${currentTrip[0].stopID}, TripLength: ${currentTrip.length}, minHeuristic: ${minStopsPerTripHeuristic}, FirstTimeOfCurrentTrip: ${firstStopTimeOfCurrentLogicalTrip}`);
                allTrips.push([...currentTrip]); 
                currentTrip = []; 
                firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes; 
            }
        }
        
        currentTrip.push(entry);
        previousStopTimeInAbsoluteMinutes = currentStopTimeInAbsoluteMinutes;
    }

    if (currentTrip.length > 0) {
        allTrips.push([...currentTrip]);
    }
    return allTrips;
}

// Helper to format a single time object for display
function formatTimeForDisplay(timeObject) {
    // timeObject = { absMinutes, displayTime, dayOffset }
    return timeObject.displayTime; 
}

function determineCanonicalStopSequence(specificEntriesForRPD) {
    const stopData = new Map(); // stopID -> { stopID, name, earliestAbsMinutes, firstSeenOriginalIndex }

    // The specificEntriesForRPD should already be sorted chronologically 
    // by the time this function is called in handleDownloadTimetable_ExtraPage
    specificEntriesForRPD.forEach((entry, index) => {
        if (entry.stopID && entry.scheduledTime) {
            const absMinutes = getAbsMinutes(entry.scheduledTime, parseInt(entry.DayOffset || 0));
            if (absMinutes === null) return;

            if (!stopData.has(entry.stopID)) {
                stopData.set(entry.stopID, {
                    stopID: entry.stopID,
                    name: entry.stopName,
                    earliestAbsMinutes: absMinutes, // Store the time of its first actual encountered entry
                    firstSeenOriginalIndex: index  // Store the index from the master sorted list
                });
            }
            // If you wanted to update earliestAbsMinutes for a stop if it appeared later with an even earlier time
            // (which shouldn't happen if specificEntriesForRPD is perfectly sorted), you could add logic here.
            // For now, we assume the first encounter sets its primary ordering criteria.
        }
    });

    return Array.from(stopData.values()).sort((a, b) => {
        if (a.firstSeenOriginalIndex !== b.firstSeenOriginalIndex) {
            return a.firstSeenOriginalIndex - b.firstSeenOriginalIndex;
        }
        return a.earliestAbsMinutes - b.earliestAbsMinutes; // Fallback sort
    });
}

function analyzeAndSummarizeTimes(sortedTimes) { // sortedTimes is array of { absMinutes, displayTime, dayOffset }
    // Define constants used within this function
    const MAX_INITIAL_INDIVIDUAL_TIMES = 2; 
    const MIN_TIMES_FOR_PATTERN_BLOCK = 4;  
    const MIN_INTERVALS_FOR_PATTERN = MIN_TIMES_FOR_PATTERN_BLOCK - 1;

    const n = sortedTimes.length;
    if (n === 0) return "-";

    if (n < MIN_TIMES_FOR_PATTERN_BLOCK) { 
        return sortedTimes.map(t => formatTimeForDisplay(t)).join(", ");
    }

    let resultParts = [];
    let currentIndex = 0;

    while (currentIndex < n) {
        let bestRun = {
            startIdx: -1, numIntervals: 0, interval: 0, 
            startTimeObj: null, endTimeObj: null
        };

        // Determine the limit for starting a pattern search.
        // We look for a pattern starting at currentIndex, or up to MAX_INITIAL_INDIVIDUAL_TIMES beyond it.
        // Ensure we don't search beyond where a minimal pattern could form.
        let searchStartLimit = Math.min(currentIndex + MAX_INITIAL_INDIVIDUAL_TIMES, n - MIN_INTERVALS_FOR_PATTERN);
        // If currentIndex itself is already very close to the end, adjust searchStartLimit to at least allow one check from currentIndex
        if (searchStartLimit <= currentIndex && currentIndex <= n - MIN_TIMES_FOR_PATTERN_BLOCK ) { 
            searchStartLimit = currentIndex + 1; 
        }


        for (let i = currentIndex; i < searchStartLimit; i++) {
            // Ensure there are enough elements from 'i' to form at least MIN_INTERVALS_FOR_PATTERN
            if (i + MIN_INTERVALS_FOR_PATTERN >= n) break; 

            const t1Abs = sortedTimes[i].absMinutes;
            const t2Abs = sortedTimes[i + 1].absMinutes;

            if (t1Abs === null || t2Abs === null) continue;
            let currentRunInterval = t2Abs - t1Abs;

            // Ignore intervals that are non-positive or too large for typical summaries
            if (currentRunInterval <= 0 || currentRunInterval >= 90) continue; 

            let currentRunNumIntervals = 1; // We found one interval (between sortedTimes[i] and sortedTimes[i+1])
            // Now count how many more *consecutive* intervals match currentRunInterval
            for (let k = i + 1; k < n - 1; k++) { // k is the index of the start of the next interval
                const tkAbs = sortedTimes[k].absMinutes;
                const tk1Abs = sortedTimes[k + 1].absMinutes;
                if (tkAbs === null || tk1Abs === null) break; 

                if ((tk1Abs - tkAbs) === currentRunInterval) {
                    currentRunNumIntervals++;
                } else {
                    break; 
                }
            }

            if (currentRunNumIntervals >= MIN_INTERVALS_FOR_PATTERN) {
                // Found a valid run of intervals. Check if it's better than any previously found bestRun.
                if (currentRunNumIntervals > bestRun.numIntervals || 
                    (currentRunNumIntervals === bestRun.numIntervals && i < bestRun.startIdx) || 
                    bestRun.startIdx === -1) { // Prioritize longer runs, or earlier starting runs of same length
                    bestRun = {
                        startIdx: i, // Index in sortedTimes of the first time in this pattern
                        endIdx: i + currentRunNumIntervals, // Index in sortedTimes of the last time in this pattern
                        interval: currentRunInterval,
                        numIntervals: currentRunNumIntervals, // Number of matching intervals
                        startTimeObj: sortedTimes[i],
                        endTimeObj: sortedTimes[i + currentRunNumIntervals]
                    };
                }
            }
        } 

        if (bestRun.startIdx !== -1 && bestRun.startIdx >= currentIndex) { 
            // A frequency pattern was found starting at or after currentIndex.
            // 1. Add any individual times from currentIndex UP TO the start of the identified pattern block
            for (let j = currentIndex; j < bestRun.startIdx; j++) {
                resultParts.push(formatTimeForDisplay(sortedTimes[j]));
            }

            // 2. Add the actual start time of the frequency block
            const formattedRunStartTime = formatTimeForDisplay(bestRun.startTimeObj);
            resultParts.push(formattedRunStartTime);
            
            // 3. Construct the core summary phrase (without "then" and without "from [start time]")
            let summaryCorePhrase = "";
            const formattedRunEndTime = formatTimeForDisplay(bestRun.endTimeObj);

            if (bestRun.interval < 15) {
                summaryCorePhrase = `every ${bestRun.interval} mins until ${formattedRunEndTime}`;
            } else { // Interval is 15 minutes or more
                const minutesPastHourSet = new Set();
                for (let k = bestRun.startIdx; k <= bestRun.endIdx; k++) { // Iterate through times in the actual run
                    if (sortedTimes[k].displayTime.includes(':')) {
                        minutesPastHourSet.add(sortedTimes[k].displayTime.substring(3, 5));
                    }
                }
                if (minutesPastHourSet.size >= 1 && minutesPastHourSet.size <= 4 && (bestRun.interval % 5 === 0)) {
                    let numericallySortedMinutes = Array.from(minutesPastHourSet).sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
                    
                    const startMinuteOfBlock = bestRun.startTimeObj.displayTime.substring(3,5);
                    if (numericallySortedMinutes.length > 1 && numericallySortedMinutes[0] === startMinuteOfBlock) {
                        const firstMin = numericallySortedMinutes.shift(); 
                        numericallySortedMinutes.push(firstMin);      
                    }
                    const displayMinutes = numericallySortedMinutes.join(', ');                                        
                    summaryCorePhrase = `at these mins past each hour: ${displayMinutes} until ${formattedRunEndTime}`;
                } else { 
                    summaryCorePhrase = `approx. every ${bestRun.interval} mins until ${formattedRunEndTime}`;
                }
            }
            resultParts.push("then " + summaryCorePhrase); // Add "then" before the core summary
            currentIndex = bestRun.endIdx + 1; // Advance currentIndex past this summarized block
        } else { // No suitable frequency block found from currentIndex, or remaining times are too few.
            if (currentIndex < n) {
                 resultParts.push(formatTimeForDisplay(sortedTimes[currentIndex]));
                 currentIndex++;
            } else { 
                break; // End of times
            }
        }
    } 

    // Final joining logic
    if (resultParts.length === 0) return "-";
    let finalStr = resultParts[0] || "";
    for (let i = 1; i < resultParts.length; i++) {
        const prevPartStr = resultParts[i-1] || "";
        const currentPartStr = resultParts[i] || "";
        
        if (currentPartStr.startsWith("then") && !prevPartStr.startsWith("then")) {
            // Previous was a time, current is its summary: "TIME then SUMMARY"
            finalStr += " " + currentPartStr; 
        } else {
            // All other cases (summary; summary, summary; time, time; time if it's a new segment after summary)
            finalStr += "; " + currentPartStr;
        }
    }
    return finalStr || "-";
}

async function handleDownloadTimetable_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !tteRouteNameInput_el_extra || !tteStatusMessage_el_extra) {
        console.warn("Timetable Exporter: Essential UI elements missing.");
        if(tteStatusMessage_el_extra) { tteStatusMessage_el_extra.textContent = "Init error."; tteStatusMessage_el_extra.style.color = "#e74c3c"; }
        return;
    }

    const routeName = tteRouteNameInput_el_extra.value.trim() || tteRouteNameSelect_el_extra.value;
    if (!routeName) {
        tteStatusMessage_el_extra.textContent = "Please select a route.";
        tteStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    if (!currentUser_extra || typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined' || typeof window.jspdf.jsPDF.API.autoTable === 'undefined') {
        tteStatusMessage_el_extra.textContent = "Error: PDF library not ready or not logged in.";
        tteStatusMessage_el_extra.style.color = "#e74c3c";
        return;
    }

    tteStatusMessage_el_extra.textContent = `Processing PDF timetable for route: ${routeName}...`;
    tteStatusMessage_el_extra.style.color = "#3498db";

    try {
        const routeEntries = currentWorkingSchedule_extra.filter(e => e.lineName === routeName);
        if (routeEntries.length === 0) {
            tteStatusMessage_el_extra.textContent = `No schedule data found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'portrait', 
            unit: 'pt',
            format: 'a4'
        });
        let isFirstTableInPDF = true;

        const uniqueProfileDestPairs = new Map();
        routeEntries.forEach(e => {
            if (e.OperatingProfile && e.destinationName) {
                uniqueProfileDestPairs.set(`${e.OperatingProfile}|${e.destinationName}`, true);
            }
        });

        if (uniqueProfileDestPairs.size === 0) {
            tteStatusMessage_el_extra.textContent = `No operating profile/destination combinations found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }
        
        const sortedPairs = Array.from(uniqueProfileDestPairs.keys()).sort((a,b) => {
            const [profA, destA] = a.split('|');
            const [profB, destB] = b.split('|');
            const profCompare = profA.localeCompare(profB);
            if (profCompare !== 0) return profCompare;
            return destA.localeCompare(destB);
        });

        let tablesAddedToPDF = 0;

        for (const pair of sortedPairs) {
            const [opProfile, destName] = pair.split('|');
            
            const specificEntriesForRPD = routeEntries
                .filter(e => e.OperatingProfile === opProfile && e.destinationName === destName && e.scheduledTime)
                .sort((a,b) => { 
                    const absA = getAbsMinutes(a.scheduledTime, parseInt(a.DayOffset || 0));
                    const absB = getAbsMinutes(b.scheduledTime, parseInt(b.DayOffset || 0));
                    if (absA === null && absB === null) return 0;
                    if (absA === null) return 1;
                    if (absB === null) return -1;
                    return absA - absB;
                });

            if (specificEntriesForRPD.length === 0) continue;

            const canonicalStopSequence = determineCanonicalStopSequence(specificEntriesForRPD);
            if (canonicalStopSequence.length === 0) continue;

            const tableHead = [["Stop ID", "Stop Name", "Scheduled Times"]];
            const tableBody = [];

            canonicalStopSequence.forEach(stopInfo => {
                const allTimesAtThisStop = specificEntriesForRPD
                    .filter(e => e.stopID === stopInfo.stopID) 
                    .map(e => ({ 
                        absMinutes: getAbsMinutes(e.scheduledTime, parseInt(e.DayOffset || 0)),
                        displayTime: e.scheduledTime,
                        dayOffset: parseInt(e.DayOffset || 0)
                    }));
                // This map preserves the pre-sorted order of times for this stop from specificEntriesForRPD

                const serviceDetailString = analyzeAndSummarizeTimes(allTimesAtThisStop);
                
                tableBody.push([
                    stopInfo.stopID || "",
                    stopInfo.name || "",
                    serviceDetailString
                ]);
            });

            if (tableBody.length > 0) {
                if (!isFirstTableInPDF) {
                    doc.addPage('a4', 'portrait');
                }
                isFirstTableInPDF = false;

                doc.setFontSize(14);
                doc.text(`Route: ${routeName}`, 40, 40); 
                doc.setFontSize(11);
                doc.text(`Destination: ${destName}`, 40, 55); 
                doc.text(`Operating Profile: ${opProfile}`, 40, 70);

                doc.autoTable({
                    head: tableHead,
                    body: tableBody,
                    startY: 85,
                    theme: 'grid',
                    styles: { 
                        fontSize: 7, 
                        cellPadding: 2,
                        overflow: 'linebreak' 
                    }, 
                    headStyles: { 
                        fillColor: [44, 62, 80], 
                        textColor: 255, 
                        fontSize: 8,       
                        fontStyle: 'bold', 
                        halign: 'left' 
                    },
                    columnStyles: {
                        0: { cellWidth: 55, fontStyle: 'bold' }, 
                        1: { cellWidth: 130 }, 
                        2: { cellWidth: 'auto' } 
                    },
                    margin: { top: 25, right: 30, bottom: 30, left: 40 },
                });
                tablesAddedToPDF++;
            }
        }

        if (tablesAddedToPDF > 0) {
            doc.save(`${sanitizeFirebaseKey(routeName)}_Timetable_Summary.pdf`);
            tteStatusMessage_el_extra.textContent = `Summarized Timetable PDF for ${routeName} generated successfully!`;
            tteStatusMessage_el_extra.style.color = "#2ecc71";
        } else {
            tteStatusMessage_el_extra.textContent = `No valid data to generate summarized PDF for ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
        }

    } catch (error) {
        console.error("Error generating summarized PDF timetable:", error);
        tteStatusMessage_el_extra.textContent = "Error generating summarized PDF: " + error.message;
        tteStatusMessage_el_extra.style.color = "#e74c3c";
    }
}

function rsg_getSelectedOpProfilesString_ExtraPage() {
    const selectedProfiles = [];
    document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox:checked').forEach(checkbox => {
        selectedProfiles.push(checkbox.value);
    });
    // Sorts alphabetically, e.g., ["Fr", "MF", "Sa"]
    selectedProfiles.sort((a,b) => a.localeCompare(b)); 
    
    // Joins with a comma AND a space
    return selectedProfiles.join(', '); // Changed from .join(',')
}

function rsg_updateDisabledProfileCheckboxes_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));
    const currentSelectedValues = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

    allCheckboxes.forEach(cb => {
        if (cb.checked) {
            cb.disabled = false;
            if (cb.parentElement) {
                cb.parentElement.style.opacity = 1;
                cb.parentElement.style.pointerEvents = 'auto';
                const labelForCb = cb.parentElement.querySelector('label');
                if (labelForCb) labelForCb.style.cursor = 'pointer';
            }
            return;
        }

        const potentialNextRawSelection = [...currentSelectedValues, cb.value];
        const finalEffectiveSelectionAfterAutoGroup = rsg_simulateAutoGroup(potentialNextRawSelection);
        const finalEffectiveSortedString = rsg_getCanonicalProfileString(finalEffectiveSelectionAfterAutoGroup);

        let canBeEnabled = false;

        if (VALID_PROFILE_COMBINATIONS_SET.has(finalEffectiveSortedString)) {
            canBeEnabled = true;
        }

        if (!canBeEnabled) {
            const prefixToTest = finalEffectiveSortedString + ",";
            for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                if (validCombo.startsWith(prefixToTest)) {
                    canBeEnabled = true;
                    break;
                }
            }
        }

        if (currentSelectedValues.length === 0) {
             const singleProfileItselfAfterPotentialGroup = rsg_simulateAutoGroup([cb.value]);
             const singleCanonical = rsg_getCanonicalProfileString(singleProfileItselfAfterPotentialGroup);
             if (VALID_PROFILE_COMBINATIONS_SET.has(singleCanonical)) {
                 canBeEnabled = true;
             } else {
                 const prefixToTestForSingle = singleCanonical + ",";
                 for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                     if (validCombo.startsWith(prefixToTestForSingle)) {
                         canBeEnabled = true;
                         break;
                     }
                 }
             }
        }

        cb.disabled = !canBeEnabled;
        if (cb.parentElement) {
            cb.parentElement.style.opacity = !canBeEnabled ? 0.5 : 1;
            cb.parentElement.style.pointerEvents = !canBeEnabled ? 'none' : 'auto';
            const labelForCb = cb.parentElement.querySelector('label');
            if (labelForCb) {
                labelForCb.style.cursor = !canBeEnabled ? 'not-allowed' : 'pointer';
            }
        }
    });
}

function rsg_simulateAutoGroup(selectedProfilesArray) {
    let simulatedSelections = [...selectedProfilesArray]; 

    for (const group of RSG_PROFILE_GROUPS_TO_MANAGE) {
        const allIndividualsPresent = group.individuals.every(ind => simulatedSelections.includes(ind));

        if (allIndividualsPresent) {
            simulatedSelections = simulatedSelections.filter(p => !group.individuals.includes(p)); 
            if (!simulatedSelections.includes(group.groupProfile)) {
                simulatedSelections.push(group.groupProfile); 
            }
        }
    }
    return simulatedSelections;
}

function rsg_handleProfileSelectionChange_ExtraPage(event) {
    let currentSelectionsArray = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox:checked')).map(cb => cb.value);
    let selectionChangedByAutoGroup = false;

    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));

    // Use RSG_PROFILE_GROUPS_TO_MANAGE which should be globally defined
    RSG_PROFILE_GROUPS_TO_MANAGE.forEach(group => {
        const groupCheckbox = allCheckboxes.find(cb => cb.value === group.groupProfile);
        if (!groupCheckbox) return; 

        // Re-fetch currentSelectionsArray in case a previous group changed it
        currentSelectionsArray = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);
        const allIndividualsInGroupSelected = group.individuals.every(day => currentSelectionsArray.includes(day));

        if (allIndividualsInGroupSelected) {
            if (!groupCheckbox.checked) {
                group.individuals.forEach(day => {
                    const cb = allCheckboxes.find(c => c.value === day);
                    if (cb && cb.checked) { cb.checked = false; }
                });
                groupCheckbox.checked = true;
                selectionChangedByAutoGroup = true;
            }
        } else if (groupCheckbox.checked) {
            // If group is checked, ensure its individuals are unchecked.
            let anIndividualWasAlsoCheckedAndUnchecked = false;
            group.individuals.forEach(day => {
                const cb = allCheckboxes.find(c => c.value === day);
                if (cb && cb.checked) {
                    cb.checked = false;
                    anIndividualWasAlsoCheckedAndUnchecked = true;
                }
            });
            if (anIndividualWasAlsoCheckedAndUnchecked) selectionChangedByAutoGroup = true;
        }
    });

    if (selectionChangedByAutoGroup) {
        currentSelectionsArray = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox:checked')).map(cb => cb.value);
    }

    currentSelectionsArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a);
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) {
            return orderA - orderB;
        }
        return a.localeCompare(b); 
    });

    const finalSelectedProfilesString = currentSelectionsArray.join(', '); 

    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }

    rsg_updateDisabledProfileCheckboxes_ExtraPage(); 

    if (event || selectionChangedByAutoGroup) {
        if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') {
             rsg_loadOrPullConfiguration_ExtraPage();
        }
    }
}

function rsg_setCheckedProfiles_ExtraPage(profileString) {
    // Determine which profiles to select based on the input string
    const profilesToSelect = profileString ? profileString.split(',').map(p => p.trim()).filter(Boolean) : [];

    // Get all profile checkboxes
    const allProfileCheckboxes = document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox');

    // Set the checked state for each checkbox
    allProfileCheckboxes.forEach(checkbox => {
        checkbox.checked = profilesToSelect.includes(checkbox.value);
    });

    // --- MODIFICATION START ---
    // After programmatically setting checkbox states,
    // directly update the "Currently Selected & Active" display string.

    // Use the 'profilesToSelect' array as the source of truth for what should be displayed,
    // as this is what the checkboxes were just set to.
    // Create a mutable copy if further manipulation of this array specific to display is needed,
    // otherwise, direct use is fine for sorting and joining.
    const currentDisplayProfilesArray = [...profilesToSelect];

    // Sort them for consistent display order using your existing sorting logic
    currentDisplayProfilesArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a); // Ensure getDaySortOrder_ExtraPage is robust
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) {
            return orderA - orderB;
        }
        return a.localeCompare(b); // Default alphabetical sort if order is the same
    });

    // Join the sorted profiles into a string for display
    const finalSelectedProfilesString = currentDisplayProfilesArray.join(', ');

    // Get the display element
    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');

    // Update the text content of the display element
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }
    // --- MODIFICATION END ---

    // This function correctly updates which checkboxes are enabled/disabled
    // based on your incompatibility rules and the newly set checkbox states.
    // This should always be called after checkbox states are modified.
    if (typeof rsg_updateDisabledProfileCheckboxes_ExtraPage === 'function') {
        rsg_updateDisabledProfileCheckboxes_ExtraPage();
    }
}

function rsg_clearProfileSelections_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));
    let selectionActuallyChanged = false;

    allCheckboxes.forEach(cb => {
        if (cb.checked) {
            cb.checked = false;
            selectionActuallyChanged = true;
        }
    });

    // Update the display string to show none selected
    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = '(None selected)';
    }

    // Update the enabled/disabled state of all checkboxes
    // After clearing, most (if not all) should become enabled depending on VALID_PROFILE_COMBINATIONS_SET
    if (typeof rsg_updateDisabledProfileCheckboxes_ExtraPage === 'function') {
        rsg_updateDisabledProfileCheckboxes_ExtraPage();
    }

    // Now that selections are cleared (empty string),
    // trigger the configuration load/pull logic.
    // This will typically try to load defaults or an empty state.
    if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') {
        rsg_loadOrPullConfiguration_ExtraPage();
    }
}

        function rsg_createConfigKey_ExtraPage(routeName, opProfile, destName) { if (!routeName || !opProfile || !destName) return null; const normRoute = sanitizeFirebaseKey(String(routeName).toUpperCase()); const normProfile = sanitizeFirebaseKey(String(opProfile).toUpperCase()); const normDest = sanitizeFirebaseKey(String(destName).toUpperCase()); return `${normRoute}|${normProfile}|${normDest}`; } 

        async function rsg_loadOrPullConfiguration_ExtraPage() {
    if (!rsgRouteNameInput_el_extra || !rsgDestinationNameInput_el_extra || !rsgFirstStopTimesInput_el_extra || !rsgStatusMessage_el_extra || !window.firebaseOMSI) {
        return;
    }

    const routeNameFromInput = rsgRouteNameInput_el_extra.value.trim();
    const currentSelectedOpProfilesInUI = rsg_getSelectedOpProfilesString_ExtraPage();
    const destNameFromInput = rsgDestinationNameInput_el_extra.value.trim();
    let hasRouteOrDestChanged = (routeNameFromInput.toUpperCase() !== (rsg_lastLoadedRouteName_extra || "").toUpperCase() || destNameFromInput !== (rsg_lastLoadedDestName_extra || ""));

    if (hasRouteOrDestChanged) {
        rsg_selectedStops_extra = [];
        if (rsgFirstStopTimesInput_el_extra) rsgFirstStopTimesInput_el_extra.value = '';
        // When route/dest changes, we don't clear user-ticked checkboxes.
        // We also don't clear rsg_lastLoadedOpProfile_extra yet, as it might be from an explicitly loaded config.
    }

    rsg_lastLoadedRouteName_extra = routeNameFromInput; // Keep track of current form state
    rsg_lastLoadedDestName_extra = destNameFromInput;

    rsg_generatedPreviewEntries_extra = [];
    rsg_renderPreviewTable_ExtraPage();
    if (rsgAddToWorkingScheduleButton_el_extra) rsgAddToWorkingScheduleButton_el_extra.style.display = 'none';
    if (rsgSchedulePreviewContainer_el_extra && rsg_generatedPreviewEntries_extra.length === 0) {
        rsgSchedulePreviewContainer_el_extra.style.display = 'none';
    }
    // Always render the current state of rsg_selectedStops_extra
    rsg_renderStopSequence_ExtraPage();

    if (!routeNameFromInput || !destNameFromInput) {
        rsgStatusMessage_el_extra.textContent = "Route Name and Destination Name are required to pull live data or generate a schedule.";
        return;
    }

    // If user has profiles selected via checkboxes, we assume they are building/editing.
    // We will not auto-load a saved config based on these inputs anymore.
    // However, if no checkboxes are selected, we can try to pull live data using a default profile.
    if (!currentSelectedOpProfilesInUI) {
        rsgStatusMessage_el_extra.textContent = `Operating Profile checkboxes blank. Trying default profiles to pull live data for <span class="math-inline">\{routeNameFromInput\}/</span>{destNameFromInput}...`;
        let profileToPullWith = "";
        const defaultProfilesToTry = RSG_OPERATING_PROFILES_LIST; // Or a more specific preferred list

        for (const prefProfile of defaultProfilesToTry) {
            const hasLiveEntries = currentWorkingSchedule_extra.some(entry =>
                entry.lineName && entry.lineName.toUpperCase() === routeNameFromInput.toUpperCase() &&
                entry.destinationName === destNameFromInput &&
                entry.OperatingProfile === prefProfile
            );
            if (hasLiveEntries) {
                profileToPullWith = prefProfile;
                break;
            }
        }

        if (profileToPullWith) {
            // Attempt to pull live data using profileToPullWith
            // (The logic for pulling live data based on a profile, deriving sequence and times)
            // This part is complex and was in your original function. For this focused change,
            // I'm indicating where it should go. If successful, update rsg_selectedStops_extra, etc.
            // and then set rsg_lastLoadedOpProfile_extra = profileToPullWith;
            // and update status message.
            // For now, just a placeholder:
            console.log(`Attempting to pull live data with assumed profile: ${profileToPullWith}`);
            // ... (Your existing live data pull logic using profileToPullWith) ...
            // If successful:
            // rsg_selectedStops_extra = derivedSequence;
            // rsgFirstStopTimesInput_el_extra.value = derivedTimes;
            // rsg_lastLoadedOpProfile_extra = profileToPullWith; // Store this as the context for the pulled data
            // rsgStatusMessage_el_extra.textContent = `Pulled live data using assumed profile: ${profileToPullWith}.`;
            // rsg_renderStopSequence_ExtraPage();
            // rsg_setCheckedProfiles_ExtraPage(profileToPullWith); // Optionally reflect the assumed profile in checkboxes
        } else {
            rsgStatusMessage_el_extra.textContent = `No profile selected & no default live data found for <span class="math-inline">\{routeNameFromInput\}/</span>{destNameFromInput}.`;
            if(hasRouteOrDestChanged) { // If route/dest changed and no default found, clear sequence
                rsg_selectedStops_extra = [];
                rsgFirstStopTimesInput_el_extra.value = '';
                rsg_renderStopSequence_ExtraPage();
            }
        }
    } else {
        // User has profiles selected. We don't auto-load.
        // The rsg_lastLoadedOpProfile_extra is updated only when they explicitly load a saved config.
        // Or when they save a new one.
        rsgStatusMessage_el_extra.textContent = "Ready to define stop sequence or generate preview with selected profiles.";
        rsg_lastLoadedOpProfile_extra = currentSelectedOpProfilesInUI; // Reflect current UI state for potential save/generate
    }
}

async function rsg_loadOrPullConfiguration_ExtraPage() {
    if (!rsgRouteNameInput_el_extra || !rsgDestinationNameInput_el_extra || !rsgFirstStopTimesInput_el_extra || !rsgStatusMessage_el_extra || !window.firebaseOMSI) {
        console.warn("RSG Load/Pull: Required element or Firebase missing.");
        return;
    }

    const routeNameFromInput = rsgRouteNameInput_el_extra.value.trim();
    const opProfileFromInput = rsg_getSelectedOpProfilesString_ExtraPage(); // MODIFIED: Get from checkboxes
    const destNameFromInput = rsgDestinationNameInput_el_extra.value.trim();

    let hasRouteOrDestChanged = (routeNameFromInput.toUpperCase() !== (rsg_lastLoadedRouteName_extra || "").toUpperCase() || destNameFromInput !== (rsg_lastLoadedDestName_extra || ""));

    if (hasRouteOrDestChanged) {
        rsg_selectedStops_extra = [];
        if (rsgFirstStopTimesInput_el_extra) rsgFirstStopTimesInput_el_extra.value = '';
        rsg_lastLoadedRouteName_extra = null;
        rsg_lastLoadedDestName_extra = null;
        rsg_lastLoadedOpProfile_extra = null; // Clear last loaded profile if route/dest changed
    }

    rsg_generatedPreviewEntries_extra = [];
    rsg_renderPreviewTable_ExtraPage();
    if (rsgAddToWorkingScheduleButton_el_extra) rsgAddToWorkingScheduleButton_el_extra.style.display = 'none';
    if (rsgSchedulePreviewContainer_el_extra && rsg_generatedPreviewEntries_extra.length === 0) {
        rsgSchedulePreviewContainer_el_extra.style.display = 'none';
    }
    rsg_renderStopSequence_ExtraPage(); // Render sequence early, may show empty or old if route/dest changed

    if (!routeNameFromInput || !destNameFromInput) {
        rsgStatusMessage_el_extra.textContent = "Route Name and Destination Name are required to load or pull configuration.";
        rsgStatusMessage_el_extra.style.color = ""; // Neutral color
        // If route/dest changed and now one is blank, we already cleared selections.
        // If opProfileFromInput is also blank now, ensure checkboxes are cleared.
        if (!opProfileFromInput) {
            rsg_setCheckedProfiles_ExtraPage(""); // Clear checkboxes
        }
        return;
    }

    let profileToAttemptLoad = opProfileFromInput;
    let isUsingAssumedProfile = false;
    const preferredDefaultProfiles = RSG_OPERATING_PROFILES_LIST; // Use the same list as checkboxes for trying defaults

    if (!opProfileFromInput) { // True if no checkboxes are selected
        isUsingAssumedProfile = true;
        // Try to find a default only if route/dest hasn't just changed to an incomplete state
        // or if the last loaded profile doesn't match the current blank state.
        if (hasRouteOrDestChanged || !rsg_lastLoadedOpProfile_extra || rsg_lastLoadedOpProfile_extra === "") {
            rsgStatusMessage_el_extra.textContent = `Operating Profile blank. Trying default profiles for ${routeNameFromInput}/${destNameFromInput}...`;
            profileToAttemptLoad = ""; // Reset before searching
            for (const prefProfile of preferredDefaultProfiles) {
                const tempConfigKey = rsg_createConfigKey_ExtraPage(routeNameFromInput, prefProfile, destNameFromInput);
                if (rsg_loadedConfigs_extra[tempConfigKey]) {
                    profileToAttemptLoad = prefProfile;
                    break;
                }
            }
            if (!profileToAttemptLoad) { // If no saved config with preferred profiles, check live data
                for (const prefProfile of preferredDefaultProfiles) {
                    const hasLiveEntries = currentWorkingSchedule_extra.some(entry =>
                        entry.lineName && entry.lineName.toUpperCase() === routeNameFromInput.toUpperCase() &&
                        entry.destinationName === destNameFromInput &&
                        entry.OperatingProfile === prefProfile
                    );
                    if (hasLiveEntries) {
                        profileToAttemptLoad = prefProfile;
                        break;
                    }
                }
            }

            if (!profileToAttemptLoad) {
                rsgStatusMessage_el_extra.textContent = `Op Profile blank. No default configuration or live data found using preferred profiles for ${routeNameFromInput}/${destNameFromInput}.`;
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
                rsg_setCheckedProfiles_ExtraPage(""); // Ensure checkboxes are cleared
                return;
            }
            rsgStatusMessage_el_extra.textContent = `Op Profile blank. Assuming default: ${profileToAttemptLoad} for ${routeNameFromInput}/${destNameFromInput}.`;
            rsgStatusMessage_el_extra.style.color = "#3498db";
        } else {
            // Profile is blank, but route/dest haven't changed from a previous load that had a profile.
            // Keep showing current sequence, prompt user to select profile for new load/save.
            profileToAttemptLoad = rsg_lastLoadedOpProfile_extra; // Use the last successfully loaded profile for current display
            rsgStatusMessage_el_extra.textContent = `Operating Profile is blank. Displaying sequence for last loaded profile: '${profileToAttemptLoad}'. Select profile(s) to load or save new.`;
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
             // Checkboxes should already reflect rsg_lastLoadedOpProfile_extra if it was set by rsg_setCheckedProfiles_ExtraPage
            // If rsg_lastLoadedOpProfile_extra is also blank here, then it's a fresh state.
            if (!profileToAttemptLoad) rsg_setCheckedProfiles_ExtraPage("");
            return; // Don't try to load/pull if we're just showing last state with blank input
        }
    }

    if (!profileToAttemptLoad) { // Should only happen if opProfileFromInput was non-empty but somehow resolved to nothing
        rsgStatusMessage_el_extra.textContent = "No valid Operating Profile to load. Please select or clear.";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    const finalConfigKey = rsg_createConfigKey_ExtraPage(routeNameFromInput, profileToAttemptLoad, destNameFromInput);
    if (!finalConfigKey) {
        rsgStatusMessage_el_extra.textContent = "Error creating configuration key with profile(s): " + profileToAttemptLoad;
        rsgStatusMessage_el_extra.style.color = "#e74c3c";
        return;
    }

    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
    if (!isUsingAssumedProfile) { // Only show "checking" if user explicitly selected profiles
      rsgStatusMessage_el_extra.textContent = `Checking for configuration: ${routeNameFromInput} / ${profileToAttemptLoad} / ${destNameFromInput}...`;
    }

    try {
        let configDataUsed = null;
        if (rsg_loadedConfigs_extra[finalConfigKey]) {
            configDataUsed = rsg_loadedConfigs_extra[finalConfigKey];
            rsgStatusMessage_el_extra.textContent = `Loaded cached config for: ${configDataUsed.routeName || routeNameFromInput} (${configDataUsed.operatingProfile || profileToAttemptLoad}) to ${configDataUsed.destinationName || destNameFromInput}.`;
        } else {
            const snapshot = await dbGet(dbChild(dbRef(database), `${FB_PATH_RSG_CONFIGS}/${finalConfigKey}`));
            if (snapshot.exists()) {
                configDataUsed = snapshot.val();
                rsg_loadedConfigs_extra[finalConfigKey] = configDataUsed; // Cache it
                rsgStatusMessage_el_extra.textContent = `Loaded Firebase config for: ${configDataUsed.routeName || routeNameFromInput} (${configDataUsed.operatingProfile || profileToAttemptLoad}) to ${configDataUsed.destinationName || destNameFromInput}.`;
            }
        }

        if (configDataUsed) {
            rsgRouteNameInput_el_extra.value = configDataUsed.routeName || routeNameFromInput;
            // The opProfile input is gone, set checkboxes instead
            rsg_setCheckedProfiles_ExtraPage(configDataUsed.operatingProfile || profileToAttemptLoad); // << REPLACEMENT
            rsgDestinationNameInput_el_extra.value = configDataUsed.destinationName || destNameFromInput;

            rsg_populateRouteSelect_ExtraPage(); // Sync dropdowns
            rsg_populateDestinationSelect_ExtraPage();

            rsg_selectedStops_extra = JSON.parse(JSON.stringify(configDataUsed.stopSequence || []));
            rsgFirstStopTimesInput_el_extra.value = configDataUsed.firstStopTimes || '';

            rsg_lastLoadedRouteName_extra = rsgRouteNameInput_el_extra.value.trim();
            rsg_lastLoadedDestName_extra = rsgDestinationNameInput_el_extra.value.trim();
            rsg_lastLoadedOpProfile_extra = configDataUsed.operatingProfile || profileToAttemptLoad; // This is now the authoritative loaded profile string

            rsgStatusMessage_el_extra.style.color = "#2ecc71";

        } else { // No saved config, try to pull from live data
            if (isUsingAssumedProfile) {
                 rsgStatusMessage_el_extra.textContent = `No saved config for default '${profileToAttemptLoad}'. Pulling live data...`;
            } else {
                 rsgStatusMessage_el_extra.textContent = `No saved config for '${profileToAttemptLoad}'. Pulling live data...`;
            }
            rsgStatusMessage_el_extra.style.color = "#f1c40f";

            const routeNameUpperForPull = routeNameFromInput.toUpperCase();
            // For pulling, we use the `profileToAttemptLoad` which could be a single profile from preferred list,
            // or the comma-separated string from checkboxes. The live data must match this exact string.
            const relevantEntries = currentWorkingSchedule_extra.filter(entry =>
                entry.lineName && entry.lineName.toUpperCase() === routeNameUpperForPull &&
                entry.OperatingProfile === profileToAttemptLoad && // Exact match for single or combined profile string
                entry.destinationName === destNameFromInput
            );

            if (relevantEntries.length === 0) {
                let failMsg = "";
                if (isUsingAssumedProfile) {
                    failMsg = `Op Profile was blank: No default live data for '${profileToAttemptLoad}' found for ${routeNameFromInput}/${destNameFromInput}.`;
                } else if (!hasRouteOrDestChanged && rsg_selectedStops_extra.length > 0 && rsg_lastLoadedOpProfile_extra) {
                     // Kept previous sequence if route/dest same, but profile changed to one with no data
                    failMsg = `No live data for '${profileToAttemptLoad}'. Displaying previous sequence for '${rsg_lastLoadedOpProfile_extra}'.`;
                } else {
                    failMsg = `No live data found for ${routeNameFromInput} (${profileToAttemptLoad}) / ${destNameFromInput}. Sequence cleared.`;
                    rsg_selectedStops_extra = []; // Clear sequence if no data and not keeping old
                    rsgFirstStopTimesInput_el_extra.value = '';
                }
                rsgStatusMessage_el_extra.textContent = failMsg;
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
                // If we attempted to load/pull a profile and found nothing, ensure checkboxes reflect that profile if it was explicit.
                // If it was assumed, and no data found, maybe clear checkboxes or set them to the assumed one.
                // For now, rsg_setCheckedProfiles_ExtraPage would have been called with profileToAttemptLoad if it was explicit.
                // If it was assumed, and failed, we might want to clear:
                if(isUsingAssumedProfile && relevantEntries.length === 0) rsg_setCheckedProfiles_ExtraPage("");


            } else { // Live data found
                const stopTimings = new Map();
                relevantEntries.forEach(entry => {
                    const entryTimeMinutes = (parseInt(entry.DayOffset || 0) * 1440) + (parseInt(entry.scheduledTime.split(':')[0]) * 60) + parseInt(entry.scheduledTime.split(':')[1]);
                    if (!stopTimings.has(entry.stopID) || entryTimeMinutes < stopTimings.get(entry.stopID).earliestTime) {
                        stopTimings.set(entry.stopID, { stopInfo: { stopID: entry.stopID, stopName: entry.stopName, direction: entry.direction }, earliestTime: entryTimeMinutes });
                    }
                });
                const orderedStopInfosFromData = Array.from(stopTimings.values()).sort((a, b) => a.earliestTime - b.earliestTime).map(item => item.stopInfo);

                if (orderedStopInfosFromData.length === 0) {
                    rsgStatusMessage_el_extra.textContent = `Error: Could not derive stop sequence for ${routeNameFromInput} (${profileToAttemptLoad}).`;
                    rsgStatusMessage_el_extra.style.color = "#e74c3c";
                } else {
                    let bestExemplarTimes = null;
                    const firstStopIdOfSequence = orderedStopInfosFromData[0].stopID;
                    const firstStopDeparturesRaw = [...new Set(
                        relevantEntries.filter(e => e.stopID === firstStopIdOfSequence)
                        .map(e => ({ time: e.scheduledTime, dayOffset: parseInt(e.DayOffset || 0), minutes: (parseInt(e.DayOffset || 0) * 1440) + (parseInt(e.scheduledTime.split(':')[0]) * 60) + parseInt(e.scheduledTime.split(':')[1]) }))
                    )].sort((a, b) => a.minutes - b.minutes);

                    for (const departure of firstStopDeparturesRaw) {
                        const currentJourneyStopTimes = new Map();
                        currentJourneyStopTimes.set(firstStopIdOfSequence, departure.minutes);
                        let lastStopAbsoluteTimeInJourney = departure.minutes;
                        let journeyLooksGood = true;
                        for (let i = 1; i < orderedStopInfosFromData.length; i++) {
                            const targetStopID = orderedStopInfosFromData[i].stopID;
                            const entryForThisStopInJourney = relevantEntries
                                .filter(e => e.stopID === targetStopID)
                                .map(e => ({...e, absoluteMinutes: (parseInt(e.DayOffset || 0) * 1440) + (parseInt(e.scheduledTime.split(':')[0]) * 60) + parseInt(e.scheduledTime.split(':')[1]) }))
                                .filter(e => e.absoluteMinutes >= lastStopAbsoluteTimeInJourney)
                                .sort((a,b) => a.absoluteMinutes - b.absoluteMinutes)[0];
                            if (entryForThisStopInJourney) {
                                currentJourneyStopTimes.set(targetStopID, entryForThisStopInJourney.absoluteMinutes);
                                lastStopAbsoluteTimeInJourney = entryForThisStopInJourney.absoluteMinutes;
                            } else {
                                journeyLooksGood = false; break;
                            }
                        }
                        if (journeyLooksGood && currentJourneyStopTimes.size === orderedStopInfosFromData.length) {
                            bestExemplarTimes = currentJourneyStopTimes; break;
                        }
                    }
                    
                    rsg_selectedStops_extra = orderedStopInfosFromData.map((stopInfo, index) => {
                        let timeAdjustment = (index > 0) ? 2 : 0; // Default adjustment
                        if (bestExemplarTimes && index > 0) {
                            const currentTime = bestExemplarTimes.get(stopInfo.stopID);
                            const prevTime = bestExemplarTimes.get(orderedStopInfosFromData[index - 1].stopID);
                            if (typeof currentTime === 'number' && typeof prevTime === 'number' && currentTime >= prevTime) {
                                timeAdjustment = currentTime - prevTime;
                            }
                        }
                        return { stopID: stopInfo.stopID, stopName: stopInfo.stopName, direction: stopInfo.direction, timeAdjustment: timeAdjustment };
                    });

                    if (firstStopDeparturesRaw.length > 0) {
                        rsgFirstStopTimesInput_el_extra.value = firstStopDeparturesRaw.map(d => d.time).join(', ');
                    }
                    
                    rsg_setCheckedProfiles_ExtraPage(profileToAttemptLoad); // << NEW: Set checkboxes to the profile used for pulling
                    rsg_lastLoadedRouteName_extra = routeNameFromInput;
                    rsg_lastLoadedDestName_extra = destNameFromInput;
                    rsg_lastLoadedOpProfile_extra = profileToAttemptLoad; // This is now the authoritative loaded profile string

                    rsgStatusMessage_el_extra.textContent = `Pulled live data for: ${routeNameFromInput} (${profileToAttemptLoad}) / ${destNameFromInput}. Review adjustments.`;
                    rsgStatusMessage_el_extra.style.color = "#2ecc71";
                }
            }
        }
        rsg_renderStopSequence_ExtraPage(); // Re-render sequence with loaded/pulled data
    } catch (error) {
        console.error("Error in rsg_loadOrPullConfiguration_ExtraPage:", error);
        rsgStatusMessage_el_extra.textContent = "Error loading/pulling configuration: " + error.message;
        rsgStatusMessage_el_extra.style.color = "#e74c3c";
        rsg_selectedStops_extra = []; // Clear sequence on error
        rsgFirstStopTimesInput_el_extra.value = '';
        rsg_setCheckedProfiles_ExtraPage(""); // Clear checkboxes
        rsg_renderStopSequence_ExtraPage();
    }
}

        function rsg_handleSaveConfiguration_ExtraPage() {
    if (!currentUser_extra) {
        alert("Please log in to save configurations.");
        return;
    }
    // Basic check: ensure essential fields for naming are present before opening modal
    const routeName = rsgRouteNameInput_el_extra.value.trim();
    const destName = rsgDestinationNameInput_el_extra.value.trim();
    const opProfiles = rsg_getSelectedOpProfilesString_ExtraPage();

    if (!routeName || !destName || !opProfiles) {
         if(rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route, Destination, and Operating Profile(s) must be selected to save.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    if (rsg_selectedStops_extra.length === 0 || !rsgFirstStopTimesInput_el_extra.value.trim()) {
         if(rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Stop Sequence and First Stop Times are required to save.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    rsg_showSaveConfigModal_ExtraPage();
}

        function rsg_populateRouteSelect_ExtraPage() { 
            if (!rsgRouteNameSelect_el_extra || !rsgRouteNameInput_el_extra) return; const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))].filter(Boolean).sort(compareLineNames_ExtraPage); const currentInputValue = rsgRouteNameInput_el_extra.value.trim(); rsgRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Existing Route --</option>'; uniqueRoutes.forEach(route => { const opt = document.createElement('option'); opt.value = route; opt.textContent = route; rsgRouteNameSelect_el_extra.appendChild(opt); }); const matchedRoute = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase()); if (matchedRoute) rsgRouteNameSelect_el_extra.value = matchedRoute; else if (currentInputValue) rsgRouteNameSelect_el_extra.value = ""; rsg_populateDestinationSelect_ExtraPage();
        }
        function rsg_handleRouteNameInputChange_ExtraPage() { 
             if (!rsgRouteNameInput_el_extra || !rsgRouteNameSelect_el_extra) return; const typedRouteUpper = rsgRouteNameInput_el_extra.value.trim().toUpperCase(); const matchedOption = Array.from(rsgRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper); if (matchedOption) { rsgRouteNameSelect_el_extra.value = matchedOption.value; if (rsgRouteNameInput_el_extra.value !== matchedOption.value) rsgRouteNameInput_el_extra.value = matchedOption.value; } else rsgRouteNameSelect_el_extra.value = ""; rsg_populateDestinationSelect_ExtraPage();
        }
        function rsg_handleRouteNameSelectChange_ExtraPage() { 
            if (!rsgRouteNameSelect_el_extra || !rsgRouteNameInput_el_extra) return; rsgRouteNameInput_el_extra.value = rsgRouteNameSelect_el_extra.value; rsg_populateDestinationSelect_ExtraPage();
        }
        function rsg_populateDestinationSelect_ExtraPage() { 
            if (!rsgDestinationNameSelect_el_extra || !rsgDestinationNameInput_el_extra || !rsgRouteNameInput_el_extra) return; const selectedRoute = rsgRouteNameInput_el_extra.value.trim().toUpperCase(); const currentDestInputValue = rsgDestinationNameInput_el_extra.value.trim(); rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- Select Existing Destination --</option>'; if (!selectedRoute) { rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- Select Route First --</option>'; return; } const uniqueDestinations = [...new Set( currentWorkingSchedule_extra.filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName).map(e => e.destinationName) )].sort(); uniqueDestinations.forEach(dest => { const opt = document.createElement('option'); opt.value = dest; opt.textContent = dest; rsgDestinationNameSelect_el_extra.appendChild(opt); }); const matchedDest = uniqueDestinations.find(d => d === currentDestInputValue); if (matchedDest) rsgDestinationNameSelect_el_extra.value = matchedDest; else if (uniqueDestinations.length === 0 && selectedRoute) rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- No Destinations for Route --</option>'; else rsgDestinationNameSelect_el_extra.value = "";
        }
        function rsg_handleDestinationNameInputChange_ExtraPage() { 
            if (!rsgDestinationNameInput_el_extra || !rsgDestinationNameSelect_el_extra) return; const typedDest = rsgDestinationNameInput_el_extra.value.trim(); const matchedOption = Array.from(rsgDestinationNameSelect_el_extra.options).find(opt => opt.value === typedDest); if (matchedOption) { rsgDestinationNameSelect_el_extra.value = matchedOption.value; if (rsgDestinationNameInput_el_extra.value !== matchedOption.value) rsgDestinationNameInput_el_extra.value = matchedOption.value; } else rsgDestinationNameSelect_el_extra.value = "";
        }
        function rsg_handleDestinationNameSelectChange_ExtraPage() { 
            if (!rsgDestinationNameSelect_el_extra || !rsgDestinationNameInput_el_extra) return; rsgDestinationNameInput_el_extra.value = rsgDestinationNameSelect_el_extra.value;
        }

        // ++ RSG Helper Function to create 'Copy Time Adjustment' buttons (sorted) ++
        function rsg_createCopyAdjustmentButtons_ExtraPage(currentStopInSequence, stopIndexInCurrentSequence, buttonsContainer) {
            if (!currentStopInSequence || !buttonsContainer || !rsg_loadedConfigs_extra || typeof rsg_loadedConfigs_extra !== 'object') {
                return;
            }

            buttonsContainer.innerHTML = ''; // Clear any existing buttons or placeholder text

            const currentRsgRouteName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
            const targetStopID = currentStopInSequence.stopID;
            
            const potentialButtonsData = [];
            const addedButtonSignatures = new Set(); // To track added "RouteName|Adjustment" for uniqueness

            for (const configKey in rsg_loadedConfigs_extra) {
                const sourceConfig = rsg_loadedConfigs_extra[configKey];

                if (!sourceConfig.routeName || sourceConfig.routeName.toUpperCase() === currentRsgRouteName || !Array.isArray(sourceConfig.stopSequence)) {
                    continue;
                }

                let sourceStopData = null;
                let sourceStopIndexInItsConfig = -1;

                for (let i = 0; i < sourceConfig.stopSequence.length; i++) {
                    if (sourceConfig.stopSequence[i].stopID === targetStopID) {
                        sourceStopData = sourceConfig.stopSequence[i];
                        sourceStopIndexInItsConfig = i;
                        break; 
                    }
                }

                if (sourceStopData && sourceStopIndexInItsConfig > 0) { // Must exist and not be the first stop in its own sequence
                    const timeAdjustmentToCopy = sourceConfig.stopSequence[sourceStopIndexInItsConfig].timeAdjustment;

                    if (typeof timeAdjustmentToCopy === 'number') {
                        const buttonSignature = `${sourceConfig.routeName}|${timeAdjustmentToCopy}`;

                        if (!addedButtonSignatures.has(buttonSignature)) {
                            potentialButtonsData.push({
                                routeName: sourceConfig.routeName,
                                timeAdjustment: timeAdjustmentToCopy,
                                operatingProfile: sourceConfig.operatingProfile || 'N/A',
                                destinationName: sourceConfig.destinationName || 'N/A'
                            });
                            addedButtonSignatures.add(buttonSignature);
                        }
                    }
                }
            }

            if (potentialButtonsData.length > 0) {
                // Sort the collected button data by routeName
                potentialButtonsData.sort((a, b) => compareLineNames_ExtraPage(a.routeName, b.routeName));

                // Now create and append buttons in sorted order
                potentialButtonsData.forEach(data => {
                    const button = document.createElement('button');
                    button.classList.add('button', 'small-action', 'neutral', 'copy-adj-button');
                    button.textContent = `Copy From ${data.routeName} (+${data.timeAdjustment} min)`;
                    button.title = `Copy ${data.timeAdjustment} min from ${data.routeName} (Profile: ${data.operatingProfile}, Dest: ${data.destinationName})`;

                    button.addEventListener('click', () => {
                        rsg_selectedStops_extra[stopIndexInCurrentSequence].timeAdjustment = data.timeAdjustment;
                        const listItem = rsgStopSequenceList_el_extra.querySelector(`li[data-index="${stopIndexInCurrentSequence}"]`);
                        if (listItem) {
                            const timeAdjInput = listItem.querySelector('.rsg-time-adjustment-input');
                            if (timeAdjInput) {
                                timeAdjInput.value = data.timeAdjustment;
                            }
                        }
                        rsg_resetPreviewState(`Time adjustment (${data.timeAdjustment} min) copied from Route ${data.routeName}. Regenerate preview.`, "info");
                    });
                    buttonsContainer.appendChild(button);
                });
            } else {
                 buttonsContainer.innerHTML = `<span style="font-size:0.75em; opacity:0.7; display:block; margin-top:0.3rem; width:100%;">No other routes serve this stop to copy adjustment from.</span>`;
            }
        }

        function rsg_renderStopSequence_ExtraPage() {  
            if (!rsgStopSequenceList_el_extra || !rsgStopSequencePlaceholder_el_extra || !rsgFirstStopTimesContainer_el_extra) return; 
            rsgStopSequenceList_el_extra.innerHTML = ''; 
            if (rsg_selectedStops_extra.length === 0) { 
                rsgStopSequencePlaceholder_el_extra.style.display = 'block'; 
                rsgFirstStopTimesContainer_el_extra.style.display = 'none'; 
                if (rsgAddToWorkingScheduleButton_el_extra) rsgAddToWorkingScheduleButton_el_extra.style.display = 'none'; 
            } else { 
                rsgStopSequencePlaceholder_el_extra.style.display = 'none'; 
                rsgFirstStopTimesContainer_el_extra.style.display = 'block'; 
                rsg_selectedStops_extra.forEach((stop, index) => { 
                    const li = document.createElement('li'); 
                    li.dataset.index = index; 
                    li.draggable = true; 
                    const stopInfoDiv = document.createElement('div'); 
                    stopInfoDiv.classList.add('rsg-stop-info'); 
                    stopInfoDiv.innerHTML = `<span class="rsg-stop-name">${stop.stopName}</span> <span class="rsg-stop-id">(${stop.stopID})</span>`; 
                    if (stop.direction) stopInfoDiv.innerHTML += `<br><small style="opacity:0.7;">Towards: ${stop.direction}</small>`; 
                    
                    const actionsDiv = document.createElement('div'); 
                    actionsDiv.classList.add('rsg-stop-actions'); 
                    
                    if (index > 0) { 
                        const timeAdjInput = document.createElement('input'); 
                        timeAdjInput.type = 'number'; 
                        timeAdjInput.classList.add('schedule-generator-input', 'rsg-time-adjustment-input'); 
                        timeAdjInput.value = stop.timeAdjustment || '2'; 
                        timeAdjInput.min = '0'; 
                        timeAdjInput.title = 'Minutes from previous stop'; 
                        timeAdjInput.addEventListener('change', (e) => { 
                            rsg_selectedStops_extra[index].timeAdjustment = parseInt(e.target.value, 10) || 0; 
                            rsg_resetPreviewState("Time adjustment changed. Regenerate preview.", "info");
                        }); 
                        actionsDiv.appendChild(timeAdjInput); 
                    } 
                    
                    const removeButton = document.createElement('button'); 
                    removeButton.textContent = 'âœ•'; 
                    removeButton.classList.add('button', 'small-action', 'secondary'); 
                    removeButton.title = 'Remove Stop'; 
                    removeButton.addEventListener('click', () => rsg_removeStopFromSequence_ExtraPage(index)); 
                    actionsDiv.appendChild(removeButton); 
                    
                    li.appendChild(stopInfoDiv); 
                    li.appendChild(actionsDiv); 

                    // Container for "Copy Time Adjustment" buttons
                    if (index > 0) {
                        const copyButtonsContainer = document.createElement('div');
                        copyButtonsContainer.classList.add('rsg-copy-adjustment-buttons-container');
                        rsg_createCopyAdjustmentButtons_ExtraPage(stop, index, copyButtonsContainer);
                        // Append this container below the actionsDiv or as part of its own column if using grid
                        li.appendChild(copyButtonsContainer); // Appending it directly to li for simplicity
                    }
                    
                    rsgStopSequenceList_el_extra.appendChild(li); 
                    li.addEventListener('dragstart', rsg_handleDragStart_ExtraPage); 
                    li.addEventListener('dragover', rsg_handleDragOver_ExtraPage); 
                    li.addEventListener('dragleave', rsg_handleDragLeave_ExtraPage); 
                    li.addEventListener('drop', rsg_handleDrop_ExtraPage); 
                    li.addEventListener('dragend', rsg_handleDragEnd_ExtraPage); 
                }); 
            }
        }
        function rsg_handleDragStart_ExtraPage(event) {  
            rsg_draggedItemIndex_extra = parseInt(event.target.closest('li').dataset.index); event.dataTransfer.effectAllowed = 'move'; event.dataTransfer.setData('text/plain', rsg_draggedItemIndex_extra); setTimeout(() => { event.target.closest('li').classList.add('rsg-dragging-item'); }, 0); if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = "Dragging stop..."; rsgStatusMessage_el_extra.style.color = "#3498db"; }
        }
        function rsg_handleDragOver_ExtraPage(event) { 
            event.preventDefault(); event.dataTransfer.dropEffect = 'move'; const targetLi = event.target.closest('li'); if (targetLi && parseInt(targetLi.dataset.index) !== rsg_draggedItemIndex_extra) { Array.from(rsgStopSequenceList_el_extra.children).forEach(child => child.classList.remove('rsg-dragover-target')); targetLi.classList.add('rsg-dragover-target'); }
        }
        function rsg_handleDragLeave_ExtraPage(event) { 
            const targetLi = event.target.closest('li'); if (targetLi) { targetLi.classList.remove('rsg-dragover-target');}
        }
        function rsg_handleDrop_ExtraPage(event) { 
            event.preventDefault(); const targetLi = event.target.closest('li'); if (!targetLi) return; const droppedOnItemIndex = parseInt(targetLi.dataset.index); Array.from(rsgStopSequenceList_el_extra.children).forEach(child => child.classList.remove('rsg-dragover-target')); if (rsg_draggedItemIndex_extra !== null && rsg_draggedItemIndex_extra !== droppedOnItemIndex) { const itemToMove = rsg_selectedStops_extra.splice(rsg_draggedItemIndex_extra, 1)[0]; rsg_selectedStops_extra.splice(droppedOnItemIndex, 0, itemToMove); rsg_renderStopSequence_ExtraPage(); rsg_resetPreviewState("Stop order changed. Regenerate preview.", "info"); }
        }
        function rsg_handleDragEnd_ExtraPage(event) { 
             Array.from(rsgStopSequenceList_el_extra.children).forEach(childLi => { childLi.classList.remove('rsg-dragging-item'); childLi.classList.remove('rsg-dragover-target'); }); rsg_draggedItemIndex_extra = null;
        }
        function rsg_handleStopSearch_ExtraPage(event) { 
            if (!rsgStopSearchInput_el_extra || !rsgStopSearchResults_el_extra) return; const searchTerm = rsgStopSearchInput_el_extra.value.toLowerCase(); rsgStopSearchResults_el_extra.innerHTML = ''; if (searchTerm.length < 2) { return; } const uniqueStops = getUniqueStopsFromSchedule_ExtraPage(); const filteredStops = uniqueStops.filter(stop => stop.stopName.toLowerCase().includes(searchTerm) || stop.stopID.toLowerCase().includes(searchTerm)).slice(0, 10); if (filteredStops.length > 0) { filteredStops.forEach(stop => { const itemDiv = document.createElement('div'); itemDiv.classList.add('rsg-search-result-item'); let content = `<span class="rsg-search-stop-name">${stop.stopName} (${stop.stopID})</span>`; content += `<span class="rsg-search-stop-details">Towards: ${stop.direction || 'N/A'}</span>`; const servingRoutes = new Set(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === stop.stopID && entry.lineName && entry.lineName !== "INFO_ONLY") { servingRoutes.add(entry.lineName); } }); if (servingRoutes.size > 0) { content += `<div class="rsg-search-serving-routes">`; Array.from(servingRoutes).sort(compareLineNames_ExtraPage).slice(0, 5).forEach(line => { const bgColor = getRouteTileColour_ExtraPage(line, stop.stopID); const textColor = getTextColourForBackground_ExtraPage(bgColor); content += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor};font-size:0.7em;padding:0.1em 0.3em;">${line}</span>`; }); if (servingRoutes.size > 5) content += `<span style="font-size:0.7em;opacity:0.8;"> +${servingRoutes.size - 5} more</span>`; content += `</div>`; } itemDiv.innerHTML = content; itemDiv.addEventListener('click', () => { rsg_addStopToSequence_ExtraPage(stop.stopID, stop.stopName, stop.direction); rsgStopSearchInput_el_extra.value = ''; rsgStopSearchResults_el_extra.innerHTML = ''; rsgStopSearchInput_el_extra.focus(); }); rsgStopSearchResults_el_extra.appendChild(itemDiv); }); } else { rsgStopSearchResults_el_extra.innerHTML = '<div class="rsg-search-result-item">No stops found.</div>'; }
        }
        function rsg_addStopToSequence_ExtraPage(stopID, stopName, direction) { 
            if (rsg_selectedStops_extra.length > 0 && rsg_selectedStops_extra[rsg_selectedStops_extra.length -1].stopID === stopID) { if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = "Stop already last in sequence."; rsgStatusMessage_el_extra.style.color = "#f1c40f"; } return; } rsg_selectedStops_extra.push({ stopID: stopID, stopName: stopName, direction: direction, timeAdjustment: rsg_selectedStops_extra.length > 0 ? 2 : 0 }); rsg_renderStopSequence_ExtraPage(); rsg_resetPreviewState("Stop added. Regenerate preview if needed.", "info");
        }
        function rsg_removeStopFromSequence_ExtraPage(index) { 
            rsg_selectedStops_extra.splice(index, 1); rsg_renderStopSequence_ExtraPage(); rsg_resetPreviewState("Stop removed. Regenerate preview if needed.", "info");
        }
        function rsg_handleGenerateSchedulePreview_ExtraPage() { 
            if (!rsgRouteNameInput_el_extra || !rsgOperatingProfileInput_el_extra || !rsgDestinationNameInput_el_extra || !rsgFirstStopTimesInput_el_extra || !rsgStatusMessage_el_extra) return; const routeName = rsgRouteNameInput_el_extra.value.trim().toUpperCase(); let opProfileForGeneration = rsg_getSelectedOpProfilesString_ExtraPage(); const destName = rsgDestinationNameInput_el_extra.value.trim(); const firstStopTimesStr = rsgFirstStopTimesInput_el_extra.value.trim(); if (!routeName) { rsgStatusMessage_el_extra.textContent = "Route Name is required."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } if (!opProfileForGeneration && rsg_lastLoadedOpProfile_extra && routeName.toUpperCase() === (rsg_lastLoadedRouteName_extra || "").toUpperCase() && destName === (rsg_lastLoadedDestName_extra || "")) { opProfileForGeneration = rsg_lastLoadedOpProfile_extra; if (rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = `Generating preview using assumed profile: ${opProfileForGeneration}. Save will require explicit profile.`; rsgStatusMessage_el_extra.style.color = "#3498db"; } } else if (!opProfileForGeneration) { rsgStatusMessage_el_extra.textContent = "Operating Profile is required (type one in its field)."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } if (!destName) { rsgStatusMessage_el_extra.textContent = "Destination Name is required."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } if (rsg_selectedStops_extra.length === 0) { rsgStatusMessage_el_extra.textContent = "Please add at least one stop to the sequence."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } if (!firstStopTimesStr) { rsgStatusMessage_el_extra.textContent = "Departure Times for First Stop are required."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } const firstStopTimes = firstStopTimesStr.split(/\s*[,;\t]\s*/).map(t => t.trim()).filter(t => t.match(/^\d{2}:\d{2}$/)); if (firstStopTimes.length === 0) { rsgStatusMessage_el_extra.textContent = "Invalid format for first stop times (HH:MM, separated by comma/semicolon/tab)."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } rsg_generatedPreviewEntries_extra = []; firstStopTimes.forEach(startTimeHHMM => { const startParts = startTimeHHMM.split(':'); let currentMinutesFromMidnight = parseInt(startParts[0], 10) * 60 + parseInt(startParts[1], 10); let currentDayOffset = 0; rsg_selectedStops_extra.forEach((stop, index) => { if (index > 0) { const adjustment = stop.timeAdjustment || 0; currentMinutesFromMidnight += adjustment; } while (currentMinutesFromMidnight >= 1440) { currentMinutesFromMidnight -= 1440; currentDayOffset++; } while (currentMinutesFromMidnight < 0) { currentMinutesFromMidnight += 1440; currentDayOffset--; } const hours = Math.floor(currentMinutesFromMidnight / 60); const minutes = currentMinutesFromMidnight % 60; const scheduledTimeOutput = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`; rsg_generatedPreviewEntries_extra.push({ internalId: `${stop.stopID}_${routeName}_${scheduledTimeOutput.replace(':', '')}_${opProfileForGeneration.replace(/[^a-zA-Z0-9]/g, '')}_rsg${Date.now()}${index}`, stopID: stop.stopID, stopName: stop.stopName, direction: stop.direction, lineName: routeName, destinationName: destName, scheduledTime: scheduledTimeOutput, OperatingProfile: opProfileForGeneration, DayOffset: String(currentDayOffset) }); }); }); rsg_renderPreviewTable_ExtraPage(); if(rsgAddToWorkingScheduleButton_el_extra) rsgAddToWorkingScheduleButton_el_extra.style.display = 'inline-block'; if(rsgSchedulePreviewContainer_el_extra) rsgSchedulePreviewContainer_el_extra.style.display = 'block'; if(!rsgStatusMessage_el_extra.textContent.includes("assumed profile")) { rsgStatusMessage_el_extra.textContent = `Preview generated for ${rsg_generatedPreviewEntries_extra.length} entries using profile '${opProfileForGeneration}'.`; } rsgStatusMessage_el_extra.style.color = '#2ecc71';
        }
        function rsg_renderPreviewTable_ExtraPage() { 
            if (!rsgPreviewTableBody_el_extra || !rsgSchedulePreviewContainer_el_extra) return; rsgPreviewTableBody_el_extra.innerHTML = ''; if (rsg_generatedPreviewEntries_extra.length === 0) { return; } rsg_generatedPreviewEntries_extra.forEach(entry => { const row = rsgPreviewTableBody_el_extra.insertRow(); row.insertCell().textContent = entry.stopID; row.insertCell().textContent = entry.stopName; row.insertCell().textContent = entry.scheduledTime; row.insertCell().textContent = entry.lineName; row.insertCell().textContent = entry.destinationName; row.insertCell().textContent = entry.OperatingProfile; row.insertCell().textContent = entry.DayOffset; });
        }
        
        function rsg_resetPreviewState(message = "Configuration changed. Please (re)generate preview or add short workings.", messageType = "info") {
            rsg_generatedPreviewEntries_extra = []; 

            if(rsgPreviewTableBody_el_extra) {
                rsgPreviewTableBody_el_extra.innerHTML = ''; 
            }
            if(rsgSchedulePreviewContainer_el_extra) {
                rsgSchedulePreviewContainer_el_extra.style.display = 'none'; 
            }
            if(rsgAddToWorkingScheduleButton_el_extra) {
                rsgAddToWorkingScheduleButton_el_extra.style.display = 'none'; 
            }

            if(rsgStatusMessage_el_extra) {
                const isCurrentMessageError = rsgStatusMessage_el_extra.style.color === 'rgb(231, 76, 60)' || rsgStatusMessage_el_extra.style.color === '#e74c3c';
                if (!isCurrentMessageError || messageType !== "info" ) {
                    rsgStatusMessage_el_extra.textContent = message;
                    if (messageType === "info") {
                        rsgStatusMessage_el_extra.style.color = "#f1c40f"; 
                    } else if (messageType === "success") {
                        rsgStatusMessage_el_extra.style.color = "#2ecc71"; 
                    } else if (messageType === "error") {
                        rsgStatusMessage_el_extra.style.color = "#e74c3c"; 
                    } else {
                        rsgStatusMessage_el_extra.style.color = ""; 
                    }
                }
            }
        }

async function rsg_handleAddGeneratedToWorkingSchedule_ExtraPage() {
    if (!currentUser_extra) {
        alert("Please log in to modify the working schedule.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Not logged in.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    if (!rsg_generatedPreviewEntries_extra || rsg_generatedPreviewEntries_extra.length === 0) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "No schedule entries generated in the preview to add.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    const targetRouteName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
    let targetOpProfile = rsgOperatingProfileInput_el_extra.value.trim(); 
    const targetDestName = rsgDestinationNameInput_el_extra.value.trim();

    const previewSample = rsg_generatedPreviewEntries_extra[0];
    if (previewSample.lineName.toUpperCase() !== targetRouteName ||
        previewSample.destinationName !== targetDestName ||
        (targetOpProfile !== "" && previewSample.OperatingProfile !== targetOpProfile) 
       ) {
        if (targetOpProfile !== "" && previewSample.OperatingProfile !== targetOpProfile && previewSample.lineName.toUpperCase() === targetRouteName && previewSample.destinationName === targetDestName) {
             if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Profile mismatch: Preview used '${previewSample.OperatingProfile}', input is '${targetOpProfile}'. Please ensure Op Profile input matches intended generation.`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
             }
             return;
        } else if (previewSample.lineName.toUpperCase() !== targetRouteName || previewSample.destinationName !== targetDestName) {
             if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Route/Destination in form does not match generated preview. Please re-generate if settings changed.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
             }
             return;
        }
    }
    if (targetOpProfile === "" && previewSample.OperatingProfile) {
        targetOpProfile = previewSample.OperatingProfile;
    }
    
    if (!targetRouteName || !targetOpProfile || !targetDestName) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route Name, Operating Profile, and Destination Name must be effectively defined (from Section 1) to update the schedule.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const actionChoice = prompt(
        `Choose action for the ${rsg_generatedPreviewEntries_extra.length} previewed entries for:\n` +
        `Route: ${targetRouteName}\nProfile: ${targetOpProfile}\nDestination: ${targetDestName}\n\n` +
        `1. OVERWRITE existing entries for this specific Route, Profile, and Destination.\n` +
        `2. ADD these new entries (will append if R/P/D exists, or create if new).\n\n` +
        `Enter 1 or 2 (or Cancel):`
    );

    let newEntriesCount = rsg_generatedPreviewEntries_extra.length;
    let operationPerformed = false;
    const entriesToAdd = JSON.parse(JSON.stringify(rsg_generatedPreviewEntries_extra));

    if (actionChoice === "1") { 
        if (confirm(`ARE YOU SURE you want to REMOVE all existing entries for Route "${targetRouteName}", Profile "${targetOpProfile}", Destination "${targetDestName}" AND THEN ADD these ${newEntriesCount} new entries?`)) {
            
            let removedCount = 0;
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
                const matchesRPD = entry.lineName && entry.lineName.toUpperCase() === targetRouteName &&
                                   entry.OperatingProfile === targetOpProfile &&
                                   entry.destinationName === targetDestName;
                if (matchesRPD) {
                    removedCount++;
                    return false; 
                }
                return true; 
            });
            
            currentWorkingSchedule_extra.push(...entriesToAdd);
            
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Removed ${removedCount} existing entries. Working schedule will be updated with ${newEntriesCount} new entries for ${targetRouteName}/${targetOpProfile}/${targetDestName}. Saving...`;
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }
            operationPerformed = true;
        } else {
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Overwrite operation cancelled by user.";
                rsgStatusMessage_el_extra.style.color = "";
            }
            return;
        }
    } else if (actionChoice === "2") { 
        currentWorkingSchedule_extra.push(...entriesToAdd);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `${newEntriesCount} entries will be ADDED to the working schedule (for ${targetRouteName}/${targetOpProfile}/${targetDestName} if applicable). Saving...`;
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        operationPerformed = true;
    } else {
        if (actionChoice !== null && rsgStatusMessage_el_extra) { 
            rsgStatusMessage_el_extra.textContent = "Invalid choice. Operation cancelled.";
        } else if (rsgStatusMessage_el_extra) { 
             rsgStatusMessage_el_extra.textContent = "Add to working schedule cancelled.";
        }
        if (rsgStatusMessage_el_extra) rsgStatusMessage_el_extra.style.color = "";
        return;
    }

    if (operationPerformed) {
        try {
            await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
            
            if (rsgStatusMessage_el_extra) {
                const messageAction = actionChoice === "1" ? `Overwrote entries for R/P/D and added ${newEntriesCount} new ones.` : `Added ${newEntriesCount} entries.`;
                rsgStatusMessage_el_extra.textContent = `Successfully saved. ${messageAction} Working schedule now has ${currentWorkingSchedule_extra.length} total entries.`;
                rsgStatusMessage_el_extra.style.color = "#2ecc71";
            }
            
            rsg_resetPreviewState("Successfully added to working schedule. Ready for new generation.", "success");
            renderUIDependentElements_ExtraPage(); 

        } catch (error) {
            console.error("Error in rsg_handleAddGeneratedToWorkingSchedule_ExtraPage (saving to Firebase):", error);
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Error saving to Firebase: " + error.message + ". Local changes might not be live. Please review.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
        }
    }
}
        // ++ END Route Schedule Generator Functions ++

        // ++ RSG Copy From Another Route Modal Functions ++
        function rsg_openCopyFromModal_ExtraPage() { 
            if (!rsgCopyModal_el_extra || !rsgCopySourceRouteNameSelect_el_extra || !rsgCopySourceDestNameSelect_el_extra || !rsgCopyModalStatus_el_extra) return; const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))].filter(Boolean).sort(compareLineNames_ExtraPage); rsgCopySourceRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route --</option>'; uniqueRoutes.forEach(route => { const opt = document.createElement('option'); opt.value = route; opt.textContent = route; rsgCopySourceRouteNameSelect_el_extra.appendChild(opt); }); if(rsgCopySourceRouteNameInput_el_extra) rsgCopySourceRouteNameInput_el_extra.value = ''; if(rsgCopySourceOpProfileInput_el_extra) rsgCopySourceOpProfileInput_el_extra.value = ''; if(rsgCopySourceDestNameInput_el_extra) rsgCopySourceDestNameInput_el_extra.value = ''; rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route First --</option>'; rsgCopyModalStatus_el_extra.textContent = ''; rsgCopyModal_el_extra.style.display = 'flex';
        }
        function rsg_closeCopyFromModal_ExtraPage() { 
             if (rsgCopyModal_el_extra) rsgCopyModal_el_extra.style.display = 'none';
        }
        function rsg_populateCopySourceDestinationSelect_ExtraPage() { 
            if (!rsgCopySourceDestNameSelect_el_extra || !rsgCopySourceDestNameInput_el_extra || !rsgCopySourceRouteNameInput_el_extra) return; const selectedRoute = rsgCopySourceRouteNameInput_el_extra.value.trim().toUpperCase(); rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Destination --</option>'; if (!selectedRoute) { rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route First --</option>'; return; } const uniqueDestinations = [...new Set(currentWorkingSchedule_extra.filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName).map(e => e.destinationName))].sort(); if (uniqueDestinations.length > 0) { uniqueDestinations.forEach(dest => { const opt = document.createElement('option'); opt.value = dest; opt.textContent = dest; rsgCopySourceDestNameSelect_el_extra.appendChild(opt); }); } else { rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- No Destinations for this Route --</option>';}
        }
        async function rsg_handleCopyDataFromSource_ExtraPage() {
    if (!rsgCopySourceRouteNameInput_el_extra || !rsgCopySourceOpProfileInput_el_extra || !rsgCopySourceDestNameInput_el_extra || !rsgCopyModalStatus_el_extra || !window.firebaseOMSI) {
        if (rsgCopyModalStatus_el_extra) {
            rsgCopyModalStatus_el_extra.textContent = "Error: Required elements for copy are missing.";
            rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
        }
        return;
    }
    const sourceRouteName = rsgCopySourceRouteNameInput_el_extra.value.trim();
    const sourceOpProfile = rsgCopySourceOpProfileInput_el_extra.value.trim();
    const sourceDestName = rsgCopySourceDestNameInput_el_extra.value.trim();

    if (!sourceRouteName || !sourceOpProfile || !sourceDestName) {
        rsgCopyModalStatus_el_extra.textContent = "All source fields (Route, Operating Profile, Destination) are required.";
        rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
        return;
    }

    rsgCopyModalStatus_el_extra.textContent = "Fetching source data...";
    rsgCopyModalStatus_el_extra.style.color = "#f1c40f";

    let sourceConfigData = null;
    let sourceStopSequence = [];
    let sourceFirstStopTimes = "";

    const sourceConfigKey = rsg_createConfigKey_ExtraPage(sourceRouteName, sourceOpProfile, sourceDestName);

    if (rsg_loadedConfigs_extra && rsg_loadedConfigs_extra[sourceConfigKey]) {
        sourceConfigData = rsg_loadedConfigs_extra[sourceConfigKey];
    } else {
        const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
        try {
            const snapshot = await dbGet(dbChild(dbRef(database), `${FB_PATH_RSG_CONFIGS}/${sourceConfigKey}`));
            if (snapshot.exists()) {
                sourceConfigData = snapshot.val();
            }
        } catch (error) {
            console.error("Error fetching source RSG configuration for copy:", error);
            rsgCopyModalStatus_el_extra.textContent = "Error fetching source configuration: " + error.message;
            rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
            return;
        }
    }

    if (sourceConfigData) {
        sourceStopSequence = sourceConfigData.stopSequence || [];
        sourceFirstStopTimes = sourceConfigData.firstStopTimes || "";
    } else {
        const sourceRouteNameUpper = sourceRouteName.toUpperCase();
        const relevantEntries = currentWorkingSchedule_extra.filter(entry =>
            entry.lineName && entry.lineName.toUpperCase() === sourceRouteNameUpper &&
            entry.OperatingProfile === sourceOpProfile &&
            entry.destinationName === sourceDestName
        );

        if (relevantEntries.length > 0) {
            relevantEntries.sort((a, b) => {
                const dayOffsetA = parseInt(a.DayOffset || 0);
                const dayOffsetB = parseInt(b.DayOffset || 0);
                if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
                const timeA = (a.scheduledTime || "99:99").replace(':', '');
                const timeB = (b.scheduledTime || "99:99").replace(':', '');
                return timeA.localeCompare(timeB);
            });
            
            const firstTripSequence = [];
            if (relevantEntries.length > 0) {
                const firstStopIDOfJourney = relevantEntries[0].stopID;
                let previousStopTimeAbs = -1;
                const MIN_STOPS_HEURISTIC_FOR_COPY_BREAK = 3;

                for (let i = 0; i < relevantEntries.length; i++) {
                    const entry = relevantEntries[i];
                    if (!entry.stopID || !entry.scheduledTime) continue;
                    const currentTimeAbs = (parseInt(entry.DayOffset || 0) * 1440) + parseInt(entry.scheduledTime.split(':')[0]) * 60 + parseInt(entry.scheduledTime.split(':')[1]);

                    if (i > 0) {
                        if (currentTimeAbs < previousStopTimeAbs) break; 
                        if (entry.stopID === firstStopIDOfJourney && firstTripSequence.length >= MIN_STOPS_HEURISTIC_FOR_COPY_BREAK) break; 
                    }
                    firstTripSequence.push({ stopID: entry.stopID, stopName: entry.stopName, direction: entry.direction, timeAdjustment: (i > 0 ? 2 : 0) }); 
                    previousStopTimeAbs = currentTimeAbs;
                }
            }
            sourceStopSequence = firstTripSequence;

            if (sourceStopSequence.length > 0) {
                const firstStopIdInPulledSequence = sourceStopSequence[0].stopID;
                const departuresForFirstStop = [...new Set(
                    relevantEntries
                        .filter(e => e.stopID === firstStopIdInPulledSequence)
                        .map(e => e.scheduledTime)
                )].sort();
                sourceFirstStopTimes = departuresForFirstStop.join(', ');
            }
        }
    }

    if (sourceStopSequence.length > 0) {
        rsg_selectedStops_extra = JSON.parse(JSON.stringify(sourceStopSequence));
        if (rsgFirstStopTimesInput_el_extra) rsgFirstStopTimesInput_el_extra.value = sourceFirstStopTimes;
        
        rsg_renderStopSequence_ExtraPage();

        rsg_lastLoadedRouteName_extra = rsgRouteNameInput_el_extra.value.trim();
        rsg_lastLoadedDestName_extra = rsgDestinationNameInput_el_extra.value.trim();   
        rsg_lastLoadedOpProfile_extra = rsg_getSelectedOpProfilesString_ExtraPage() || sourceOpProfile;

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Stops and timings copied from ${sourceRouteName} (Profile: ${sourceOpProfile}, Dest: ${sourceDestName}). Main form context updated.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
        }
        rsg_resetPreviewState("Data copied. Regenerate preview if needed.", "info");
        rsg_closeCopyFromModal_ExtraPage();
    } else {
        rsgCopyModalStatus_el_extra.textContent = `No sequence data found for source: ${sourceRouteName} (Profile: ${sourceOpProfile}, Dest: ${sourceDestName}).`;
        rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
    }
}

        // --- Page Setup ---
        function showExtraPageSection(sectionId) {
    console.log('[MENU] Button clicked. Attempting to show section:', sectionId);

    if (!toolSectionsWrapper_el_extra) {
        console.error('[MENU] ERROR: toolSectionsWrapper_el_extra is null or undefined!');
        return;
    }

    const allSections = toolSectionsWrapper_el_extra.querySelectorAll('.tool-content-section');
    // console.log('[MENU] Found', allSections.length, 'elements with class "tool-content-section" to hide.'); // For debugging

    allSections.forEach(s => {
        s.style.display = 'none';
    });

    const sectionToShow = document.getElementById(sectionId);
    // console.log('[MENU] Element to show (sectionToShow):', sectionToShow); // For debugging

    if (sectionToShow) {
        sectionToShow.style.display = 'block';
        // console.log('[MENU] Set display to "block" for:', sectionId); // For debugging
        localStorage.setItem('omsiExtraToolsActiveSection', sectionId);

        if (sectionId === 'day-profile-override-section_extra') {
            loadAndDisplayOverrides_ExtraPage();
            updateSelectedDateInfo_ExtraPage();
        } else if (sectionId === 'stop-manager-tool-section_extra') {
            populateMasterStopList_ExtraPage();
            if (inputNewStopName_el_extra && inputNewStopId_el_extra && !inputNewStopName_el_extra.value && !inputNewStopId_el_extra.value) {
                autoGenerateAndSetNewStopId_ExtraPage();
            }
            if(duplicateStopsByNameDirResults_el_extra) duplicateStopsByNameDirResults_el_extra.innerHTML = 'Click "Find Duplicates (Name/Dir)" to check.';
        } else if (sectionId === 'global-route-deletion-section_extra') {
            populateGlobalRouteToDeleteList_ExtraPage();
        } else if (sectionId === 'route-schedule-generator-section_extra') {
            rsg_populateProfileCheckboxes_ExtraPage();
            rsg_populateRouteSelect_ExtraPage();
            // rsg_renderStopSequence_ExtraPage(); // rsg_loadOrPullConfiguration_ExtraPage will call this
            if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') {
                 rsg_loadOrPullConfiguration_ExtraPage();
            }
        } else if (sectionId === 'route-profile-deletion-section_extra') {
            rpd_populateRouteSelect_ExtraPage();
        } else if (sectionId === "service-analyzer-section_extra") { // Service Analyzer (Stops Only)
            onShowServiceAnalyzerSection_ExtraPage();
        } else if (sectionId === 'timetable-exporter-section_extra') { // Timetable Exporter
            populateTimetableExporterRouteSelect_ExtraPage();
            if (tteRouteNameInput_el_extra) tteRouteNameInput_el_extra.value = '';
            if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = 'Select a route to download its timetable.';
        }
    } else {
        console.warn("[MENU] showExtraPageSection: Could not find section with ID:", sectionId);
    }
}

        function updateAuthUI_ExtraPage(user) { 
            currentUser_extra = user; if (user) { if(authSection_el_extra) authSection_el_extra.style.display = 'none'; if(topMenuBar_el_extra) topMenuBar_el_extra.style.display = 'block'; if(logoutContainer_el_extra) logoutContainer_el_extra.style.display = 'block'; if(loginFormContainer_el_extra) loginFormContainer_el_extra.style.display = 'none'; if(authStatus_el_extra) authStatus_el_extra.textContent = ''; if(loggedInUserEmailDisplay_el_extra) loggedInUserEmailDisplay_el_extra.textContent = user.email; if(currentProfileDisplayContainer_el) currentProfileDisplayContainer_el.style.display = 'block'; loadInitialData_ExtraPage(); const lastSection = localStorage.getItem('omsiExtraToolsActiveSection'); const firstButton = topMenuBar_el_extra.querySelector('.menu-button'); if (lastSection && document.getElementById(lastSection) && Array.from(topMenuBar_el_extra.querySelectorAll('.menu-button')).some(b => b.dataset.section === lastSection) ) showExtraPageSection(lastSection); else if (firstButton && firstButton.dataset.section) showExtraPageSection(firstButton.dataset.section); } else { if(authSection_el_extra) authSection_el_extra.style.display = 'block'; if(topMenuBar_el_extra) topMenuBar_el_extra.style.display = 'none'; if(logoutContainer_el_extra) logoutContainer_el_extra.style.display = 'none'; if(loginFormContainer_el_extra) loginFormContainer_el_extra.style.display = 'block'; if(authStatus_el_extra) authStatus_el_extra.textContent = 'Please log in.'; if(loggedInUserEmailDisplay_el_extra) loggedInUserEmailDisplay_el_extra.textContent = ''; if(currentProfileDisplayContainer_el) currentProfileDisplayContainer_el.style.display = 'none'; if(toolSectionsWrapper_el_extra) toolSectionsWrapper_el_extra.querySelectorAll('.tool-content-section').forEach(s => s.style.display = 'none'); currentWorkingSchedule_extra = []; closedStopIDs_extra = []; globalCustomRouteColours_extra = {}; stopSpecificRouteColours_extra = {}; pageSpecificSettings = {}; rsg_loadedConfigs_extra = {}; rsg_lastLoadedRouteName_extra = null; rsg_lastLoadedDestName_extra = null; rsg_lastLoadedOpProfile_extra = null; renderUIDependentElements_ExtraPage(); }
        }
        
async function loadInitialData_ExtraPage() {
    let msg = "Loading data for Extra Modules (enhanced for all stops)...";
    console.log(msg);

    currentWorkingSchedule_extra = [];
    closedStopIDs_extra = [];
    globalCustomRouteColours_extra = {}; 
    stopSpecificRouteColours_extra = {}; 
    rsg_loadedConfigs_extra = {}; 
    
    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        msg = "Firebase not connected for Extra Modules.";
        console.error(msg);
        renderUIDependentElements_ExtraPage(); 
        return;
    }

    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
    try {
        const scheduleSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULES_BY_ROUTE));
        const flatScheduleFromDB = []; 
        if (scheduleSnap.exists()) {
            const schedulesByRoute = scheduleSnap.val();
            for (const routeKey in schedulesByRoute) {
                const routeData = schedulesByRoute[routeKey];
                for (const profileKey in routeData) {
                    const profileData = routeData[profileKey];
                    for (const destKey in profileData) {
                        const destData = profileData[destKey];
                        if (destData && Array.isArray(destData.entries)) {
                            destData.entries.forEach(entry => {
                                flatScheduleFromDB.push({ ...entry });
                            });
                        }
                    }
                }
            }
        }
        currentWorkingSchedule_extra = flatScheduleFromDB.map((e,i)=>({...e, internalId: e.internalId || `${(e.stopID||'s')}_${(e.lineName||'l')}_${(e.scheduledTime||"").replace(':','')}_${i}_fbloadX_flat`}));
        console.log(`Extra Tools: Loaded ${currentWorkingSchedule_extra.length} entries from structured schedule data (schedulesByRoute).`);

        const uniqueStopsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_UNIQUE_STOPS));
        const firebaseUniqueStops = uniqueStopsSnap.exists() && Array.isArray(uniqueStopsSnap.val()) ? uniqueStopsSnap.val() : [];
        console.log(`Extra Tools: Fetched ${firebaseUniqueStops.length} stops from uniqueBusStops list.`);

        const stopIDsAlreadyInScheduleFromRoutes = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase()));

        firebaseUniqueStops.forEach(fbStop => {
            if (fbStop && fbStop.stopID && !stopIDsAlreadyInScheduleFromRoutes.has(fbStop.stopID.toUpperCase())) {
                currentWorkingSchedule_extra.push({
                    internalId: `${fbStop.stopID}_definition_fbloadX_${Date.now()}`, 
                    stopID: fbStop.stopID,
                    stopName: fbStop.stopName || "Unknown Stop Name", 
                    direction: fbStop.direction || "" 
                });
                console.log(`Extra Tools: Added definition for stop ${fbStop.stopID} (from uniqueBusStops) to local working schedule.`);
            }
        });

        const closedSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_CLOSED_STOPS));
        if (closedSnap.exists()) {
            const fbC = closedSnap.val();
            closedStopIDs_extra = Object.keys(fbC).filter(id => fbC[id] === true).map(id => id.toUpperCase());
        }

        const globalCSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS));
        if (globalCSnap.exists()) globalCustomRouteColours_extra = globalCSnap.val() || {};

        const stopSpecificCSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS));
        if (stopSpecificCSnap.exists()) stopSpecificRouteColours_extra = stopSpecificCSnap.val() || {};

        const rsgConfigsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_RSG_CONFIGS));
        if (rsgConfigsSnap.exists()) {
    rsg_loadedConfigs_extra = rsgConfigsSnap.val() || {};
}
rsg_renderSavedConfigsList_ExtraPage();
        

        msg = `Extra Modules: Data loaded. Working schedule has ${currentWorkingSchedule_extra.length} items. ${closedStopIDs_extra.length} closed. ${Object.keys(rsg_loadedConfigs_extra).length} RSG configs.`;
    } catch (error) {
        console.error("Firebase Load Error (Extra Tools with merge logic):", error);
        msg = "Error loading data (Extra Tools): " + error.message;
        currentWorkingSchedule_extra = []; 
    }
    
    console.log(msg); 

    if (typeof fetchBankHolidays_ExtraPage === 'function') {
        await fetchBankHolidays_ExtraPage();
    }
    
    renderUIDependentElements_ExtraPage(); 
}
        function renderUIDependentElements_ExtraPage() { 
            const activeSectionId = localStorage.getItem('omsiExtraToolsActiveSection'); 
            const activeSectionElement = activeSectionId ? document.getElementById(activeSectionId) : null; 
            if (activeSectionElement && activeSectionElement.style.display === 'block') { 
                 showExtraPageSection(activeSectionId); // Re-run the show function to refresh content
            } else if (!activeSectionId && topMenuBar_el_extra && topMenuBar_el_extra.querySelector('.menu-button')) { 
                // If no active section is stored or visible, attempt to show the first one if user is logged in
                 if(currentUser_extra) {
                    const firstButton = topMenuBar_el_extra.querySelector('.menu-button');
                    if (firstButton && firstButton.dataset.section) {
                         showExtraPageSection(firstButton.dataset.section);
                    }
                }
            } 
        }

        // --- DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', () => { 
            console.log("OMSI Tools Extra DOMContentLoaded"); updateAuthUI_ExtraPage(null); 
            function initializeExtraAppLogic() { 
                console.log("Firebase ready, Extra app logic init."); 
                const { auth, authOnAuthStateChanged, authSignInWithEmailAndPassword, authSignOut } = window.firebaseOMSI; 
                authOnAuthStateChanged(auth, user => { updateAuthUI_ExtraPage(user); if (user && selectNewStopIdFormat_el_extra && inputNewStopName_el_extra && inputNewStopId_el_extra && !inputNewStopName_el_extra.value && !inputNewStopId_el_extra.value) { autoGenerateAndSetNewStopId_ExtraPage(); } }); 
                if (adminLoginForm_el_extra && inputEmail_el_extra && inputPassword_el_extra && authStatus_el_extra) { adminLoginForm_el_extra.addEventListener('submit', (e) => { e.preventDefault(); authStatus_el_extra.textContent = 'Logging in...'; authSignInWithEmailAndPassword(auth, inputEmail_el_extra.value, inputPassword_el_extra.value) .catch(err => { authStatus_el_extra.textContent = `Login Error: ${err.message}`; }); }); } 
                const logoutButton = logoutContainer_el_extra.querySelector('button'); 
                if (logoutButton) logoutButton.addEventListener('click', () => { localStorage.removeItem('omsiExtraToolsActiveSection'); authSignOut(auth).catch(e => console.error("Sign-out error (Extra):", e)); }); 
            } 

// Timetable Exporter Listeners
if (tteRouteNameSelect_el_extra && tteRouteNameInput_el_extra) {
    tteRouteNameSelect_el_extra.addEventListener('change', () => {
        if (tteRouteNameInput_el_extra) { // Ensure input exists
            tteRouteNameInput_el_extra.value = tteRouteNameSelect_el_extra.value;
        }
        if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = ''; // Clear status on new selection
    });
    tteRouteNameInput_el_extra.addEventListener('input', () => {
        const typedValue = tteRouteNameInput_el_extra.value.trim().toUpperCase();
        let matchedSelectValue = "";
        if (tteRouteNameSelect_el_extra) {
            const matchedOption = Array.from(tteRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedValue);
            if (matchedOption) {
                matchedSelectValue = matchedOption.value;
            }
            // Only update if the value actually changes to avoid potential loops if 'input' also triggers 'change'
            if (tteRouteNameSelect_el_extra.value !== matchedSelectValue) {
                 tteRouteNameSelect_el_extra.value = matchedSelectValue;
            }
        }
        if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = '';
    });
}
if (tteDownloadTimetableButton_el_extra) {
    tteDownloadTimetableButton_el_extra.addEventListener('click', handleDownloadTimetable_ExtraPage);
}
            if (window.firebaseOMSI && window.firebaseOMSI.auth) { initializeExtraAppLogic(); } 
            else { document.addEventListener('firebaseReady', () => { if (window.firebaseOMSI && window.firebaseOMSI.auth) { initializeExtraAppLogic(); } else { console.error("Extra Tools: Firebase still not ready after event!"); } }, { once: true }); } 
            
            const menuButtons = topMenuBar_el_extra.querySelectorAll('.menu-button'); 
            menuButtons.forEach(button => button.addEventListener('click', () => { if (currentUser_extra) showExtraPageSection(button.dataset.section); else alert("Please log in."); })); 

// Timetable Exporter Listeners
if (tteRouteNameSelect_el_extra && tteRouteNameInput_el_extra) {
        tteRouteNameSelect_el_extra.addEventListener('change', () => {
            if (tteRouteNameInput_el_extra) {
                tteRouteNameInput_el_extra.value = tteRouteNameSelect_el_extra.value;
            }
            if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = '';
        });
        tteRouteNameInput_el_extra.addEventListener('input', () => { // Using 'input' for more responsive sync
            const typedValue = tteRouteNameInput_el_extra.value.trim().toUpperCase();
            let matchedSelectValue = "";
            if (tteRouteNameSelect_el_extra) {
                const matchedOption = Array.from(tteRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedValue);
                if (matchedOption) {
                    matchedSelectValue = matchedOption.value;
                }
                if (tteRouteNameSelect_el_extra.value !== matchedSelectValue) {
                     tteRouteNameSelect_el_extra.value = matchedSelectValue;
                }
            }
            if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = '';
        });
    }
    if (tteDownloadTimetableButton_el_extra) {
        tteDownloadTimetableButton_el_extra.addEventListener('click', handleDownloadTimetable_ExtraPage);
    }
            
            // Day Profile Override Listeners
            if(overrideDateInput_el_extra) overrideDateInput_el_extra.addEventListener('change', updateSelectedDateInfo_ExtraPage); 
            if(setOverrideButton_el_extra) setOverrideButton_el_extra.addEventListener('click', handleSetOverride_ExtraPage); 
            if(clearOverrideButton_el_extra) clearOverrideButton_el_extra.addEventListener('click', handleClearOverride_ExtraPage); 
            
            // Stop Management Listeners
            if (inputNewStopName_el_extra) inputNewStopName_el_extra.addEventListener('input', autoGenerateAndSetNewStopId_ExtraPage); 
            if (inputNewStopId_el_extra && newStopIdAvailability_el_extra) { inputNewStopId_el_extra.addEventListener('input', () => { const newStopId = inputNewStopId_el_extra.value.trim().toUpperCase(); if (!newStopId) { newStopIdAvailability_el_extra.textContent = ''; return; } if (!/^[A-Z0-9]+$/.test(newStopId)) { newStopIdAvailability_el_extra.textContent = 'ID invalid chars.'; newStopIdAvailability_el_extra.style.color = '#e74c3c'; return; } const existingStopIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase())); if (existingStopIDs.has(newStopId)) { newStopIdAvailability_el_extra.textContent = 'ID already exists!'; newStopIdAvailability_el_extra.style.color = '#e74c3c'; } else { newStopIdAvailability_el_extra.textContent = 'ID available.'; newStopIdAvailability_el_extra.style.color = '#2ecc71'; } }); } 
            if (buttonAddNewStop_el_extra) buttonAddNewStop_el_extra.addEventListener('click', handleAddStopDetails_ExtraPage); 
            if (fileInputBulkAddStops_el_extra) fileInputBulkAddStops_el_extra.addEventListener('change', handleExcelFileForBulkAdd_ExtraPage); 
            if (buttonBulkAddNewStops_el_extra) buttonBulkAddNewStops_el_extra.addEventListener('click', handleBulkAddStops_ExtraPage); 
            if(masterStopListFilterInput_el_extra) masterStopListFilterInput_el_extra.addEventListener('input', populateMasterStopList_ExtraPage); 
            if(refreshMasterStopListButton_el_extra) refreshMasterStopListButton_el_extra.addEventListener('click', ()=>{ loadInitialData_ExtraPage().then(()=>populateMasterStopList_ExtraPage()); }); 
            if(applyMasterListStopIdChangesButton_el_extra) applyMasterListStopIdChangesButton_el_extra.addEventListener('click', handleApplyMasterListStopIdChangesButton_ExtraPage); 
            if(exportUniqueStopsButton_el_extra) exportUniqueStopsButton_el_extra.addEventListener('click', () => { if (!currentUser_extra) { alert("Log in to export."); return; } const uniqueStops = getUniqueStopsFromSchedule_ExtraPage(); if (uniqueStops.length === 0) { alert("No unique stops to export."); return; } const dataToExport = uniqueStops.map(stop => { const servingLineNames = new Set(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === stop.stopID && entry.lineName && entry.lineName.trim() !== "" && entry.lineName.toUpperCase() !== "INFO_ONLY") servingLineNames.add(entry.lineName); }); return { "StopID": stop.stopID, "StopName": stop.stopName, "Direction": stop.direction, "LineName(s)": Array.from(servingLineNames).sort(compareLineNames_ExtraPage).join(', ') }; }); const headers = ["StopID", "StopName", "Direction", "LineName(s)"]; const worksheetData = [ headers, ...dataToExport.map(row => headers.map(header => row[header])) ]; const worksheet = XLSX.utils.aoa_to_sheet(worksheetData); const workbook = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(workbook, worksheet, "OMSI Bus Stops"); XLSX.writeFile(workbook, "OMSI_Bus_Stops_Extra.xlsx"); }); 
            if(findDuplicateStopsByNameDirButton_el_extra) findDuplicateStopsByNameDirButton_el_extra.addEventListener('click', findDuplicateStopsByNameAndDirection_ExtraPage); 
            
            // Global Route Deletion Listeners
            if(deleteEntireRouteButton_el_extra) deleteEntireRouteButton_el_extra.addEventListener('click', handleDeleteEntireRouteGlobally_ExtraPage); 
            
            // Route Profile Deletion (RPD) Listeners
            if (rpdRouteSelect_el_extra) rpdRouteSelect_el_extra.addEventListener('change', rpd_handleRouteNameSelectChange_ExtraPage);
            if (rpdRouteInput_el_extra) rpdRouteInput_el_extra.addEventListener('blur', rpd_handleRouteNameInputChange_ExtraPage); // Changed to blur for better UX with select sync
            if (rpdDestinationSelect_el_extra) rpdDestinationSelect_el_extra.addEventListener('change', rpd_handleDestinationNameSelectChange_ExtraPage);
            if (rpdDestinationInput_el_extra) rpdDestinationInput_el_extra.addEventListener('blur', rpd_handleDestinationNameInputChange_ExtraPage); // Changed to blur
            if (rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.addEventListener('click', rpd_handleClearDestination_ExtraPage);
            if (rpdDeleteProfilesButton_el_extra) rpdDeleteProfilesButton_el_extra.addEventListener('click', handleDeleteRouteProfiles_ExtraPage);

            // Route Schedule Generator (RSG) Listeners
            if (rsgRouteNameSelect_el_extra) rsgRouteNameSelect_el_extra.addEventListener('change', () => { rsg_handleRouteNameSelectChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgRouteNameInput_el_extra) rsgRouteNameInput_el_extra.addEventListener('blur', () => { rsg_handleRouteNameInputChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgDestinationNameSelect_el_extra) rsgDestinationNameSelect_el_extra.addEventListener('change', () => { rsg_handleDestinationNameSelectChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgDestinationNameInput_el_extra) rsgDestinationNameInput_el_extra.addEventListener('blur', () => { rsg_handleDestinationNameInputChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgStopSearchInput_el_extra) rsgStopSearchInput_el_extra.addEventListener('input', rsg_handleStopSearch_ExtraPage); 
            if (rsgGenerateScheduleButton_el_extra) rsgGenerateScheduleButton_el_extra.addEventListener('click', rsg_handleGenerateSchedulePreview_ExtraPage); 
            if (rsgSaveConfigurationButton_el_extra) rsgSaveConfigurationButton_el_extra.addEventListener('click', rsg_handleSaveConfiguration_ExtraPage); 
            if (rsgAddToWorkingScheduleButton_el_extra) rsgAddToWorkingScheduleButton_el_extra.addEventListener('click', rsg_handleAddGeneratedToWorkingSchedule_ExtraPage); 
            if(rsgOpenCopyModalButton_el_extra) rsgOpenCopyModalButton_el_extra.addEventListener('click', rsg_openCopyFromModal_ExtraPage); 
            if(rsgCopyModalCancelButton_el_extra) rsgCopyModalCancelButton_el_extra.addEventListener('click', rsg_closeCopyFromModal_ExtraPage); 
            if(rsgCopyModalActionButton_el_extra) rsgCopyModalActionButton_el_extra.addEventListener('click', rsg_handleCopyDataFromSource_ExtraPage); 
            if(rsgCopySourceRouteNameSelect_el_extra) { rsgCopySourceRouteNameSelect_el_extra.addEventListener('change', () => { if(rsgCopySourceRouteNameInput_el_extra) rsgCopySourceRouteNameInput_el_extra.value = rsgCopySourceRouteNameSelect_el_extra.value; rsg_populateCopySourceDestinationSelect_ExtraPage(); }); } 
            if(rsgCopySourceRouteNameInput_el_extra) { rsgCopySourceRouteNameInput_el_extra.addEventListener('blur', () => { const typedRouteUpper = rsgCopySourceRouteNameInput_el_extra.value.trim().toUpperCase(); const matchedOption = Array.from(rsgCopySourceRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper); if (matchedOption) { rsgCopySourceRouteNameSelect_el_extra.value = matchedOption.value; if(rsgCopySourceRouteNameInput_el_extra.value !== matchedOption.value) rsgCopySourceRouteNameInput_el_extra.value = matchedOption.value; } else { rsgCopySourceRouteNameSelect_el_extra.value = ""; } rsg_populateCopySourceDestinationSelect_ExtraPage(); }); } 
            if(rsgCopySourceDestNameSelect_el_extra) { rsgCopySourceDestNameSelect_el_extra.addEventListener('change', () => { if(rsgCopySourceDestNameInput_el_extra) rsgCopySourceDestNameInput_el_extra.value = rsgCopySourceDestNameSelect_el_extra.value; }); } 
            if(rsgCopySourceDestNameInput_el_extra) { rsgCopySourceDestNameInput_el_extra.addEventListener('blur', () => { const typedDest = rsgCopySourceDestNameInput_el_extra.value.trim(); const matchedOption = Array.from(rsgCopySourceDestNameSelect_el_extra.options).find(opt => opt.value === typedDest); if (matchedOption) rsgCopySourceDestNameSelect_el_extra.value = matchedOption.value; else rsgCopySourceDestNameSelect_el_extra.value = ""; }); } 
            if (rsgCopyModal_el_extra) { rsgCopyModal_el_extra.addEventListener('click', (event) => { if (event.target === rsgCopyModal_el_extra) rsg_closeCopyFromModal_ExtraPage(); }); }
        });

const rsgClearProfilesButton_el_extra = document.getElementById('rsg-clear-profile-checkboxes-button-extra');
if (rsgClearProfilesButton_el_extra) {
    rsgClearProfilesButton_el_extra.addEventListener('click', rsg_clearProfileSelections_ExtraPage);
}

// Save Config Modal Buttons
const rsgSaveConfirmBtn = document.getElementById('rsg-save-config-confirm-button-extra');
if (rsgSaveConfirmBtn) {
    rsgSaveConfirmBtn.addEventListener('click', rsg_performSaveConfiguration_ExtraPage);
}
const rsgSaveCancelBtn = document.getElementById('rsg-save-config-cancel-button-extra');
if (rsgSaveCancelBtn) {
    rsgSaveCancelBtn.addEventListener('click', rsg_hideSaveConfigModal_ExtraPage);
}

// Clicking outside the modal content to close it
const rsgSaveModal = document.getElementById('rsg-save-config-modal-extra');
if (rsgSaveModal) {
    rsgSaveModal.addEventListener('click', (event) => {
        if (event.target === rsgSaveModal) { // Only if overlay itself is clicked
            rsg_hideSaveConfigModal_ExtraPage();
        }

        });
    }

// Event Listeners for RSG Rename Config Modal (New)
    const rsgRenameConfirmBtn = document.getElementById('rsg-rename-config-confirm-button-extra');
    if (rsgRenameConfirmBtn) {
        rsgRenameConfirmBtn.addEventListener('click', rsg_performRenameConfiguration_ExtraPage);
    }
    const rsgRenameCancelBtn = document.getElementById('rsg-rename-config-cancel-button-extra');
    if (rsgRenameCancelBtn) {
        rsgRenameCancelBtn.addEventListener('click', rsg_hideRenameConfigModal_ExtraPage);
    }
    const rsgRenameModal = document.getElementById('rsg-rename-config-modal-extra');
    if (rsgRenameModal) {
        rsgRenameModal.addEventListener('click', (event) => {
            if (event.target === rsgRenameModal) { // Only if overlay (modal background) itself is clicked
                rsg_hideRenameConfigModal_ExtraPage();
            }
        });
    }

// === SERVICE ANALYZER JS ===
const serviceAnalyzerStopSelect_el_extra = document.getElementById('service-analyzer-stop-select-extra');
const serviceAnalyzerStopInput_el_extra = document.getElementById('service-analyzer-stop-input-extra');
const serviceAnalyzerStopSummary_el_extra = document.getElementById('service-analyzer-stop-summary-extra');

function populateServiceAnalyzerDropdowns_ExtraPage() {
    if (!Array.isArray(currentWorkingSchedule_extra)) return;
    // const allRoutesSet = new Set(); // No longer needed
    const allStopsSet = new Set();
    const allStopsMap = new Map();
    currentWorkingSchedule_extra.forEach(entry => {
        // if (entry.lineName) allRoutesSet.add(entry.lineName); // Removed
        if (entry.stopID) {
            allStopsSet.add(entry.stopID);
            allStopsMap.set(entry.stopID, entry.stopName || entry.stopID);
        }
    });
    // The block for populating serviceAnalyzerRouteSelect_el_extra is removed.
    if (serviceAnalyzerStopSelect_el_extra) { // This element variable should still be defined
        serviceAnalyzerStopSelect_el_extra.innerHTML = '<option value="">-- Select Stop --</option>';
        Array.from(allStopsSet)
            .map(stopID => ({ id: stopID, name: allStopsMap.get(stopID) || stopID }))
            .sort((a,b) => {
                const nameCompare = (a.name.toLowerCase()).localeCompare(b.name.toLowerCase());
                if (nameCompare !== 0) return nameCompare;
                return (a.id.toLowerCase()).localeCompare(b.id.toLowerCase());
            })
            .forEach(stopObj => {
                serviceAnalyzerStopSelect_el_extra.innerHTML += `<option value="${stopObj.id}">${stopObj.name} (${stopObj.id})</option>`;
            });
    }
}

function triggerStopAnalysisDynamically(stopIdentifier) {
    if (stopIdentifier) {
        analyzeStop_ExtraPage(stopIdentifier); // Your existing analysis function
    } else {
        if (serviceAnalyzerStopSummary_el_extra) {
            serviceAnalyzerStopSummary_el_extra.innerHTML = 'Select or type a stop to analyze.';
        }
    }
}

// 1. Listener for the SELECT dropdown
if (serviceAnalyzerStopSelect_el_extra) {
    serviceAnalyzerStopSelect_el_extra.addEventListener('change', function() {
        const selectedStopID = this.value;
        if (serviceAnalyzerStopInput_el_extra) {
            // Update the text input to reflect the dropdown's current selection's full text
            const selectedOption = this.options[this.selectedIndex];
            if (selectedOption && selectedOption.value) { // Check if it's a real stop, not the placeholder
                serviceAnalyzerStopInput_el_extra.value = selectedOption.text; // Show "Stop Name (ID)"
            } else {
                serviceAnalyzerStopInput_el_extra.value = ""; // Clear input if "-- Select Stop --"
            }
        }
        triggerStopAnalysisDynamically(selectedStopID);
    });
}

// 2. Listener for the TEXT input
if (serviceAnalyzerStopInput_el_extra && serviceAnalyzerStopSelect_el_extra) {
    // While typing, try to sync the select dropdown (no analysis on every keystroke)
    serviceAnalyzerStopInput_el_extra.addEventListener('input', function() {
        const typedValueLower = this.value.toLowerCase().trim();
        if (typedValueLower === "") {
            if (serviceAnalyzerStopSelect_el_extra.value !== "") {
                 serviceAnalyzerStopSelect_el_extra.value = ""; // Reset select, this won't fire its change event
            }
            return;
        }

        const options = Array.from(serviceAnalyzerStopSelect_el_extra.options);
        const matchedOption = options.find(opt =>
            opt.text.toLowerCase().includes(typedValueLower) || // Prioritize matching by text content
            opt.value.toLowerCase() === typedValueLower      // Also allow matching by ID
        );

        if (matchedOption) {
            if (serviceAnalyzerStopSelect_el_extra.value !== matchedOption.value) {
                serviceAnalyzerStopSelect_el_extra.value = matchedOption.value; // Sync select
            }
        } else {
            if (serviceAnalyzerStopSelect_el_extra.value !== "") {
                serviceAnalyzerStopSelect_el_extra.value = ""; // No match, deselect
            }
        }
    });

    // Analyze when the text input loses focus (on blur)
    serviceAnalyzerStopInput_el_extra.addEventListener('blur', function() {
        const typedValue = this.value.trim();
        // Prefer the synced select value if it's valid and matches what was typed (or part of it)
        const selectedInDropdown = serviceAnalyzerStopSelect_el_extra.value;
        const selectedOptionText = serviceAnalyzerStopSelect_el_extra.options[serviceAnalyzerStopSelect_el_extra.selectedIndex]?.text;

        if (selectedInDropdown && selectedOptionText && selectedOptionText.toLowerCase().includes(typedValue.toLowerCase())) {
            triggerStopAnalysisDynamically(selectedInDropdown);
        } else if (typedValue) { // If no sync or no valid option that aligns with typed text, try analyzing the raw typed value
            triggerStopAnalysisDynamically(typedValue);
        } else { // Input is empty
             triggerStopAnalysisDynamically(null);
        }
    });
}



// Helper function to generate sequence HTML for a given set of profiles
function generateSequenceMapForProfiles(
    profilesToAnalyze,
    currentDestName,
    allEntriesForRoute // All schedule entries for the main route being analyzed
) {
    const sequencesMap = new Map(); // Key: sequenceSignature, Value: { sequence: [stopObjects], profiles: Set() }

    if (!profilesToAnalyze || profilesToAnalyze.length === 0) {
        return sequencesMap; // Return an empty map if no profiles to analyze
    }

    const sortedProfiles = [...profilesToAnalyze].sort(); // Process profiles in a consistent order

    for (const opProfile of sortedProfiles) {
        // Filter entries for the current operating profile and destination
        const specificProfileEntries = allEntriesForRoute.filter(e =>
            e.destinationName === currentDestName && e.OperatingProfile === opProfile
        );

        if (specificProfileEntries.length === 0) continue; // No entries for this specific profile/destination

        // Sort these specificProfileEntries chronologically to correctly identify the first trip
        specificProfileEntries.sort((a, b) => {
            const dayOffsetA = parseInt(a.DayOffset || 0);
            const dayOffsetB = parseInt(b.DayOffset || 0);
            if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;

            const timeA = (a.scheduledTime || "99:99").replace(':', ''); // Fallback for missing time
            const timeB = (b.scheduledTime || "99:99").replace(':', '');
            return timeA.localeCompare(timeB);
        });

        const sequenceForThisProfileTrip = [];
        if (specificProfileEntries.length > 0) {
            const firstStopIDOfThisJourneyPattern = specificProfileEntries[0].stopID;
            let previousStopTimeInAbsoluteMinutes = -1;
            // Heuristic: Minimum stops to process before considering a repeat of the first stop ID as a new trip.
            // This helps distinguish a genuine new trip from a route that might loop back to its start ID quickly.
            // Adjust if necessary. If routes are very short (e.g. 2-stop shuttles that repeat often), this might need tuning.
            const MIN_STOPS_BEFORE_FIRST_ID_REVISIT_BREAK = 3;

            for (let i = 0; i < specificProfileEntries.length; i++) {
                const entry = specificProfileEntries[i];

                if (!entry.stopID || !entry.scheduledTime) {
                    console.warn(`Service Analyzer: Skipping entry for ${opProfile} (Dest: ${currentDestName}) due to missing stopID/time:`, entry);
                    continue;
                }

                const currentStopTimeInAbsoluteMinutes =
                    (parseInt(entry.DayOffset || 0) * 1440) +
                    parseInt(entry.scheduledTime.split(':')[0]) * 60 +
                    parseInt(entry.scheduledTime.split(':')[1]);

                // These break conditions apply only after the very first stop (i > 0)
                if (i > 0) {
                    // Condition 1: Time regresses (e.g., next day's service, or data error)
                    if (currentStopTimeInAbsoluteMinutes < previousStopTimeInAbsoluteMinutes) {
                        break; // End of the current trip's sequence
                    }
                    // Condition 2: Encountered the starting stop ID again *after* a few other stops
                    if (entry.stopID === firstStopIDOfThisJourneyPattern &&
                        sequenceForThisProfileTrip.length >= MIN_STOPS_BEFORE_FIRST_ID_REVISIT_BREAK) {
                        break; // Assumed start of the next iteration of this trip pattern
                    }
                }

                sequenceForThisProfileTrip.push({
                    stopID: entry.stopID,
                    name: entry.stopName || entry.stopID,
                    direction: entry.direction || 'N/A'
                });
                previousStopTimeInAbsoluteMinutes = currentStopTimeInAbsoluteMinutes;
            }
        }

        if (sequenceForThisProfileTrip.length > 0) {
            const sequenceSignature = sequenceForThisProfileTrip.map(s => s.stopID).join('->');
            if (!sequencesMap.has(sequenceSignature)) {
                sequencesMap.set(sequenceSignature, {
                    sequence: sequenceForThisProfileTrip,
                    profiles: new Set()
                });
            }
            sequencesMap.get(sequenceSignature).profiles.add(opProfile);
        }
    } // End opProfile loop
    return sequencesMap;
}

function analyzeStop_ExtraPage(stopID) {
    if (!serviceAnalyzerStopSummary_el_extra) return;
    if (!stopID) {
        serviceAnalyzerStopSummary_el_extra.innerHTML = `<span style="color:#f1c40f;">Please select or enter a stop.</span>`;
        return;
    }
    const entries = currentWorkingSchedule_extra.filter(e => e.stopID && e.stopID.toUpperCase() === stopID.toUpperCase());
    if (entries.length === 0) {
        serviceAnalyzerStopSummary_el_extra.innerHTML = `<span style="color:#e74c3c;">No data found for this stop.</span>`;
        return;
    }
    const stopDetails = entries[0]; // Get name/direction from first entry
    const routes = new Set();
    const profilesByRoute = new Map(); // route -> Set of profiles
    const destinationsByRoute = new Map(); // route -> Set of destinations
    const times = []; // All scheduled times at this stop

    entries.forEach(e => {
        if (e.lineName) {
            routes.add(e.lineName);
            if (!profilesByRoute.has(e.lineName)) profilesByRoute.set(e.lineName, new Set());
            if (e.OperatingProfile) profilesByRoute.get(e.lineName).add(e.OperatingProfile);
            
            if (!destinationsByRoute.has(e.lineName)) destinationsByRoute.set(e.lineName, new Set());
            if (e.destinationName) destinationsByRoute.get(e.lineName).add(e.destinationName);
        }
        if (e.scheduledTime) times.push(e.scheduledTime);
    });

    let firstTime = null, lastTime = null;
    if (times.length > 0) {
        const sortedTimes = times.map(t => {
            const [h, m] = t.split(':');
            return parseInt(h, 10) * 60 + parseInt(m, 10);
        }).sort((a, b) => a - b);
        
        const formatMinutesToHHMM = (totalMinutes) => {
            const h = String(Math.floor(totalMinutes / 60)).padStart(2,'0');
            const m = String(totalMinutes % 60).padStart(2,'0');
            return `${h}:${m}`;
        };
        firstTime = formatMinutesToHHMM(sortedTimes[0]);
        lastTime = formatMinutesToHHMM(sortedTimes[sortedTimes.length - 1]);
    }
    
    let routeDetailsHTML = "";
    Array.from(routes).sort(compareLineNames_ExtraPage).forEach(route => {
        const profilesStr = profilesByRoute.has(route) ? Array.from(profilesByRoute.get(route)).sort().join(', ') : 'N/A';
        const destsStr = destinationsByRoute.has(route) ? Array.from(destinationsByRoute.get(route)).sort().join(', ') : 'N/A';
        routeDetailsHTML += `<div class="subsection" style="margin-top:0.5rem; padding:0.5rem; font-size:0.9em;">
                              <strong>Route: ${route}</strong><br>
                              Profiles: ${profilesStr}<br>
                              Destinations: ${destsStr}
                           </div>`;
    });


    serviceAnalyzerStopSummary_el_extra.innerHTML = `
        <strong>Stop: ${stopDetails.stopName || 'N/A'} (ID: ${stopID})</strong><br>
        <strong>Direction:</strong> ${stopDetails.direction || 'N/A'}<br>
        <strong>Total Schedule Entries at Stop:</strong> ${entries.length}<br>
        ${firstTime && lastTime ? `<strong>First Bus (any route):</strong> ${firstTime} &nbsp;&nbsp; <strong>Last Bus (any route):</strong> ${lastTime}<br>` : ''}
        <strong style="margin-top:0.75em; display:block;">Routes Serving This Stop (${routes.size}):</strong>
        <div style= padding-right:0.5em;">${routeDetailsHTML || '(None listed)'}</div>
    `;
}




// Sync input with select for Service Analyzer Stop
if (serviceAnalyzerStopSelect_el_extra && serviceAnalyzerStopInput_el_extra) {
    serviceAnalyzerStopSelect_el_extra.addEventListener('change', () => {
        // When select changes, update input to show "ID - Name" or just ID if name is the same
        const selectedOption = serviceAnalyzerStopSelect_el_extra.options[serviceAnalyzerStopSelect_el_extra.selectedIndex];
        serviceAnalyzerStopInput_el_extra.value = selectedOption.value ? selectedOption.value : ""; // Store ID in input
    });
    serviceAnalyzerStopInput_el_extra.addEventListener('input', () => { // Or 'blur'
        const typedValue = serviceAnalyzerStopInput_el_extra.value.trim();
        // Try to match typed value against stop ID (value of option) or text content
        const matchedOption = Array.from(serviceAnalyzerStopSelect_el_extra.options).find(opt => 
            opt.value === typedValue || opt.textContent.toLowerCase().includes(typedValue.toLowerCase())
        );
        serviceAnalyzerStopSelect_el_extra.value = matchedOption ? matchedOption.value : "";
    });
}


function onShowServiceAnalyzerSection_ExtraPage() {
    populateServiceAnalyzerDropdowns_ExtraPage();
    if (serviceAnalyzerStopSummary_el_extra) serviceAnalyzerStopSummary_el_extra.innerHTML = 'Select a stop.';
}

</script>
</body>
</html>
