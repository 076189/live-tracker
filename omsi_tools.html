<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMSI Countdown - Tools</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <link rel="manifest" href="/live-tracker/manifest-omsi.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OMSI Tools">
    <meta name="theme-color" content="#2c3e50">
    <link rel="apple-touch-icon" href="/live-tracker/assets/icons/apple-touch-icon-180x180.png">

    <style>
        @font-face {
            font-family: 'NJFont Medium Web';
            src: url('fonts/NJFont-Medium.ttf') format('truetype'); /* Relative path */
            font-weight: normal;font-style: normal;font-display: swap;
        }
        body {
            font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            margin:0;
        }
        .page-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        #top-menu-bar {
            background-color: rgba(0,0,0,0.25);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center;
            display: none; /* Hidden by default, shown after login */
        }
        .menu-button {
            cursor: pointer;
            background-color: #3498db;
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 0.25rem;
            font-size: 0.9rem;
            transition: background-color 0.2s;
            border: none;
            margin: 0.25rem;
        }
        .menu-button:hover {
            background-color: #2980b9;
        }

        .tool-content-section {
            display: none; /* All tool sections hidden by default */
        }

        #auth-section {
             margin-bottom: 1.5rem;
        }
        #current-profile-display-container {
            text-align: center;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background-color: rgba(255,255,255,0.05);
            border-radius: 0.25rem;
            display: none; /* Hidden by default, shown after login */
        }
        #current-profile-display { font-size: 0.9rem; opacity: 0.9; font-style: italic;}


        h1 { font-size: 2rem; margin-bottom: 1.5rem; font-weight: normal; text-align: center; color: #ffffff; }
        h2 { font-size: 1.5rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: normal; border-bottom: 1px solid #7f8c8d; padding-bottom: 0.25rem;}
        h3.subsection-title { font-size: 1.25rem; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: normal; color: #e0e0e0; border-bottom: 1px solid rgba(127,140,141,0.5); padding-bottom: 0.2rem;}


        .section {
            background-color: rgba(0,0,0,0.15);
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .subsection {
            background-color: rgba(0,0,0,0.1);
            padding: 1rem;
            border-radius: 0.375rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
             border: 1px solid rgba(127,140,141,0.2);
        }


        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;}
        .form-field-group { margin-bottom: 1rem; }


        label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.85rem;
            color: #bdc3c7;
        }

        input[type="text"],
        input[type="email"],
        input[type="password"],
        input[type="time"],
        input[type="color"],
        input[type="number"],
        select {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size:0.9rem;
        }
        input[type="color"] { height: 2.75rem; padding: 0.25rem; }
        #inputOperatingProfile, #analyticsOperatingProfileSelect { max-width: 100%;}
        #selectDayOffset, #selectRouteNameColour, #selectStopForDeparturesView,
        #selectStopForSpecificRouteColour,
        #selectGlobalRouteToDelete {
            max-width: 100%;
        }
        #editMasterStopIdSelect, #routesForStopSelect_SM { max-width: 100%; }
        #selectNewStopIdFormat_ARS, #selectStopToRemove_ARS {max-width: 100%;}
        #consolidateStopSelect, #consolidateRouteSelect {max-width: 100%;}
        /* Added for new Route Stops Explorer */
        #rse_selectRoute { max-width: 100%; }
        select option { background-color: #34495e; color: #ecf0f1; }


        #inputStopID,
        #bulkEditTargetStopID, #bulkEditTargetLineName,
        #findStopIdScheduleInput, #replaceStopIdScheduleInput,
        #gen_stopId, #inputNewStopId_ARS {
            text-transform: uppercase;
        }
        #gen_lineName, #gen_destinationName, #consolidateNewProfileInput {
            text-transform: none;
        }


        .button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin-right: 0.5rem; margin-top:0.5rem;
        }
        .button:hover { background-color: #2980b9; }
        .button.small-action { padding: 0.2rem 0.4rem; font-size: 0.8rem; margin: 0 0.15rem; line-height: 1; min-width: 20px; text-align:center;}
        .button.secondary { background-color: #e74c3c; }
        .button.secondary:hover { background-color: #c0392b; }
        .button.tertiary { background-color: #f39c12; }
        .button.tertiary:hover { background-color: #e67e22; }
        .button.neutral { background-color: #7f8c8d; }
        .button.neutral:hover { background-color: #95a5a6; color: #2c3e50; }


        .file-upload-label { display: inline-block; cursor: pointer; background-color: #95a5a6; color: #2c3e50; padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem; transition: background-color 0.2s; margin-bottom: 0.5rem; }
        .file-upload-label:hover { background-color: #7f8c8d; }
        #file-status { font-size: 0.9rem; margin-top: 0.25rem; margin-bottom:1rem; opacity: 0.9; min-height: 1.2em; }

        .actions-section { margin-top: 1.5rem; }
        #stageScheduleButton { background-color: #27ae60; }
        #stagingStatusMessage { text-align:center; margin-bottom: 1rem; font-size: 0.9em; color: #f1c40f; min-height:1.2em; }


        .info-section { margin-top:2rem; padding:1rem; background-color: rgba(0,0,0,0.1); border-radius:0.25rem; font-size:0.8rem; }
        .info-section h3 { font-size:1rem; margin-bottom:0.5rem; color: #ffffff; }
        .info-section p { line-height:1.6; color:#bdc3c7; }

        .tooltip { position: relative; display: inline-block; cursor: help; margin-left: 4px; font-size:0.8em; background-color:#7f8c8d; color:white; border-radius:50%; width:14px; height:14px; text-align:center; line-height:14px;}
        .tooltip .tooltiptext {
            visibility: hidden; width: 280px; background-color: #34495e; color: #fff;
            text-align: left; border-radius: 6px; padding: 8px; position: absolute;
            z-index: 10; bottom: 135%; left: 50%; margin-left: -140px; opacity: 0; transition: opacity 0.3s;
            font-size: 0.75rem; line-height: 1.4; border: 1px solid #7f8c8d;
        }
        .tooltip .tooltiptext::after {
            content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px;
            border-width: 5px; border-style: solid; border-color: #34495e transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .filter-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; margin-bottom: 1rem; align-items: end;}

        .current-details-display {
            margin-top: 0.5rem;
            font-size: 0.85em;
            background-color: rgba(0,0,0,0.2);
            padding: 0.5rem;
            border-radius: 0.25rem;
            color: #bdc3c7;
        }
        .current-details-display p { margin: 0.2rem 0; }
        .current-details-display span { font-style: italic; color: #ecf0f1; }

        .event-section div, .stop-status-section div,
        .route-colour-management-subsection div,
        .stop-specific-route-colour-subsection div,
        .view-stop-departures div, .analytics-subsection div {
            margin-bottom: 0.75rem;
        }
        .event-section label, .stop-status-section label,
        .route-colour-management-subsection label,
        .stop-specific-route-colour-subsection label,
        .view-stop-departures label, .analytics-subsection label {
             margin-bottom: 0.25rem;
        }


        #currentRouteColoursListContainer,
        #currentStopSpecificColoursListContainer,
        #duplicateEntriesResults {
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            padding: 0.75rem;
            margin-top: 1rem;
            max-height: 300px;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.05);
        }
        #currentRouteColoursList li,
        #currentStopSpecificColoursList ul,
        #currentStopSpecificColoursList li,
        #duplicateEntriesResults li {
            display: block;
            padding: 0.5rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #currentRouteColoursList li:last-child,
        #currentStopSpecificColoursList li:last-child,
        #duplicateEntriesResults li:last-child { border-bottom: none; }

        #currentStopSpecificColoursList .stop-group-title {
            font-weight: bold;
            margin-top: 0.5rem;
            padding-bottom: 0.2rem;
            border-bottom: 1px dashed #566573;
        }
        #currentStopSpecificColoursList .stop-group-title:first-child {
            margin-top: 0;
        }
        #currentStopSpecificColoursList ul {
            list-style-type: none;
            padding-left: 1rem;
            margin:0;
        }


        #duplicateEntriesResults .duplicate-set { margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 1px dashed #4A5568;}
        #duplicateEntriesResults .duplicate-set:last-child { border-bottom: none; }
        #duplicateEntriesResults .entry-detail { display: block; font-size: 0.85rem; margin-left: 1rem; opacity: 0.9;}


        .colour-preview-box {
            width: 20px;
            height: 20px;
            border: 1px solid #ecf0f1;
            margin-right: 10px;
            display: inline-block;
            vertical-align: middle;
        }
        #currentRouteColoursList .route-info,
        #currentStopSpecificColoursList .route-info {
            flex-grow: 1;
            display: inline-flex;
            align-items: center;
        }


        .route-tile-tools-list {
            display: inline-block;
            padding: 0.2em 0.55em;
            margin-right: 0.3em;
            margin-bottom: 0.3em;
            border-radius: 0.25rem;
            font-size: 0.8em;
            font-weight: bold;
            color: white;
            text-align: center;
            line-height: 1.3;
            min-width: 28px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.25);
            vertical-align: middle;
        }
        #stopDeparturesList li {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.1rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #stopDeparturesList li:last-child {
            border-bottom: none;
        }

        /* Enhanced Master Stop List Styles START */
        #masterStopListUL_SM li {
            padding: 0.75rem 0.5rem; /* Increased padding */
            border-bottom: 1px solid #34495e;
            transition: background-color 0.15s ease-in-out;
        }
        #masterStopListUL_SM li:last-child {
            border-bottom: none;
        }
        #masterStopListUL_SM li .stop-id-master { /* Style for Stop ID - now less prominent */
            font-weight: normal; /* Changed from bold */
            color: #bdc3c7;     /* Swapped color with stop-name-master */
            font-size: 0.95em;  /* Swapped font-size with stop-name-master */
        }
        #masterStopListUL_SM li .stop-name-master { /* Style for Stop Name - now more prominent */
            font-weight: bold;  /* Added bold */
            color: #ecf0f1;      /* Swapped color with stop-id-master */
            font-size: 1.05em; /* Swapped font-size with stop-id-master */
        }
        #masterStopListUL_SM li .stop-direction-master {
            font-style: italic;
            font-size: 0.85em;
            color: #95a5a6;
            margin-bottom: 0.3rem;
        }

        #masterStopListUL_SM li .stop-details-grid {
            display: grid;
            grid-template-columns: auto 1fr; /* For label and value */
            gap: 0.2rem 0.5rem; /* Row and column gap */
            font-size: 0.85em;
            margin-top: 0.4rem;
        }
        #masterStopListUL_SM li .detail-label {
            font-weight: normal; /* Changed from bold to normal */
            color: #bdc3c7;
            opacity: 0.8;
        }
        #masterStopListUL_SM li .detail-value {
            color: #ecf0f1;
        }
        #masterStopListUL_SM li .detail-value.status-closed {
            color: #e74c3c; /* Red for closed */
            font-weight: bold;
        }
        #masterStopListUL_SM li .detail-value.status-open {
            color: #2ecc71; /* Green for open */
        }

        #masterStopListUL_SM li .serving-routes-container {
            margin-top: 0.4rem;
            margin-bottom: 0.2rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3em;
            padding: 0.25rem 0;
        }
        /* Uses existing .route-tile-tools-list for the tiles inside .serving-routes-container */

        #masterStopListUL_SM li .service-times-info { /* This class is not used in the JS provided, keeping it just in case or for future */
            font-size: 0.8em;
            opacity: 0.9;
            margin-top: 0.3rem;
            padding: 0.25rem;
            background-color: rgba(0,0,0,0.1);
            border-radius: 0.2rem;
        }
        /* Action Buttons for Master Stop List */
        #masterStopListUL_SM li .stop-actions {
            margin-top: 0.75rem;
            padding-top: 0.5rem;
            border-top: 1px dashed rgba(127,140,141,0.3);
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        /* Enhanced Master Stop List Styles END */


        #routesServingStopListContainer_SM {
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.05);
            padding:0.75rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
        }
        #routesServingStopList_SM {
            list-style: none;
            padding: 0;
            margin:0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5em;
        }
        #routesServingStopList_SM li {
            padding: 0;
            border-bottom: none;
        }

        #schedule-generator-section h2,
        #schedule-generator-section h3.subsection-title,
        #schedule-generator-section h4 {
            color: #ecf0f1;
            border-bottom-color: #4A5568;
        }

        #schedule-generator-section label {
            display: block;
            color: #bdc3c7;
            margin-top: 10px;
            margin-bottom: 0.35rem;
            font-weight: 500;
            font-size: 0.85rem;
        }

        .schedule-generator-select {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        .schedule-generator-select option {
            background-color: #34495e;
            color: #ecf0f1;
        }

        .schedule-generator-input {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size: 0.9rem;
        }
        #gen_stopId.schedule-generator-input {
             text-transform: uppercase;
        }
        #gen_lineName.schedule-generator-input,
        #gen_destinationName.schedule-generator-input {
            text-transform: none;
        }


        .gen_interval-rule {
            border: 1px solid #4A5568;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 0.375rem;
            background-color: rgba(0,0,0,0.1);
        }

        .gen_input-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }


        #gen_resultsTable {
            width: 100%;
            margin-top: 1.5rem;
            border-collapse: collapse;
            color: #ecf0f1;
        }
        #gen_resultsTable th, #gen_resultsTable td {
            border: 1px solid #4A5568;
            padding: 8px 10px;
            text-align: left;
        }
        #gen_resultsTable th {
            background-color: #34495e;
            color: white;
            font-weight: 500;
        }
        #gen_resultsTable tbody tr:nth-child(odd) {
            background-color: rgba(0,0,0,0.1);
        }
         #gen_resultsTable tbody tr:nth-child(even) {
            background-color: rgba(0,0,0,0.2);
        }

        .gen_action-buttons {
            margin-top: 1.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }
        .gen_footer-note {
            text-align: center;
            margin-top: 1.5rem;
            font-size: 0.85em;
            color: #bdc3c7;
        }

        #newStopIdAvailability_ARS {
            font-size: 0.8em;
            min-height: 1.1em;
            margin-top: 0.25rem;
        }

        #sgCopierSourceRoutesContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5em;
            padding: 0.75rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            background-color: rgba(0,0,0,0.05);
            min-height: 40px;
        }

        .copier-route-tile {
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out, outline 0.1s ease-in-out;
            border: 1px solid transparent;
        }

        .copier-route-tile:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .copier-route-tile.selected-tile {
            outline: 2px solid #3498db;
            box-shadow: 0 0 0 2px #3498db, 0 2px 5px rgba(0,0,0,0.4);
        }

        #sgCopierSourceRoutesPlaceholder {
            width: 100%;
            text-align: center;
            opacity: 0.7;
            padding: 0.5rem;
        }

        #specificRouteColourTilesContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5em;
            padding: 0.75rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            background-color: rgba(0,0,0,0.05);
            min-height: 40px;
            margin-bottom: 1rem;
        }

        .specific-colour-route-tile {
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out, outline 0.1s ease-in-out;
            border: 1px solid transparent;
            cursor: pointer;
        }
        .specific-colour-route-tile:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .specific-colour-route-tile.selected-for-color-edit {
            outline: 2px solid #f39c12;
            box-shadow: 0 0 0 2px #f39c12, 0 2px 5px rgba(0,0,0,0.4);
        }
        #specificRouteColourTilesPlaceholder {
             width: 100%;
            text-align: center;
            opacity: 0.7;
            padding: 0.5rem;
        }

        /* START: Styles for Route Stops Explorer */
        #route-stops-explorer-section .form-grid {
            grid-template-columns: 1fr; /* Single column for route selection */
            margin-bottom: 1.5rem;
        }
        .route-stops-columns-container {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Two equal columns for stop lists */
            gap: 1.5rem;
        }
        .route-stops-column {
            background-color: rgba(0,0,0,0.1);
            padding: 1rem;
            border-radius: 0.375rem;
            border: 1px solid rgba(127,140,141,0.2);
        }
        .route-stops-column h4 {
            font-size: 1.1rem;
            color: #e0e0e0;
            margin-bottom: 0.75rem;
            border-bottom: 1px solid rgba(127,140,141,0.3);
            padding-bottom: 0.3rem;
        }
        .route-stops-column ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
            max-height: 400px; /* Or adjust as needed */
            overflow-y: auto;
        }
        .route-stops-column li {
            padding: 0.5rem 0.25rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        .route-stops-column li:last-child {
            border-bottom: none;
        }
        .route-stops-column .stop-name {
            font-weight: bold;
        }
        .route-stops-column .stop-id {
            font-size: 0.85em;
            opacity: 0.8;
            margin-left: 0.5em;
        }
        #rse_direction1_placeholder, #rse_direction2_placeholder {
            text-align: center;
            opacity: 0.7;
            padding: 1rem;
        }
        /* END: Styles for Route Stops Explorer */

    </style>
</head>
<body lang="en-GB">
    <div class="page-container">
        <h1>Bus Schedule Setup & Management</h1>

        <div id="auth-section" class="section">
            <h2>Admin Login</h2>
            <div id="login-form-container">
                <form id="adminLoginForm">
                    <div class="form-grid" style="grid-template-columns: 1fr;">
                        <div><label for="inputEmail">Email</label><input type="email" id="inputEmail" autocomplete="email"></div>
                        <div><label for="inputPassword">Password</label><input type="password" id="inputPassword" autocomplete="current-password"></div>
                    </div>
                    <button id="loginButton" type="submit" class="button">Login</button>
                </form>
                <p id="auth-status" style="margin-top: 0.5em; color: #f1c40f;"></p>
            </div>
            <div id="logout-container" style="display:none;">
                <p>Logged in as: <span id="loggedInUserEmail"></span></p>
                <button id="logoutButton" class="button secondary">Logout</button>
            </div>
        </div>

        <div id="current-profile-display-container" class="section">
            <p id="current-profile-display">Today's Auto Profile: (determining...)</p>
        </div>

        <div id="top-menu-bar">
            <div id="main-menu-buttons">
                <button class="menu-button" data-section="bulk-edit-tools-section">Bulk Edit & Colours</button>
                <button class="menu-button" data-section="view-departures-section">View Departures</button>
                <button class="menu-button" data-section="schedule-generator-section">Schedule Generator & Copier</button>
                <button class="menu-button" data-section="route-timetable-overwrite-section">Route Timetable Overwrite</button>
                <button class="menu-button" data-section="operating-profiles-section">View Operating Profiles</button>
                <button class="menu-button" data-section="deployment-tools-section">Deployment & Upload</button>
                <button class="menu-button" data-section="analytics-validation-section">Analytics & Validation</button>
                <button class="menu-button" data-section="stop-management-tool-section">Stop Management</button>
                <button class="menu-button" data-section="add-remove-stop-section">Add/Remove Stop</button>
                <button class="menu-button" data-section="global-route-deletion-section">Global Route Deletion</button>
                <button class="menu-button" data-section="route-stops-explorer-section">Route Stops Explorer</button> </div>
        </div>

        <div id="tool-sections-wrapper">

            <div id="route-stops-explorer-section" class="tool-content-section section">
                <h2>Route Stops Explorer</h2>
                <p style="opacity:0.8; margin-bottom:1.5rem; font-size:0.9em;">
                    Select a route to view the sequence of stops it serves in each direction.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">1. Select Route</h3>
                    <div class="form-grid">
                        <div>
                            <label for="rse_selectRoute">Route (LineName):</label>
                            <select id="rse_selectRoute" class="schedule-generator-select">
                                <option value="">-- Select Route --</option>
                                </select>
                        </div>
                    </div>
                </div>
                <div class="subsection">
                    <h3 class="subsection-title">2. Stops Served</h3>
                    <div class="route-stops-columns-container">
                        <div id="rse_direction1_container" class="route-stops-column">
                            <h4 id="rse_direction1_title">Direction 1: (Select Route)</h4>
                            <ul id="rse_direction1_stopsList">
                                </ul>
                            <p id="rse_direction1_placeholder">Select a route to view stops.</p>
                        </div>
                        <div id="rse_direction2_container" class="route-stops-column">
                            <h4 id="rse_direction2_title">Direction 2: (Select Route)</h4>
                            <ul id="rse_direction2_stopsList">
                                </ul>
                             <p id="rse_direction2_placeholder">Select a route to view stops.</p>
                        </div>
                    </div>
                </div>
                 <p id="rse_statusMessage" style="min-height:1.2em; margin-top: 0.75rem; font-weight:bold; text-align:center;"></p>
            </div>
            <div id="route-timetable-overwrite-section" class="tool-content-section section">
                <h2>Route Timetable Overwrite</h2>
                <p style="opacity:0.8; margin-bottom:1.5rem; font-size:0.9em;">
                    This tool replaces all scheduled times for a selected route, operating profile, and (optionally) specific destination with new timetable data from an uploaded file.
                    The uploaded file should be in .COUNT or .txt format. It's best if the file only contains data for the exact route, profile, and destination you intend to replace.
                    The tool will filter the uploaded data to only use entries matching your selections.
                </p>

                <div class="subsection">
                    <h3 class="subsection-title">1. Select Target for Timetable Overwrite</h3>
                    <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));">
                        <div>
                            <label for="rto_selectRoute">Route (LineName):</label>
                            <select id="rto_selectRoute" class="schedule-generator-select">
                                <option value="">-- Select Route --</option>
                            </select>
                        </div>
                        <div>
                            <label for="rto_selectProfile">Operating Profile:</label>
                            <select id="rto_selectProfile" class="schedule-generator-select">
                                <option value="">-- Select Route First --</option>
                            </select>
                        </div>
                        <div>
                            <label for="rto_selectDestination">Destination (Optional - for specific direction):</label>
                            <select id="rto_selectDestination" class="schedule-generator-select">
                                <option value="">-- All Destinations for Route/Profile --</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">2. Upload New Timetable File</h3>
                    <div style="margin-top: 1rem; margin-bottom: 1rem;">
                        <label for="rto_fileInput" class="file-upload-label">Choose New Timetable File (.COUNT, .txt)</label>
                        <input type="file" id="rto_fileInput" accept=".COUNT,.txt" style="display: none;">
                        <p id="rto_fileStatus" style="font-size: 0.9rem; margin-top: 0.25rem; opacity: 0.9; min-height: 1.2em;">No file selected.</p>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">3. Execute Overwrite</h3>
                    <button id="rto_overwriteButton" class="button tertiary" style="padding: 0.7rem 1.5rem;">Overwrite Timetable for Selected Criteria</button>
                    <p id="rto_statusMessage" style="min-height:1.2em; margin-top: 0.75rem; font-weight:bold;"></p>
                </div>
            </div>

            <div id="operating-profiles-section" class="tool-content-section section">
                <h2>Unique Operating Profiles Viewer</h2>
                <p style="opacity:0.8; margin-bottom:1.5rem; font-size:0.9em;">
                    This tool lists all unique "OperatingProfile" strings currently found in your working schedule.
                    This can help you see all the different day types or conditions your schedule caters to.
                </p>

                <div class="subsection">
                    <h3 class="subsection-title">Discovered Operating Profiles</h3>
                    <button id="refreshOperatingProfilesButton" class="button" style="margin-bottom: 1rem;">Refresh List</button>
                    <p id="operatingProfilesStatusMessage" style="min-height:1.2em; margin-bottom: 0.75rem; font-style: italic;"></p>
                    <div id="uniqueOperatingProfilesListContainer" style="border: 1px solid #4A5568; border-radius: 0.25rem; padding: 0.75rem; margin-top: 1rem; max-height: 400px; overflow-y: auto; background-color: rgba(0,0,0,0.05);">
                        <ul id="uniqueOperatingProfilesUL" style="list-style: disc; padding-left: 20px;">
                        </ul>
                    </div>
                </div>
            </div>

            <div id="bulk-edit-tools-section" class="tool-content-section">
                <div class="section bulk-edit-route-destination">
                    <h2>Update Destination for a Route</h2>
                    <div class="form-grid" style="grid-template-columns: 1fr 1.5fr 1.5fr auto; align-items:end; gap: 0.75rem;">
                        <div><label for="bulkEditTargetLineName">Target Line</label><input type="text" id="bulkEditTargetLineName" placeholder="e.g., 186" autocomplete="off"></div>
                        <div><label for="bulkEditOldDestination">Old Destination (optional)</label><input type="text" id="bulkEditOldDestination" placeholder="Blank to update all" autocomplete="off"></div>
                        <div><label for="bulkEditNewDestination">New Destination</label><input type="text" id="bulkEditNewDestination" placeholder="New destination" autocomplete="off"></div>
                        <div style="padding-bottom:0.05rem;"><button id="bulkUpdateRouteDestinationButton" class="button">Update Destination</button></div>
                    </div>
                </div>

                <div class="section route-colour-management-subsection">
                    <h2>Global Route Tile Colour Management</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">Define global custom colours for routes. These apply unless a stop-specific colour is set.</p>
                    <div class="form-grid" style="grid-template-columns: 1.5fr 1fr auto auto auto auto; align-items: end; gap: 0.75rem;">
                        <div><label for="selectRouteNameColour">Route Name</label><select id="selectRouteNameColour"><option value="">-- Select Route --</option></select></div>
                        <div><label for="inputRouteColour">Select Colour</label><input type="color" id="inputRouteColour" value="#73809C" autocomplete="off"></div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #73809C; color: #FFFFFF;" onclick="setGlobalRouteColour('#73809C')">Day Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #4CDBE6; color: #000000;" onclick="setGlobalRouteColour('#4CDBE6')">24 Hr / Night Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #AC5099; color: #FFFFFF;" onclick="setGlobalRouteColour('#AC5099')">School Bus</button>
                        </div>
                        <div style="padding-bottom:0.05rem;"><button id="saveRouteColourButton" class="button">Save Global Colour</button></div>
                    </div>
                    <div id="currentRouteColoursListContainer"><h3 class="subsection-title" style="font-size: 1.1rem; margin-bottom: 0.5rem;">Current Global Custom Colours</h3><ul id="currentRouteColoursList"></ul><p id="noCustomColoursMessage">No global custom colours set.</p></div>
                    <p id="routeColourStatusMessage" style="min-height:1.2em;"></p>
                </div>

                <div class="section stop-specific-route-colour-subsection">
                    <h2>Stop-Specific Route Tile Colours</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">Override global route colours for specific stops.</p>
                    <div>
                        <label for="selectStopForSpecificRouteColour">1. Select Stop:</label>
                        <select id="selectStopForSpecificRouteColour" class="schedule-generator-select">
                            <option value="">-- Select Stop --</option>
                        </select>
                    </div>
                    <div>
                        <label>2. Select Route(s) at this stop to colour (click one to enable delete option below):</label>
                        <div id="specificRouteColourTilesContainer">
                            <p id="specificRouteColourTilesPlaceholder">Select a stop to see its routes.</p>
                        </div>
                    </div>
                    <div style="margin-top: 0.5rem; margin-bottom: 1rem;">
                        <button id="deleteRouteFromStopButton" class="button secondary" style="display: none;">Delete Selected Route from This Stop</button>
                        <p id="deleteRouteFromStopStatusMessage" style="min-height:1.2em; margin-top:0.5rem; font-size:0.85em;"></p>
                    </div>

                    <div class="form-grid" style="grid-template-columns: 1fr auto auto auto auto; align-items:end; gap:0.75rem; margin-top:0.5rem;">
                        <div>
                            <label for="inputStopSpecificRouteColour">3. Select Colour:</label>
                            <input type="color" id="inputStopSpecificRouteColour" value="#73809C">
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #73809C; color: #FFFFFF;" onclick="setStopSpecificRouteColour('#73809C')">Day Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #4CDBE6; color: #000000;" onclick="setStopSpecificRouteColour('#4CDBE6')">24 Hr / Night Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #AC5099; color: #FFFFFF;" onclick="setStopSpecificRouteColour('#AC5099')">School Bus</button>
                        </div>
                        <div style="padding-bottom:0.05rem;">
                            <button id="saveStopSpecificRouteColourButton" class="button tertiary">Save Colour for Selected Route(s) at this Stop</button>
                        </div>
                    </div>
                    <p id="stopSpecificRouteColourStatusMessage" style="min-height:1.2em; margin-top:0.5rem;"></p>

                    <div id="currentStopSpecificColoursListContainer">
                        <h3 class="subsection-title" style="font-size: 1.1rem; margin-bottom: 0.5rem;">Current Stop-Specific Colour Overrides</h3>
                        <div id="currentStopSpecificColoursList">
                            <p id="noStopSpecificColoursMessage">No stop-specific colours are currently set.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div id="event-generator-section" class="tool-content-section" style="display:none !important;">
            </div>

            <div id="stop-status-section" class="tool-content-section" style="display:none !important;">
            </div>

            <div id="view-departures-section" class="tool-content-section">
                <div class="section view-stop-departures">
                    <h2>View Scheduled Departures by Stop</h2>
                    <div class="form-grid" style="grid-template-columns: 1fr 2fr; align-items: start; gap: 1.5rem;">
                        <div><label for="selectStopForDeparturesView">Bus Stop</label><select id="selectStopForDeparturesView"><option value="">-- Select Stop --</option></select></div>
                        <div><label>Departures (Sorted by Day Offset -> Profile Day -> Time)</label><div id="stopDeparturesListContainer" style="max-height: 400px; overflow-y: auto; border: 1px solid #4A5568; padding: 0.5rem; border-radius: 0.25rem;"><ul id="stopDeparturesList"></ul><p id="noDeparturesForStopMessage">Select stop to view.</p></div></div>
                    </div>
                </div>
            </div>

            <div id="schedule-generator-section" class="tool-content-section section">
                <h2>Transit Schedule Generator & Copier</h2>
                <p style="opacity:0.8; margin-bottom:1rem;">Create, export, copy, and adjust transit schedules.</p>
                <div class="subsection">
                    <h3 class="subsection-title">Base Data (First Entry for Generation)</h3>
                    <div class="form-field-group">
                        <label for="gen_stopNameSelect">Select Stop:</label>
                        <select id="gen_stopNameSelect" class="schedule-generator-select">
                            <option value="">-- Loading Stops --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label for="gen_stopId">StopID (auto-filled from selection):</label>
                        <input type="text" id="gen_stopId" class="schedule-generator-input" placeholder="Select stop from list" readonly>
                    </div>
                    <div class="gen_input-group">
                        <div>
                            <label for="gen_stopName">StopName (auto-filled from selection):</label>
                            <input type="text" id="gen_stopName" class="schedule-generator-input" placeholder="Select stop from list" readonly>
                        </div>
                        <div>
                            <label for="gen_direction">Direction (auto-filled from selection):</label>
                            <input type="text" id="gen_direction" class="schedule-generator-input" placeholder="Select stop from list" readonly>
                        </div>
                    </div>
                    <div class="form-field-group">
                        <label for="gen_routeSelect">Select Existing Route (populates Line Name below):</label>
                        <select id="gen_routeSelect" class="schedule-generator-select">
                            <option value="">-- Select Existing Route --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label for="gen_lineName">Line Name (Route - type new or select above):</label>
                        <input type="text" id="gen_lineName" class="schedule-generator-input" placeholder="e.g., 10A or NEW_ROUTE">
                    </div>
                    <div class="form-field-group">
                        <label for="gen_destinationSelect">Select Existing Destination (for chosen Line Name):</label>
                        <select id="gen_destinationSelect" class="schedule-generator-select">
                            <option value="">-- Enter/Select Route First --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label for="gen_destinationName">Destination Name (type new or select above):</label>
                        <input type="text" id="gen_destinationName" class="schedule-generator-input" placeholder="e.g., City Centre or NEW_DEST">
                    </div>
                    <div class="gen_input-group">
                        <div>
                            <label for="gen_operatingProfile">OperatingProfile:</label>
                            <input type="text" id="gen_operatingProfile" class="schedule-generator-input" placeholder="e.g., Weekday">
                        </div>
                        <div>
                            <label for="gen_initialScheduledTime">ScheduledTime (HHMM):</label>
                            <input type="text" id="gen_initialScheduledTime" class="schedule-generator-input" placeholder="e.g., 0845">
                        </div>
                        <div>
                            <label for="gen_initialDayOffset">DayOffset:</label>
                            <input type="number" id="gen_initialDayOffset" class="schedule-generator-input" min="0" value="0" placeholder="0">
                        </div>
                    </div>
                </div>
                <div class="subsection">
                    <h3 class="subsection-title">Interval Definitions for Additional Entries (Generation)</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.5rem;">
                        <strong>DayOffset Logic for Generated Times:</strong><br>
                        - If an interval rule starts <em>before</em> midnight (e.g., at 22:00) and generates times that cross into the 00:00-03:59 window, those specific post-midnight times get <code>DayOffset = 1</code>.<br>
                        - If an interval rule itself starts <em>at or after</em> midnight (e.g., "00:15", "01:00", up to "03:59"), all times it generates get <code>DayOffset = 0</code>.<br>
                        - All other generated times get <code>DayOffset = 0</code>.
                    </p>
                    <div id="gen_intervalRulesContainer"></div>
                    <button id="gen_addIntervalRuleButton" class="button" style="margin-top:10px;">+ Add Interval Rule</button>
                </div>
                <div class="subsection" id="schedule-copier-subsection-sg">
                    <h3 class="subsection-title">Copy & Adjust Schedules (from Working Schedule)</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        Select a source stop from the current working schedule, choose routes, copy, then select a target stop, adjust times, and paste the new entries back into the main working schedule.
                    </p>
                    <div class="form-field-group">
                        <label for="sgCopierSourceStopSelect">1. Source Stop:</label>
                        <select id="sgCopierSourceStopSelect" class="schedule-generator-select">
                            <option value="">-- Select Source Stop --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label>2. Routes serving Source Stop (click tiles to select/deselect for copying):</label>
                        <div id="sgCopierSourceRoutesContainer">
                            <p id="sgCopierSourceRoutesPlaceholder">Select a source stop to see routes.</p>
                        </div>
                    </div>
                    <button id="sgCopierCopySchedulesButton" class="button" style="margin-top: 0.5rem; margin-bottom:1rem;">Copy Selected Schedules from Source</button>
                    <hr style="margin: 1.5rem 0; border-color: rgba(255,255,255,0.1);">
                    <div class="form-field-group">
                        <label for="sgCopierTargetStopSelect">3. Target Stop:</label>
                        <select id="sgCopierTargetStopSelect" class="schedule-generator-select">
                            <option value="">-- Select Target Stop --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label for="sgCopierTimeAdjustmentInput">4. Time Adjustment (minutes, e.g., +5 or -10):</label>
                        <input type="text" id="sgCopierTimeAdjustmentInput" class="schedule-generator-input" placeholder="e.g., +3 or -2" value="0">
                    </div>
                    <button id="sgCopierPasteSchedulesButton" class="button tertiary" style="margin-top: 0.5rem;">Paste Schedules to Target Stop (in Working Schedule)</button>
                    <div id="sgCopierStatusMessage" style="margin-top: 1rem; padding: 0.5rem; background-color: rgba(0,0,0,0.08); border-radius: 0.25rem; min-height: 1.5em; text-align: center;">
                        Status will appear here.
                    </div>
                </div>
                <div class="subsection">
                    <div class="gen_action-buttons">
                        <button id="gen_generateScheduleButton" class="button">Generate Schedule</button>
                        <button id="gen_exportToCountButton" class="button" style="background-color: #27ae60;">Export to .COUNT</button>
                        <button id="gen_addToWorkingScheduleButton" class="button" style="background-color: #1abc9c;">Add Generated to Working Schedule</button>
                        <button id="gen_getWorkingScheduleButton" class="button" style="background-color: #9b59b6;">Load Full Schedule to Generator Table</button>
                        <button id="gen_loadStopScheduleButton" class="button" style="background-color: #34495e;">Load Selected Stop's Schedule to Table</button>
                        <button id="gen_clearAllDataButton" class="button secondary">Clear All Generator Data & Table</button>
                    </div>
                    <h3 class="subsection-title" style="margin-top:1.5rem;">Generated Schedule / Loaded Data Table</h3>
                    <div style="max-height: 400px; overflow-y: auto;">
                        <table id="gen_resultsTable">
                            <thead>
                                <tr>
                                    <th>StopID</th><th>StopName</th><th>Direction</th><th>LineName</th><th>DestinationName</th><th>ScheduledTime (HH:MM)</th><th>OperatingProfile</th><th>DayOffset</th><th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
                <div class="gen_footer-note">
                    <p>Generator data (base data, intervals, table content) is saved in your browser's local storage. Copied schedules are added directly to the main "Working Schedule".</p>
                </div>
            </div>

            <div id="deployment-tools-section" class="tool-content-section">
                <div class="section count-file-upload">
                    <h2>Upload Full Schedule</h2>
                    <p style="font-size:0.8em; margin-bottom:0.5em;">Replaces current working schedule. Ensure file has correct headers: StopID, StopName, Direction, LineName, DestinationName, ScheduledTime, OperatingProfile, DayOffset (optional).</p>
                    <label for="count-file-input" class="file-upload-label">Choose .COUNT or .txt File</label>
                    <input type="file" id="count-file-input" accept=".COUNT,.txt" style="display: none;">
                    <p id="file-status">No file selected.</p>
                </div>
                <div class="actions-section section">
                    <h2>Schedule Deployment Actions</h2>
                    <div id="stagingStatusMessage" style="min-height:1.2em;">Checking status...</div>
                    <button id="stageScheduleButton" class="button">Stage Working Schedule</button>
                    <button id="applyNowButton" class="button tertiary">Apply Staged Live NOW</button>
                    <hr style="margin: 1.5rem 0; border-color: rgba(255,255,255,0.1);">
                    <button id="viewArrivalsButton" class="button">View Arrivals Board</button>
                </div>
            </div>

            <div id="analytics-validation-section" class="tool-content-section">
                <div class="section">
                    <h2>Schedule Analytics & Validation</h2>
                    <div class="subsection analytics-subsection">
                        <h3 class="subsection-title">Duplicate Entry Detection</h3>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <button id="detectDuplicatesButton" class="button">Find Duplicate Entries</button>
                            <button id="removeDuplicateEntriesButton" class="button secondary">Remove All Duplicates (Keep First)</button>
                        </div>
                        <p id="removeDuplicatesStatusMessage" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                        <div id="duplicateEntriesResults" style="margin-top: 0.75rem;">
                            <p>Click "Find Duplicate Entries" to scan the current working schedule.</p>
                        </div>
                    </div>
                    <div class="subsection">
                        <h3 class="subsection-title">Consolidate Operating Days for Route at Stop</h3>
                        <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                            Select a stop and a route. This tool will find entries with the same time, destination, and day offset, and consolidate their Operating Profiles into one entry, removing the redundant ones.
                        </p>
                        <div class="form-grid" style="grid-template-columns: 1fr 1fr 1fr auto; align-items: end; gap: 0.75rem;">
                            <div>
                                <label for="consolidateStopSelect">Select Stop ID:</label>
                                <select id="consolidateStopSelect" class="schedule-generator-select"></select>
                            </div>
                            <div>
                                <label for="consolidateRouteSelect">Select Route:</label>
                                <select id="consolidateRouteSelect" class="schedule-generator-select"></select>
                            </div>
                            <div>
                                <label for="consolidateNewProfileInput">New Combined Operating Profile:</label>
                                <input type="text" id="consolidateNewProfileInput" class="schedule-generator-input" placeholder="e.g., MF,Sa,Su">
                            </div>
                            <div style="padding-bottom:0.05rem;">
                                <button id="consolidateOperatingDaysButton" class="button tertiary">Consolidate</button>
                            </div>
                        </div>
                        <p id="consolidateOpDaysStatusMessage" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                    </div>
                </div>
            </div>

            <div id="stop-management-tool-section" class="tool-content-section">
                <div class="section">
                    <h2>Master List of Unique Stops</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.75rem;">
                        This list is generated from the unique Stop IDs in the current working schedule.
                        It shows details for each unique Stop ID.
                    </p>
                    <div class="filter-controls" style="grid-template-columns: 1fr auto; gap: 0.75rem; margin-bottom: 0.5rem;">
                        <input type="text" id="masterStopListFilterInput_SM" placeholder="Filter by Stop ID, Name, Route, Status...">
                        <button id="refreshMasterStopListButton_SM" class="button neutral">Refresh List</button>
                    </div>
                    <div id="masterStopListContainer_SM" class="subsection" style="max-height: 600px; overflow-y: auto; padding: 0.5rem; background-color: rgba(0,0,0,0.05);">
                        <ul id="masterStopListUL_SM" style="list-style: none; padding: 0;">
                        </ul>
                    </div>
                    <p id="masterStopListStatus_SM" style="text-align: center; margin-top: 0.5rem; min-height: 1.2em;">Click "Refresh List" to load stops.</p>
                </div>

                <div class="section">
                    <h2>Find and Replace Stop IDs in Working Schedule</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.75rem;">
                        This utility modifies the 'Working Schedule'. It changes all occurrences of an old Stop ID to a new Stop ID.
                        The Stop Name and Direction for entries with the new Stop ID will be updated based on the first found instance of the 'New Stop ID' in the schedule.
                    </p>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr auto; align-items: end; gap: 0.75rem;">
                        <div><label for="findStopIdScheduleInput_SM">Stop ID to Find in Schedule</label><input type="text" id="findStopIdScheduleInput_SM" placeholder="e.g., OLDSTOPID"></div>
                        <div><label for="replaceStopIdScheduleInput_SM">Replace with New Stop ID</label><input type="text" id="replaceStopIdScheduleInput_SM" placeholder="e.g., NEWSTOPID"></div>
                        <div style="padding-bottom:0.05rem;"><button id="findReplaceStopIdScheduleButton_SM" class="button tertiary">Execute Find & Replace</button></div>
                    </div>
                    <p id="findReplaceStatusMessage_SM" style="min-height: 1.2em; margin-top: 0.5rem;">-</p>
                </div>

                <div class="section" style="display:none !important;">
                    <h2>Stop Information: Serving Routes</h2>
                </div>
            </div>

            <div id="add-remove-stop-section" class="tool-content-section">
                <div class="section">
                    <h2>Add or Remove Stop Details</h2>
                    <div class="subsection">
                        <h3 class="subsection-title">Add New Stop Details</h3>
                        <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                            Define a new stop. A placeholder schedule entry will be added to make it available in selectors.
                            The Stop ID must be unique.
                        </p>
                        <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                            <div> <label for="selectNewStopIdFormat_ARS">Stop ID Format/Prefix</label>
                                <div style="display: flex; align-items: flex-end; gap: 0.5rem;">
                                    <select id="selectNewStopIdFormat_ARS" class="schedule-generator-select" style="flex-grow: 1;">
                                        <option value="NUM">Numeric (e.g., 101-99999)</option>
                                        <option value="BP">BP Prefix (e.g., BP1-BP99999)</option>
                                        <option value="LE">LE Prefix (e.g., LE1-LE99999)</option>
                                        <option value="RO">RO Prefix (e.g., RO1-RO99999)</option>
                                    </select>
                                    <button id="buttonSuggestStopId_ARS" class="button neutral" style="padding: 0.5rem 0.8rem; margin-bottom: 0px; height: calc(0.5rem * 2 + 0.9rem + 2px); line-height: 0.9rem;">Suggest ID</button>
                                </div>
                            </div>
                            <div> <label for="inputNewStopId_ARS">New Stop ID (type or use suggest)</label>
                                <input type="text" id="inputNewStopId_ARS" class="schedule-generator-input" placeholder="e.g., NEWSTOP123" autocomplete="off">
                                <p id="newStopIdAvailability_ARS" style="font-size: 0.8em; min-height: 1.1em; margin-top: 0.25rem;"></p>
                            </div>
                            <div>
                                <label for="inputNewStopName_ARS">New Stop Name</label>
                                <input type="text" id="inputNewStopName_ARS" class="schedule-generator-input" placeholder="e.g., Main Street Library" autocomplete="off">
                            </div>
                            <div>
                                <label for="inputNewStopDirection_ARS">New Stop Direction (Towards)</label>
                                <input type="text" id="inputNewStopDirection_ARS" class="schedule-generator-input" placeholder="e.g., Town Centre" autocomplete="off">
                            </div>
                        </div>
                        <div style="margin-top: 1rem;">
                            <button id="buttonAddNewStop_ARS" class="button">Add New Stop Details</button>
                        </div>
                        <p id="addNewStopStatus_ARS" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                    </div>
                    <hr style="margin: 2rem 0; border-color: rgba(255,255,255,0.1);">
                    <div class="subsection">
                        <h3 class="subsection-title">Remove Stop & All Its Schedule Entries</h3>
                        <div class="form-field-group">
                            <label for="selectStopToRemove_ARS">Select Stop to Remove:</label>
                            <select id="selectStopToRemove_ARS" class="schedule-generator-select">
                                <option value="">-- Select Stop --</option>
                            </select>
                        </div>
                        <button id="buttonRemoveStop_ARS" class="button secondary">Remove Selected Stop & Its Schedule Entries</button>
                        <p id="removeStopStatus_ARS" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                    </div>
                </div>
            </div>

            <div id="global-route-deletion-section" class="tool-content-section">
                <div class="section">
                    <h2>Global Route Deletion</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        Select a route to remove ALL of its schedule entries from ALL stops.
                        This will also remove its global custom colour and any stop-specific colour overrides for this route.
                        <strong>This action is highly destructive and cannot be easily undone.</strong>
                    </p>
                    <div class="form-field-group">
                        <label for="selectGlobalRouteToDelete">Select Route to Delete Globally:</label>
                        <select id="selectGlobalRouteToDelete" class="schedule-generator-select">
                            <option value="">-- Select Route --</option>
                        </select>
                    </div>
                    <button id="deleteEntireRouteButton" class="button secondary" style="margin-top: 0.5rem;">Delete Entire Selected Route Globally</button>
                    <p id="deleteEntireRouteStatusMessage" style="min-height:1.2em; margin-top:0.75rem;"></p>
                </div>
            </div>
        </div>
    </div> </body>

<script type="module">
      // Firebase App initialization
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s", // Replace with your actual Firebase API Key
        authDomain: "omsi-c5505.firebaseapp.com", // Replace with your actual Firebase Auth Domain
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app", // Replace with your actual Firebase Database URL
        projectId: "omsi-c5505", // Replace with your actual Firebase Project ID
        storageBucket: "omsi-c5505.appspot.com", // Replace with your actual Firebase Storage Bucket
        messagingSenderId: "503595375440", // Replace with your actual Firebase Messaging Sender ID
        appId: "1:503595375440:web:356be6684b77ff5909ea55", // Replace with your actual Firebase App ID
        measurementId: "G-VN7X65V3F9" // Replace with your actual Firebase Measurement ID
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);

      window.firebaseOMSI = {
          database: database, auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut
      };
      console.log("Firebase Initialized for OMSI Tools.");
document.dispatchEvent(new CustomEvent('firebaseReady', { detail: window.firebaseOMSI }));
</script> 
<script>  

// --- DOM Elements ---
const countFileInput = document.getElementById('count-file-input');
const fileStatusElement = document.getElementById('file-status');
const currentProfileDisplayContainer = document.getElementById('current-profile-display-container');
const currentProfileDisplayElement = document.getElementById('current-profile-display');

const refreshOperatingProfilesButton = document.getElementById('refreshOperatingProfilesButton');
const operatingProfilesStatusMessage = document.getElementById('operatingProfilesStatusMessage');
const uniqueOperatingProfilesUL = document.getElementById('uniqueOperatingProfilesUL');

const bulkEditTargetLineNameInput = document.getElementById('bulkEditTargetLineName');
const bulkEditOldDestinationInput = document.getElementById('bulkEditOldDestination');
const bulkEditNewDestinationInput = document.getElementById('bulkEditNewDestination');
const bulkUpdateRouteDestinationButton = document.getElementById('bulkUpdateRouteDestinationButton');

const rto_selectRoute = document.getElementById('rto_selectRoute');
const rto_selectProfile = document.getElementById('rto_selectProfile');
const rto_selectDestination = document.getElementById('rto_selectDestination');
const rto_fileInput = document.getElementById('rto_fileInput');
const rto_fileStatus = document.getElementById('rto_fileStatus');
const rto_overwriteButton = document.getElementById('rto_overwriteButton');
const rto_statusMessage = document.getElementById('rto_statusMessage');

const stageScheduleButton = document.getElementById('stageScheduleButton');
const applyNowButton = document.getElementById('applyNowButton');
const viewArrivalsButton = document.getElementById('viewArrivalsButton');
const stagingStatusMessage = document.getElementById('stagingStatusMessage');

const selectRouteNameColour = document.getElementById('selectRouteNameColour');
const inputRouteColour = document.getElementById('inputRouteColour');
const saveRouteColourButton = document.getElementById('saveRouteColourButton');
const currentRouteColoursList = document.getElementById('currentRouteColoursList');
const noCustomColoursMessage = document.getElementById('noCustomColoursMessage');
const routeColourStatusMessage = document.getElementById('routeColourStatusMessage');

const selectStopForSpecificRouteColour = document.getElementById('selectStopForSpecificRouteColour');
const specificRouteColourTilesContainer = document.getElementById('specificRouteColourTilesContainer');
const specificRouteColourTilesPlaceholder = document.getElementById('specificRouteColourTilesPlaceholder');
const inputStopSpecificRouteColour = document.getElementById('inputStopSpecificRouteColour');
const saveStopSpecificRouteColourButton = document.getElementById('saveStopSpecificRouteColourButton');
const stopSpecificRouteColourStatusMessage = document.getElementById('stopSpecificRouteColourStatusMessage');
const currentStopSpecificColoursListContainer = document.getElementById('currentStopSpecificColoursListContainer');
const currentStopSpecificColoursList = document.getElementById('currentStopSpecificColoursList');
const noStopSpecificColoursMessageEl = document.getElementById('currentStopSpecificColoursListContainer')?.querySelector('#noStopSpecificColoursMessage');

const deleteRouteFromStopButton = document.getElementById('deleteRouteFromStopButton');
const deleteRouteFromStopStatusMessage = document.getElementById('deleteRouteFromStopStatusMessage');

const selectStopForDeparturesView = document.getElementById('selectStopForDeparturesView');
const stopDeparturesList = document.getElementById('stopDeparturesList');
const noDeparturesForStopMessage = document.getElementById('noDeparturesForStopMessage');

const topMenuBar = document.getElementById('top-menu-bar');
const adminLoginSection = document.getElementById('auth-section');
const loginFormContainer = document.getElementById('login-form-container');
const logoutContainer = document.getElementById('logout-container');
const loginButton = document.getElementById('loginButton');
const logoutButton = document.getElementById('logoutButton');
const inputEmail = document.getElementById('inputEmail');
const inputPassword = document.getElementById('inputPassword');
const authStatus = document.getElementById('auth-status');
const loggedInUserEmailDisplay = document.getElementById('loggedInUserEmail');
const mainMenuButtons = document.querySelectorAll('#main-menu-buttons .menu-button');
const allToolContentSections = document.querySelectorAll('.tool-content-section');

const detectDuplicatesButton = document.getElementById('detectDuplicatesButton');
const duplicateEntriesResults = document.getElementById('duplicateEntriesResults');
const removeDuplicateEntriesButton = document.getElementById('removeDuplicateEntriesButton');
const removeDuplicatesStatusMessage = document.getElementById('removeDuplicatesStatusMessage');

const consolidateStopSelect = document.getElementById('consolidateStopSelect');
const consolidateRouteSelect = document.getElementById('consolidateRouteSelect');
const consolidateNewProfileInput = document.getElementById('consolidateNewProfileInput');
const consolidateOperatingDaysButton = document.getElementById('consolidateOperatingDaysButton');
const consolidateOpDaysStatusMessage = document.getElementById('consolidateOpDaysStatusMessage');

const masterStopListFilterInput_SM = document.getElementById('masterStopListFilterInput_SM');
const refreshMasterStopListButton_SM = document.getElementById('refreshMasterStopListButton_SM');
const masterStopListUL_SM = document.getElementById('masterStopListUL_SM');
const masterStopListStatus_SM = document.getElementById('masterStopListStatus_SM');

const findStopIdScheduleInput_SM = document.getElementById('findStopIdScheduleInput_SM');
const replaceStopIdScheduleInput_SM = document.getElementById('replaceStopIdScheduleInput_SM');
const findReplaceStopIdScheduleButton_SM = document.getElementById('findReplaceStopIdScheduleButton_SM');
const findReplaceStatusMessage_SM = document.getElementById('findReplaceStatusMessage_SM');

const selectNewStopIdFormat_ARS = document.getElementById('selectNewStopIdFormat_ARS');
const buttonSuggestStopId_ARS = document.getElementById('buttonSuggestStopId_ARS');
const inputNewStopId_ARS = document.getElementById('inputNewStopId_ARS');
const newStopIdAvailability_ARS = document.getElementById('newStopIdAvailability_ARS');
const inputNewStopName_ARS = document.getElementById('inputNewStopName_ARS');
const inputNewStopDirection_ARS = document.getElementById('inputNewStopDirection_ARS');
const buttonAddNewStop_ARS = document.getElementById('buttonAddNewStop_ARS');
const addNewStopStatus_ARS = document.getElementById('addNewStopStatus_ARS');

const selectStopToRemove_ARS = document.getElementById('selectStopToRemove_ARS');
const buttonRemoveStop_ARS = document.getElementById('buttonRemoveStop_ARS');
const removeStopStatus_ARS = document.getElementById('removeStopStatus_ARS');

const sgCopierSourceStopSelect = document.getElementById('sgCopierSourceStopSelect');
const sgCopierSourceRoutesContainer = document.getElementById('sgCopierSourceRoutesContainer');
const sgCopierSourceRoutesPlaceholder = document.getElementById('sgCopierSourceRoutesPlaceholder');
const sgCopierCopySchedulesButton = document.getElementById('sgCopierCopySchedulesButton');
const sgCopierTargetStopSelect = document.getElementById('sgCopierTargetStopSelect');
const sgCopierTimeAdjustmentInput = document.getElementById('sgCopierTimeAdjustmentInput');
const sgCopierPasteSchedulesButton = document.getElementById('sgCopierPasteSchedulesButton');
const sgCopierStatusMessage = document.getElementById('sgCopierStatusMessage');

const selectGlobalRouteToDelete = document.getElementById('selectGlobalRouteToDelete');
const deleteEntireRouteButton = document.getElementById('deleteEntireRouteButton');
const deleteEntireRouteStatusMessage = document.getElementById('deleteEntireRouteStatusMessage');

const rse_selectRoute = document.getElementById('rse_selectRoute');
const rse_direction1_container = document.getElementById('rse_direction1_container');
const rse_direction1_title = document.getElementById('rse_direction1_title');
const rse_direction1_stopsList = document.getElementById('rse_direction1_stopsList');
const rse_direction1_placeholder = document.getElementById('rse_direction1_placeholder');
const rse_direction2_container = document.getElementById('rse_direction2_container');
const rse_direction2_title = document.getElementById('rse_direction2_title');
const rse_direction2_stopsList = document.getElementById('rse_direction2_stopsList');
const rse_direction2_placeholder = document.getElementById('rse_direction2_placeholder');
const rse_statusMessage = document.getElementById('rse_statusMessage');

// --- Global State ---
let currentUser = null;
let currentWorkingSchedule = [];
let ukBankHolidaysData = { dates: [], titles: {} };
const schoolHolidayDateRanges = [ ]; // Example: { start: '2024-07-22', end: '2024-09-02' }
let closedStopIDs = [];
let globalCustomRouteColours = {};
let stopSpecificRouteColours = {};
let uniqueStopsMasterList_SM = [];
let autoApplyIntervalId = null;
let copiedScheduleEntries = [];

// --- Constants ---
const LOCAL_STORAGE_ACTIVE_SECTION_KEY = 'omsiToolsActiveSection';
const FB_PATH_LIVE_SCHEDULE_DATA = '/liveSchedule/allScheduledBusData';
const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
const FB_PATH_PENDING_SCHEDULE_DATA = '/pendingSchedule/allScheduledBusData';
const FB_PATH_PENDING_UNIQUE_STOPS = '/pendingSchedule/uniqueBusStops';
const FB_PATH_PENDING_TIMESTAMP = '/pendingSchedule/uploadTimestamp';
const FB_PATH_APPSTATE_STATUS = '/appState/scheduleStatus';
const FB_PATH_APPSTATE_LAST_UPDATED = '/appState/scheduleLastUpdated';
const FB_PATH_APPSTATE_CLOSED_STOPS = '/appState/closedStopIDs';
const FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS = '/settings/customRouteColours';
const FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS = '/settings/stopSpecificRouteColours';

const initialRouteColourMapForTools = {};
const DEFAULT_ROUTE_COLOUR_TOOLS = "#73809C";
const NIGHT_BUS_BLUE_COLOR = (initialRouteColourMapForTools["N35"] || "#4CDBE6").toUpperCase();
const DAY_BUS_GREY_COLOR = DEFAULT_ROUTE_COLOUR_TOOLS.toUpperCase();

// --- START: Schedule Generator (from COUNT_generator.html) ---
let gen_ruleCounter = 0;
let gen_currentScheduleEntries = [];
const GEN_APP_DATA_KEY = 'transitScheduleAppData_tools_v1';
let gen_isInitialized = false;

let rto_uploadedScheduleData = [];

// --- START: Schedule Generator Population & Interaction ---
function gen_populateStopNameSelect() {
    const selectEl = document.getElementById('gen_stopNameSelect');
    if (!selectEl) return;

    const previouslySelectedStopId = selectEl.value;
    selectEl.innerHTML = '<option value="">-- Select Stop --</option>';

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        selectEl.innerHTML = '<option value="">-- No Stops Loaded --</option>';
        const stopIdEl = document.getElementById('gen_stopId');
        const stopNameEl = document.getElementById('gen_stopName');
        const directionEl = document.getElementById('gen_direction');
        if (stopIdEl) stopIdEl.value = '';
        if (stopNameEl) stopNameEl.value = '';
        if (directionEl) directionEl.value = '';
        gen_populateRouteSelect();
        return;
    }

    const stopMap = new Map();
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && !stopMap.has(entry.stopID.toUpperCase())) {
            stopMap.set(entry.stopID.toUpperCase(), {
                id: entry.stopID,
                name: entry.stopName || entry.stopID,
                direction: entry.direction || ""
            });
        }
    });

    const sortedStops = Array.from(stopMap.values()).sort((a, b) => {
        const nameA = String(a.name || "").toLowerCase();
        const nameB = String(b.name || "").toLowerCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        return 0;
    });

    sortedStops.forEach(stop => {
        const opt = document.createElement('option');
        opt.value = stop.id;
        opt.textContent = `${stop.name} (${stop.id})`;
        opt.dataset.stopname = stop.name;
        opt.dataset.direction = stop.direction;
        selectEl.appendChild(opt);
    });

    if (previouslySelectedStopId && stopMap.has(previouslySelectedStopId.toUpperCase())) {
        selectEl.value = previouslySelectedStopId;
    }
    selectEl.dispatchEvent(new Event('change'));
}

function displayUniqueOperatingProfiles() {
    if (!currentUser) {
        if (operatingProfilesStatusMessage) operatingProfilesStatusMessage.textContent = "Please log in to view operating profiles.";
        if (uniqueOperatingProfilesUL) uniqueOperatingProfilesUL.innerHTML = '';
        return;
    }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        if (operatingProfilesStatusMessage) operatingProfilesStatusMessage.textContent = "Working schedule is empty. No operating profiles to display.";
        if (uniqueOperatingProfilesUL) uniqueOperatingProfilesUL.innerHTML = '<li>No schedule data loaded.</li>';
        return;
    }

    const profileStrings = new Set();
    currentWorkingSchedule.forEach(entry => {
        if (entry.OperatingProfile && typeof entry.OperatingProfile === 'string' && entry.OperatingProfile.trim() !== '') {
            profileStrings.add(entry.OperatingProfile.trim());
        }
    });

    const sortedProfiles = Array.from(profileStrings).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

    if (uniqueOperatingProfilesUL) {
        uniqueOperatingProfilesUL.innerHTML = '';
        if (sortedProfiles.length > 0) {
            sortedProfiles.forEach(profile => {
                const li = document.createElement('li');
                li.textContent = profile;
                uniqueOperatingProfilesUL.appendChild(li);
            });
            if (operatingProfilesStatusMessage) operatingProfilesStatusMessage.textContent = `Found ${sortedProfiles.length} unique operating profile string(s).`;
        } else {
            uniqueOperatingProfilesUL.innerHTML = '<li>No operating profiles found in the current schedule.</li>';
            if (operatingProfilesStatusMessage) operatingProfilesStatusMessage.textContent = "No operating profiles found.";
        }
    }
}

function gen_populateRouteSelect() {
    const routeSelectEl = document.getElementById('gen_routeSelect');
    if (!routeSelectEl) return;

    const previouslySelectedRouteInDropdown = routeSelectEl.value;
    // const currentLineNameInInput = document.getElementById('gen_lineName')?.value || ""; // Not strictly needed here for population

    routeSelectEl.innerHTML = '<option value="">-- Select Existing Route --</option>';

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        routeSelectEl.innerHTML = '<option value="">-- No Routes in Schedule --</option>';
        const lineNameInputEl = document.getElementById('gen_lineName');
        if (lineNameInputEl) lineNameInputEl.dispatchEvent(new Event('input'));
        return;
    }

    const uniqueRoutes = [...new Set(currentWorkingSchedule.map(e => e.lineName))]
        .filter(Boolean)
        .sort(compareLineNames);

    uniqueRoutes.forEach(lineName => {
        const opt = document.createElement('option');
        opt.value = lineName;
        opt.textContent = lineName;
        routeSelectEl.appendChild(opt);
    });

    const lineNameInputEl = document.getElementById('gen_lineName');
    if (lineNameInputEl && lineNameInputEl.value && uniqueRoutes.includes(lineNameInputEl.value)) {
        routeSelectEl.value = lineNameInputEl.value;
    } else if (previouslySelectedRouteInDropdown && uniqueRoutes.includes(previouslySelectedRouteInDropdown)) {
        routeSelectEl.value = previouslySelectedRouteInDropdown;
        if (lineNameInputEl) lineNameInputEl.value = routeSelectEl.value;
    } else {
        if (lineNameInputEl) lineNameInputEl.value = routeSelectEl.value;
    }

    if(lineNameInputEl) lineNameInputEl.dispatchEvent(new Event('input', { bubbles:true, cancelable:true }));
}


function gen_populateDestinationSelect() {
    const lineNameInputEl = document.getElementById('gen_lineName');
    const destSelectEl = document.getElementById('gen_destinationSelect');
    if (!lineNameInputEl || !destSelectEl) return;

    const selectedRoute = lineNameInputEl.value;
    const previouslySelectedDestInDropdown = destSelectEl.value;

    destSelectEl.innerHTML = '';

    if (!selectedRoute) {
        destSelectEl.innerHTML = '<option value="">-- Enter/Select Route First --</option>';
        return;
    }

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        destSelectEl.innerHTML = '<option value="">-- No Schedule Data --</option>';
        return;
    }

    const relevantEntries = currentWorkingSchedule.filter(e =>
        e.lineName === selectedRoute && e.destinationName
    );

    const uniqueDestinations = [...new Set(relevantEntries.map(e => e.destinationName))]
        .sort((a, b) => String(a || "").toLowerCase().localeCompare(String(b || "").toLowerCase()));

    if (uniqueDestinations.length === 0) {
        destSelectEl.innerHTML = `<option value="">-- No Known Destinations for Route ${selectedRoute} --</option>`;
    } else {
        destSelectEl.innerHTML = '<option value="">-- Select Existing Destination --</option>';
        uniqueDestinations.forEach(destName => {
            const opt = document.createElement('option');
            opt.value = destName;
            opt.textContent = destName;
            destSelectEl.appendChild(opt);
        });
    }

    const destNameInputEl = document.getElementById('gen_destinationName');
    if (destNameInputEl && destNameInputEl.value && uniqueDestinations.includes(destNameInputEl.value)) {
        destSelectEl.value = destNameInputEl.value;
    } else if (previouslySelectedDestInDropdown && uniqueDestinations.includes(previouslySelectedDestInDropdown)) {
        destSelectEl.value = previouslySelectedDestInDropdown;
        if (destNameInputEl) destNameInputEl.value = destSelectEl.value;
    } else {
         if (destNameInputEl) destNameInputEl.value = destSelectEl.value;
    }
}


function gen_attachEventListenersForGeneratorSelects() {
    const stopNameSelect = document.getElementById('gen_stopNameSelect');
    const routeSelect = document.getElementById('gen_routeSelect');
    const destinationSelect = document.getElementById('gen_destinationSelect');
    const lineNameInputEl = document.getElementById('gen_lineName');
    const destNameInputEl = document.getElementById('gen_destinationName');

    if (stopNameSelect) {
        stopNameSelect.removeEventListener('change', gen_handleStopNameSelectChange);
        stopNameSelect.addEventListener('change', gen_handleStopNameSelectChange);
    }
    if (routeSelect) {
        routeSelect.removeEventListener('change', gen_handleRouteSelectChange);
        routeSelect.addEventListener('change', gen_handleRouteSelectChange);
    }
    if (destinationSelect) {
        destinationSelect.removeEventListener('change', gen_handleDestinationSelectChange);
        destinationSelect.addEventListener('change', gen_handleDestinationSelectChange);
    }

    if (lineNameInputEl) {
        lineNameInputEl.removeEventListener('input', gen_handleLineNameInputChange);
        lineNameInputEl.addEventListener('input', gen_handleLineNameInputChange);
        lineNameInputEl.removeEventListener('change', gen_saveDataToLocalStorage);
        lineNameInputEl.addEventListener('change', gen_saveDataToLocalStorage);
    }
    if (destNameInputEl) {
        destNameInputEl.removeEventListener('input', gen_saveDataToLocalStorage);
        destNameInputEl.addEventListener('input', gen_saveDataToLocalStorage);
        destNameInputEl.removeEventListener('change', gen_saveDataToLocalStorage);
        destNameInputEl.addEventListener('change', gen_saveDataToLocalStorage);
    }
}

function gen_handleLineNameInputChange() {
    gen_populateDestinationSelect();
    const lineNameInputEl = document.getElementById('gen_lineName');
    const routeSelectEl = document.getElementById('gen_routeSelect');
    if (lineNameInputEl && routeSelectEl) {
        const currentLineName = lineNameInputEl.value;
        let optionExists = Array.from(routeSelectEl.options).some(opt => opt.value === currentLineName);
        if(optionExists) {
            routeSelectEl.value = currentLineName;
        } else {
            routeSelectEl.selectedIndex = 0;
        }
    }
    gen_saveDataToLocalStorage();
}


function gen_handleStopNameSelectChange() {
    const stopNameSelect = document.getElementById('gen_stopNameSelect');
    const selectedOption = stopNameSelect.options[stopNameSelect.selectedIndex];
    const stopIdInput = document.getElementById('gen_stopId');
    const stopNameInput = document.getElementById('gen_stopName');
    const directionInput = document.getElementById('gen_direction');

    if (selectedOption && selectedOption.value) {
        if (stopIdInput) stopIdInput.value = selectedOption.value;
        if (stopNameInput) stopNameInput.value = selectedOption.dataset.stopname || '';
        if (directionInput) directionInput.value = selectedOption.dataset.direction || '';
    } else {
        if (stopIdInput) stopIdInput.value = '';
        if (stopNameInput) stopNameInput.value = '';
        if (directionInput) directionInput.value = '';
    }
    gen_saveDataToLocalStorage();
}

function gen_handleRouteSelectChange() {
    const routeSelect = document.getElementById('gen_routeSelect');
    const lineNameInput = document.getElementById('gen_lineName');
    if (lineNameInput) {
        lineNameInput.value = routeSelect.value;
        lineNameInput.dispatchEvent(new Event('input', { bubbles:true, cancelable:true }));
    }
}

function gen_handleDestinationSelectChange() {
    const destinationSelect = document.getElementById('gen_destinationSelect');
    const destNameInput = document.getElementById('gen_destinationName');
    if (destNameInput) {
        destNameInput.value = destinationSelect.value;
         destNameInput.dispatchEvent(new Event('input', { bubbles:true, cancelable:true }));
    }
}
// --- END: Schedule Generator Population & Interaction ---

// --- START: Route Timetable Overwrite Functions ---

function populate_rto_SelectRoute() {
    if (!rto_selectRoute) return;
    const currentVal = rto_selectRoute.value;
    rto_selectRoute.innerHTML = '<option value="">-- Select Route --</option>';

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        if (rto_selectProfile) rto_selectProfile.innerHTML = '<option value="">-- Select Route First --</option>';
        if (rto_selectDestination) rto_selectDestination.innerHTML = '<option value="">-- Select Route & Profile First --</option>';
        return;
    }
    const uniqueRoutes = [...new Set(currentWorkingSchedule.map(e => e.lineName))].filter(Boolean).sort(compareLineNames);
    uniqueRoutes.forEach(route => {
        const opt = document.createElement('option');
        opt.value = route;
        opt.textContent = route;
        rto_selectRoute.appendChild(opt);
    });
    if (uniqueRoutes.includes(currentVal)) {
        rto_selectRoute.value = currentVal;
    }
    populate_rto_SelectProfile(rto_selectRoute.value);
}

function populate_rto_SelectProfile(selectedRoute) {
    if (!rto_selectProfile) return;
    const currentVal = rto_selectProfile.value;
    rto_selectProfile.innerHTML = '<option value="">-- Select Profile --</option>';

    if (!selectedRoute || !currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        rto_selectProfile.innerHTML = '<option value="">-- Select Route First --</option>';
        if (rto_selectDestination) rto_selectDestination.innerHTML = '<option value="">-- Select Route & Profile First --</option>';
        return;
    }
    const profilesForRoute = [...new Set(
        currentWorkingSchedule
            .filter(e => e.lineName === selectedRoute && e.OperatingProfile)
            .map(e => e.OperatingProfile)
    )].sort();

    if (profilesForRoute.length === 0) {
        rto_selectProfile.innerHTML = '<option value="">-- No Profiles for Route --</option>';
        if (rto_selectDestination) rto_selectDestination.innerHTML = '<option value="">-- Select Route & Profile First --</option>';
        return;
    }
    profilesForRoute.forEach(profile => {
        const opt = document.createElement('option');
        opt.value = profile;
        opt.textContent = profile;
        rto_selectProfile.appendChild(opt);
    });
    if (profilesForRoute.includes(currentVal)) {
        rto_selectProfile.value = currentVal;
    }
    populate_rto_SelectDestination(selectedRoute, rto_selectProfile.value);
}

function populate_rto_SelectDestination(selectedRoute, selectedProfile) {
    if (!rto_selectDestination) return;
    const currentVal = rto_selectDestination.value;
    rto_selectDestination.innerHTML = '<option value="">-- All Destinations for Route/Profile --</option>';

    if (!selectedRoute || !selectedProfile || !currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        rto_selectDestination.innerHTML = '<option value="">-- Select Route & Profile First --</option>';
        return;
    }
    const destinations = [...new Set(
        currentWorkingSchedule
            .filter(e => e.lineName === selectedRoute && e.OperatingProfile === selectedProfile && e.destinationName)
            .map(e => e.destinationName)
    )].sort();

    if (destinations.length === 0) {
        // Keep default
    } else {
        destinations.forEach(dest => {
            const opt = document.createElement('option');
            opt.value = dest;
            opt.textContent = dest;
            rto_selectDestination.appendChild(opt);
        });
        if (destinations.includes(currentVal)) {
            rto_selectDestination.value = currentVal;
        }
    }
}

function handle_rto_FileUpload(event) {
    const file = event.target.files[0];
    if (!rto_fileStatus || !rto_fileInput) return;

    if (!file) {
        rto_fileStatus.textContent = "No file selected.";
        rto_uploadedScheduleData = [];
        return;
    }
    rto_fileStatus.textContent = `Processing ${file.name}...`;
    rto_uploadedScheduleData = [];

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const fileContent = e.target.result;
            const lines = fileContent.split(/\r?\n/);
            if (lines.length < 2) {
                alert("Uploaded file is empty or has no data rows.");
                rto_fileStatus.textContent = "File empty or no data.";
                rto_fileInput.value = "";
                return;
            }
            const headers = lines[0].split('\t').map(h => h.trim());
            const requiredHeaders = ['StopID', 'LineName', 'ScheduledTime', 'OperatingProfile'];
            const missingHeaders = requiredHeaders.filter(rh => !headers.includes(rh));
            if (missingHeaders.length > 0) {
                alert(`Uploaded file is missing required headers for overwrite: ${missingHeaders.join(', ')}. \nExpected at least: StopID, LineName, ScheduledTime, OperatingProfile. \nAlso recommended: StopName, Direction, DestinationName, DayOffset.`);
                rto_fileStatus.textContent = "Invalid file headers.";
                rto_fileInput.value = "";
                return;
            }

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === "") continue;
                const values = line.split('\t').map(v => v.trim());
                let entry = {};
                headers.forEach((header, index) => {
                    entry[header] = values[index] !== undefined ? values[index] : "";
                });

                if (entry.StopID && entry.LineName && entry.ScheduledTime && entry.OperatingProfile) {
                     let scheduledTime = String(entry.ScheduledTime || "").trim();
                     if (scheduledTime.match(/^\d{4}$/)) {
                         scheduledTime = `${scheduledTime.substring(0,2)}:${scheduledTime.substring(2,4)}`;
                     } else if (scheduledTime.match(/^\d{1,2}:\d{2}$/)) {
                         const parts = scheduledTime.split(':');
                         scheduledTime = `${String(parts[0]).padStart(2, '0')}:${String(parts[1]).padStart(2, '0')}`;
                     }
                     entry.ScheduledTime = scheduledTime;
                     entry.DayOffset = String(entry.DayOffset || "0").trim();
                     entry.StopID = entry.StopID.toUpperCase();
                     entry.LineName = entry.LineName.toUpperCase();
                     rto_uploadedScheduleData.push(entry);
                }
            }
            rto_fileStatus.textContent = `${file.name} processed. ${rto_uploadedScheduleData.length} potentially valid entries found. Ready to overwrite.`;
            if (rto_statusMessage) rto_statusMessage.textContent = "";
        } catch (error) {
            console.error("Error processing timetable overwrite file:", error);
            alert(`Error processing file: ${error.message}`);
            rto_fileStatus.textContent = "Error processing file.";
            if (rto_fileInput) rto_fileInput.value = "";
        }
    };
    reader.onerror = () => {
        alert("Could not read file.");
        rto_fileStatus.textContent = "Error reading file.";
        if (rto_fileInput) rto_fileInput.value = "";
    };
    reader.readAsText(file);
}

function handle_rto_OverwriteTimetable() {
    if (!currentUser) { alert("Please log in."); return; }
     if (!rto_selectRoute || !rto_selectProfile || !rto_selectDestination || !rto_overwriteButton || !rto_statusMessage) {
         console.error("RTO Tool: One or more UI elements are missing for overwrite operation."); return;
     }

    const targetRoute = rto_selectRoute.value;
    const targetProfile = rto_selectProfile.value;
    const targetDestination = rto_selectDestination.value;

    if (!targetRoute) {
        rto_statusMessage.textContent = "Please select a Route to overwrite.";
        rto_statusMessage.style.color = "#e74c3c"; return;
    }
    if (!targetProfile) {
        rto_statusMessage.textContent = "Please select an Operating Profile to overwrite.";
        rto_statusMessage.style.color = "#e74c3c"; return;
    }
    if (rto_uploadedScheduleData.length === 0) {
        rto_statusMessage.textContent = "No new timetable data uploaded. Please upload a file first.";
        rto_statusMessage.style.color = "#e74c3c"; return;
    }

    const confirmationMessage = `Are you sure you want to overwrite all times for:\nRoute: ${targetRoute}\nProfile: ${targetProfile}\n${targetDestination ? `Destination: ${targetDestination}` : '(All Destinations for this Route/Profile)'}\n\nThis will REPLACE existing entries matching these criteria in the current working schedule with data from the uploaded file. This action cannot be easily undone.`;
    if (!confirm(confirmationMessage)) {
        rto_statusMessage.textContent = "Overwrite cancelled by user.";
        rto_statusMessage.style.color = "#f1c40f"; return;
    }

    const newEntriesForTarget = rto_uploadedScheduleData.filter(entry =>
        entry.LineName === targetRoute &&
        entry.OperatingProfile === targetProfile &&
        (targetDestination === "" || entry.DestinationName === targetDestination)
    ).map((row, index) => {
         return {
             internalId: `${String(row.StopID||'s').trim().toUpperCase()}_${String(row.LineName||'l').trim().toUpperCase()}_${(row.ScheduledTime||"0000").replace(':','')}_${index}_rto_${Date.now()}`,
             stopID: String(row.StopID || "").trim().toUpperCase(),
             stopName: String(row.StopName || "Unknown Stop").trim(),
             direction: String(row.Direction || "Unknown Direction").trim(),
             lineName: String(row.LineName || targetRoute).trim().toUpperCase(),
             destinationName: String(row.DestinationName || (targetDestination === "" ? "Unknown Destination" : targetDestination)).trim(),
             scheduledTime: row.ScheduledTime,
             OperatingProfile: String(row.OperatingProfile || targetProfile).trim(),
             DayOffset: String(row.DayOffset || "0").trim()
         };
    });

    if (newEntriesForTarget.length === 0) {
        rto_statusMessage.textContent = "No matching entries found in the uploaded file for the selected criteria. No changes made to the working schedule.";
        rto_statusMessage.style.color = "#f1c40f"; return;
    }

    let entriesKept = 0;
    let entriesRemoved = 0;
    const updatedWorkingSchedule = currentWorkingSchedule.filter(entry => {
        const matchesCriteriaForRemoval = entry.lineName === targetRoute &&
                              entry.OperatingProfile === targetProfile &&
                              (targetDestination === "" || entry.destinationName === targetDestination);
        if (matchesCriteriaForRemoval) {
            entriesRemoved++;
            return false;
        }
        entriesKept++;
        return true;
    });

    updatedWorkingSchedule.push(...newEntriesForTarget);
    currentWorkingSchedule = updatedWorkingSchedule;

    rto_statusMessage.textContent = `Timetable overwritten successfully. ${entriesRemoved} old entries removed, ${newEntriesForTarget.length} new entries added. Working schedule now has ${currentWorkingSchedule.length} total entries.`;
    rto_statusMessage.style.color = "#2ecc71";

    if (rto_fileInput) rto_fileInput.value = "";
    if (rto_fileStatus) rto_fileStatus.textContent = "No file selected.";
    rto_uploadedScheduleData = [];

    renderUIDependentElements();
    updateStagingStatusDisplay();

    const activeSectionId = localStorage.getItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
    if (activeSectionId === 'schedule-generator-section') {
        gen_initializeScheduleGeneratorControls();
    }
    if (activeSectionId === 'stop-management-tool-section') {
         populateMasterStopList_SM();
    }
    populate_rto_SelectRoute();
}
// --- END: Route Timetable Overwrite Functions ---

function gen_addIntervalRule(ruleData = null) {
    gen_ruleCounter++;
    const container = document.getElementById('gen_intervalRulesContainer');
    if (!container) return;

    const ruleDiv = document.createElement('div');
    ruleDiv.className = 'gen_interval-rule';
    ruleDiv.id = `gen_rule-${gen_ruleCounter}`;

    const ruleTitle = document.createElement('h4');
    ruleTitle.textContent = `Rule ${gen_ruleCounter}`;
    ruleDiv.appendChild(ruleTitle);

    const inputGroupDiv = document.createElement('div');
    inputGroupDiv.className = 'gen_input-group';

    const startTimeDiv = document.createElement('div');
    const startTimeLabel = document.createElement('label');
    startTimeLabel.setAttribute('for', `gen_startTime-${gen_ruleCounter}`);
    startTimeLabel.textContent = 'Start Time (HHMM):';
    const startTimeInput = document.createElement('input');
    startTimeInput.type = 'text';
    startTimeInput.id = `gen_startTime-${gen_ruleCounter}`;
    startTimeInput.className = 'schedule-generator-input';
    startTimeInput.placeholder = 'e.g., 0900';
    startTimeDiv.appendChild(startTimeLabel);
    startTimeDiv.appendChild(startTimeInput);
    inputGroupDiv.appendChild(startTimeDiv);

    const endTimeDiv = document.createElement('div');
    const endTimeLabel = document.createElement('label');
    endTimeLabel.setAttribute('for', `gen_endTime-${gen_ruleCounter}`);
    endTimeLabel.textContent = 'End Time (HHMM):';
    const endTimeInput = document.createElement('input');
    endTimeInput.type = 'text';
    endTimeInput.id = `gen_endTime-${gen_ruleCounter}`;
    endTimeInput.className = 'schedule-generator-input';
    endTimeInput.placeholder = 'e.g., 1900';
    endTimeDiv.appendChild(endTimeLabel);
    endTimeDiv.appendChild(endTimeInput);
    inputGroupDiv.appendChild(endTimeDiv);

    const intervalDiv = document.createElement('div');
    const intervalLabel = document.createElement('label');
    intervalLabel.setAttribute('for', `gen_interval-${gen_ruleCounter}`);
    intervalLabel.textContent = 'Interval (minutes):';
    const intervalInput = document.createElement('input');
    intervalInput.type = 'number';
    intervalInput.id = `gen_interval-${gen_ruleCounter}`;
    intervalInput.className = 'schedule-generator-input';
    intervalInput.min = '1';
    intervalInput.placeholder = '15';
    intervalDiv.appendChild(intervalLabel);
    intervalDiv.appendChild(intervalInput);
    inputGroupDiv.appendChild(intervalDiv);

    ruleDiv.appendChild(inputGroupDiv);

    const removeButton = document.createElement('button');
    removeButton.className = 'button small-action tertiary';
    removeButton.textContent = 'Remove Rule';
    removeButton.style.marginLeft = '0';
    removeButton.style.marginTop = '5px';
    removeButton.addEventListener('click', () => gen_removeIntervalRule(`gen_rule-${gen_ruleCounter}`));
    ruleDiv.appendChild(removeButton);

    container.appendChild(ruleDiv);

    if (ruleData) {
        if(startTimeInput) startTimeInput.value = ruleData.startTime || '';
        if(endTimeInput) endTimeInput.value = ruleData.endTime || '';
        if(intervalInput) intervalInput.value = ruleData.interval || '';
    }
}


function gen_removeIntervalRule(ruleId) {
    const ruleElement = document.getElementById(ruleId);
    if (ruleElement) {
        ruleElement.remove();
        gen_saveDataToLocalStorage();
    }
}

function gen_hhmmToMinutes(hhmmStr) {
    if (!hhmmStr || hhmmStr.length !== 4 || !/^\d{4}$/.test(hhmmStr)) return 0;
    const hours = parseInt(hhmmStr.substring(0, 2), 10);
    const minutes = parseInt(hhmmStr.substring(2, 4), 10);
    if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) return 0;
    return hours * 60 + minutes;
}

function gen_minutesToHHMM(totalMinutes) {
    const hours = Math.floor(totalMinutes / 60) % 24;
    const minutes = totalMinutes % 60;
    return String(hours).padStart(2, '0') + String(minutes).padStart(2, '0');
}

function gen_formatTimeToHHMMColon(hhmmStr) {
    const timeStr = String(hhmmStr || "").padStart(4, '0');
    if (timeStr.length === 4 && !isNaN(parseInt(timeStr,10))) {
         return timeStr.substring(0, 2) + ":" + timeStr.substring(2, 4);
    }
    return hhmmStr;
}

function gen_getBaseDataFromForm() {
    return {
        stopId: document.getElementById('gen_stopId')?.value.trim(),
        stopName: document.getElementById('gen_stopName')?.value.trim(),
        direction: document.getElementById('gen_direction')?.value.trim(),
        lineName: document.getElementById('gen_lineName')?.value.trim().toUpperCase(),
        destinationName: document.getElementById('gen_destinationName')?.value.trim(),
        operatingProfile: document.getElementById('gen_operatingProfile')?.value.trim(),
        initialScheduledTime: document.getElementById('gen_initialScheduledTime')?.value.trim(),
        initialDayOffset: document.getElementById('gen_initialDayOffset')?.value.trim() || '0'
    };
}

function gen_getIntervalRulesFromForm() {
    const intervalRulesData = [];
    document.querySelectorAll('#gen_intervalRulesContainer .gen_interval-rule').forEach(ruleElement => {
        const idNum = ruleElement.id.split('-')[1];
        const startTime = document.getElementById(`gen_startTime-${idNum}`)?.value.trim();
        const endTime = document.getElementById(`gen_endTime-${idNum}`)?.value.trim();
        const intervalValue = document.getElementById(`gen_interval-${idNum}`)?.value.trim();
        if (startTime && endTime && intervalValue && parseInt(intervalValue, 10) > 0) {
             intervalRulesData.push({
                startTime: startTime,
                endTime: endTime,
                interval: parseInt(intervalValue, 10)
            });
        } else if (startTime || endTime || intervalValue) {
            console.warn(`Generator: Incomplete or invalid interval rule ${idNum} skipped (Start: ${startTime}, End: ${endTime}, Interval: ${intervalValue})`);
        }
    });
    return intervalRulesData;
}

function gen_saveDataToLocalStorage() {
    if (document.getElementById('schedule-generator-section')?.style.display !== 'block' && !gen_isInitialized) {
        return;
    }
    try {
        const appData = {
            baseData: gen_getBaseDataFromForm(),
            intervalRules: gen_getIntervalRulesFromForm(),
            generatedSchedule: gen_currentScheduleEntries
        };
        localStorage.setItem(GEN_APP_DATA_KEY, JSON.stringify(appData));
    } catch (e) {
        console.error("Error saving generator data to localStorage:", e);
    }
}

function gen_loadDataFromLocalStorage() {
    const savedDataString = localStorage.getItem(GEN_APP_DATA_KEY);
    if (savedDataString) {
        try {
            const appData = JSON.parse(savedDataString);

            if (appData.baseData) {
                const fieldsToSet = {
                    'gen_stopId': appData.baseData.stopId,
                    'gen_stopName': appData.baseData.stopName,
                    'gen_direction': appData.baseData.direction,
                    'gen_lineName': appData.baseData.lineName,
                    'gen_destinationName': appData.baseData.destinationName,
                    'gen_operatingProfile': appData.baseData.operatingProfile,
                    'gen_initialScheduledTime': appData.baseData.initialScheduledTime,
                    'gen_initialDayOffset': appData.baseData.initialDayOffset || '0',
                };
                for (const id in fieldsToSet) {
                    const el = document.getElementById(id);
                    if (el) el.value = fieldsToSet[id] || '';
                }

                const gen_stopNameSelectEl = document.getElementById('gen_stopNameSelect');
                if (gen_stopNameSelectEl && appData.baseData.stopId) {
                    let optionExists = Array.from(gen_stopNameSelectEl.options).some(opt => opt.value === appData.baseData.stopId);
                    if (optionExists) {
                        gen_stopNameSelectEl.value = appData.baseData.stopId;
                    } else {
                         gen_stopNameSelectEl.selectedIndex = 0;
                    }
                }
                gen_stopNameSelectEl?.dispatchEvent(new Event('change'));

                setTimeout(() => {
                    const lineNameInputEl = document.getElementById('gen_lineName');
                    const routeSelectEl = document.getElementById('gen_routeSelect');
                    if (routeSelectEl && lineNameInputEl && lineNameInputEl.value) {
                        let optionExists = Array.from(routeSelectEl.options).some(opt => opt.value === lineNameInputEl.value);
                        if (optionExists) routeSelectEl.value = lineNameInputEl.value;
                        else routeSelectEl.selectedIndex = 0;
                    }
                    lineNameInputEl?.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));

                    setTimeout(() => {
                        const destNameInputEl = document.getElementById('gen_destinationName');
                        const destSelectEl = document.getElementById('gen_destinationSelect');
                        if (destSelectEl && destNameInputEl && destNameInputEl.value) {
                           let optionExists = Array.from(destSelectEl.options).some(opt => opt.value === destNameInputEl.value);
                           if(optionExists) destSelectEl.value = destNameInputEl.value;
                           else destSelectEl.selectedIndex = 0;
                        }
                    }, 150);
                }, 100);
            }

            const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
            if(intervalRulesContainer) intervalRulesContainer.innerHTML = '';
            gen_ruleCounter = 0;
            (appData.intervalRules || []).forEach(ruleData => gen_addIntervalRule(ruleData));

            gen_currentScheduleEntries = appData.generatedSchedule || [];
            gen_renderScheduleTable();

        } catch (e) {
            console.error("Error loading/parsing generator data from localStorage:", e);
            localStorage.removeItem(GEN_APP_DATA_KEY);
             gen_addIntervalRule();
        }
    } else {
        const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
        if (intervalRulesContainer && intervalRulesContainer.childElementCount === 0) {
            gen_addIntervalRule();
        }
        document.getElementById('gen_stopNameSelect')?.dispatchEvent(new Event('change'));
    }
}


function gen_clearAllData() {
    if (confirm("Are you sure you want to clear all data for the Schedule Generator? This includes base data, interval rules and the current generated schedule table. This cannot be undone.")) {
        const fieldsToClear = [
            'gen_stopId', 'gen_stopName', 'gen_direction',
            'gen_lineName', 'gen_destinationName',
            'gen_operatingProfile', 'gen_initialScheduledTime', 'gen_initialDayOffset'
        ];
        fieldsToClear.forEach(id => {
            const el = document.getElementById(id);
            if(el) el.value = '';
        });

        ['gen_stopNameSelect', 'gen_routeSelect', 'gen_destinationSelect'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.selectedIndex = 0;
        });
        const initialDayOffsetEl = document.getElementById('gen_initialDayOffset');
        if(initialDayOffsetEl) initialDayOffsetEl.value = '0';

        const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
        if(intervalRulesContainer) intervalRulesContainer.innerHTML = '';
        gen_ruleCounter = 0;
        gen_addIntervalRule();

        gen_currentScheduleEntries = [];
        gen_renderScheduleTable();

        localStorage.removeItem(GEN_APP_DATA_KEY);
        alert("All generator data has been cleared.");

        document.getElementById('gen_stopNameSelect')?.dispatchEvent(new Event('change'));
    }
}

function gen_generateSchedule() {
    gen_currentScheduleEntries = [];
    const addedEntryKeys = new Set();

    const baseFormValues = gen_getBaseDataFromForm();
    const baseDataForGeneration = {
        stopId: baseFormValues.stopId,
        stopName: baseFormValues.stopName,
        direction: baseFormValues.direction,
        lineName: baseFormValues.lineName,
        destinationName: baseFormValues.destinationName,
        operatingProfile: baseFormValues.operatingProfile,
    };

    if (baseFormValues.initialScheduledTime && baseFormValues.initialScheduledTime.match(/^\d{3,4}$/)) {
        const initialEntry = {
            ...baseDataForGeneration,
            scheduledTime: baseFormValues.initialScheduledTime.padStart(4,'0'),
            dayOffset: baseFormValues.initialDayOffset || '0'
        };
        const initialKey = `${initialEntry.stopId}-${initialEntry.lineName}-${initialEntry.scheduledTime}-${initialEntry.operatingProfile}`;
        gen_currentScheduleEntries.push(initialEntry);
        addedEntryKeys.add(initialKey);
    }

    const intervalRules = gen_getIntervalRulesFromForm();
    intervalRules.forEach(rule => {
        const startTimeStr = rule.startTime;
        const endTimeStr = rule.endTime;
        const intervalMins = parseInt(rule.interval, 10);

        if (!startTimeStr || !startTimeStr.match(/^\d{3,4}$/) ||
            !endTimeStr || !endTimeStr.match(/^\d{3,4}$/) ||
            isNaN(intervalMins) || intervalMins <= 0) {
            console.warn(`Generator: Skipping invalid rule: Start-${startTimeStr}, End-${endTimeStr}, Interval-${rule.interval}`);
            return;
        }

        let currentTotalMinutes = gen_hhmmToMinutes(startTimeStr.padStart(4,'0'));
        const endTotalMinutesInput = gen_hhmmToMinutes(endTimeStr.padStart(4,'0'));
        let effectiveEndTotalMinutes = endTotalMinutesInput;

        if (currentTotalMinutes > endTotalMinutesInput && startTimeStr > endTimeStr) {
             effectiveEndTotalMinutes += 24 * 60;
        }

        const ruleStartHourForContext = parseInt(startTimeStr.padStart(4,'0').substring(0, 2), 10);
        const isRuleConsideredNewDayService = (ruleStartHourForContext >= 0 && ruleStartHourForContext <= 3);

        while (currentTotalMinutes <= effectiveEndTotalMinutes) {
            const scheduledTimeHHMM = gen_minutesToHHMM(currentTotalMinutes);
            const entryKey = `${baseDataForGeneration.stopId}-${baseDataForGeneration.lineName}-${scheduledTimeHHMM}-${baseDataForGeneration.operatingProfile}`;

            if (!addedEntryKeys.has(entryKey)) {
                let generatedDayOffset = 0;
                const currentGeneratedHour = parseInt(scheduledTimeHHMM.substring(0,2), 10);

                if (isRuleConsideredNewDayService) {
                    generatedDayOffset = 0;
                } else {
                    if (currentTotalMinutes >= 1440 && (currentGeneratedHour >=0 && currentGeneratedHour <=3)) {
                         generatedDayOffset = 1;
                    } else {
                        generatedDayOffset = 0;
                    }
                }
                gen_currentScheduleEntries.push({
                    ...baseDataForGeneration,
                    scheduledTime: scheduledTimeHHMM,
                    dayOffset: String(generatedDayOffset)
                });
                addedEntryKeys.add(entryKey);
            }
            if (intervalMins === 0) break;
            currentTotalMinutes += intervalMins;
        }
    });
    gen_renderScheduleTable();
    gen_saveDataToLocalStorage();
}

function gen_deleteScheduleEntry(index) {
    if (index < 0 || index >= gen_currentScheduleEntries.length) {
        console.error("Invalid index for deletion from generator table:", index);
        return;
    }
    const entryToDelete = gen_currentScheduleEntries[index];
    let timeToDisplay = entryToDelete.scheduledTime || "";
    if (timeToDisplay.length === 4 && !isNaN(timeToDisplay)) {
        timeToDisplay = `${timeToDisplay.substring(0,2)}:${timeToDisplay.substring(2,4)}`;
    } else if (timeToDisplay.length === 3 && !isNaN(timeToDisplay)) {
            timeToDisplay = `0${timeToDisplay.substring(0,1)}:${timeToDisplay.substring(1,3)}`;
    }

    if (confirm(`Are you sure you want to delete this entry from the generator's table?\nStop: ${entryToDelete.stopId} - ${entryToDelete.stopName}\nLine: ${entryToDelete.lineName}\nTime: ${timeToDisplay}\nDest: ${entryToDelete.destinationName}`)) {
        gen_currentScheduleEntries.splice(index, 1);
        gen_renderScheduleTable();
        gen_saveDataToLocalStorage();
        console.log("Entry deleted from generator list and local storage updated.");
    }
}

function gen_renderScheduleTable() {
    const resultsTable = document.getElementById('gen_resultsTable');
    if (!resultsTable) return;
    const resultsBody = resultsTable.getElementsByTagName('tbody')[0];
    const resultsHead = resultsTable.getElementsByTagName('thead')[0];
    if (!resultsBody || !resultsHead) return;

    resultsBody.innerHTML = '';

    if (resultsHead.rows.length > 0) {
        let headerRow = resultsHead.rows[0];
        if (headerRow.cells.length === 8 && headerRow.cells[7].textContent !== "Actions") {
            let th = document.createElement('th');
            th.textContent = 'Actions';
            headerRow.appendChild(th);
        } else if (headerRow.cells.length === 0) {
            headerRow.innerHTML = `<th>StopID</th><th>StopName</th><th>Direction</th><th>LineName</th><th>DestinationName</th><th>ScheduledTime (HH:MM)</th><th>OperatingProfile</th><th>DayOffset</th><th>Actions</th>`;
        } else if (headerRow.cells.length > 0 && headerRow.cells[headerRow.cells.length - 1].textContent !== "Actions") {
            let th = document.createElement('th');
            th.textContent = 'Actions';
            headerRow.appendChild(th);
        }
    } else {
        let header = resultsTable.createTHead();
        let row = header.insertRow(0);
        row.innerHTML = `<th>StopID</th><th>StopName</th><th>Direction</th><th>LineName</th><th>DestinationName</th><th>ScheduledTime (HH:MM)</th><th>OperatingProfile</th><th>DayOffset</th><th>Actions</th>`;
    }


    gen_currentScheduleEntries.forEach((entry, index) => {
        let newRow = resultsBody.insertRow();
        newRow.insertCell().textContent = entry.stopId || '';
        newRow.insertCell().textContent = entry.stopName || '';
        newRow.insertCell().textContent = entry.direction || '';
        newRow.insertCell().textContent = entry.lineName || '';
        newRow.insertCell().textContent = entry.destinationName || '';

        let displayTime = entry.scheduledTime || "";
        if (displayTime.length === 4 && !isNaN(displayTime)) {
            displayTime = `${displayTime.substring(0,2)}:${displayTime.substring(2,4)}`;
        } else if (displayTime.length === 3 && !isNaN(displayTime)) {
             displayTime = `0${displayTime.substring(0,1)}:${displayTime.substring(1,3)}`;
        }
        newRow.insertCell().textContent = displayTime;

        newRow.insertCell().textContent = entry.operatingProfile || '';
        newRow.insertCell().textContent = String(entry.dayOffset || '0');

        let actionCell = newRow.insertCell();
        let deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.classList.add('button', 'small-action', 'secondary');
        deleteButton.style.padding = '0.2rem 0.4rem';
        deleteButton.style.fontSize = '0.8rem';
        deleteButton.addEventListener('click', () => gen_deleteScheduleEntry(index));
        actionCell.appendChild(deleteButton);
    });
}

function gen_exportToCountFile() {
    if (gen_currentScheduleEntries.length === 0) {
        alert("No schedule data to export from generator. Please generate a schedule first.");
        return;
    }
    const headers = [
        "StopID", "StopName", "Direction", "LineName",
        "DestinationName", "ScheduledTime", "OperatingProfile", "DayOffset"
    ];
    let tabText = headers.join("\t") + "\n";
    gen_currentScheduleEntries.forEach(entry => {
        let formattedTime = entry.scheduledTime;
        if (formattedTime && formattedTime.length === 4 && !formattedTime.includes(':')) {
            formattedTime = `${formattedTime.substring(0,2)}:${formattedTime.substring(2,4)}`;
        } else if (formattedTime && formattedTime.length === 3 && !formattedTime.includes(':')) {
            formattedTime = `0${formattedTime.substring(0,1)}:${formattedTime.substring(1,3)}`;
        }
        const rowValues = [
            entry.stopId, entry.stopName, entry.direction, entry.lineName,
            entry.destinationName, formattedTime, entry.operatingProfile, String(entry.dayOffset || '0')
        ];
        tabText += rowValues.map(val => String(val || '').replace(/\t|\n|\r/g, " ")).join("\t") + "\n";
    });
    const blob = new Blob([tabText], { type: 'text/plain;charset=utf-8;' });
    const link = document.createElement("a");
    if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "schedule_generated.count");
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    } else {
        alert("Your browser does not support automatic file downloading.");
    }
}

function gen_handleAddGeneratedToWorkingSchedule() {
    if (!currentUser) {
        alert("Please log in to modify the working schedule.");
        return;
    }
    if (!gen_currentScheduleEntries || gen_currentScheduleEntries.length === 0) {
        alert("No schedule entries generated/loaded in the generator's table to add.");
        return;
    }
    const actionChoice = prompt("Choose action for adding entries from the generator's table to the main working schedule:\n1. OVERWRITE entire working schedule.\n2. APPEND to existing working schedule.\n\nEnter 1 or 2 (or Cancel):");
    if (actionChoice !== "1" && actionChoice !== "2") {
        if (actionChoice !== null) alert("Invalid choice. Operation cancelled.");
        return;
    }
    const isOverwrite = actionChoice === "1";
    if (isOverwrite) {
        if (!confirm(`ARE YOU SURE you want to OVERWRITE the ENTIRE main working schedule with these ${gen_currentScheduleEntries.length} entries from the generator's table?`)) {
            return;
        }
        currentWorkingSchedule = [];
    } else {
        if (!confirm(`Are you sure you want to APPEND these ${gen_currentScheduleEntries.length} entries to the main working schedule?`)) {
            return;
        }
    }
    let addedCount = 0;
    const newEntriesForWorkingSchedule = gen_currentScheduleEntries.map((genEntry, index) => {
        let scheduledTimeForWorking = genEntry.scheduledTime || "";
        if (scheduledTimeForWorking && scheduledTimeForWorking.length === 4 && !scheduledTimeForWorking.includes(':')) {
            scheduledTimeForWorking = `${scheduledTimeForWorking.substring(0,2)}:${scheduledTimeForWorking.substring(2,4)}`;
        } else if (scheduledTimeForWorking && scheduledTimeForWorking.length === 3 && !scheduledTimeForWorking.includes(':')) {
            scheduledTimeForWorking = `0${scheduledTimeForWorking.substring(0,1)}:${scheduledTimeForWorking.substring(1,3)}`;
        }
        const uniqueSuffix = Date.now() + "_" + index + (isOverwrite ? "_ow_gen" : "_app_gen");
        const internalId = `${(genEntry.stopId||'s').toUpperCase()}_${(genEntry.lineName||'l').toUpperCase()}_${(genEntry.scheduledTime||"").replace(':','')}_${uniqueSuffix}`;
        addedCount++;
        return {
            internalId: internalId,
            stopID: (genEntry.stopId || "").toUpperCase(),
            stopName: genEntry.stopName || "",
            direction: genEntry.direction || "",
            lineName: (genEntry.lineName || "").toUpperCase(),
            destinationName: genEntry.destinationName || "",
            scheduledTime: scheduledTimeForWorking,
            OperatingProfile: genEntry.operatingProfile || "",
            DayOffset: String(genEntry.dayOffset || "0")
        };
    });
    currentWorkingSchedule.push(...newEntriesForWorkingSchedule);
    alert(`${addedCount} entries from the generator's table have been ${isOverwrite ? 'set as (overwritten)' : 'appended to'} the main working schedule.`);
    renderUIDependentElements();
    updateStagingStatusDisplay();
}

function gen_handleGetWorkingSchedule() {
    if (!currentUser) { alert("Please log in."); return; }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        alert("The main working schedule is currently empty."); return;
    }
    if (!confirm(`Replace current generator table with all ${currentWorkingSchedule.length} entries from main working schedule?`)) {
        return;
    }
    let tempSchedule = currentWorkingSchedule.map(entry => {
        let internalGenScheduledTime = entry.scheduledTime || "";
        if (internalGenScheduledTime.includes(':')) {
            internalGenScheduledTime = internalGenScheduledTime.replace(':', '');
        }
        internalGenScheduledTime = internalGenScheduledTime.padStart(4, '0');
        return {
            stopId: entry.stopID || "", stopName: entry.stopName || "", direction: entry.direction || "",
            lineName: entry.lineName || "", destinationName: entry.destinationName || "",
            scheduledTime: internalGenScheduledTime, operatingProfile: entry.OperatingProfile || "",
            dayOffset: String(entry.DayOffset || "0")
        };
    });
    tempSchedule.sort((a, b) => {
        const lineCompare = compareLineNames(a.lineName, b.lineName); if (lineCompare !== 0) return lineCompare;
        const stopNameA = (a.stopName || "").toLowerCase(); const stopNameB = (b.stopName || "").toLowerCase();
        if (stopNameA < stopNameB) return -1; if (stopNameA > stopNameB) return 1;
        const timeA = a.scheduledTime || "9999"; const timeB = b.scheduledTime || "9999";
        if (timeA < timeB) return -1; if (timeA > timeB) return 1;
        const dayOffsetA = parseInt(a.dayOffset, 10); const dayOffsetB = parseInt(b.dayOffset, 10);
        if (dayOffsetA < dayOffsetB) return -1; if (dayOffsetA > dayOffsetB) return 1;
        return 0;
    });
    gen_currentScheduleEntries = tempSchedule;
    gen_renderScheduleTable();
    gen_saveDataToLocalStorage();
    alert(`Loaded ${gen_currentScheduleEntries.length} entries into generator table.`);
}

function gen_handleLoadStopSchedule() {
    if (!currentUser) { alert("Please log in."); return; }
    const stopSelectEl = document.getElementById('gen_stopNameSelect');
    const selectedStopId = stopSelectEl ? stopSelectEl.value : null;
    if (!selectedStopId) { alert("Select stop from 'Base Data' section."); return; }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) { alert("Main working schedule empty."); return; }
    if (!confirm(`Replace generator table with schedule for stop "${selectedStopId}"?`)) { return; }

    const entriesForSelectedStop = currentWorkingSchedule.filter(entry => entry.stopID === selectedStopId);
    if (entriesForSelectedStop.length === 0) {
        alert(`No entries for stop "${selectedStopId}".`);
        gen_currentScheduleEntries = [];
    } else {
        let tempSchedule = entriesForSelectedStop.map(entry => {
            let internalGenScheduledTime = entry.scheduledTime || "";
            if (internalGenScheduledTime.includes(':')) internalGenScheduledTime = internalGenScheduledTime.replace(':', '');
            internalGenScheduledTime = internalGenScheduledTime.padStart(4, '0');
            return {
                stopId: entry.stopID || "", stopName: entry.stopName || "", direction: entry.direction || "",
                lineName: entry.lineName || "", destinationName: entry.destinationName || "",
                scheduledTime: internalGenScheduledTime, operatingProfile: entry.OperatingProfile || "",
                dayOffset: String(entry.DayOffset || "0")
            };
        });
        tempSchedule.sort((a, b) => {
            const lineCompare = compareLineNames(a.lineName, b.lineName); if (lineCompare !== 0) return lineCompare;
            const timeA = a.scheduledTime || "9999"; const timeB = b.scheduledTime || "9999";
            if (timeA < timeB) return -1; if (timeA > timeB) return 1;
            const dayOffsetA = parseInt(a.dayOffset, 10); const dayOffsetB = parseInt(b.dayOffset, 10);
            if (dayOffsetA < dayOffsetB) return -1; if (dayOffsetA > dayOffsetB) return 1;
            return 0;
        });
        gen_currentScheduleEntries = tempSchedule;
    }
    gen_renderScheduleTable();
    gen_saveDataToLocalStorage();
    if (entriesForSelectedStop.length > 0) alert(`Loaded ${gen_currentScheduleEntries.length} entries for stop "${selectedStopId}".`);
}

function gen_initializeScheduleGeneratorControls() {
    gen_populateStopNameSelect();
    gen_populateRouteSelect();
    gen_attachEventListenersForGeneratorSelects();
    gen_loadDataFromLocalStorage();

    const gen_baseDataInputsIds = [
        'gen_operatingProfile', 'gen_initialScheduledTime', 'gen_initialDayOffset'
    ];
    gen_baseDataInputsIds.forEach(id => {
        const element = document.getElementById(id);
        if (element && (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'select')) {
            const eventType = element.tagName.toLowerCase() === 'select' ? 'change' : 'input';
            element.removeEventListener(eventType, gen_saveDataToLocalStorage);
            element.addEventListener(eventType, gen_saveDataToLocalStorage);
        }
    });

    const gen_intervalContainer = document.getElementById('gen_intervalRulesContainer');
    if (gen_intervalContainer) {
        gen_intervalContainer.removeEventListener('input', gen_handleIntervalContainerInput);
        gen_intervalContainer.addEventListener('input', gen_handleIntervalContainerInput);
    }
    function gen_handleIntervalContainerInput(event) {
        const target = event.target;
        if (target.tagName.toLowerCase() === 'input' && target.closest('.gen_interval-rule')) {
             gen_saveDataToLocalStorage();
        }
    }

    const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
    if (intervalRulesContainer && intervalRulesContainer.childElementCount === 0) {
        gen_addIntervalRule();
    }

    const btnGenerate = document.getElementById('gen_generateScheduleButton');
    if (btnGenerate) { btnGenerate.removeEventListener('click', gen_generateSchedule); btnGenerate.addEventListener('click', gen_generateSchedule); }
    const btnExport = document.getElementById('gen_exportToCountButton');
    if (btnExport) { btnExport.removeEventListener('click', gen_exportToCountFile); btnExport.addEventListener('click', gen_exportToCountFile); }
    const btnAddToWorking = document.getElementById('gen_addToWorkingScheduleButton');
    if (btnAddToWorking) { btnAddToWorking.removeEventListener('click', gen_handleAddGeneratedToWorkingSchedule); btnAddToWorking.addEventListener('click', gen_handleAddGeneratedToWorkingSchedule); }
    const btnGetWorkingSchedule = document.getElementById('gen_getWorkingScheduleButton');
    if (btnGetWorkingSchedule) { btnGetWorkingSchedule.removeEventListener('click', gen_handleGetWorkingSchedule); btnGetWorkingSchedule.addEventListener('click', gen_handleGetWorkingSchedule); }
    const btnLoadStopSchedule = document.getElementById('gen_loadStopScheduleButton');
    if (btnLoadStopSchedule) { btnLoadStopSchedule.removeEventListener('click', gen_handleLoadStopSchedule); btnLoadStopSchedule.addEventListener('click', gen_handleLoadStopSchedule); }
    const btnClear = document.getElementById('gen_clearAllDataButton');
    if (btnClear) { btnClear.removeEventListener('click', gen_clearAllData); btnClear.addEventListener('click', gen_clearAllData); }
    const btnAddRule = document.getElementById('gen_addIntervalRuleButton');
    function gen_addIntervalRuleHandler() { gen_addIntervalRule(null); }
    if (btnAddRule) { btnAddRule.removeEventListener('click', gen_addIntervalRuleHandler); btnAddRule.addEventListener('click', gen_addIntervalRuleHandler); }

    if (!gen_isInitialized) {
      gen_isInitialized = true;
      console.log("Schedule Generator Controls Initialized (First Time).");
    } else {
      console.log("Schedule Generator Controls Re-initialized/Refreshed.");
    }
}
// --- END: Schedule Generator ---

// --- START: Schedule Copier (within Schedule Generator) Tool Specific Functions ---
function populateCopierStopSelectors() {
    const uniqueStops = getUniqueStopsFromSchedule();

    if (sgCopierSourceStopSelect) {
        const currentSourceVal = sgCopierSourceStopSelect.value;
        sgCopierSourceStopSelect.innerHTML = '<option value="">-- Select Source Stop --</option>';
        uniqueStops.forEach(stop => {
            const opt = document.createElement('option');
            opt.value = stop.stopID;
            opt.textContent = `${stop.stopName} (${stop.stopID})`;
            sgCopierSourceStopSelect.appendChild(opt);
        });
        if (uniqueStops.find(s => s.stopID === currentSourceVal)) {
            sgCopierSourceStopSelect.value = currentSourceVal;
        }
        sgCopierSourceStopSelect.dispatchEvent(new Event('change'));
    }

    if (sgCopierTargetStopSelect) {
        const currentTargetVal = sgCopierTargetStopSelect.value;
        sgCopierTargetStopSelect.innerHTML = '<option value="">-- Select Target Stop --</option>';
        uniqueStops.forEach(stop => {
            const opt = document.createElement('option');
            opt.value = stop.stopID;
            opt.textContent = `${stop.stopName} (${stop.stopID})`;
            sgCopierTargetStopSelect.appendChild(opt);
        });
        if (uniqueStops.find(s => s.stopID === currentTargetVal)) {
            sgCopierTargetStopSelect.value = currentTargetVal;
        }
    }
}

function displayRoutesForCopierSourceStop() {
    if (!sgCopierSourceStopSelect || !sgCopierSourceRoutesContainer || !sgCopierSourceRoutesPlaceholder) return;
    const selectedStopID = sgCopierSourceStopSelect.value;
    sgCopierSourceRoutesContainer.innerHTML = '';

    if (!selectedStopID) {
        sgCopierSourceRoutesPlaceholder.textContent = 'Select a source stop to see routes.';
        sgCopierSourceRoutesPlaceholder.style.display = 'block';
        return;
    }

    const servingRoutes = new Set();
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID === selectedStopID && entry.lineName) {
            servingRoutes.add(entry.lineName);
        }
    });

    const sortedRoutes = Array.from(servingRoutes).sort(compareLineNames);

    if (sortedRoutes.length === 0) {
        sgCopierSourceRoutesPlaceholder.textContent = `No routes found serving stop ${selectedStopID}.`;
        sgCopierSourceRoutesPlaceholder.style.display = 'block';
    } else {
        sgCopierSourceRoutesPlaceholder.style.display = 'none';
        sortedRoutes.forEach(lineName => {
            const tile = document.createElement('span');
            tile.classList.add('route-tile-tools-list', 'copier-route-tile');
            tile.textContent = lineName;
            tile.dataset.lineName = lineName;
            const bgColor = getRouteTileColourForTools(lineName, selectedStopID);
            tile.style.backgroundColor = bgColor;
            tile.style.color = getTextColourForBackgroundTools(bgColor);
            tile.style.cursor = 'pointer';
            tile.setAttribute('role', 'checkbox');
            tile.setAttribute('aria-checked', 'false');
            tile.setAttribute('tabindex', '0');
            tile.addEventListener('click', () => {
                const isSelected = tile.classList.toggle('selected-tile');
                tile.setAttribute('aria-checked', isSelected.toString());
            });
            tile.addEventListener('keydown', (event) => {
                if (event.key === ' ' || event.key === 'Enter') {
                    event.preventDefault();
                    tile.click();
                }
            });
            sgCopierSourceRoutesContainer.appendChild(tile);
        });
    }
}

function handleCopySchedules() {
    if (!sgCopierSourceStopSelect || !sgCopierStatusMessage) return;
    const sourceStopID = sgCopierSourceStopSelect.value;
    if (!sourceStopID) {
        sgCopierStatusMessage.textContent = 'Please select a source stop first.';
        sgCopierStatusMessage.style.color = '#f1c40f';
        return;
    }
    const selectedRouteTiles = document.querySelectorAll('#sgCopierSourceRoutesContainer .copier-route-tile.selected-tile');
    if (selectedRouteTiles.length === 0) {
        sgCopierStatusMessage.textContent = 'Please select at least one route to copy.';
        sgCopierStatusMessage.style.color = '#f1c40f';
        return;
    }
    const selectedRoutes = Array.from(selectedRouteTiles).map(tile => tile.dataset.lineName);
    copiedScheduleEntries = [];
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID === sourceStopID && selectedRoutes.includes(entry.lineName)) {
            copiedScheduleEntries.push(JSON.parse(JSON.stringify(entry)));
        }
    });
    if (copiedScheduleEntries.length > 0) {
        sgCopierStatusMessage.textContent = `${copiedScheduleEntries.length} schedule entries for routes [${selectedRoutes.join(', ')}] from stop ${sourceStopID} copied.`;
        sgCopierStatusMessage.style.color = '#2ecc71';
    } else {
        sgCopierStatusMessage.textContent = `No schedule entries found for the selected routes at stop ${sourceStopID}.`;
        sgCopierStatusMessage.style.color = '#f1c40f';
    }
}

function adjustScheduledTime(timeStr, adjustmentMinutes) {
    if (!timeStr || !timeStr.match(/^\d{2}:\d{2}$/)) {
        console.warn(`Invalid time format for adjustment: ${timeStr}. Returning as is.`);
        return { newTime: timeStr, dayOffsetChange: 0 };
    }
    const [hours, minutes] = timeStr.split(':').map(Number);
    let totalMinutes = (hours * 60) + minutes + adjustmentMinutes;
    const oneDayInMinutes = 24 * 60;
    let dayOffsetChange = 0;
    if (totalMinutes < 0) {
        dayOffsetChange = Math.floor(totalMinutes / oneDayInMinutes);
        totalMinutes = totalMinutes % oneDayInMinutes;
        if (totalMinutes < 0) totalMinutes += oneDayInMinutes;
    } else if (totalMinutes >= oneDayInMinutes) {
        dayOffsetChange = Math.floor(totalMinutes / oneDayInMinutes);
        totalMinutes = totalMinutes % oneDayInMinutes;
    }
    const newHours = Math.floor(totalMinutes / 60);
    const newMinutes = totalMinutes % 60;
    return {
        newTime: `${String(newHours).padStart(2, '0')}:${String(newMinutes).padStart(2, '0')}`,
        dayOffsetChange: dayOffsetChange
    };
}

function handlePasteSchedules() {
    if (!currentUser) {
        sgCopierStatusMessage.textContent = 'Please log in.'; sgCopierStatusMessage.style.color = '#e74c3c'; return;
    }
    if (copiedScheduleEntries.length === 0) {
        sgCopierStatusMessage.textContent = 'No schedules copied. Use "Copy Selected Schedules" first.'; sgCopierStatusMessage.style.color = '#f1c40f'; return;
    }
    const targetStopID = sgCopierTargetStopSelect.value;
    if (!targetStopID) {
        sgCopierStatusMessage.textContent = 'Select a target stop.'; sgCopierStatusMessage.style.color = '#f1c40f'; return;
    }
    const timeAdjustmentStr = sgCopierTimeAdjustmentInput.value.trim();
    const timeAdjustmentMinutes = parseInt(timeAdjustmentStr, 10);
    if (isNaN(timeAdjustmentMinutes)) {
        sgCopierStatusMessage.textContent = 'Invalid time adjustment (e.g., +5, -10, 0).'; sgCopierStatusMessage.style.color = '#e74c3c'; return;
    }
    const targetStopDetails = getUniqueStopsFromSchedule().find(s => s.stopID === targetStopID);
    if (!targetStopDetails) {
        sgCopierStatusMessage.textContent = `Details for target stop ID: ${targetStopID} not found.`; sgCopierStatusMessage.style.color = '#e74c3c'; return;
    }
    const newEntriesForWorkingSchedule = [];
    copiedScheduleEntries.forEach((copiedEntry, index) => {
        const newEntry = JSON.parse(JSON.stringify(copiedEntry));
        newEntry.stopID = targetStopDetails.stopID;
        newEntry.stopName = targetStopDetails.stopName;
        newEntry.direction = targetStopDetails.direction;
        const { newTime, dayOffsetChange } = adjustScheduledTime(newEntry.scheduledTime, timeAdjustmentMinutes);
        newEntry.scheduledTime = newTime;
        let originalDayOffset = parseInt(newEntry.DayOffset || "0", 10);
        newEntry.DayOffset = String(originalDayOffset + dayOffsetChange);
        if (parseInt(newEntry.DayOffset, 10) < 0) {
            console.warn(`Adjusted DayOffset for ${newEntry.lineName} at ${newEntry.scheduledTime} became negative. Clamping to 0.`);
            newEntry.DayOffset = "0";
        }
        const uniqueSuffix = `_copied_sg_${Date.now()}_${index}`;
        newEntry.internalId = `${targetStopDetails.stopID.toUpperCase()}_${newEntry.lineName.toUpperCase()}_${newEntry.scheduledTime.replace(':', '')}${uniqueSuffix}`;
        newEntriesForWorkingSchedule.push(newEntry);
    });
    if (newEntriesForWorkingSchedule.length > 0) {
        if (confirm(`Add ${newEntriesForWorkingSchedule.length} new entries to Stop "${targetStopDetails.stopName} (${targetStopDetails.stopID})" with ${timeAdjustmentMinutes} min adjustment to MAIN WORKING SCHEDULE?`)) {
            currentWorkingSchedule.push(...newEntriesForWorkingSchedule);
            sgCopierStatusMessage.textContent = `${newEntriesForWorkingSchedule.length} entries pasted to stop ${targetStopDetails.stopID}. Added to main working schedule.`;
            sgCopierStatusMessage.style.color = '#2ecc71';
            copiedScheduleEntries = [];
            renderUIDependentElements();
            updateStagingStatusDisplay();
        } else {
            sgCopierStatusMessage.textContent = 'Paste cancelled.'; sgCopierStatusMessage.style.color = '#f1c40f';
        }
    } else {
        sgCopierStatusMessage.textContent = 'No valid entries processed for pasting.'; sgCopierStatusMessage.style.color = '#e74c3c';
    }
}

function initializeScheduleGeneratorCopierControls() {
    if (!sgCopierSourceStopSelect || !sgCopierCopySchedulesButton || !sgCopierPasteSchedulesButton) {
        console.warn("Schedule Copier (SG) DOM elements not found."); return;
    }
    populateCopierStopSelectors();
    sgCopierSourceStopSelect.removeEventListener('change', displayRoutesForCopierSourceStop);
    sgCopierSourceStopSelect.addEventListener('change', displayRoutesForCopierSourceStop);
    sgCopierCopySchedulesButton.removeEventListener('click', handleCopySchedules);
    sgCopierCopySchedulesButton.addEventListener('click', handleCopySchedules);
    sgCopierPasteSchedulesButton.removeEventListener('click', handlePasteSchedules);
    sgCopierPasteSchedulesButton.addEventListener('click', handlePasteSchedules);
    console.log("Schedule Generator's Copier Controls Initialized/Refreshed.");
}
// --- END: Schedule Copier (within Schedule Generator) Tool Specific Functions ---

// --- UI Navigation & State ---
function showSection(sectionId) {
    allToolContentSections.forEach(section => {
        section.style.display = 'none';
    });
    const sectionToShow = document.getElementById(sectionId);
    if (sectionToShow) {
        sectionToShow.style.display = 'block';
        const isMainButtonSection = Array.from(mainMenuButtons).some(btn => btn.getAttribute('data-section') === sectionId);
        if (isMainButtonSection) localStorage.setItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY, sectionId);

        if (sectionId === 'bulk-edit-tools-section') {
            populateRouteSelectorForColours(); renderGlobalCustomRouteColours();
            populateStopSelectorForSpecificColours(); renderStopSpecificRouteColours();
            if (selectStopForSpecificRouteColour?.value) displayRoutesForSpecificColouring();
        } else if (sectionId === 'stop-management-tool-section') populateMasterStopList_SM();
        else if (sectionId === 'view-departures-section') {
            populateStopSelectorForDeparturesView();
            if(selectStopForDeparturesView?.value) displayDeparturesForSelectedStop();
        } else if (sectionId === 'add-remove-stop-section') {
            handleSuggestStopId_ARS(); populateStopToRemoveSelector_ARS();
        } else if (sectionId === 'schedule-generator-section') {
            gen_initializeScheduleGeneratorControls(); initializeScheduleGeneratorCopierControls();
        } else if (sectionId === 'analytics-validation-section') populateConsolidateStopSelect();
        else if (sectionId === 'global-route-deletion-section') populateGlobalRouteToDeleteSelector();
        else if (sectionId === 'route-timetable-overwrite-section') populate_rto_SelectRoute();
        else if (sectionId === 'operating-profiles-section') displayUniqueOperatingProfiles();
        else if (sectionId === 'route-stops-explorer-section') {
            populate_rse_SelectRoute();
            if(rse_selectRoute?.value) displayRouteStopsExplorer();
            else {
                if(rse_direction1_title) rse_direction1_title.textContent = "Direction 1: (Select Route)";
                if(rse_direction1_stopsList) rse_direction1_stopsList.innerHTML = "";
                if(rse_direction1_placeholder) rse_direction1_placeholder.style.display = 'block';
                if(rse_direction2_title) rse_direction2_title.textContent = "Direction 2: (Select Route)";
                if(rse_direction2_stopsList) rse_direction2_stopsList.innerHTML = "";
                if(rse_direction2_placeholder) rse_direction2_placeholder.style.display = 'block';
                if(rse_statusMessage) rse_statusMessage.textContent = "";
            }
        }
    } else console.warn(`Attempted to show non-existent section: ${sectionId}`);
}

function hideAllToolSections() { allToolContentSections.forEach(s => s.style.display = 'none'); }
function updateAuthUI(user) {
    currentUser = user;
    hideAllToolSections();
    if (user) {
        if (adminLoginSection) adminLoginSection.style.display = 'none';
        if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'block';
        if (topMenuBar) topMenuBar.style.display = 'block';
        if (logoutContainer) logoutContainer.style.display = 'block';
        if (loginFormContainer) loginFormContainer.style.display = 'none';
        if (authStatus) authStatus.textContent = '';
        if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = user.email;
        loadInitialData();
        initializeAutoApplyScheduler();
        const lastActiveSection = localStorage.getItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        let sectionShown = false;
        if (lastActiveSection) {
            const sectionEl = document.getElementById(lastActiveSection);
            const isKnownMenu = Array.from(mainMenuButtons).some(b=>b.dataset.section === lastActiveSection);
            if (sectionEl && isKnownMenu) { showSection(lastActiveSection); sectionShown = true; }
            else localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        }
        if (!sectionShown && mainMenuButtons.length > 0 && mainMenuButtons[0].dataset.section) {
            showSection(mainMenuButtons[0].dataset.section);
        }
    } else {
        if (adminLoginSection) adminLoginSection.style.display = 'block';
        if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'none';
        if (topMenuBar) topMenuBar.style.display = 'none';
        if (logoutContainer) logoutContainer.style.display = 'none';
        if (loginFormContainer) loginFormContainer.style.display = 'block';
        if (authStatus) authStatus.textContent = 'Please log in to use the tools.';
        if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = '';
        localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        stopAutoApplyScheduler();
        currentWorkingSchedule = []; closedStopIDs = []; globalCustomRouteColours = {}; stopSpecificRouteColours = {};
        renderUIDependentElements();
    }
}

// --- Analytics Functions ---
function detectDuplicateEntries() {
    if (!currentUser || currentWorkingSchedule.length === 0) {
        if (duplicateEntriesResults) duplicateEntriesResults.innerHTML = '<p>No schedule data or not logged in.</p>'; return;
    }
    const signatures = new Map(); const duplicates = [];
    currentWorkingSchedule.forEach((entry, index) => {
        const profileString = (entry.OperatingProfile || "").toLowerCase().split(',').map(s => s.trim()).sort().join(',');
        const signature = [(entry.stopID || "").toUpperCase(), (entry.lineName || "").toUpperCase(), entry.scheduledTime || "00:00", profileString, entry.DayOffset || "0", (entry.destinationName || "").trim()].join('|');
        if (signatures.has(signature)) signatures.get(signature).push(index);
        else signatures.set(signature, [index]);
    });
    signatures.forEach((indices, sig) => {
        if (indices.length > 1) duplicates.push(indices.map(originalIndex => ({...currentWorkingSchedule[originalIndex], originalIndex})));
    });
    if (duplicateEntriesResults) {
        if (duplicates.length === 0) duplicateEntriesResults.innerHTML = '<p>No duplicate entries found.</p>';
        else {
            let html = `<p>Found ${duplicates.length} set(s) of duplicates:</p><ul>`;
            duplicates.forEach((set, i) => {
                html += `<li class="duplicate-set"><strong>Set ${i + 1}:</strong> (Appears ${set.length} times)`;
                set.forEach(e => { html += `<span class="entry-detail"> - Stop: ${e.stopID}, Line: ${e.lineName}, Time: ${e.scheduledTime}, Profile: ${e.OperatingProfile}, Dest: ${e.destinationName} (Idx: ${e.originalIndex})</span>`; });
                html += `</li>`;
            });
            duplicateEntriesResults.innerHTML = html + `</ul>`;
        }
    }
}
function handleRemoveDuplicateEntries() {
    if (!currentUser) { alert("Please log in."); if(removeDuplicatesStatusMessage) removeDuplicatesStatusMessage.textContent = "Not logged in."; return; }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) { alert("Working schedule empty."); if(removeDuplicatesStatusMessage) removeDuplicatesStatusMessage.textContent = "Working schedule empty."; return; }
    const initialCount = currentWorkingSchedule.length; const signaturesEncountered = new Set(); const deduplicatedSchedule = [];
    currentWorkingSchedule.forEach(entry => {
        const profileString = (entry.OperatingProfile || "").toLowerCase().split(',').map(s=>s.trim()).sort().join(',');
        const signature = [(entry.stopID||"").toUpperCase(), (entry.lineName||"").toUpperCase(), entry.scheduledTime||"00:00", profileString, entry.DayOffset||"0", (entry.destinationName||"").trim()].join('|');
        if (!signaturesEncountered.has(signature)) { signaturesEncountered.add(signature); deduplicatedSchedule.push(entry); }
    });
    const removedCount = initialCount - deduplicatedSchedule.length;
    if (removedCount === 0) { alert("No duplicates found."); if(removeDuplicatesStatusMessage){ removeDuplicatesStatusMessage.textContent = "No duplicates found."; removeDuplicatesStatusMessage.style.color = ""; } return; }
    if (confirm(`Found ${removedCount} duplicates. Remove them (keeping first occurrence)?`)) {
        currentWorkingSchedule = deduplicatedSchedule;
        if(removeDuplicatesStatusMessage){ removeDuplicatesStatusMessage.textContent = `${removedCount} duplicates removed.`; removeDuplicatesStatusMessage.style.color = '#2ecc71'; }
        alert(`${removedCount} duplicates removed.`); renderUIDependentElements(); detectDuplicateEntries(); updateStagingStatusDisplay();
    } else { if(removeDuplicatesStatusMessage){ removeDuplicatesStatusMessage.textContent = "Cancelled by user."; removeDuplicatesStatusMessage.style.color = '#f1c40f'; } }
}

// --- START: Consolidate Operating Days Functions ---
function populateConsolidateStopSelect() {
    if (!consolidateStopSelect) return;
    const currentVal = consolidateStopSelect.value;
    consolidateStopSelect.innerHTML = '<option value="">-- Select Stop --</option>';
    const uniqueStops = getUniqueStopsFromSchedule();
    if (uniqueStops.length === 0) { consolidateStopSelect.innerHTML = '<option value="">-- No Stops --</option>'; populateConsolidateRouteSelect(); return; }
    uniqueStops.forEach(stop => { const opt=document.createElement('option'); opt.value=stop.stopID; opt.textContent=`${stop.stopName} (${stop.stopID})`; consolidateStopSelect.appendChild(opt); });
    if (uniqueStops.find(s => s.stopID === currentVal)) consolidateStopSelect.value = currentVal;
    populateConsolidateRouteSelect();
}
function populateConsolidateRouteSelect() {
    if (!consolidateRouteSelect || !consolidateStopSelect) return;
    const selectedStopId = consolidateStopSelect.value; const currentRouteVal = consolidateRouteSelect.value;
    consolidateRouteSelect.innerHTML = '<option value="">-- Select Route --</option>';
    if (!selectedStopId) { consolidateRouteSelect.innerHTML = '<option value="">-- Select Stop First --</option>'; return; }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) return;
    const routesForStop = [...new Set(currentWorkingSchedule.filter(e => e.stopID === selectedStopId && e.lineName).map(e => e.lineName))].sort(compareLineNames);
    if (routesForStop.length === 0) consolidateRouteSelect.innerHTML = `<option value="">-- No Routes for Stop ${selectedStopId} --</option>`;
    else { routesForStop.forEach(ln => { const opt=document.createElement('option'); opt.value=ln; opt.textContent=ln; consolidateRouteSelect.appendChild(opt); });
           if (routesForStop.includes(currentRouteVal)) consolidateRouteSelect.value = currentRouteVal; }
}
function handleConsolidateOperatingDays() {
    if (!currentUser) { alert("Please log in."); consolidateOpDaysStatusMessage.textContent = "Not logged in."; return; }
    const stopId = consolidateStopSelect.value; const lineName = consolidateRouteSelect.value; const newProfile = consolidateNewProfileInput.value.trim();
    if (!stopId) { consolidateOpDaysStatusMessage.textContent = "Select Stop ID."; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return; }
    if (!lineName) { consolidateOpDaysStatusMessage.textContent = "Select Route."; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return; }
    if (!newProfile) { consolidateOpDaysStatusMessage.textContent = "Enter new combined Operating Profile."; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return; }
    const relevantEntriesForStopRoute = currentWorkingSchedule.filter(e => e.stopID === stopId && e.lineName === lineName);
    if (relevantEntriesForStopRoute.length === 0) { consolidateOpDaysStatusMessage.textContent = `No entries for Stop ${stopId}, Line ${lineName}.`; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return; }
    const groups = new Map();
    relevantEntriesForStopRoute.forEach(e => { const key = `${e.scheduledTime}|${e.destinationName||""}|${e.DayOffset||"0"}`; if(!groups.has(key)) groups.set(key, []); groups.get(key).push(e); });
    let consolidatedGroupCount = 0; let entriesToRemoveInternalIds = new Set(); let modifiedEntries = [];
    groups.forEach((group, key) => {
        if (group.length > 1) { consolidatedGroupCount++; const firstEntry = {...group[0]}; firstEntry.OperatingProfile = newProfile; modifiedEntries.push(firstEntry);
                               for (let i = 1; i < group.length; i++) { if (group[i].internalId) entriesToRemoveInternalIds.add(group[i].internalId); else console.warn("Entry missing internalId:", group[i]); }
        } else modifiedEntries.push(group[0]);
    });
    const otherEntries = currentWorkingSchedule.filter(e => e.stopID !== stopId || e.lineName !== lineName);
    if (consolidatedGroupCount === 0) { consolidateOpDaysStatusMessage.textContent = "No entries found to consolidate."; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return; }
    const actualRemovedCount = entriesToRemoveInternalIds.size;
    if (!confirm(`Found ${consolidatedGroupCount} group(s) for Stop ${stopId}, Route ${lineName}. Update one per group to profile "${newProfile}" and remove ${actualRemovedCount} other entries?`)) {
        consolidateOpDaysStatusMessage.textContent = "Consolidation cancelled."; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return;
    }
    currentWorkingSchedule = [...otherEntries, ...modifiedEntries.filter(mEntry => !entriesToRemoveInternalIds.has(mEntry.internalId))];
    consolidateOpDaysStatusMessage.textContent = `Consolidated ${consolidatedGroupCount} group(s) for Stop ${stopId}, Route ${lineName}. ${actualRemovedCount} entries removed. Profile "${newProfile}".`;
    consolidateOpDaysStatusMessage.style.color = '#2ecc71'; alert(`Operating days consolidated. ${actualRemovedCount} entries removed.`);
    renderUIDependentElements(); detectDuplicateEntries(); updateStagingStatusDisplay();
}
// --- END: Consolidate Operating Days Functions ---

// --- Utility Functions (Date, Sorting, Parsing etc.) ---
function parseLineName(lineNameStr) { const name = String(lineNameStr || "").toUpperCase().trim(); const numericPrefixRegex = new RegExp(/^(\d+)([A-Z]*)$/); const alphaNumericRegex = new RegExp(/^([A-Z]+)(\d+)?([A-Z]*)$/); const numericPrefixMatch = name.match(numericPrefixRegex); if (numericPrefixMatch) return { type: 'numeric', number: parseInt(numericPrefixMatch[1], 10), suffix: numericPrefixMatch[2] || '', original: name }; const alphaNumericMatch = name.match(alphaNumericRegex); if (alphaNumericMatch) return { type: 'alpha', prefix: alphaNumericMatch[1], number: alphaNumericMatch[2] ? parseInt(alphaNumericMatch[2], 10) : null, suffix: alphaNumericMatch[3] || '', original: name }; return { type: 'other', original: name }; }
function compareLineNames(lineAStr, lineBStr) { const parsedA = parseLineName(lineAStr); const parsedB = parseLineName(lineBStr); if (parsedA.type === 'numeric' && parsedB.type === 'alpha') return -1; if (parsedA.type === 'alpha' && parsedB.type === 'numeric') return 1; if (parsedA.type === 'numeric' && parsedB.type === 'numeric') { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type === 'alpha' && parsedB.type === 'alpha') { const prefixCompare = parsedA.prefix.localeCompare(parsedB.prefix); if (prefixCompare !== 0) return prefixCompare; if (parsedA.number === null && parsedB.number !== null) return -1; if (parsedA.number !== null && parsedB.number === null) return 1; if (parsedA.number !== null && parsedB.number !== null) { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; } return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type !== 'other' && parsedB.type === 'other') return -1; if (parsedA.type === 'other' && parsedB.type !== 'other') return 1; return (parsedA.original || "").localeCompare(parsedB.original || ""); }

function generateUniqueStopId(format) {
    const existingStopIDs = new Set(currentWorkingSchedule.map(entry => entry.stopID.toUpperCase()));
    let nextId = ""; let currentNum = 0; let attempts = 0; const maxAttempts = 100000;
    if (format === "NUM") {
        let maxNumeric = 100; existingStopIDs.forEach(id => { if (/^\d+$/.test(id)) { const num = parseInt(id, 10); if (num >= 101 && num > maxNumeric) maxNumeric = num; } });
        currentNum = maxNumeric + 1;
        while (attempts < maxAttempts) { nextId = String(currentNum); if (!existingStopIDs.has(nextId)) return nextId; currentNum++; attempts++; if (currentNum > 99999) break; }
    } else if (["BP", "LE", "RO"].includes(format)) {
        const prefix = format; let maxPrefixNum = 0; existingStopIDs.forEach(id => { if (id.startsWith(prefix)) { const numPart = id.substring(prefix.length); if (/^\d+$/.test(numPart)) { const num = parseInt(numPart, 10); if (num > maxPrefixNum) maxPrefixNum = num; } } });
        currentNum = maxPrefixNum + 1;
        while (attempts < maxAttempts) { nextId = prefix + currentNum; if (!existingStopIDs.has(nextId.toUpperCase())) return nextId; currentNum++; attempts++; if (currentNum > 99999) break; }
    }
    console.warn("Could not generate unique Stop ID for format:", format); return (format || "ID") + String(Date.now()).slice(-5) + String(Math.floor(Math.random()*90)+10);
}

function getOperatingCodesForToday_Tools() {
    const n = new Date(); const dOW = n.getDay(); const todayDateString = `${n.getFullYear()}-${String(n.getMonth()+1).padStart(2,'0')}-${String(n.getDate()).padStart(2,'0')}`;
    let dateCodes = new Set(); let isBankHolidayToday = false;
    if (ukBankHolidaysData && ukBankHolidaysData.dates && ukBankHolidaysData.dates.includes(todayDateString)) {
        const holidayTitle = ukBankHolidaysData.titles[todayDateString] || ""; isBankHolidayToday = true;
        if (holidayTitle.toLowerCase().includes("good friday")) dateCodes.add("Sa"); else dateCodes.add("Su");
    }
    if (!isBankHolidayToday) {
        const isSchHol = isSchoolHolidayPeriodForSetup(n); const schoolSuffix = isSchHol ? "NSD" : "Sch"; let dayCode = "";
        switch (dOW) { case 0: dayCode="Su"; break; case 1: dayCode="Mo"; break; case 2: dayCode="Tu"; break; case 3: dayCode="We"; break; case 4: dayCode="Th"; break; case 5: dayCode="Fr"; break; case 6: dayCode="Sa"; break; }
        dateCodes.add(dayCode);
        if (dOW >= 1 && dOW <= 5) { dateCodes.add(dayCode + schoolSuffix); dateCodes.add("MF" + schoolSuffix); dateCodes.add("Mo-Fr"); dateCodes.add("MF"); }
        if ((dOW === 6 || dOW === 0) && isSchHol) dateCodes.add(dayCode + "NSD");
        if (isSchHol) dateCodes.add("SchoolHoliday");
    } else { const isSchHolOnBH = isSchoolHolidayPeriodForSetup(n); if (isSchHolOnBH) { dateCodes.add("SchoolHoliday"); if(dateCodes.has("Sa")) dateCodes.add("SaNSD"); if(dateCodes.has("Su") && !dateCodes.has("Sa")) dateCodes.add("SuNSD"); } }
    return Array.from(dateCodes);
}
async function fetchBankHolidaysForSetup() { try { const response = await fetch('https://www.gov.uk/bank-holidays.json'); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); if (data['england-and-wales'] && data['england-and-wales'].events) { const events = data['england-and-wales'].events; ukBankHolidaysData = { dates: events.map(event => event.date), titles: events.reduce((acc, event) => { acc[event.date] = event.title; return acc; }, {}) }; } else { console.warn("Setup: Bank holiday data format issue."); ukBankHolidaysData = { dates: [], titles: {} }; } } catch (error) { console.error("Setup: Failed to fetch UK bank holidays:", error); ukBankHolidaysData = { dates: [], titles: {} }; if(currentProfileDisplayElement) currentProfileDisplayElement.textContent = "Today's Auto Profile: (Bank Hol. check failed)"; } updateCurrentProfileDisplayOnSetup(); }
function isSchoolHolidayPeriodForSetup(dateObject) { if (!schoolHolidayDateRanges || schoolHolidayDateRanges.length === 0) return false; const checkTime = dateObject.getTime(); for (const range of schoolHolidayDateRanges) { try { const startTime = new Date(range.start + "T00:00:00").getTime(); const endTime = new Date(range.end + "T23:59:59").getTime(); if (checkTime >= startTime && checkTime <= endTime) return true; } catch (e) { console.error("Invalid date in schoolHolidayDateRanges (setup):", range, e); } } return false; }
function updateCurrentProfileDisplayOnSetup() {
    const now = new Date(); const dayOfWeek = now.getDay(); const todayDateString = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
    let profileDisplayText = ""; let isBankHol = false; let serviceTypeDisplay = "";
    if (ukBankHolidaysData.dates && ukBankHolidaysData.dates.includes(todayDateString)) {
        const holidayTitle = ukBankHolidaysData.titles[todayDateString] || "Bank Holiday"; isBankHol = true;
        if (holidayTitle.toLowerCase().includes("good friday")) { profileDisplayText = "Good Friday"; serviceTypeDisplay = "(Sat Service)"; }
        else { profileDisplayText = holidayTitle; serviceTypeDisplay = "(Sun Service)"; }
    }
    let dayName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][dayOfWeek];
    if (!isBankHol) { profileDisplayText = dayName; const isSchHol = isSchoolHolidayPeriodForSetup(now); if (isSchHol) profileDisplayText += " (School Hol)"; }
    else { profileDisplayText += ` ${serviceTypeDisplay} - Observed on a ${dayName}`; const isSchHolOnBH = isSchoolHolidayPeriodForSetup(now); if (isSchHolOnBH) profileDisplayText += " (School Hol Period)"; }
    const operatingCodes = getOperatingCodesForToday_Tools();
    if (currentProfileDisplayElement) currentProfileDisplayElement.textContent = `Today's Auto Profile: ${profileDisplayText} [Codes: ${operatingCodes.join(', ')}]`;
}

// --- Form & Data Handling Functions ---
function isValidScheduleDataFromText(jsonData) { if (!jsonData || jsonData.length === 0) return false; const requiredColumns = ['StopID', 'StopName', 'Direction', 'LineName', 'DestinationName', 'ScheduledTime', 'OperatingProfile']; const firstEntry = jsonData[0]; const allColumnsPresent = requiredColumns.every(col => col in firstEntry); if (!allColumnsPresent) { const missingCols = requiredColumns.filter(col => !(col in firstEntry)); alert(`Uploaded .COUNT missing headers: ${missingCols.join(', ')}.\nExpected: StopID, StopName, Direction, LineName, DestinationName, ScheduledTime, OperatingProfile. DayOffset optional.`); return false; } return true; }
function handleCountFileUpload(event) { const file = event.target.files[0]; if (file) { if (fileStatusElement) fileStatusElement.textContent = `Processing ${file.name}...`; setTimeout(() => { const reader = new FileReader(); reader.onload = function(e) { try { const fileContent = e.target.result; const lines = fileContent.split(/\r?\n/); if (lines.length < 2) { alert("File empty/no data."); if(fileStatusElement) fileStatusElement.textContent="File processing failed."; if(countFileInput)countFileInput.value=""; return; } const headers = lines[0].split('\t').map(h=>h.trim()); const jsonData = []; for (let i = 1; i < lines.length; i++) { const line = lines[i].trim(); if (line === "") continue; const values = line.split('\t').map(v=>v.trim()); if (values.length < headers.length && values.every(v=>v==="")) continue; if (values.length < headers.length && values.length > 0) for(let k=values.length;k<headers.length;k++)values.push(''); let entry = {}; headers.forEach((h,idx)=>entry[h]=values[idx]!==undefined?values[idx]:""); jsonData.push(entry); } if (isValidScheduleDataFromText(jsonData)) { if (currentWorkingSchedule.length > 0 && !confirm("Replace current working schedule with this file?")) { if(fileStatusElement)fileStatusElement.textContent="Upload cancelled."; if(countFileInput)countFileInput.value=""; return; } currentWorkingSchedule = jsonData.map((row,idx) => { let schTime = String(row.ScheduledTime||"").trim(); if(schTime.match(/^\d{1,2}:\d{2}(:\d{2})?$/)){const p=schTime.split(':'); schTime=`${String(p[0]).padStart(2,'0')}:${String(p[1]).padStart(2,'0')}`; } else if(schTime.length===4&&!schTime.includes(':')) schTime=`${schTime.substring(0,2)}:${schTime.substring(2,4)}`; else if(schTime.length===3&&!schTime.includes(':')) schTime=`0${schTime.substring(0,1)}:${schTime.substring(1,3)}`; return { internalId: `${String(row.StopID||'s').trim().toUpperCase()}_${String(row.LineName||'l').trim().toUpperCase()}_${schTime.replace(':','')}_${idx}_countfile`, stopID: String(row.StopID||"").trim().toUpperCase(), stopName: String(row.StopName||"").trim(), direction: String(row.Direction||"").trim(), lineName: String(row.LineName||"").trim().toUpperCase(), destinationName: String(row.DestinationName||"").trim(), scheduledTime: schTime, OperatingProfile: String(row.OperatingProfile||"").trim(), DayOffset: String(row.DayOffset||"0").trim() }; }); renderUIDependentElements(); updateStagingStatusDisplay(); if(fileStatusElement) fileStatusElement.textContent = `${file.name} processed. ${currentWorkingSchedule.length} entries loaded.`; } else { if(fileStatusElement) fileStatusElement.textContent = "File processing failed: Invalid structure/headers."; } } catch (error) { console.error("Error processing .COUNT file:", error); alert(`Error: ${error.message}.`); if(fileStatusElement) fileStatusElement.textContent = "Error loading file."; } if(countFileInput)countFileInput.value=""; }; reader.onerror = () => { alert("Could not read file."); if(fileStatusElement) fileStatusElement.textContent = "Error reading file."; if(countFileInput) countFileInput.value = ""; }; reader.readAsText(file); }, 50); } }
function handleBulkUpdateRouteDestination() {
    if (!currentUser) { alert("Please log in."); return; }
    const targetLineName = bulkEditTargetLineNameInput.value.trim().toUpperCase();
    const oldDestination = bulkEditOldDestinationInput.value.trim();
    const newDestination = bulkEditNewDestinationInput.value.trim();
    if (!targetLineName) { alert("Target Line Name required."); bulkEditTargetLineNameInput.focus(); return; }
    if (!newDestination) { alert("New Destination Name required."); bulkEditNewDestinationInput.focus(); return; }
    let updatedCount = 0;
    currentWorkingSchedule.forEach(entry => {
        if (entry.lineName && entry.lineName.toUpperCase() === targetLineName) {
            if (oldDestination) { if (entry.destinationName && entry.destinationName.toLowerCase() === oldDestination.toLowerCase()) { entry.destinationName = newDestination; updatedCount++; } }
            else { entry.destinationName = newDestination; updatedCount++; }
        }
    });
    if (updatedCount > 0) { renderUIDependentElements(); updateStagingStatusDisplay(); alert(`${updatedCount} entries for Line "${targetLineName}" updated to "${newDestination}".`); }
    else { alert(`No entries for Line "${targetLineName}"` + (oldDestination ? ` with Old Destination "${oldDestination}"` : "") + " found."); }
}

// --- Firebase Data Interaction ---
function handleStageSchedule() { if (!currentUser) { alert("Log in to stage."); return; } if (currentWorkingSchedule.length === 0 && !confirm("Working schedule empty. Stage empty schedule?")) { stagingStatusMessage.textContent = "Staging empty cancelled."; stagingStatusMessage.style.color = "#e74c3c"; return; } let dataToStage = JSON.parse(JSON.stringify(currentWorkingSchedule)); dataToStage.sort((a, b) => { const lineCmp = compareLineNames(a.lineName, b.lineName); if (lineCmp !== 0) return lineCmp; const timeA = (a.scheduledTime || "").replace(':', ''); const timeB = (b.scheduledTime || "").replace(':', ''); const timeCmp = timeA.localeCompare(timeB); if (timeCmp !== 0) return timeCmp; return (a.stopID || "").localeCompare(b.stopID || ""); }); const finalScheduleData = dataToStage.map((entry, index) => ({ ...entry, internalId: entry.internalId || `${entry.stopID.toUpperCase()}_${entry.lineName.toUpperCase()}_${(entry.scheduledTime||"").replace(':','')}_${index}_staged` })); const stopsMap = new Map(); finalScheduleData.forEach(row => { if (row.stopID && !stopsMap.has(row.stopID.toUpperCase())) stopsMap.set(row.stopID.toUpperCase(), { stopID: row.stopID, stopName: row.stopName, direction: row.direction }); }); const finalUniqueStops = Array.from(stopsMap.values()).sort((a,b)=>{ const nC=(a.stopName||"").localeCompare(b.stopName||""); return nC!==0?nC:(a.direction||"").localeCompare(b.direction||""); }); if (window.firebaseOMSI) { const { database, dbUpdate, dbRef } = window.firebaseOMSI; const updates = {}; updates[FB_PATH_PENDING_SCHEDULE_DATA] = finalScheduleData; updates[FB_PATH_PENDING_UNIQUE_STOPS] = finalUniqueStops; updates[FB_PATH_PENDING_TIMESTAMP] = new Date().toISOString(); updates[FB_PATH_APPSTATE_STATUS] = 'update_staged'; dbUpdate(dbRef(database), updates).then(() => { alert("Schedule STAGED to Firebase."); updateStagingStatusDisplay(); }).catch((e) => { console.error("FB Staging Error: ", e); alert("FB Staging Error."); if(stagingStatusMessage) { stagingStatusMessage.textContent = "FB Staging Error."; stagingStatusMessage.style.color = "#e74c3c"; } }); } else alert("Firebase not available."); }
function handleApplyNow() { if (!currentUser) { alert("Log in to apply."); return; } if (window.firebaseOMSI) { const { database, dbGet, dbUpdate, dbRef, dbChild } = window.firebaseOMSI; dbGet(dbChild(dbRef(database), '/pendingSchedule')).then((snapshot) => { if (snapshot.exists()) { const pendingData = snapshot.val(); if (!confirm("Apply Firebase staged schedule LIVE NOW?")) { if (stagingStatusMessage) { stagingStatusMessage.textContent = "Apply cancelled."; stagingStatusMessage.style.color = "#e74c3c"; } return; } let liveAllScheduledBusData = Array.isArray(pendingData.allScheduledBusData) ? pendingData.allScheduledBusData.filter(item => item != null) : (typeof pendingData.allScheduledBusData === 'object' && pendingData.allScheduledBusData !== null ? Object.values(pendingData.allScheduledBusData).filter(item => item != null) : []); let liveUniqueBusStops = Array.isArray(pendingData.uniqueBusStops) ? pendingData.uniqueBusStops.filter(item => item != null) : (typeof pendingData.uniqueBusStops === 'object' && pendingData.uniqueBusStops !== null ? Object.values(pendingData.uniqueBusStops).filter(item => item != null) : []); let hasInvalidKey = false; function check(obj, path) { if (typeof obj !== 'object' || obj === null) return; for (const key in obj) { if (/[.#$/\[\]]/.test(key)) { console.error(`INVALID KEY at ${path}: key='${key}'`); hasInvalidKey = true; } if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) check(obj[key], `${path}.${key}`); } } liveAllScheduledBusData.forEach((item, i) => { if (typeof item !== 'object' || item === null) { hasInvalidKey = true; console.error(`Schedule item at index ${i} non-object/null.`); return; } check(item, `schedule[${i}]`); }); liveUniqueBusStops.forEach((item, i) => { if (typeof item !== 'object' || item === null) { hasInvalidKey = true; console.error(`Stop item at index ${i} non-object/null.`); return; } check(item, `stops[${i}]`); }); if (hasInvalidKey) { alert("Invalid keys found in data (e.g. '.', '#', '$', '/', '[', ']'). Cannot apply."); return; } const liveUpdates = {}; liveUpdates[FB_PATH_LIVE_SCHEDULE_DATA] = liveAllScheduledBusData; liveUpdates[FB_PATH_LIVE_UNIQUE_STOPS] = liveUniqueBusStops; dbUpdate(dbRef(database), liveUpdates).then(() => { const appUpdates = {}; appUpdates[FB_PATH_APPSTATE_LAST_UPDATED] = new Date().toISOString(); appUpdates[FB_PATH_APPSTATE_STATUS] = 'idle'; appUpdates['/pendingSchedule'] = null; return dbUpdate(dbRef(database), appUpdates); }).then(() => { alert("Staged schedule APPLIED LIVE!"); updateStagingStatusDisplay(); }).catch(e => { console.error("FB Apply Error: ", e); alert("FB Apply Error: " + e.message); }); } else { alert("No Firebase staged schedule to apply."); if (stagingStatusMessage) { stagingStatusMessage.textContent = "No FB staged schedule."; stagingStatusMessage.style.color = "#e74c3c"; } } }).catch(e => { console.error("FB Fetch Pending Error: ", e); alert("FB Fetch Pending Error: " + e.message); }); } else alert("Firebase not available."); }
async function loadInitialData() {
    console.log("Tools: Loading initial data from Firebase..."); let msg = "Loading data..."; if (fileStatusElement) fileStatusElement.textContent = msg;
    currentWorkingSchedule = []; closedStopIDs = []; globalCustomRouteColours = {}; stopSpecificRouteColours = {};
    if (!window.firebaseOMSI) msg = "Firebase not connected.";
    else { const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try {
            const liveSnap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_SCHEDULE_DATA));
            if (liveSnap.exists() && Array.isArray(liveSnap.val())) currentWorkingSchedule = liveSnap.val().map((e,i)=>({...e, internalId: e.internalId || `${(e.stopID||'s')}_${(e.lineName||'l')}_${(e.scheduledTime||"").replace(':','')}_${i}_fb`}));
            else if (liveSnap.exists()) { console.warn("Live schedule not array, converting from object."); currentWorkingSchedule = Object.values(liveSnap.val()).map((e,i)=>({...e, internalId: e.internalId || `${(e.stopID||'s')}_${(e.lineName||'l')}_${(e.scheduledTime||"").replace(':','')}_${i}_fb`})); }
            const closedSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_CLOSED_STOPS)); if (closedSnap.exists()) { const fbClosed = closedSnap.val(); for(const id in fbClosed) if(fbClosed[id]===true) closedStopIDs.push(id); }
            const globalColoursSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS)); if (globalColoursSnap.exists()) globalCustomRouteColours = globalColoursSnap.val();
            const stopSpecificColoursSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS)); if (stopSpecificColoursSnap.exists()) stopSpecificRouteColours = stopSpecificColoursSnap.val();
            msg = `Data loaded. ${currentWorkingSchedule.length} schedule entries.`;
        } catch (e) { console.error("FB Load Error:", e); msg = "FB Load Error."; }
    }
    if (fileStatusElement) fileStatusElement.textContent = msg; compileEffectiveRouteColoursForTools(); renderUIDependentElements(); updateStagingStatusDisplay(); fetchBankHolidaysForSetup();
}
async function updateStagingStatusDisplay() { let pTime = null; let lTime = null; let fbStatus = "Checking..."; if (window.firebaseOMSI) { const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const pSnap = await dbGet(dbChild(dbRef(database), FB_PATH_PENDING_TIMESTAMP)); if (pSnap.exists()) pTime = pSnap.val(); const lSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_LAST_UPDATED)); if (lSnap.exists()) lTime = lSnap.val(); const sSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_STATUS)); const currentFbSt = sSnap.exists() ? sSnap.val() : 'unknown'; fbStatus = `Firebase status: ${currentFbSt}.`; applyNowButton.disabled = !(currentFbSt === 'update_staged' && pTime); } catch (e) { fbStatus = "FB Status Error."; console.error(fbStatus, e); applyNowButton.disabled = true;} } else { fbStatus = "Firebase not available."; applyNowButton.disabled = true;} let msg = ""; if (pTime && applyNowButton.disabled === false) { msg = `STAGED on: ${new Date(pTime).toLocaleString()}.<br>Ready to 'Apply Staged Live NOW'.`; if(stagingStatusMessage) stagingStatusMessage.style.color = "#2ecc71"; } else { msg = "No schedule staged. Changes can be staged."; if(stagingStatusMessage) stagingStatusMessage.style.color = "#f1c40f"; } msg += lTime ? `<br>LIVE schedule last updated: ${new Date(lTime).toLocaleString()}` : "<br>No LIVE schedule set yet."; msg += `<br><small>(${fbStatus})</small>`; if(stagingStatusMessage) stagingStatusMessage.innerHTML = msg; }
function saveClosedStopsToFirebase() {
    if (!currentUser) return; if (window.firebaseOMSI) { const { database, dbRef, dbUpdate } = window.firebaseOMSI; const fbClosedObject = {}; closedStopIDs.forEach(id => fbClosedObject[id.toUpperCase()] = true); const updates = {}; updates[FB_PATH_APPSTATE_CLOSED_STOPS] = fbClosedObject; dbUpdate(dbRef(database), updates).then(() => { console.log("Closed stops saved to Firebase."); if (masterStopListStatus_SM && document.getElementById('stop-management-tool-section')?.style.display === 'block') { masterStopListStatus_SM.textContent = "Stop status updated in Firebase."; setTimeout(() => { if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Showing ${masterStopListUL_SM.children.length} of ${uniqueStopsMasterList_SM.length} unique stops.`;}, 2000); } populateMasterStopList_SM(); }).catch(e => { console.error("FB Save Closed Stops Error: ", e); if (masterStopListStatus_SM) masterStopListStatus_SM.textContent = "Error saving stop status."; }); }
}
function saveGlobalCustomRouteColours() {
    if (!currentUser) return; if (window.firebaseOMSI) { const { database, dbSet, dbRef } = window.firebaseOMSI; dbSet(dbRef(database, FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS), globalCustomRouteColours).then(() => console.log("Global custom route colours saved.")).catch(e => console.error("FB Save Global Colours Error: ", e)); } if (routeColourStatusMessage) { routeColourStatusMessage.textContent = 'Global custom colours saved.'; setTimeout(() => { if(routeColourStatusMessage) routeColourStatusMessage.textContent = ''; }, 3000); } compileEffectiveRouteColoursForTools(); renderGlobalCustomRouteColours(); if(selectStopForDeparturesView?.value) displayDeparturesForSelectedStop(); if (selectStopForSpecificRouteColour?.value) displayRoutesForSpecificColouring(); if (document.getElementById('stop-management-tool-section')?.style.display === 'block') populateMasterStopList_SM();
}
function saveStopSpecificRouteColoursToFirebase() {
    if (!currentUser) { if(stopSpecificRouteColourStatusMessage) {stopSpecificRouteColourStatusMessage.textContent="Not logged in."; stopSpecificRouteColourStatusMessage.style.color='#e74c3c';} return; }
    if (window.firebaseOMSI) { const { database, dbSet, dbRef } = window.firebaseOMSI; dbSet(dbRef(database, FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS), stopSpecificRouteColours).then(() => { console.log("Stop-specific route colours saved."); if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent='Stop-specific colours saved.'; stopSpecificRouteColourStatusMessage.style.color='#2ecc71'; setTimeout(()=>{if(stopSpecificRouteColourStatusMessage)stopSpecificRouteColourStatusMessage.textContent='';},3000);} compileEffectiveRouteColoursForTools(); renderStopSpecificRouteColours(); if (selectStopForSpecificRouteColour?.value) displayRoutesForSpecificColouring(); if (document.getElementById('stop-management-tool-section')?.style.display==='block') populateMasterStopList_SM(); if (selectStopForDeparturesView?.value) displayDeparturesForSelectedStop(); }).catch(e => { console.error("FB Save Stop-Specific Colours Error:", e); if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent='Error saving stop-specific colours.'; stopSpecificRouteColourStatusMessage.style.color='#e74c3c';} });
    } else { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent='Firebase not available.'; stopSpecificRouteColourStatusMessage.style.color='#e74c3c';} }
}

// --- UI Population & Rendering ---
function setGlobalRouteColour(colour) { if (inputRouteColour) inputRouteColour.value = colour; }
function setStopSpecificRouteColour(colour) { if (inputStopSpecificRouteColour) inputStopSpecificRouteColour.value = colour; }

function renderUIDependentElements() {
    if(currentUser) {
        populateRouteSelectorForColours(); populateStopSelectorForSpecificColours(); populateStopSelectorForDeparturesView();
        renderGlobalCustomRouteColours(); renderStopSpecificRouteColours(); populateStopToRemoveSelector_ARS();
        populateConsolidateStopSelect(); populateCopierStopSelectors(); populateGlobalRouteToDeleteSelector();
        populate_rse_SelectRoute();
        const scheduleGeneratorSection = document.getElementById('schedule-generator-section');
        if (scheduleGeneratorSection && scheduleGeneratorSection.style.display === 'block') { console.log("renderUIDependentElements: Refreshing Schedule Generator controls."); gen_initializeScheduleGeneratorControls(); initializeScheduleGeneratorCopierControls(); }
        const activeSectionId = localStorage.getItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        if (activeSectionId) {
            const sectionElement = document.getElementById(activeSectionId);
            if (sectionElement && sectionElement.style.display === 'block') {
                console.log(`renderUIDependentElements: Processing active section: ${activeSectionId}`);
                if (activeSectionId === 'bulk-edit-tools-section') { populateRouteSelectorForColours(); renderGlobalCustomRouteColours(); populateStopSelectorForSpecificColours(); renderStopSpecificRouteColours(); if (selectStopForSpecificRouteColour?.value) displayRoutesForSpecificColouring(); }
                else if (activeSectionId === 'view-departures-section') { populateStopSelectorForDeparturesView(); if(selectStopForDeparturesView?.value) displayDeparturesForSelectedStop(); }
                else if (activeSectionId === 'stop-management-tool-section') populateMasterStopList_SM();
                else if (activeSectionId === 'global-route-deletion-section') populateGlobalRouteToDeleteSelector();
                else if (activeSectionId === 'route-timetable-overwrite-section') { console.log("renderUIDependentElements: Refreshing rto_selectRoute for 'Route Timetable Override'."); populate_rto_SelectRoute(); }
                else if (activeSectionId === 'analytics-validation-section') populateConsolidateStopSelect();
                else if (activeSectionId === 'add-remove-stop-section') populateStopToRemoveSelector_ARS();
                else if (activeSectionId === 'operating-profiles-section') { console.log("renderUIDependentElements: Refreshing unique operating profiles."); displayUniqueOperatingProfiles(); }
                else if (activeSectionId === 'route-stops-explorer-section') { populate_rse_SelectRoute(); if (rse_selectRoute?.value) displayRouteStopsExplorer(); }
            }
        }
    } else {
        const allSelects = document.querySelectorAll('select');
        allSelects.forEach(sel => {
            const firstOptionText = sel.options[0] ? sel.options[0].textContent : "-- Select --"; const firstOptionValue = sel.options[0] ? sel.options[0].value : "";
            sel.innerHTML = `<option value="${firstOptionValue}">${firstOptionText}</option>`;
        });
        if(currentRouteColoursList) currentRouteColoursList.innerHTML = ""; if(noCustomColoursMessage) noCustomColoursMessage.style.display = 'block';
        if(currentStopSpecificColoursList) currentStopSpecificColoursList.innerHTML = ""; if(noStopSpecificColoursMessageEl) noStopSpecificColoursMessageEl.style.display = 'block';
        if(stopDeparturesList) stopDeparturesList.innerHTML = ""; if(noDeparturesForStopMessage) noDeparturesForStopMessage.style.display = 'block';
        if(masterStopListUL_SM) masterStopListUL_SM.innerHTML = ""; if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = 'Please log in.';
        if(duplicateEntriesResults) duplicateEntriesResults.innerHTML = '<p>Please log in.</p>'; if(gen_currentScheduleEntries) gen_currentScheduleEntries = []; gen_renderScheduleTable();
        if(rse_direction1_stopsList) rse_direction1_stopsList.innerHTML = ""; if(rse_direction2_stopsList) rse_direction2_stopsList.innerHTML = "";
        if(rse_direction1_placeholder) rse_direction1_placeholder.style.display = 'block'; if(rse_direction2_placeholder) rse_direction2_placeholder.style.display = 'block';
        if(rse_direction1_title) rse_direction1_title.textContent = "Direction 1: (Select Route)"; if(rse_direction2_title) rse_direction2_title.textContent = "Direction 2: (Select Route)";
    }
}

function compileEffectiveRouteColoursForTools() { /* console.log("Effective route colours re-evaluation triggered."); */ }
function renderGlobalCustomRouteColours() {
    if (!currentRouteColoursList || !noCustomColoursMessage) return; currentRouteColoursList.innerHTML = '';
    const routes = Object.keys(globalCustomRouteColours).sort(compareLineNames); let hasTrueCustoms = routes.length > 0;
    if (!hasTrueCustoms && Object.keys(initialRouteColourMapForTools).every(key => !globalCustomRouteColours[key.toUpperCase()])) { noCustomColoursMessage.textContent = 'No global custom colours. Using initial defaults or system default.'; noCustomColoursMessage.style.display = 'block'; }
    else noCustomColoursMessage.style.display = 'none';
    const allDisplayableGlobalRoutes = [...new Set([...Object.keys(initialRouteColourMapForTools).map(k=>k.toUpperCase()), ...Object.keys(globalCustomRouteColours).map(k=>k.toUpperCase())])].sort(compareLineNames);
    allDisplayableGlobalRoutes.forEach(rName => {
        const isCustom = globalCustomRouteColours.hasOwnProperty(rName); const color = globalCustomRouteColours[rName] || initialRouteColourMapForTools[rName] || DEFAULT_ROUTE_COLOUR_TOOLS;
        const li = document.createElement('li'); li.style.display='flex'; li.style.alignItems='center'; li.style.justifyContent='space-between';
        const box = document.createElement('span'); box.className='colour-preview-box'; box.style.backgroundColor=color;
        const info = document.createElement('span'); info.className='route-info';
        let statusText = isCustom ? "" : ` <small style="opacity:0.7;">(Initial Default)</small>`; if (!isCustom && !initialRouteColourMapForTools[rName]) statusText = ` <small style="opacity:0.7;">(System Default)</small>`;
        info.innerHTML = `Route: ${rName} - Colour: ${color.toUpperCase()}${statusText}`;
        const actions = document.createElement('div');
        if (isCustom) { const btn=document.createElement('button'); btn.textContent='Remove Global'; btn.classList.add('button','small-action','secondary'); btn.addEventListener('click',()=>handleRemoveGlobalRouteColour(rName)); actions.appendChild(btn); }
        li.appendChild(box); li.appendChild(info); li.appendChild(actions); currentRouteColoursList.appendChild(li);
    });
}
function populateRouteSelectorForColours() { if (!selectRouteNameColour) return; const currentVal = selectRouteNameColour.value; selectRouteNameColour.innerHTML = '<option value="">-- Select Route --</option>'; const lines = [...new Set(currentWorkingSchedule.map(e => e.lineName))].filter(Boolean).sort(compareLineNames); lines.forEach(ln => { const opt = document.createElement('option'); opt.value = ln; opt.textContent = ln; selectRouteNameColour.appendChild(opt); }); if (lines.includes(currentVal)) selectRouteNameColour.value = currentVal; selectRouteNameColour.dispatchEvent(new Event('change')); }
function handleSaveGlobalRouteColour() {
    if (!currentUser) return; if (!selectRouteNameColour || !inputRouteColour || !routeColourStatusMessage) return;
    const rName = selectRouteNameColour.value; const color = inputRouteColour.value;
    if (!rName) { routeColourStatusMessage.textContent = 'Select route.'; routeColourStatusMessage.style.color = '#e74c3c'; return; }
    if (!color.match(/^#[0-9a-fA-F]{6}$/)) { routeColourStatusMessage.textContent = 'Invalid hex (e.g., #RRGGBB).'; routeColourStatusMessage.style.color = '#e74c3c'; return; }
    globalCustomRouteColours[rName.toUpperCase()] = color.toUpperCase(); saveGlobalCustomRouteColours();
}
function handleRemoveGlobalRouteColour(key) {
    if (!currentUser) return; if (globalCustomRouteColours.hasOwnProperty(key) && confirm(`Remove GLOBAL custom colour for ${key}?`)) {
        delete globalCustomRouteColours[key]; saveGlobalCustomRouteColours();
        if (selectRouteNameColour.value.toUpperCase() === key) inputRouteColour.value = initialRouteColourMapForTools[key] || DEFAULT_ROUTE_COLOUR_TOOLS;
    }
}

// --- START: Stop-Specific Route Colour Functions ---
function populateStopSelectorForSpecificColours() {
    if (!selectStopForSpecificRouteColour) return; const currentVal = selectStopForSpecificRouteColour.value;
    selectStopForSpecificRouteColour.innerHTML = '<option value="">-- Select Stop --</option>';
    const uniqueStops = getUniqueStopsFromSchedule();
    if (uniqueStops.length === 0) { selectStopForSpecificRouteColour.innerHTML = '<option value="">-- No Stops --</option>'; displayRoutesForSpecificColouring(); return; }
    uniqueStops.forEach(stop => { const opt=document.createElement('option'); opt.value=stop.stopID; opt.textContent=`${stop.stopName} (${stop.stopID})`; selectStopForSpecificRouteColour.appendChild(opt); });
    if (uniqueStops.find(s => s.stopID === currentVal)) selectStopForSpecificRouteColour.value = currentVal;
    displayRoutesForSpecificColouring();
}
function displayRoutesForSpecificColouring() {
    if (!specificRouteColourTilesContainer || !specificRouteColourTilesPlaceholder) return;
    if (deleteRouteFromStopButton) deleteRouteFromStopButton.style.display = 'none'; if (deleteRouteFromStopStatusMessage) deleteRouteFromStopStatusMessage.textContent = '';
    const selectedStopID = selectStopForSpecificRouteColour.value; specificRouteColourTilesContainer.innerHTML = '';
    if (!selectedStopID) { specificRouteColourTilesPlaceholder.textContent = 'Select a stop to see its routes.'; specificRouteColourTilesPlaceholder.style.display = 'block'; return; }
    const servingRoutes = new Set(); currentWorkingSchedule.forEach(e => { if (e.stopID === selectedStopID && e.lineName) servingRoutes.add(e.lineName); });
    const sortedRoutes = Array.from(servingRoutes).sort(compareLineNames);
    if (sortedRoutes.length === 0) { specificRouteColourTilesPlaceholder.textContent = `No routes for stop ${selectedStopID}.`; specificRouteColourTilesPlaceholder.style.display = 'block'; }
    else { specificRouteColourTilesPlaceholder.style.display = 'none'; sortedRoutes.forEach(lineName => {
            const tile = document.createElement('span'); tile.classList.add('route-tile-tools-list', 'specific-colour-route-tile'); tile.textContent=lineName; tile.dataset.lineName=lineName;
            const bgColor = getRouteTileColourForTools(lineName, selectedStopID); tile.style.backgroundColor=bgColor; tile.style.color=getTextColourForBackgroundTools(bgColor);
            tile.setAttribute('role','checkbox'); tile.setAttribute('aria-checked','false'); tile.setAttribute('tabindex','0');
            tile.addEventListener('click', () => { const isSelected = tile.classList.toggle('selected-for-color-edit'); tile.setAttribute('aria-checked',isSelected.toString());
                const selTiles = specificRouteColourTilesContainer.querySelectorAll('.specific-colour-route-tile.selected-for-color-edit');
                if (deleteRouteFromStopButton) { if(selTiles.length===1){ deleteRouteFromStopButton.style.display='inline-block'; deleteRouteFromStopButton.dataset.selectedRouteName=selTiles[0].dataset.lineName; } else { deleteRouteFromStopButton.style.display='none'; delete deleteRouteFromStopButton.dataset.selectedRouteName; } }
                if (deleteRouteFromStopStatusMessage) deleteRouteFromStopStatusMessage.textContent = '';
            });
            tile.addEventListener('keydown', (event) => { if (event.key===' '||event.key==='Enter'){event.preventDefault(); tile.click();}});
            specificRouteColourTilesContainer.appendChild(tile);
        });
    }
}
function handleDeleteRouteFromSpecificStop() {
    if (!currentUser) { alert("Log in."); if(deleteRouteFromStopStatusMessage) deleteRouteFromStopStatusMessage.textContent="Not logged in."; return; }
    const selectedStopID = selectStopForSpecificRouteColour.value; const lineNameToDelete = deleteRouteFromStopButton.dataset.selectedRouteName;
    if (!selectedStopID || !lineNameToDelete) { if(deleteRouteFromStopStatusMessage){ deleteRouteFromStopStatusMessage.textContent="No stop/route selected (ensure one route tile selected)."; deleteRouteFromStopStatusMessage.style.color='#f1c40f'; } return; }
    if (!confirm(`Delete ALL schedule entries for route "${lineNameToDelete}" from stop "${selectedStopID}"?\nThis also removes specific colour override.\nCannot be undone.`)) {
        if(deleteRouteFromStopStatusMessage){ deleteRouteFromStopStatusMessage.textContent="Deletion cancelled."; deleteRouteFromStopStatusMessage.style.color='#7f8c8d'; } return;
    }
    let originalScheduleLength = currentWorkingSchedule.length;
    currentWorkingSchedule = currentWorkingSchedule.filter(e => !(e.stopID === selectedStopID && e.lineName && e.lineName.toUpperCase() === lineNameToDelete.toUpperCase()));
    let scheduleEntriesRemovedCount = originalScheduleLength - currentWorkingSchedule.length; let colourOverrideRemoved = false;
    if (stopSpecificRouteColours[selectedStopID] && stopSpecificRouteColours[selectedStopID][lineNameToDelete.toUpperCase()]) {
        delete stopSpecificRouteColours[selectedStopID][lineNameToDelete.toUpperCase()]; colourOverrideRemoved = true;
        if (Object.keys(stopSpecificRouteColours[selectedStopID]).length === 0) delete stopSpecificRouteColours[selectedStopID];
        saveStopSpecificRouteColoursToFirebase();
    }
    if (deleteRouteFromStopStatusMessage) { deleteRouteFromStopStatusMessage.textContent = `Route "${lineNameToDelete}" deleted from stop "${selectedStopID}". ${scheduleEntriesRemovedCount} entries removed. ${colourOverrideRemoved?'Specific colour removed.':''}`; deleteRouteFromStopStatusMessage.style.color = '#2ecc71'; }
    if(deleteRouteFromStopButton) { deleteRouteFromStopButton.style.display = 'none'; delete deleteRouteFromStopButton.dataset.selectedRouteName; }
    displayRoutesForSpecificColouring(); renderUIDependentElements(); updateStagingStatusDisplay();
}
function handleSaveStopSpecificRouteColour() {
    if (!currentUser) { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent="Not logged in.";stopSpecificRouteColourStatusMessage.style.color='#e74c3c';} return; }
    const selectedStopID = selectStopForSpecificRouteColour.value; if (!selectedStopID) { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent="Select stop.";stopSpecificRouteColourStatusMessage.style.color='#f1c40f';} return; }
    const selectedTiles = specificRouteColourTilesContainer.querySelectorAll('.specific-colour-route-tile.selected-for-color-edit');
    if (selectedTiles.length === 0) { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent="Select route tile(s).";stopSpecificRouteColourStatusMessage.style.color='#f1c40f';} return; }
    const newColour = inputStopSpecificRouteColour.value; if (!newColour.match(/^#[0-9a-fA-F]{6}$/)) { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent='Invalid hex (e.g., #RRGGBB).';stopSpecificRouteColourStatusMessage.style.color='#e74c3c';} return; }
    if (!stopSpecificRouteColours[selectedStopID]) stopSpecificRouteColours[selectedStopID] = {};
    let routesUpdated = []; selectedTiles.forEach(tile => { const lineName = tile.dataset.lineName; if(lineName){stopSpecificRouteColours[selectedStopID][lineName.toUpperCase()]=newColour.toUpperCase(); routesUpdated.push(lineName);} });
    if (routesUpdated.length > 0) { saveStopSpecificRouteColoursToFirebase(); selectedTiles.forEach(tile => tile.classList.remove('selected-for-color-edit'));
        const stillSelTiles = specificRouteColourTilesContainer.querySelectorAll('.specific-colour-route-tile.selected-for-color-edit');
        if(deleteRouteFromStopButton){ if(stillSelTiles.length===1){deleteRouteFromStopButton.style.display='inline-block'; deleteRouteFromStopButton.dataset.selectedRouteName=stillSelTiles[0].dataset.lineName;} else {deleteRouteFromStopButton.style.display='none'; delete deleteRouteFromStopButton.dataset.selectedRouteName;}}
    } else { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent="No routes updated.";stopSpecificRouteColourStatusMessage.style.color='#e74c3c';} }
}
function renderStopSpecificRouteColours() {
    if (!currentStopSpecificColoursList || !noStopSpecificColoursMessageEl) return; currentStopSpecificColoursList.innerHTML = '';
    const stopIDsWithOverrides = Object.keys(stopSpecificRouteColours).filter(stopID => stopSpecificRouteColours[stopID] && Object.keys(stopSpecificRouteColours[stopID]).length > 0)
        .sort((a,b)=>{ const stopA=getUniqueStopsFromSchedule().find(s=>s.stopID===a); const stopB=getUniqueStopsFromSchedule().find(s=>s.stopID===b); const nameA=stopA?stopA.stopName.toLowerCase():a.toLowerCase(); const nameB=stopB?stopB.stopName.toLowerCase():b.toLowerCase(); if(nameA<nameB)return -1; if(nameA>nameB)return 1; return 0; });
    if (stopIDsWithOverrides.length === 0) { noStopSpecificColoursMessageEl.textContent = 'No stop-specific colour overrides set.'; noStopSpecificColoursMessageEl.style.display = 'block'; return; }
    noStopSpecificColoursMessageEl.style.display = 'none';
    stopIDsWithOverrides.forEach(stopID => {
        const stopDetails = getUniqueStopsFromSchedule().find(s => s.stopID === stopID); const stopDisplayName = stopDetails ? `${stopDetails.stopName} (${stopID})` : stopID;
        const stopGroupTitle = document.createElement('h4'); stopGroupTitle.className='stop-group-title'; stopGroupTitle.textContent=`Stop: ${stopDisplayName}`; currentStopSpecificColoursList.appendChild(stopGroupTitle);
        const routesListUl = document.createElement('ul'); const routesForThisStop = stopSpecificRouteColours[stopID];
        Object.keys(routesForThisStop).sort(compareLineNames).forEach(lineName => {
            const color = routesForThisStop[lineName]; const li = document.createElement('li'); li.style.display='flex'; li.style.alignItems='center'; li.style.justifyContent='space-between';
            const box = document.createElement('span'); box.className='colour-preview-box'; box.style.backgroundColor=color;
            const info = document.createElement('span'); info.className='route-info'; info.textContent=`Route: ${lineName} - Colour: ${color.toUpperCase()}`;
            const actions = document.createElement('div'); const removeBtn = document.createElement('button'); removeBtn.textContent='Remove Override'; removeBtn.classList.add('button','small-action','secondary');
            removeBtn.addEventListener('click', () => handleRemoveStopSpecificRouteColour(stopID, lineName)); actions.appendChild(removeBtn);
            li.appendChild(box); li.appendChild(info); li.appendChild(actions); routesListUl.appendChild(li);
        }); currentStopSpecificColoursList.appendChild(routesListUl);
    });
}
function handleRemoveStopSpecificRouteColour(stopID, lineName) {
    if (!currentUser) return; if (stopSpecificRouteColours[stopID] && stopSpecificRouteColours[stopID][lineName]) {
        if (confirm(`Remove colour override for route ${lineName} at stop ${stopID}?`)) {
            delete stopSpecificRouteColours[stopID][lineName];
            if (Object.keys(stopSpecificRouteColours[stopID]).length === 0) delete stopSpecificRouteColours[stopID];
            saveStopSpecificRouteColoursToFirebase();
        }
    }
}
// --- END: Stop-Specific Route Colour Functions ---

// --- START: Global Route Deletion Functions ---
function populateGlobalRouteToDeleteSelector() {
    if (!selectGlobalRouteToDelete) return; const currentVal = selectGlobalRouteToDelete.value;
    selectGlobalRouteToDelete.innerHTML = '<option value="">-- Select Route --</option>';
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) { selectGlobalRouteToDelete.innerHTML = '<option value="">-- No Routes in Schedule --</option>'; return; }
    const uniqueRoutes = [...new Set(currentWorkingSchedule.map(e => e.lineName).filter(Boolean))].sort(compareLineNames);
    if (uniqueRoutes.length === 0) selectGlobalRouteToDelete.innerHTML = '<option value="">-- No Valid Routes Found --</option>';
    else { uniqueRoutes.forEach(ln => { const opt=document.createElement('option'); opt.value=ln; opt.textContent=ln; selectGlobalRouteToDelete.appendChild(opt); });
           if (uniqueRoutes.includes(currentVal)) selectGlobalRouteToDelete.value = currentVal; }
}
function handleDeleteEntireRouteGlobally() {
    if (!currentUser) { alert("Log in."); if(deleteEntireRouteStatusMessage) deleteEntireRouteStatusMessage.textContent="Not logged in."; return; }
    const lineNameToDelete = selectGlobalRouteToDelete.value;
    if (!lineNameToDelete) { if(deleteEntireRouteStatusMessage){ deleteEntireRouteStatusMessage.textContent="Select route."; deleteEntireRouteStatusMessage.style.color='#f1c40f';} return; }
    if (!confirm(`EXTREME CAUTION!\n\nDelete ALL schedule entries for route "${lineNameToDelete}" from ALL stops?\nThis also removes global custom colour and ALL stop-specific colours for this route.\n\nCANNOT BE UNDONE EASILY.\n\nProceed?`)) {
        if(deleteEntireRouteStatusMessage){ deleteEntireRouteStatusMessage.textContent="Global deletion cancelled."; deleteEntireRouteStatusMessage.style.color='#7f8c8d';} return;
    }
    let originalScheduleLength = currentWorkingSchedule.length;
    currentWorkingSchedule = currentWorkingSchedule.filter(e => !(e.lineName && e.lineName.toUpperCase() === lineNameToDelete.toUpperCase()));
    let scheduleEntriesRemovedCount = originalScheduleLength - currentWorkingSchedule.length; let globalColourRemoved = false;
    if (globalCustomRouteColours[lineNameToDelete.toUpperCase()]) { delete globalCustomRouteColours[lineNameToDelete.toUpperCase()]; globalColourRemoved=true; saveGlobalCustomRouteColours(); }
    let specificColoursRemovedCount = 0; let specificColoursNeedSave = false;
    Object.keys(stopSpecificRouteColours).forEach(stopID => { if (stopSpecificRouteColours[stopID] && stopSpecificRouteColours[stopID][lineNameToDelete.toUpperCase()]) { delete stopSpecificRouteColours[stopID][lineNameToDelete.toUpperCase()]; specificColoursRemovedCount++; if(Object.keys(stopSpecificRouteColours[stopID]).length===0) delete stopSpecificRouteColours[stopID]; specificColoursNeedSave=true; } });
    if (specificColoursNeedSave) saveStopSpecificRouteColoursToFirebase();
    if (deleteEntireRouteStatusMessage) { deleteEntireRouteStatusMessage.textContent = `Route "${lineNameToDelete}" deleted. ${scheduleEntriesRemovedCount} entries removed. ${globalColourRemoved?'Global colour removed. ':''}${specificColoursRemovedCount>0?specificColoursRemovedCount+' stop-specific colour(s) removed.':''}`; deleteEntireRouteStatusMessage.style.color = '#2ecc71'; }
    selectGlobalRouteToDelete.value = ""; renderUIDependentElements(); updateStagingStatusDisplay();
}
// --- END: Global Route Deletion Functions ---

function getRouteTileColourForTools(lineName, stopID = null) {
    const upName = String(lineName || "").toUpperCase();
    if (stopID && stopSpecificRouteColours[stopID.toUpperCase()] && stopSpecificRouteColours[stopID.toUpperCase()][upName]) return stopSpecificRouteColours[stopID.toUpperCase()][upName];
    if (globalCustomRouteColours[upName]) return globalCustomRouteColours[upName];
    if (initialRouteColourMapForTools[upName]) return initialRouteColourMapForTools[upName];
    if (upName.startsWith("N")) return globalCustomRouteColours["NIGHT_DEFAULT"] || initialRouteColourMapForTools["NIGHT_DEFAULT"] || NIGHT_BUS_BLUE_COLOR;
    if (upName.startsWith("SL")) return globalCustomRouteColours["SL_DEFAULT"] || initialRouteColourMapForTools["SL_DEFAULT"] || "#D32F2F";
    return DEFAULT_ROUTE_COLOUR_TOOLS;
}
function getTextColourForBackgroundTools(hex) { if(!hex||hex.length<7)return'#FFFFFF'; const r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16); return((0.299*r+0.587*g+0.114*b)/255)>0.5?'#000000':'#FFFFFF';}
function getDaySortOrder(profile) { if(!profile)return 99;const p=profile.toUpperCase().split(',').map(s=>s.trim());if(p.some(s=>s.startsWith("MO")&&!s.startsWith("MO-FR")))return 1;if(p.some(s=>s.startsWith("TU")))return 2;if(p.some(s=>s.startsWith("WE")))return 3;if(p.some(s=>s.startsWith("TH")))return 4;if(p.some(s=>s.startsWith("FR")&&!s.startsWith("MO-FR")))return 5;if(p.some(s=>s.startsWith("MF")||s.startsWith("MO-FR")))return 6;if(p.some(s=>s.startsWith("SA")))return 7;if(p.some(s=>s.startsWith("SU")))return 8;if(p.includes("GOODFRIDAY"))return 10;if(p.includes("BANKHOLIDAY"))return 11; return 99;}
function populateStopSelectorForDeparturesView() { if (!selectStopForDeparturesView) return; const currentVal = selectStopForDeparturesView.value; selectStopForDeparturesView.innerHTML = '<option value="">-- Select Stop --</option>'; if (currentWorkingSchedule.length === 0) { displayDeparturesForSelectedStop(); return; } const stopsMap = new Map(); currentWorkingSchedule.forEach(e => { if (e.stopID && !stopsMap.has(e.stopID.toUpperCase())) stopsMap.set(e.stopID.toUpperCase(), { stopID: e.stopID, stopName: e.stopName || e.stopID }); }); const sorted = Array.from(stopsMap.values()).sort((a,b)=>(a.stopName.toLowerCase()).localeCompare(b.stopName.toLowerCase())); sorted.forEach(s => { const opt = document.createElement('option'); opt.value = s.stopID; opt.textContent = `${s.stopName} (${s.stopID})`; selectStopForDeparturesView.appendChild(opt); }); if (stopsMap.has(currentVal.toUpperCase())) selectStopForDeparturesView.value = currentVal; displayDeparturesForSelectedStop(); }
function displayDeparturesForSelectedStop() {
    if (!selectStopForDeparturesView || !stopDeparturesList || !noDeparturesForStopMessage) return;
    const selStopID = selectStopForDeparturesView.value; stopDeparturesList.innerHTML = '';
    if (!selStopID) { noDeparturesForStopMessage.textContent = 'Select stop to view departures.'; noDeparturesForStopMessage.style.display = 'block'; return; }
    const deps = currentWorkingSchedule.filter(e => e.stopID === selStopID).sort((a,b) => {
        const offsetA=parseInt(a.DayOffset||"0",10); const offsetB=parseInt(b.DayOffset||"0",10); if(offsetA!==offsetB)return offsetA-offsetB;
        const dayA=getDaySortOrder(a.OperatingProfile); const dayB=getDaySortOrder(b.OperatingProfile); if(dayA!==dayB)return dayA-dayB;
        const timeA=(a.scheduledTime||"99:99").replace(':',''); const timeB=(b.scheduledTime||"99:99").replace(':',''); if(timeA!==timeB)return timeA.localeCompare(timeB);
        const lineComp=compareLineNames(a.lineName,b.lineName); if(lineComp!==0)return lineComp;
        return (a.OperatingProfile||"").localeCompare(b.OperatingProfile||"");
    });
    if (deps.length === 0) { noDeparturesForStopMessage.textContent = 'No scheduled departures for this stop.'; noDeparturesForStopMessage.style.display = 'block'; }
    else { noDeparturesForStopMessage.style.display = 'none'; deps.forEach(d => {
            const li=document.createElement('li'); const tile=document.createElement('span'); tile.className='route-tile-tools-list'; tile.textContent=d.lineName||'N/A';
            const bg=getRouteTileColourForTools(d.lineName,selStopID); tile.style.backgroundColor=bg; tile.style.color=getTextColourForBackgroundTools(bg);
            const span=document.createElement('span'); span.innerHTML=` to ${d.destinationName||'Unknown'} <strong style="margin-left:0.5em;">at ${d.scheduledTime||'N/A'}</strong> <small style="opacity:0.7;margin-left:0.75em;">(Profile: ${d.OperatingProfile||'N/A'})</small>${d.DayOffset&&d.DayOffset!=="0"?`<small style="opacity:0.7;margin-left:0.3em;color:#FFD700;">(+${d.DayOffset}d)</small>`:''}`;
            li.appendChild(tile); li.appendChild(span); stopDeparturesList.appendChild(li);
        });
    }
}

// --- Stop Management Tool Functions ---
function getUniqueStopsFromSchedule() {
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) return []; const stopsMap = new Map();
    currentWorkingSchedule.forEach(entry => { if (entry.stopID && !stopsMap.has(entry.stopID.toUpperCase())) { stopsMap.set(entry.stopID.toUpperCase(), { stopID: entry.stopID, stopName: entry.stopName || "Unknown Name", direction: entry.direction || "No Direction" }); } });
    return Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase()));
}

function populateMasterStopList_SM() {
    if (!masterStopListUL_SM || !masterStopListStatus_SM) return;
    uniqueStopsMasterList_SM = getUniqueStopsFromSchedule();
    const filterText = masterStopListFilterInput_SM.value.toLowerCase().trim();
    masterStopListUL_SM.innerHTML = ''; let displayedCount = 0;
    const NIGHT_BUS_BLUE_COLOR_CONST = (globalCustomRouteColours["NIGHT_DEFAULT"] || initialRouteColourMapForTools["NIGHT_DEFAULT"] || NIGHT_BUS_BLUE_COLOR || "#4CDBE6").toUpperCase();

    if (uniqueStopsMasterList_SM.length === 0) { masterStopListStatus_SM.textContent = 'No unique stops in current working schedule.'; return; }

    uniqueStopsMasterList_SM.forEach(stop => {
        if (!stop || !stop.stopID) return;
        const stopIdLower=stop.stopID.toLowerCase(); const stopNameLower=(stop.stopName||"").toLowerCase(); const stopDirectionLower=(stop.direction||"").toLowerCase();
        const servingRoutesData=new Map(); let earliestTimeOverall=null; let latestTimeOverall=null; let hasNightBusService=false; let hasDayBusService=false;
        currentWorkingSchedule.forEach(entry => { if (entry.stopID===stop.stopID) {
            if (entry.lineName) { if(!servingRoutesData.has(entry.lineName)) servingRoutesData.set(entry.lineName,{}); const tileColor = getRouteTileColourForTools(entry.lineName,stop.stopID).toUpperCase(); if(tileColor===NIGHT_BUS_BLUE_COLOR_CONST)hasNightBusService=true; if(tileColor!==NIGHT_BUS_BLUE_COLOR_CONST)hasDayBusService=true; }
            if (entry.scheduledTime) { const entryTimeNumeric=parseInt((entry.scheduledTime||"99:99").replace(":",""),10); const entryDayOffset=parseInt(entry.DayOffset||"0",10); const comparableTime=(entryDayOffset*2400)+entryTimeNumeric; if(earliestTimeOverall===null||comparableTime<earliestTimeOverall.comparable)earliestTimeOverall={time:entry.scheduledTime,dayOffset:entryDayOffset,comparable:comparableTime}; if(latestTimeOverall===null||comparableTime>latestTimeOverall.comparable)latestTimeOverall={time:entry.scheduledTime,dayOffset:entryDayOffset,comparable:comparableTime}; }
        }});
        const sortedServingRouteNames = Array.from(servingRoutesData.keys()).sort(compareLineNames);
        const isClosed = closedStopIDs.includes(stop.stopID.toUpperCase()); const closureStatus = isClosed ? "Closed" : "Open"; const is24HourStop = hasNightBusService && hasDayBusService;
        const matchesFilter = !filterText || stopIdLower.includes(filterText) || stopNameLower.includes(filterText) || stopDirectionLower.includes(filterText) || sortedServingRouteNames.some(rn=>rn.toLowerCase().includes(filterText)) || closureStatus.toLowerCase().includes(filterText) || (is24HourStop && "24 hours".includes(filterText)) || (is24HourStop && "24hr".includes(filterText));

        if (matchesFilter) {
            displayedCount++;
            const li = document.createElement('li'); li.dataset.stopid = stop.stopID;
            let content = `<span class="stop-name-master">${stop.stopName}</span><br><span class="stop-direction-master">Towards: ${stop.direction}</span><br><span class="stop-id-master">Stop ID: ${stop.stopID}</span><br>`;
            if (sortedServingRouteNames.length > 0) { content += `<div class="serving-routes-container">`; sortedServingRouteNames.forEach(lineName => { const bgColor=getRouteTileColourForTools(lineName,stop.stopID); const textColor=getTextColourForBackgroundTools(bgColor); content += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor};">${lineName}</span>`; }); content += `</div>`; }
            else content += `<div class="serving-routes-container"><span style="font-size:0.8em;opacity:0.7;">No routes scheduled.</span></div>`;
            content += `<div class="stop-details-grid">`; content += `<span class="detail-label">Status:</span> <span class="detail-value status-${closureStatus.toLowerCase()}">${closureStatus}</span>`;
            if (is24HourStop) { content += `<span class="detail-label">Service:</span> <span class="detail-value" style="color:${NIGHT_BUS_BLUE_COLOR_CONST};font-weight:bold;">24 Hours</span>`; content += `<span class="detail-label">First Bus:</span> <span class="detail-value">-</span>`; content += `<span class="detail-label">Last Bus:</span> <span class="detail-value">-</span>`; }
            else { let firstBusText = earliestTimeOverall?earliestTimeOverall.time+(earliestTimeOverall.dayOffset>0?` (+${earliestTimeOverall.dayOffset}d)`:''):"N/A"; let lastBusText = latestTimeOverall?latestTimeOverall.time+(latestTimeOverall.dayOffset>0?` (+${latestTimeOverall.dayOffset}d)`:''):"N/A"; content += `<span class="detail-label">First Bus (approx):</span> <span class="detail-value">${firstBusText}</span>`; content += `<span class="detail-label">Last Bus (approx):</span> <span class="detail-value">${lastBusText}</span>`; }
            content += `</div>`; li.innerHTML = content;

            const actionsDiv = document.createElement('div'); actionsDiv.className = 'stop-actions';
            const editBtn = document.createElement('button'); editBtn.className = 'button small-action'; editBtn.textContent = 'Edit';
            editBtn.addEventListener('click', () => handleEditStop_SM(stop.stopID, stop.stopName, stop.direction));
            actionsDiv.appendChild(editBtn);

            const deleteBtn = document.createElement('button'); deleteBtn.className = 'button small-action secondary'; deleteBtn.textContent = 'Delete';
            deleteBtn.addEventListener('click', () => handleDeleteStop_SM(stop.stopID));
            actionsDiv.appendChild(deleteBtn);

            const toggleBtn = document.createElement('button'); toggleBtn.className = `button small-action ${isClosed ? "tertiary" : "secondary"}`; toggleBtn.textContent = isClosed ? "Reopen Stop" : "Close Stop";
            toggleBtn.addEventListener('click', () => handleToggleStopStatus_SM(stop.stopID));
            actionsDiv.appendChild(toggleBtn);

            li.appendChild(actionsDiv); masterStopListUL_SM.appendChild(li);
        }
    });
    if (displayedCount === 0 && uniqueStopsMasterList_SM.length > 0 && filterText) masterStopListStatus_SM.textContent = 'No stops match filter.';
    else if (uniqueStopsMasterList_SM.length > 0) masterStopListStatus_SM.textContent = `Showing ${displayedCount} of ${uniqueStopsMasterList_SM.length} unique stops. Filter: "${filterText||'none'}"`;
    else masterStopListStatus_SM.textContent = 'No unique stops in current schedule.';
}

function handleEditStop_SM(stopID, currentName, currentDirection) {
    if (!currentUser) { alert("Please log in."); return; }
    const newStopName = prompt(`Editing Stop: ${stopID}\nEnter new Stop Name (current: ${currentName}):`, currentName);
    if (newStopName === null) { if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Edit cancelled for ${stopID}.`; return; }
    const newDirection = prompt(`Editing Stop: ${stopID}\nEnter new "Towards" text (current: ${currentDirection}):`, currentDirection);
    if (newDirection === null) { if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Edit cancelled for ${stopID}.`; return; }
    const nameChanged = newStopName.trim() !== currentName.trim(); const directionChanged = newDirection.trim() !== currentDirection.trim();
    if (!nameChanged && !directionChanged) { if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `No changes made to ${stopID}.`; return; }
    let updatedCount = 0;
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && entry.stopID.toUpperCase() === stopID.toUpperCase()) {
            let entryChangedInLoop = false;
            if (nameChanged && newStopName.trim()) { entry.stopName = newStopName.trim(); entryChangedInLoop = true; }
            if (directionChanged && newDirection.trim()) { entry.direction = newDirection.trim(); entryChangedInLoop = true; }
            if (nameChanged && !newStopName.trim() && entry.stopName !== "") { entry.stopName = ""; entryChangedInLoop = true; }
            if (directionChanged && !newDirection.trim() && entry.direction !== "") { entry.direction = ""; entryChangedInLoop = true; }
            if (entryChangedInLoop) updatedCount++;
        }
    });
    if (updatedCount > 0) { renderUIDependentElements(); updateStagingStatusDisplay(); if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `${updatedCount} entries for Stop ID "${stopID}" updated.`; setTimeout(() => populateMasterStopList_SM(), 100); }
    else { if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `No entries for Stop ID "${stopID}" to update, or no changes specified.`; }
}
function handleDeleteStop_SM(stopIdToRemove) {
    if (!currentUser) { alert("Please log in."); return; } if (!stopIdToRemove) { if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = "Stop ID not provided for deletion."; return; }
    const stopDetails = uniqueStopsMasterList_SM.find(s => s.stopID === stopIdToRemove); const stopNameToConfirm = stopDetails ? `${stopDetails.stopName} (${stopIdToRemove})` : stopIdToRemove;
    if (!confirm(`ARE YOU SURE to remove stop "${stopNameToConfirm}" and ALL its schedule entries? Cannot be undone.`)) { if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Deletion of ${stopNameToConfirm} cancelled.`; return; }
    const initialLength = currentWorkingSchedule.length; currentWorkingSchedule = currentWorkingSchedule.filter(entry => entry.stopID.toUpperCase() !== stopIdToRemove.toUpperCase());
    const removedCount = initialLength - currentWorkingSchedule.length;
    const closedIndex = closedStopIDs.indexOf(stopIdToRemove.toUpperCase()); if (closedIndex > -1) closedStopIDs.splice(closedIndex, 1);
    if (stopSpecificRouteColours[stopIdToRemove.toUpperCase()]) delete stopSpecificRouteColours[stopIdToRemove.toUpperCase()];
    if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Stop "${stopNameToConfirm}" and ${removedCount} schedule entries removed.`;
    saveClosedStopsToFirebase(); saveStopSpecificRouteColoursToFirebase(); renderUIDependentElements(); updateStagingStatusDisplay();
}
function handleToggleStopStatus_SM(stopID) {
    if (!currentUser) { alert("Please log in."); return; } if (!stopID) { if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = "Stop ID not provided for status change."; return; }
    const stopIdUpper = stopID.toUpperCase(); const stopDetails = uniqueStopsMasterList_SM.find(s => s.stopID === stopID); const stopName = stopDetails ? stopDetails.stopName : stopID;
    const idx = closedStopIDs.indexOf(stopIdUpper);
    if (idx === -1) { closedStopIDs.push(stopIdUpper); if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Stop '${stopName}' marked as closed.`; }
    else { closedStopIDs.splice(idx, 1); if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Stop '${stopName}' marked as reopened.`; }
    saveClosedStopsToFirebase();
}
function handleFindReplaceStopIdInSchedule_SM() {
    if (!currentUser) { alert("Please log in."); return; } const findStopID = findStopIdScheduleInput_SM.value.trim().toUpperCase(); const replaceStopID = replaceStopIdScheduleInput_SM.value.trim().toUpperCase();
    if (!findStopID || !replaceStopID) { findReplaceStatusMessage_SM.textContent = "'Stop ID to Find' and 'Replace with New Stop ID' required."; findReplaceStatusMessage_SM.style.color = '#e74c3c'; return; }
    if (findStopID === replaceStopID) { findReplaceStatusMessage_SM.textContent = "Find and Replace Stop IDs cannot be same."; findReplaceStatusMessage_SM.style.color = '#f1c40f'; return; }
    let newNameForReplaced = ""; let newDirectionForReplaced = ""; let foundNewStopDetails = false;
    const existingNewStopEntry = currentWorkingSchedule.find(e => e.stopID.toUpperCase() === replaceStopID);
    if (existingNewStopEntry) { newNameForReplaced = existingNewStopEntry.stopName; newDirectionForReplaced = existingNewStopEntry.direction; foundNewStopDetails = true; }
    else { const oldStopDetails = currentWorkingSchedule.find(e => e.stopID.toUpperCase() === findStopID); if (oldStopDetails) { newNameForReplaced = oldStopDetails.stopName; newDirectionForReplaced = oldStopDetails.direction; console.warn(`Details for new Stop ID "${replaceStopID}" not found. Using details from old "${findStopID}".`); } else console.warn(`Details for both new "${replaceStopID}" and old "${findStopID}" not found.`); }
    if (!confirm(`Replace ALL occurrences of Stop ID "${findStopID}" with "${replaceStopID}"? ${foundNewStopDetails?`Name/Dir updated to match existing for "${replaceStopID}".`:(newNameForReplaced?`Name/Dir based on "${findStopID}".`:`Name/Dir may need review.`)} Cannot be undone.`)) {
        findReplaceStatusMessage_SM.textContent = "Find/replace cancelled."; findReplaceStatusMessage_SM.style.color = '#7f8c8d'; return;
    }
    let replacedCount = 0; currentWorkingSchedule.forEach(entry => { if (entry.stopID && entry.stopID.toUpperCase() === findStopID) { entry.stopID = replaceStopID; if (newNameForReplaced || foundNewStopDetails) entry.stopName = newNameForReplaced; if (newDirectionForReplaced || foundNewStopDetails) entry.direction = newDirectionForReplaced; replacedCount++; } });
    if (replacedCount > 0) { renderUIDependentElements(); updateStagingStatusDisplay(); findReplaceStatusMessage_SM.textContent = `Replaced ${replacedCount} of "${findStopID}" with "${replaceStopID}".`; if (foundNewStopDetails || newNameForReplaced) findReplaceStatusMessage_SM.textContent += ` Name/Dir for "${replaceStopID}" updated to: "${newNameForReplaced||'(name not set)'}" / "${newDirectionForReplaced||'(dir not set)'}".`; findReplaceStatusMessage_SM.style.color = '#2ecc71'; findStopIdScheduleInput_SM.value=''; replaceStopIdScheduleInput_SM.value=''; }
    else { findReplaceStatusMessage_SM.textContent = `No occurrences of "${findStopID}" found.`; findReplaceStatusMessage_SM.style.color = '#f1c40f'; }
}

// --- START: Functions for "Add/Remove Stop Details" section ---
function handleSuggestStopId_ARS() {
    if (!currentUser || !selectNewStopIdFormat_ARS || !inputNewStopId_ARS) return; const selectedFormat = selectNewStopIdFormat_ARS.value;
    const suggestedId = generateUniqueStopId(selectedFormat); inputNewStopId_ARS.value = suggestedId;
    inputNewStopId_ARS.dispatchEvent(new Event('input', {bubbles:true, cancelable:true}));
    if (addNewStopStatus_ARS) {
        if (suggestedId && !suggestedId.includes(String(Date.now()).slice(-5))) { addNewStopStatus_ARS.textContent = `Suggested ID: ${suggestedId}.`; addNewStopStatus_ARS.style.color = '#bdc3c7'; }
        else if (suggestedId) { addNewStopStatus_ARS.textContent = `Suggested fallback ID: ${suggestedId}. Review.`; addNewStopStatus_ARS.style.color = '#f1c40f'; }
        else { addNewStopStatus_ARS.textContent = 'Could not suggest unique ID.'; addNewStopStatus_ARS.style.color = '#e74c3c'; }
    }
}
function handleAddStopDetails_ARS() {
    if (!currentUser) { alert("Log in."); return; } const newStopID = inputNewStopId_ARS.value.trim().toUpperCase(); const newStopName = inputNewStopName_ARS.value.trim(); const newStopDirection = inputNewStopDirection_ARS.value.trim();
    if (!newStopID) { addNewStopStatus_ARS.textContent = "New Stop ID required."; addNewStopStatus_ARS.style.color = '#e74c3c'; inputNewStopId_ARS.focus(); return; }
    if (!/^[A-Z0-9]+$/.test(newStopID)) { addNewStopStatus_ARS.textContent = "Stop ID: uppercase letters & numbers only."; addNewStopStatus_ARS.style.color = '#e74c3c'; inputNewStopId_ARS.focus(); return; }
    if (!newStopName) { addNewStopStatus_ARS.textContent = "New Stop Name required."; addNewStopStatus_ARS.style.color = '#e74c3c'; inputNewStopName_ARS.focus(); return; }
    if (!newStopDirection) { addNewStopStatus_ARS.textContent = "New Stop Direction required."; addNewStopStatus_ARS.style.color = '#e74c3c'; inputNewStopDirection_ARS.focus(); return; }
    const existingStopIDs = new Set(currentWorkingSchedule.map(e => e.stopID.toUpperCase()));
    if (existingStopIDs.has(newStopID)) { addNewStopStatus_ARS.textContent = `Stop ID "${newStopID}" already exists.`; if(newStopIdAvailability_ARS){ newStopIdAvailability_ARS.textContent = 'Stop ID already exists.'; newStopIdAvailability_ARS.style.color = '#e74c3c'; } inputNewStopId_ARS.focus(); return; }
    const placeholderEntry = { internalId: `${newStopID}_placeholder_${Date.now()}`, stopID: newStopID, stopName: newStopName, direction: newStopDirection, lineName: "INFO_ONLY", destinationName: "Stop Definition Placeholder", scheduledTime: "00:00", OperatingProfile: "AllDays", DayOffset: "0" };
    currentWorkingSchedule.push(placeholderEntry); addNewStopStatus_ARS.textContent = `Stop "${newStopID} - ${newStopName}" added with placeholder. Now available.`; addNewStopStatus_ARS.style.color = '#2ecc71';
    inputNewStopId_ARS.value = ''; inputNewStopName_ARS.value = ''; inputNewStopDirection_ARS.value = ''; if(newStopIdAvailability_ARS) newStopIdAvailability_ARS.textContent = ''; selectNewStopIdFormat_ARS.selectedIndex = 0;
    renderUIDependentElements(); updateStagingStatusDisplay();
}
function populateStopToRemoveSelector_ARS() {
    if (!selectStopToRemove_ARS) return; const currentVal = selectStopToRemove_ARS.value; selectStopToRemove_ARS.innerHTML = '<option value="">-- Select Stop to Remove --</option>';
    const uniqueStops = getUniqueStopsFromSchedule(); if (uniqueStops.length === 0) { selectStopToRemove_ARS.innerHTML = '<option value="">-- No Stops --</option>'; return; }
    uniqueStops.forEach(stop => { const opt=document.createElement('option'); opt.value=stop.stopID; opt.textContent=`${stop.stopName} (${stop.stopID})`; selectStopToRemove_ARS.appendChild(opt); });
    if (uniqueStops.find(s => s.stopID === currentVal)) selectStopToRemove_ARS.value = currentVal;
}
function handleRemoveStop_ARS() {
    if (!currentUser) { alert("Log in."); return; } const stopIdToRemove = selectStopToRemove_ARS.value;
    if (!stopIdToRemove) { removeStopStatus_ARS.textContent = "Select stop to remove."; removeStopStatus_ARS.style.color = '#f1c40f'; return; }
    const stopDetails = getUniqueStopsFromSchedule().find(s => s.stopID === stopIdToRemove); const stopNameToConfirm = stopDetails ? `${stopDetails.stopName} (${stopIdToRemove})` : stopIdToRemove;
    if (!confirm(`ARE YOU SURE to remove stop "${stopNameToConfirm}" and ALL its schedule entries? Cannot be undone.`)) { removeStopStatus_ARS.textContent = "Remove cancelled."; removeStopStatus_ARS.style.color = '#7f8c8d'; return; }
    const initialLength = currentWorkingSchedule.length; currentWorkingSchedule = currentWorkingSchedule.filter(e => e.stopID.toUpperCase() !== stopIdToRemove.toUpperCase());
    const removedCount = initialLength - currentWorkingSchedule.length; const stopIdUpper = stopIdToRemove.toUpperCase();
    const closedIndex = closedStopIDs.indexOf(stopIdUpper); if (closedIndex > -1) closedStopIDs.splice(closedIndex, 1);
    if (stopSpecificRouteColours[stopIdUpper]) delete stopSpecificRouteColours[stopIdUpper];
    removeStopStatus_ARS.textContent = `Stop "${stopNameToConfirm}" and ${removedCount} entries removed. Closed status & specific colours cleared.`; removeStopStatus_ARS.style.color = '#2ecc71';
    saveClosedStopsToFirebase(); saveStopSpecificRouteColoursToFirebase(); renderUIDependentElements(); updateStagingStatusDisplay(); selectStopToRemove_ARS.value = "";
}
// --- END: Functions for "Add/Remove Stop Details" section ---

// --- START: Route Stops Explorer Functions ---
function populate_rse_SelectRoute() {
    if (!rse_selectRoute) return; const currentVal = rse_selectRoute.value; rse_selectRoute.innerHTML = '<option value="">-- Select Route --</option>';
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) { rse_selectRoute.innerHTML = '<option value="">-- No Routes --</option>'; displayRouteStopsExplorer(); return; }
    const uniqueRoutes = [...new Set(currentWorkingSchedule.map(e => e.lineName))].filter(Boolean).sort(compareLineNames);
    uniqueRoutes.forEach(route => { const opt=document.createElement('option'); opt.value=route; opt.textContent=route; rse_selectRoute.appendChild(opt); });
    if (uniqueRoutes.includes(currentVal)) rse_selectRoute.value = currentVal;
}

function displayRouteStopsExplorer() {
    if (!rse_selectRoute || !rse_direction1_title || !rse_direction1_stopsList || !rse_direction1_placeholder || !rse_direction2_title || !rse_direction2_stopsList || !rse_direction2_placeholder || !rse_statusMessage) { console.error("Route Stops Explorer UI elements missing."); return; }
    const selectedRoute = rse_selectRoute.value;
    rse_direction1_title.textContent="Direction 1: (Select Route)"; rse_direction1_stopsList.innerHTML=""; rse_direction1_placeholder.style.display='block'; rse_direction1_placeholder.textContent="Select route.";
    rse_direction2_title.textContent="Direction 2: (Select Route)"; rse_direction2_stopsList.innerHTML=""; rse_direction2_placeholder.style.display='block'; rse_direction2_placeholder.textContent="Select route.";
    rse_statusMessage.textContent = ""; if (!selectedRoute) return;
    const routeEntries = currentWorkingSchedule.filter(e => e.lineName === selectedRoute);
    if (routeEntries.length === 0) { rse_statusMessage.textContent=`No data for route ${selectedRoute}.`; rse_direction1_placeholder.textContent=`No data for ${selectedRoute}.`; rse_direction2_placeholder.textContent=`No data for ${selectedRoute}.`; return; }
    const uniqueDestinations = [...new Set(routeEntries.map(e => e.destinationName).filter(Boolean))].sort();
    let direction1Name = uniqueDestinations.length > 0 ? uniqueDestinations[0] : null; let direction2Name = uniqueDestinations.length > 1 ? uniqueDestinations[1] : null;
    if (!direction1Name && !direction2Name) { rse_statusMessage.textContent=`Route ${selectedRoute} no defined destinations.`; rse_direction1_placeholder.textContent=`No destinations.`; rse_direction2_placeholder.textContent=`No destinations.`; return; }
    if(rse_direction1_container) rse_direction1_container.style.display = direction1Name ? 'block' : 'none'; if(rse_direction2_container) rse_direction2_container.style.display = direction2Name ? 'block' : 'none';
    function getStopsForDirection(destinationName) {
        if (!destinationName) return []; const directionEntries = routeEntries.filter(e => e.destinationName === destinationName); if (directionEntries.length === 0) return [];
        const stopTimes = new Map();
        directionEntries.forEach(entry => {
            const stopID=entry.stopID; const stopName=entry.stopName||stopID; const timeParts=(entry.scheduledTime||"00:00").split(':'); const hours=parseInt(timeParts[0],10); const minutes=parseInt(timeParts[1],10); const dayOffset=parseInt(entry.DayOffset||"0",10);
            const comparableTime=(dayOffset*1440)+(hours*60)+minutes;
            if(!stopTimes.has(stopID)||comparableTime<stopTimes.get(stopID).earliestTime) stopTimes.set(stopID,{stopName:stopName,stopID:stopID,earliestTime:comparableTime});
        }); return Array.from(stopTimes.values()).sort((a,b)=>a.earliestTime-b.earliestTime);
    }
    if (direction1Name) { rse_direction1_title.textContent=`Direction 1: Towards ${direction1Name}`; const stops1=getStopsForDirection(direction1Name);
        if(stops1.length>0){rse_direction1_placeholder.style.display='none'; stops1.forEach(s=>{const li=document.createElement('li');li.innerHTML=`<span class="stop-name">${s.stopName}</span> <span class="stop-id">(${s.stopID})</span>`;rse_direction1_stopsList.appendChild(li);});}
        else {rse_direction1_placeholder.textContent=`No stops for direction: ${direction1Name}.`; rse_direction1_placeholder.style.display='block';}
    } else if(rse_direction1_container) rse_direction1_container.style.display = 'none';
    if (direction2Name) { rse_direction2_title.textContent=`Direction 2: Towards ${direction2Name}`; const stops2=getStopsForDirection(direction2Name);
        if(stops2.length>0){rse_direction2_placeholder.style.display='none'; stops2.forEach(s=>{const li=document.createElement('li');li.innerHTML=`<span class="stop-name">${s.stopName}</span> <span class="stop-id">(${s.stopID})</span>`;rse_direction2_stopsList.appendChild(li);});}
        else {rse_direction2_placeholder.textContent=`No stops for direction: ${direction2Name}.`; rse_direction2_placeholder.style.display='block';}
    } else { if(rse_direction2_container) rse_direction2_container.style.display='none'; if(direction1Name && rse_statusMessage) rse_statusMessage.textContent=`Route ${selectedRoute} appears one-way/circular.`; }
    if (uniqueDestinations.length>2 && rse_statusMessage) rse_statusMessage.textContent=`Note: Route ${selectedRoute} has ${uniqueDestinations.length} destinations. Displaying for first two: "${direction1Name}" and "${direction2Name||'N/A'}".`;
    else if (uniqueDestinations.length===1 && rse_statusMessage && direction1Name) rse_statusMessage.textContent=`Route ${selectedRoute} one primary destination: "${direction1Name}".`;
}
// --- END: Route Stops Explorer Functions ---

// --- START: Auto Apply Scheduler ---
function initializeAutoApplyScheduler() { if(autoApplyIntervalId)clearInterval(autoApplyIntervalId); autoApplyIntervalId = setInterval(checkForAutoApply, 60*1000); console.log("Auto-apply scheduler initialized (checks every minute)."); }
function stopAutoApplyScheduler() { if(autoApplyIntervalId){clearInterval(autoApplyIntervalId); autoApplyIntervalId=null; console.log("Auto-apply scheduler stopped.");} }
async function checkForAutoApply() {
    if (!currentUser) return; const now=new Date(); const day=now.getDay(); const hour=now.getHours(); const currentISODate=now.toISOString().split('T')[0];
    const AUTO_APPLY_DAY = 3; const AUTO_APPLY_HOUR = 2; // Example: Wed 2 AM
    if (day===AUTO_APPLY_DAY && hour===AUTO_APPLY_HOUR) {
        const flagKey = `autoApplied_${AUTO_APPLY_DAY}_${AUTO_APPLY_HOUR}_${currentISODate}`;
        if (sessionStorage.getItem(flagKey)==='true') return; // console.log(`Auto-apply: Already run for ${currentISODate} at ${AUTO_APPLY_HOUR}:00.`);
        console.log(`Auto-apply: Day ${AUTO_APPLY_DAY}, Hour ${AUTO_APPLY_HOUR} (${currentISODate}). Checking staged...`);
        if (window.firebaseOMSI) { const {database,dbGet,dbRef,dbChild}=window.firebaseOMSI; try {
            const statusSnapshot=await dbGet(dbChild(dbRef(database),FB_PATH_APPSTATE_STATUS)); const pendingTimestampSnapshot=await dbGet(dbChild(dbRef(database),FB_PATH_PENDING_TIMESTAMP));
            const currentFbStatus = statusSnapshot.exists()?statusSnapshot.val():'unknown'; const pendingTimestamp = pendingTimestampSnapshot.exists()?pendingTimestampSnapshot.val():null;
            if(currentFbStatus==='update_staged' && pendingTimestamp){ console.log("Auto-apply: Staged update found. Applying..."); const originalConfirm=window.confirm; window.confirm=(message)=>{console.log(`Auto-apply: Bypassed confirm: "${message}"`); return true;}; handleApplyNow(); window.confirm=originalConfirm; sessionStorage.setItem(flagKey,'true'); console.log(`Auto-apply: Staged schedule applied for ${currentISODate} at ${AUTO_APPLY_HOUR}:00.`); }
            else { console.log(`Auto-apply: No staged update or missing timestamp. Status: ${currentFbStatus}. Timestamp: ${pendingTimestamp}`); sessionStorage.setItem(flagKey,'true'); }
        } catch(error){console.error("Auto-apply: Error checking FB or applying:",error);}
        } else console.log("Auto-apply: Firebase not available.");
    } else { const T24_HOURS_AGO=new Date(now.getTime()-(24*60*60*1000)); const yesterdayISODate=T24_HOURS_AGO.toISOString().split('T')[0]; const oldFlagKey=`autoApplied_${AUTO_APPLY_DAY}_${AUTO_APPLY_HOUR}_${yesterdayISODate}`; if(sessionStorage.getItem(oldFlagKey)){sessionStorage.removeItem(oldFlagKey); console.log(`Auto-apply: Cleared old flag ${oldFlagKey}`);} }
}
// --- END: Auto Apply Scheduler ---

// --- Event Listeners & Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    if (adminLoginSection) adminLoginSection.style.display = 'block';
    if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'none';
    if (topMenuBar) topMenuBar.style.display = 'none';
    hideAllToolSections();

    if (refreshOperatingProfilesButton) refreshOperatingProfilesButton.addEventListener('click', displayUniqueOperatingProfiles);

    const allMainMenuButtons = document.querySelectorAll('#main-menu-buttons .menu-button');
    allMainMenuButtons.forEach(button => {
        button.addEventListener('click', () => {
            const sectionId = button.getAttribute('data-section');
            if (currentUser && sectionId) showSection(sectionId);
            else if (!currentUser) alert("Please log in to access this section.");
        });
    });

    if(detectDuplicatesButton) detectDuplicatesButton.addEventListener('click', detectDuplicateEntries);
    if(removeDuplicateEntriesButton) removeDuplicateEntriesButton.addEventListener('click', handleRemoveDuplicateEntries);
    if(consolidateOperatingDaysButton) consolidateOperatingDaysButton.addEventListener('click', handleConsolidateOperatingDays);
    if(consolidateStopSelect) consolidateStopSelect.addEventListener('change', populateConsolidateRouteSelect);

    const inputNewStopId_ARS_El = document.getElementById('inputNewStopId_ARS');
    const newStopIdAvailability_ARS_El = document.getElementById('newStopIdAvailability_ARS');
    if (inputNewStopId_ARS_El && newStopIdAvailability_ARS_El) {
        inputNewStopId_ARS_El.addEventListener('input', () => {
            const newStopId = inputNewStopId_ARS_El.value.trim().toUpperCase();
            if (!newStopId) { newStopIdAvailability_ARS_El.textContent=''; newStopIdAvailability_ARS_El.style.color=''; return; }
            if (!/^[A-Z0-9]+$/.test(newStopId)) { newStopIdAvailability_ARS_El.textContent='ID alphanumeric.'; newStopIdAvailability_ARS_El.style.color='#e74c3c'; return; }
            const existingStopIDs = new Set(currentWorkingSchedule.map(e=>e.stopID.toUpperCase()));
            if (existingStopIDs.has(newStopId)) { newStopIdAvailability_ARS_El.textContent='Stop ID exists.'; newStopIdAvailability_ARS_El.style.color='#e74c3c'; }
            else { newStopIdAvailability_ARS_El.textContent='Stop ID available.'; newStopIdAvailability_ARS_El.style.color='#2ecc71'; }
        });
    }

    if (rto_selectRoute) rto_selectRoute.addEventListener('change', () => populate_rto_SelectProfile(rto_selectRoute.value));
    if (rto_selectProfile) rto_selectProfile.addEventListener('change', () => populate_rto_SelectDestination(rto_selectRoute.value, rto_selectProfile.value));
    if (rto_fileInput) rto_fileInput.addEventListener('change', handle_rto_FileUpload);
    if (rto_overwriteButton) rto_overwriteButton.addEventListener('click', handle_rto_OverwriteTimetable);

    if (rse_selectRoute) rse_selectRoute.addEventListener('change', displayRouteStopsExplorer);

    // Attach listeners for colour preset buttons
    const globalColorPresetButtons = document.querySelectorAll('.route-colour-management-subsection .button[onclick^="setGlobalRouteColour"]');
    globalColorPresetButtons.forEach(button => {
        const colorMatch = button.getAttribute('onclick').match(/setGlobalRouteColour\('#([0-9a-fA-F]{6})'\)/);
        if (colorMatch && colorMatch[1]) {
            const color = '#' + colorMatch[1];
            button.removeAttribute('onclick'); // Remove inline handler
            button.addEventListener('click', () => setGlobalRouteColour(color));
        }
    });

    const stopSpecificColorPresetButtons = document.querySelectorAll('.stop-specific-route-colour-subsection .button[onclick^="setStopSpecificRouteColour"]');
    stopSpecificColorPresetButtons.forEach(button => {
        const colorMatch = button.getAttribute('onclick').match(/setStopSpecificRouteColour\('#([0-9a-fA-F]{6})'\)/);
        if (colorMatch && colorMatch[1]) {
            const color = '#' + colorMatch[1];
            button.removeAttribute('onclick'); // Remove inline handler
            button.addEventListener('click', () => setStopSpecificRouteColour(color));
        }
    });


function initializeMainAppLogic() {
    console.log("Firebase ready, initializing main app logic for OMSI Tools.");
    const { auth, authOnAuthStateChanged, authSignInWithEmailAndPassword, authSignOut } = window.firebaseOMSI;
    authOnAuthStateChanged(auth, (user) => updateAuthUI(user));
    if (loginButton && inputEmail && inputPassword && authStatus) {
        const adminLoginForm = document.getElementById('adminLoginForm');
        if (adminLoginForm) adminLoginForm.addEventListener('submit', (event) => {
            event.preventDefault(); const email=inputEmail.value; const password=inputPassword.value;
            if(authStatus)authStatus.textContent='Logging in...';
            authSignInWithEmailAndPassword(auth, email, password).catch((error) => { console.error("Login Error:", error); if(authStatus) authStatus.textContent = `Login Error: ${error.message}`; });
        });
    }
    if (logoutButton) logoutButton.addEventListener('click', () => { localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY); authSignOut(auth).catch((e) => console.error("Sign-out Error:", e)); });
}

if (window.firebaseOMSI && window.firebaseOMSI.auth) { console.log("Firebase already ready on DOMContentLoaded for OMSI Tools."); initializeMainAppLogic(); }
else { console.log("Firebase not yet ready on DOMContentLoaded, waiting for 'firebaseReady'.");
    document.addEventListener('firebaseReady', () => {
        console.log("'firebaseReady' event received by OMSI Tools.");
        if (window.firebaseOMSI && window.firebaseOMSI.auth) initializeMainAppLogic();
        else { console.error("'firebaseReady' fired, but window.firebaseOMSI.auth still not available!"); updateAuthUI(null); if (authStatus) authStatus.textContent = 'Critical Firebase Auth init error.'; }
    }, { once: true });
}

    if (stageScheduleButton) stageScheduleButton.addEventListener('click', handleStageSchedule);
    if (applyNowButton) applyNowButton.addEventListener('click', handleApplyNow);
    if (viewArrivalsButton) viewArrivalsButton.addEventListener('click', () => { window.location.href = "omsi_arrivals.html"; });
    if (countFileInput) countFileInput.addEventListener('change', handleCountFileUpload);

    if(bulkEditTargetLineNameInput) bulkEditTargetLineNameInput.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); });
    if(bulkUpdateRouteDestinationButton) bulkUpdateRouteDestinationButton.addEventListener('click', handleBulkUpdateRouteDestination);

    if (saveRouteColourButton) saveRouteColourButton.addEventListener('click', handleSaveGlobalRouteColour);
    if (selectRouteNameColour) selectRouteNameColour.addEventListener('change', () => {
        const selectedRoute = selectRouteNameColour.value; const upperSelectedRoute = selectedRoute.toUpperCase();
        if (selectedRoute && globalCustomRouteColours[upperSelectedRoute]) inputRouteColour.value = globalCustomRouteColours[upperSelectedRoute];
        else if (initialRouteColourMapForTools[upperSelectedRoute]) inputRouteColour.value = initialRouteColourMapForTools[upperSelectedRoute];
        else inputRouteColour.value = DEFAULT_ROUTE_COLOUR_TOOLS;
    });

    if (selectStopForSpecificRouteColour) selectStopForSpecificRouteColour.addEventListener('change', displayRoutesForSpecificColouring);
    if (saveStopSpecificRouteColourButton) saveStopSpecificRouteColourButton.addEventListener('click', handleSaveStopSpecificRouteColour);
    if (deleteRouteFromStopButton) deleteRouteFromStopButton.addEventListener('click', handleDeleteRouteFromSpecificStop);

    if (selectStopForDeparturesView) selectStopForDeparturesView.addEventListener('change', displayDeparturesForSelectedStop);

    if (refreshMasterStopListButton_SM) refreshMasterStopListButton_SM.addEventListener('click', populateMasterStopList_SM);
    if (masterStopListFilterInput_SM) masterStopListFilterInput_SM.addEventListener('input', populateMasterStopList_SM);
    if (findStopIdScheduleInput_SM) findStopIdScheduleInput_SM.addEventListener('input', (e) => e.target.value = e.target.value.toUpperCase());
    if (replaceStopIdScheduleInput_SM) replaceStopIdScheduleInput_SM.addEventListener('input', (e) => e.target.value = e.target.value.toUpperCase());
    if (findReplaceStopIdScheduleButton_SM) findReplaceStopIdScheduleButton_SM.addEventListener('click', handleFindReplaceStopIdInSchedule_SM);

    if (buttonSuggestStopId_ARS) buttonSuggestStopId_ARS.addEventListener('click', handleSuggestStopId_ARS);
    if (buttonAddNewStop_ARS) buttonAddNewStop_ARS.addEventListener('click', handleAddStopDetails_ARS);
    if(selectNewStopIdFormat_ARS) selectNewStopIdFormat_ARS.addEventListener('change', handleSuggestStopId_ARS);
    if(buttonRemoveStop_ARS) buttonRemoveStop_ARS.addEventListener('click', handleRemoveStop_ARS);

    if (deleteEntireRouteButton) deleteEntireRouteButton.addEventListener('click', handleDeleteEntireRouteGlobally);

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/live-tracker/sw-omsi.js') // Ensure this path is correct from your web root
            .then(registration => console.log('Service Worker (sw-omsi.js) registered:', registration.scope))
            .catch(error => console.error('Service Worker (sw-omsi.js) registration failed:', error));
        });
    }
});
</script>
</body>
</html>
