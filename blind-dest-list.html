<!DOCTYPE html>
<html lang="en">
<head>
    <title>Blind Destination List</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="manifest" href="./manifest-blind.json">
    
    <meta name="theme-color" content="#007bff">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.1/jspdf.plugin.autotable.min.js"></script>
    <style>
        /* --- Basic Page Setup --- */
        body, html { margin: 0; padding: 0; box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }
        body { font-family: Arial, sans-serif; padding: 20px; background-color: #f4f4f4; color: #333; }
        .page-container { background-color: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin: 20px auto; width: 95%; max-width: 900px; }
        h1 { text-align: center; color: #333; margin-top: 0; margin-bottom: 10px;}
        h2 { text-align: center; color: #555; margin-top: 20px; margin-bottom: 10px; font-size: 1.2em; }
        h3.inserts-title { text-align: center; color: #444; margin-top:15px; margin-bottom:5px; font-size: 1.1em; }

        /* --- Controls Area --- */
        .top-controls-container {
            padding: 15px; background-color: #f0f0f0; border-radius: 6px; margin-bottom: 25px; border: 1px solid #e0e0e0;
            display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 15px;
        }
        .list-name-section { display: flex; align-items: center; gap: 10px; flex-grow: 1; flex-basis: 250px; }
        .list-name-section label { font-weight: bold; font-size: 0.95em; white-space: nowrap; }
        .list-name-section input[type="text"] { padding: 8px; border: 1px solid #ccc; border-radius: 4px; flex-grow: 1; min-width: 180px; font-size: 0.95em; }

        .blind-mode-section { display: flex; align-items: center; gap: 8px; padding: 10px 0; flex-basis: auto; justify-content: center;}
        .blind-mode-section label { margin-right: 3px; font-size: 0.9em;}
        .blind-mode-section input[type="radio"] { margin-right: 2px; vertical-align: middle; }
        
        .mode-specific-controls { 
            width: 100%; 
            margin-top: 10px; 
            padding: 10px; 
            border-radius: 4px;
        }
        .three-track-controls-section { 
            display: none; /* JS will control visibility */
            flex-direction: column; 
            align-items: flex-start; 
            gap: 8px;
            background-color: #e9f5ff; 
            border: 1px solid #cce0ff;
        }
        .three-track-controls-section div { display: flex; align-items: center; gap: 5px;}
        
        .manual-blind-specific-controls { /* MODIFIED for new color and structure */
            display: none; /* JS will control visibility */
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            background-color: #e9f5ff; /* Matching three-track style */
            border: 1px solid #cce0ff; /* Matching three-track style */
            font-size: 0.9em;
        }
        .manual-blind-specific-controls div { display: flex; align-items: center; gap: 5px; margin-bottom: 5px;}
        .manual-blind-specific-controls div:last-child { margin-bottom: 0; }


        .table-visibility-controls { 
            display: none; /* JS will control visibility */
            flex-wrap: wrap; 
            gap: 10px; 
            align-items: center;
            background-color: #e6ffed; 
            border: 1px solid #c3e6cb; 
            font-size: 0.9em;
        }
        .table-visibility-controls strong { font-size: 0.95em; margin-right: 5px; }
        .table-visibility-controls label { margin-right: 3px; white-space: nowrap; }
        .table-visibility-controls input[type="checkbox"] { margin-right: 2px; vertical-align: middle; }
        .table-visibility-controls span { /* NEW for D and E toggles */
            display: inline-flex; 
            align-items: center;
            gap: 2px; 
            margin-right: 8px; 
        }


        .actions-group { display: flex; gap: 10px; flex-shrink: 0; } 
        .actions-group button { width: auto; padding: 8px 12px; }
        .help-button { background-color: #17a2b8; } .help-button:hover { background-color: #138496; }
        .text-export-button { background-color: #28a745; } .text-export-button:hover { background-color: #218838; }
        .pdf-export-button { background-color: #28a745; } .pdf-export-button:hover { background-color: #218838; } /* MODIFIED color */
        
        .import-section { display: flex; align-items: center; gap: 10px; flex-grow: 1; flex-basis: 100%; margin-top:10px; }
        .import-section label { font-weight: bold; font-size: 0.95em; white-space: nowrap; margin-right: 5px; }
        .import-section input[type="file"] { 
            padding: 6px; 
            border: 1px solid #ccc; 
            border-radius: 4px; 
            flex-grow: 1;
            font-size: 0.9em;
            min-width: 150px; 
            max-width: 100%;
        }

        /* --- Tables --- */
        .tables-wrapper { }
        .table-container { margin-bottom: 30px; border: 1px solid #ccc; border-radius: 6px; padding: 15px; background-color: #fdfdfd; }
        .table-container:last-child { margin-bottom: 0; }
        .inserts-options-section { margin-top: 10px; padding: 8px; background-color: #eef; border-radius: 4px;}
        .inserts-options-section label { font-size: 0.9em; margin-right: 5px;}
        .inserts-table-sub-container { margin-top: 15px; padding:10px; border: 1px dashed #bbb; border-radius: 4px; background-color: #fafcff; }
        
        table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 0.9em; table-layout: fixed; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; vertical-align: middle; word-wrap: break-word; }
        th { background-color: #e9ecef; font-weight: bold; text-align: center; }
        
        tbody tr:not(.fixed-row):not(.insert-row):nth-child(even) { background-color: #f0f0f0; }
        tbody tr:not(.fixed-row):not(.insert-row):nth-child(odd) { background-color: #ffffff; }
        
        tbody tr.insert-row { background-color: #e6f2ff; } 
        tbody tr.insert-row:nth-child(odd) { background-color: #f0f8ff; } 
        
        tbody input[type="text"] {
            width: 95%;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-sizing: border-box;
            font-family: inherit;
            font-size: inherit;
        }
        tbody textarea { /* NEW for multi-line input */
            width: 95%; 
            padding: 4px; 
            border: 1px solid #ccc; 
            border-radius: 3px; 
            box-sizing: border-box; 
            font-family: inherit; 
            font-size: inherit; 
            line-height: 1.4; 
            vertical-align: middle; 
            resize: vertical; 
            min-height: 30px; 
            display: block; 
            margin: 0 auto; 
        }
        
        col.col-drag-common { width: 10%; }
        col.col-num-common { width: 15%; }
        col.col-data-wide    { width: 55%; } 
        col.col-action-narrow { width: 20%; } 

        .drag-handle { cursor: grab; font-size: 1.2em; user-select: none; } 
        .drag-handle:active { cursor: grabbing; }
        td.col-drag-cell { text-align: center; vertical-align: middle; } 
        th.col-drag-header { text-align: center; }
        .sortable-ghost { opacity: 0.4; background: #c8ebfb !important; }
        
        .fixed-row td { background-color: #d8d8d8; color: #333; font-weight: bold; }
        .fixed-row .fixed-text-cell { text-align: center !important; } 
        .fixed-row-num-cell, .fixed-row-action-cell, .fixed-row-drag-cell { text-align: center; }
        
        button { padding: 8px 15px; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; margin: 2px; background-color: #007bff; transition: background-color 0.2s ease; flex-shrink: 0; }
        button:hover { background-color: #0056b3; }
        
        .small-danger-button { padding: 3px 8px; font-size: 0.85em; background-color: #dc3545; width: auto; }
        .small-danger-button:hover { background-color: #c82333; }
        .clear-table-button { margin-left: auto; }
        
        .small-add-insert-button { padding: 3px 8px; font-size: 0.85em; background-color: #17a2b8; width: auto; } 
        .small-add-insert-button:hover { background-color: #138496; }
        
        .add-top-insert-button { background-color: #6f42c1; } 
        .add-top-insert-button:hover { background-color: #5a2f9e; }
        
        .copy-track-button { background-color: #fd7e14; } 
        .copy-track-button:hover { background-color: #e66b00; }

        td.col-action-cell { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 3px;}
        .controls { margin-top: 15px; display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 10px; }
        .controls > button:not(.clear-table-button) { flex-grow: 1; min-width: 120px; width: auto; }
        .controls .copy-track-button { flex-grow: 0; min-width: fit-content; }
        .controls .add-top-insert-button { flex-grow: 0; min-width: fit-content; } 
        
        .multiple-add-control { display: flex; align-items: center; gap: 8px; flex-grow: 1; justify-content: flex-end;}
        .multiple-rows-input { width: 75px; padding: 7px; font-size: 0.9em; border: 1px solid #ccc; border-radius: 4px; text-align: center;}
        .add-multiple-button { padding: 7px 10px; width: auto;}
        th.col-action-header { text-align: center; vertical-align: middle; }

        /* --- Modal Styles (for Help Dialog) --- */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 10% auto; padding: 25px; border: 1px solid #888; width: 80%; max-width: 700px; border-radius: 8px; position: relative; box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19); animation-name: animatetop; animation-duration: 0.4s }
        @keyframes animatetop { from {top: -300px; opacity: 0} to {top: 0; opacity: 1} }
        .modal-close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; line-height: 1; }
        .modal-close-button:hover, .modal-close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        #helpModalBody h4 { margin-top: 15px; margin-bottom: 5px; color: #333; }
        #helpModalBody p, #helpModalBody ul { font-size: 0.95em; line-height: 1.6; color: #555; }
        #helpModalBody ul { margin-left: 20px; padding-left: 10px; }
        #helpModalBody li { margin-bottom: 8px; }

        /* --- Orientation Prompt Styles --- */
        .orientation-prompt-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); color: white; z-index: 2000; justify-content: center; align-items: center; text-align: center; padding: 20px; box-sizing: border-box; }
        .orientation-prompt-message { font-size: 1.2em; line-height: 1.6; }
        .orientation-prompt-icon { font-size: 3em; margin-bottom: 15px; transform: rotate(90deg); }
        @media screen and (max-width: 768px) and (orientation: portrait) { .orientation-prompt-overlay { display: flex; flex-direction: column; } }
    </style>
</head>
<body>
    <div class="page-container">
        <h1>Blind Destination List</h1>

        <div class="top-controls-container">
            <div class="list-name-section">
                <label for="listNameInput">List Name:</label>
                <input type="text" id="listNameInput" placeholder="Enter list name for export">
            </div>
            <div class="blind-mode-section">
                <input type="radio" id="smartBlindMode" name="blindMode" value="smart" checked>
                <label for="smartBlindMode">Smartblind</label>
                <input type="radio" id="manualBlindMode" name="blindMode" value="manual">
                <label for="manualBlindMode">Manual Blind</label>
                <input type="radio" id="threeTrackMode" name="blindMode" value="threeTrack">
                <label for="threeTrackMode">3 Track</label>
            </div>
            <div class="actions-group"> 
                <button id="helpButton" class="help-button">Help</button>
                <button onclick="exportToBLIND()" class="text-export-button">Export to .blind</button>
                <button onclick="exportCurrentDataToPDF()" class="pdf-export-button">Export to PDF</button>
            </div>

            <div class="mode-specific-controls three-track-controls-section" id="threeTrackGlobalControls" style="display: none;">
                <div>
                    <input type="checkbox" id="threeTrackIdentical" checked>
                    <label for="threeTrackIdentical">Are all 3 tracks identical?</label>
                </div>
            </div>

            <div class="mode-specific-controls manual-blind-specific-controls" id="manualBlindSpecificControlsContainer" style="display: none;">
                <div>
                    <input type="checkbox" id="isSideBlindSplitCheckbox">
                    <label for="isSideBlindSplitCheckbox">Is Side Blind Split?</label>
                </div>
                <div>
                    <input type="checkbox" id="isFrontRearSeparateCheckbox">
                    <label for="isFrontRearSeparateCheckbox">Is Front & Rear Number Separate? (e.g, Trident)</label>
                </div>
            </div>

            <div class="mode-specific-controls table-visibility-controls" id="tableVisibilityControls" style="display: none;">
                <strong>Show Tables:</strong>
                <input type="checkbox" id="showTableA" data-table-id="A" checked> <label for="showTableA" id="showTableALabel">Front / Rear Number</label>
                <input type="checkbox" id="showTableB" data-table-id="B" checked> <label for="showTableB" id="showTableBLabel">Front Destination</label>
                <input type="checkbox" id="showTableC" data-table-id="C" checked> <label for="showTableC" id="showTableCLabel">Side Ultimate / Via</label>
                <span id="showTableDSpan" style="display:none;">
                    <input type="checkbox" id="showTableD" data-table-id="D" checked> <label for="showTableD" id="showTableDLabel">Side Intermediate</label>
                </span>
                <span id="showTableESpan" style="display:none;">
                    <input type="checkbox" id="showTableE" data-table-id="E" checked> <label for="showTableE" id="showTableELabel">Rear Number</label>
                </span>
            </div>

            <div class="import-section">
                <label for="blindFileInput">Import .blind File:</label>
                <input type="file" id="blindFileInput" accept=".blind"> 
            </div>
        </div>

        <div class="tables-wrapper">
            <div class="table-container" id="table-container-A">
                <h2 id="table-title-A">Front / Rear Number</h2>
                <div class="inserts-options-section">
                    <input type="checkbox" id="hasInsertsA" data-table-id="A">
                    <label for="hasInsertsA">Enable Inserts</label> 
                </div>
                <table id="table-A">
                    <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                    <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-data-A">Route</th><th class="col-action-header">Action</th></tr></thead>
                    <tbody id="table-body-A"></tbody>
                </table>
                <div class="controls">
                    <button onclick="addTopInsert('A')" id="addTopInsertA" class="add-top-insert-button" style="display:none;">Add Top Insert</button>
                    <button onclick="addDataRow('A')" id="addDataRowBtnA">Add Number</button>
                    <div class="multiple-add-control">
                        <input type="number" id="qty-A" class="multiple-rows-input" min="1" placeholder="Qty">
                        <button onclick="handleAddMultiple('A')" class="add-multiple-button">Add Qty</button>
                    </div>
                    <button onclick="clearTableData('A')" class="small-danger-button clear-table-button">Clear Table</button>
                </div>
                <div id="inserts-table-sub-container-A" style="display: none;">
                    <h3 class="inserts-title" id="inserts-title-A">Inserts for Front / Rear Number</h3>
                    <table id="table-inserts-A">
                        <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                        <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-inserts-data-A">Route (Insert)</th><th class="col-action-header">Action</th></tr></thead>
                        <tbody id="table-body-inserts-A"></tbody>
                    </table>
                    <div class="controls">
                        <button onclick="addInsertDataRow('A')" id="addSmartInsertBtnA">Add Smart Insert</button>
                         <div class="multiple-add-control">
                            <input type="number" id="qty-inserts-A" class="multiple-rows-input" min="1" placeholder="Qty">
                            <button onclick="handleAddMultipleInserts('A')" class="add-multiple-button">Add Qty Smart Inserts</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="table-container" id="table-container-B">
                <h2 id="table-title-B">Front Destination</h2>
                <div class="inserts-options-section">
                    <input type="checkbox" id="hasInsertsB" data-table-id="B">
                    <label for="hasInsertsB">Enable Inserts</label>
                </div>
                <table id="table-B">
                    <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                    <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-data-B">Destination</th><th class="col-action-header">Action</th></tr></thead>
                    <tbody id="table-body-B"></tbody>
                </table>
                <div class="controls">
                     <button id="copyToBBtn" class="copy-track-button" style="display:none;">Copy Track 1 to this Track</button>
                    <button onclick="addTopInsert('B')" id="addTopInsertB" class="add-top-insert-button" style="display:none;">Add Top Insert</button>
                    <button onclick="addDataRow('B')" id="addDataRowBtnB">Add Destination</button>
                    <div class="multiple-add-control">
                        <input type="number" id="qty-B" class="multiple-rows-input" min="1" placeholder="Qty">
                        <button onclick="handleAddMultiple('B')" class="add-multiple-button">Add Qty</button>
                    </div>
                    <button onclick="clearTableData('B')" class="small-danger-button clear-table-button">Clear Table</button>
                </div>
                <div id="inserts-table-sub-container-B" style="display: none;">
                    <h3 class="inserts-title" id="inserts-title-B">Inserts for Front Destination</h3>
                    <table id="table-inserts-B">
                        <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                        <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-inserts-data-B">Destination (Insert)</th><th class="col-action-header">Action</th></tr></thead>
                        <tbody id="table-body-inserts-B"></tbody>
                    </table>
                     <div class="controls">
                        <button onclick="addInsertDataRow('B')" id="addSmartInsertBtnB">Add Smart Insert</button>
                         <div class="multiple-add-control">
                            <input type="number" id="qty-inserts-B" class="multiple-rows-input" min="1" placeholder="Qty">
                            <button onclick="handleAddMultipleInserts('B')" class="add-multiple-button">Add Qty Smart Inserts</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="table-container" id="table-container-C">
                <h2 id="table-title-C">Side Ultimate / Via</h2> 
                <div class="inserts-options-section">
                    <input type="checkbox" id="hasInsertsC" data-table-id="C">
                    <label for="hasInsertsC">Enable Inserts</label>
                </div>
                <table id="table-C">
                    <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                    <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-data-C">Side Blind</th><th class="col-action-header">Action</th></tr></thead>
                    <tbody id="table-body-C"></tbody>
                </table>
                <div class="controls">
                    <button id="copyToCBtn" class="copy-track-button" style="display:none;">Copy Track 1 to this Track</button>
                    <button onclick="addTopInsert('C')" id="addTopInsertC" class="add-top-insert-button" style="display:none;">Add Top Insert</button>
                    <button onclick="addDataRow('C')" id="addDataRowBtnC">Add Via</button> 
                    <div class="multiple-add-control">
                        <input type="number" id="qty-C" class="multiple-rows-input" min="1" placeholder="Qty">
                        <button onclick="handleAddMultiple('C')" class="add-multiple-button">Add Qty</button>
                    </div>
                    <button onclick="clearTableData('C')" class="small-danger-button clear-table-button">Clear Table</button>
                </div>
                <div id="inserts-table-sub-container-C" style="display: none;">
                    <h3 class="inserts-title" id="inserts-title-C">Inserts for Side Ultimate / Via</h3>
                    <table id="table-inserts-C">
                        <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                        <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-inserts-data-C">Side Blind (Insert)</th><th class="col-action-header">Action</th></tr></thead>
                        <tbody id="table-body-inserts-C"></tbody>
                    </table>
                     <div class="controls">
                        <button onclick="addInsertDataRow('C')" id="addSmartInsertBtnC">Add Smart Insert</button>
                        <div class="multiple-add-control">
                            <input type="number" id="qty-inserts-C" class="multiple-rows-input" min="1" placeholder="Qty">
                            <button onclick="handleAddMultipleInserts('C')" class="add-multiple-button">Add Qty Smart Inserts</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="table-container" id="table-container-D" style="display: none;"> 
                <h2 id="table-title-D">Side Intermediate</h2>
                <div class="inserts-options-section">
                    <input type="checkbox" id="hasInsertsD" data-table-id="D">
                    <label for="hasInsertsD">Enable Inserts</label>
                </div>
                <table id="table-D">
                    <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                    <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-data-D">Intermediate Blind</th><th class="col-action-header">Action</th></tr></thead>
                    <tbody id="table-body-D"></tbody>
                </table>
                <div class="controls">
                    <button onclick="addTopInsert('D')" id="addTopInsertD" class="add-top-insert-button" style="display:none;">Add Top Insert</button>
                    <button onclick="addDataRow('D')" id="addDataRowBtnD">Add Intermediate</button>
                    <div class="multiple-add-control">
                        <input type="number" id="qty-D" class="multiple-rows-input" min="1" placeholder="Qty">
                        <button onclick="handleAddMultiple('D')" class="add-multiple-button">Add Qty</button>
                    </div>
                    <button onclick="clearTableData('D')" class="small-danger-button clear-table-button">Clear Table</button>
                </div>
                <div id="inserts-table-sub-container-D" style="display: none;">
                    <h3 class="inserts-title" id="inserts-title-D">Inserts for Side Intermediate</h3>
                    <table id="table-inserts-D">
                        <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                        <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-inserts-data-D">Intermediate (Insert)</th><th class="col-action-header">Action</th></tr></thead>
                        <tbody id="table-body-inserts-D"></tbody>
                    </table>
                     <div class="controls">
                        <button onclick="addInsertDataRow('D')" id="addSmartInsertBtnD">Add Smart Insert</button>
                        <div class="multiple-add-control">
                            <input type="number" id="qty-inserts-D" class="multiple-rows-input" min="1" placeholder="Qty">
                            <button onclick="handleAddMultipleInserts('D')" class="add-multiple-button">Add Qty Smart Inserts</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="table-container" id="table-container-E" style="display: none;">
                <h2 id="table-title-E">Rear Number</h2>
                <div class="inserts-options-section">
                    <input type="checkbox" id="hasInsertsE" data-table-id="E">
                    <label for="hasInsertsE">Enable Inserts</label>
                </div>
                <table id="table-E">
                    <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                    <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-data-E">Rear Number</th><th class="col-action-header">Action</th></tr></thead>
                    <tbody id="table-body-E"></tbody>
                </table>
                <div class="controls">
                    <button onclick="addTopInsert('E')" id="addTopInsertE" class="add-top-insert-button" style="display:none;">Add Top Insert</button>
                    <button onclick="addDataRow('E')" id="addDataRowBtnE">Add Rear No.</button>
                    <div class="multiple-add-control">
                        <input type="number" id="qty-E" class="multiple-rows-input" min="1" placeholder="Qty">
                        <button onclick="handleAddMultiple('E')" class="add-multiple-button">Add Qty</button>
                    </div>
                    <button onclick="clearTableData('E')" class="small-danger-button clear-table-button">Clear Table</button>
                </div>
                <div id="inserts-table-sub-container-E" style="display: none;">
                    <h3 class="inserts-title" id="inserts-title-E">Inserts for Rear Number</h3>
                    <table id="table-inserts-E">
                        <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                        <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-inserts-data-E">Rear Number (Insert)</th><th class="col-action-header">Action</th></tr></thead>
                        <tbody id="table-body-inserts-E"></tbody>
                    </table>
                     <div class="controls">
                        <button onclick="addInsertDataRow('E')" id="addSmartInsertBtnE">Add Smart Insert</button>
                        <div class="multiple-add-control">
                            <input type="number" id="qty-inserts-E" class="multiple-rows-input" min="1" placeholder="Qty">
                            <button onclick="handleAddMultipleInserts('E')" class="add-multiple-button">Add Qty Smart Inserts</button>
                        </div>
                    </div>
                </div>
            </div>
        </div> 
        
        <div class="orientation-prompt-overlay" id="orientationPrompt">
            <div> 
                <div class="orientation-prompt-icon">&#x21BB;</div>
                <p class="orientation-prompt-message">
                    For the best experience, please rotate your device to landscape mode.
                </p>
            </div>
        </div>

    </div> 
    
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="modal-close-button" id="closeHelpModalBtn">&times;</span>
            <h2>Help & Instructions</h2>
            <div id="helpModalBody">
                 <h4>General Usage:</h4>
                <p>This tool helps you create and manage blind destination lists for different types of blinds.</p>
                <ul>
                    <li><strong>List Name:</strong> Enter a name for your list. Used in exports. Avoid invalid characters (<code>/ \ : * ? " &lt; &gt; |</code>).</li>
                    <li><strong>Add / Delete Rows:</strong> Use "Add..." buttons or "Delete" button on each row.</li>
                    <li><strong>Drag & Drop:</strong> Use ↕ to reorder rows.</li>
                    <li><strong>Clear Table:</strong> Removes all data and inserts for that table.</li>
                    <li><strong>Import/Export:</strong> Use buttons to save/load <code>.blind</code> files. Import overwrites current data. Session Persistence: Data is saved across page refreshes, but cleared when tab/browser is closed.</li>
                </ul>

                <h4>Blind Modes:</h4>
                <ul>
                    <li><strong>Smartblind:</strong> Sequential numbering (0 & 511 are fixed). Max 255 user rows (incl. inserts). Separate insert table.</li>
                    <li><strong>Manual Blind:</strong> Sequential main numbers. Lettered top inserts (A,B..), numbered middle inserts (17A..).
                        <ul>
                            <li><strong>Front & Rear Separate:</strong> If "Is Front & Rear Number Separate?" is checked (below mode selection), "Front / Rear Number" table becomes "Front Number / Via", and a new "Rear Number" table appears. "Front Number / Via" data cells allow multi-line input.</li>
                            <li><strong>Side Blind Split:</strong> If "Is Side Blind Split?" is checked, "Side Ultimate / Via" table becomes "Side Number", and a new "Side Intermediate" table appears.</li>
                        </ul>
                    </li>
                    <li><strong>3 Track:</strong> "All 3 tracks identical?" option. If not, 3 separate tracks appear (Track 1, Track 2, Track 3). Inserts are like Manual mode.</li>
                </ul>
                <h4>Table Visibility (Smartblind/Manual):</h4>
                <p>In "Smartblind" and "Manual Blind" modes, use "Show Tables:" checkboxes to toggle visibility and inclusion in exports. Additional tables created via Manual mode options ("Rear Number", "Side Intermediate") will also have their visibility toggles appear here.</p>
                <p><em>Close this dialog by clicking the &times; or pressing Esc.</em></p>
            </div>
        </div>
    </div>

    <script>
    // --- PART 1: Setup, State, UI Logic, Session Storage ---

    // --- PWA Service Worker Registration ---
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./manifest-blind.json') // Ensure this path points to your actual sw.js file
                .then((registration) => {
                    console.log('PWA Service Worker registered successfully with scope:', registration.scope);
                })
                .catch((error) => {
                    console.error('PWA Service Worker registration failed:', error);
                });
        });
    }

    // --- Constants for Smartblind Mode ---
    const BLACK_BLANK_TEXT = "BLACK BLANK";
    const SMART_DELIMITER_0_NUM = "0";
    const SMART_DELIMITER_0_DISPLAY_TEXT = "BLACK BLANK";
    const SMART_DELIMITER_511_NUM = "511";
    const SMART_DELIMITER_511_DISPLAY_TEXT = "END CODE";
    const MAX_EDITABLE_ROWS_SMART = 255;
    const SMART_INSERT_SEPARATOR_TEXT = "--- INSERT ---";

    // --- Global State Variables ---
    let currentBlindMode = 'smart';
    let threeTrackIsIdentical = true;
    let isSideBlindSplit = false;
    let isFrontRearSeparate = false;

    // --- Configuration for Table Appearances ---
    const originalTableAppearances = {
        A: {
            title: "Front / Rear Number", altTitle: "Front Number / Via",
            header: "Route", altHeader: "Front Route/Via",
            addBtn: "Add Number", altAddBtn: "Add Front Rte/Via",
            insertsTitle: "Inserts for Front / Rear Number", altInsertsTitle: "Inserts for Front Number / Via"
        },
        B: { title: "Front Destination", header: "Destination", addBtn: "Add Destination", insertsTitle: "Inserts for Front Destination" },
        C: {
            title: "Side Ultimate / Via", altTitle: "Side Number",
            header: "Side Blind", altHeader: "Number",
            addBtn: "Add Via", altAddBtn: "Add Number",
            insertsTitle: "Inserts for Side Ultimate / Via", altInsertsTitle: "Inserts for Side Number"
        },
        D: { title: "Side Intermediate", header: "Intermediate Blind", addBtn: "Add Intermediate", insertsTitle: "Inserts for Side Intermediate" },
        E: { title: "Rear Number", header: "Rear Number", addBtn: "Add Rear No.", insertsTitle: "Inserts for Rear Number" }
    };

    const threeTrackAppearances = {
        A: { title: "Track 1", header: "Number", addBtn: "Add Row", insertsTitle: "Inserts for Track 1"},
        B: { title: "Track 2", header: "Number", addBtn: "Add Row", insertsTitle: "Inserts for Track 2"},
        C: { title: "Track 3", header: "Number", addBtn: "Add Row", insertsTitle: "Inserts for Track 3"}
    };
    const threeTrackIdenticalAppearance = {
        title: "All Three Track Blinds", header: "Number", addBtn: "Add Row", insertsTitle: "Inserts for All Three Track Blinds"
    };

    // --- Data Storage for Tables ---
    let tableSettings = {
        A: { data: [], insertsData: [], hasInserts: false, manual_insert_location: 'bottom', manual_insert_after_display_row_number: 0, isVisibleInSmartManual: true, sortableInstance: null, sortableInsertsInstance: null },
        B: { data: [], insertsData: [], hasInserts: false, manual_insert_location: 'bottom', manual_insert_after_display_row_number: 0, isVisibleInSmartManual: true, sortableInstance: null, sortableInsertsInstance: null },
        C: { data: [], insertsData: [], hasInserts: false, manual_insert_location: 'bottom', manual_insert_after_display_row_number: 0, isVisibleInSmartManual: true, sortableInstance: null, sortableInsertsInstance: null },
        D: { data: [], insertsData: [], hasInserts: false, manual_insert_location: 'bottom', manual_insert_after_display_row_number: 0, isVisibleInSmartManual: true, sortableInstance: null, sortableInsertsInstance: null }, // Default true, actual display depends on split state
        E: { data: [], insertsData: [], hasInserts: false, manual_insert_location: 'bottom', manual_insert_after_display_row_number: 0, isVisibleInSmartManual: true, sortableInstance: null, sortableInsertsInstance: null }  // Default true, actual display depends on split state
    };

    // --- Utility Functions ---
    function generateUUID() { return crypto.randomUUID(); }

    function getThreeTrackPrefillData() {
        const prefillValues = [
            BLACK_BLANK_TEXT, ...Array.from({length: 10}, (_, i) => String(i)), BLACK_BLANK_TEXT,
            ...Array.from({length: 26}, (_, i) => String.fromCharCode(65 + i)), BLACK_BLANK_TEXT
        ];
        return prefillValues.map(val => ({ id: generateUUID(), value: val, type: 'main' }));
    }

    // --- Session Storage Functions ---
    function saveStateToSessionStorage() {
        try {
            const tableSettingsToStore = {};
            for (const key in tableSettings) {
                if (tableSettings.hasOwnProperty(key) && tableSettings[key]) {
                    tableSettingsToStore[key] = {
                        data: tableSettings[key].data,
                        insertsData: tableSettings[key].insertsData,
                        hasInserts: tableSettings[key].hasInserts,
                        isVisibleInSmartManual: tableSettings[key].isVisibleInSmartManual,
                        manual_insert_location: tableSettings[key].manual_insert_location,
                        manual_insert_after_display_row_number: tableSettings[key].manual_insert_after_display_row_number
                    };
                }
            }
            const stateToSave = {
                listName: document.getElementById('listNameInput').value,
                currentBlindMode: currentBlindMode,
                threeTrackIsIdentical: threeTrackIsIdentical,
                isSideBlindSplit: isSideBlindSplit,
                isFrontRearSeparate: isFrontRearSeparate,
                tableSettings: tableSettingsToStore
            };
            sessionStorage.setItem('blindListAppState', JSON.stringify(stateToSave));
        } catch (error) {
            console.error("Error saving state to sessionStorage:", error);
        }
    }

    function loadStateFromSessionStorage() {
        try {
            const savedStateJSON = sessionStorage.getItem('blindListAppState');
            if (!savedStateJSON) return false;

            const savedState = JSON.parse(savedStateJSON);

            document.getElementById('listNameInput').value = savedState.listName || '';
            currentBlindMode = savedState.currentBlindMode || 'smart';
            threeTrackIsIdentical = savedState.isThreeTrackIdentical === undefined ? true : savedState.isThreeTrackIdentical;
            isSideBlindSplit = savedState.isSideBlindSplit || false;
            isFrontRearSeparate = savedState.isFrontRearSeparate || false;

            const loadedTableSettings = savedState.tableSettings || {};
            ['A', 'B', 'C', 'D', 'E'].forEach(key => {
                if (!tableSettings[key]) {
                    tableSettings[key] = { data: [], insertsData: [], hasInserts: false, isVisibleInSmartManual: (key !=='D' && key !=='E'), sortableInstance: null, sortableInsertsInstance: null, manual_insert_location: 'bottom', manual_insert_after_display_row_number: 0 };
                }
                if (loadedTableSettings[key]) {
                    tableSettings[key].data = loadedTableSettings[key].data || [];
                    tableSettings[key].insertsData = loadedTableSettings[key].insertsData || [];
                    tableSettings[key].hasInserts = loadedTableSettings[key].hasInserts || false;
                    tableSettings[key].isVisibleInSmartManual = loadedTableSettings[key].isVisibleInSmartManual === undefined ? (key !=='D' && key !=='E') : !!loadedTableSettings[key].isVisibleInSmartManual;
                    tableSettings[key].manual_insert_location = loadedTableSettings[key].manual_insert_location || 'bottom';
                    tableSettings[key].manual_insert_after_display_row_number = loadedTableSettings[key].manual_insert_after_display_row_number || 0;
                }
                tableSettings[key].sortableInstance = null;
                tableSettings[key].sortableInsertsInstance = null;
            });

            const modeRadio = document.querySelector(`input[name="blindMode"][value="${currentBlindMode}"]`);
            if (modeRadio) modeRadio.checked = true;

            if (currentBlindMode === 'threeTrack') {
                const tiCheckbox = document.getElementById('threeTrackIdentical');
                if(tiCheckbox) tiCheckbox.checked = threeTrackIsIdentical;
            }
            if (currentBlindMode === 'manual') {
                const sbsCheckbox = document.getElementById('isSideBlindSplitCheckbox');
                if(sbsCheckbox) sbsCheckbox.checked = isSideBlindSplit;
                const frsCheckbox = document.getElementById('isFrontRearSeparateCheckbox');
                if(frsCheckbox) frsCheckbox.checked = isFrontRearSeparate;
            }

            ['A', 'B', 'C', 'D', 'E'].forEach(setId => {
                 if (tableSettings[setId]) {
                    const hiChk = document.getElementById(`hasInserts${setId}`);
                    if(hiChk) hiChk.checked = tableSettings[setId].hasInserts;
                    const stChk = document.getElementById(`showTable${setId}`);
                    if(stChk) stChk.checked = tableSettings[setId].isVisibleInSmartManual;
                }
            });
            return true;
        } catch (error) {
            console.error("Error loading state from sessionStorage:", error);
            sessionStorage.removeItem('blindListAppState');
            return false;
        }
    }

    // --- Help Modal Variables & Functions ---
    let helpModalElement;
    let closeHelpModalBtnElement;
    function showHelpModal() { if(helpModalElement) helpModalElement.style.display = "block"; }
    function closeHelpModal() { if(helpModalElement) helpModalElement.style.display = "none"; }

    // --- DOMContentLoaded: Main Setup ---
    document.addEventListener('DOMContentLoaded', () => {
        // Mode Change Listeners
        document.getElementById('smartBlindMode').addEventListener('change', () => { updateBlindMode('smart'); saveStateToSessionStorage(); });
        document.getElementById('manualBlindMode').addEventListener('change', () => { updateBlindMode('manual'); saveStateToSessionStorage(); });
        document.getElementById('threeTrackMode').addEventListener('change', () => {
            document.getElementById('threeTrackMode').justSwitchedTo = true;
            updateBlindMode('threeTrack');
            saveStateToSessionStorage();
        });

        // Specific Control Listeners
        document.getElementById('threeTrackIdentical').addEventListener('change', (event) => { handleThreeTrackIdenticalToggle(event.target.checked); saveStateToSessionStorage(); });
        document.getElementById('isSideBlindSplitCheckbox').addEventListener('change', (event) => { handleSideBlindSplitToggle(event.target.checked); saveStateToSessionStorage(); });
        document.getElementById('isFrontRearSeparateCheckbox').addEventListener('change', (event) => { handleFrontRearSeparateToggle(event.target.checked); saveStateToSessionStorage(); });

        // Action Button Listeners
        document.getElementById('copyToBBtn').addEventListener('click', () => { copyFromFirstTrackTo('B'); /* Calls saveState internally */ });
        document.getElementById('copyToCBtn').addEventListener('click', () => { copyFromFirstTrackTo('C'); /* Calls saveState internally */ });

        const fileInput = document.getElementById('blindFileInput');
        if (fileInput) fileInput.addEventListener('change', importFromBLIND); // importFromBLIND calls saveState

        helpModalElement = document.getElementById("helpModal");
        closeHelpModalBtnElement = document.getElementById("closeHelpModalBtn");
        const helpButton = document.getElementById("helpButton");
        if(helpButton) helpButton.addEventListener('click', showHelpModal);
        if(closeHelpModalBtnElement) closeHelpModalBtnElement.addEventListener('click', closeHelpModal);
        window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && helpModalElement && helpModalElement.style.display === "block") closeHelpModal(); });
        if(helpModalElement) helpModalElement.addEventListener('click', (e) => { if (e.target === helpModalElement) closeHelpModal(); });

        const listNameInput = document.getElementById('listNameInput');
        if (listNameInput) listNameInput.addEventListener('input', saveStateToSessionStorage);

        ['A', 'B', 'C', 'D', 'E'].forEach(setId => {
            const hasInsertsCheckbox = document.getElementById(`hasInserts${setId}`);
            if (hasInsertsCheckbox && tableSettings[setId]) {
                 hasInsertsCheckbox.addEventListener('change', (event) => { handleInsertToggle(setId, event.target.checked); saveStateToSessionStorage(); });
            }
            const showTableCheckbox = document.getElementById(`showTable${setId}`);
            if (showTableCheckbox && tableSettings[setId]) {
                showTableCheckbox.addEventListener('change', (event) => { handleTableVisibilityToggle(setId, event.target.checked); saveStateToSessionStorage(); });
            }
        });

        const manualSpecificControls = document.getElementById('manualBlindSpecificControlsContainer'); if(manualSpecificControls) manualSpecificControls.style.display = 'none';
        const showTableDSpan = document.getElementById('showTableDSpan'); if(showTableDSpan) showTableDSpan.style.display = 'none';
        const showTableESpan = document.getElementById('showTableESpan'); if(showTableESpan) showTableESpan.style.display = 'none';

        const stateLoaded = loadStateFromSessionStorage();

        if (stateLoaded) {
            updateBlindMode(currentBlindMode, true); // true = skip default data init and initial render

            if (currentBlindMode === 'threeTrack') {
                handleThreeTrackIdenticalToggle(threeTrackIsIdentical);
            } else if (currentBlindMode === 'manual') {
                handleSideBlindSplitToggle(isSideBlindSplit);
                handleFrontRearSeparateToggle(isFrontRearSeparate);
            }

            ['A', 'B', 'C', 'D', 'E'].forEach(setId => {
                if (tableSettings[setId]) {
                    handleInsertToggle(setId, tableSettings[setId].hasInserts, true); // true for calledDuringSync
                    const showCheckbox = document.getElementById(`showTable${setId}`);
                    const isChecked = showCheckbox ? showCheckbox.checked : tableSettings[setId].isVisibleInSmartManual;
                    handleTableVisibilityToggle(setId, isChecked); // This should also call renderTable if visible
                }
            });
            updateTableAppearances(); // Final text/label refresh
        } else {
            updateBlindMode('smart'); // Default initialization
            // updateBlindMode -> ... -> saveStateToSessionStorage will be called if it modifies anything.
            // For a truly fresh start, ensure saveState happens once.
             saveStateToSessionStorage();
        }
    });

    // --- UI Update & State Handler Functions ---
    function handleTableVisibilityToggle(setId, isVisible) {
        if (!tableSettings[setId]) return;
        // This function is primarily for Smart/Manual modes for tables A,B,C and for D,E when their split is active.
        // 3-Track table visibility for B,C is handled by handleThreeTrackIdenticalToggle directly setting container style.
        if (currentBlindMode === 'smart' || currentBlindMode === 'manual') {
            tableSettings[setId].isVisibleInSmartManual = isVisible;
            const tableContainer = document.getElementById(`table-container-${setId}`);
            if (tableContainer) {
                let actualDisplay = false;
                if (setId === 'D') actualDisplay = currentBlindMode === 'manual' && isSideBlindSplit && isVisible;
                else if (setId === 'E') actualDisplay = currentBlindMode === 'manual' && isFrontRearSeparate && isVisible;
                else actualDisplay = isVisible;

                tableContainer.style.display = actualDisplay ? 'block' : 'none';

                if (actualDisplay && typeof renderTable === "function") renderTable(setId);
                else if (!actualDisplay) {
                    const tableBodyClear = document.getElementById(`table-body-${setId}`); if(tableBodyClear) tableBodyClear.innerHTML = '';
                    const insertsTableBodyClear = document.getElementById(`table-body-inserts-${setId}`); if(insertsTableBodyClear) insertsTableBodyClear.innerHTML = '';
                }
            }
        }
        // saveStateToSessionStorage(); // Called by the event listener directly
    }

    function updateTableAppearances() {
        ['A', 'B', 'C', 'D', 'E'].forEach(setId => {
            const titleEl = document.getElementById(`table-title-${setId}`);
            const headerEl = document.getElementById(`table-header-data-${setId}`);
            const addBtnEl = document.getElementById(`addDataRowBtn${setId}`);
            const insertTitleEl = document.getElementById(`inserts-title-${setId}`);
            const smartInsertHeaderEl = document.getElementById(`table-header-inserts-data-${setId}`);
            const showTableLabelEl = document.getElementById(`showTable${setId}Label`);

            let appearance = originalTableAppearances[setId];
            let currentTitleForLabel = appearance ? appearance.title : '';

            if (currentBlindMode === 'manual') {
                if (setId === 'A' && isFrontRearSeparate && appearance) {
                    currentTitleForLabel = appearance.altTitle || appearance.title;
                    appearance = { title: originalTableAppearances.A.altTitle, header: originalTableAppearances.A.altHeader, addBtn: originalTableAppearances.A.altAddBtn, insertsTitle: originalTableAppearances.A.altInsertsTitle };
                } else if (setId === 'C' && isSideBlindSplit && appearance) {
                    currentTitleForLabel = appearance.altTitle || appearance.title;
                    appearance = { title: originalTableAppearances.C.altTitle, header: originalTableAppearances.C.altHeader, addBtn: originalTableAppearances.C.altAddBtn, insertsTitle: originalTableAppearances.C.altInsertsTitle };
                }
            } else if (currentBlindMode === 'threeTrack') {
                if (setId === 'D' || setId === 'E') { if(titleEl) titleEl.textContent = originalTableAppearances[setId]?.title || ''; return; } // D & E not used
                if (threeTrackIsIdentical) {
                    if (setId === 'A') appearance = threeTrackIdenticalAppearance;
                    else if (threeTrackAppearances[setId]) appearance = threeTrackAppearances[setId];
                } else {
                    if (threeTrackAppearances[setId]) appearance = threeTrackAppearances[setId];
                }
                currentTitleForLabel = appearance ? appearance.title : '';
            }
            // For D and E, their originalTableAppearances are static unless overridden by a specific mode
            if (setId === 'D' && originalTableAppearances.D) currentTitleForLabel = originalTableAppearances.D.title;
            if (setId === 'E' && originalTableAppearances.E) currentTitleForLabel = originalTableAppearances.E.title;


            if (showTableLabelEl && currentTitleForLabel) showTableLabelEl.textContent = currentTitleForLabel;
            if (titleEl && appearance) titleEl.textContent = appearance.title;
            if (headerEl && appearance) headerEl.textContent = appearance.header;
            if (addBtnEl && appearance) addBtnEl.textContent = appearance.addBtn;
            if (insertTitleEl && appearance) insertTitleEl.textContent = appearance.insertsTitle;
            if (smartInsertHeaderEl && appearance && appearance.header) smartInsertHeaderEl.textContent = `${appearance.header} (Insert)`;
        });
    }

    function handleThreeTrackIdenticalToggle(isIdentical) {
        threeTrackIsIdentical = isIdentical;
        const copyToBBtn = document.getElementById('copyToBBtn');
        const copyToCBtn = document.getElementById('copyToCBtn');
        const tableAContainer = document.getElementById('table-container-A');
        const tableBContainer = document.getElementById('table-container-B');
        const tableCContainer = document.getElementById('table-container-C');

        if (tableAContainer) tableAContainer.style.display = 'block'; // A is always potentially visible in 3-track

        if (isIdentical) {
            if (tableBContainer) tableBContainer.style.display = 'none';
            if (tableCContainer) tableCContainer.style.display = 'none';
            if (copyToBBtn) copyToBBtn.style.display = 'none';
            if (copyToCBtn) copyToCBtn.style.display = 'none';
        } else {
            if (tableBContainer) tableBContainer.style.display = 'block'; // Explicitly show B
            if (tableCContainer) tableCContainer.style.display = 'block'; // Explicitly show C
            if (copyToBBtn) copyToBBtn.style.display = 'inline-block';
            if (copyToCBtn) copyToCBtn.style.display = 'inline-block';
        }
        updateTableAppearances();
        if (typeof renderTable === "function") {
            renderTable('A');
            if (!isIdentical) {
                if (tableBContainer && tableBContainer.style.display === 'block') renderTable('B');
                if (tableCContainer && tableCContainer.style.display === 'block') renderTable('C');
            } else {
                 const bBody = document.getElementById('table-body-B'); if(bBody) bBody.innerHTML = '';
                 const cBody = document.getElementById('table-body-C'); if(cBody) cBody.innerHTML = '';
            }
        }
        // saveStateToSessionStorage(); // Called by its event listener
    }

    function copyFromFirstTrackTo(targetSetId) {
        if (currentBlindMode !== 'threeTrack' || threeTrackIsIdentical || (targetSetId !== 'B' && targetSetId !== 'C')) return;
        const sourceTableTitle = tableSettings.A.title || "Track 1"; // Fallback title
        const targetTableTitle = tableSettings[targetSetId].title || `Track ${targetSetId}`;
        if (!confirm(`Overwrite ${targetTableTitle} with ${sourceTableTitle} contents?`)) return;

        tableSettings[targetSetId].data = JSON.parse(JSON.stringify(tableSettings.A.data)).map(item => ({...item, id: generateUUID()}));
        tableSettings[targetSetId].hasInserts = tableSettings.A.hasInserts;
        document.getElementById(`hasInserts${targetSetId}`).checked = tableSettings.A.hasInserts;
        handleInsertToggle(targetSetId, tableSettings.A.hasInserts, true); // true for calledDuringSync
        if (typeof renderTable === "function") renderTable(targetSetId);
        saveStateToSessionStorage(); // Save state after copy
    }

    function handleSideBlindSplitToggle(isSplit) {
        isSideBlindSplit = isSplit;
        const showTableDSpan = document.getElementById('showTableDSpan');
        if (showTableDSpan) showTableDSpan.style.display = (currentBlindMode === 'manual' && isSplit) ? 'inline-flex' : 'none';

        updateTableAppearances();

        const showTableCCheckbox = document.getElementById('showTableC');
        if (showTableCCheckbox && tableSettings.C) handleTableVisibilityToggle('C', showTableCCheckbox.checked);

        if (currentBlindMode === 'manual' && isSplit) {
            const showTableDCheckbox = document.getElementById('showTableD');
            if (showTableDCheckbox && tableSettings.D) handleTableVisibilityToggle('D', showTableDCheckbox.checked);
        } else {
            handleTableVisibilityToggle('D', false);
        }
        // saveStateToSessionStorage(); // Called by its event listener
    }

    function handleFrontRearSeparateToggle(isSeparate) {
        isFrontRearSeparate = isSeparate;
        const showTableESpan = document.getElementById('showTableESpan');
        if (showTableESpan) showTableESpan.style.display = (currentBlindMode === 'manual' && isSeparate) ? 'inline-flex' : 'none';

        updateTableAppearances();

        const showTableACheckbox = document.getElementById('showTableA');
        if (showTableACheckbox && tableSettings.A) handleTableVisibilityToggle('A', showTableACheckbox.checked);

        if (currentBlindMode === 'manual' && isSeparate) {
            const showTableECheckbox = document.getElementById('showTableE');
            if (showTableECheckbox && tableSettings.E) handleTableVisibilityToggle('E', showTableECheckbox.checked);
        } else {
            handleTableVisibilityToggle('E', false);
        }
        // saveStateToSessionStorage(); // Called by its event listener
    }

    function updateBlindMode(newMode, skipRenderOrInitialLoad = false) {
        const previousMode = currentBlindMode;
        currentBlindMode = newMode;

        const threeTrackGlobalControlsDiv = document.getElementById('threeTrackGlobalControls');
        const tableVisibilityControlsDiv = document.getElementById('tableVisibilityControls');
        const manualBlindSpecificControlsContainer = document.getElementById('manualBlindSpecificControlsContainer');
        // Visibility of D and E specific toggles (showTableDSpan, showTableESpan) is handled by their respective split handlers

        if (threeTrackGlobalControlsDiv) threeTrackGlobalControlsDiv.style.display = 'none';
        if (tableVisibilityControlsDiv) tableVisibilityControlsDiv.style.display = 'none';
        if (manualBlindSpecificControlsContainer) manualBlindSpecificControlsContainer.style.display = 'none';
        const copyToBBtn = document.getElementById('copyToBBtn'); if(copyToBBtn) copyToBBtn.style.display = 'none';
        const copyToCBtn = document.getElementById('copyToCBtn'); if(copyToCBtn) copyToCBtn.style.display = 'none';

        // Explicitly set visibility of main table containers before specific handlers adjust them
        // Default to showing A, B, C unless 3-track identical hides B, C
        document.getElementById('table-container-A').style.display = 'block';
        document.getElementById('table-container-B').style.display = (currentBlindMode === 'threeTrack' && threeTrackIsIdentical) ? 'none' : 'block';
        document.getElementById('table-container-C').style.display = (currentBlindMode === 'threeTrack' && threeTrackIsIdentical) ? 'none' : 'block';
        document.getElementById('table-container-D').style.display = 'none'; // Default hidden
        document.getElementById('table-container-E').style.display = 'none'; // Default hidden


        if (currentBlindMode === 'manual') {
            if (manualBlindSpecificControlsContainer) manualBlindSpecificControlsContainer.style.display = 'flex';
            if (tableVisibilityControlsDiv) tableVisibilityControlsDiv.style.display = 'flex';
        } else if (currentBlindMode === 'threeTrack') {
            if (threeTrackGlobalControlsDiv) threeTrackGlobalControlsDiv.style.display = 'flex';
        } else { // Smart Mode
            if (tableVisibilityControlsDiv) tableVisibilityControlsDiv.style.display = 'flex';
        }

        if (previousMode === 'manual' && newMode !== 'manual') { // Reset manual states when leaving manual mode
            const sbsChk = document.getElementById('isSideBlindSplitCheckbox'); if (sbsChk && sbsChk.checked) sbsChk.click(); // Trigger change event
            const frsChk = document.getElementById('isFrontRearSeparateCheckbox'); if (frsChk && frsChk.checked) frsChk.click();
        }
        // Always call these; they will set visibility of D/E toggles and containers based on current state
        handleSideBlindSplitToggle(currentBlindMode === 'manual' && document.getElementById('isSideBlindSplitCheckbox').checked);
        handleFrontRearSeparateToggle(currentBlindMode === 'manual' && document.getElementById('isFrontRearSeparateCheckbox').checked);


        if (currentBlindMode === 'threeTrack' && document.getElementById('threeTrackMode').justSwitchedTo && !skipRenderOrInitialLoad) {
             tableSettings.A.data = getThreeTrackPrefillData();
             ['B', 'C', 'D', 'E'].forEach(id => { if(tableSettings[id]) tableSettings[id].data = [];});
             const tiChk = document.getElementById('threeTrackIdentical'); if(tiChk) tiChk.checked = true; threeTrackIsIdentical = true;
        }
        if (document.getElementById('threeTrackMode')) document.getElementById('threeTrackMode').justSwitchedTo = false;

        if (!skipRenderOrInitialLoad) {
            if (currentBlindMode === 'threeTrack') {
                handleThreeTrackIdenticalToggle(threeTrackIsIdentical); // Handles A,B,C display & render
            } else { // Smart or Manual - D & E visibility already handled by their toggle functions
                ['A', 'B', 'C'].forEach(setId => { // Render A,B,C based on their visibility checkboxes
                    if (tableSettings[setId]) {
                        const showCheckbox = document.getElementById(`showTable${setId}`);
                        handleTableVisibilityToggle(setId, showCheckbox ? showCheckbox.checked : tableSettings[setId].isVisibleInSmartManual);
                    }
                });
            }
        }

        ['A', 'B', 'C', 'D', 'E'].forEach(setId => { // Sync inserts UI
            if (tableSettings[setId]) {
                if (!skipRenderOrInitialLoad && (currentBlindMode === 'smart' || currentBlindMode === 'manual') && !(previousMode === currentBlindMode && previousMode !== 'threeTrack')) {
                    const hasInsertsChk = document.getElementById(`hasInserts${setId}`);
                    if (hasInsertsChk) hasInsertsChk.checked = false;
                    handleInsertToggle(setId, false, true);
                }
                // ... (rest of insert UI sync from your previous full version)
                 const insertsSubContainer = document.getElementById(`inserts-table-sub-container-${setId}`);
                if (insertsSubContainer) insertsSubContainer.style.display = (currentBlindMode === 'smart' && tableSettings[setId].hasInserts) ? 'block' : 'none';
                const addTopInsertBtn = document.getElementById(`addTopInsert${setId}`);
                if (addTopInsertBtn) addTopInsertBtn.style.display = ((currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') && tableSettings[setId].hasInserts) ? 'inline-block' : 'none';
                if (currentBlindMode === 'smart' && !skipRenderOrInitialLoad) { /* Smart mode data cleanup */ }
                if (tableSettings[setId].sortableInsertsInstance && currentBlindMode !== 'smart') { /* Destroy smart insert sortable */ }
            }
        });
        updateTableAppearances();
        // saveStateToSessionStorage(); // Called by triggering event listeners
    }

    function clearTableData(setId) {
        if (!tableSettings[setId]) return;
        const tableName = document.getElementById(`table-title-${setId}`)?.textContent || `Table ${setId}`;
        if (!confirm(`Are you sure you want to clear all data and inserts for ${tableName}?`)) return;
        tableSettings[setId].data = []; tableSettings[setId].insertsData = [];
        const hasInsertsCheckbox = document.getElementById(`hasInserts${setId}`);
        if (hasInsertsCheckbox) { tableSettings[setId].hasInserts = false; hasInsertsCheckbox.checked = false; }
        handleInsertToggle(setId, false, true);
        if (typeof renderTable === "function") renderTable(setId);
        saveStateToSessionStorage();
    }

    function handleInsertToggle(setId, isChecked, calledDuringSync = false) {
        if (!tableSettings[setId]) return;
        tableSettings[setId].hasInserts = isChecked;
        const insertsSubContainer = document.getElementById(`inserts-table-sub-container-${setId}`);
        const addTopInsertButton = document.getElementById(`addTopInsert${setId}`);
        const addSmartInsertButton = document.getElementById(`addSmartInsertBtn${setId}`);
        const addQtySmartInsertParent = insertsSubContainer ? insertsSubContainer.querySelector(`.multiple-add-control`) : null;

        if (currentBlindMode === 'smart') {
            if (insertsSubContainer) insertsSubContainer.style.display = isChecked ? 'block' : 'none';
            if (addTopInsertButton) addTopInsertButton.style.display = 'none';
            if (addSmartInsertButton) addSmartInsertButton.style.visibility = isChecked ? 'visible' : 'hidden';
            if (addQtySmartInsertParent) addQtySmartInsertParent.style.visibility = isChecked ? 'visible' : 'hidden';

            const smartInsertsTableBody = document.getElementById(`table-body-inserts-${setId}`);
            if (isChecked && !tableSettings[setId].sortableInsertsInstance && smartInsertsTableBody && typeof initializeSortableForTable === "function") {
                initializeSortableForTable(setId, true);
            } else if (!isChecked && tableSettings[setId].sortableInsertsInstance) {
                tableSettings[setId].sortableInsertsInstance.destroy();
                tableSettings[setId].sortableInsertsInstance = null;
                if (!calledDuringSync) tableSettings[setId].insertsData = [];
            }
        } else { // Manual or 3-Track
            if (insertsSubContainer) insertsSubContainer.style.display = 'none';
            if (addSmartInsertButton) addSmartInsertButton.style.visibility = 'hidden';
            if (addQtySmartInsertParent) addQtySmartInsertParent.style.visibility = 'hidden';
            if (addTopInsertButton) addTopInsertButton.style.display = isChecked ? 'inline-block' : 'none';
        }
        if (!calledDuringSync && typeof renderTable === "function") renderTable(setId);
        // saveStateToSessionStorage(); // Called by the checkbox event listener
    }

    function getPlaceholderText(setId, isInsert = false, itemType = 'main') {
        let baseText = 'Value';
        let currentAppearance = originalTableAppearances[setId]; // Start with default

        if (currentBlindMode === 'manual') {
            if (setId === 'A' && isFrontRearSeparate) currentAppearance = { header: originalTableAppearances.A.altHeader || originalTableAppearances.A.header };
            else if (setId === 'C' && isSideBlindSplit) currentAppearance = { header: originalTableAppearances.C.altHeader || originalTableAppearances.C.header };
        } else if (currentBlindMode === 'threeTrack') {
            if (setId === 'D' || setId === 'E') return "N/A"; // Not applicable
            if (threeTrackIsIdentical && setId === 'A') currentAppearance = threeTrackIdenticalAppearance;
            else if (threeTrackAppearances[setId]) currentAppearance = threeTrackAppearances[setId];
        }
        baseText = currentAppearance ? currentAppearance.header : 'Value';
        
        if (isInsert || itemType === 'insert') {
             if (currentBlindMode === 'smart') return `Enter ${baseText} (Smart Insert)`;
             return `Enter ${baseText} (Insert)`;
        }
        return `Enter ${baseText}`;
    }

    // Part 2 functions (renderTable, createEditableRowElement, data ops, import/export etc.) will be added next.
// --- PART 2: Detailed Table Operations, Rendering, Import/Export ---

function renderTable(setId) {
    const tableContainer = document.getElementById(`table-container-${setId}`);
    // Ensure table is meant to be visible before rendering
    if (!tableContainer || tableContainer.style.display === 'none') {
        const tableBodyClear = document.getElementById(`table-body-${setId}`);
        if(tableBodyClear) tableBodyClear.innerHTML = '';
        const insertsTableBodyClear = document.getElementById(`table-body-inserts-${setId}`);
        if(insertsTableBodyClear) insertsTableBodyClear.innerHTML = '';
        return;
    }

    const tableBody = document.getElementById(`table-body-${setId}`);
    const settings = tableSettings[setId];
    if (!settings) {
        if (tableBody) tableBody.innerHTML = ''; // Clear if no settings defined
        console.warn(`renderTable called for non-existent table settings: ${setId}`);
        return;
    }
    const mainDataArray = settings.data;
    if (!tableBody) { console.error(`Table body not found for ${setId}`); return; }
    tableBody.innerHTML = ''; // Clear before re-render

    const smartInsertsTableBody = document.getElementById(`table-body-inserts-${setId}`);
    if (smartInsertsTableBody) smartInsertsTableBody.innerHTML = '';

    // updateTableAppearances(); // Typically called by a higher-level function before renderTable

    const addTopInsertButton = document.getElementById(`addTopInsert${setId}`);
    if (addTopInsertButton) {
        addTopInsertButton.style.display = ((currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') && settings.hasInserts) ? 'inline-block' : 'none';
    }

    // Manual/3-Track numbering logic
    if (currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') {
        // This complex numbering logic should be the same as previously established and working for A,B,C
        // It will now also apply to D and E if they are rendered in these modes (primarily manual)
        mainDataArray.forEach(item => { /* ... reset/calculate numbering properties ... */
            if (!item.type) item.type = 'main';
            delete item.actualMainNumber; delete item.potentialParentMainNumber;
            if (item.insertSubtype === 'top' || item.insertSubtype === 'continuous_end') delete item.parentMainItemNumber;
        });
        let lastMainItemActualNum = 0; let currentOverallMainSeqNum = 0;
        for (let i = 0; i < mainDataArray.length; i++) {
            const item = mainDataArray[i];
            if (item.type === 'main') { currentOverallMainSeqNum++; item.actualMainNumber = currentOverallMainSeqNum; lastMainItemActualNum = item.actualMainNumber; }
            else if (item.type === 'insert' && item.insertSubtype !== 'top') item.potentialParentMainNumber = lastMainItemActualNum;
        }
        for (let i = 0; i < mainDataArray.length; i++) {
            const item = mainDataArray[i];
            if (item.type === 'insert') {
                if (item.insertSubtype === 'continuous_end') {
                    let mainItemFollows = false; for (let j = i + 1; j < mainDataArray.length; j++) if (mainDataArray[j].type === 'main') { mainItemFollows = true; break; }
                    if (mainItemFollows) { item.insertSubtype = 'middle'; item.parentMainItemNumber = item.potentialParentMainNumber > 0 ? item.potentialParentMainNumber : undefined; if (item.parentMainItemNumber === undefined) { item.insertSubtype = 'top'; delete item.parentMainItemNumber;}}
                }
                if (item.insertSubtype === 'middle') { if (item.parentMainItemNumber === undefined || item.parentMainItemNumber === 0) { item.parentMainItemNumber = item.potentialParentMainNumber > 0 ? item.potentialParentMainNumber : undefined; if(item.parentMainItemNumber === undefined) item.insertSubtype = 'top';}}
                if (item.insertSubtype === 'middle' || item.insertSubtype === 'top') delete item.actualMainNumber;
            }
        }
        currentOverallMainSeqNum = 0; mainDataArray.forEach(item => {
            if (item.type === 'main') { currentOverallMainSeqNum++; item.actualMainNumber = currentOverallMainSeqNum; }
            else if (item.type === 'insert' && item.insertSubtype === 'continuous_end') { currentOverallMainSeqNum++; item.actualMainNumber = currentOverallMainSeqNum; }
        });
    }

    // Smartblind rendering (only for A, B, C)
    if (currentBlindMode === 'smart' && (setId === 'A' || setId === 'B' || setId === 'C')) {
        tableBody.appendChild(createFixedRowElement(SMART_DELIMITER_0_DISPLAY_TEXT, SMART_DELIMITER_0_NUM, setId));
        mainDataArray.forEach((item, index) => {
            item.actualMainNumber = index + 1;
            tableBody.appendChild(createEditableRowElement(item, item.actualMainNumber, setId, false, false, index === mainDataArray.length -1));
        });
        const smartInsertsDataArray = settings.insertsData;
        const insertsSubContainer = document.getElementById(`inserts-table-sub-container-${setId}`);
        if (settings.hasInserts && insertsSubContainer) {
            insertsSubContainer.style.display = 'block';
            let insertNumberBase = mainDataArray.length + 1;
            smartInsertsDataArray.forEach((item, index) => {
                if (smartInsertsTableBody) smartInsertsTableBody.appendChild(createEditableRowElement(item, insertNumberBase + index, setId, true, false, index === smartInsertsDataArray.length - 1));
            });
            if (smartInsertsTableBody) smartInsertsTableBody.appendChild(createFixedRowElement(SMART_DELIMITER_511_DISPLAY_TEXT, SMART_DELIMITER_511_NUM, setId));
            if (!settings.sortableInsertsInstance && smartInsertsTableBody) initializeSortableForTable(setId, true);
        } else {
            if(insertsSubContainer) insertsSubContainer.style.display = 'none';
            tableBody.appendChild(createFixedRowElement(SMART_DELIMITER_511_DISPLAY_TEXT, SMART_DELIMITER_511_NUM, setId));
        }
    } else if (currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') {
        if (currentBlindMode === 'threeTrack' && (setId === 'D' || setId === 'E')) return; // D & E not in 3-track

        const insertsSubContainer = document.getElementById(`inserts-table-sub-container-${setId}`);
        if (insertsSubContainer) insertsSubContainer.style.display = 'none';

        let topInsertCounter = 0;
        let tempMiddleInsertLetterMap = {};
        mainDataArray.forEach((item, index) => {
            let displayNumber = "";
            let isManualInsertStyled = item.type === 'insert';
            // ... (Manual/3-Track display numbering logic from previous complete version) ...
            if (item.type === 'insert' && item.insertSubtype === 'top') displayNumber = String.fromCharCode(65 + topInsertCounter++);
            else if (item.type === 'main' || (item.type === 'insert' && item.insertSubtype === 'continuous_end')) { displayNumber = item.actualMainNumber; if (item.actualMainNumber !== undefined) tempMiddleInsertLetterMap[item.actualMainNumber] = 0; }
            else if (item.type === 'insert' && item.insertSubtype === 'middle') { const pNum = item.parentMainItemNumber; if (pNum !== undefined && pNum > 0 && tempMiddleInsertLetterMap.hasOwnProperty(pNum)) { const lIdx = tempMiddleInsertLetterMap[pNum]; displayNumber = `${pNum}${String.fromCharCode(65 + lIdx)}`; tempMiddleInsertLetterMap[pNum]++; } else displayNumber = `Ins(ErrP:${pNum})`; }

            if (displayNumber !== undefined && String(displayNumber).length > 0) tableBody.appendChild(createEditableRowElement(item, displayNumber, setId, false, isManualInsertStyled, index === mainDataArray.length - 1));
            else if (item.type === 'main') tableBody.appendChild(createEditableRowElement(item, `M?${mainDataArray.indexOf(item) + 1}`, setId, false, false, index === mainDataArray.length - 1));
            else tableBody.appendChild(createEditableRowElement(item, "??", setId, false, isManualInsertStyled, index === mainDataArray.length - 1));
        });
    }
    if (settings && !settings.sortableInstance && tableBody.children.length > 0) initializeSortableForTable(setId, false);
}

function createFixedRowElement(textDisplay, numberCellText, setId) {
    const fixedRow = document.createElement('tr'); fixedRow.className = 'fixed-row';
    fixedRow.insertCell().innerHTML = '&nbsp;'; fixedRow.cells[0].className = 'col-drag-cell fixed-row-drag-cell';
    fixedRow.insertCell().textContent = numberCellText; fixedRow.cells[1].className = 'col-num-cell fixed-row-num-cell';
    fixedRow.insertCell().textContent = textDisplay; fixedRow.cells[2].className = 'col-data-wide fixed-text-cell';
    fixedRow.insertCell().innerHTML = '&nbsp;'; fixedRow.cells[3].className = 'col-action-narrow col-action-cell fixed-row-action-cell';
    return fixedRow;
}

function createEditableRowElement(itemData, displayNumber, setId, isSmartInsertTable, isManualInsertStyled = false, isLastRow = false) {
    const tr = document.createElement('tr'); tr.dataset.id = itemData.id;
    if (isManualInsertStyled || (isSmartInsertTable && currentBlindMode === 'smart')) tr.classList.add('insert-row');

    const dragCell = tr.insertCell(); dragCell.className = 'col-drag-cell';
    const dragHandle = document.createElement('span'); dragHandle.className = 'drag-handle'; dragHandle.innerHTML = '&#9776;'; dragHandle.title = 'Drag to reorder';
    dragCell.appendChild(dragHandle);

    const numCell = tr.insertCell(); numCell.textContent = displayNumber; numCell.style.textAlign = 'center'; numCell.className = 'col-num-cell';
    const dataCell = tr.insertCell(); dataCell.className = 'col-data-wide';

    let inputElement;
    const commonPlaceholder = getPlaceholderText(setId, isSmartInsertTable || itemData.type === 'insert', itemData.type);
    const commonValue = itemData.value || '';
    const commonOnInput = () => { itemData.value = inputElement.value; saveStateToSessionStorage(); };

    if (setId === 'A' && currentBlindMode === 'manual' && isFrontRearSeparate && !isSmartInsertTable && itemData.type !== 'insert') {
        inputElement = document.createElement('textarea');
        inputElement.rows = 2; // Default, CSS can override or user can resize
    } else {
        inputElement = document.createElement('input');
        inputElement.type = 'text';
    }
    inputElement.placeholder = commonPlaceholder;
    inputElement.value = commonValue;
    inputElement.oninput = commonOnInput;
    dataCell.appendChild(inputElement);

    if (isLastRow) inputElement.addEventListener('keydown', (event) => handleTabOnLastInput(event, setId, isSmartInsertTable));

    const actionCell = tr.insertCell(); actionCell.className = 'col-action-narrow col-action-cell';
    if ((currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') && tableSettings[setId] && tableSettings[setId].hasInserts && (itemData.type === 'main' || (itemData.type === 'insert' && itemData.insertSubtype === 'continuous_end'))) {
        const addInsertButton = document.createElement('button'); addInsertButton.textContent = '+ Insert';
        addInsertButton.title = 'Add an insert item after this row'; addInsertButton.classList.add('small-add-insert-button');
        const parentNumForInsert = itemData.actualMainNumber !== undefined ? itemData.actualMainNumber : displayNumber;
        addInsertButton.onclick = () => addInsertAfterRow(setId, itemData.id, parentNumForInsert);
        actionCell.appendChild(addInsertButton);
    }
    const deleteButton = document.createElement('button'); deleteButton.textContent = 'Delete';
    deleteButton.classList.add('small-danger-button');
    deleteButton.onclick = () => {
        if (!tableSettings[setId]) return;
        let arrayToModify = (currentBlindMode === 'smart' && isSmartInsertTable) ? tableSettings[setId].insertsData : tableSettings[setId].data;
        const itemIndex = arrayToModify.findIndex(d => d.id === itemData.id);
        if (itemIndex > -1) {
            if ((currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') && !isSmartInsertTable && (itemData.type === 'main' || (itemData.type === 'insert' && itemData.insertSubtype === 'continuous_end'))) {
                const mainNumToDelete = itemData.actualMainNumber;
                tableSettings[setId].data = tableSettings[setId].data.filter(item => item.id !== itemData.id && !(item.type === 'insert' && item.insertSubtype === 'middle' && item.parentMainItemNumber === mainNumToDelete));
            } else arrayToModify.splice(itemIndex, 1);
        }
        if (typeof renderTable === "function") renderTable(setId);
        saveStateToSessionStorage();
    };
    actionCell.appendChild(deleteButton);
    return tr;
}

function handleTabOnLastInput(event, setId, isSmartInsertTable) {
    if (event.key === 'Tab' && !event.shiftKey) {
        event.preventDefault(); let newRowAdded = false;
        if (isSmartInsertTable) { if (currentBlindMode === 'smart' && tableSettings[setId] && tableSettings[setId].hasInserts) { addInsertDataRow(setId); newRowAdded = true; } }
        else { if (tableSettings[setId]) { addDataRow(setId); newRowAdded = true; } }
        if (newRowAdded) { setTimeout(() => {
            const tableBodyId = isSmartInsertTable ? `table-body-inserts-${setId}` : `table-body-${setId}`;
            const tableBody = document.getElementById(tableBodyId);
            if (tableBody && tableBody.lastElementChild) {
                let targetRowForFocus = tableBody.lastElementChild;
                while(targetRowForFocus && targetRowForFocus.classList.contains('fixed-row')) targetRowForFocus = targetRowForFocus.previousElementSibling;
                if (targetRowForFocus && !targetRowForFocus.classList.contains('fixed-row') && targetRowForFocus.cells.length > 2) {
                    const lastRowInput = targetRowForFocus.cells[2].querySelector('input, textarea'); if (lastRowInput) lastRowInput.focus();
                }
            }
        }, 0); }
    }
}

function addTopInsert(setId) {
    if (!tableSettings[setId] || !((currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') && tableSettings[setId].hasInserts)) { alert("Top inserts conditions not met."); return; }
    tableSettings[setId].data.unshift({ id: generateUUID(), value: '', type: 'insert', insertSubtype: 'top' });
    if (typeof renderTable === "function") renderTable(setId); saveStateToSessionStorage();
}

function addInsertAfterRow(setId, parentItemId, parentActualNumber) {
    if (!tableSettings[setId] || !((currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') && tableSettings[setId].hasInserts)) return;
    const dataArray = tableSettings[setId].data;
    const parentItemIndex = dataArray.findIndex(item => item.id === parentItemId); if (parentItemIndex === -1) return;
    const parentItem = dataArray[parentItemIndex]; let initialSubtype = 'middle'; let mainItemsFollow = false;
    for (let i = parentItemIndex + 1; i < dataArray.length; i++) if (dataArray[i].type === 'main') { mainItemsFollow = true; break; }
    if (!mainItemsFollow && (parentItem.type === 'main' || parentItem.insertSubtype === 'continuous_end')) initialSubtype = 'continuous_end';
    const newInsert = { id: generateUUID(), value: '', type: 'insert', insertSubtype: initialSubtype, parentMainItemNumber: (initialSubtype === 'middle' && typeof parentActualNumber === 'number' && parentActualNumber > 0) ? parentActualNumber : undefined };
    if (initialSubtype === 'middle' && newInsert.parentMainItemNumber === undefined) newInsert.insertSubtype = 'top';
    let insertionIndex = parentItemIndex + 1;
    if (newInsert.insertSubtype === 'middle' && newInsert.parentMainItemNumber !== undefined) { while (insertionIndex < dataArray.length && dataArray[insertionIndex].type === 'insert' && dataArray[insertionIndex].insertSubtype === 'middle' && dataArray[insertionIndex].parentMainItemNumber === newInsert.parentMainItemNumber) insertionIndex++; }
    dataArray.splice(insertionIndex, 0, newInsert); if (typeof renderTable === "function") renderTable(setId); saveStateToSessionStorage();
}

function initializeSortableForTable(setId, isInsertTable) {
    const tableBodyId = isInsertTable ? `table-body-inserts-${setId}` : `table-body-${setId}`;
    const tableBodyElement = document.getElementById(tableBodyId);
    const settings = tableSettings[setId]; if (!settings || !tableBodyElement) return;
    const instanceKey = isInsertTable ? 'sortableInsertsInstance' : 'sortableInstance';
    if (settings[instanceKey]) { settings[instanceKey].destroy(); settings[instanceKey] = null;}
    if (typeof Sortable !== 'undefined') {
        settings[instanceKey] = new Sortable(tableBodyElement, {
            animation: 150, handle: '.drag-handle', filter: '.fixed-row', preventOnFilter: true,
            ghostClass: 'sortable-ghost', chosenClass: 'sortable-chosen',
            onEnd: function (evt) {
                if (evt.newIndex !== undefined && evt.from.children[evt.newIndex] && evt.from.children[evt.newIndex].classList.contains('fixed-row')) { if (typeof renderTable === "function") renderTable(setId); return; }
                const currentDataArrayRef = isInsertTable ? settings.insertsData : settings.data;
                const newOrderIds = Array.from(evt.from.children).filter(c => !c.classList.contains('fixed-row') && c.dataset.id).map(c => c.dataset.id);
                const idToItemMap = new Map(currentDataArrayRef.map(item => [item.id, item]));
                const newSortedData = newOrderIds.map(id => idToItemMap.get(id)).filter(item => item);
                if (isInsertTable) settings.insertsData = newSortedData; else settings.data = newSortedData;
                if (typeof renderTable === "function") renderTable(setId); saveStateToSessionStorage();
            }
        });
    } else console.warn(`SortableJS library not loaded for ${setId}, insert: ${isInsertTable}.`);
}

function addDataRow(setId) {
    if (!tableSettings[setId]) return;
    const targetArray = tableSettings[setId].data;
    if (currentBlindMode === 'smart' && targetArray.length >= MAX_EDITABLE_ROWS_SMART) { alert(`Max ${MAX_EDITABLE_ROWS_SMART} rows.`); return; }
    targetArray.push({ id: generateUUID(), value: '', type: 'main' });
    if (typeof renderTable === "function") renderTable(setId); saveStateToSessionStorage();
}

function addInsertDataRow(setId) { // Smartblind inserts
    if (currentBlindMode !== 'smart' || !tableSettings[setId] || !tableSettings[setId].hasInserts) { alert("Smart inserts conditions not met."); return; }
    tableSettings[setId].insertsData.push({ id: generateUUID(), value: '', type: 'main' });
    if (typeof renderTable === "function") renderTable(setId); saveStateToSessionStorage();
}

function handleAddMultiple(setId) {
    if (!tableSettings[setId]) return;
    const qtyInput = document.getElementById(`qty-${setId}`); const quantity = parseInt(qtyInput.value, 10); if (isNaN(quantity) || quantity < 1) { alert(`Invalid qty.`); qtyInput.focus(); return; }
    const targetArray = tableSettings[setId].data;
    if (currentBlindMode === 'smart' && (targetArray.length + quantity) > MAX_EDITABLE_ROWS_SMART) { alert(`Cannot add. Max ${MAX_EDITABLE_ROWS_SMART} rows.`); return; }
    for (let i = 0; i < quantity; i++) targetArray.push({ id: generateUUID(), value: '', type: 'main' });
    if (typeof renderTable === "function") renderTable(setId); qtyInput.value = ''; saveStateToSessionStorage();
}

function handleAddMultipleInserts(setId) { // Smartblind inserts
    if (currentBlindMode !== 'smart' || !tableSettings[setId] || !tableSettings[setId].hasInserts) { alert("Smart inserts conditions not met."); return; }
    const qtyInput = document.getElementById(`qty-inserts-${setId}`); const quantity = parseInt(qtyInput.value, 10); if (isNaN(quantity) || quantity < 1) { alert(`Invalid qty.`); qtyInput.focus(); return; }
    for (let i = 0; i < quantity; i++) tableSettings[setId].insertsData.push({ id: generateUUID(), value: '', type: 'main' });
    if (typeof renderTable === "function") renderTable(setId); qtyInput.value = ''; saveStateToSessionStorage();
}

function getDisplayedRowsForExport(setId) {
    const outputRows = []; if (!tableSettings[setId]) return outputRows;
    const mainDataArray = JSON.parse(JSON.stringify(tableSettings[setId].data));
    const smartInsertsDataArray = JSON.parse(JSON.stringify(tableSettings[setId].insertsData));

    if (currentBlindMode === 'smart' && (setId === 'A' || setId === 'B' || setId === 'C') ) { // D & E not for smart mode
        outputRows.push({ label: SMART_DELIMITER_0_NUM, text: SMART_DELIMITER_0_DISPLAY_TEXT, type: 'delimiter' });
        mainDataArray.forEach((item, index) => outputRows.push({ label: String(index + 1), text: item.value || "", type: 'data' }));
        if (tableSettings[setId].hasInserts && smartInsertsDataArray && smartInsertsDataArray.length > 0) {
            outputRows.push({ label: "", text: SMART_INSERT_SEPARATOR_TEXT, type: 'insert_separator' });
            let insertNumberBase = mainDataArray.length + 1;
            smartInsertsDataArray.forEach((item, index) => outputRows.push({ label: String(insertNumberBase + index), text: item.value || "", type: 'insert' }));
        }
        outputRows.push({ label: SMART_DELIMITER_511_NUM, text: SMART_DELIMITER_511_DISPLAY_TEXT, type: 'delimiter' });
    } else if (currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') {
        // This complex numbering logic should be the same as in renderTable for these modes
        mainDataArray.forEach(item => { if(!item.type) item.type = 'main'; delete item.actualMainNumber; delete item.potentialParentMainNumber; if(item.insertSubtype === 'top' || item.insertSubtype === 'continuous_end') delete item.parentMainItemNumber;});
        let lastMainItemActualNum = 0; let currentOverallMainSeqNum = 0;
        for (let i = 0; i < mainDataArray.length; i++) { const item = mainDataArray[i]; if (item.type === 'main') { currentOverallMainSeqNum++; item.actualMainNumber = currentOverallMainSeqNum; lastMainItemActualNum = item.actualMainNumber; } else if (item.type === 'insert' && item.insertSubtype !== 'top') item.potentialParentMainNumber = lastMainItemActualNum; }
        for (let i = 0; i < mainDataArray.length; i++) { const item = mainDataArray[i]; if (item.type === 'insert') { if (item.insertSubtype === 'continuous_end') { let mainItemFollows = false; for (let j = i + 1; j < mainDataArray.length; j++) if (mainDataArray[j].type === 'main') { mainItemFollows = true; break; } if (mainItemFollows) { item.insertSubtype = 'middle'; item.parentMainItemNumber = item.potentialParentMainNumber > 0 ? item.potentialParentMainNumber : undefined; if (item.parentMainItemNumber === undefined) { item.insertSubtype = 'top'; delete item.parentMainItemNumber;}} } if (item.insertSubtype === 'middle') { if (item.parentMainItemNumber === undefined || item.parentMainItemNumber === 0) { item.parentMainItemNumber = item.potentialParentMainNumber > 0 ? item.potentialParentMainNumber : undefined; if(item.parentMainItemNumber === undefined) item.insertSubtype = 'top';}} if (item.insertSubtype === 'middle' || item.insertSubtype === 'top') delete item.actualMainNumber;}}
        currentOverallMainSeqNum = 0; mainDataArray.forEach(item => { if (item.type === 'main') { currentOverallMainSeqNum++; item.actualMainNumber = currentOverallMainSeqNum; } else if (item.type === 'insert' && item.insertSubtype === 'continuous_end') { currentOverallMainSeqNum++; item.actualMainNumber = currentOverallMainSeqNum; }});
        let topInsertCounter = 0; let tempMiddleInsertLetterMap = {};
        mainDataArray.forEach(item => {
            let displayNumber = "", value = item.value || "", isInsert = item.type === 'insert';
            if (isInsert && item.insertSubtype === 'top') displayNumber = String.fromCharCode(65 + topInsertCounter++);
            else if (item.type === 'main' || (isInsert && item.insertSubtype === 'continuous_end')) { displayNumber = String(item.actualMainNumber); if (item.actualMainNumber !== undefined) tempMiddleInsertLetterMap[item.actualMainNumber] = 0; }
            else if (isInsert && item.insertSubtype === 'middle') { const pNum = item.parentMainItemNumber; if (pNum !== undefined && pNum > 0 && tempMiddleInsertLetterMap.hasOwnProperty(pNum)) { const lIdx = tempMiddleInsertLetterMap[pNum]; displayNumber = `${pNum}${String.fromCharCode(65 + lIdx)}`; tempMiddleInsertLetterMap[pNum]++; } else displayNumber = "Ins"; }
            if (displayNumber) outputRows.push({ label: displayNumber, text: value + (isInsert ? " (insert)" : ""), type: isInsert ? 'insert' : 'data' });
        });
    }
    return outputRows;
}

function isValidFilename(filename) { /* ... (Keep existing robust validation logic) ... */
    const invalidCharsRegex = /[<>:"/\\|?*\x00-\x1F]/g; const filenameCore = filename.includes('.') ? filename.substring(0, filename.lastIndexOf('.')) : filename; const reservedNamesRegex = /^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])$/i;
    if (invalidCharsRegex.test(filename)) { alert('Invalid chars in filename.'); return false; } if (reservedNamesRegex.test(filenameCore)) { alert('Reserved filename.'); return false; } if (filename.length > 255) { alert('Filename too long.'); return false; } if (filename === "." || filename === "..") { alert('Filename cannot be . or ..'); return false; } if (/^[\s.]*$/.test(filename) && filename.length > 0) { alert('Filename only dots/spaces.'); return false; } if (/[. ]$/.test(filename)) { alert('Filename ends with dot/space.'); return false; } return true;
}

function exportToBLIND() {
    let userInputListName = document.getElementById('listNameInput').value.trim() || "Unnamed_List";
    if (document.getElementById('listNameInput').value.trim() && !isValidFilename(userInputListName)) { document.getElementById('listNameInput').focus(); return; }
    let textContent = `List Name:${userInputListName}\n`;
    let blindTypeDisplayValue; switch(currentBlindMode){ case 'smart': blindTypeDisplayValue = "Smartblind"; break; case 'manual': blindTypeDisplayValue = "Manual Blind"; break; case 'threeTrack': blindTypeDisplayValue = "3 Track"; break; default: blindTypeDisplayValue = currentBlindMode; } textContent += `Blind Type:${blindTypeDisplayValue}\n`;
    if (currentBlindMode === 'threeTrack') textContent += `Tracks Identical:${threeTrackIsIdentical ? 'Yes' : 'No'}\n`;
    if (currentBlindMode === 'manual') {
        textContent += `SideBlindSplit:${isSideBlindSplit ? 'Yes' : 'No'}\n`;
        textContent += `FrontRearSeparate:${isFrontRearSeparate ? 'Yes' : 'No'}\n`;
    }
    textContent += "\n";
    const tablesToActuallyExport = determineTablesToExport();
    tablesToActuallyExport.forEach(setId => {
        if (!tableSettings[setId] || isTableEffectivelyEmpty(setId)) return;
        let tableTitle, dataHeader;
        if (currentBlindMode === 'threeTrack') { if (setId === 'D' || setId === 'E') return; tableTitle = (threeTrackIsIdentical && setId === 'A') ? threeTrackIdenticalAppearance.title : threeTrackAppearances[setId].title; dataHeader = (threeTrackIsIdentical && setId === 'A') ? threeTrackIdenticalAppearance.header : threeTrackAppearances[setId].header; }
        else if (currentBlindMode === 'manual') {
            if (setId === 'A' && isFrontRearSeparate) { tableTitle = originalTableAppearances.A.altTitle; dataHeader = originalTableAppearances.A.altHeader; }
            else if (setId === 'C' && isSideBlindSplit) { tableTitle = originalTableAppearances.C.altTitle; dataHeader = originalTableAppearances.C.altHeader; }
            else { tableTitle = originalTableAppearances[setId].title; dataHeader = originalTableAppearances[setId].header; }
        } else { tableTitle = originalTableAppearances[setId].title; dataHeader = originalTableAppearances[setId].header; }
        textContent += `${tableTitle}\n`;
        textContent += `Inserts Added:${tableSettings[setId].hasInserts ? 'Yes' : 'No'}\n`;
        if(currentBlindMode === 'manual' || currentBlindMode === 'smart') textContent += `TableVisible:${tableSettings[setId].isVisibleInSmartManual ? 'Yes' : 'No'}\n`;
        textContent += `No.,${dataHeader}\n`;
        const displayedRows = getDisplayedRowsForExport(setId);
        displayedRows.forEach(row => { if (row.type === 'insert_separator') textContent += `${SMART_INSERT_SEPARATOR_TEXT}\n`; else textContent += `${row.label},${row.text.replace(/\n/g, '\\n')}\n`; }); // Replace newlines for .blind file
        textContent += "\n";
    });
    const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8;' }); const link = document.createElement("a"); link.href = URL.createObjectURL(blob); link.download = `${userInputListName}.blind`; document.body.appendChild(link); link.click(); document.body.removeChild(link);
}

function exportCurrentDataToPDF() {
    const { jsPDF } = window.jspdf;
    if (!jsPDF || !jsPDF.API || !jsPDF.API.autoTable) {
        alert("PDF library not loaded.");
        return;
    }
    let userInputListName = document.getElementById('listNameInput').value.trim() || "Blind_List";
    if (document.getElementById('listNameInput').value.trim() && !isValidFilename(userInputListName)) {
        document.getElementById('listNameInput').focus();
        return;
    }
    const doc = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
    let currentDocY = 40;

    // Set default text color to black for all subsequent doc.text calls
    doc.setTextColor(0, 0, 0);

    doc.setFontSize(16);
    doc.setFont("helvetica", "bold");
    doc.text(userInputListName, doc.internal.pageSize.getWidth() / 2, currentDocY, { align: 'center', maxWidth: doc.internal.pageSize.getWidth() - 80 });
    currentDocY += (doc.splitTextToSize(userInputListName, doc.internal.pageSize.getWidth() - 80).length * 16 * 1.15) + 10;

    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    let blindTypeDisplayValue;
    switch (currentBlindMode) {
        case 'smart': blindTypeDisplayValue = "Smartblind"; break;
        case 'manual': blindTypeDisplayValue = "Manual Blind"; break;
        case 'threeTrack': blindTypeDisplayValue = "3 Track"; break;
        default: blindTypeDisplayValue = currentBlindMode;
    }
    let blindTypeText = `Blind Type: ${blindTypeDisplayValue}`;
    if (currentBlindMode === 'threeTrack') blindTypeText += ` (Tracks Identical: ${threeTrackIsIdentical ? 'Yes' : 'No'})`;
    if (currentBlindMode === 'manual') blindTypeText += ` (Side Split: ${isSideBlindSplit ? 'Yes' : 'No'}, Front/Rear Separate: ${isFrontRearSeparate ? 'Yes' : 'No'})`;
    doc.text(blindTypeText, 40, currentDocY);
    currentDocY += (10 * 1.15) + 15;

    const tablesToActuallyExport = determineTablesToExport();
    let firstTable = true;
    tablesToActuallyExport.forEach((setId) => {
        if (!tableSettings[setId] || isTableEffectivelyEmpty(setId)) return;

        let tableTitle, dataHeader;
        // Determine title/header based on mode and split states (same logic as in exportToBLIND)
        if (currentBlindMode === 'threeTrack') {
            if (setId === 'D' || setId === 'E') return; // D & E not used in 3-track
            tableTitle = (threeTrackIsIdentical && setId === 'A') ? threeTrackIdenticalAppearance.title : threeTrackAppearances[setId].title;
            dataHeader = (threeTrackIsIdentical && setId === 'A') ? threeTrackIdenticalAppearance.header : threeTrackAppearances[setId].header;
        } else if (currentBlindMode === 'manual') {
            if (setId === 'A' && isFrontRearSeparate) {
                tableTitle = originalTableAppearances.A.altTitle;
                dataHeader = originalTableAppearances.A.altHeader;
            } else if (setId === 'C' && isSideBlindSplit) {
                tableTitle = originalTableAppearances.C.altTitle;
                dataHeader = originalTableAppearances.C.altHeader;
            } else {
                tableTitle = originalTableAppearances[setId].title;
                dataHeader = originalTableAppearances[setId].header;
            }
        } else { // Smart mode
            tableTitle = originalTableAppearances[setId].title;
            dataHeader = originalTableAppearances[setId].header;
        }

        if (!firstTable) {
             currentDocY = doc.lastAutoTable.finalY + 30;
        } else {
            firstTable = false;
        }

        // Check if there's enough space for the table title and some rows, add new page if not
        if (currentDocY + 60 > doc.internal.pageSize.getHeight() - 50) { // 60 is an arbitrary value for title + some rows
            doc.addPage();
            currentDocY = 60; // Reset Y for new page (adjust for top margin)
            doc.setTextColor(0, 0, 0); // Re-apply text color on the new page
        }

        doc.setFontSize(12);
        doc.setFont("helvetica", "bold");
        doc.text(tableTitle, 40, currentDocY);
        currentDocY += (12 * 1.15);

        doc.setFontSize(9);
        doc.setFont("helvetica", "italic");
        doc.text(`Inserts Added: ${tableSettings[setId].hasInserts ? 'Yes' : 'No'}`, 40, currentDocY);
        currentDocY += (9 * 1.15) + 10;

        const pdfHeaders = [["No.", dataHeader]];
        const pdfBody = getDisplayedRowsForExport(setId).map(row => {
            if (row.type === 'insert_separator') {
                return [{ content: '', _isInsertSeparator: true, _separatorText: SMART_INSERT_SEPARATOR_TEXT, colSpan: 2, styles: { cellPadding: { top: 6, bottom: 8, left: 2, right: 2 } } }];
            }
            return [row.label, row.text];
        });

        if (pdfBody.length === 0 && !(currentBlindMode === 'smart' && getDisplayedRowsForExport(setId).some(r => r.type === 'delimiter'))) {
             pdfBody.push([{content: " ", styles: {textColor: [0,0,0]}}, {content: " ", styles: {textColor: [0,0,0]}}]);
        }

        doc.autoTable({
            head: pdfHeaders,
            body: pdfBody,
            startY: currentDocY,
            theme: 'grid',
            headStyles: { textColor: [0, 0, 0], fontStyle: 'bold', halign: 'center', fillColor: [220, 220, 220] },
            bodyStyles: { textColor: [0, 0, 0] }, // Ensures table body text is black
            columnStyles: {
                0: { halign: 'center', cellWidth: 60 },
                1: { cellWidth: doc.internal.pageSize.getWidth() - 80 - 60 - 4 } // Adjusted for margins
            },
            margin: { left: 40, right: 40, bottom: 50 }, // Ensure enough bottom margin for footer
            didDrawPage: function (data) {
                const pageCount = doc.internal.getNumberOfPages();
                doc.setFontSize(9);
                doc.setFont("helvetica", "normal");
                doc.setTextColor(0, 0, 0); // Footer text color
                const footerY = doc.internal.pageSize.getHeight() - 20;
                doc.text(`Page ${data.pageNumber} of ${pageCount}`, doc.internal.pageSize.getWidth() - 40, footerY, { align: 'right' });
                const today = new Date();
                // Format date as DD/MM/YYYY
                const day = String(today.getDate()).padStart(2, '0');
                const month = String(today.getMonth() + 1).padStart(2, '0'); // Months are 0-indexed
                const year = today.getFullYear();
                const formattedDate = `${day}/${month}/${year}`;
                doc.text(`Generated: ${formattedDate}`, 40, footerY);
            },
            didDrawCell: function(data) {
                if (data.cell.raw && data.cell.raw._isInsertSeparator) {
                    const cell = data.cell;
                    const docInstance = data.doc;
                    cell.text = ''; // Clear any default text rendering for this cell
                    const text = cell.raw._separatorText || "INSERT";

                    // Save current styles
                    const pLW = docInstance.getLineWidth();
                    const pDC = docInstance.getDrawColor(); // This is an object/string depending on jsPDF version, handle carefully
                    const pFC = docInstance.getFillColor(); // Same as above
                    const pFont = docInstance.getFont();
                    const pFS = docInstance.getFontSize();
                    const pTC = docInstance.getTextColor(); // Same as above

                    docInstance.setLineWidth(0.2);
                    docInstance.setDrawColor(200); // Light grey for cell border
                    // docInstance.rect(cell.x, cell.y, cell.width, cell.height); // Optionally draw cell border

                    docInstance.setFontSize(9);
                    docInstance.setFont(pFont.fontName, 'italic');
                    docInstance.setTextColor(0, 0, 0); // "--- INSERT ---" text to black

                    let cPad = { top: 0, right: 0, bottom: 0, left: 0 };
                    const cellPaddingStyle = cell.styles.cellPadding;
                    if (typeof cellPaddingStyle === 'object') {
                        cPad = { top: cellPaddingStyle.top || 0, right: cellPaddingStyle.right || 0, bottom: cellPaddingStyle.bottom || 0, left: cellPaddingStyle.left || 0 };
                    } else if (typeof cellPaddingStyle === 'number') {
                        cPad = { top: cellPaddingStyle, right: cellPaddingStyle, bottom: cellPaddingStyle, left: cellPaddingStyle };
                    }

                    const tW = docInstance.getTextWidth(text);
                    const cellContentHeight = cell.height - cPad.top - cPad.bottom;
                    const lineY = cell.y + cPad.top + cellContentHeight / 2;
                    const textY = lineY + (docInstance.getFontSize() * 0.35 / docInstance.internal.scaleFactor); // Minor adjustment for visual centering

                    docInstance.text(text, cell.x + (cell.width - tW) / 2, textY);

                    // Draw dashed lines
                    docInstance.setLineWidth(0.5);
                    docInstance.setDrawColor(0); // Black lines
                    docInstance.setLineDashPattern([3, 2], 0);
                    const linePaddingFromText = 5;

                    const line1x1 = cell.x + cPad.left + 2;
                    const line1x2 = cell.x + (cell.width - tW) / 2 - linePaddingFromText;
                    if (line1x2 > line1x1) docInstance.line(line1x1, lineY, line1x2, lineY);

                    const line2x1 = cell.x + (cell.width + tW) / 2 + linePaddingFromText;
                    const line2x2 = cell.x + cell.width - cPad.right - 2;
                    if (line2x2 > line2x1) docInstance.line(line2x1, lineY, line2x2, lineY);

                    // Restore previous styles
                    docInstance.setLineDashPattern([], 0);
                    docInstance.setLineWidth(pLW);
                    // Safely restore colors - jsPDF's getColor methods can return different types
                    if (typeof pDC === 'object' && pDC.r !== undefined) docInstance.setDrawColor(pDC.r, pDC.g, pDC.b); else docInstance.setDrawColor(pDC);
                    if (typeof pFC === 'object' && pFC.r !== undefined) docInstance.setFillColor(pFC.r, pFC.g, pFC.b); else docInstance.setFillColor(pFC);
                    docInstance.setFont(pFont.fontName, pFont.fontStyle);
                    docInstance.setFontSize(pFS);
                    if (typeof pTC === 'object' && pTC.r !== undefined) docInstance.setTextColor(pTC.r, pTC.g, pTC.b); else docInstance.setTextColor(pTC);
                }
            }
        });
        // currentDocY is automatically updated by autoTable via doc.lastAutoTable.finalY for the next iteration
    });
    doc.save(`${userInputListName}.pdf`);
}

function determineTablesToExport() {
    if (currentBlindMode === 'threeTrack') {
        return threeTrackIsIdentical ? ['A'] : ['A', 'B', 'C'].filter(setId => tableSettings[setId]);
    } else if (currentBlindMode === 'manual') {
        let tables = ['A', 'B', 'C'];
        if (isSideBlindSplit) tables.push('D');
        if (isFrontRearSeparate) tables.push('E');
        return tables.filter(setId => tableSettings[setId] && tableSettings[setId].isVisibleInSmartManual);
    } else { // Smart mode
        return ['A', 'B', 'C'].filter(setId => tableSettings[setId] && tableSettings[setId].isVisibleInSmartManual);
    }
}

function isTableEffectivelyEmpty(setId) {
    if (!tableSettings[setId]) return true;
    const mainDataEmpty = !tableSettings[setId].data || tableSettings[setId].data.length === 0;
    if (currentBlindMode === 'smart') {
        const insertsDataEmpty = !tableSettings[setId].insertsData || tableSettings[setId].insertsData.length === 0;
        return mainDataEmpty && (!tableSettings[setId].hasInserts || insertsDataEmpty);
    }
    return mainDataEmpty;
}

function importFromBLIND(event) {
    const file = event.target.files[0];
    if (!file) return;
    if (!confirm("Importing this .blind file will overwrite current data. Proceed?")) {
        event.target.value = null; // Clear the file input if user cancels
        return;
    }

    const reader = new FileReader();
    reader.onload = function(e) {
        const fileContent = e.target.result;
        try {
            const lines = fileContent.split(/\r\n|\n/);
            const tempImportedTableVisibility = {}; // To store visibility from file

            // Moved function definition to the top of the onload scope
            // And corrected its name to match the calls
            function processImportLineAsTableTitle(line, mode, sideSplit, frontRearSplit) {
                let tempSetId = Object.keys(originalTableAppearances).find(k => originalTableAppearances[k].title === line || (originalTableAppearances[k].altTitle && originalTableAppearances[k].altTitle === line)) ||
                                Object.keys(threeTrackAppearances).find(k => threeTrackAppearances[k].title === line) ||
                                (line === threeTrackIdenticalAppearance.title ? 'A' : null);

                if (!tempSetId) return null;

                let newCurrentParsingSetId = null;
                if (mode === 'threeTrack') {
                    newCurrentParsingSetId = ((threeTrackIdenticalAppearance.title === line && tempSetId === 'A') || (threeTrackAppearances[tempSetId] && threeTrackAppearances[tempSetId].title === line)) ? tempSetId : null;
                } else if (mode === 'manual') {
                    if (tempSetId === 'A') newCurrentParsingSetId = (frontRearSplit && line === originalTableAppearances.A.altTitle) || (!frontRearSplit && line === originalTableAppearances.A.title) ? 'A' : null;
                    else if (tempSetId === 'B' && line === originalTableAppearances.B.title) newCurrentParsingSetId = 'B';
                    else if (tempSetId === 'C') newCurrentParsingSetId = (sideSplit && line === originalTableAppearances.C.altTitle) || (!sideSplit && line === originalTableAppearances.C.title) ? 'C' : null;
                    else if (tempSetId === 'D' && sideSplit && line === originalTableAppearances.D.title) newCurrentParsingSetId = 'D';
                    else if (tempSetId === 'E' && frontRearSplit && line === originalTableAppearances.E.title) newCurrentParsingSetId = 'E';
                } else if (mode === 'smart') {
                    newCurrentParsingSetId = (tempSetId === 'A' || tempSetId === 'B' || tempSetId === 'C') && originalTableAppearances[tempSetId] && line === originalTableAppearances[tempSetId].title ? tempSetId : null;
                }

                if (newCurrentParsingSetId) {
                    console.log(`Title matched: "${line}" to setId: ${newCurrentParsingSetId}`);
                } else {
                    console.warn(`Title "${line}" NOT matched for mode ${mode}, sideSplit ${sideSplit}, frontRearSplit ${frontRearSplit}`);
                }
                return newCurrentParsingSetId;
            }

            // Reset current table data before import
            ['A', 'B', 'C', 'D', 'E'].forEach(id => {
                if (tableSettings[id]) {
                    tableSettings[id].data = [];
                    tableSettings[id].insertsData = [];
                    tableSettings[id].hasInserts = false;
                    // Default visibility, will be overridden if specified in file
                    tableSettings[id].isVisibleInSmartManual = (id !== 'D' && id !== 'E');
                }
            });

            let importedIsSideBlindSplit = false;
            let importedIsFrontRearSeparate = false;
            let parsedListName = "";
            let parsedBlindMode = "";
            let parsedThreeTrackIdentical = null; // null indicates not yet parsed
            let foundListName = false;
            let foundBlindType = false;
            let currentParsingSetId = null;
            let parsingState = 'expectListName';
            let parsingSmartInserts = false;

            console.log("--- Starting .blind file import ---");

            lines.forEach((lineText, lineIdx) => {
                const line = lineText.trim();
                // Allow empty lines within data sections, but not between metadata blocks typically
                if (!line && lineIdx !== lines.length - 1 && parsingState !== 'expectDataRows' && parsingState !== 'expectTableTitle') return;

                console.log(`L${lineIdx + 1} [State: ${parsingState}] Line: "${line}" (CurrentSetId: ${currentParsingSetId})`);

                if (parsingState === 'expectListName') {
                    if (line.startsWith("List Name:")) {
                        parsedListName = line.substring("List Name:".length).trim();
                        foundListName = true;
                        parsingState = 'expectBlindType';
                    } else if (line) { console.warn("Expected 'List Name:' not found. Line:", line); }
                } else if (parsingState === 'expectBlindType') {
                    if (line.startsWith("Blind Type:")) {
                        const typeVal = line.substring("Blind Type:".length).trim().toLowerCase();
                        if (typeVal.includes("smart")) parsedBlindMode = "smart";
                        else if (typeVal.includes("manual")) parsedBlindMode = "manual";
                        else if (typeVal.includes("3 track")) parsedBlindMode = "threeTrack";
                        if (parsedBlindMode) foundBlindType = true;
                        parsingState = 'expectModeSettingsOrTableTitle'; // Next, look for mode-specific settings or jump to table title
                    } else if (line) { console.warn("Expected 'Blind Type:' not found. Line:", line); }
                } else if (parsingState === 'expectModeSettingsOrTableTitle') {
                    let consumedModeSetting = false;
                    if (parsedBlindMode === 'threeTrack' && line.startsWith("Tracks Identical:")) {
                        parsedThreeTrackIdentical = line.substring("Tracks Identical:".length).trim().toLowerCase() === 'yes';
                        consumedModeSetting = true;
                        parsingState = 'expectTableTitle'; // After this, only table titles for 3-track
                    } else if (parsedBlindMode === 'manual') {
                        if (line.startsWith("SideBlindSplit:")) {
                            importedIsSideBlindSplit = line.substring("SideBlindSplit:".length).trim().toLowerCase() === 'yes';
                            consumedModeSetting = true;
                            // Stay in this state, FrontRearSeparate might be next for manual
                        } else if (line.startsWith("FrontRearSeparate:")) {
                            importedIsFrontRearSeparate = line.substring("FrontRearSeparate:".length).trim().toLowerCase() === 'yes';
                            consumedModeSetting = true;
                            parsingState = 'expectTableTitle'; // After this, only table titles for manual
                        }
                    }

                    if (!consumedModeSetting) { // If no mode-specific setting was consumed, this line should be a table title or empty
                        parsingState = 'expectTableTitle'; // Advance state regardless
                        // Now, let the 'expectTableTitle' state handle the current line
                        const setIdFound = processImportLineAsTableTitle(line, parsedBlindMode, importedIsSideBlindSplit, importedIsFrontRearSeparate);
                        if (setIdFound) {
                            currentParsingSetId = setIdFound;
                            parsingState = 'expectInsertsAdded';
                            if (!tableSettings[currentParsingSetId]) tableSettings[currentParsingSetId] = { data: [], insertsData: [], hasInserts: false, isVisibleInSmartManual: true };
                        } else if (line) { // Only warn if the line was not empty and not a title
                            console.warn("Unexpected line after mode settings (expected table title or empty line):", line);
                        }
                    }
                } else if (parsingState === 'expectTableTitle') {
                    const setIdFound = processImportLineAsTableTitle(line, parsedBlindMode, importedIsSideBlindSplit, importedIsFrontRearSeparate);
                    if (setIdFound) {
                        currentParsingSetId = setIdFound;
                        parsingState = 'expectInsertsAdded';
                        if (!tableSettings[currentParsingSetId]) tableSettings[currentParsingSetId] = { data: [], insertsData: [], hasInserts: false, isVisibleInSmartManual: true };
                    } else if (line) { // Only warn if line is not empty and not a title
                        console.warn("Unexpected line, expected table title or empty line:", line);
                         // If we encounter unexpected non-empty lines here, it might be better to stop or revert to a known state.
                         // For now, it will just skip them and look for the next valid title.
                    }
                } else if (currentParsingSetId && tableSettings[currentParsingSetId]) { // Processing a specific table's content
                    if (parsingState === 'expectInsertsAdded' && line.startsWith("Inserts Added:")) {
                        tableSettings[currentParsingSetId].hasInserts = (line.substring("Inserts Added:".length).trim().toLowerCase() === 'yes');
                        parsingState = 'expectTableVisibleOrDataHeader';
                    } else if (parsingState === 'expectTableVisibleOrDataHeader') {
                        if ((parsedBlindMode === 'manual' || parsedBlindMode === 'smart') && line.startsWith("TableVisible:")) {
                            tempImportedTableVisibility[currentParsingSetId] = line.substring("TableVisible:".length).trim().toLowerCase() === 'yes';
                            parsingState = 'expectDataHeader'; // After TableVisible, we MUST expect the "No." header
                        } else if (line.toUpperCase().startsWith("NO.,")) { // Header for data rows
                            parsingState = 'expectDataRows';
                            parsingSmartInserts = false; // Reset for each new table data section
                            console.log(`Data header found for ${currentParsingSetId}.`);
                        } else if (line) {
                            console.warn(`Expected "TableVisible:" or "No.," for table ${currentParsingSetId} but found: "${line}". Resetting to expect new table title.`);
                            parsingState = 'expectTableTitle'; currentParsingSetId = null; parsingSmartInserts = false;
                        }
                    } else if (parsingState === 'expectDataHeader' && line.toUpperCase().startsWith("NO.,")) {
                         parsingState = 'expectDataRows';
                         parsingSmartInserts = false;
                         console.log(`Data header found for ${currentParsingSetId} after TableVisible.`);
                    } else if (parsingState === 'expectDataRows') {
                        if (line === SMART_INSERT_SEPARATOR_TEXT && parsedBlindMode === 'smart' && tableSettings[currentParsingSetId].hasInserts) {
                            parsingSmartInserts = true;
                        } else {
                            const parts = line.split(',');
                            const noValFromFile = parts.length > 0 ? parts[0].trim() : "";
                            // Join remaining parts for value, then replace escaped newlines
                            const itemValueFromFile = parts.length > 1 ? parts.slice(1).join(',').trim().replace(/\\n/g, '\n') : "";

                            if (parsedBlindMode === 'smart' && noValFromFile === SMART_DELIMITER_511_NUM && itemValueFromFile === SMART_DELIMITER_511_DISPLAY_TEXT) {
                                console.log(`End delimiter found for smart table ${currentParsingSetId}.`);
                                parsingState = 'expectTableTitle'; currentParsingSetId = null; parsingSmartInserts = false;
                            } else if (parsedBlindMode === 'smart' && noValFromFile === SMART_DELIMITER_0_NUM && itemValueFromFile === SMART_DELIMITER_0_DISPLAY_TEXT) {
                                // Smartblind start delimiter, just ignore
                            } else if (noValFromFile !== "" || itemValueFromFile !== "") { // Process if line has content
                                const newItem = { id: generateUUID(), value: itemValueFromFile, type: 'main' }; // Default to 'main'
                                if (parsedBlindMode === 'smart') {
                                    if (parsingSmartInserts) {
                                        tableSettings[currentParsingSetId].insertsData.push(newItem);
                                    } else {
                                        tableSettings[currentParsingSetId].data.push(newItem);
                                    }
                                } else { // Manual or 3 Track - parse insert types
                                    if (itemValueFromFile.toLowerCase().endsWith(" (insert)")) {
                                        newItem.value = itemValueFromFile.substring(0, itemValueFromFile.length - " (insert)".length).trim();
                                        newItem.type = 'insert';
                                        if (/^[A-Z]$/.test(noValFromFile)) newItem.insertSubtype = 'top';
                                        else if (/^\d+[A-Z]$/.test(noValFromFile)) { newItem.insertSubtype = 'middle'; newItem.parentMainItemNumber = parseInt(noValFromFile.match(/\d+/)[0], 10); }
                                        else if (/^\d+$/.test(noValFromFile)) newItem.insertSubtype = 'continuous_end'; // For inserts numbered like main items
                                        else newItem.insertSubtype = 'middle'; // Default insert subtype if not top or specific middle
                                    }
                                    tableSettings[currentParsingSetId].data.push(newItem); // All manual/3track items go into main .data array
                                }
                                console.log("Pushed item to:", currentParsingSetId, "SmartInserts:", parsingSmartInserts, "Item:", JSON.stringify(newItem));
                            } else if (line.trim() === "" && currentParsingSetId) { // Empty line typically ends a data section
                                console.log(`Empty line in data for ${currentParsingSetId}, moving to expect next TableTitle.`);
                                parsingState = 'expectTableTitle'; currentParsingSetId = null; parsingSmartInserts = false;
                            }
                        }
                    }
                } else if (line) { // Line has content but we are not in a state to process it, or currentParsingSetId is null
                    console.warn(`Unhandled line: "${line}" in global parsing state: ${parsingState} or no current table context.`);
                }
            }); // End lines.forEach

            console.log("--- Import Parsing Final Values ---");
            console.log("Parsed List Name:", parsedListName, "Mode:", parsedBlindMode, "3TIdentical:", parsedThreeTrackIdentical, "SideSplit:", importedIsSideBlindSplit, "FrontRearSeparate:", importedIsFrontRearSeparate);
            ['A','B','C','D','E'].forEach(s => console.log(`Table ${s} settings:`, tableSettings[s] ? `Data: ${tableSettings[s].data.length}, Inserts: ${tableSettings[s].insertsData.length}, HasInserts: ${tableSettings[s].hasInserts}, Visible: ${tableSettings[s].isVisibleInSmartManual}` : 'N/A'));

            if (!foundListName || !foundBlindType) {
                throw new Error("Essential metadata (List Name or Blind Type) missing or invalid in the imported file. Import cannot proceed.");
            }

            // --- Apply Parsed State to Application ---
            document.getElementById('listNameInput').value = parsedListName;
            // currentBlindMode is already set by the parser if foundBlindType is true.

            if (parsedBlindMode === 'threeTrack') {
                threeTrackIsIdentical = parsedThreeTrackIdentical !== null ? parsedThreeTrackIdentical : true; // Default to true if not specified
            }
            if (parsedBlindMode === 'manual') {
                isSideBlindSplit = importedIsSideBlindSplit;
                isFrontRearSeparate = importedIsFrontRearSeparate;
            } else { // Reset for smart or if switching away from manual
                isSideBlindSplit = false;
                isFrontRearSeparate = false;
            }

            // Update the UI to reflect the new mode and its settings.
            // Pass `true` to skip default data initialization and initial rendering within updateBlindMode.
            updateBlindMode(parsedBlindMode, true);

            // Explicitly set the radio button for the mode
            const modeRadio = document.querySelector(`input[name="blindMode"][value="${parsedBlindMode}"]`);
            if (modeRadio) modeRadio.checked = true;

            // Explicitly set checkboxes for mode-specific controls based on parsed values
            if (parsedBlindMode === 'threeTrack') {
                const tiCheckbox = document.getElementById('threeTrackIdentical');
                if (tiCheckbox) tiCheckbox.checked = threeTrackIsIdentical;
            }
            if (parsedBlindMode === 'manual') {
                const sbsCheckbox = document.getElementById('isSideBlindSplitCheckbox');
                if (sbsCheckbox) sbsCheckbox.checked = isSideBlindSplit;
                const frsCheckbox = document.getElementById('isFrontRearSeparateCheckbox');
                if (frsCheckbox) frsCheckbox.checked = isFrontRearSeparate;
            }

            // Apply parsed table-specific settings (hasInserts, isVisibleInSmartManual)
            ['A', 'B', 'C', 'D', 'E'].forEach(setId => {
                if (tableSettings[setId]) {
                    const hasInsertsCheckbox = document.getElementById(`hasInserts${setId}`);
                    if (hasInsertsCheckbox) hasInsertsCheckbox.checked = tableSettings[setId].hasInserts;

                    // Set isVisibleInSmartManual based on imported value or sensible defaults
                    if (tempImportedTableVisibility.hasOwnProperty(setId)) {
                        tableSettings[setId].isVisibleInSmartManual = tempImportedTableVisibility[setId];
                    } else { // Default visibility logic if 'TableVisible:' line was missing from file
                        if (parsedBlindMode === 'manual') {
                            if (setId === 'D') tableSettings[setId].isVisibleInSmartManual = importedIsSideBlindSplit && (tableSettings[setId].data.length > 0 || (tableSettings[setId].hasInserts && tableSettings[setId].insertsData.length > 0));
                            else if (setId === 'E') tableSettings[setId].isVisibleInSmartManual = importedIsFrontRearSeparate && (tableSettings[setId].data.length > 0 || (tableSettings[setId].hasInserts && tableSettings[setId].insertsData.length > 0));
                            else tableSettings[setId].isVisibleInSmartManual = (setId !== 'D' && setId !== 'E'); // A,B,C default true for manual
                        } else if (parsedBlindMode === 'smart') {
                            tableSettings[setId].isVisibleInSmartManual = (setId !== 'D' && setId !== 'E'); // A,B,C default true for smart
                        } else { // threeTrack
                            tableSettings[setId].isVisibleInSmartManual = (setId !== 'D' && setId !== 'E'); // D & E not used in 3-track
                        }
                    }
                    const showTableCheckbox = document.getElementById(`showTable${setId}`);
                    if (showTableCheckbox) showTableCheckbox.checked = tableSettings[setId].isVisibleInSmartManual;

                    // Update insert UI based on parsed hasInserts state
                    handleInsertToggle(setId, tableSettings[setId].hasInserts, true); // true for calledDuringSync
                }
            });

            // After individual states are set, call higher-level UI refreshers
            // These functions also handle visibility of table containers based on global state.
            if (parsedBlindMode === 'threeTrack') {
                handleThreeTrackIdenticalToggle(threeTrackIsIdentical);
            } else if (parsedBlindMode === 'manual') {
                handleSideBlindSplitToggle(isSideBlindSplit);
                handleFrontRearSeparateToggle(isFrontRearSeparate);
            }

            // Final pass: update all table appearances (titles, headers) and render visible tables.
            updateTableAppearances();
            ['A', 'B', 'C', 'D', 'E'].forEach(setId => {
                if (tableSettings[setId]) {
                    // Check if the table *container* is supposed to be visible
                    const tableContainer = document.getElementById(`table-container-${setId}`);
                    let shouldBeVisible = false;
                    if (parsedBlindMode === 'threeTrack') {
                        if (setId === 'A') shouldBeVisible = true;
                        else if (setId === 'B' || setId === 'C') shouldBeVisible = !threeTrackIsIdentical;
                    } else if (parsedBlindMode === 'manual') {
                        if (setId === 'D') shouldBeVisible = isSideBlindSplit && tableSettings[setId].isVisibleInSmartManual;
                        else if (setId === 'E') shouldBeVisible = isFrontRearSeparate && tableSettings[setId].isVisibleInSmartManual;
                        else shouldBeVisible = tableSettings[setId].isVisibleInSmartManual; // For A, B, C
                    } else { // Smart Mode
                         shouldBeVisible = (setId !== 'D' && setId !== 'E') && tableSettings[setId].isVisibleInSmartManual;
                    }

                    if (tableContainer) tableContainer.style.display = shouldBeVisible ? 'block' : 'none';

                    if (shouldBeVisible) {
                        renderTable(setId); // This will also initialize sortables
                    } else { // If table is not visible, ensure its body is empty
                        const tableBodyClear = document.getElementById(`table-body-${setId}`); if(tableBodyClear) tableBodyClear.innerHTML = '';
                        const insertsTableBodyClear = document.getElementById(`table-body-inserts-${setId}`); if(insertsTableBodyClear) insertsTableBodyClear.innerHTML = '';
                    }
                }
            });

            alert(".blind file data imported successfully!");
            saveStateToSessionStorage();

        } catch (error) {
            console.error("Import Error:", error);
            alert("Import failed: " + error.message + "\nPlease ensure the file is a valid .blind file and try again. The application will attempt to revert to its previous state.");
            // Attempt to revert to a known good state by reloading from session storage.
            // This is a simple revert; a more robust one would deep-copy state before import.
            loadStateFromSessionStorage(); // Reload previous valid state
            updateBlindMode(currentBlindMode, false); // Re-render based on (potentially reverted) currentBlindMode
            // The above calls should refresh the UI to the pre-import state.
        } finally {
            event.target.value = null; // Clear the file input in all cases
        }
    };
    reader.onerror = function() {
        alert("Could not read file. Please ensure the file is accessible and not corrupted.");
        event.target.value = null;
    };
    reader.readAsText(file);
}
</script>
</body>
</html>
