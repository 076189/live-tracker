<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMSI Countdown - Tools</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <link rel="manifest" href="/live-tracker/manifest-omsi.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OMSI Tools">
    <meta name="theme-color" content="#2c3e50">
    <link rel="apple-touch-icon" href="/live-tracker/assets/icons/apple-touch-icon-180x180.png">

    <style>
        @font-face {
            font-family: 'NJFont Medium Web';
            src: url('fonts/NJFont-Medium.ttf') format('truetype'); /* Relative path */
            font-weight: normal;font-style: normal;font-display: swap;
        }
        body {
            font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            margin:0;
        }
        .page-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        #top-menu-bar {
            background-color: rgba(0,0,0,0.25);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center;
            display: none; /* Hidden by default, shown after login */
        }
        .menu-button {
            cursor: pointer;
            background-color: #3498db;
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 0.25rem;
            font-size: 0.9rem;
            transition: background-color 0.2s;
            border: none;
            margin: 0.25rem;
        }
        .menu-button:hover {
            background-color: #2980b9;
        }

        .tool-content-section {
            display: none; /* All tool sections hidden by default */
        }

        #auth-section {
             margin-bottom: 1.5rem;
        }
        #current-profile-display-container {
            text-align: center;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background-color: rgba(255,255,255,0.05);
            border-radius: 0.25rem;
            display: none; /* Hidden by default, shown after login */
        }
        #current-profile-display { font-size: 0.9rem; opacity: 0.9; font-style: italic;}


        h1 { font-size: 2rem; margin-bottom: 1.5rem; font-weight: normal; text-align: center; color: #ffffff; }
        h2 { font-size: 1.5rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: normal; border-bottom: 1px solid #7f8c8d; padding-bottom: 0.25rem;}
        h3.subsection-title { font-size: 1.25rem; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: normal; color: #e0e0e0; border-bottom: 1px solid rgba(127,140,141,0.5); padding-bottom: 0.2rem;}


        .section {
            background-color: rgba(0,0,0,0.15);
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .subsection {
            background-color: rgba(0,0,0,0.1);
            padding: 1rem;
            border-radius: 0.375rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
             border: 1px solid rgba(127,140,141,0.2);
        }


        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;}

        label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.85rem;
            color: #bdc3c7;
        }

        input[type="text"],
        input[type="email"],
        input[type="password"],
        input[type="time"],
        input[type="color"],
        input[type="number"],
        select {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size:0.9rem;
        }
        input[type="color"] { height: 2.75rem; padding: 0.25rem; }
        #inputOperatingProfile, #analyticsOperatingProfileSelect { max-width: 100%;}
        #selectDayOffset, #selectRouteNameColour, #selectStopForDeparturesView { max-width: 100%; }
        #editMasterStopIdSelect, #routesForStopSelect_SM { max-width: 100%; }
        #selectNewStopIdFormat_ARS, #selectStopToRemove_ARS {max-width: 100%;} 
        select option { background-color: #34495e; color: #ecf0f1; }


        #inputStopID, 
        #bulkEditTargetStopID, #bulkEditTargetLineName,
        #findStopIdScheduleInput, #replaceStopIdScheduleInput, 
        #gen_stopId, #inputNewStopId_ARS {
            text-transform: uppercase; 
        }
        #gen_lineName, #gen_destinationName { 
            text-transform: none;
        }


        .button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin-right: 0.5rem; margin-top:0.5rem;
        }
        .button:hover { background-color: #2980b9; }
        .button.small-action { padding: 0.2rem 0.4rem; font-size: 0.8rem; margin: 0 0.15rem; line-height: 1; min-width: 20px; text-align:center;}
        .button.secondary { background-color: #e74c3c; }
        .button.secondary:hover { background-color: #c0392b; }
        .button.tertiary { background-color: #f39c12; }
        .button.tertiary:hover { background-color: #e67e22; }
        .button.neutral { background-color: #7f8c8d; }
        .button.neutral:hover { background-color: #95a5a6; color: #2c3e50; }


        .file-upload-label { display: inline-block; cursor: pointer; background-color: #95a5a6; color: #2c3e50; padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem; transition: background-color 0.2s; margin-bottom: 0.5rem; }
        .file-upload-label:hover { background-color: #7f8c8d; }
        #file-status { font-size: 0.9rem; margin-top: 0.25rem; margin-bottom:1rem; opacity: 0.9; min-height: 1.2em; }

        .actions-section { margin-top: 1.5rem; }
        #stageScheduleButton { background-color: #27ae60; }
        #stagingStatusMessage { text-align:center; margin-bottom: 1rem; font-size: 0.9em; color: #f1c40f; min-height:1.2em; }


        .info-section { margin-top:2rem; padding:1rem; background-color: rgba(0,0,0,0.1); border-radius:0.25rem; font-size:0.8rem; }
        .info-section h3 { font-size:1rem; margin-bottom:0.5rem; color: #ffffff; }
        .info-section p { line-height:1.6; color:#bdc3c7; }

        .tooltip { position: relative; display: inline-block; cursor: help; margin-left: 4px; font-size:0.8em; background-color:#7f8c8d; color:white; border-radius:50%; width:14px; height:14px; text-align:center; line-height:14px;}
        .tooltip .tooltiptext {
            visibility: hidden; width: 280px; background-color: #34495e; color: #fff;
            text-align: left; border-radius: 6px; padding: 8px; position: absolute;
            z-index: 10; bottom: 135%; left: 50%; margin-left: -140px; opacity: 0; transition: opacity 0.3s;
            font-size: 0.75rem; line-height: 1.4; border: 1px solid #7f8c8d;
        }
        .tooltip .tooltiptext::after {
            content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px;
            border-width: 5px; border-style: solid; border-color: #34495e transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .filter-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; margin-bottom: 1rem; align-items: end;}

        .current-details-display {
            margin-top: 0.5rem;
            font-size: 0.85em;
            background-color: rgba(0,0,0,0.2);
            padding: 0.5rem;
            border-radius: 0.25rem;
            color: #bdc3c7;
        }
        .current-details-display p { margin: 0.2rem 0; }
        .current-details-display span { font-style: italic; color: #ecf0f1; }

        .event-section div, .stop-status-section div, .route-colour-management-subsection div,
        .view-stop-departures div, .analytics-subsection div {
            margin-bottom: 0.75rem;
        }
        .event-section label, .stop-status-section label, .route-colour-management-subsection label,
        .view-stop-departures label, .analytics-subsection label {
             margin-bottom: 0.25rem;
        }


        #currentRouteColoursListContainer, #duplicateEntriesResults {
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            padding: 0.75rem;
            margin-top: 1rem;
            max-height: 300px;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.05);
        }
        #currentRouteColoursList li, #duplicateEntriesResults li {
            display: block;
            padding: 0.5rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #currentRouteColoursList li:last-child, #duplicateEntriesResults li:last-child { border-bottom: none; }

        #duplicateEntriesResults .duplicate-set { margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 1px dashed #4A5568;}
        #duplicateEntriesResults .duplicate-set:last-child { border-bottom: none; }
        #duplicateEntriesResults .entry-detail { display: block; font-size: 0.85rem; margin-left: 1rem; opacity: 0.9;}


        .colour-preview-box {
            width: 20px;
            height: 20px;
            border: 1px solid #ecf0f1;
            margin-right: 10px;
            display: inline-block;
            vertical-align: middle;
        }
        #currentRouteColoursList .route-info { flex-grow: 1; }

        .route-tile-tools-list {
            display: inline-block;
            padding: 0.2em 0.55em;
            margin-right: 0.3em;
            margin-bottom: 0.3em;
            border-radius: 0.25rem;
            font-size: 0.8em;
            font-weight: bold;
            color: white;
            text-align: center;
            line-height: 1.3;
            min-width: 28px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.25);
            vertical-align: middle;
        }
        #stopDeparturesList li {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.1rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #stopDeparturesList li:last-child {
            border-bottom: none;
        }

        #masterStopListUL_SM li {
            padding: 0.6rem 0.5rem;
            border-bottom: 1px solid #34495e;
            transition: background-color 0.15s ease-in-out;
        }
        #masterStopListUL_SM li:last-child {
            border-bottom: none;
        }
        #masterStopListUL_SM li .stop-id-master { font-weight: bold; color: #ecf0f1;}
        #masterStopListUL_SM li .stop-name-master { color: #bdc3c7; }
        #masterStopListUL_SM li .stop-direction-master { font-style: italic; font-size: 0.85em; color: #95a5a6; }

        #routesServingStopListContainer_SM {
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.05);
            padding:0.75rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
        }
        #routesServingStopList_SM {
            list-style: none;
            padding: 0;
            margin:0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5em;
        }
        #routesServingStopList_SM li {
            padding: 0;
            border-bottom: none;
        }

        /* Styles for the Schedule Generator section */
        #schedule-generator-section h2,
        #schedule-generator-section h3.subsection-title, 
        #schedule-generator-section h4 { 
            color: #ecf0f1;
            border-bottom-color: #4A5568;
        }

        #schedule-generator-section label {
            display: block; 
            color: #bdc3c7;
            margin-top: 10px; 
            margin-bottom: 0.35rem; 
            font-weight: 500; 
            font-size: 0.85rem; 
        }

        .schedule-generator-select {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size: 0.9rem;
            margin-bottom: 0.25rem; 
        }
        .schedule-generator-select option {
            background-color: #34495e; 
            color: #ecf0f1;
        }

        .schedule-generator-input {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size: 0.9rem;
        }
        #gen_stopId.schedule-generator-input { 
             text-transform: uppercase;
        }
        #gen_lineName.schedule-generator-input, 
        #gen_destinationName.schedule-generator-input {
            text-transform: none; 
        }


        .gen_interval-rule {
            border: 1px solid #4A5568;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 0.375rem;
            background-color: rgba(0,0,0,0.1);
        }

        .gen_input-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .form-field-group {
            margin-bottom: 1rem;
        }


        .gen_stop-id-group {
            display: flex;
            flex-wrap: wrap;
            align-items: flex-end; 
            gap: 0.75rem;
            margin-bottom: 1rem; 
        }
        .gen_stop-id-group > input[type="text"],
        .gen_stop-id-group > .schedule-generator-input { 
            flex-grow: 1;
            margin-bottom:0; 
        }
        .gen_stop-id-group > select,
        .gen_stop-id-group > .schedule-generator-select { 
            width: auto; 
            min-width:180px; 
            margin-bottom:0;
        }
        .gen_stop-id-group > button {
            margin-top: 0; 
            margin-bottom:0;
        }

        #gen_resultsTable {
            width: 100%;
            margin-top: 1.5rem;
            border-collapse: collapse;
            color: #ecf0f1;
        }
        #gen_resultsTable th, #gen_resultsTable td {
            border: 1px solid #4A5568;
            padding: 8px 10px;
            text-align: left;
        }
        #gen_resultsTable th {
            background-color: #34495e;
            color: white;
            font-weight: 500;
        }
        #gen_resultsTable tbody tr:nth-child(odd) {
            background-color: rgba(0,0,0,0.1);
        }
         #gen_resultsTable tbody tr:nth-child(even) {
            background-color: rgba(0,0,0,0.2);
        }

        .gen_action-buttons {
            margin-top: 1.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }
        .gen_footer-note {
            text-align: center;
            margin-top: 1.5rem;
            font-size: 0.85em;
            color: #bdc3c7;
        }

        /* Styles for Add/Remove Stop section */
        #newStopIdAvailability_ARS { 
            font-size: 0.8em;
            min-height: 1.1em; 
            margin-top: 0.25rem;
        }


    </style>
</head>
<body lang="en-GB">
    <div class="page-container">
        <h1>Bus Schedule Setup & Management</h1>

        <div id="auth-section" class="section">
            <h2>Admin Login</h2>
            <div id="login-form-container">
                <form id="adminLoginForm">
                    <div class="form-grid" style="grid-template-columns: 1fr;">
                        <div><label for="inputEmail">Email</label><input type="email" id="inputEmail" autocomplete="email"></div>
                        <div><label for="inputPassword">Password</label><input type="password" id="inputPassword" autocomplete="current-password"></div>
                    </div>
                    <button id="loginButton" type="submit" class="button">Login</button>
                </form>
                <p id="auth-status" style="margin-top: 0.5em; color: #f1c40f;"></p>
            </div>
            <div id="logout-container" style="display:none;">
                <p>Logged in as: <span id="loggedInUserEmail"></span></p>
                <button id="logoutButton" class="button secondary">Logout</button>
            </div>
        </div>

        <div id="current-profile-display-container" class="section">
            <p id="current-profile-display">Today's Auto Profile: (determining...)</p>
        </div>

        <div id="top-menu-bar">
            <div id="main-menu-buttons">
                <button class="menu-button" data-section="bulk-edit-tools-section">Bulk Edit & Colours</button>
                <button class="menu-button" data-section="event-generator-section">Event Generator</button>
                <button class="menu-button" data-section="stop-status-section">Stop Status</button>
                <button class="menu-button" data-section="view-departures-section">View Departures</button>
                <button class="menu-button" data-section="schedule-generator-section">Schedule Generator</button>
                <button class="menu-button" data-section="deployment-tools-section">Deployment & Upload</button>
                <button class="menu-button" data-section="analytics-validation-section">Analytics & Validation</button>
                <button class="menu-button" data-section="stop-management-tool-section">Stop Management</button>
                <button class="menu-button" data-section="add-remove-stop-section">Add/Remove Stop</button>
            </div>
        </div>

        <div id="tool-sections-wrapper">
            <div id="bulk-edit-tools-section" class="tool-content-section">
                <div class="section bulk-edit-stop-details-section">
                    <h2>Update Stop Name & Direction by Stop ID</h2>
                    <div class="form-grid" style="grid-template-columns: 1fr; gap: 0.75rem;">
                        <div><label for="bulkEditTargetStopID">Target Stop ID</label><input type="text" id="bulkEditTargetStopID" placeholder="Enter Stop ID" autocomplete="off"></div>
                        <div class="current-details-display"><p><strong>Current Name:</strong> <span id="currentBulkEditStopNameDisplay">-</span></p><p><strong>Current Direction:</strong> <span id="currentBulkEditDirectionDisplay">-</span></p></div>
                        <div><label for="bulkEditNewStopName">New Stop Name</label><input type="text" id="bulkEditNewStopName" placeholder="New stop name" autocomplete="off"></div>
                        <div><label for="bulkEditNewDirection">New "Towards" Text</label><input type="text" id="bulkEditNewDirection" placeholder="New direction" autocomplete="off"></div>
                        <div style="margin-top: 0.5rem;"><button id="bulkUpdateDetailsButton" class="button">Update Stop Details</button></div>
                    </div>
                </div>
                <div class="section bulk-edit-route-destination">
                    <h2>Update Destination for a Route</h2>
                    <div class="form-grid" style="grid-template-columns: 1fr 1.5fr 1.5fr auto; align-items:end; gap: 0.75rem;">
                        <div><label for="bulkEditTargetLineName">Target Line</label><input type="text" id="bulkEditTargetLineName" placeholder="e.g., 186" autocomplete="off"></div>
                        <div><label for="bulkEditOldDestination">Old Destination (optional)</label><input type="text" id="bulkEditOldDestination" placeholder="Blank to update all" autocomplete="off"></div>
                        <div><label for="bulkEditNewDestination">New Destination</label><input type="text" id="bulkEditNewDestination" placeholder="New destination" autocomplete="off"></div>
                        <div style="padding-bottom:0.05rem;"><button id="bulkUpdateRouteDestinationButton" class="button">Update Destination</button></div>
                    </div>
                </div>
                <div class="section route-colour-management-subsection">
                    <h2>Route Tile Colour Management</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">Define custom colours for routes on the arrivals board.</p>
                    <div class="form-grid" style="grid-template-columns: 1.5fr 1fr auto; align-items: end; gap: 0.75rem;">
                        <div><label for="selectRouteNameColour">Route Name</label><select id="selectRouteNameColour"><option value="">-- Select Route --</option></select></div>
                        <div><label for="inputRouteColour">Select Colour</label><input type="color" id="inputRouteColour" value="#73809C" autocomplete="off"></div>
                        <div style="padding-bottom:0.05rem;"><button id="saveRouteColourButton" class="button">Save Colour</button></div>
                    </div>
                    <div id="currentRouteColoursListContainer"><h3 class="subsection-title" style="font-size: 1.1rem; margin-bottom: 0.5rem;">Current Custom Colours</h3><ul id="currentRouteColoursList"></ul><p id="noCustomColoursMessage">No custom colours set.</p></div>
                    <p id="routeColourStatusMessage" style="min-height:1.2em;"></p>
                </div>
            </div>

            <div id="event-generator-section" class="tool-content-section">
                 <div class="section random-event-generator">
                    <h2>Random Event Generator (Simulated)</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        This tool simulates events by logging them. It does not alter the working schedule.
                        Customize predefined events in the script for specific scenarios.
                    </p>
                    <div class="form-grid event-section" style="grid-template-columns: 1.5fr 1.5fr auto; align-items:end;">
                        <div><label for="selectEventRoute">Route</label><select id="selectEventRoute"><option value="">-- Select Route --</option></select></div>
                        <div><label for="selectEventImpactStop">Impact From Stop (Optional for some events)</label><select id="selectEventImpactStop"><option value="">-- Route Wide / Not Applicable --</option></select></div>
                        <div style="padding-bottom:0.05rem;"><button id="triggerEventButton" class="button tertiary">Trigger Simulated Event</button></div>
                    </div>
                    <p id="eventStatusMessage" style="min-height:1.2em; background-color: rgba(0,0,0,0.1); padding: 0.5em; border-radius: 0.25rem;"></p>
                </div>
            </div>

            <div id="stop-status-section" class="tool-content-section">
                <div class="section stop-status-section">
                    <h2>Manage Bus Stop Status (Live)</h2>
                    <div class="form-grid stop-status-section" style="grid-template-columns: 2fr auto auto; align-items:end;">
                        <div><label for="selectStopForStatusChange">Stop</label><select id="selectStopForStatusChange"><option value="">-- Select Stop --</option></select></div>
                        <div style="padding-bottom:0.05rem;"><button id="closeStopButton" class="button secondary">Close Stop</button></div>
                        <div style="padding-bottom:0.05rem;"><button id="reopenStopButton" class="button" style="background-color: #2ecc71;">Reopen Stop</button></div>
                    </div>
                    <p id="stopStatusMessage" style="min-height:1.2em;"></p>
                </div>
            </div>

            <div id="view-departures-section" class="tool-content-section">
                <div class="section view-stop-departures">
                    <h2>View Scheduled Departures by Stop</h2>
                    <div class="form-grid" style="grid-template-columns: 1fr 2fr; align-items: start; gap: 1.5rem;">
                        <div><label for="selectStopForDeparturesView">Bus Stop</label><select id="selectStopForDeparturesView"><option value="">-- Select Stop --</option></select></div>
                        <div><label>Departures (Sorted by Day Offset -> Profile Day -> Time)</label><div id="stopDeparturesListContainer" style="max-height: 400px; overflow-y: auto; border: 1px solid #4A5568; padding: 0.5rem; border-radius: 0.25rem;"><ul id="stopDeparturesList"></ul><p id="noDeparturesForStopMessage">Select stop to view.</p></div></div>
                    </div>
                </div>
            </div>
            
            <div id="schedule-generator-section" class="tool-content-section section">
                <h2>Transit Schedule Generator</h2>
                <p style="opacity:0.8; margin-bottom:1rem;">Create and export transit schedules in .COUNT format.</p>

                <div class="subsection">
                    <h3 class="subsection-title">Base Data (First Entry)</h3>

                    <div class="form-field-group">
                        <label for="gen_stopNameSelect">Select Stop:</label>
                        <select id="gen_stopNameSelect" class="schedule-generator-select">
                            <option value="">-- Loading Stops --</option>
                        </select>
                    </div>

                    <div class="form-field-group">
                        <label for="gen_stopId">StopID (auto-filled from selection):</label>
                        <div class="gen_stop-id-group">
                            <input type="text" id="gen_stopId" class="schedule-generator-input" placeholder="Select stop from list or suggest" readonly>
                            <select id="gen_stopIdPattern" class="schedule-generator-select" title="Select StopID pattern for suggestion">
                                <option value="Custom">Custom/Manual</option>
                                <option value="Numeric">Numeric (101-99999)</option>
                                <option value="BP">BP Series (BP1-BP99999)</option>
                                <option value="LE">LE Series (LE1-LE99999)</option>
                                <option value="RO">RO Series (RO1-RO99999)</option>
                            </select>
                            <button type="button" id="gen_suggestRandomStopIdButton" class="button neutral" style="padding: 0.5rem 0.8rem; white-space: nowrap;">Suggest ID</button>
                        </div>
                    </div>

                    <div class="gen_input-group">
                        <div>
                            <label for="gen_stopName">StopName (auto-filled from selection):</label>
                            <input type="text" id="gen_stopName" class="schedule-generator-input" placeholder="Select stop from list" readonly>
                        </div>
                        <div>
                            <label for="gen_direction">Direction (auto-filled from selection):</label>
                            <input type="text" id="gen_direction" class="schedule-generator-input" placeholder="Select stop from list" readonly>
                        </div>
                    </div>
                    
                    <div class="form-field-group">
                        <label for="gen_routeSelect">Select Existing Route (populates Line Name below):</label>
                        <select id="gen_routeSelect" class="schedule-generator-select">
                            <option value="">-- Select Existing Route --</option>
                        </select>
                    </div>
                     <div class="form-field-group">
                        <label for="gen_lineName">Line Name (Route - type new or select above):</label>
                        <input type="text" id="gen_lineName" class="schedule-generator-input" placeholder="e.g., 10A or NEW_ROUTE">
                    </div>

                    <div class="form-field-group">
                        <label for="gen_destinationSelect">Select Existing Destination (for chosen Line Name):</label>
                        <select id="gen_destinationSelect" class="schedule-generator-select">
                            <option value="">-- Enter/Select Route First --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label for="gen_destinationName">Destination Name (type new or select above):</label>
                        <input type="text" id="gen_destinationName" class="schedule-generator-input" placeholder="e.g., City Centre or NEW_DEST">
                    </div>


                    <div class="gen_input-group">
                        <div>
                            <label for="gen_operatingProfile">OperatingProfile:</label>
                            <input type="text" id="gen_operatingProfile" class="schedule-generator-input" placeholder="e.g., Weekday">
                        </div>
                        <div>
                            <label for="gen_initialScheduledTime">ScheduledTime (HHMM):</label>
                            <input type="text" id="gen_initialScheduledTime" class="schedule-generator-input" placeholder="e.g., 0845">
                        </div>
                        <div>
                            <label for="gen_initialDayOffset">DayOffset:</label>
                            <input type="number" id="gen_initialDayOffset" class="schedule-generator-input" min="0" value="0" placeholder="0">
                        </div>
                    </div>
                </div>


                <div class="subsection"> 
                    <h3 class="subsection-title">Interval Definitions for Additional Entries</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.5rem;">
                        <strong>DayOffset Logic for Generated Times:</strong><br>
                        - If an interval rule starts <em>before</em> midnight (e.g., at 22:00) and generates times that cross into the 00:00-03:59 window, those specific post-midnight times get <code>DayOffset = 1</code>.<br>
                        - If an interval rule itself starts <em>at or after</em> midnight (e.g., "00:15", "01:00", up to "03:59"), all times it generates get <code>DayOffset = 0</code>.<br>
                        - All other generated times get <code>DayOffset = 0</code>.
                    </p>
                    <div id="gen_intervalRulesContainer">
                        </div>
                    <button id="gen_addIntervalRuleButton" class="button" style="margin-top:10px;">+ Add Interval Rule</button>
                </div>

                <div class="subsection">
                    <div class="gen_action-buttons">
                        <button id="gen_generateScheduleButton" class="button">Generate Schedule</button>
                        <button id="gen_exportToCountButton" class="button" style="background-color: #27ae60;">Export to .COUNT</button>
                        <button id="gen_addToWorkingScheduleButton" class="button" style="background-color: #1abc9c;">Add Generated to Working Schedule</button>
                        <button id="gen_getWorkingScheduleButton" class="button" style="background-color: #9b59b6;">Load Full Schedule to Generator</button>
                        <button id="gen_clearAllDataButton" class="button secondary">Clear All Generator Data</button>
                    </div>
                    <h3 class="subsection-title" style="margin-top:1.5rem;">Generated Schedule / Loaded Data</h3>
                    <div style="max-height: 400px; overflow-y: auto;">
                        <table id="gen_resultsTable">
                             <thead>
                                <tr>
                                    <th>StopID</th>
                                    <th>StopName</th>
                                    <th>Direction</th>
                                    <th>LineName</th>
                                    <th>DestinationName</th>
                                    <th>ScheduledTime (HH:MM)</th>
                                    <th>OperatingProfile</th>
                                    <th>DayOffset</th>
                                    <th>Actions</th> 
                                </tr>
                            </thead>
                            <tbody>
                                </tbody>
                        </table>
                    </div>
                </div>
                <div class="gen_footer-note">
                    <p>Generator data is saved in your browser's local storage. It will persist unless you clear your browser's data or use the "Clear All Generator Data" button.</p>
                </div>
            </div>

            <div id="deployment-tools-section" class="tool-content-section">
                <div class="section count-file-upload">
                    <h2>Upload Full Schedule</h2>
                    <p style="font-size:0.8em; margin-bottom:0.5em;">Replaces current working schedule. Ensure file has correct headers: StopID, StopName, Direction, LineName, DestinationName, ScheduledTime, OperatingProfile, DayOffset (optional).</p>
                    <label for="count-file-input" class="file-upload-label">Choose .COUNT or .txt File</label>
                    <input type="file" id="count-file-input" accept=".COUNT,.txt" style="display: none;">
                    <p id="file-status">No file selected.</p>
                </div>
                <div class="actions-section section">
                    <h2>Schedule Deployment Actions</h2>
                    <div id="stagingStatusMessage" style="min-height:1.2em;">Checking status...</div>
                    <button id="stageScheduleButton" class="button">Stage Working Schedule</button>
                    <button id="applyNowButton" class="button tertiary">Apply Staged Live NOW</button>
                    <hr style="margin: 1.5rem 0; border-color: rgba(255,255,255,0.1);">
                    <button id="viewArrivalsButton" class="button">View Arrivals Board</button>
                </div>
            </div>

            <div id="analytics-validation-section" class="tool-content-section">
                <div class="section">
                    <h2>Schedule Analytics & Validation</h2>
                    <div class="subsection analytics-subsection">
                        <h3 class="subsection-title">Duplicate Entry Detection</h3>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <button id="detectDuplicatesButton" class="button">Find Duplicate Entries</button>
                            <button id="removeDuplicateEntriesButton" class="button secondary">Remove All Duplicates (Keep First)</button>
                        </div>
                        <p id="removeDuplicatesStatusMessage" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                        <div id="duplicateEntriesResults" style="margin-top: 0.75rem;">
                            <p>Click "Find Duplicate Entries" to scan the current working schedule.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div id="stop-management-tool-section" class="tool-content-section">
                <div class="section">
                    <h2>Master List of Unique Stops</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.75rem;">
                        This list is generated from the unique Stop IDs in the current working schedule.
                        It shows the last known name and direction for each unique Stop ID.
                    </p>
                    <div class="filter-controls" style="grid-template-columns: 1fr auto; gap: 0.75rem; margin-bottom: 0.5rem;">
                        <input type="text" id="masterStopListFilterInput_SM" placeholder="Filter by Stop ID, Name, or Direction...">
                        <button id="refreshMasterStopListButton_SM" class="button neutral">Refresh List</button>
                    </div>
                    <div id="masterStopListContainer_SM" class="subsection" style="max-height: 350px; overflow-y: auto; padding: 0.5rem; background-color: rgba(0,0,0,0.05);">
                        <ul id="masterStopListUL_SM" style="list-style: none; padding: 0;">
                            </ul>
                    </div>
                    <p id="masterStopListStatus_SM" style="text-align: center; margin-top: 0.5rem; min-height: 1.2em;">Click "Refresh List" to load stops.</p>
                </div>

                <div class="section">
                    <h2>Find and Replace Stop IDs in Working Schedule</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.75rem;">
                        This utility modifies the 'Working Schedule'. It changes all occurrences of an old Stop ID to a new Stop ID.
                        The Stop Name and Direction for entries with the new Stop ID will be updated based on the first found instance of the 'New Stop ID' in the schedule.
                    </p>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr auto; align-items: end; gap: 0.75rem;">
                        <div><label for="findStopIdScheduleInput_SM">Stop ID to Find in Schedule</label><input type="text" id="findStopIdScheduleInput_SM" placeholder="e.g., OLDSTOPID"></div>
                        <div><label for="replaceStopIdScheduleInput_SM">Replace with New Stop ID</label><input type="text" id="replaceStopIdScheduleInput_SM" placeholder="e.g., NEWSTOPID"></div>
                        <div style="padding-bottom:0.05rem;"><button id="findReplaceStopIdScheduleButton_SM" class="button tertiary">Execute Find & Replace</button></div>
                    </div>
                    <p id="findReplaceStatusMessage_SM" style="min-height: 1.2em; margin-top: 0.5rem;">-</p>
                </div>

                <div class="section">
                    <h2>Stop Information: Serving Routes</h2>
                    <div class="form-grid" style="grid-template-columns: 1fr auto; align-items: end; gap: 0.75rem;">
                        <div>
                            <label for="routesForStopSelect_SM">Select Stop ID to View Serving Routes</label>
                            <select id="routesForStopSelect_SM">
                                <option value="">-- Select Stop --</option>
                            </select>
                        </div>
                         <div style="padding-bottom:0.05rem;"><button id="refreshRoutesForStopSelectButton_SM" class="button neutral">Refresh Stop List</button></div>
                    </div>
                    <p id="routesServingStopStatus_SM" style="min-height: 1.2em; margin-top: 0.5rem;">Select a stop to see its serving routes.</p>
                    <div id="routesServingStopListContainer_SM">
                        <ul id="routesServingStopList_SM">
                            </ul>
                    </div>
                </div>
            </div>
            
            <div id="add-remove-stop-section" class="tool-content-section"> 
                <div class="section">
                    <h2>Add or Remove Stop Details</h2>
                    
                    <div class="subsection">
                        <h3 class="subsection-title">Add New Stop Details</h3>
                        <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                            Define a new stop. A placeholder schedule entry will be added to make it available in selectors.
                            The Stop ID must be unique.
                        </p>
                        <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                            <div> <label for="selectNewStopIdFormat_ARS">Stop ID Format/Prefix</label>
                                <div style="display: flex; align-items: flex-end; gap: 0.5rem;">
                                    <select id="selectNewStopIdFormat_ARS" class="schedule-generator-select" style="flex-grow: 1;">
                                        <option value="NUM">Numeric (e.g., 101-99999)</option>
                                        <option value="BP">BP Prefix (e.g., BP1-BP99999)</option>
                                        <option value="LE">LE Prefix (e.g., LE1-LE99999)</option>
                                        <option value="RO">RO Prefix (e.g., RO1-RO99999)</option>
                                    </select>
                                    <button id="buttonSuggestStopId_ARS" class="button neutral" style="padding: 0.5rem 0.8rem; margin-bottom: 0px; height: calc(0.5rem * 2 + 0.9rem + 2px); line-height: 0.9rem;">Suggest ID</button>
                                </div>
                            </div>
                            <div> <label for="inputNewStopId_ARS">New Stop ID (type or use suggest)</label>
                                <input type="text" id="inputNewStopId_ARS" class="schedule-generator-input" placeholder="e.g., NEWSTOP123" autocomplete="off">
                                <p id="newStopIdAvailability_ARS" style="font-size: 0.8em; min-height: 1.1em; margin-top: 0.25rem;"></p>
                            </div>
                            <div>
                                <label for="inputNewStopName_ARS">New Stop Name</label>
                                <input type="text" id="inputNewStopName_ARS" class="schedule-generator-input" placeholder="e.g., Main Street Library" autocomplete="off">
                            </div>
                            <div>
                                <label for="inputNewStopDirection_ARS">New Stop Direction (Towards)</label>
                                <input type="text" id="inputNewStopDirection_ARS" class="schedule-generator-input" placeholder="e.g., Town Centre" autocomplete="off">
                            </div>
                        </div>
                        <div style="margin-top: 1rem;">
                            <button id="buttonAddNewStop_ARS" class="button">Add New Stop Details</button>
                        </div>
                        <p id="addNewStopStatus_ARS" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                    </div>

                    <hr style="margin: 2rem 0; border-color: rgba(255,255,255,0.1);">

                    <div class="subsection">
                        <h3 class="subsection-title">Remove Stop & All Its Schedule Entries</h3>
                         <div class="form-field-group">
                            <label for="selectStopToRemove_ARS">Select Stop to Remove:</label>
                            <select id="selectStopToRemove_ARS" class="schedule-generator-select">
                                <option value="">-- Select Stop --</option>
                            </select>
                        </div>
                        <button id="buttonRemoveStop_ARS" class="button secondary">Remove Selected Stop & Its Schedule Entries</button>
                        <p id="removeStopStatus_ARS" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                    </div>

                </div>
            </div>
        </div> </div> <script type="module">
      // Firebase App initialization
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s", // Replace with your actual Firebase API Key
        authDomain: "omsi-c5505.firebaseapp.com", // Replace with your actual Firebase Auth Domain
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app", // Replace with your actual Firebase Database URL
        projectId: "omsi-c5505", // Replace with your actual Firebase Project ID
        storageBucket: "omsi-c5505.appspot.com", // Replace with your actual Firebase Storage Bucket
        messagingSenderId: "503595375440", // Replace with your actual Firebase Messaging Sender ID
        appId: "1:503595375440:web:356be6684b77ff5909ea55", // Replace with your actual Firebase App ID
        measurementId: "G-VN7X65V3F9" // Replace with your actual Firebase Measurement ID
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);

      window.firebaseOMSI = {
          database: database, auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut
      };
      console.log("Firebase Initialized for OMSI Tools.");
    </script>

    <script>
// --- DOM Elements ---
const countFileInput = document.getElementById('count-file-input');
const fileStatusElement = document.getElementById('file-status');
const currentProfileDisplayContainer = document.getElementById('current-profile-display-container');
const currentProfileDisplayElement = document.getElementById('current-profile-display');

const bulkEditTargetStopIDInput = document.getElementById('bulkEditTargetStopID');
const currentBulkEditStopNameDisplay = document.getElementById('currentBulkEditStopNameDisplay');
const currentBulkEditDirectionDisplay = document.getElementById('currentBulkEditDirectionDisplay');
const bulkEditNewStopNameInput = document.getElementById('bulkEditNewStopName');
const bulkEditNewDirectionInput = document.getElementById('bulkEditNewDirection');
const bulkUpdateDetailsButton = document.getElementById('bulkUpdateDetailsButton');
const bulkEditTargetLineNameInput = document.getElementById('bulkEditTargetLineName');
const bulkEditOldDestinationInput = document.getElementById('bulkEditOldDestination');
const bulkEditNewDestinationInput = document.getElementById('bulkEditNewDestination');
const bulkUpdateRouteDestinationButton = document.getElementById('bulkUpdateRouteDestinationButton');
const selectEventRoute = document.getElementById('selectEventRoute');
const selectEventImpactStop = document.getElementById('selectEventImpactStop');
const triggerEventButton = document.getElementById('triggerEventButton');
const eventStatusMessage = document.getElementById('eventStatusMessage');
const selectStopForStatusChange = document.getElementById('selectStopForStatusChange');
const closeStopButton = document.getElementById('closeStopButton');
const reopenStopButton = document.getElementById('reopenStopButton');
const stopStatusMessage = document.getElementById('stopStatusMessage');
const stageScheduleButton = document.getElementById('stageScheduleButton');
const applyNowButton = document.getElementById('applyNowButton');
const viewArrivalsButton = document.getElementById('viewArrivalsButton');
const stagingStatusMessage = document.getElementById('stagingStatusMessage');
const selectRouteNameColour = document.getElementById('selectRouteNameColour');
const inputRouteColour = document.getElementById('inputRouteColour');
const saveRouteColourButton = document.getElementById('saveRouteColourButton');
const currentRouteColoursList = document.getElementById('currentRouteColoursList');
const noCustomColoursMessage = document.getElementById('noCustomColoursMessage');
const routeColourStatusMessage = document.getElementById('routeColourStatusMessage');
const selectStopForDeparturesView = document.getElementById('selectStopForDeparturesView');
const stopDeparturesList = document.getElementById('stopDeparturesList');
const noDeparturesForStopMessage = document.getElementById('noDeparturesForStopMessage');
const topMenuBar = document.getElementById('top-menu-bar');
const adminLoginSection = document.getElementById('auth-section');
const loginFormContainer = document.getElementById('login-form-container');
const logoutContainer = document.getElementById('logout-container');
const loginButton = document.getElementById('loginButton');
const logoutButton = document.getElementById('logoutButton');
const inputEmail = document.getElementById('inputEmail');
const inputPassword = document.getElementById('inputPassword');
const authStatus = document.getElementById('auth-status');
const loggedInUserEmailDisplay = document.getElementById('loggedInUserEmail');
const mainMenuButtons = document.querySelectorAll('#main-menu-buttons .menu-button');
const allToolContentSections = document.querySelectorAll('.tool-content-section');

const detectDuplicatesButton = document.getElementById('detectDuplicatesButton');
const duplicateEntriesResults = document.getElementById('duplicateEntriesResults');
const removeDuplicateEntriesButton = document.getElementById('removeDuplicateEntriesButton');
const removeDuplicatesStatusMessage = document.getElementById('removeDuplicatesStatusMessage');


// DOM Elements for Stop Management Tool
const masterStopListFilterInput_SM = document.getElementById('masterStopListFilterInput_SM');
const refreshMasterStopListButton_SM = document.getElementById('refreshMasterStopListButton_SM');
const masterStopListUL_SM = document.getElementById('masterStopListUL_SM');
const masterStopListStatus_SM = document.getElementById('masterStopListStatus_SM');

const findStopIdScheduleInput_SM = document.getElementById('findStopIdScheduleInput_SM');
const replaceStopIdScheduleInput_SM = document.getElementById('replaceStopIdScheduleInput_SM');
const findReplaceStopIdScheduleButton_SM = document.getElementById('findReplaceStopIdScheduleButton_SM');
const findReplaceStatusMessage_SM = document.getElementById('findReplaceStatusMessage_SM');
const routesForStopSelect_SM = document.getElementById('routesForStopSelect_SM');
const refreshRoutesForStopSelectButton_SM = document.getElementById('refreshRoutesForStopSelectButton_SM');
const routesServingStopList_SM = document.getElementById('routesServingStopList_SM');
const routesServingStopStatus_SM = document.getElementById('routesServingStopStatus_SM');

// DOM Elements for "Add/Remove Stop Details" section
const selectNewStopIdFormat_ARS = document.getElementById('selectNewStopIdFormat_ARS'); 
const buttonSuggestStopId_ARS = document.getElementById('buttonSuggestStopId_ARS'); 
const inputNewStopId_ARS = document.getElementById('inputNewStopId_ARS'); 
const newStopIdAvailability_ARS = document.getElementById('newStopIdAvailability_ARS'); 
const inputNewStopName_ARS = document.getElementById('inputNewStopName_ARS'); 
const inputNewStopDirection_ARS = document.getElementById('inputNewStopDirection_ARS'); 
const buttonAddNewStop_ARS = document.getElementById('buttonAddNewStop_ARS'); 
const addNewStopStatus_ARS = document.getElementById('addNewStopStatus_ARS'); 

const selectStopToRemove_ARS = document.getElementById('selectStopToRemove_ARS'); 
const buttonRemoveStop_ARS = document.getElementById('buttonRemoveStop_ARS');     
const removeStopStatus_ARS = document.getElementById('removeStopStatus_ARS');     


// --- Global State ---
let currentUser = null;
let currentWorkingSchedule = [];
let ukBankHolidaysData = { dates: [], titles: {} };
const schoolHolidayDateRanges = [ ]; 
let closedStopIDs = [];
let customRouteColours = {};
let effectiveRouteColourMapTools = {};
let uniqueStopsMasterList_SM = [];
let autoApplyIntervalId = null; 


// --- Constants ---
const LOCAL_STORAGE_ACTIVE_SECTION_KEY = 'omsiToolsActiveSection';
const FB_PATH_LIVE_SCHEDULE_DATA = '/liveSchedule/allScheduledBusData';
const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
const FB_PATH_PENDING_SCHEDULE_DATA = '/pendingSchedule/allScheduledBusData';
const FB_PATH_PENDING_UNIQUE_STOPS = '/pendingSchedule/uniqueBusStops';
const FB_PATH_PENDING_TIMESTAMP = '/pendingSchedule/uploadTimestamp';
const FB_PATH_APPSTATE_STATUS = '/appState/scheduleStatus';
const FB_PATH_APPSTATE_LAST_UPDATED = '/appState/scheduleLastUpdated';
const FB_PATH_APPSTATE_CLOSED_STOPS = '/appState/closedStopIDs';
const FB_PATH_SETTINGS_CUSTOM_COLOURS = '/settings/customRouteColours';

const initialRouteColourMapForTools = { "1": "#DC2626", "2": "#DC2626", "3": "#DC2626", "4": "#00783A", "5": "#00783A", "6": "#00783A", "7": "#FFD300", "8": "#FFD300", "9": "#FFD300", "10": "#970006", "11": "#76D0BD", "12": "#F3A9BB", "186": "#E32017", "32":  "#00A4A7", "N5":  "#0019A8", "C11": "#FFD300","107": "#76D0BD", "221": "#93002F", "240": "#C9A0DC", "251": "#F8A960","303": "#868F98", "305": "#CF7EA2", "SL1": "#5F259F", "SL10": "#A05A2C" };
const DEFAULT_ROUTE_COLOUR_TOOLS = "#73809C";

// --- START: Schedule Generator (from COUNT_generator.html) ---
let gen_ruleCounter = 0;
let gen_currentScheduleEntries = []; 
const GEN_APP_DATA_KEY = 'transitScheduleAppData_tools_v1'; 
let gen_isInitialized = false; 


// --- START: Schedule Generator Population & Interaction ---
function gen_populateStopNameSelect() {
    const selectEl = document.getElementById('gen_stopNameSelect');
    if (!selectEl) return;

    const previouslySelectedStopId = selectEl.value; 
    selectEl.innerHTML = '<option value="">-- Select Stop --</option>'; 

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        selectEl.innerHTML = '<option value="">-- No Stops Loaded --</option>';
        const stopIdEl = document.getElementById('gen_stopId');
        const stopNameEl = document.getElementById('gen_stopName');
        const directionEl = document.getElementById('gen_direction');
        if (stopIdEl) stopIdEl.value = '';
        if (stopNameEl) stopNameEl.value = '';
        if (directionEl) directionEl.value = '';
        gen_populateRouteSelect(); 
        return;
    }

    const stopMap = new Map(); 
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && !stopMap.has(entry.stopID.toUpperCase())) {
            stopMap.set(entry.stopID.toUpperCase(), {
                id: entry.stopID, 
                name: entry.stopName || entry.stopID,
                direction: entry.direction || ""
            });
        }
    });

    const sortedStops = Array.from(stopMap.values()).sort((a, b) => {
        const nameA = String(a.name || "").toLowerCase();
        const nameB = String(b.name || "").toLowerCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        return 0;
    });

    sortedStops.forEach(stop => {
        const opt = document.createElement('option');
        opt.value = stop.id; 
        opt.textContent = `${stop.name} (${stop.id})`;
        opt.dataset.stopname = stop.name;
        opt.dataset.direction = stop.direction;
        selectEl.appendChild(opt);
    });

    if (previouslySelectedStopId && stopMap.has(previouslySelectedStopId.toUpperCase())) {
        selectEl.value = previouslySelectedStopId;
    }
    selectEl.dispatchEvent(new Event('change'));
}

function gen_populateRouteSelect() { 
    const routeSelectEl = document.getElementById('gen_routeSelect');
    if (!routeSelectEl) return;

    const previouslySelectedRouteInDropdown = routeSelectEl.value; 
    const currentLineNameInInput = document.getElementById('gen_lineName')?.value || "";

    routeSelectEl.innerHTML = '<option value="">-- Select Existing Route --</option>'; 

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        routeSelectEl.innerHTML = '<option value="">-- No Routes in Schedule --</option>';
        const lineNameInputEl = document.getElementById('gen_lineName');
        if (lineNameInputEl) lineNameInputEl.dispatchEvent(new Event('input')); 
        return;
    }

    const uniqueRoutes = [...new Set(currentWorkingSchedule.map(e => e.lineName))]
        .filter(Boolean)
        .sort(compareLineNames);

    uniqueRoutes.forEach(lineName => {
        const opt = document.createElement('option');
        opt.value = lineName;
        opt.textContent = lineName;
        routeSelectEl.appendChild(opt);
    });
    
    const lineNameInputEl = document.getElementById('gen_lineName');
    if (lineNameInputEl && lineNameInputEl.value && uniqueRoutes.includes(lineNameInputEl.value)) {
        routeSelectEl.value = lineNameInputEl.value;
    } else if (previouslySelectedRouteInDropdown && uniqueRoutes.includes(previouslySelectedRouteInDropdown)) {
        routeSelectEl.value = previouslySelectedRouteInDropdown;
        if (lineNameInputEl) lineNameInputEl.value = routeSelectEl.value; 
    } else {
        if (lineNameInputEl) lineNameInputEl.value = routeSelectEl.value; 
    }
    
    if(lineNameInputEl) lineNameInputEl.dispatchEvent(new Event('input', { bubbles:true, cancelable:true }));
}


function gen_populateDestinationSelect() { 
    const lineNameInputEl = document.getElementById('gen_lineName');
    const destSelectEl = document.getElementById('gen_destinationSelect');
    if (!lineNameInputEl || !destSelectEl) return;

    const selectedRoute = lineNameInputEl.value; 
    const previouslySelectedDestInDropdown = destSelectEl.value;

    destSelectEl.innerHTML = ''; 
    
    if (!selectedRoute) {
        destSelectEl.innerHTML = '<option value="">-- Enter/Select Route First --</option>';
        return;
    }

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        destSelectEl.innerHTML = '<option value="">-- No Schedule Data --</option>';
        return;
    }

    const relevantEntries = currentWorkingSchedule.filter(e =>
        e.lineName === selectedRoute && e.destinationName
    );

    const uniqueDestinations = [...new Set(relevantEntries.map(e => e.destinationName))]
        .sort((a, b) => String(a || "").toLowerCase().localeCompare(String(b || "").toLowerCase()));

    if (uniqueDestinations.length === 0) {
        destSelectEl.innerHTML = `<option value="">-- No Known Destinations for Route ${selectedRoute} --</option>`;
    } else {
        destSelectEl.innerHTML = '<option value="">-- Select Existing Destination --</option>';
        uniqueDestinations.forEach(destName => {
            const opt = document.createElement('option');
            opt.value = destName;
            opt.textContent = destName;
            destSelectEl.appendChild(opt);
        });
    }

    const destNameInputEl = document.getElementById('gen_destinationName');
    if (destNameInputEl && destNameInputEl.value && uniqueDestinations.includes(destNameInputEl.value)) {
        destSelectEl.value = destNameInputEl.value;
    } else if (previouslySelectedDestInDropdown && uniqueDestinations.includes(previouslySelectedDestInDropdown)) {
        destSelectEl.value = previouslySelectedDestInDropdown;
        if (destNameInputEl) destNameInputEl.value = destSelectEl.value; 
    } else {
         if (destNameInputEl) destNameInputEl.value = destSelectEl.value; 
    }
}


function gen_attachEventListenersForGeneratorSelects() {
    const stopNameSelect = document.getElementById('gen_stopNameSelect');
    const routeSelect = document.getElementById('gen_routeSelect');
    const destinationSelect = document.getElementById('gen_destinationSelect');
    const lineNameInputEl = document.getElementById('gen_lineName');
    const destNameInputEl = document.getElementById('gen_destinationName');

    if (stopNameSelect) {
        stopNameSelect.removeEventListener('change', gen_handleStopNameSelectChange);
        stopNameSelect.addEventListener('change', gen_handleStopNameSelectChange);
    }
    if (routeSelect) { 
        routeSelect.removeEventListener('change', gen_handleRouteSelectChange);
        routeSelect.addEventListener('change', gen_handleRouteSelectChange);
    }
    if (destinationSelect) { 
        destinationSelect.removeEventListener('change', gen_handleDestinationSelectChange);
        destinationSelect.addEventListener('change', gen_handleDestinationSelectChange);
    }

    if (lineNameInputEl) {
        lineNameInputEl.removeEventListener('input', gen_handleLineNameInputChange);
        lineNameInputEl.addEventListener('input', gen_handleLineNameInputChange);
        lineNameInputEl.removeEventListener('change', gen_saveDataToLocalStorage); 
        lineNameInputEl.addEventListener('change', gen_saveDataToLocalStorage);
    }
    if (destNameInputEl) {
        destNameInputEl.removeEventListener('input', gen_saveDataToLocalStorage); 
        destNameInputEl.addEventListener('input', gen_saveDataToLocalStorage);
        destNameInputEl.removeEventListener('change', gen_saveDataToLocalStorage); 
        destNameInputEl.addEventListener('change', gen_saveDataToLocalStorage);
    }
}

function gen_handleLineNameInputChange() {
    gen_populateDestinationSelect();
    const lineNameInputEl = document.getElementById('gen_lineName');
    const routeSelectEl = document.getElementById('gen_routeSelect');
    if (lineNameInputEl && routeSelectEl) {
        const currentLineName = lineNameInputEl.value;
        let optionExists = Array.from(routeSelectEl.options).some(opt => opt.value === currentLineName);
        if(optionExists) {
            routeSelectEl.value = currentLineName;
        } else {
            routeSelectEl.selectedIndex = 0; 
        }
    }
    gen_saveDataToLocalStorage(); 
}


function gen_handleStopNameSelectChange() {
    const stopNameSelect = document.getElementById('gen_stopNameSelect');
    const selectedOption = stopNameSelect.options[stopNameSelect.selectedIndex];
    const stopIdInput = document.getElementById('gen_stopId');
    const stopNameInput = document.getElementById('gen_stopName');
    const directionInput = document.getElementById('gen_direction');

    if (selectedOption && selectedOption.value) {
        if (stopIdInput) stopIdInput.value = selectedOption.value; 
        if (stopNameInput) stopNameInput.value = selectedOption.dataset.stopname || '';
        if (directionInput) directionInput.value = selectedOption.dataset.direction || '';
    } else {
        if (stopIdInput) stopIdInput.value = '';
        if (stopNameInput) stopNameInput.value = '';
        if (directionInput) directionInput.value = '';
    }
    gen_saveDataToLocalStorage();
}

function gen_handleRouteSelectChange() { 
    const routeSelect = document.getElementById('gen_routeSelect');
    const lineNameInput = document.getElementById('gen_lineName'); 
    if (lineNameInput) {
        lineNameInput.value = routeSelect.value; 
        lineNameInput.dispatchEvent(new Event('input', { bubbles:true, cancelable:true })); 
    }
}

function gen_handleDestinationSelectChange() { 
    const destinationSelect = document.getElementById('gen_destinationSelect');
    const destNameInput = document.getElementById('gen_destinationName'); 
    if (destNameInput) {
        destNameInput.value = destinationSelect.value; 
         destNameInput.dispatchEvent(new Event('input', { bubbles:true, cancelable:true })); 
    }
}
// --- END: Schedule Generator Population & Interaction ---


function gen_addIntervalRule(ruleData = null) {
    gen_ruleCounter++;
    const container = document.getElementById('gen_intervalRulesContainer');
    if (!container) return;
    const ruleDiv = document.createElement('div');
    ruleDiv.className = 'gen_interval-rule'; 
    ruleDiv.id = `gen_rule-${gen_ruleCounter}`;
    ruleDiv.innerHTML = `
        <h4>Rule ${gen_ruleCounter}</h4>
        <div class="gen_input-group">
            <div>
                <label for="gen_startTime-${gen_ruleCounter}">Start Time (HHMM):</label>
                <input type="text" id="gen_startTime-${gen_ruleCounter}" class="schedule-generator-input" placeholder="e.g., 0900">
            </div>
            <div>
                <label for="gen_endTime-${gen_ruleCounter}">End Time (HHMM):</label>
                <input type="text" id="gen_endTime-${gen_ruleCounter}" class="schedule-generator-input" placeholder="e.g., 1900">
            </div>
            <div>
                <label for="gen_interval-${gen_ruleCounter}">Interval (minutes):</label>
                <input type="number" id="gen_interval-${gen_ruleCounter}" class="schedule-generator-input" min="1" placeholder="15">
            </div>
        </div>
        <button class="button small-action tertiary" onclick="gen_removeIntervalRule('gen_rule-${gen_ruleCounter}')" style="margin-left:0; margin-top:5px;">Remove Rule</button>
    `;
    container.appendChild(ruleDiv);

    if (ruleData) {
        const startTimeEl = document.getElementById(`gen_startTime-${gen_ruleCounter}`);
        const endTimeEl = document.getElementById(`gen_endTime-${gen_ruleCounter}`);
        const intervalEl = document.getElementById(`gen_interval-${gen_ruleCounter}`);
        if(startTimeEl) startTimeEl.value = ruleData.startTime || '';
        if(endTimeEl) endTimeEl.value = ruleData.endTime || '';
        if(intervalEl) intervalEl.value = ruleData.interval || '';
    }
}

function gen_removeIntervalRule(ruleId) {
    const ruleElement = document.getElementById(ruleId);
    if (ruleElement) {
        ruleElement.remove();
        gen_saveDataToLocalStorage();
    }
}

function gen_hhmmToMinutes(hhmmStr) {
    if (!hhmmStr || hhmmStr.length !== 4) return 0;
    const hours = parseInt(hhmmStr.substring(0, 2), 10);
    const minutes = parseInt(hhmmStr.substring(2, 4), 10);
    if (isNaN(hours) || isNaN(minutes)) return 0;
    return hours * 60 + minutes;
}

function gen_minutesToHHMM(totalMinutes) {
    const hours = Math.floor(totalMinutes / 60) % 24;
    const minutes = totalMinutes % 60;
    return String(hours).padStart(2, '0') + String(minutes).padStart(2, '0');
}

function gen_formatTimeToHHMMColon(hhmmStr) {
    const timeStr = String(hhmmStr || "").padStart(4, '0');
    if (timeStr.length === 4 && !isNaN(parseInt(timeStr,10))) {
         return timeStr.substring(0, 2) + ":" + timeStr.substring(2, 4);
    }
    return hhmmStr;
}

function gen_getBaseDataFromForm() { 
    return {
        stopId: document.getElementById('gen_stopId')?.value.trim(), 
        stopIdPattern: document.getElementById('gen_stopIdPattern')?.value,
        stopName: document.getElementById('gen_stopName')?.value.trim(), 
        direction: document.getElementById('gen_direction')?.value.trim(), 
        lineName: document.getElementById('gen_lineName')?.value.trim().toUpperCase(), 
        destinationName: document.getElementById('gen_destinationName')?.value.trim(), 
        operatingProfile: document.getElementById('gen_operatingProfile')?.value.trim(),
        initialScheduledTime: document.getElementById('gen_initialScheduledTime')?.value.trim(),
        initialDayOffset: document.getElementById('gen_initialDayOffset')?.value.trim() || '0'
    };
}

function gen_getIntervalRulesFromForm() {
    const intervalRulesData = [];
    document.querySelectorAll('#gen_intervalRulesContainer .gen_interval-rule').forEach(ruleElement => {
        const idNum = ruleElement.id.split('-')[1]; 
        const startTime = document.getElementById(`gen_startTime-${idNum}`)?.value.trim();
        const endTime = document.getElementById(`gen_endTime-${idNum}`)?.value.trim();
        const intervalValue = document.getElementById(`gen_interval-${idNum}`)?.value.trim();
        if (startTime || endTime || intervalValue) {
             intervalRulesData.push({
                startTime: startTime,
                endTime: endTime,
                interval: parseInt(intervalValue, 10) || 15
            });
        }
    });
    return intervalRulesData;
}

function gen_saveDataToLocalStorage() {
    if (document.getElementById('schedule-generator-section')?.style.display !== 'block' && !gen_isInitialized) {
        return;
    }
    try {
        const appData = {
            baseData: gen_getBaseDataFromForm(),
            intervalRules: gen_getIntervalRulesFromForm(),
            generatedSchedule: gen_currentScheduleEntries 
        };
        localStorage.setItem(GEN_APP_DATA_KEY, JSON.stringify(appData));
    } catch (e) {
        console.error("Error saving generator data to localStorage:", e);
    }
}


function gen_loadDataFromLocalStorage() {
    const savedDataString = localStorage.getItem(GEN_APP_DATA_KEY);
    if (savedDataString) {
        try {
            const appData = JSON.parse(savedDataString);

            if (appData.baseData) {
                const fieldsToSet = {
                    'gen_stopId': appData.baseData.stopId,
                    'gen_stopName': appData.baseData.stopName,
                    'gen_direction': appData.baseData.direction,
                    'gen_lineName': appData.baseData.lineName, 
                    'gen_destinationName': appData.baseData.destinationName, 
                    'gen_operatingProfile': appData.baseData.operatingProfile,
                    'gen_initialScheduledTime': appData.baseData.initialScheduledTime,
                    'gen_initialDayOffset': appData.baseData.initialDayOffset || '0',
                    'gen_stopIdPattern': appData.baseData.stopIdPattern || 'Custom'
                };
                for (const id in fieldsToSet) {
                    const el = document.getElementById(id);
                    if (el) el.value = fieldsToSet[id] || '';
                }
                
                const gen_stopNameSelectEl = document.getElementById('gen_stopNameSelect');
                if (gen_stopNameSelectEl && appData.baseData.stopId) {
                    let optionExists = Array.from(gen_stopNameSelectEl.options).some(opt => opt.value === appData.baseData.stopId);
                    if (optionExists) {
                        gen_stopNameSelectEl.value = appData.baseData.stopId;
                    } else {
                         gen_stopNameSelectEl.selectedIndex = 0; 
                    }
                }
                gen_stopNameSelectEl?.dispatchEvent(new Event('change')); 

                setTimeout(() => {
                    const lineNameInputEl = document.getElementById('gen_lineName'); 
                    const routeSelectEl = document.getElementById('gen_routeSelect'); 
                    if (routeSelectEl && lineNameInputEl && lineNameInputEl.value) {
                        let optionExists = Array.from(routeSelectEl.options).some(opt => opt.value === lineNameInputEl.value);
                        if (optionExists) routeSelectEl.value = lineNameInputEl.value;
                        else routeSelectEl.selectedIndex = 0;
                    }
                    lineNameInputEl?.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));

                    setTimeout(() => {
                        const destNameInputEl = document.getElementById('gen_destinationName'); 
                        const destSelectEl = document.getElementById('gen_destinationSelect'); 
                        if (destSelectEl && destNameInputEl && destNameInputEl.value) {
                           let optionExists = Array.from(destSelectEl.options).some(opt => opt.value === destNameInputEl.value);
                           if(optionExists) destSelectEl.value = destNameInputEl.value;
                           else destSelectEl.selectedIndex = 0;
                        }
                    }, 150); 
                }, 100); 
            }

            const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
            if(intervalRulesContainer) intervalRulesContainer.innerHTML = ''; 
            gen_ruleCounter = 0; 
            (appData.intervalRules || []).forEach(ruleData => gen_addIntervalRule(ruleData));

            gen_currentScheduleEntries = appData.generatedSchedule || [];
            gen_renderScheduleTable();
        } catch (e) {
            console.error("Error loading generator data from localStorage:", e);
            localStorage.removeItem(GEN_APP_DATA_KEY); 
        }
    } else {
        const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
        if (intervalRulesContainer && intervalRulesContainer.childElementCount === 0) {
            gen_addIntervalRule();
        }
        document.getElementById('gen_stopNameSelect')?.dispatchEvent(new Event('change'));
    }
}


function gen_clearAllData() {
    if (confirm("Are you sure you want to clear all data for the Schedule Generator? This cannot be undone.")) {
        const fieldsToClear = [
            'gen_stopId', 'gen_stopName', 'gen_direction', 
            'gen_lineName', 'gen_destinationName', 
            'gen_operatingProfile', 'gen_initialScheduledTime', 'gen_initialDayOffset'
        ];
        fieldsToClear.forEach(id => {
            const el = document.getElementById(id);
            if(el) el.value = '';
        });
        
        ['gen_stopNameSelect', 'gen_routeSelect', 'gen_destinationSelect', 'gen_stopIdPattern'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.selectedIndex = 0; 
                if (id === 'gen_stopIdPattern') el.value = 'Custom'; 
            }
        });
        const initialDayOffsetEl = document.getElementById('gen_initialDayOffset');
        if(initialDayOffsetEl) initialDayOffsetEl.value = '0'; 

        const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
        if(intervalRulesContainer) intervalRulesContainer.innerHTML = '';
        gen_ruleCounter = 0;
        gen_addIntervalRule(); 

        gen_currentScheduleEntries = [];
        gen_renderScheduleTable();

        localStorage.removeItem(GEN_APP_DATA_KEY);
        alert("All generator data has been cleared.");
        
        document.getElementById('gen_stopNameSelect')?.dispatchEvent(new Event('change')); 
    }
}


function gen_suggestRandomStopId() { 
    const patternEl = document.getElementById('gen_stopIdPattern');
    const stopIdInputEl = document.getElementById('gen_stopId');
    const stopNameSelectEl = document.getElementById('gen_stopNameSelect');
    const stopNameInputEl = document.getElementById('gen_stopName');
    const directionInputEl = document.getElementById('gen_direction');

    if (!patternEl || !stopIdInputEl || !stopNameSelectEl || !stopNameInputEl || !directionInputEl) return;

    const pattern = patternEl.value;
    if (pattern === 'Custom') {
        alert("Please select a valid pattern (other than Custom/Manual) to suggest an ID.");
        return;
    }

    const newStopId = generateUniqueStopId(pattern); 

    if (!newStopId || newStopId.includes(String(Date.now()).slice(-5))) { 
         alert("Could not suggest a unique ID based on selected pattern and existing data. A fallback ID was generated or suggestion failed. Please review/edit or try a different pattern.");
         if(!newStopId) return; 
    }
    
    stopIdInputEl.value = newStopId;
    stopNameSelectEl.selectedIndex = 0;  
    stopNameInputEl.value = ''; 
    directionInputEl.value = ''; 
    
    stopNameSelectEl.dispatchEvent(new Event('change'));
    gen_saveDataToLocalStorage();
}


function gen_generateSchedule() {
    gen_currentScheduleEntries = [];
    const addedEntryKeys = new Set();

    const baseFormValues = gen_getBaseDataFromForm();
    const baseDataForGeneration = {
        stopId: baseFormValues.stopId,
        stopName: baseFormValues.stopName,
        direction: baseFormValues.direction,
        lineName: baseFormValues.lineName, 
        destinationName: baseFormValues.destinationName,
        operatingProfile: baseFormValues.operatingProfile,
    };

    if (baseFormValues.initialScheduledTime && baseFormValues.initialScheduledTime.match(/^\d{3,4}$/)) {
        const initialEntry = {
            ...baseDataForGeneration,
            scheduledTime: baseFormValues.initialScheduledTime.padStart(4,'0'), 
            dayOffset: baseFormValues.initialDayOffset || '0'
        };
        const initialKey = `${initialEntry.stopId}-${initialEntry.lineName}-${initialEntry.scheduledTime}-${initialEntry.operatingProfile}`;
        gen_currentScheduleEntries.push(initialEntry);
        addedEntryKeys.add(initialKey);
    }

    const intervalRules = gen_getIntervalRulesFromForm();
    intervalRules.forEach(rule => {
        const startTimeStr = rule.startTime;
        const endTimeStr = rule.endTime;
        const intervalMins = parseInt(rule.interval, 10);

        if (!startTimeStr || !startTimeStr.match(/^\d{3,4}$/) ||
            !endTimeStr || !endTimeStr.match(/^\d{3,4}$/) ||
            isNaN(intervalMins) || intervalMins <= 0) {
            console.warn(`Generator: Skipping invalid rule: Start-${startTimeStr}, End-${endTimeStr}, Interval-${rule.interval}`);
            return;
        }

        let currentTotalMinutes = gen_hhmmToMinutes(startTimeStr.padStart(4,'0'));
        const endTotalMinutesInput = gen_hhmmToMinutes(endTimeStr.padStart(4,'0'));
        let effectiveEndTotalMinutes = endTotalMinutesInput;

        if (currentTotalMinutes > endTotalMinutesInput && startTimeStr > endTimeStr) { 
             effectiveEndTotalMinutes += 24 * 60; 
        }

        const ruleStartHourForContext = parseInt(startTimeStr.padStart(4,'0').substring(0, 2), 10);
        const isRuleConsideredNewDayService = (ruleStartHourForContext >= 0 && ruleStartHourForContext <= 3);
        
        while (currentTotalMinutes <= effectiveEndTotalMinutes) {
            const scheduledTimeHHMM = gen_minutesToHHMM(currentTotalMinutes); 
            const entryKey = `${baseDataForGeneration.stopId}-${baseDataForGeneration.lineName}-${scheduledTimeHHMM}-${baseDataForGeneration.operatingProfile}`;

            if (!addedEntryKeys.has(entryKey)) {
                let generatedDayOffset = 0;
                const currentGeneratedHour = parseInt(scheduledTimeHHMM.substring(0,2), 10);

                if (isRuleConsideredNewDayService) {
                    generatedDayOffset = 0;
                } else {
                    if (currentTotalMinutes >= 1440 && (currentGeneratedHour >=0 && currentGeneratedHour <=3)) {
                         generatedDayOffset = 1;
                    } else {
                        generatedDayOffset = 0;
                    }
                }

                gen_currentScheduleEntries.push({
                    ...baseDataForGeneration,
                    scheduledTime: scheduledTimeHHMM, 
                    dayOffset: generatedDayOffset
                });
                addedEntryKeys.add(entryKey);
            }

            if (intervalMins === 0) break; 
            currentTotalMinutes += intervalMins;
        }
    });
    gen_renderScheduleTable();
    gen_saveDataToLocalStorage();
}

function gen_deleteScheduleEntry(index) {
    if (index < 0 || index >= gen_currentScheduleEntries.length) {
        console.error("Invalid index for deletion:", index);
        return;
    }
    const entryToDelete = gen_currentScheduleEntries[index];
    let timeToDisplay = entryToDelete.scheduledTime || "";
    if (timeToDisplay.length === 4 && !isNaN(timeToDisplay)) {
        timeToDisplay = `${timeToDisplay.substring(0,2)}:${timeToDisplay.substring(2,4)}`;
    } else if (timeToDisplay.length === 3 && !isNaN(timeToDisplay)) {
            timeToDisplay = `0${timeToDisplay.substring(0,1)}:${timeToDisplay.substring(1,3)}`;
    }

    if (confirm(`Are you sure you want to delete this entry?\nStop: ${entryToDelete.stopId} - ${entryToDelete.stopName}\nLine: ${entryToDelete.lineName}\nTime: ${timeToDisplay}\nDest: ${entryToDelete.destinationName}`)) {
        gen_currentScheduleEntries.splice(index, 1); 
        gen_renderScheduleTable(); 
        gen_saveDataToLocalStorage(); 
        console.log("Entry deleted from generator list and local storage updated.");
    }
}

function gen_renderScheduleTable() {
    const resultsTable = document.getElementById('gen_resultsTable');
    if (!resultsTable) return;
    const resultsBody = resultsTable.getElementsByTagName('tbody')[0];
    const resultsHead = resultsTable.getElementsByTagName('thead')[0];
    if (!resultsBody || !resultsHead) return;

    resultsBody.innerHTML = ''; 

    if (resultsHead.rows.length > 0) {
        let headerRow = resultsHead.rows[0];
        if (headerRow.cells.length === 8 && headerRow.cells[7].textContent !== "Actions") {
            let th = document.createElement('th');
            th.textContent = 'Actions';
            headerRow.appendChild(th);
        } else if (headerRow.cells.length === 0) { 
            headerRow.innerHTML = `<th>StopID</th><th>StopName</th><th>Direction</th><th>LineName</th><th>DestinationName</th><th>ScheduledTime (HH:MM)</th><th>OperatingProfile</th><th>DayOffset</th><th>Actions</th>`;
        } else if (headerRow.cells.length > 0 && headerRow.cells[headerRow.cells.length - 1].textContent !== "Actions") {
            // This case might occur if columns were added but not 'Actions' yet
            let th = document.createElement('th');
            th.textContent = 'Actions';
            headerRow.appendChild(th);
        }
    } else { // If no thead row at all
        let header = resultsTable.createTHead();
        let row = header.insertRow(0);
        row.innerHTML = `<th>StopID</th><th>StopName</th><th>Direction</th><th>LineName</th><th>DestinationName</th><th>ScheduledTime (HH:MM)</th><th>OperatingProfile</th><th>DayOffset</th><th>Actions</th>`;
    }


    gen_currentScheduleEntries.forEach((entry, index) => {
        let newRow = resultsBody.insertRow();
        newRow.insertCell().textContent = entry.stopId || '';
        newRow.insertCell().textContent = entry.stopName || '';
        newRow.insertCell().textContent = entry.direction || '';
        newRow.insertCell().textContent = entry.lineName || '';
        newRow.insertCell().textContent = entry.destinationName || '';

        let displayTime = entry.scheduledTime || ""; 
        if (displayTime.length === 4 && !isNaN(displayTime)) { 
            displayTime = `${displayTime.substring(0,2)}:${displayTime.substring(2,4)}`;
        } else if (displayTime.length === 3 && !isNaN(displayTime)) { 
             displayTime = `0${displayTime.substring(0,1)}:${displayTime.substring(1,3)}`;
        }
        newRow.insertCell().textContent = displayTime;

        newRow.insertCell().textContent = entry.operatingProfile || '';
        newRow.insertCell().textContent = String(entry.dayOffset || '0');

        let actionCell = newRow.insertCell();
        let deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.classList.add('button', 'small-action', 'secondary'); 
        deleteButton.style.padding = '0.2rem 0.4rem'; 
        deleteButton.style.fontSize = '0.8rem'; 
        deleteButton.onclick = function() { gen_deleteScheduleEntry(index); };
        actionCell.appendChild(deleteButton);
    });
}


function gen_exportToCountFile() {
    if (gen_currentScheduleEntries.length === 0) {
        alert("No schedule data to export from generator. Please generate a schedule first.");
        return;
    }

    const headers = [
        "StopID", "StopName", "Direction", "LineName",
        "DestinationName", "ScheduledTime", "OperatingProfile", "DayOffset"
    ];

    let tabText = headers.join("\t") + "\n";

    gen_currentScheduleEntries.forEach(entry => {
        let formattedTime = entry.scheduledTime; 
        if (formattedTime && formattedTime.length === 4 && !formattedTime.includes(':')) {
            formattedTime = `${formattedTime.substring(0,2)}:${formattedTime.substring(2,4)}`;
        } else if (formattedTime && formattedTime.length === 3 && !formattedTime.includes(':')) { 
            formattedTime = `0${formattedTime.substring(0,1)}:${formattedTime.substring(1,3)}`;
        }

        const rowValues = [
            entry.stopId, entry.stopName, entry.direction, entry.lineName,
            entry.destinationName, formattedTime, entry.operatingProfile, String(entry.dayOffset || '0')
        ];
        tabText += rowValues.map(val => String(val || '').replace(/\t|\n|\r/g, " ")).join("\t") + "\n";
    });

    const blob = new Blob([tabText], { type: 'text/plain;charset=utf-8;' });
    const link = document.createElement("a");

    if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "schedule_generated.count");
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    } else {
        alert("Your browser does not support automatic file downloading.");
    }
}

function gen_handleAddGeneratedToWorkingSchedule() {
    if (!currentUser) {
        alert("Please log in to modify the working schedule.");
        return;
    }
    if (!gen_currentScheduleEntries || gen_currentScheduleEntries.length === 0) {
        alert("No schedule entries generated/loaded in the generator to add. Please generate or load a schedule into the generator first.");
        return;
    }

    const actionChoice = prompt("Choose action for adding generated/loaded entries to the main working schedule:\n1. OVERWRITE entire working schedule.\n2. APPEND to existing working schedule.\n\nEnter 1 or 2 (or Cancel):");

    if (actionChoice !== "1" && actionChoice !== "2") {
        if (actionChoice !== null) { 
            alert("Invalid choice. Operation cancelled.");
        }
        return; 
    }

    const isOverwrite = actionChoice === "1";

    if (isOverwrite) {
        if (!confirm(`ARE YOU SURE you want to OVERWRITE the ENTIRE main working schedule with these ${gen_currentScheduleEntries.length} entries? This cannot be undone easily.`)) {
            return;
        }
        currentWorkingSchedule = []; 
    } else { 
        if (!confirm(`Are you sure you want to APPEND these ${gen_currentScheduleEntries.length} entries to the main working schedule?`)) {
            return;
        }
    }

    let addedCount = 0;
    const newEntriesForWorkingSchedule = gen_currentScheduleEntries.map((genEntry, index) => {
        let scheduledTimeForWorking = genEntry.scheduledTime || ""; 
        if (scheduledTimeForWorking && scheduledTimeForWorking.length === 4 && !scheduledTimeForWorking.includes(':')) {
            scheduledTimeForWorking = `${scheduledTimeForWorking.substring(0,2)}:${scheduledTimeForWorking.substring(2,4)}`;
        } else if (scheduledTimeForWorking && scheduledTimeForWorking.length === 3 && !scheduledTimeForWorking.includes(':')) { 
            scheduledTimeForWorking = `0${scheduledTimeForWorking.substring(0,1)}:${scheduledTimeForWorking.substring(1,3)}`;
        }

        const uniqueSuffix = Date.now() + "_" + index + (isOverwrite ? "_ow" : "_app");
        const internalId = `${(genEntry.stopId||'s').toUpperCase()}_${(genEntry.lineName||'l').toUpperCase()}_${(genEntry.scheduledTime||"").replace(':','')}_gen_${uniqueSuffix}`;

        addedCount++;
        return {
            internalId: internalId,
            stopID: (genEntry.stopId || "").toUpperCase(), 
            stopName: genEntry.stopName || "",
            direction: genEntry.direction || "",
            lineName: (genEntry.lineName || "").toUpperCase(), 
            destinationName: genEntry.destinationName || "",
            scheduledTime: scheduledTimeForWorking, 
            OperatingProfile: genEntry.operatingProfile || "",
            DayOffset: String(genEntry.dayOffset || "0")
        };
    });

    currentWorkingSchedule.push(...newEntriesForWorkingSchedule); 
    alert(`${addedCount} entries have been ${isOverwrite ? 'set as (overwritten)' : 'appended to'} the main working schedule.`);
    renderUIDependentElements();
}


function gen_handleGetWorkingSchedule() {
    if (!currentUser) {
        alert("Please log in to access the working schedule.");
        return;
    }

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        alert("The main working schedule is currently empty. Nothing to load into the generator.");
        return;
    }

    if (!confirm(`This will replace the current list in the generator with all ${currentWorkingSchedule.length} entries from the main working schedule. Are you sure?`)) {
        return;
    }

    let tempSchedule = currentWorkingSchedule.map(entry => {
        let internalGenScheduledTime = entry.scheduledTime || ""; 
        if (internalGenScheduledTime.includes(':')) {
            internalGenScheduledTime = internalGenScheduledTime.replace(':', '');
        }
        internalGenScheduledTime = internalGenScheduledTime.padStart(4, '0');

        return { 
            stopId: entry.stopID || "", 
            stopName: entry.stopName || "",
            direction: entry.direction || "",
            lineName: entry.lineName || "",
            destinationName: entry.destinationName || "",
            scheduledTime: internalGenScheduledTime, 
            operatingProfile: entry.OperatingProfile || "",
            dayOffset: String(entry.DayOffset || "0")
        };
    });

    tempSchedule.sort((a, b) => {
        const lineCompare = compareLineNames(a.lineName, b.lineName);
        if (lineCompare !== 0) return lineCompare;

        const stopNameA = (a.stopName || "").toLowerCase();
        const stopNameB = (b.stopName || "").toLowerCase();
        if (stopNameA < stopNameB) return -1;
        if (stopNameA > stopNameB) return 1;

        const timeA = a.scheduledTime || "9999"; 
        const timeB = b.scheduledTime || "9999";
        if (timeA < timeB) return -1;
        if (timeA > timeB) return 1;
        
        const dayOffsetA = parseInt(a.dayOffset, 10);
        const dayOffsetB = parseInt(b.dayOffset, 10);
        if (dayOffsetA < dayOffsetB) return -1;
        if (dayOffsetA > dayOffsetB) return 1;

        return 0; 
    });

    gen_currentScheduleEntries = tempSchedule; 

    gen_renderScheduleTable(); 
    gen_saveDataToLocalStorage(); 

    alert(`Loaded and sorted ${gen_currentScheduleEntries.length} entries from the main working schedule into the generator's list.`);
}


function gen_initializeScheduleGeneratorControls() {
    gen_populateStopNameSelect(); 
    gen_populateRouteSelect(); 
    
    if (gen_isInitialized) {
        const lineNameInputEl = document.getElementById('gen_lineName');
        if (lineNameInputEl) lineNameInputEl.dispatchEvent(new Event('input')); 
        return;
    }
    console.log("Initializing Schedule Generator Controls (First Time)...");
    
    gen_attachEventListenersForGeneratorSelects(); 
    gen_loadDataFromLocalStorage(); 

    const gen_baseDataInputsIds = [ 
        'gen_stopIdPattern', 
        'gen_operatingProfile', 'gen_initialScheduledTime', 'gen_initialDayOffset'
    ];

    gen_baseDataInputsIds.forEach(id => {
        const element = document.getElementById(id);
        if (element && (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'select')) {
            const eventType = element.tagName.toLowerCase() === 'select' ? 'change' : 'input';
            element.removeEventListener(eventType, gen_saveDataToLocalStorage);
            element.addEventListener(eventType, gen_saveDataToLocalStorage);
        }
    });

    const gen_intervalContainer = document.getElementById('gen_intervalRulesContainer');
    if (gen_intervalContainer) {
        gen_intervalContainer.removeEventListener('input', gen_handleIntervalContainerInput); 
        gen_intervalContainer.addEventListener('input', gen_handleIntervalContainerInput);
    }
    function gen_handleIntervalContainerInput(event) {
        const target = event.target;
        if (target.tagName.toLowerCase() === 'input' && target.closest('.gen_interval-rule')) {
             gen_saveDataToLocalStorage();
        }
    }

    const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer'); 
    if (intervalRulesContainer && intervalRulesContainer.childElementCount === 0) {
        gen_addIntervalRule(); 
    }

    // --- Button Listeners ---
    const btnGenerate = document.getElementById('gen_generateScheduleButton');
    if (btnGenerate) { btnGenerate.removeEventListener('click', gen_generateSchedule); btnGenerate.addEventListener('click', gen_generateSchedule); }

    const btnExport = document.getElementById('gen_exportToCountButton');
    if (btnExport) { btnExport.removeEventListener('click', gen_exportToCountFile); btnExport.addEventListener('click', gen_exportToCountFile); }
    
    const btnAddToWorking = document.getElementById('gen_addToWorkingScheduleButton');
    if (btnAddToWorking) { btnAddToWorking.removeEventListener('click', gen_handleAddGeneratedToWorkingSchedule); btnAddToWorking.addEventListener('click', gen_handleAddGeneratedToWorkingSchedule); }

    const btnGetWorkingSchedule = document.getElementById('gen_getWorkingScheduleButton');
    if (btnGetWorkingSchedule) { btnGetWorkingSchedule.removeEventListener('click', gen_handleGetWorkingSchedule); btnGetWorkingSchedule.addEventListener('click', gen_handleGetWorkingSchedule); }

    const btnClear = document.getElementById('gen_clearAllDataButton');
    if (btnClear) { btnClear.removeEventListener('click', gen_clearAllData); btnClear.addEventListener('click', gen_clearAllData); }

    const btnAddRule = document.getElementById('gen_addIntervalRuleButton');
    function gen_addIntervalRuleHandler() { gen_addIntervalRule(null); }
    if (btnAddRule) { btnAddRule.removeEventListener('click', gen_addIntervalRuleHandler); btnAddRule.addEventListener('click', gen_addIntervalRuleHandler); }

    const btnSuggestId = document.getElementById('gen_suggestRandomStopIdButton');
    if (btnSuggestId) { btnSuggestId.removeEventListener('click', gen_suggestRandomStopId); btnSuggestId.addEventListener('click', gen_suggestRandomStopId); }

    gen_isInitialized = true;
    console.log("Schedule Generator Controls Initialized/Refreshed.");
}
// --- END: Schedule Generator ---


// --- UI Navigation & State ---
function showSection(sectionId) {
    allToolContentSections.forEach(section => {
        section.style.display = 'none';
    });
    const sectionToShow = document.getElementById(sectionId);
    if (sectionToShow) {
        sectionToShow.style.display = 'block';
        const isMainButtonSection = Array.from(mainMenuButtons).some(btn => btn.getAttribute('data-section') === sectionId);
        if (isMainButtonSection) {
            localStorage.setItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY, sectionId);
            if (sectionId === 'stop-management-tool-section') {
                populateMasterStopList_SM();
                populateRoutesForStopSelector_SM();
            }
            if (sectionId === 'event-generator-section') populateRouteSelectorForEvents();
            if (sectionId === 'stop-status-section') populateStopStatusSelector();
            if (sectionId === 'view-departures-section') populateStopSelectorForDeparturesView();
            if (sectionId === 'bulk-edit-tools-section') {
                populateRouteSelectorForColours();
                renderCustomRouteColours();
            }
            if (sectionId === 'add-remove-stop-section') { 
                handleSuggestStopId_ARS(); 
                populateStopToRemoveSelector_ARS();
            }
            if (sectionId === 'schedule-generator-section') {
                gen_initializeScheduleGeneratorControls(); 
            }
        }
    } else {
        console.warn(`Attempted to show non-existent section: ${sectionId}`);
        localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY); 
    }
}


function hideAllToolSections() {
    allToolContentSections.forEach(section => {
        section.style.display = 'none';
    });
}

function updateAuthUI(user) {
    currentUser = user;
    hideAllToolSections(); 

    if (user) {
        if (adminLoginSection) adminLoginSection.style.display = 'none';
        if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'block';
        if (topMenuBar) topMenuBar.style.display = 'block'; 
        if (logoutContainer) logoutContainer.style.display = 'block';
        if (loginFormContainer) loginFormContainer.style.display = 'none';
        if (authStatus) authStatus.textContent = '';
        if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = user.email;
        initializeAutoApplyScheduler(); 


        const lastActiveSection = localStorage.getItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        let sectionActuallyShown = false;
        if (lastActiveSection) {
            const sectionElement = document.getElementById(lastActiveSection);
            const isKnownMenuSection = Array.from(mainMenuButtons).some(btn => btn.getAttribute('data-section') === lastActiveSection);
            if (sectionElement && isKnownMenuSection) {
                showSection(lastActiveSection); 
                sectionActuallyShown = true;
            } else {
                localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY); 
            }
        }
        
        if (!sectionActuallyShown && mainMenuButtons.length > 0 && mainMenuButtons[0].dataset.section) {
            showSection(mainMenuButtons[0].dataset.section);
        }

    } else {
        if (adminLoginSection) adminLoginSection.style.display = 'block';
        if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'none';
        if (topMenuBar) topMenuBar.style.display = 'none'; 
        if (logoutContainer) logoutContainer.style.display = 'none';
        if (loginFormContainer) loginFormContainer.style.display = 'block';
        if (authStatus) authStatus.textContent = 'Please log in to use the tools.';
        if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = '';
        localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY); 
        stopAutoApplyScheduler(); 
    }
}

// --- Analytics Functions ---
function detectDuplicateEntries() {
    if (!currentUser || currentWorkingSchedule.length === 0) {
        if (duplicateEntriesResults) duplicateEntriesResults.innerHTML = '<p>No schedule data loaded or not logged in.</p>';
        return;
    }
    const signatures = new Map();
    const duplicates = []; 
    currentWorkingSchedule.forEach((entry, index) => {
        const profileString = (entry.OperatingProfile || "").toLowerCase().split(',').map(s => s.trim()).sort().join(',');
        const signature = [
            (entry.stopID || "").toUpperCase(),
            (entry.lineName || "").toUpperCase(),
            entry.scheduledTime || "00:00", 
            profileString,
            entry.DayOffset || "0", 
            (entry.destinationName || "").trim() 
        ].join('|'); 

        if (signatures.has(signature)) {
            signatures.get(signature).push(index); 
        } else {
            signatures.set(signature, [index]); 
        }
    });

    signatures.forEach((indices, sig) => {
        if (indices.length > 1) {
            duplicates.push(indices.map(originalIndex => ({...currentWorkingSchedule[originalIndex], originalIndex})));
        }
    });

    if (duplicateEntriesResults) {
        if (duplicates.length === 0) {
            duplicateEntriesResults.innerHTML = '<p>No duplicate entries found in the current working schedule.</p>';
        } else {
            let html = `<p>Found ${duplicates.length} set(s) of duplicate entries:</p><ul>`;
            duplicates.forEach((set, i) => {
                html += `<li class="duplicate-set"><strong>Set ${i + 1}:</strong> (Appears ${set.length} times)`;
                set.forEach(entry => {
                    html += `<span class="entry-detail"> - Stop: ${entry.stopID}, Line: ${entry.lineName}, Time: ${entry.scheduledTime}, Profile: ${entry.OperatingProfile}, Dest: ${entry.destinationName} (Original Index: ${entry.originalIndex})</span>`;
                });
                html += `</li>`;
            });
            html += `</ul>`;
            duplicateEntriesResults.innerHTML = html;
        }
    }
}

function handleRemoveDuplicateEntries() {
    if (!currentUser) {
        alert("Please log in to modify the schedule.");
        if (removeDuplicatesStatusMessage) removeDuplicatesStatusMessage.textContent = "Not logged in.";
        return;
    }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        alert("Working schedule is empty. Nothing to deduplicate.");
        if (removeDuplicatesStatusMessage) removeDuplicatesStatusMessage.textContent = "Working schedule is empty.";
        return;
    }

    const initialCount = currentWorkingSchedule.length;
    const signaturesEncountered = new Set();
    const deduplicatedSchedule = [];

    currentWorkingSchedule.forEach(entry => {
        const profileString = (entry.OperatingProfile || "").toLowerCase().split(',').map(s => s.trim()).sort().join(',');
        const signature = [
            (entry.stopID || "").toUpperCase(),
            (entry.lineName || "").toUpperCase(),
            entry.scheduledTime || "00:00", 
            profileString,
            entry.DayOffset || "0",
            (entry.destinationName || "").trim()
        ].join('|');

        if (!signaturesEncountered.has(signature)) {
            signaturesEncountered.add(signature);
            deduplicatedSchedule.push(entry); 
        }
    });

    const removedCount = initialCount - deduplicatedSchedule.length;

    if (removedCount === 0) {
        alert("No duplicate entries found based on the criteria (StopID, Line, Time, Profile, DayOffset, Destination).");
        if (removeDuplicatesStatusMessage) {
            removeDuplicatesStatusMessage.textContent = "No duplicates found.";
            removeDuplicatesStatusMessage.style.color = ""; 
        }
        return;
    }

    if (confirm(`Found ${removedCount} duplicate schedule entries. Are you sure you want to remove them, keeping only the first occurrence of each?`)) {
        currentWorkingSchedule = deduplicatedSchedule;
        if (removeDuplicatesStatusMessage) {
            removeDuplicatesStatusMessage.textContent = `${removedCount} duplicate entries removed. Working schedule updated.`;
            removeDuplicatesStatusMessage.style.color = '#2ecc71'; 
        }
        alert(`${removedCount} duplicate entries removed.`);
        renderUIDependentElements(); 
        detectDuplicateEntries(); 
    } else {
        if (removeDuplicatesStatusMessage) {
            removeDuplicatesStatusMessage.textContent = "Operation cancelled by user.";
            removeDuplicatesStatusMessage.style.color = '#f1c40f'; 
        }
    }
}

// --- Utility Functions (Date, Sorting, Parsing etc.) ---
function parseLineName(lineNameStr) { const name = String(lineNameStr || "").toUpperCase().trim(); const numericPrefixRegex = new RegExp(/^(\d+)([A-Z]*)$/); const alphaNumericRegex = new RegExp(/^([A-Z]+)(\d+)?([A-Z]*)$/); const numericPrefixMatch = name.match(numericPrefixRegex); if (numericPrefixMatch) return { type: 'numeric', number: parseInt(numericPrefixMatch[1], 10), suffix: numericPrefixMatch[2] || '', original: name }; const alphaNumericMatch = name.match(alphaNumericRegex); if (alphaNumericMatch) return { type: 'alpha', prefix: alphaNumericMatch[1], number: alphaNumericMatch[2] ? parseInt(alphaNumericMatch[2], 10) : null, suffix: alphaNumericMatch[3] || '', original: name }; return { type: 'other', original: name }; }
function compareLineNames(lineAStr, lineBStr) { const parsedA = parseLineName(lineAStr); const parsedB = parseLineName(lineBStr); if (parsedA.type === 'numeric' && parsedB.type === 'alpha') return -1; if (parsedA.type === 'alpha' && parsedB.type === 'numeric') return 1; if (parsedA.type === 'numeric' && parsedB.type === 'numeric') { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type === 'alpha' && parsedB.type === 'alpha') { const prefixCompare = parsedA.prefix.localeCompare(parsedB.prefix); if (prefixCompare !== 0) return prefixCompare; if (parsedA.number === null && parsedB.number !== null) return -1; if (parsedA.number !== null && parsedB.number === null) return 1; if (parsedA.number !== null && parsedB.number !== null) { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; } return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type !== 'other' && parsedB.type === 'other') return -1; if (parsedA.type === 'other' && parsedB.type !== 'other') return 1; return (parsedA.original || "").localeCompare(parsedB.original || ""); }

// Moved generateUniqueStopId to global scope to be accessible by all functions needing it
function generateUniqueStopId(format) {
    const existingStopIDs = new Set(currentWorkingSchedule.map(entry => entry.stopID.toUpperCase()));
    let nextId = "";
    let currentNum = 0;
    let attempts = 0;
    const maxAttempts = 10000; 

    if (format === "NUM") {
        let maxNumeric = 100; 
        existingStopIDs.forEach(id => {
            if (/^\d+$/.test(id)) {
                const num = parseInt(id, 10);
                if (num >= 101 && num > maxNumeric) {
                    maxNumeric = num;
                }
            }
        });
        currentNum = maxNumeric + 1;
        while (attempts < maxAttempts) {
            nextId = String(currentNum);
            if (!existingStopIDs.has(nextId)) {
                return nextId;
            }
            currentNum++;
            attempts++;
            if (currentNum > 99999) break; 
        }
    } else if (["BP", "LE", "RO"].includes(format)) {
        const prefix = format;
        let maxPrefixNum = 0;
        existingStopIDs.forEach(id => {
            if (id.startsWith(prefix)) {
                const numPart = id.substring(prefix.length);
                if (/^\d+$/.test(numPart)) {
                    const num = parseInt(numPart, 10);
                    if (num > maxPrefixNum) {
                        maxPrefixNum = num;
                    }
                }
            }
        });
        currentNum = maxPrefixNum + 1;
        while (attempts < maxAttempts) {
            nextId = prefix + currentNum;
            if (!existingStopIDs.has(nextId.toUpperCase())) { 
                return nextId;
            }
            currentNum++;
            attempts++;
             if (currentNum > 99999) break; 
        }
    }
    console.warn("Could not generate a unique Stop ID for format:", format, "- Max limit may be reached or format not handled. Using fallback.");
    return format + String(Date.now()).slice(-5) + String(Math.floor(Math.random()*90)+10); 
}


function getOperatingCodesForToday_Tools() {
    const n = new Date();
    const dOW = n.getDay(); 
    const todayDateString = `${n.getFullYear()}-${String(n.getMonth() + 1).padStart(2, '0')}-${String(n.getDate()).padStart(2, '0')}`;
    let dateCodes = new Set(); 
    let isBankHolidayToday = false;

    if (ukBankHolidaysData && ukBankHolidaysData.dates && ukBankHolidaysData.dates.includes(todayDateString)) {
        const holidayTitle = ukBankHolidaysData.titles[todayDateString] || "";
        isBankHolidayToday = true;
        if (holidayTitle.toLowerCase().includes("good friday")) {
            dateCodes.add("Sa"); 
        } else {
            dateCodes.add("Su"); 
        }
    }

    if (!isBankHolidayToday) {
        const isSchHol = isSchoolHolidayPeriodForSetup(n); 
        const schoolSuffix = isSchHol ? "NSD" : "Sch"; 

        let dayCode = "";
        switch (dOW) {
            case 0: dayCode = "Su"; break; 
            case 1: dayCode = "Mo"; break; 
            case 2: dayCode = "Tu"; break; 
            case 3: dayCode = "We"; break; 
            case 4: dayCode = "Th"; break; 
            case 5: dayCode = "Fr"; break; 
            case 6: dayCode = "Sa"; break; 
        }
        dateCodes.add(dayCode); 

        if (dOW >= 1 && dOW <= 5) { 
            dateCodes.add(dayCode + schoolSuffix); 
            dateCodes.add("MF" + schoolSuffix); 
            dateCodes.add("Mo-Fr"); 
            dateCodes.add("MF"); 
        }
        if ((dOW === 6 || dOW === 0) && isSchHol) { 
             dateCodes.add(dayCode + "NSD"); 
        }

        if (isSchHol) {
            dateCodes.add("SchoolHoliday"); 
        }
    } else { 
        const isSchHolOnBH = isSchoolHolidayPeriodForSetup(n);
        if (isSchHolOnBH) {
            dateCodes.add("SchoolHoliday");
            if (dateCodes.has("Sa")) dateCodes.add("SaNSD"); 
            if (dateCodes.has("Su") && !dateCodes.has("Sa")) dateCodes.add("SuNSD"); 
        }
    }
    return Array.from(dateCodes);
}

async function fetchBankHolidaysForSetup() { try { const response = await fetch('https://www.gov.uk/bank-holidays.json'); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); if (data['england-and-wales'] && data['england-and-wales'].events) { const events = data['england-and-wales'].events; ukBankHolidaysData = { dates: events.map(event => event.date), titles: events.reduce((acc, event) => { acc[event.date] = event.title; return acc; }, {}) }; } else { console.warn("Setup: Bank holiday data not in expected format."); ukBankHolidaysData = { dates: [], titles: {} }; } } catch (error) { console.error("Setup: Failed to fetch UK bank holidays:", error); ukBankHolidaysData = { dates: [], titles: {} }; if(currentProfileDisplayElement) currentProfileDisplayElement.textContent = "Today's Auto Profile: (Bank Hol. check failed)"; } updateCurrentProfileDisplayOnSetup(); }
function isSchoolHolidayPeriodForSetup(dateObject) { if (!schoolHolidayDateRanges || schoolHolidayDateRanges.length === 0) return false; const checkTime = dateObject.getTime(); for (const range of schoolHolidayDateRanges) { try { const startTime = new Date(range.start + "T00:00:00").getTime(); const endTime = new Date(range.end + "T23:59:59").getTime(); if (checkTime >= startTime && checkTime <= endTime) return true; } catch (e) { console.error("Invalid date in schoolHolidayDateRanges (setup):", range, e); } } return false; }

function updateCurrentProfileDisplayOnSetup() {
    const now = new Date();
    const dayOfWeek = now.getDay(); 
    const todayDateString = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
    let profileDisplayText = "";
    let isBankHol = false;
    let serviceTypeDisplay = ""; 

    if (!ukBankHolidaysData || !ukBankHolidaysData.dates ) {
        if (currentProfileDisplayElement) currentProfileDisplayElement.textContent = "Today's Auto Profile: (determining bank holidays...)";
    }

    if (ukBankHolidaysData.dates && ukBankHolidaysData.dates.includes(todayDateString)) {
        const holidayTitle = ukBankHolidaysData.titles[todayDateString] || "Bank Holiday";
        isBankHol = true;
        if (holidayTitle.toLowerCase().includes("good friday")) {
            profileDisplayText = "Good Friday"; serviceTypeDisplay = "(Sat Service)";
        } else {
            profileDisplayText = holidayTitle; serviceTypeDisplay = "(Sun Service)";
        }
    }

    let dayName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][dayOfWeek];
    if (!isBankHol) {
        profileDisplayText = dayName;
        const isSchHol = isSchoolHolidayPeriodForSetup(now);
        if (isSchHol) profileDisplayText += " (School Hol)";
        else if (dayOfWeek >= 1 && dayOfWeek <= 5) profileDisplayText += " (School Term)"; 
    } else { 
        profileDisplayText += ` ${serviceTypeDisplay} - Observed on a ${dayName}`;
        const isSchHolOnBH = isSchoolHolidayPeriodForSetup(now); 
        if (isSchHolOnBH) profileDisplayText += " (School Hol Period)";
    }

    const operatingCodes = getOperatingCodesForToday_Tools();
    if (currentProfileDisplayElement) {
        currentProfileDisplayElement.textContent = `Today's Auto Profile: ${profileDisplayText} [Codes: ${operatingCodes.join(', ')}]`;
    }
}

// --- Form & Data Handling Functions ---
function isValidScheduleDataFromText(jsonData) { if (!jsonData || jsonData.length === 0) return false; const requiredColumns = ['StopID', 'StopName', 'Direction', 'LineName', 'DestinationName', 'ScheduledTime', 'OperatingProfile']; const firstEntry = jsonData[0]; const allColumnsPresent = requiredColumns.every(col => col in firstEntry); if (!allColumnsPresent) { const missingCols = requiredColumns.filter(col => !(col in firstEntry)); alert(`Uploaded .COUNT file is missing expected headers: ${missingCols.join(', ')}.\nExpected: StopID, StopName, Direction, LineName, DestinationName, ScheduledTime, OperatingProfile. Case matters.`); return false; } return true; }
function handleCountFileUpload(event) { const file = event.target.files[0]; if (file) { if (fileStatusElement) fileStatusElement.textContent = `Processing ${file.name}...`; setTimeout(() => { const reader = new FileReader(); reader.onload = function(e) { try { const fileContent = e.target.result; const lines = fileContent.split(/\r?\n/); if (lines.length < 2) { alert("File empty or no data (header + one entry needed)."); if (fileStatusElement) fileStatusElement.textContent = "File processing failed."; if (countFileInput) countFileInput.value = ""; return; } const headers = lines[0].split('\t').map(h => h.trim()); const jsonData = []; for (let i = 1; i < lines.length; i++) { const line = lines[i].trim(); if (line === "") continue; const values = line.split('\t').map(v => v.trim()); if (values.length < headers.length && values.every(v => v === "")) continue; if (values.length < headers.length && values.length > 0) { for(let k = values.length; k < headers.length; k++) { values.push(''); } } let entry = {}; headers.forEach((header, index) => { entry[header] = values[index] !== undefined ? values[index] : ""; }); jsonData.push(entry); } if (isValidScheduleDataFromText(jsonData)) { if (currentWorkingSchedule.length > 0 && !confirm("Replace current working schedule with this file?")) { if (fileStatusElement) fileStatusElement.textContent = "Upload cancelled."; if (countFileInput) countFileInput.value = ""; return; } currentWorkingSchedule = jsonData.map((row, index) => { let scheduledTime = String(row.ScheduledTime || "").trim(); if (scheduledTime.match(/^\d{1,2}:\d{2}(:\d{2})?$/)) { const parts = scheduledTime.split(':'); scheduledTime = `${String(parts[0]).padStart(2, '0')}:${String(parts[1]).padStart(2, '0')}`; } else if (scheduledTime.length === 4 && !scheduledTime.includes(':')) { scheduledTime = `${scheduledTime.substring(0,2)}:${scheduledTime.substring(2,4)}`; } else if (scheduledTime.length === 3 && !scheduledTime.includes(':')) { scheduledTime = `0${scheduledTime.substring(0,1)}:${scheduledTime.substring(1,3)}`; } return { internalId: `${String(row.StopID||'s').trim().toUpperCase()}_${String(row.LineName||'l').trim().toUpperCase()}_${scheduledTime.replace(':','')}_${index}_countfile`, stopID: String(row.StopID || "").trim().toUpperCase(), stopName: String(row.StopName || "").trim(), direction: String(row.Direction || "").trim(), lineName: String(row.LineName || "").trim().toUpperCase(), destinationName: String(row.DestinationName || "").trim(), scheduledTime: scheduledTime, OperatingProfile: String(row.OperatingProfile || "").trim(), DayOffset: String(row.DayOffset || "0").trim() }; }); renderUIDependentElements(); if (fileStatusElement) fileStatusElement.textContent = `${file.name} processed. ${currentWorkingSchedule.length} entries loaded.`; } else { if (fileStatusElement) fileStatusElement.textContent = "File processing failed: Invalid structure/headers."; } } catch (error) { console.error("Error processing .COUNT file:", error); alert(`Error: ${error.message}.`); if (fileStatusElement) fileStatusElement.textContent = "Error loading file."; } if (countFileInput) countFileInput.value = ""; }; reader.onerror = () => { alert("Could not read file."); if (fileStatusElement) fileStatusElement.textContent = "Error reading file."; if (countFileInput) countFileInput.value = ""; }; reader.readAsText(file); }, 50); } }
function handleBulkUpdateStopDetails() { if (!currentUser) { alert("Please log in."); return; } const targetStopID = bulkEditTargetStopIDInput.value.trim().toUpperCase(); const newStopName = bulkEditNewStopNameInput.value.trim(); const newDirection = bulkEditNewDirectionInput.value.trim(); if (!targetStopID) { alert("Target Stop ID required."); bulkEditTargetStopIDInput.focus(); return; } if (!newStopName && !newDirection) { alert("New Stop Name or Direction required."); return; } let updatedCount = 0; currentWorkingSchedule.forEach(entry => { if (entry.stopID && entry.stopID.toUpperCase() === targetStopID) { let entryChanged = false; if (newStopName) { entry.stopName = newStopName; entryChanged = true; } if (newDirection) { entry.direction = newDirection; entryChanged = true; } if (entryChanged) updatedCount++; } }); if (updatedCount > 0) { renderUIDependentElements(); alert(`${updatedCount} entries for Stop ID "${targetStopID}" updated.`); bulkEditNewStopNameInput.value = ''; bulkEditNewDirectionInput.value = ''; displayCurrentDetailsForBulkStopEdit(); } else { alert(`No entries found for Stop ID "${targetStopID}".`); } }
function handleBulkUpdateRouteDestination() { if (!currentUser) { alert("Please log in."); return; } const targetLineName = bulkEditTargetLineNameInput.value.trim().toUpperCase(); const oldDestination = bulkEditOldDestinationInput.value.trim(); const newDestination = bulkEditNewDestinationInput.value.trim(); if (!targetLineName) { alert("Target Line Name required."); bulkEditTargetLineNameInput.focus(); return; } if (!newDestination) { alert("New Destination Name required."); bulkEditNewDestinationInput.focus(); return; } let updatedCount = 0; currentWorkingSchedule.forEach(entry => { if (entry.lineName && entry.lineName.toUpperCase() === targetLineName) { if (oldDestination) { if (entry.destinationName && entry.destinationName.toLowerCase() === oldDestination.toLowerCase()) { entry.destinationName = newDestination; updatedCount++; } } else { entry.destinationName = newDestination; updatedCount++; } } }); if (updatedCount > 0) { renderUIDependentElements(); alert(`${updatedCount} entries for Line "${targetLineName}" updated to "${newDestination}".`); } else { alert(`No entries for Line "${targetLineName}"` + (oldDestination ? ` with Old Destination "${oldDestination}"` : "") + " found."); } }
function displayCurrentDetailsForBulkStopEdit() { const targetStopID = bulkEditTargetStopIDInput.value.trim().toUpperCase(); if (!targetStopID) { currentBulkEditStopNameDisplay.textContent = "-"; currentBulkEditDirectionDisplay.textContent = "-"; return; } const existingEntry = currentWorkingSchedule.find(entry => entry.stopID && entry.stopID.toUpperCase() === targetStopID); if (existingEntry) { currentBulkEditStopNameDisplay.textContent = existingEntry.stopName || "N/A"; currentBulkEditDirectionDisplay.textContent = existingEntry.direction || "N/A"; } else { currentBulkEditStopNameDisplay.textContent = "- Not found -"; currentBulkEditDirectionDisplay.textContent = "- Not found -"; } }

// --- Firebase Data Interaction ---
function handleStageSchedule() { if (!currentUser) { alert("Log in to stage."); return; } if (currentWorkingSchedule.length === 0 && !confirm("Working schedule empty. Stage empty schedule?")) { stagingStatusMessage.textContent = "Staging empty schedule cancelled."; stagingStatusMessage.style.color = "#e74c3c"; return; } let dataToStage = JSON.parse(JSON.stringify(currentWorkingSchedule)); dataToStage.sort((a, b) => { const lineCmp = compareLineNames(a.lineName, b.lineName); if (lineCmp !== 0) return lineCmp; const timeA = (a.scheduledTime || "").replace(':', ''); const timeB = (b.scheduledTime || "").replace(':', ''); const timeCmp = timeA.localeCompare(timeB); if (timeCmp !== 0) return timeCmp; return (a.stopID || "").localeCompare(b.stopID || ""); }); const finalScheduleData = dataToStage.map((entry, index) => ({ ...entry, internalId: entry.internalId || `${entry.stopID.toUpperCase()}_${entry.lineName.toUpperCase()}_${(entry.scheduledTime||"").replace(':','')}_${index}_staged` })); const stopsMap = new Map(); finalScheduleData.forEach(row => { if (row.stopID && !stopsMap.has(row.stopID)) { stopsMap.set(row.stopID, { stopID: row.stopID, stopName: row.stopName, direction: row.direction }); } }); const finalUniqueStops = Array.from(stopsMap.values()).sort((a,b)=>{ const nC=(a.stopName||"").localeCompare(b.stopName||""); return nC!==0?nC:(a.direction||"").localeCompare(b.direction||""); }); if (window.firebaseOMSI) { const { database, dbUpdate, dbRef } = window.firebaseOMSI; const updates = {}; updates[FB_PATH_PENDING_SCHEDULE_DATA] = finalScheduleData; updates[FB_PATH_PENDING_UNIQUE_STOPS] = finalUniqueStops; updates[FB_PATH_PENDING_TIMESTAMP] = new Date().toISOString(); updates[FB_PATH_APPSTATE_STATUS] = 'update_staged'; dbUpdate(dbRef(database), updates) .then(() => { alert("Schedule STAGED to Firebase."); updateStagingStatusDisplay(); }) .catch((e) => { console.error("FB Staging Error: ", e); alert("FB Staging Error. Check console."); if(stagingStatusMessage) { stagingStatusMessage.textContent = "FB Staging Error."; stagingStatusMessage.style.color = "#e74c3c"; } }); } else { alert("Firebase not available."); } }
function handleApplyNow() { if (!currentUser) { alert("Log in to apply."); return; } if (window.firebaseOMSI) { const { database, dbGet, dbUpdate, dbRef, dbChild } = window.firebaseOMSI; dbGet(dbChild(dbRef(database), '/pendingSchedule')) .then((snapshot) => { if (snapshot.exists()) { const pendingData = snapshot.val(); if (!confirm("Apply Firebase staged schedule LIVE NOW?")) { if (stagingStatusMessage) { stagingStatusMessage.textContent = "Apply cancelled."; stagingStatusMessage.style.color = "#e74c3c"; } return; } let liveAllScheduledBusData = Array.isArray(pendingData.allScheduledBusData) ? pendingData.allScheduledBusData.filter(item => item != null) : (typeof pendingData.allScheduledBusData === 'object' && pendingData.allScheduledBusData !== null ? Object.values(pendingData.allScheduledBusData).filter(item => item != null) : []); let liveUniqueBusStops = Array.isArray(pendingData.uniqueBusStops) ? pendingData.uniqueBusStops.filter(item => item != null) : (typeof pendingData.uniqueBusStops === 'object' && pendingData.uniqueBusStops !== null ? Object.values(pendingData.uniqueBusStops).filter(item => item != null) : []); let hasInvalidKey = false; function check(obj, path) { if (typeof obj !== 'object' || obj === null) return; for (const key in obj) { if (/[.#$/\[\]]/.test(key)) { console.error(`INVALID KEY at ${path}: key='${key}'`); hasInvalidKey = true; } if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) { check(obj[key], `${path}.${key}`); } } } liveAllScheduledBusData.forEach((item, i) => { if (typeof item !== 'object' || item === null) { hasInvalidKey = true; return; } check(item, `schedule[${i}]`); }); liveUniqueBusStops.forEach((item, i) => { if (typeof item !== 'object' || item === null) { hasInvalidKey = true; return; } check(item, `stops[${i}]`); }); if (hasInvalidKey) { alert("Invalid keys in data. Cannot apply. Check console."); return; } const liveUpdates = {}; liveUpdates[FB_PATH_LIVE_SCHEDULE_DATA] = liveAllScheduledBusData; liveUpdates[FB_PATH_LIVE_UNIQUE_STOPS] = liveUniqueBusStops; dbUpdate(dbRef(database), liveUpdates) .then(() => { const appUpdates = {}; appUpdates[FB_PATH_APPSTATE_LAST_UPDATED] = new Date().toISOString(); appUpdates[FB_PATH_APPSTATE_STATUS] = 'idle'; appUpdates['/pendingSchedule'] = null; return dbUpdate(dbRef(database), appUpdates); }) .then(() => { alert("Staged schedule APPLIED LIVE!"); updateStagingStatusDisplay(); }) .catch(e => { console.error("FB Apply Error: ", e); alert("FB Apply Error. Check console: " + e.message); }); } else { alert("No Firebase staged schedule to apply."); if (stagingStatusMessage) { stagingStatusMessage.textContent = "No FB staged schedule."; stagingStatusMessage.style.color = "#e74c3c"; } } }).catch(e => { console.error("FB Fetch Pending Error: ", e); alert("FB Fetch Pending Error. Check console: " + e.message); }); } else { alert("Firebase not available."); } }
async function loadInitialData() {
    console.log("Tools: Loading initial data from Firebase...");
    let msg = "Loading data...";
    if (fileStatusElement) fileStatusElement.textContent = msg;
    currentWorkingSchedule = [];
    closedStopIDs = [];
    customRouteColours = {};

    if (!window.firebaseOMSI) {
        msg = "Firebase not connected.";
    } else {
        const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
        try {
            const liveSnap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_SCHEDULE_DATA));
            if (liveSnap.exists() && Array.isArray(liveSnap.val())) {
                currentWorkingSchedule = liveSnap.val().map((e, i) => ({ ...e, internalId: e.internalId || `${(e.stopID||'s')}_${(e.lineName||'l')}_${(e.scheduledTime||"").replace(':','')}_${i}_fb` }));
            }
            const closedSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_CLOSED_STOPS));
            if (closedSnap.exists()) {
                const fbClosed = closedSnap.val();
                for (const id in fbClosed) { if (fbClosed[id] === true) closedStopIDs.push(id); }
            }
            const coloursSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_CUSTOM_COLOURS));
            if (coloursSnap.exists()) customRouteColours = coloursSnap.val();
            msg = `Data loaded from Firebase. ${currentWorkingSchedule.length} entries.`;
        } catch (e) {
            console.error("FB Load Error:", e);
            msg = "FB Load Error. Check console.";
        }
    }
    if (fileStatusElement) fileStatusElement.textContent = msg;
    loadAndApplyCustomRouteColoursForTools();
    renderUIDependentElements(); 
    updateStagingStatusDisplay();
    fetchBankHolidaysForSetup(); 
}
async function updateStagingStatusDisplay() { let pTime = null; let lTime = null; let fbStatus = "Checking..."; if (window.firebaseOMSI) { const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const pSnap = await dbGet(dbChild(dbRef(database), FB_PATH_PENDING_TIMESTAMP)); if (pSnap.exists()) pTime = pSnap.val(); const lSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_LAST_UPDATED)); if (lSnap.exists()) lTime = lSnap.val(); const sSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_STATUS)); const currentFbSt = sSnap.exists() ? sSnap.val() : 'unknown'; fbStatus = `Firebase status: ${currentFbSt}.`; applyNowButton.disabled = !(currentFbSt === 'update_staged' && pTime); } catch (e) { fbStatus = "FB Status Error."; console.error(fbStatus, e); applyNowButton.disabled = true;} } else { fbStatus = "Firebase not available."; applyNowButton.disabled = true;} let msg = ""; if (pTime && applyNowButton.disabled === false) { msg = `STAGED on: ${new Date(pTime).toLocaleString()}.<br>Ready to 'Apply Staged Live NOW'.`; if(stagingStatusMessage) stagingStatusMessage.style.color = "#2ecc71"; } else { msg = "No schedule staged. Changes can be staged."; if(stagingStatusMessage) stagingStatusMessage.style.color = "#f1c40f"; } msg += lTime ? `<br>LIVE schedule last updated: ${new Date(lTime).toLocaleString()}` : "<br>No LIVE schedule set yet."; msg += `<br><small>(${fbStatus})</small>`; if(stagingStatusMessage) stagingStatusMessage.innerHTML = msg; }
function saveClosedStops() { if (!currentUser) return; if (window.firebaseOMSI) { const { database, dbSet, dbRef } = window.firebaseOMSI; const fbClosed = {}; closedStopIDs.forEach(id => fbClosed[id] = true); dbSet(dbRef(database, FB_PATH_APPSTATE_CLOSED_STOPS), fbClosed) .then(() => dbSet(dbRef(database, FB_PATH_APPSTATE_LAST_UPDATED), new Date().toISOString())) .catch(e => console.error("FB Save Closed Stops Error: ", e)); } }
function saveCustomRouteColours() { if (!currentUser) return; if (window.firebaseOMSI) { const { database, dbSet, dbRef } = window.firebaseOMSI; dbSet(dbRef(database, FB_PATH_SETTINGS_CUSTOM_COLOURS), customRouteColours) .then(() => dbSet(dbRef(database, FB_PATH_APPSTATE_LAST_UPDATED), new Date().toISOString())) .catch(e => console.error("FB Save Colours Error: ", e)); } if (routeColourStatusMessage) { routeColourStatusMessage.textContent = 'Custom colours saved.'; setTimeout(() => { if(routeColourStatusMessage) routeColourStatusMessage.textContent = ''; }, 3000); } loadAndApplyCustomRouteColoursForTools(); if(selectStopForDeparturesView && selectStopForDeparturesView.value) displayDeparturesForSelectedStop(); renderCustomRouteColours(); }

// --- UI Population & Rendering ---
function renderUIDependentElements() {
    if(currentUser) { 
        populateRouteSelectorForEvents();
        populateStopStatusSelector();
        populateRouteSelectorForColours();
        populateStopSelectorForDeparturesView(); 
        renderCustomRouteColours();
        populateStopToRemoveSelector_ARS(); 

        const activeSection = localStorage.getItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        if (activeSection) {
            const sectionElement = document.getElementById(activeSection);
            if (sectionElement && sectionElement.style.display === 'block') {
                showSection(activeSection); 
            }
        }
    }
}


function populateRouteSelectorForEvents() { if (!selectEventRoute) return; const currentVal = selectEventRoute.value; selectEventRoute.innerHTML = '<option value="">-- Select Route --</option>'; const uniqueLines = [...new Set(currentWorkingSchedule.map(e => e.lineName))].filter(Boolean).sort(compareLineNames); uniqueLines.forEach(ln => { const opt = document.createElement('option'); opt.value = ln; opt.textContent = ln; selectEventRoute.appendChild(opt); }); selectEventRoute.value = uniqueLines.includes(currentVal) ? currentVal : ""; populateImpactStopSelector(); }
function populateImpactStopSelector() { if (!selectEventImpactStop || !selectEventRoute) return; const selRoute = selectEventRoute.value; const currentVal = selectEventImpactStop.value; selectEventImpactStop.innerHTML = '<option value="">-- Route Wide / Not Applicable --</option>'; if (selRoute) { const stops = currentWorkingSchedule.filter(e => e.lineName === selRoute).map(e => ({ id: e.stopID, name: e.stopName, time: e.scheduledTime })).sort((a,b) => (a.time||"").localeCompare(b.time||"")); const uniqueStops = []; const seen=new Set(); stops.forEach(s => { if (s.id && !seen.has(s.id)) { uniqueStops.push(s); seen.add(s.id); }}); uniqueStops.forEach(s => { const opt = document.createElement('option'); opt.value = s.id; opt.textContent = `${s.stopName || s.id} (${s.id})`; selectEventImpactStop.appendChild(opt); }); selectEventImpactStop.value = seen.has(currentVal) ? currentVal : ""; } }
async function populateStopStatusSelector() { if (!selectStopForStatusChange || !window.firebaseOMSI) return; const currentVal = selectStopForStatusChange.value; selectStopForStatusChange.innerHTML = '<option value="">-- Select Stop --</option>'; const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const snap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_UNIQUE_STOPS)); let stops = []; if (snap.exists() && Array.isArray(snap.val()) && snap.val().length > 0) { stops = snap.val(); } else { stops = getUniqueStopsFromSchedule(); } stops.sort((a,b) => (a.stopName||"").localeCompare(b.stopName||"")); stops.forEach(s => { if(!s || !s.stopID) return; const opt = document.createElement('option'); opt.value = s.stopID; const isClosed = closedStopIDs.includes(s.stopID); opt.textContent = `${s.stopName||s.stopID} (${s.stopID})${isClosed?' (Closed)':''}`; selectStopForStatusChange.appendChild(opt); }); selectStopForStatusChange.value = currentVal && stops.find(s => s && s.stopID === currentVal) ? currentVal : ""; } catch (e) {console.error("Error populating stop status selector", e)} }
function handleStopStatusChange(action) { if (!currentUser) return; const stopID = selectStopForStatusChange.value; if (!stopID) { stopStatusMessage.textContent = "Select a stop."; return; } const idx = closedStopIDs.indexOf(stopID); const name = selectStopForStatusChange.options[selectStopForStatusChange.selectedIndex].text.split(' (')[0]; if (action === 'close') { if (idx === -1) { closedStopIDs.push(stopID); stopStatusMessage.textContent = `Stop '${name}' closed.`; } else { stopStatusMessage.textContent = `Stop '${name}' already closed.`; } } else if (action === 'reopen') { if (idx !== -1) { closedStopIDs.splice(idx, 1); stopStatusMessage.textContent = `Stop '${name}' reopened.`; } else { stopStatusMessage.textContent = `Stop '${name}' not closed.`; } } saveClosedStops(); populateStopStatusSelector(); }

function applyRandomEvent() {
    if (!currentUser) {
        if(eventStatusMessage) { eventStatusMessage.textContent = "Please log in."; eventStatusMessage.style.color = '#e74c3c'; }
        return;
    }
    const selRoute = selectEventRoute.value;
    const impactStopID = selectEventImpactStop.value;
    let selectedStopName = "Route Wide";
    if (impactStopID && selectEventImpactStop.options.length > 0 && selectEventImpactStop.selectedIndex >= 0 && selectEventImpactStop.options[selectEventImpactStop.selectedIndex].value !== "") {
        const selectedOptionText = selectEventImpactStop.options[selectEventImpactStop.selectedIndex].text;
        selectedStopName = selectedOptionText.includes('(') ? selectedOptionText.split(' (')[0] : selectedOptionText;
    } else if (!impactStopID) { 
         selectedStopName = "the start of its route"; 
    }

    if (!selRoute) {
        if(eventStatusMessage) { eventStatusMessage.textContent = "Please select a route."; eventStatusMessage.style.color = '#e74c3c'; }
        return;
    }
    const predefinedEvents = [ { name: `Severe Delays on Route ${selRoute}`, type: "LOG_DELAY_ROUTE", baseDetails: `Route ${selRoute} is experiencing severe delays (simulated +%DELAY% mins) due to a major incident.`, minDelay: 15, maxDelay: 20 }, { name: `Minor Delays on ${selRoute} from ${selectedStopName}`, type: "LOG_DELAY_FROM_STOP", condition: true, baseDetails: `Route ${selRoute} is experiencing minor delays (simulated +%DELAY% mins) from ${selectedStopName} onwards due to congestion.`, minDelay: 5, maxDelay: 10 }, { name: `Route ${selRoute} Curtailed to Town Centre`, type: "LOG_CURTAIL", curtailToStopName: "Town Centre", baseDetails: `Route ${selRoute} services are now terminating at Town Centre due to an obstruction. (Simulated)` }, { name: `Route ${selRoute} Curtailed to Bus Station`, type: "LOG_CURTAIL", curtailToStopName: "Bus Station", baseDetails: `Route ${selRoute} services are now terminating at Bus Station due to a police incident. (Simulated)` } ];
    let applicableEvents = predefinedEvents.filter(event => { return true; }); 
    if (applicableEvents.length === 0) {
        if(eventStatusMessage) { eventStatusMessage.textContent = "No predefined applicable events for this specific selection."; eventStatusMessage.style.color = '#f1c40f'; }
        return;
    }
    const choice = applicableEvents[Math.floor(Math.random() * applicableEvents.length)];
    let eventDetailsText = choice.baseDetails || choice.name;
    switch (choice.type) {
        case "LOG_DELAY_ROUTE": case "LOG_DELAY_FROM_STOP": const delay = Math.floor(Math.random() * (choice.maxDelay - choice.minDelay + 1)) + choice.minDelay; eventDetailsText = eventDetailsText.replace('%DELAY%', delay); break;
        case "LOG_CURTAIL": break; 
        default: console.warn("Unknown event type in predefinedEvents:", choice.type);
    }
    if(eventStatusMessage) { eventStatusMessage.textContent = `SIMULATED EVENT: ${eventDetailsText}`; eventStatusMessage.style.color = '#3498db'; }
}

function loadAndApplyCustomRouteColoursForTools() { effectiveRouteColourMapTools = { ...initialRouteColourMapForTools, ...customRouteColours }; }
function renderCustomRouteColours() { if (!currentRouteColoursList || !noCustomColoursMessage) return; currentRouteColoursList.innerHTML = ''; const routes = [...new Set(currentWorkingSchedule.map(e => e.lineName))].filter(Boolean).sort(compareLineNames); if (routes.length === 0) { noCustomColoursMessage.textContent = 'No routes in working schedule.'; noCustomColoursMessage.style.display = 'block'; return; } noCustomColoursMessage.style.display = 'none'; routes.forEach(rName => { const upName = rName.toUpperCase(); const isCustom = customRouteColours.hasOwnProperty(upName); const color = isCustom ? customRouteColours[upName] : DEFAULT_ROUTE_COLOUR_TOOLS; const li = document.createElement('li'); const box = document.createElement('span'); box.className = 'colour-preview-box'; box.style.backgroundColor = color; const info = document.createElement('span'); info.className = 'route-info'; info.innerHTML = `Route: ${rName} - Colour: ${color.toUpperCase()}${isCustom?"":` <small style="opacity:0.7;">(Default)</small>`}`; const actions = document.createElement('div'); actions.style.marginLeft = 'auto'; if (isCustom) { const btn = document.createElement('button'); btn.textContent = 'Remove'; btn.classList.add('button','small-action','secondary'); btn.onclick=()=>handleRemoveRouteColour(upName); actions.appendChild(btn); } li.appendChild(box); li.appendChild(info); li.appendChild(actions); currentRouteColoursList.appendChild(li); }); }
function populateRouteSelectorForColours() { if (!selectRouteNameColour) return; const currentVal = selectRouteNameColour.value; selectRouteNameColour.innerHTML = '<option value="">-- Select Route --</option>'; const lines = [...new Set(currentWorkingSchedule.map(e => e.lineName))].filter(Boolean).sort(compareLineNames); lines.forEach(ln => { const opt = document.createElement('option'); opt.value = ln; opt.textContent = ln; selectRouteNameColour.appendChild(opt); }); if (lines.includes(currentVal)) selectRouteNameColour.value = currentVal; selectRouteNameColour.dispatchEvent(new Event('change')); }
function handleSaveRouteColour() { if (!currentUser) return; if (!selectRouteNameColour || !inputRouteColour || !routeColourStatusMessage) return; const rName = selectRouteNameColour.value; const color = inputRouteColour.value; if (!rName) { routeColourStatusMessage.textContent = 'Select route name.'; routeColourStatusMessage.style.color = '#e74c3c'; return; } if (!color.match(/^#[0-9a-fA-F]{6}$/)) { routeColourStatusMessage.textContent = 'Invalid hex colour (e.g., #RRGGBB).'; routeColourStatusMessage.style.color = '#e74c3c'; return; } customRouteColours[rName.toUpperCase()] = color.toUpperCase(); saveCustomRouteColours(); }
function handleRemoveRouteColour(key) { if (!currentUser) return; if (customRouteColours.hasOwnProperty(key) && confirm(`Remove custom colour for route ${key}?`)) { delete customRouteColours[key]; saveCustomRouteColours(); if (selectRouteNameColour.value.toUpperCase() === key) inputRouteColour.value = DEFAULT_ROUTE_COLOUR_TOOLS; } }
function getRouteTileColourForTools(lineName) { const upName = String(lineName||"").toUpperCase(); if(effectiveRouteColourMapTools[upName]) return effectiveRouteColourMapTools[upName]; if(upName.startsWith("N")) return effectiveRouteColourMapTools["N5"]||DEFAULT_ROUTE_COLOUR_TOOLS; if(upName.startsWith("SL")) return effectiveRouteColourMapTools["SL1"]||DEFAULT_ROUTE_COLOUR_TOOLS; return DEFAULT_ROUTE_COLOUR_TOOLS;}
function getTextColourForBackgroundTools(hex) { if(!hex||hex.length<7)return'#FFFFFF'; const r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16); return((0.299*r+0.587*g+0.114*b)/255)>0.5?'#000000':'#FFFFFF';}
function getDaySortOrder(profile) { if(!profile)return 99;const p=profile.toUpperCase().split(',').map(s=>s.trim());if(p.some(s=>s.startsWith("MO")&&!s.startsWith("MO-FR")))return 1;if(p.some(s=>s.startsWith("TU")))return 2;if(p.some(s=>s.startsWith("WE")))return 3;if(p.some(s=>s.startsWith("TH")))return 4;if(p.some(s=>s.startsWith("FR")&&!s.startsWith("MO-FR")))return 5;if(p.some(s=>s.startsWith("MF")||s.startsWith("MO-FR")))return 6;if(p.some(s=>s.startsWith("SA")))return 7;if(p.some(s=>s.startsWith("SU")))return 8;if(p.includes("GOODFRIDAY"))return 10;if(p.includes("BANKHOLIDAY"))return 11; return 99;}
function populateStopSelectorForDeparturesView() { if (!selectStopForDeparturesView) return; const currentVal = selectStopForDeparturesView.value; selectStopForDeparturesView.innerHTML = '<option value="">-- Select Stop --</option>'; if (currentWorkingSchedule.length === 0) { displayDeparturesForSelectedStop(); return; } const stopsMap = new Map(); currentWorkingSchedule.forEach(e => { if (e.stopID && !stopsMap.has(e.stopID)) stopsMap.set(e.stopID, { stopID: e.stopID, stopName: e.stopName || e.stopID }); }); const sorted = Array.from(stopsMap.values()).sort((a,b)=>(a.stopName.toLowerCase()).localeCompare(b.stopName.toLowerCase())); sorted.forEach(s => { const opt = document.createElement('option'); opt.value = s.stopID; opt.textContent = `${s.stopName} (${s.stopID})`; selectStopForDeparturesView.appendChild(opt); }); if (stopsMap.has(currentVal)) selectStopForDeparturesView.value = currentVal; displayDeparturesForSelectedStop(); }

function displayDeparturesForSelectedStop() {
    if (!selectStopForDeparturesView || !stopDeparturesList || !noDeparturesForStopMessage) return;
    const selStopID = selectStopForDeparturesView.value;
    stopDeparturesList.innerHTML = '';

    if (!selStopID) {
        noDeparturesForStopMessage.textContent = 'Select stop to view.';
        noDeparturesForStopMessage.style.display = 'block';
        return;
    }

    const deps = currentWorkingSchedule
        .filter(e => e.stopID === selStopID)
        .sort((a, b) => {
            const offsetA = parseInt(a.DayOffset || "0", 10);
            const offsetB = parseInt(b.DayOffset || "0", 10);
            if (offsetA !== offsetB) return offsetA - offsetB;

            const dayA = getDaySortOrder(a.OperatingProfile);
            const dayB = getDaySortOrder(b.OperatingProfile);
            if (dayA !== dayB) return dayA - dayB;

            const timeA = (a.scheduledTime || "9999").replace(':', '');
            const timeB = (b.scheduledTime || "9999").replace(':', '');
            if (timeA !== timeB) return timeA.localeCompare(timeB);

            const lineComp = compareLineNames(a.lineName, b.lineName);
            if (lineComp !== 0) return lineComp;

            return (a.OperatingProfile || "").localeCompare(b.OperatingProfile || "");
        });

    if (deps.length === 0) {
        noDeparturesForStopMessage.textContent = 'No departures for this stop.';
        noDeparturesForStopMessage.style.display = 'block';
    } else {
        noDeparturesForStopMessage.style.display = 'none';
        deps.forEach(d => {
            const li = document.createElement('li');
            const tile = document.createElement('span');
            tile.className = 'route-tile-tools-list';
            tile.textContent = d.lineName || 'N/A';
            const bg = getRouteTileColourForTools(d.lineName);
            tile.style.backgroundColor = bg;
            tile.style.color = getTextColourForBackgroundTools(bg);

            const span = document.createElement('span');
            span.innerHTML = ` to ${d.destinationName || 'Unknown'} <strong style="margin-left:0.5em;">at ${d.scheduledTime || 'N/A'}</strong> <small style="opacity:0.7;margin-left:0.75em;">(Profile: ${d.OperatingProfile || 'N/A'})</small>${d.DayOffset && d.DayOffset !== "0" ? `<small style="opacity:0.7;margin-left:0.3em;color:#FFD700;">(+${d.DayOffset}d)</small>` : ''}`;

            li.appendChild(tile);
            li.appendChild(span);
            stopDeparturesList.appendChild(li);
        });
    }
}

// --- Stop Management Tool Functions ---
function getUniqueStopsFromSchedule() { 
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) return [];
    const stopsMap = new Map();
    currentWorkingSchedule.forEach(entry => { 
        if (entry.stopID && !stopsMap.has(entry.stopID.toUpperCase())) {
            stopsMap.set(entry.stopID.toUpperCase(), {
                stopID: entry.stopID, 
                stopName: entry.stopName || "Unknown Name",
                direction: entry.direction || "No Direction"
            });
        }
    });
    return Array.from(stopsMap.values()).sort((a, b) => (String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase()));
}


function populateMasterStopList_SM() {
    if (!masterStopListUL_SM || !masterStopListStatus_SM) return;
    uniqueStopsMasterList_SM = getUniqueStopsFromSchedule(); 
    const filterText = masterStopListFilterInput_SM.value.toLowerCase();
    masterStopListUL_SM.innerHTML = ''; 
    let displayedCount = 0;

    if (uniqueStopsMasterList_SM.length === 0) {
        masterStopListStatus_SM.textContent = 'No unique stops found in the current working schedule.';
        return;
    }

    uniqueStopsMasterList_SM.forEach(stop => {
        if (!stop || !stop.stopID) return; 
        const stopIdLower = stop.stopID.toLowerCase();
        const stopNameLower = (stop.stopName || "").toLowerCase();
        const stopDirectionLower = (stop.direction || "").toLowerCase();

        const matchesFilter = !filterText ||
                            stopIdLower.includes(filterText) ||
                            stopNameLower.includes(filterText) ||
                            stopDirectionLower.includes(filterText);

        if (matchesFilter) {
            displayedCount++;
            const li = document.createElement('li');
            li.innerHTML = `<span class="stop-id-master">${stop.stopID}</span><br>
                            <span class="stop-name-master">${stop.stopName}</span><br>
                            <span class="stop-direction-master">Towards: ${stop.direction}</span>`;
            li.dataset.stopid = stop.stopID;
            li.dataset.stopname = stop.stopName;
            li.dataset.direction = stop.direction;
            masterStopListUL_SM.appendChild(li);
        }
    });

    if (displayedCount === 0 && uniqueStopsMasterList_SM.length > 0) {
        masterStopListStatus_SM.textContent = 'No stops match your filter.';
    } else {
        masterStopListStatus_SM.textContent = `Showing ${displayedCount} of ${uniqueStopsMasterList_SM.length} unique stops.`;
    }
}

function handleFindReplaceStopIdInSchedule_SM() {
    if (!currentUser) { alert("Please log in."); return; }
    const findStopID = findStopIdScheduleInput_SM.value.trim().toUpperCase();
    const replaceStopID = replaceStopIdScheduleInput_SM.value.trim().toUpperCase();

    if (!findStopID || !replaceStopID) {
        findReplaceStatusMessage_SM.textContent = "Both 'Stop ID to Find' and 'Replace with New Stop ID' are required.";
        findReplaceStatusMessage_SM.style.color = '#e74c3c';
        return;
    }
    if (findStopID === replaceStopID) {
        findReplaceStatusMessage_SM.textContent = "Find and Replace Stop IDs cannot be the same.";
        findReplaceStatusMessage_SM.style.color = '#f1c40f';
        return;
    }

    if (!confirm(`Are you sure you want to replace ALL occurrences of Stop ID "${findStopID}" with "${replaceStopID}" in the working schedule? This action cannot be undone easily.`)) {
        findReplaceStatusMessage_SM.textContent = "Find and replace operation cancelled.";
        findReplaceStatusMessage_SM.style.color = '#7f8c8d';
        return;
    }

    let replacedCount = 0;
    let newNameForReplaced = "";
    let newDirectionForReplaced = "";
    
    const existingNewStopEntry = currentWorkingSchedule.find(e => e.stopID.toUpperCase() === replaceStopID);
    if (existingNewStopEntry) {
        newNameForReplaced = existingNewStopEntry.stopName;
        newDirectionForReplaced = existingNewStopEntry.direction;
    } else {
        const oldStopDetails = currentWorkingSchedule.find(e => e.stopID.toUpperCase() === findStopID);
        if (oldStopDetails) {
             newNameForReplaced = oldStopDetails.stopName; 
             newDirectionForReplaced = oldStopDetails.direction;
             console.warn(`Details for new Stop ID "${replaceStopID}" not found. Using details from old Stop ID "${findStopID}".`);
        } else {
            console.warn(`Details for both new Stop ID "${replaceStopID}" and old Stop ID "${findStopID}" not found. Replaced entries might require manual name/direction update.`);
        }
    }

    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && entry.stopID.toUpperCase() === findStopID) {
            entry.stopID = replaceStopID; 
            if (newNameForReplaced) entry.stopName = newNameForReplaced;
            if (newDirectionForReplaced) entry.direction = newDirectionForReplaced;
            replacedCount++;
        }
    });

    if (replacedCount > 0) {
        renderUIDependentElements(); 
        findReplaceStatusMessage_SM.textContent = `Replaced ${replacedCount} occurrences of "${findStopID}" with "${replaceStopID}".`;
        if (newNameForReplaced || newDirectionForReplaced) {
            findReplaceStatusMessage_SM.textContent += ` Name/Direction for "${replaceStopID}" updated to: "${newNameForReplaced || '(name not set)'}" / "${newDirectionForReplaced || '(direction not set)'}".`;
        }
        findReplaceStatusMessage_SM.style.color = '#2ecc71';
        findStopIdScheduleInput_SM.value = ''; 
        replaceStopIdScheduleInput_SM.value = '';
    } else {
        findReplaceStatusMessage_SM.textContent = `No occurrences of Stop ID "${findStopID}" found in the working schedule.`;
        findReplaceStatusMessage_SM.style.color = '#f1c40f';
    }
}

function populateRoutesForStopSelector_SM() {
    if (!routesForStopSelect_SM) return;
    const currentVal = routesForStopSelect_SM.value;
    routesForStopSelect_SM.innerHTML = '<option value="">-- Select Stop --</option>';
    
    const uniqueStops = getUniqueStopsFromSchedule(); 

    if (uniqueStops.length === 0) {
        if (routesServingStopStatus_SM) routesServingStopStatus_SM.textContent = 'No stops in working schedule to select from.';
        displayRoutesServingSelectedStop_SM(); 
        return;
    }

    uniqueStops.forEach(stop => {
        const opt = document.createElement('option');
        opt.value = stop.stopID;
        opt.textContent = `${stop.stopName} (${stop.stopID})`; 
        routesForStopSelect_SM.appendChild(opt);
    });

    if (uniqueStops.find(s => s.stopID === currentVal)) {
        routesForStopSelect_SM.value = currentVal;
    }
    displayRoutesServingSelectedStop_SM(); 
}

function displayRoutesServingSelectedStop_SM() {
    if (!routesForStopSelect_SM || !routesServingStopList_SM || !routesServingStopStatus_SM) return;
    const selectedStopID = routesForStopSelect_SM.value;
    routesServingStopList_SM.innerHTML = ''; 

    if (!selectedStopID) {
        routesServingStopStatus_SM.textContent = 'Select a stop to view its serving routes.';
        return;
    }

    const servingRoutes = new Set();
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && entry.stopID.toUpperCase() === selectedStopID.toUpperCase() && entry.lineName) {
            servingRoutes.add(entry.lineName);
        }
    });

    const sortedRoutes = Array.from(servingRoutes).sort(compareLineNames);

    if (sortedRoutes.length === 0) {
        routesServingStopStatus_SM.textContent = `No routes found serving stop ${selectedStopID} in the current schedule.`;
    } else {
        const selectedStopDisplayInfo = routesForStopSelect_SM.options[routesForStopSelect_SM.selectedIndex]?.text || selectedStopID;
        routesServingStopStatus_SM.textContent = `Serving routes for ${selectedStopDisplayInfo}:`;
        sortedRoutes.forEach(lineName => {
            const li = document.createElement('li');
            const tile = document.createElement('span');
            tile.className = 'route-tile-tools-list';
            tile.textContent = lineName;
            const bgColor = getRouteTileColourForTools(lineName); 
            tile.style.backgroundColor = bgColor;
            tile.style.color = getTextColourForBackgroundTools(bgColor); 

            li.appendChild(tile);
            routesServingStopList_SM.appendChild(li);
        });
    }
}

// --- START: Functions for "Add/Remove Stop Details" section ---
function generateUniqueStopId(format) { // Ensure this is globally accessible
    const existingStopIDs = new Set(currentWorkingSchedule.map(entry => entry.stopID.toUpperCase()));
    let nextId = "";
    let currentNum = 0;
    let attempts = 0;
    const maxAttempts = 10000;

    if (format === "NUM") {
        let maxNumeric = 100;
        existingStopIDs.forEach(id => {
            if (/^\d+$/.test(id)) {
                const num = parseInt(id, 10);
                if (num >= 101 && num > maxNumeric) {
                    maxNumeric = num;
                }
            }
        });
        currentNum = maxNumeric + 1;
        while (attempts < maxAttempts) {
            nextId = String(currentNum);
            if (!existingStopIDs.has(nextId)) {
                return nextId;
            }
            currentNum++;
            attempts++;
            if (currentNum > 99999) break;
        }
    } else if (["BP", "LE", "RO"].includes(format)) {
        const prefix = format;
        let maxPrefixNum = 0;
        existingStopIDs.forEach(id => {
            if (id.startsWith(prefix)) {
                const numPart = id.substring(prefix.length);
                if (/^\d+$/.test(numPart)) {
                    const num = parseInt(numPart, 10);
                    if (num > maxPrefixNum) {
                        maxPrefixNum = num;
                    }
                }
            }
        });
        currentNum = maxPrefixNum + 1;
        while (attempts < maxAttempts) {
            nextId = prefix + currentNum;
            if (!existingStopIDs.has(nextId.toUpperCase())) {
                return nextId;
            }
            currentNum++;
            attempts++;
             if (currentNum > 99999) break;
        }
    }
    console.warn("Could not generate a unique Stop ID for format:", format, "- Max limit may be reached or format not handled. Using fallback.");
    return format + String(Date.now()).slice(-5) + String(Math.floor(Math.random()*90)+10); 
}


function handleSuggestStopId_ARS() { 
    if (!currentUser || !selectNewStopIdFormat_ARS || !inputNewStopId_ARS) return;
    const selectedFormat = selectNewStopIdFormat_ARS.value;
    const suggestedId = generateUniqueStopId(selectedFormat); 
    inputNewStopId_ARS.value = suggestedId; 
    inputNewStopId_ARS.dispatchEvent(new Event('input', {bubbles:true, cancelable:true}));

    if (addNewStopStatus_ARS) { 
        if (suggestedId && !suggestedId.includes(String(Date.now()).slice(-5))) { 
            addNewStopStatus_ARS.textContent = `Suggested ID: ${suggestedId}. You can edit this.`;
            addNewStopStatus_ARS.style.color = '#bdc3c7'; 
        } else if (suggestedId) {
             addNewStopStatus_ARS.textContent = `Suggested fallback ID: ${suggestedId}. Please review.`;
            addNewStopStatus_ARS.style.color = '#f1c40f';
        }else {
            addNewStopStatus_ARS.textContent = 'Could not suggest a unique ID for the selected format.';
            addNewStopStatus_ARS.style.color = '#e74c3c'; 
        }
    }
}

function handleAddStopDetails_ARS() {
    if (!currentUser) { alert("Please log in."); return; }

    const newStopID = inputNewStopId_ARS.value.trim().toUpperCase();
    const newStopName = inputNewStopName_ARS.value.trim();
    const newStopDirection = inputNewStopDirection_ARS.value.trim();

    if (!newStopID) {
        addNewStopStatus_ARS.textContent = "New Stop ID is required.";
        addNewStopStatus_ARS.style.color = '#e74c3c'; inputNewStopId_ARS.focus(); return;
    }
    if (!newStopName) {
        addNewStopStatus_ARS.textContent = "New Stop Name is required.";
        addNewStopStatus_ARS.style.color = '#e74c3c'; inputNewStopName_ARS.focus(); return;
    }
    if (!newStopDirection) {
        addNewStopStatus_ARS.textContent = "New Stop Direction (Towards) is required.";
        addNewStopStatus_ARS.style.color = '#e74c3c'; inputNewStopDirection_ARS.focus(); return;
    }

    const existingStopIDs = new Set(currentWorkingSchedule.map(entry => entry.stopID.toUpperCase()));
    if (existingStopIDs.has(newStopID)) {
        addNewStopStatus_ARS.textContent = `Stop ID "${newStopID}" already exists. Please choose a unique ID.`;
        if(newStopIdAvailability_ARS) {
            newStopIdAvailability_ARS.textContent = 'Stop ID already exists.'; 
            newStopIdAvailability_ARS.style.color = '#e74c3c'; 
        }
        inputNewStopId_ARS.focus(); return;
    }

    const placeholderEntry = {
        internalId: `${newStopID}_placeholder_${Date.now()}`, stopID: newStopID,
        stopName: newStopName, direction: newStopDirection,
        lineName: "INFO_ONLY", destinationName: "Stop Definition Placeholder", 
        scheduledTime: "00:00", OperatingProfile: "AllDays", DayOffset: "0"
    };
    currentWorkingSchedule.push(placeholderEntry);

    addNewStopStatus_ARS.textContent = `Stop details for "${newStopID} - ${newStopName}" added with a placeholder schedule entry. You can now use this stop in the generator.`;
    addNewStopStatus_ARS.style.color = '#2ecc71';
    
    inputNewStopId_ARS.value = ''; inputNewStopName_ARS.value = ''; inputNewStopDirection_ARS.value = '';
    if(newStopIdAvailability_ARS) newStopIdAvailability_ARS.textContent = ''; 
    selectNewStopIdFormat_ARS.selectedIndex = 0; 
    renderUIDependentElements(); 
}

function populateStopToRemoveSelector_ARS() {
    if (!selectStopToRemove_ARS) return;
    const currentVal = selectStopToRemove_ARS.value;
    selectStopToRemove_ARS.innerHTML = '<option value="">-- Select Stop to Remove --</option>';
    const uniqueStops = getUniqueStopsFromSchedule(); 

    if (uniqueStops.length === 0) {
        selectStopToRemove_ARS.innerHTML = '<option value="">-- No Stops in Schedule --</option>'; return;
    }
    uniqueStops.forEach(stop => {
        const opt = document.createElement('option'); opt.value = stop.stopID;
        opt.textContent = `${stop.stopName} (${stop.stopID})`;
        selectStopToRemove_ARS.appendChild(opt);
    });
    if (uniqueStops.find(s => s.stopID === currentVal)) {
        selectStopToRemove_ARS.value = currentVal;
    }
}

function handleRemoveStop_ARS() {
    if (!currentUser) { alert("Please log in."); return; }
    const stopIdToRemove = selectStopToRemove_ARS.value;

    if (!stopIdToRemove) {
        removeStopStatus_ARS.textContent = "Please select a stop to remove.";
        removeStopStatus_ARS.style.color = '#f1c40f'; return;
    }
    if (!confirm(`ARE YOU SURE you want to remove stop "${stopIdToRemove}" and ALL its associated schedule entries from the working schedule? This cannot be undone easily.`)) {
        removeStopStatus_ARS.textContent = "Remove operation cancelled.";
        removeStopStatus_ARS.style.color = '#7f8c8d'; return;
    }

    const initialLength = currentWorkingSchedule.length;
    currentWorkingSchedule = currentWorkingSchedule.filter(entry => entry.stopID.toUpperCase() !== stopIdToRemove.toUpperCase());
    const removedCount = initialLength - currentWorkingSchedule.length;

    const closedIndex = closedStopIDs.indexOf(stopIdToRemove);
    if (closedIndex > -1) {
        closedStopIDs.splice(closedIndex, 1);
    }
    
    removeStopStatus_ARS.textContent = `Stop "${stopIdToRemove}" and ${removedCount} schedule entries removed.`;
    removeStopStatus_ARS.style.color = '#2ecc71';
    renderUIDependentElements(); 
}
// --- END: Functions for "Add/Remove Stop Details" section ---

// --- START: Auto Apply Scheduler ---
function initializeAutoApplyScheduler() {
    if (autoApplyIntervalId) { clearInterval(autoApplyIntervalId); }
    autoApplyIntervalId = setInterval(checkForAutoApply, 60 * 1000); 
    console.log("Auto-apply scheduler initialized. Will check time every minute.");
}

function stopAutoApplyScheduler() {
    if (autoApplyIntervalId) {
        clearInterval(autoApplyIntervalId);
        autoApplyIntervalId = null;
        console.log("Auto-apply scheduler stopped.");
    }
}

async function checkForAutoApply() {
    if (!currentUser) { return; }

    const now = new Date();
    const day = now.getDay(); 
    const hour = now.getHours();
    const currentISODate = now.toISOString().split('T')[0]; 

    if (day === 6 && hour === 3) { 
        const flagKey = 'autoAppliedSat3AM_' + currentISODate;
        if (sessionStorage.getItem(flagKey) === 'true') { return; }

        console.log(`It's Saturday 3 AM (${currentISODate}). Checking for staged schedule...`);

        if (window.firebaseOMSI) {
            const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
            try {
                const statusSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_STATUS));
                const pendingTimestampSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_PENDING_TIMESTAMP));
                const currentFbStatus = statusSnapshot.exists() ? statusSnapshot.val() : 'unknown';
                const pendingTimestamp = pendingTimestampSnapshot.exists() ? pendingTimestampSnapshot.val() : null;

                if (currentFbStatus === 'update_staged' && pendingTimestamp) {
                    console.log("Auto-apply: Staged update found. Attempting to apply now...");
                    
                    const originalConfirm = window.confirm; 
                    window.confirm = (message) => { 
                        console.log(`Auto-apply: Bypassed confirmation for: "${message}"`);
                        return true; 
                    };
                    
                    handleApplyNow(); 
                    
                    window.confirm = originalConfirm; 

                    sessionStorage.setItem(flagKey, 'true'); 
                    console.log(`Auto-apply attempted for ${currentISODate} at 3 AM.`);
                } else {
                    console.log(`Auto-apply: No staged update found or missing timestamp. Status: ${currentFbStatus}`);
                    sessionStorage.setItem(flagKey, 'true'); 
                }
            } catch (error) {
                console.error("Auto-apply: Error checking Firebase status:", error);
            }
        } else { console.log("Auto-apply: Firebase not available."); }
    }
}
// --- END: Auto Apply Scheduler ---


// --- Event Listeners & Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    if (adminLoginSection) adminLoginSection.style.display = 'block'; 
    if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'none';
    if (topMenuBar) topMenuBar.style.display = 'none'; 
    hideAllToolSections(); 

    const allMainMenuButtons = document.querySelectorAll('#main-menu-buttons .menu-button');
    allMainMenuButtons.forEach(button => {
        button.addEventListener('click', () => {
            const sectionId = button.getAttribute('data-section');
            if (currentUser && sectionId) { 
                 showSection(sectionId);
            }
        });
    });

    if(detectDuplicatesButton) detectDuplicatesButton.addEventListener('click', detectDuplicateEntries);
    if(removeDuplicateEntriesButton) removeDuplicateEntriesButton.addEventListener('click', handleRemoveDuplicateEntries);


    const inputNewStopId_ARS_El = document.getElementById('inputNewStopId_ARS');
    const newStopIdAvailability_ARS_El = document.getElementById('newStopIdAvailability_ARS');
    if (inputNewStopId_ARS_El && newStopIdAvailability_ARS_El) {
        inputNewStopId_ARS_El.addEventListener('input', () => {
            const newStopId = inputNewStopId_ARS_El.value.trim().toUpperCase();
            if (!newStopId) {
                newStopIdAvailability_ARS_El.textContent = '';
                newStopIdAvailability_ARS_El.style.color = '';
                return;
            }
            const existingStopIDs = new Set(currentWorkingSchedule.map(entry => entry.stopID.toUpperCase()));
            if (existingStopIDs.has(newStopId)) {
                newStopIdAvailability_ARS_El.textContent = 'Stop ID already exists.';
                newStopIdAvailability_ARS_El.style.color = '#e74c3c'; 
            } else {
                newStopIdAvailability_ARS_El.textContent = 'Stop ID is available.';
                newStopIdAvailability_ARS_El.style.color = '#2ecc71'; 
            }
        });
    }


    if (window.firebaseOMSI && window.firebaseOMSI.auth) {
        const { auth, authOnAuthStateChanged, authSignInWithEmailAndPassword, authSignOut } = window.firebaseOMSI;
        
        authOnAuthStateChanged(auth, (user) => {
            updateAuthUI(user); 
            if (user) {
                console.log("Firebase: User is signed in.");
                fetchBankHolidaysForSetup().then(() => {
                    loadInitialData(); 
                }).catch(error => {
                    console.error("Failed to fetch bank holidays, proceeding with data load.", error);
                    loadInitialData(); 
                });
            } else {
                console.log("Firebase: User is signed out.");
                currentWorkingSchedule = []; 
                closedStopIDs = [];
                customRouteColours = {};
                if (currentProfileDisplayElement) currentProfileDisplayElement.textContent = "Today's Auto Profile: (determining...)";
                updateStagingStatusDisplay(); 
                const selectsToClearOnLogout = [
                    selectEventRoute, selectEventImpactStop, selectStopForStatusChange,
                    selectRouteNameColour, selectStopForDeparturesView, routesForStopSelect_SM,
                    document.getElementById('gen_stopNameSelect'), 
                    document.getElementById('gen_routeSelect'),
                    document.getElementById('gen_destinationSelect'),
                    selectNewStopIdFormat_ARS, 
                    selectStopToRemove_ARS
                ];
                selectsToClearOnLogout.forEach(sel => {
                    if (sel) {
                        const firstOptionText = sel.options.length > 0 ? sel.options[0].text : "-- Select --";
                        sel.innerHTML = `<option value="">${firstOptionText.startsWith('--') ? firstOptionText : '-- Select --'}</option>`;
                        if (['gen_stopNameSelect', 'gen_routeSelect', 'gen_destinationSelect'].includes(sel.id)) {
                            sel.dispatchEvent(new Event('change'));
                        }
                    }
                });
                 if(stopDeparturesList) stopDeparturesList.innerHTML = '';
                 if(noDeparturesForStopMessage) { noDeparturesForStopMessage.textContent = 'Select stop to view.'; noDeparturesForStopMessage.style.display = 'block';}
                 if(masterStopListUL_SM) masterStopListUL_SM.innerHTML = '';
                 if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = 'Please log in and load/refresh data.';
                 if(routesServingStopList_SM) routesServingStopList_SM.innerHTML = '';
                 if(routesServingStopStatus_SM) routesServingStopStatus_SM.textContent = 'Please log in and select a stop.';
                 if(addNewStopStatus_ARS) addNewStopStatus_ARS.textContent = '';
                 if(newStopIdAvailability_ARS_El) newStopIdAvailability_ARS_El.textContent = '';
                 if(removeStopStatus_ARS) removeStopStatus_ARS.textContent = '';
                 if(removeDuplicatesStatusMessage) removeDuplicatesStatusMessage.textContent = '';
            }
        });

        if (loginButton) { 
            loginButton.addEventListener('click', (event) => { 
                event.preventDefault(); 
                const email = inputEmail.value; 
                const password = inputPassword.value; 
                if(authStatus) authStatus.textContent = 'Logging in...'; 
                authSignInWithEmailAndPassword(auth, email, password)
                .catch((error) => { 
                    console.error("Login Error:", error); 
                    if(authStatus) authStatus.textContent = `Login Error: ${error.message}`; 
                }); 
            }); 
        }
        if (logoutButton) { 
            logoutButton.addEventListener('click', () => { 
                localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY); 
                authSignOut(auth).catch((e) => console.error("Sign-out Error:", e)); 
            }); 
        }
    } else { 
        console.warn("Firebase Auth not available on DOMContentLoaded."); 
        updateAuthUI(null); 
        if (authStatus) authStatus.textContent = 'Firebase not available. Cannot log in.';
    }

    if (stageScheduleButton) stageScheduleButton.addEventListener('click', handleStageSchedule);
    if (applyNowButton) applyNowButton.addEventListener('click', handleApplyNow);
    if (viewArrivalsButton) viewArrivalsButton.addEventListener('click', () => { window.location.href = "omsi_arrivals.html"; });
    if (countFileInput) countFileInput.addEventListener('change', handleCountFileUpload);

    if(bulkEditTargetStopIDInput) { bulkEditTargetStopIDInput.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); displayCurrentDetailsForBulkStopEdit(); }); bulkEditTargetStopIDInput.addEventListener('blur', displayCurrentDetailsForBulkStopEdit); }
    if(bulkEditTargetLineNameInput) { bulkEditTargetLineNameInput.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); }); }
    if(bulkUpdateDetailsButton) bulkUpdateDetailsButton.addEventListener('click', handleBulkUpdateStopDetails);
    if(bulkUpdateRouteDestinationButton) bulkUpdateRouteDestinationButton.addEventListener('click', handleBulkUpdateRouteDestination);
    if (selectEventRoute) selectEventRoute.addEventListener('change', populateImpactStopSelector);
    if (triggerEventButton) triggerEventButton.addEventListener('click', applyRandomEvent);
    if (closeStopButton) closeStopButton.addEventListener('click', () => handleStopStatusChange('close'));
    if (reopenStopButton) reopenStopButton.addEventListener('click', () => handleStopStatusChange('reopen'));
    if (saveRouteColourButton) saveRouteColourButton.addEventListener('click', handleSaveRouteColour);
    if (selectRouteNameColour) { selectRouteNameColour.addEventListener('change', () => { const selectedRoute = selectRouteNameColour.value; if (selectedRoute && customRouteColours[selectedRoute.toUpperCase()]) { inputRouteColour.value = customRouteColours[selectedRoute.toUpperCase()]; } else { inputRouteColour.value = DEFAULT_ROUTE_COLOUR_TOOLS; } }); }
    if (selectStopForDeparturesView) { selectStopForDeparturesView.addEventListener('change', displayDeparturesForSelectedStop); }

    // Stop Management Tool Listeners
    if (refreshMasterStopListButton_SM) refreshMasterStopListButton_SM.addEventListener('click', populateMasterStopList_SM);
    if (masterStopListFilterInput_SM) masterStopListFilterInput_SM.addEventListener('input', populateMasterStopList_SM);
    if (findStopIdScheduleInput_SM) findStopIdScheduleInput_SM.addEventListener('input', (e) => e.target.value = e.target.value.toUpperCase());
    if (replaceStopIdScheduleInput_SM) replaceStopIdScheduleInput_SM.addEventListener('input', (e) => e.target.value = e.target.value.toUpperCase());
    if (findReplaceStopIdScheduleButton_SM) findReplaceStopIdScheduleButton_SM.addEventListener('click', handleFindReplaceStopIdInSchedule_SM);
    if (routesForStopSelect_SM) routesForStopSelect_SM.addEventListener('change', displayRoutesServingSelectedStop_SM);
    if (refreshRoutesForStopSelectButton_SM) refreshRoutesForStopSelectButton_SM.addEventListener('click', populateRoutesForStopSelector_SM);

    // "Add/Remove Stop Details" Section Listeners 
    if (buttonSuggestStopId_ARS) { 
        buttonSuggestStopId_ARS.addEventListener('click', handleSuggestStopId_ARS);
    }
    if (buttonAddNewStop_ARS) { 
        buttonAddNewStop_ARS.addEventListener('click', handleAddStopDetails_ARS);
    }
    if(selectNewStopIdFormat_ARS) { 
        selectNewStopIdFormat_ARS.addEventListener('change', handleSuggestStopId_ARS);
    }
    if(buttonRemoveStop_ARS) { 
        buttonRemoveStop_ARS.addEventListener('click', handleRemoveStop_ARS);
    }
    
    // Removed obsolete listeners for elements that no longer exist (from old "Add Stop with Route Times")


    fetchBankHolidaysForSetup(); 

    // Service Worker Registration
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/live-tracker/sw-omsi.js') 
            .then(registration => {
                console.log('Service Worker (sw-omsi.js) registered successfully with scope:', registration.scope);
            })
            .catch(error => {
                console.error('Service Worker (sw-omsi.js) registration failed:', error);
            });
        });
    }
});
</script>
</body>
</html>
