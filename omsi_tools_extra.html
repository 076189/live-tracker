<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMSI Tools - Extra Modules</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
   <link rel="manifest" href="/live-tracker/manifest-omsitoolsextra.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OMSI Extra Tools">
    <meta name="theme-color" content="#2c3e50">
    
    <style>
        @font-face {
            font-family: 'NJFont Medium Web';
            src: url('fonts/NJFont-Medium.ttf') format('truetype');
            font-weight: normal;font-style: normal;font-display: swap;
        }
        body {
            font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            margin:0;
            box-sizing: border-box;
        }
        .page-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            box-sizing: border-box;
        }
        #top-menu-bar_extra {
            background-color: rgba(0,0,0,0.25); padding: 0.75rem; border-radius: 0.5rem;
            margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center; display: block;
        }
        .menu-button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin: 0.25rem;
        }
        .menu-button:hover { background-color: #2980b9; }
        .tool-content-section {
            display: block; 
            background-color: rgba(0,0,0,0.15); padding: 1.5rem;
            border-radius: 0.5rem; margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            box-sizing: border-box;
        }
        #auth-section {
             margin-bottom: 1.5rem; background-color: rgba(0,0,0,0.15); padding: 1.5rem;
             border-radius: 0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #current-profile-display-container {
            text-align: center; margin-bottom: 1.5rem; padding: 0.75rem;
            background-color: rgba(255,255,255,0.05); border-radius: 0.25rem; display: block;
        }
        #auth-section.auth-section-compact {
            padding: 0.75rem;
            background-color: rgba(255,255,255,0.05);
            border-radius: 0.25rem;
            text-align: center;
        }

        #logout-container_extra {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .logged-in-username {
            font-size: 0.9rem;
            color: #FFFFFF;
        }

	#stopDeparturesList_extra li {
    display: flex;
    align-items: center;
    padding: 0.4rem 0.1rem;
    border-bottom: 1px solid #34495e;
    font-size: 0.9rem;
}
	#stopDeparturesList_extra li:last-child {
    border-bottom: none;
}


        #current-profile-display { font-size: 0.9rem; opacity: 1; font-style: normal; color: #FFFFFF;}
        h1 { font-size: 2rem; margin-bottom: 1.5rem; font-weight: normal; text-align: center; color: #ffffff; }
        h2 { font-size: 1.5rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: normal; border-bottom: 1px solid #7f8c8d; padding-bottom: 0.25rem;}
        h3.subsection-title { font-size: 1.25rem; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: normal; color: #e0e0e0; border-bottom: 1px solid rgba(127,140,141,0.5); padding-bottom: 0.2rem;}
        .subsection {
            background-color: rgba(0,0,0,0.1); padding: 1rem; border-radius: 0.375rem;
            margin-top: 1rem; margin-bottom: 1rem; border: 1px solid rgba(127,140,141,0.2);
            box-sizing: border-box;
        }
        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;}
        .form-field-group { margin-bottom: 1rem; }
        label { display: block; margin-bottom: 0.25rem; font-size: 0.85rem; color: #bdc3c7; }
        input[type="text"], input[type="email"], input[type="password"], input[type="time"],
        input[type="color"], input[type="number"], input[type="date"], input[type="datetime-local"],
        select, textarea {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e; color: #ecf0f1; font-size:0.9rem; box-sizing: border-box;
        }
        input[type="date"]::-webkit-calendar-picker-indicator,
        input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            filter: invert(0.8); cursor:pointer;
        }
        select option { background-color: #34495e; color: #ecf0f1; }
        .button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.5rem 0.8rem;
            border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin-right: 0.5rem; margin-top:0.5rem;
            display: inline-block;
            text-align: center;
            vertical-align: middle;
            box-sizing: border-box;
        }
        .button:hover { background-color: #2980b9; }
        .button.secondary { background-color: #e74c3c; }
        .button.secondary:hover { background-color: #c0392b; }
        .button.save { background-color: #27ae60; }
        .button.save:hover { background-color: #229954; }
        .button.tertiary { background-color: #f39c12; }
        .button.tertiary:hover { background-color: #e67e22; }
        .button.neutral { background-color: #7f8c8d; }
        .button.neutral:hover { background-color: #95a5a6; color: #2c3e50; }
        .button.small-action { padding: 0.2rem 0.4rem; font-size: 0.8rem; margin: 0 0.15rem; line-height: 1; min-width: 20px; text-align:center; font-weight: bold;}

        .button:disabled,
        .button[disabled] {
            background-color: #5D6D7E !important;
            color: #a0a0a0 !important;
            cursor: not-allowed;
            opacity: 0.65;
            box-shadow: none;
        }

        .schedule-generator-input {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e; color: #ecf0f1; font-size: 0.9rem;
        }
        #masterStopListUL_extra li.master-stop-list-item { display: grid; grid-template-columns: 2.5fr 1.5fr 1fr; gap: 1rem; padding: 0.75rem 0.5rem; border-bottom: 1px solid #34495e; transition: background-color 0.15s ease-in-out; align-items: start; } #masterStopListUL_extra li.master-stop-list-item:last-child { border-bottom: none; } .master-stop-original-info .stop-name-master { font-weight: bold; color: #ecf0f1; font-size: 1.05em; } .master-stop-original-info .stop-direction-master { font-size: 0.85em; color: #95a5a6; margin-bottom: 0.3rem; } .master-stop-original-info .stop-id-master { font-weight: normal; color: #bdc3c7; font-size: 0.95em; } .master-stop-original-info .stop-details-grid { display: grid; grid-template-columns: auto 1fr; gap: 0.2rem 0.8rem; font-size: 0.85em; margin-top: 0.4rem; } .master-stop-original-info .detail-label { font-weight: normal; color: #bdc3c7; opacity: 0.8; } .master-stop-original-info .detail-value { color: #ecf0f1; } .master-stop-original-info .detail-value.status-closed { color: #e74c3c; font-weight: bold; } .master-stop-original-info .status-open { color: #2ecc71; } .master-stop-original-info .serving-routes-container { margin-top: 0.4rem; margin-bottom: 0.2rem; display: flex; flex-wrap: wrap; gap: 0.3em; padding: 0.25rem 0;} .master-stop-new-id-section label { font-size: 0.8em; display: block; margin-bottom: 0.2em; color: #bdc3c7; } .master-list-new-id-input { margin-bottom: 0.25rem; } .master-list-row-warning { font-size: 0.8em; color: #f39c12; min-height: 1.2em; margin-top: 0.25rem; } .master-stop-actions { margin-top: 0rem; padding-top: 0rem; border-top: none; display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-start; } .master-stop-actions .button { width: 100%; margin: 0; } .route-tile-tools-list { display: inline-block; padding: 0.2em 0.55em; margin-right: 0.3em; margin-bottom: 0.3em; border-radius: 0.25rem; font-size: 0.8em; font-weight: bold; color: white; text-align: center; line-height: 1.3; min-width: 28px; box-shadow: 0 1px 2px rgba(0,0,0,0.25); vertical-align: middle; } #newStopIdAvailability_extra { font-size: 0.8em; min-height: 1.1em; margin-top: 0.25rem; }
        .selectable-route-tile-container { display: flex; flex-wrap: wrap; gap: 0.6rem; padding: 0.25rem 0; } .selectable-route-tile { display: inline-block; padding: 0.4em 0.8em; border-radius: 0.25rem; font-size: 0.9em; font-weight: bold; text-align: center; line-height: 1.4; min-width: 40px; box-shadow: 0 1px 3px rgba(0,0,0,0.3); cursor: pointer; border: 2px solid transparent; transition: border-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out; } .selectable-route-tile:hover { transform: translateY(-1px); } .selectable-route-tile.selected { border-color: #f1c40f !important; box-shadow: 0 0 8px 1px #f1c40f !important; }
        #duplicateStopsByNameDirResults_extra ul { list-style: none; padding-left: 0; } #duplicateStopsByNameDirResults_extra li { margin-bottom: 0rem; } .duplicate-set-to-merge { border: 1px solid #4a5568; padding: 0.75rem; margin-bottom: 0.75rem; border-radius: 0.25rem; background-color: rgba(0,0,0,0.05); } .duplicate-set-to-merge p { margin-bottom: 0.35rem; } .duplicate-set-to-merge .stop-id-options label { display: block; margin-bottom: 0.25rem; font-size: 0.9em; cursor: pointer; } .duplicate-set-to-merge .stop-id-options input[type="radio"] { margin-right: 0.35em; vertical-align: middle; }
        #rsg-stop-sequence-list-extra li { display: flex; flex-direction: column; padding: 0.6rem 0.5rem; border-bottom: 1px solid #4A5568; background-color: rgba(255,255,255,0.03); cursor: grab; } #rsg-stop-sequence-list-extra li:active { cursor: grabbing; background-color: rgba(255,255,255,0.07); } #rsg-stop-sequence-list-extra li.rsg-dragging-placeholder { opacity: 0.5; background-color: #567a9a; border: 1px dashed #ecf0f1; } #rsg-stop-sequence-list-extra li:last-child { border-bottom: none; } .rsg-li-main-content { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 0.5rem; }
        #rsg-stop-sequence-list-extra .rsg-stop-info { flex-grow: 1; margin-right: 1rem; } #rsg-stop-sequence-list-extra .rsg-stop-name { font-weight: bold; } #rsg-stop-sequence-list-extra .rsg-stop-id { font-size: 0.85em; color: #bdc3c7; margin-left: 0.5em; } #rsg-stop-sequence-list-extra .rsg-stop-actions { display: flex; align-items: center; gap: 0.5rem; } #rsg-stop-sequence-list-extra .rsg-stop-actions button { padding: 0.15rem 0.35rem; font-size: 0.75rem; line-height: 1; } #rsg-stop-sequence-list-extra .rsg-time-adjustment-input { width: 70px; padding: 0.25rem; font-size: 0.85em; text-align: center; }
        .rsg-copy-adjustment-buttons-container { display: flex; flex-wrap: wrap; gap: 0.4rem; margin-top: 0.5rem; align-items: center; width: 100%; padding-top: 0.3rem; border-top: 1px solid rgba(127,140,141,0.15); } .rsg-copy-adjustment-buttons-container .button.copy-adj-button { font-size: 0.7em; padding: 0.2em 0.5em; line-height: 1.3; white-space: nowrap; margin: 0; background-color: #546E7A; color: white; } .rsg-copy-adjustment-buttons-container .button.copy-adj-button:hover { background-color: #607D8B; }
        #dpo-selectable-profiles-container-extra > div, #rsg-selectable-profiles-container-extra > div {
    display: inline-flex;
    align-items: center;
    background-color: #4A5568;
    color: #ecf0f1;
    padding: 0.4em 0.8em;
    border-radius: 0.25rem;
    border: 1px solid transparent;
    cursor: pointer;
    transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    margin-right: 0.5rem;
    margin-bottom: 0.5rem;
}

#dpo-selectable-profiles-container-extra > div > label, #rsg-selectable-profiles-container-extra > div > label {
    font-size: 14px !important; /* Changed to fixed pixel size for consistency */
    font-weight: 700 !important; /* Changed from 500 to 700 for a bolder look */
    font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif !important; /* Explicitly set font family */
    text-shadow: 0 0 1px rgba(255,255,255,0.5); /* Added subtle text shadow */
    cursor: pointer;
    line-height: 1.4;
    margin-left: 4px;
    color: #ecf0f1;
}

#dpo-selectable-profiles-container-extra > div > input[type="checkbox"], #rsg-selectable-profiles-container-extra > div > input[type="checkbox"] {
    margin-right: 8px;
    vertical-align: middle;
    height: 1em;
    width: 1em;
}

#dpo-selectable-profiles-container-extra > div:has(input[type="checkbox"]:checked), #rsg-selectable-profiles-container-extra > div:has(input[type="checkbox"]:checked) {
    border-color: #f1c40f !important;
    box-shadow: 0 0 6px 1px #f1c40f !important;
}

#dpo-selectable-profiles-container-extra > div:hover, #rsg-selectable-profiles-container-extra > div:hover {
    background-color: #5D6D7E;
}
        #rsg-stop-search-results-extra { max-height: 200px; overflow-y: auto; border: 1px solid #4A5568; border-radius: 0.25rem; background-color: #34495e; margin-top: 0.25rem; } #rsg-stop-search-results-extra .rsg-search-result-item { padding: 0.5rem 0.6rem; cursor: pointer; border-bottom: 1px solid #2c3e50; } #rsg-stop-search-results-extra .rsg-search-result-item:last-child { border-bottom: none; } #rsg-stop-search-results-extra .rsg-search-result-item:hover { background-color: #4a6a80; } #rsg-stop-search-results-extra .rsg-search-stop-name { font-weight: bold; display: block; } #rsg-stop-search-results-extra .rsg-search-stop-details { font-size: 0.8em; color: #bdc3c7; display: block; margin-top:0.1em; } #rsg-stop-search-results-extra .rsg-search-serving-routes { margin-top: 0.3em; }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }
        .rpd-profile-tile { border: 2px solid transparent; transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; } .rpd-profile-tile.selected { border-color: #f1c40f !important; box-shadow: 0 0 8px 1px #f1c40f !important; }
        .rsg-modal { position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 1050; display: flex; justify-content: center; align-items: center; } .rsg-modal-content { background: linear-gradient(145deg, #3a506b, #2c3e50); color: #ecf0f1; padding: 20px 25px; border-radius: 8px; width: 90%; max-width: 500px; box-shadow: 0 8px 25px rgba(0,0,0,0.3); border: 1px solid #4a6a80; } .rsg-modal-content h4 { margin-top: 0; margin-bottom: 1rem; font-size: 1.3em; color: #ffffff; border-bottom: 1px solid #567a9a; padding-bottom: 0.5rem; } .rsg-modal-content .form-field-group { margin-bottom: 1rem; } .rsg-modal-content label { font-size: 0.9em; } .rsg-modal-content input.schedule-generator-input { background-color: #2c3e50; border-color: #567a9a; } .rsg-modal-actions { margin-top: 1.5rem; text-align: right; display: flex; justify-content: flex-end; gap: 0.5rem; } .rsg-modal-actions .button { margin-top: 0; }
        #sru-cancel-modal-checkboxes-container-extra .sru-cancel-time-item label { color: #ecf0f1; font-size: 0.9em; cursor: pointer; } #sru-cancel-modal-checkboxes-container-extra .sru-cancel-time-item input[type="checkbox"] { margin-right: 8px; vertical-align: middle; } #sru-cancel-modal-checkboxes-container-extra .sru-cancel-time-item { display: block; margin-bottom: 0.4rem; padding: 0.2rem 0.1rem; }

        /* --- RESPONSIVE BUTTON AND FORM FIXES --- */
        #main-menu-buttons_extra { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.25rem; }
        #main-menu-buttons_extra .menu-button { flex-grow: 1; min-width: 160px; margin: 0.25rem;  }
        @media (max-width: 480px) { #logout-container_extra { flex-direction: column; align-items: flex-start; gap: 0.5rem; } #logoutButton_extra {  margin-top: 0.25rem; align-self: flex-start; } }
        
        /* Timetable Exporter Grid */
        #timetable-exporter-section_extra .form-grid[style*="grid-template-columns: 3fr 1fr"] { grid-template-columns: 1fr !important;  }
        @media (min-width: 768px) { #timetable-exporter-section_extra .form-grid[style*="grid-template-columns: 3fr 1fr"] { grid-template-columns: 3fr 1fr !important;  } }
        
        /* Scheduled Route Deletion Grid */
        #scheduled-route-deletion-section_extra .form-grid[style*="grid-template-columns: 2fr 1.5fr 1fr"] { grid-template-columns: 1fr !important;  }
        @media (min-width: 768px) { #scheduled-route-deletion-section_extra .form-grid[style*="grid-template-columns: 2fr 1.5fr 1fr"] { grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)) !important;  } }
        @media (min-width: 1024px) { #scheduled-route-deletion-section_extra .form-grid[style*="grid-template-columns: 2fr 1.5fr 1fr"] { grid-template-columns: 2fr 1.5fr 1fr !important;  } }
        
        /* RSG Action Buttons */
        #route-schedule-generator-section_extra .subsection > .form-field-group[style*="display: flex"] { flex-wrap: wrap !important; gap: 0.5rem;  }
        #route-schedule-generator-section_extra .subsection > .form-field-group[style*="display: flex"] .button { flex-grow: 1; flex-basis: calc(50% - 0.5rem);  min-width: 200px;  margin-left: 0 !important;  margin-right: 0 !important; }
        @media (max-width: 600px) {  #route-schedule-generator-section_extra .subsection > .form-field-group[style*="display: flex"] .button { flex-basis: 100%;  } }
        
        /* Modal Action Buttons */
        .rsg-modal-actions { flex-wrap: wrap; justify-content: flex-start;  gap: 0.5rem;  }
        .rsg-modal-actions .button { flex-grow: 1; min-width: 120px; margin: 0;  }
        
        /* Stop Management Action Buttons */
        #stop-manager-tool-section_extra .subsection > div[style*="justify-content:space-between"][style*="align-items:center"] { flex-wrap: wrap !important;  gap: 0.5rem; }
        #stop-manager-tool-section_extra .subsection > div[style*="justify-content:space-between"][style*="align-items:center"] > .button { flex-grow: 1; min-width: 160px;  }
        
        /* Config Data - School Holiday Form Grid */
        #config-data-section_extra .subsection .form-grid[style*="grid-template-columns: 1fr 1fr 2fr auto"] {
            grid-template-columns: 1fr !important; /* Stack on small screens */
            gap: 0.5rem !important; /* Adjust gap for stacked items */
        }
        @media (min-width: 768px) { /* Adjust breakpoint as needed */
            #config-data-section_extra .subsection .form-grid[style*="grid-template-columns: 1fr 1fr 2fr auto"] {
                grid-template-columns: 1fr 1fr 2fr auto !important; /* Original layout for larger screens */
                gap: 1rem !important;
            }
        }
        /* Important Considerations box text wrapping (should be default, but ensure) */
        #config-data-section_extra .subsection div[style*="border: 1px dashed #f39c12"] {
            white-space: normal;
            word-wrap: break-word;
        }
        #config-data-section_extra .subsection div[style*="border: 1px dashed #f39c12"] ul {
            white-space: normal;
            word-wrap: break-word;
        }


        /* --- RESPONSIVE CALENDAR CSS (No Scroll, Wrap) --- */
        .calendar-tool-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .calendar-grid-container-extra {
            width: 100%;
            margin-bottom: 1rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            box-sizing: border-box;
        }
        #events-calendar-grid_extra {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-auto-rows: minmax(100px, auto);
        }

        #events-calendar-grid_extra .cv-current-day {
            background-color: rgba(255, 255, 0, 0.25) !important; /* A semi-transparent yellow */
            border: 2px solid #F1C40F !important; /* A gold border */
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.7);
        }
        #events-calendar-grid_extra .cv-current-day .cv-day-number-span {
            font-weight: bold;
            color: #F1C40F !important; /* Make day number stand out more */
        }

        #events-calendar-grid_extra > div { /* Calendar day cells */
            height: auto;
            padding: 4px;
            font-size: 0.70em; /* Base font size for cell */
            box-sizing: border-box;
            overflow-wrap: break-word;
            word-wrap: break-word;
            white-space: normal;
            border-right: 1px solid #3e4e5e;
            border-bottom: 1px solid #3e4e5e;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            min-width: 0; /* Allow cells to shrink fully */
        }
        #events-calendar-grid_extra > div:nth-child(7n) { border-right: none; }
        #events-calendar-grid_extra > div:last-child { border-bottom: none; }
        #events-calendar-grid_extra > div[style*="font-weight: bold"] { /* Day headers like Mon, Tue */
            font-size: 0.6em !important;
            padding: 3px 2px !important;
            text-align: center !important;
            height: auto;
            background-color: rgba(0,0,0,0.25) !important;
            justify-content: center;
            border-bottom: 1px solid #4A5568 !important;
        }
        #events-calendar-grid_extra .cv-day-number-span { /* Day number (1, 2, 3...) */
            font-size: 0.9em; /* Relative to cell font-size */
            display: block;
            text-align: right;
            margin-bottom: 2px;
            font-weight: bold;
            color: #ecf0f1;
        }
        .cv-profile-text { /* For Operating Profile text in calendar cell */
            font-size: 0.85em;  /* Relative to cell's font-size (0.70em base) */
            font-weight: bold;
            color: #bdc3c7;
            margin-bottom: 0.3em;
            text-align: left;
            white-space: normal;
            overflow-wrap: break-word;
            word-wrap: break-word;
            line-height: 1.3;
        }
        #events-calendar-grid_extra .cv-event-item { /* For individual event pills */
            display: block;
            padding: 2px 3px; /* Adjusted from 2px 4px */
            margin-top: 1px;  /* Adjusted from 2px */
            border-radius: 3px;
            font-size: 0.9em; /* Relative to cell's font-size (0.70em base) */
            line-height: 1.2;
            color: white; 
            white-space: normal;
            overflow-wrap: break-word;
            word-wrap: break-word;
            /* overflow: hidden; -- Removed to ensure wrapping takes precedence */
            /* text-overflow: ellipsis; -- Removed */
        }

        @media (max-width: 600px) {
            #events-calendar-grid_extra { grid-auto-rows: minmax(80px, auto); }
            #events-calendar-grid_extra > div { font-size: 0.65em; padding: 3px; }
            #events-calendar-grid_extra > div[style*="font-weight: bold"] { font-size: 0.6em !important; }
            #events-calendar-grid_extra .cv-day-number-span { font-size: 0.85em; }
            .cv-profile-text { font-size: 0.8em; } /* Adjust profile text for this breakpoint */
            #events-calendar-grid_extra .cv-event-item { font-size: 0.85em; line-height: 1.15; padding: 1px 2px;}
        }
        @media (max-width: 480px) {
            .calendar-tool-header { justify-content: center; }
            #cv-month-year-display_extra { order: -1; width: 100%; text-align: center; margin-bottom: 0.5rem; font-size: 1.2em; }
            #cv-prev-month-btn_extra, #cv-next-month-btn_extra { flex-basis: calc(50% - 0.25rem); justify-content: center; font-size: 0.8em; padding: 0.5rem 0.6rem; }
            #events-calendar-grid_extra { grid-auto-rows: minmax(70px, auto); }
            #events-calendar-grid_extra > div { font-size: 0.6em; padding: 2px; }
            #events-calendar-grid_extra > div[style*="font-weight: bold"] { font-size: 0.55em !important; }
            #events-calendar-grid_extra .cv-day-number-span { font-size: 0.9em; }
            .cv-profile-text { font-size: 0.75em; line-height: 1.2; } /* Further adjust profile text */
            #events-calendar-grid_extra .cv-event-item { font-size: 0.8em; line-height: 1.1; padding: 1px 2px;}
        }

        /* Scheduled Tasks List - Title Wrapping */
        .sru-task-title-heading {
            white-space: normal !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            text-overflow: clip !important;
            /* overflow: visible !important; -- Might not be needed if parent heights are auto */
            display: block;
        }

    </style>
</head>
<body>
    <div class="page-container">
        <h1>OMSI Tools - Extra Modules</h1>
        <div id="global-notification-banner" style="display: none; padding: 12px 15px; background-color: #27ae60; color: white; text-align: center; position: sticky; top: 0; left: 0; width: 100%; z-index: 1060; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
        </div>

        <div id="auth-section" class="section">
            <h2>Admin Login</h2>
            <div id="login-form-container_extra">
                <form id="adminLoginForm_extra">
                    <div class="form-grid" style="grid-template-columns: 1fr;">
                        <div><label for="inputEmail_extra">Email</label><input type="email" id="inputEmail_extra" autocomplete="email"></div>
                        <div><label for="inputPassword_extra">Password</label><input type="password" id="inputPassword_extra" autocomplete="current-password"></div>
                    </div>
                    <button id="loginButton_extra" type="submit" class="button">Login</button>
                </form>
                <p id="auth-status_extra" style="margin-top: 0.5em; color: #f1c40f;"></p>
            </div>
            <div id="logout-container_extra" style="display:none;"> <span id="loggedInUserEmail_extra" class="logged-in-username"></span>
                <button id="logoutButton_extra" class="button secondary small-action">Logout</button>
            </div>
        </div>

        <div id="current-profile-display-container" style="display:none;"> <p id="current-profile-display">Today's Operating Profile: (loading...)</p>
            <button id="enableDesktopNotificationsBtn_extra" class="button neutral">Enable Desktop Alerts</button>
            <button id="iphoneTestNotificationBtn" class="button neutral" style="background-color: lightblue; color: #2c3e50;">Test iPhone Notification</button>
        </div>

        <div id="top-menu-bar_extra" style="display:none;"> 
    <div id="main-menu-buttons_extra">
        <button class="menu-button" data-section="day-profile-override-section_extra">Day Profile Override</button>
        <button class="menu-button" data-section="stop-manager-tool-section_extra">Stop Management & Creation</button>
        <button class="menu-button" data-section="global-route-deletion-section_extra">Global Route Deletion</button>
        <button class="menu-button" data-section="route-schedule-generator-section_extra">Route Schedule Generator</button>
        <button class="menu-button" data-section="route-profile-deletion-section_extra">Route Profile Deletion</button>
        <button class="menu-button" data-section="view-departures-section_extra">View Departures</button>
        <button class="menu-button" data-section="timetable-exporter-section_extra">Timetable Exporter</button>
        <button class="menu-button" data-section="scheduled-route-updates-section_extra">Scheduled Tasks</button>
        <button class="menu-button" data-section="scheduled-route-deletion-section_extra">Schedule Route Deletion</button>
        <button class="menu-button" data-section="config-data-section_extra">View/Edit Config Data</button>
        <button class="menu-button" data-section="key-departures-section_extra">Key Departures</button> 
        <button class="menu-button" data-section="calendar-view-section_extra">Events Calendar</button>
    </div>
</div>

<div id="tool-sections-wrapper_extra">

    <div id="key-departures-section_extra" class="tool-content-section section" style="display:none;">
        <h2>Today's Key Departures</h2>
        <p style="font-size:0.9em; margin-bottom:1.5em; opacity:0.8;">
            This section shows upcoming first and last departures for services operating today, based on your Route Schedule Generator configurations. Entries will automatically disappear after their scheduled departure time. Data refreshes periodically.
        </p>
        <div class="subsection">
            <h3 class="subsection-title" style="color: #A5D6A7;">First Departures of the Day</h3>
            <div id="kd-first-departures-list_extra" style="min-height: 50px; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem;">
                <p>Loading first departures...</p>
            </div>
        </div>
        <div class="subsection" style="margin-top: 1.5rem;">
            <h3 class="subsection-title" style="color: #FFCCBC;">Last Departures of the Day</h3>
            <div id="kd-last-departures-list_extra" style="min-height: 50px; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem;">
                <p>Loading last departures...</p>
            </div>
        </div>
        <p id="kd-status-message_extra" style="min-height:1.2em; margin-top:1rem; font-size:0.85em; text-align:center;"></p>
        <button id="kd-refresh-btn_extra" class="button neutral" style="display:block; margin: 1rem auto;">Refresh Now</button>
    </div>

    <div id="day-profile-override-section_extra" class="tool-content-section section" style="display:none;">
        <h2>Operational Day Profile Override</h2>
        <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
            Use this tool to manually set a specific operating profile for individual routes on an upcoming date (e.g., bank holidays, special events). This overrides the automatically calculated profile for those routes on that day.
        </p>

<div class="rsg-info-box" style="font-size: 0.85em; padding: 0.85rem 1rem; margin-top: 1.5rem; border: 1px solid #f39c12; border-radius: 0.375rem; background-color: rgba(243,156,18,0.08);">
    <h5 style="margin-top:0; font-weight:bold; color:#f1c40f; font-size:1.05em;">Christmas & New Year's Scheduling:</h5>
    <ul style="list-style-type: disc; padding-left: 20px; margin:0; line-height:1.5;">
        <li style="margin-bottom:0.3em;">23 December: Normal service.</li>
        <li style="margin-bottom:0.3em;">Christmas Eve: Saturday service on all day routes. No Night routes in operation. 24 Hour routes finish around Midnight.</li>
        <li>Christmas Day: No service.</li>
		<li>Boxing Day: Sunday service for all routes.</li>
		<li>27 December: Saturday service on all day routes. Sunday service on all Night and 24 hour overnight routes.</li>
		<li>28 December: Normal service.</li>
		<li>29 December: Normal service.</li>
		<li>30 December: Saturday service on all day routes. Normal service on all Night and 24 hour overnight routes.</li>
		<li>New Year's Eve: Saturday service on all day, Night and 24 hour overnight routes. Normal service on all Night routes and 24 hour overnight services. Special enhanced Saturday service for some routes.</li>
            </ul>
		<li>New Year's Day: Sunday service on all day, Night and 24 hour overnight routes.</li>
		<li>2 January: Normal service resumes on all day, Night and 24 hour overnight routes.</li>
        </div>
       


        <div class="subsection">
            <h3 class="subsection-title">1. Select Date and Profiles to Apply</h3>
            <div class="form-grid" style="grid-template-columns: 1fr;">
                <div>
                    <label for="overrideDate_extra">Date to Override:</label>
                    <input type="date" id="overrideDate_extra" class="schedule-generator-input">
                </div>
                <div class="form-field-group">
                    <label>Profile(s) to apply to selected routes (select one or more):</label>
                    <div id="dpo-selectable-profiles-container-extra" class="selectable-route-tile-container" style="background-color: rgba(0,0,0,0.05); padding: 0.5rem; border-radius: 0.25rem; min-height:30px;">
                        <p id="dpo-profiles-placeholder-extra" style="font-size:0.85em; opacity:0.7;">Loading profiles...</p>
                    </div>
                    <div style="margin-top:0.25rem; display:flex; justify-content:space-between; align-items:center;">
                        <span style="font-size:0.8em;">Selected Profile(s) for routes: <strong id="dpo-selected-profiles-display-extra" style="color:#f1c40f;">(None selected)</strong></span>
                        <button id="dpo-clear-profile-checkboxes-button-extra" class="button small-action neutral">Clear Sel.</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="subsection" style="margin-top: 1.5rem;">
            <h3 class="subsection-title">2. Select Route(s) and Apply/Clear Override</h3>
            <div class="form-field-group">
                <label>Select Route(s) to apply the above profile(s) to:</label>
                
                    <div id="dpo-route-selection-container-extra" class="selectable-route-tile-container" style="max-height: 200px; overflow-y: auto; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border: 1px solid rgba(127,140,141,0.2); min-height:50px;">
                        <p id="dpo-routes-placeholder-extra" style="width:100%; text-align:center; opacity:0.7;">Loading routes...</p>
                    </div>
                    <div style="margin-top:0.25rem; display:flex; justify-content:space-between; align-items:center;">
                        <span style="font-size:0.8em;">Routes Selected: <strong id="dpo-selected-routes-display-extra" style="color:#f1c40f;">(None selected)</strong></span>
                        <div> <button id="dpo-select-all-routes-button-extra" class="button small-action neutral">Select All</button>
                            <button id="dpo-clear-route-selection-button-extra" class="button small-action neutral">Clear Sel.</button>
                        </div>
                    </div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem;">
                    <button id="dpo-apply-override-to-routes-button-extra" class="button save">Apply Profile(s) to Selected Route(s)</button>
                    <button id="dpo-clear-override-for-routes-button-extra" class="button secondary">Clear Override for Selected Route(s)</button>
                </div>
                <p id="dpo-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
            </div>

        <div class="subsection" style="margin-top: 2rem;">
            <h3 class="subsection-title">3. Current Overrides for Selected Date</h3>
            <p style="font-size:0.85em;"><strong>Selected Date:</strong> <span id="selectedDateDisplay_extra">(select a date)</span></p>
            <div id="dpo-current-overrides-list-extra" style="background-color: rgba(0,0,0,0.05); padding: 0.5rem; border-radius: 0.25rem; border:1px solid rgba(127,140,141,0.2);">
                <p>Select a date above to see its current overrides.</p>
            </div>
        </div>
        
        <div class="subsection" style="margin-top: 2rem;">
            <h3 class="subsection-title" id="dpo-active-overrides-title">All Active Overrides (Until End of Current Year)</h3>
            <div id="activeOverridesList_extra" style="background-color: rgba(0,0,0,0.05); padding: 0.5rem; border-radius: 0.25rem;">
                <p>Loading all active overrides...</p>
            </div>
        </div>
    </div>

    <div id="stop-manager-tool-section_extra" class="tool-content-section section" style="display:none;">
        <h2>Stop Management & Creation (Live Updates)</h2>
        <div class="subsection">
            <h3 class="subsection-title">Add New Stop Definition</h3>
            <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); align-items: end;">
                <div>
                    <label for="inputNewStopName_extra">Stop Name:</label>
                    <input type="text" id="inputNewStopName_extra" class="schedule-generator-input" placeholder="e.g., High Street / Central Avenue">
                </div>
                <div>
                    <label for="selectNewStopIdFormat_extra">ID Format Suggestion:</label>
                    <select id="selectNewStopIdFormat_extra" class="schedule-generator-input">
                        <option value="NUM">Numeric (e.g., 101)</option>
                        <option value="BP">Bus Point (e.g., BP123)</option>
                        <option value="LE">Location E (e.g., LE45)</option>
                        <option value="RO">Route Objective (e.g., RO67)</option>
                        <option value="Custom">Custom (type below)</option>
                    </select>
                </div>
                <div>
                    <label for="inputNewStopId_extra">New Stop ID (Uppercase Alphanumeric):</label>
                    <input type="text" id="inputNewStopId_extra" class="schedule-generator-input" placeholder="Auto-suggest or type custom">
                    <div id="newStopIdAvailability_extra"></div>
                </div>
                 <div>
                    <label for="inputNewStopDirection_extra">"Towards" Text (Optional):</label>
                    <input type="text" id="inputNewStopDirection_extra" class="schedule-generator-input" placeholder="e.g., Town Centre">
                </div>
                <div style="padding-bottom:0.05rem;">
                    <button id="buttonAddNewStop_extra" class="button save">Add Stop Definition</button>
                </div>
            </div>
            <p id="addNewStopStatus_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
        </div>

        <div class="subsection">
            <h3 class="subsection-title">Bulk Add Stop Definitions (Replaces ALL Existing Stops/Schedules)</h3>
             <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                <strong>DANGER ZONE:</strong> Uploading an Excel (.xlsx) file here will <strong>DELETE ALL current schedules and stop definitions</strong> from Firebase and replace them with placeholder entries derived from the uploaded file.
                The Excel file should have columns (no headers needed in file): UserProvidedStopID (optional), StopName (required if ID not provided), Direction (optional), LineName(s) (comma-separated, optional, defaults to "INFO_ONLY").
            </p>
            <input type="file" id="fileInputBulkAddStops_extra" accept=".xlsx" style="display:none;">
            <label for="fileInputBulkAddStops_extra" class="button neutral">Choose Excel File (.xlsx)</label>
            <span id="fileNameBulkAddStops_extra" style="margin-left:10px; font-size:0.9em;">No file selected.</span>
            <button id="buttonBulkAddNewStops_extra" class="button secondary" style="margin-top:0.75rem;">Bulk Replace All Data With Excel Definitions</button>
            <p id="bulkAddNewStopsStatus_extra" style="min-height:1.2em; margin-top:0.5rem; white-space:pre-wrap;"></p>
        </div>

        <div class="subsection">
            <h3 class="subsection-title">Master Stop List & Actions (Live Data)</h3>
            <div class="form-field-group">
                <label for="masterStopListFilterInput_extra">Filter Stops (by ID, Name, Direction, Route, Status):</label>
                <input type="text" id="masterStopListFilterInput_extra" class="schedule-generator-input" placeholder="Type to filter...">
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem; flex-wrap: wrap; gap: 0.5rem;">
                <button id="refreshMasterStopListButton_extra" class="button neutral">Refresh List</button>
                <button id="exportUniqueStopsButton_extra" class="button" style="background-color: #16a085;">Export Stops to Excel</button>
            </div>
            <p id="masterStopListStatus_extra" style="min-height:1.2em; margin-bottom:0.5rem; font-size:0.9em;"></p>
            <ul id="masterStopListUL_extra" style="max-height: 500px; overflow-y: auto; border: 1px solid #4A5568; padding: 0; list-style:none; border-radius:0.25rem;">
                <li style="text-align:center; padding:1rem; opacity:0.7;"><p>Loading stops...</p></li>
            </ul>
            <button id="applyMasterListStopIdChangesButton_extra" class="button save" style="margin-top:1rem;">Apply All Proposed Stop ID Changes (Bulk)</button>
            <p id="masterListApplyChangesStatus_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
        </div>

        <div class="subsection">
            <h3 class="subsection-title">Stop Name/Direction Duplicate Management</h3>
            <button id="findDuplicateStopsByNameDirButton_extra" class="button tertiary">Find Duplicates (Name/Dir)</button>
            <div id="duplicateStopsByNameDirResults_extra" style="margin-top:0.75rem;">
                <p>Click button above to scan for stops with identical names and directions but different StopIDs.</p>
            </div>
        </div>
    </div>

    <div id="global-route-deletion-section_extra" class="tool-content-section section" style="display:none;">
        <h2>Global Route Deletion (Live)</h2>
        <p style="font-size:0.9em; margin-bottom:1.5em; opacity:0.8;">
            Click on route tiles below to select them for deletion. This action deletes ALL data for the selected route(s) from the live schedule, including global and stop-specific color settings. This is irreversible.
        </p>
        <div class="form-field-group">
            <label style="display:block; margin-bottom:0.5rem;">Select Route(s) to Delete Globally by clicking tiles:</label>
            <div id="globalRouteDeletionListContainer_el_extra" class="subsection selectable-route-tile-container" style="max-height: 300px; overflow-y: auto; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border: 1px solid rgba(127,140,141,0.2); min-height:50px;">
                <p style="width:100%; text-align:center; opacity:0.7;">Loading routes...</p>
            </div>
        </div>
        <button id="deleteEntireRouteButton_el_extra" class="button secondary" style="margin-top: 0.5rem;">Delete Selected Route(s) (Live)</button>
        <p id="deleteEntireRouteStatusMessage_el_extra" style="min-height:1.2em; margin-top:0.75rem;"></p>
    </div>
    
    <div id="route-schedule-generator-section_extra" class="tool-content-section section" style="display:none;">
        <h2>Route Schedule Generator</h2>
        <p style="font-size:0.9em; margin-bottom:1.5em; opacity:0.8;">
            Define a route, its operating profile(s), primary destination, a sequence of stops with inter-stop timings, and departure times for the first stop. Then generate, preview, and add the full schedule to the main working schedule or schedule it for a future go-live.
        </p>
        <div> <div class="subsection">
                <h3 class="subsection-title">1. Route, Profile & Destination</h3>
                <div class="form-field-group">
                    <label>Select Route Name (click a tile to select):</label>
                    <div id="rsg-route-selection-container-extra" class="selectable-route-tile-container" style="max-height: 150px; overflow-y: auto; background-color: rgba(0,0,0,0.05); padding: 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(127,140,141,0.2); min-height:50px;">
                        <p id="rsg-routes-placeholder-extra" style="width:100%; text-align:center; opacity:0.7;">Loading routes...</p>
                    </div>
                    <div style="margin-top:0.25rem; display:flex; justify-content:space-between; align-items:center;">
                        <span style="font-size:0.8em;">Selected Route: <strong id="rsg-selected-route-display-extra" style="color:#f1c40f;">(None selected)</strong></span>
                        <button id="rsg-clear-route-selection-button-extra" class="button small-action neutral">Clear Selection</button>
                    </div>
                    <input type="hidden" id="rsg-routeName-input-extra" value="">
                </div>
                <div class="form-field-group">
                    <label>Operating Profile(s) (select one or more):</label>
                    <div id="rsg-selectable-profiles-container-extra" class="selectable-route-tile-container" style="background-color: rgba(0,0,0,0.05); padding: 0.5rem; border-radius: 0.25rem; min-height:30px;">
                        <p id="rsg-profiles-placeholder-extra" style="font-size:0.85em; opacity:0.7;">Loading profiles...</p>
                    </div>
                    <div style="margin-top:0.25rem; display:flex; justify-content:space-between; align-items:center;">

                        <span style="font-size:0.8em;">Currently Selected: <strong id="rsg-selected-profiles-display-extra" style="color:#f1c40f;">(None selected)</strong></span>
                        <button id="rsg-clear-profile-checkboxes-button-extra" class="button small-action neutral">Clear Selection</button>
                    </div>

<div class="rsg-info-box" style="font-size: 0.85em; padding: 0.85rem 1rem; margin-top: 1.5rem; border: 1px solid #f39c12; border-radius: 0.375rem; background-color: rgba(243,156,18,0.08);">
    <h5 style="margin-top:0; font-weight:bold; color:#f1c40f; font-size:1.05em;">Tips for Scheduling Overnight Services on New Years Eve:</h5>
    <ul style="list-style-type: disc; padding-left: 20px; margin:0; line-height:1.5;">
        <li style="margin-bottom:0.3em;">Assign services starting on <span style="border: 1px solid #7f8c8d; padding: 0.1em 0.4em; border-radius: 0.25rem; background-color: rgba(255,255,255,0.05);">New Years Eve</span>.</li>
        <li style="margin-bottom:0.3em;">In RSG, list all First Stop Departure times for journeys that begin during this service period until the final departure before midnight (e.g., from 05:00 through to 23:30).</li>
        <li style="margin-bottom:0.3em;">Regular services for <span style="border: 1px solid #7f8c8d; padding: 0.1em 0.4em; border-radius: 0.25rem; background-color: rgba(255,255,255,0.05);">New Years Day</span> should be scheduled under that day's own Operating Profile.</li>
        <li style="margin-bottom:0.3em;">Activate the correct profile for each calendar date using the "Day Profile Override" tool.</li>
        <li>
            <p style="margin-bottom: 0.25em;">It should look something like this:</p>
            <ul style="list-style-type: disc; padding-left: 1.5em; margin-top: 0.5em; margin-bottom: 0.5em;"> 
                <li style="margin-bottom: 0.35em;">Operating Profile: 
                    <span style="border: 1px solid #7f8c8d; padding: 0.1em 0.4em; border-radius: 0.25rem; background-color: rgba(255,255,255,0.05);">05:00</span> 
                    - all the way through until the final departure before midnight - 
                    <span style="border: 1px solid #7f8c8d; padding: 0.1em 0.4em; border-radius: 0.25rem; background-color: rgba(255,255,255,0.05);">23:30</span>
                </li>
                <li style="margin-bottom: 0.35em;">
                    Operating Profile: 
                    <span style="border: 1px solid #7f8c8d; padding: 0.1em 0.4em; border-radius: 0.25rem; background-color: rgba(255,255,255,0.05);">New Years Day</span> 
                    - Start of overnight service 
                    <span style="border: 1px solid #7f8c8d; padding: 0.1em 0.4em; border-radius: 0.25rem; background-color: rgba(255,255,255,0.05);">00:00</span> 
                    - all the way through until the end of normal service.
                </li>
                <li style="margin-bottom: 0.35em;">
                    Operating Profile: 
                    <span style="border: 1px solid #7f8c8d; padding: 0.1em 0.4em; border-radius: 0.25rem; background-color: rgba(255,255,255,0.05);">Your next day's profile</span> 
                    - Start of normal service 
                    <span style="border: 1px solid #7f8c8d; padding: 0.1em 0.4em; border-radius: 0.25rem; background-color: rgba(255,255,255,0.05);">05:00</span> 
                    - all the way through until the end of normal service.
                </li>
            </ul>
        </li>
    </ul>
</div>
</div>
                <div class="form-field-group">
                    <label for="rsg-destinationName-select-extra">Primary Destination (Select or Type):</label>
                    <select id="rsg-destinationName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                        <option value="">-- Select Existing Destination --</option>
                    </select>
                    <input type="text" id="rsg-destinationName-input-extra" class="schedule-generator-input" placeholder="e.g., Amcotts or type new">
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">2. Stop Sequence & Timings</h3>
                <div class="form-field-group">
                    <label for="rsg-stop-search-input-extra">Add Stop to Sequence (Search by Name/ID):</label>
                    <input type="text" id="rsg-stop-search-input-extra" class="schedule-generator-input" placeholder="Type to search stops...">
                    <div id="rsg-stop-search-results-extra"></div>
                </div>
                <div class="form-field-group" style="margin-top: 0.75rem; margin-bottom: 0.75rem;">
                    <button id="rsg-open-copy-modal-button-extra" class="button neutral" style="width:100%;">Copy Stop Sequence From Route</button>
                </div>
                <div class="form-field-group">
                    <label>Current Stop Sequence (Drag to reorder):</label>
                    <ul id="rsg-stop-sequence-list-extra" style="border: 1px solid #4A5568; padding: 0.5rem; border-radius: 0.25rem; background-color: rgba(0,0,0,0.05);">
                        <p id="rsg-stop-sequence-placeholder-extra" style="text-align:center; opacity:0.7; padding:1rem;">Search and add stops above.</p> </ul>
                </div>
                <div id="rsg-first-stop-times-container-extra" class="form-field-group" style="display:none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                        <label for="rsg-first-stop-times-input-extra">Departure Times for First Stop (HH:MM, TAB separated):</label>
                        <button id="rsg-pull-first-stop-times-button-extra" class="button neutral" style="padding: 0.2em 0.6em; font-size: 0.8em; line-height: 1.2;">Pull Current Times</button>
                    </div>
                    <textarea id="rsg-first-stop-times-input-extra" class="schedule-generator-input" rows="2" placeholder="e.g., 07:00	07:15	07:30 (use Tab to separate)"></textarea>
                </div>
            </div>
            <div id="rsg-schedule-preview-container-extra" class="subsection" style="margin-top:1.5rem; display:none;">
                <h3 class="subsection-title">Schedule Preview</h3>
                <div style="max-height: 400px; overflow-y: auto;">
                    <table id="rsg-preview-table-extra" style="width:100%; border-collapse:collapse; font-size:0.85em;">
                        <thead>
                            <tr style="background-color:#34495e;">
                                <th style="padding:5px; border:1px solid #4A5568;">StopID</th>
                                <th style="padding:5px; border:1px solid #4A5568;">StopName</th>
                                <th style="padding:5px; border:1px solid #4A5568;">Time</th>
                                <th style="padding:5px; border:1px solid #4A5568;">Route</th>
                                <th style="padding:5px; border:1px solid #4A5568;">Dest</th>
                                <th style="padding:5px; border:1px solid #4A5568;">Profile</th>
                                <th style="padding:5px; border:1px solid #4A5568;">Offset</th>
                            </tr>
                        </thead>
                        <tbody>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="subsection">
                <h3 class="subsection-title">3. Actions & Configurations</h3>
                <div class="form-field-group" style="display: flex; flex-wrap:wrap; gap:0.5rem; margin-bottom: 0.5rem;"> <button id="rsg-generate-schedule-button-extra" class="button" style="flex: 1 1 auto; min-width: 200px;">Generate Schedule Preview</button>
                    <button id="rsg-schedule-this-config-button-extra" class="button tertiary" style="flex: 1 1 auto; min-width: 200px;">Schedule Current Setup</button>
                </div>
                <div class="form-field-group" style="display: flex; flex-wrap:wrap; gap:0.5rem; margin-bottom: 0.5rem;"> <button id="rsg-save-configuration-button-extra" class="button" style="flex: 1 1 auto; min-width: 200px;">Save Current Setup</button>
                    <button id="rsg-add-to-working-schedule-button-extra" class="button neutral" style="flex: 1 1 auto; min-width: 200px;" disabled>Add Preview to Working Schedule (Live)</button>
                </div>

                <div class="form-field-group" style="margin-top: 1rem;">
                     <button id="rsg-schedule-selected-configs-button-extra" class="button save" style="width:100%;" disabled>Schedule Selected Saved Configurations</button>
                </div>

                <div class="form-field-group" style="margin-top: 1rem;">
                     <label>Saved Configurations (click name to load, or tick to schedule):</label>
                     <div style="margin-bottom: 0.5em; padding: 0.25em 0;">
                         <input type="checkbox" id="rsg-select-all-configs-checkbox-extra" style="vertical-align: middle; margin-right: 5px;">
                         <label for="rsg-select-all-configs-checkbox-extra" style="cursor:pointer; color: #ecf0f1; font-size: 0.9em;">Select All (Everything)</label>
                     </div>
                     <div id="rsg-saved-configs-list-extra" style="border: 1px solid #4A5568; padding:0.25rem 0.5rem; border-radius: 0.25rem; background-color: rgba(0,0,0,0.05); min-height: 50px;">
                         <p id="rsg-no-saved-configs-message-extra" style="padding:0.5em; text-align:center; opacity:0.7;">Loading saved configurations...</p>
                     </div>
                     <p id="rsg-load-status-message-extra" style="font-size:0.8em; min-height:1.1em; margin-top:0.25rem;"></p>
                </div>
            </div>
        </div>
        <p id="rsg-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold; text-align:center;"></p>
    </div>

    <div id="route-profile-deletion-section_extra" class="tool-content-section section" style="display:none;">
         <h2>Selective Route Profile Deletion</h2>
        <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
            Select a route, optionally a specific destination, and then one or more operating profiles to delete all associated schedule entries from the live Firebase data.
        </p>
        <div class="subsection">
            <h3 class="subsection-title">1. Select Route & Destination (Optional)</h3>
            <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));">
                <div>
                    <label for="rpd-route-name-select-extra">Route Name (Select or Type):</label>
                    <select id="rpd-route-name-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                        <option value="">-- Select Existing Route --</option>
                    </select>
                    <input type="text" id="rpd-route-name-input-extra" class="schedule-generator-input" placeholder="e.g., 35 or type new">
                </div>
                <div>
                    <label for="rpd-destination-name-select-extra">Destination (Optional - Select or Type):</label>
                    <div style="display:flex; align-items: center; gap: 0.5rem;">
                        <select id="rpd-destination-name-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem; flex-grow:1;">
                            <option value="">-- Optional: All Destinations --</option>
                        </select>
                        <button id="rpd-clear-destination-button-extra" class="button small-action neutral" title="Clear Destination Filter" style="display:none;">&#x2715;</button>
                    </div>
                    <input type="text" id="rpd-destination-name-input-extra" class="schedule-generator-input" placeholder="Leave blank for all destinations">
                </div>
            </div>
        </div>
        <div class="subsection">
            <h3 class="subsection-title">2. Select Profile(s) to Delete for this Route/Destination</h3>
            <div id="rpd-profile-list-container-extra" class="selectable-route-tile-container" style="min-height: 50px; padding:0.5rem; background-color: rgba(0,0,0,0.05); border-radius:0.25rem; border:1px solid #4A5568;">
                <p style="font-size:0.85em; opacity:0.7; width:100%; text-align:center;">Select a route (and optionally destination) above.</p>
            </div>
        </div>
        <div class="subsection">
             <h3 class="subsection-title">3. Execute Deletion</h3>
            <button id="rpd-delete-profiles-button-extra" class="button secondary">Delete Selected Profile(s) for Route/Destination</button>
            <p id="rpd-status-message-extra" style="min-height:1.2em; margin-top: 0.75rem; font-weight:bold;"></p>
        </div>
    </div>

    <div id="view-departures-section_extra" class="tool-content-section section" style="display:none;">
    <h2 style="margin-bottom:1rem;">View Departures</h2>
    <div class="subsection view-stop-departures">
        <h3 class="subsection-title">Scheduled Departures by Stop</h3>
        <div class="form-grid" style="grid-template-columns: 1fr; align-items: start; gap: 1.5rem;">
            <div>
                <label for="selectStopForDeparturesView_extra">Bus Stop</label>
                <select id="selectStopForDeparturesView_extra">
                    <option value="">-- Select Stop --</option>
                </select>
            </div>
            <div>
                <label>Departures (Sorted by Day Offset -> Profile -> Time)</label>
                <div id="stopDeparturesListContainer_extra" style="max-height: 400px; overflow-y: auto; border: 1px solid #4A5568; padding: 0.5rem; border-radius: 0.25rem;">
                    <ul id="stopDeparturesList_extra"></ul>
                    <p id="noDeparturesForStopMessage_extra" style="padding: 0.5rem;">Select a stop to view departures.</p>
                </div>
            </div>
        </div>
    </div>
</div>
    
    <div id="timetable-exporter-section_extra" class="tool-content-section section" style="display:none;">
        <h2>Route Timetable Exporter</h2>
        <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
            Select a route to download its full timetable as a PDF file.
        </p>
        <div class="subsection">
            <h3 class="subsection-title">Select Route</h3>
            <div class="form-grid" style="grid-template-columns: 3fr 1fr; align-items: end;">
                <div>
                    <label for="tte-routeName-select-extra">Route Name (Select or Type):</label>
                    <select id="tte-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                        <option value="">-- Select Route --</option>
                    </select>
                    <input type="text" id="tte-routeName-input-extra" class="schedule-generator-input" placeholder="Or Type Route Name">
                </div>
                <div>
                    <button id="tte-downloadTimetable-button-extra" class="button save" style="width:100%;">Download Timetable</button>
                </div>
            </div>
            <p id="tte-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
        </div>
    </div>

    <div id="scheduled-route-updates-section_extra" class="tool-content-section section" style="display:none;">
        <h2>Scheduled Tasks</h2>
        <p style="font-size:0.9em; margin-bottom:1.5em; opacity:0.8;">
            View and manage route timetables and deletions scheduled to go live automatically.
        </p>
        <div class="subsection">
             <h3 class="subsection-title">Master Controls for Pending Timetable Updates</h3>
            <button id="sru-refresh-list-button-extra" class="button neutral" style="margin-bottom:1rem;">Refresh Task List</button>

            <div id="sru-apply-all-batches-section-extra" style="margin-bottom: 2rem; border: 1px solid #607D8B; padding: 1rem; border-radius:0.25rem; background-color: rgba(0,0,0,0.08);">
                <h4 class="subsection-title" style="font-size: 1.15em; color: #A5D6A7; margin-top:0;">Apply All Pending Batches for a Specific Go-Live Time</h4>
                <p style="font-size:0.85em; opacity:0.85; margin-bottom:1rem; color: #f1c40f;">
                    <strong>Important:</strong> Select a Go-Live Date/Time from the list below. Clicking "Apply All for Selected Time"
                    will process <strong>ALL</strong> pending timetable updates scheduled for that exact time, across <strong>ALL</strong> affected routes simultaneously.
                    For each affected route, its entire current schedule will be <strong>DELETED</strong> and replaced by the new schedule entries from the batch.
                    This is a significant bulk operation.
                </p>
                <div id="sru-batch-golive-radios-container-extra" style="margin-bottom: 1rem; background-color: rgba(0,0,0,0.08); padding: 1rem; border-radius: 0.375rem; border: 1px solid rgba(127,140,141,0.2);">
                    <p style="opacity:0.7;">Loading available batch go-live times...</p>
                </div>
                <button id="sru-apply-all-for-time-button-extra" class="button save" style="background-color: #e67e22; width:100%; padding: 0.75rem; font-size: 1em;" disabled>Apply All Updates for Selected Go-Live Time</button>
                <p id="sru-apply-all-status-message-extra" style="min-height:1.5em; margin-top:1rem; font-weight:bold; text-align:center;"></p>
            </div>

            <div style="margin-top: 2rem; border-top: 2px solid #e74c3c; padding-top: 1.5rem; background-color: rgba(231, 76, 60, 0.05); padding:1rem; border-radius:0.25rem;">
                <h4 class="subsection-title" style="color: #e74c3c; font-size:1.15em; margin-top:0;">Global Cancellation - Danger Zone</h4>
                <p style="font-size:0.85em; opacity:0.85; margin-bottom:1rem; color: #fAD7A0;">
                    <strong>EXTREME CAUTION:</strong> Clicking the button below will attempt to cancel <strong>ALL</strong> currently pending timetable updates
                    across <strong>ALL routes and ALL scheduled go-live times</strong>. This action cannot be undone.
                    <br>(Scheduled <i>route deletions</i> will NOT be affected by this button.)
                </p>
                <button id="sru-cancel-all-pending-updates-globally-button-extra" class="button secondary" style="width:100%; background-color: #c0392b; padding: 0.75rem; font-size: 1em;">
                    Cancel ALL Pending Timetable Updates (Global)
                </button>
                <p id="sru-cancel-all-global-status-message-extra" style="min-height:1.5em; margin-top:1rem; font-weight:bold; text-align:center;"></p>
            </div>
        </div>

        <div class="subsection" style="margin-top:2rem;">
            <h3 class="subsection-title">Individually Pending & Actionable Scheduled Tasks</h3>
            <div id="sru-updates-list-container-extra" style="background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border:1px solid rgba(127,140,141,0.2); min-height:100px;">
                <p>Loading scheduled tasks...</p>
            </div>
        </div>
    </div>

    <div id="scheduled-route-deletion-section_extra" class="tool-content-section section" style="display:none;">
        <h2>Schedule Route Deletion</h2>
        <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
            Select a route and a future date/time to schedule its complete deletion from the live schedule and associated settings.
            The deletion will need to be manually confirmed or processed from the "Scheduled Tasks" list when due.
        </p>
        <div class="subsection">
            <h3 class="subsection-title">Select Route and Go-Live Time</h3>
            <div class="form-grid" style="grid-template-columns: 2fr 1.5fr 1fr; align-items: end;">
                <div>
                    <label for="srd-routeName-select-extra">Route Name (Select or Type):</label>
                    <select id="srd-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                        <option value="">-- Select Route --</option>
                    </select>
                    <input type="text" id="srd-routeName-input-extra" class="schedule-generator-input" placeholder="Or Type Route Name">
                </div>
                <div>
                    <label for="srd-go-live-datetime-input-extra">Deletion Go-Live Date and Time:</label>
                    <input type="datetime-local" id="srd-go-live-datetime-input-extra" class="schedule-generator-input">
                </div>
                <div>
                    <button id="srd-schedule-deletion-button-extra" class="button secondary" style="width:100%;">Schedule Deletion</button>
                </div>
            </div>
            <p id="srd-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
        </div>
    </div>

    <div id="config-data-section_extra" class="tool-content-section section" style="display:none;">
        <h2>Configuration Data Management</h2>
        <div class="subsection">
            <h3 class="subsection-title">School Holiday Periods Management</h3>
            <div id="school-holidays-display-extra" style="margin-bottom: 1rem; min-height: 50px;">
                <p>Loading school holiday periods...</p>
            </div>
            <div class="subsection" style="background-color: rgba(0,0,0,0.1); padding:1rem; border-radius:0.25rem;">
                <h4 class="subsection-title" style="margin-top:0;">Add/Edit School Holiday Period</h4>
                <input type="hidden" id="sh-editing-id-extra">
                <div class="form-grid" style="grid-template-columns: 1fr 1fr 2fr auto; align-items: end;">
                    <div>
                        <label for="sh-start-date-input-extra">Start Date:</label>
                        <input type="date" id="sh-start-date-input-extra" class="schedule-generator-input">
                    </div>
                    <div>
                        <label for="sh-end-date-input-extra">End Date:</label>
                        <input type="date" id="sh-end-date-input-extra" class="schedule-generator-input">
                    </div>
                    <div>
                        <label for="sh-description-input-extra">Description (Optional):</label>
                        <input type="text" id="sh-description-input-extra" class="schedule-generator-input" placeholder="e.g., Summer Half Term">
                    </div>
                    <div style="padding-bottom:0.05rem;">
                        <button id="sh-save-button-extra" class="button save">Save/Add Period</button>
                        <button id="sh-clear-form-button-extra" class="button neutral" style="display:none;">Cancel Edit</button>
                    </div>
                </div>
            </div>
            <p id="sh-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
        </div>
        <div class="subsection" style="margin-top: 2rem;">
            <h3 class="subsection-title">Operating Profiles Management</h3>
            <p style="font-size:0.9em; margin-bottom:1em; opacity: 0.8;">
                Manage the list of operating profiles used throughout the tools. Changes here will be saved to Firebase.
            </p>
            <div class="form-field-group">
                <label for="op-profile-input-extra">New Profile Name:</label>
                <div style="display: flex; gap: 0.5rem;">
                    <input type="text" id="op-profile-input-extra" class="schedule-generator-input" placeholder="e.g., SundayBankHol">
                    <button id="op-profile-add-button-extra" class="button save">Add Profile</button>
                </div>
            </div>
            <div id="op-profiles-list-extra" style="margin-top: 1rem; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border:1px solid rgba(127,140,141,0.2); min-height: 100px;">
                <p>Loading operating profiles...</p>
            </div>
            <p id="op-profiles-status-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
            <div style="margin-top:1rem; padding:0.75rem; border: 1px dashed #f39c12; border-radius:0.25rem; background-color: rgba(243,156,18,0.05);">
                <h4 style="margin-top:0; color:#f39c12; font-size:1.1em;">Important Considerations:</h4>
                <ul style="font-size:0.85em; list-style-position:inside; padding-left:0.5em; white-space:normal; word-wrap:break-word;">
                    <li>Renaming or deleting profiles (especially common ones like "Mo", "MF", "Sa", "Su", "MFSch", etc.) can affect the hardcoded "Profile Groups" (e.g., MF = Mon-Fri) and "Valid Profile Combinations" used in the Route Schedule Generator and Day Profile Override tools.</li>
                    <li>If you change a profile name that's part of these hardcoded rules, the checkbox logic for those tools might not behave as expected for grouped or combined selections involving the altered profile.</li>
                    <li>This management UI does NOT dynamically update those hardcoded JavaScript constants (`RSG_PROFILE_GROUPS_TO_MANAGE`, `MASTER_VALID_PROFILE_COMBINATIONS_LIST_EXTRA`). Developer intervention would be needed in the script to align them with major profile name changes or deletions if full compatibility is required.</li>
                    <li>You will also be warned if a profile is currently used in any saved RSG configurations, live schedules, or day profile overrides before deletion/editing.</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div id="calendar-view-section_extra" class="tool-content-section section" style="display:none;">
        <h2>Events & Operations Calendar</h2>
        <div class="subsection">
            <div class="calendar-tool-header">
                <button id="cv-prev-month-btn_extra" class="button">&lt; Prev Month</button>
                <h3 id="cv-month-year-display_extra" style="margin:0; font-size: 1.4em;">Month Year</h3>
                <button id="cv-next-month-btn_extra" class="button">Next Month &gt;</button>
            </div>
            <div class="calendar-grid-container-extra"> 
                <div id="events-calendar-grid_extra">
                    </div>
            </div>
            <div id="calendar-day-details_extra" style="margin-top: 1.5rem; padding: 1rem; background-color: rgba(0,0,0,0.1); border-radius: 0.25rem; min-height: 50px;">
                <p>Click on a day to see details.</p>
            </div>
        </div>
    </div>

</div> 
        <div id="rsg-save-config-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content">
                <h4 style="margin-top:0;">Save Configuration As</h4>
                <div class="form-field-group">
                    <label for="rsg-config-name-input-extra">Configuration Name:</label>
                    <input type="text" id="rsg-config-name-input-extra" class="schedule-generator-input" placeholder="e.g., 4_Skippingdale_MFSch">
                </div>
                <div class="rsg-modal-actions">
                    <button id="rsg-save-config-confirm-button-extra" class="button save">Save</button>
                    <button id="rsg-save-config-cancel-button-extra" class="button neutral">Cancel</button>
                </div>
                <p id="rsg-save-config-modal-status-extra" style="min-height:1.2em; margin-top:0.75em; font-size:0.85em;"></p>
            </div>
        </div>

        <div id="rsg-copy-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content" style="max-width: 550px;">
                <h3 class="subsection-title" style="margin-top:0; padding-bottom: 0.5rem; border-color: #567a9a;">Copy Stops From Source</h3>
                <div class="form-field-group">
                    <label for="rsg-copy-source-routeName-select-extra">Source Route:</label>
                     <select id="rsg-copy-source-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                        <option value="">-- Select Source Route --</option>
                    </select>
                </div>
                <div class="form-field-group">
                    <label for="rsg-copy-source-operatingProfile-select-extra">Source Operating Profile:</label>
                    <select id="rsg-copy-source-operatingProfile-select-extra" class="schedule-generator-input">
                        <option value="">-- Select Profile --</option>
                    </select>
                </div>
                <div class="form-field-group">
                     <label for="rsg-copy-source-destinationName-select-extra">Source Destination:</label>
                     <select id="rsg-copy-source-destinationName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                        <option value="">-- Select Source Destination --</option>
                    </select>
                </div>
                <p id="rsg-copy-modal-status-extra" style="min-height:1.2em; margin-top:0.5em; font-size:0.85em;"></p>
                <div class="rsg-modal-actions">
                    <button id="rsg-copy-modal-action-button-extra" class="button save">Copy Data</button>
                    <button id="rsg-copy-modal-cancel-button-extra" class="button neutral">Cancel</button>
                </div>
            </div>
        </div>

        <div id="rsg-schedule-datetime-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content">
                <h4 style="margin-top:0;">Set Go-Live Date & Time</h4>
                 <div class="form-field-group">
                    <label for="rsg-go-live-datetime-input-extra">Scheduled Go-Live Date and Time:</label>
                    <input type="datetime-local" id="rsg-go-live-datetime-input-extra" class="schedule-generator-input">
                </div>
                <div class="rsg-modal-actions">
                    <button id="rsg-schedule-datetime-confirm-button-extra" class="button save">Confirm Schedule</button>
                    <button id="rsg-schedule-datetime-cancel-button-extra" class="button neutral">Cancel</button>
                </div>
                <p id="rsg-schedule-datetime-modal-status-extra" style="min-height:1.2em; margin-top:0.75em; font-size:0.85em;"></p>
            </div>
        </div>

        <div id="sru-cancel-route-time-select-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content" style="max-width: 600px;">
                <h4 id="sru-cancel-modal-title-extra" style="margin-top:0;">Select Go-Live Time(s) to Cancel Updates</h4>
                <p id="sru-cancel-modal-route-info-extra" style="margin-bottom: 1rem; font-size: 0.9em;"></p>
                <div class="form-field-group">
                    <div style="margin-bottom: 0.5em; padding: 0.25em 0; border-bottom: 1px solid #567a9a; margin-bottom: 0.75em;">
                        <input type="checkbox" id="sru-cancel-modal-select-all-times-extra" style="vertical-align: middle; margin-right: 5px;">
                        <label for="sru-cancel-modal-select-all-times-extra" style="cursor:pointer; color: #ecf0f1; font-size: 0.9em;">Select All Times Below</label>
                    </div>
                    <div id="sru-cancel-modal-checkboxes-container-extra" style="max-height: 200px; overflow-y: auto; padding: 0.5rem; border: 1px solid #567a9a; border-radius: 0.25rem; background-color: rgba(0,0,0,0.05);">
                        <p style="opacity:0.7;">Loading available times...</p>
                    </div>
                </div>
                <div class="rsg-modal-actions">
                    <button id="sru-cancel-modal-confirm-button-extra" class="button secondary">Confirm Cancellation for Selected Time(s)</button>
                    <button id="sru-cancel-modal-cancel-button-extra" class="button neutral">Close</button>
                </div>
                <p id="sru-cancel-modal-status-extra" style="min-height:1.2em; margin-top:0.75em; font-size:0.85em;"></p>
            </div>
        </div>

        <div id="rsg-replace-stop-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content" style="max-width: 550px;">
                <h4 id="rsg-replace-stop-modal-title-extra" style="margin-top:0;">Replace Stop in Sequence</h4>
                <p id="rsg-replace-stop-modal-info-extra" style="font-size:0.9em; margin-bottom:1rem;">Replacing stop...</p>
                <div class="form-field-group">
                    <label for="rsg-replace-stop-search-input-extra">Search for New Stop (Name/ID):</label>
                    <input type="text" id="rsg-replace-stop-search-input-extra" class="schedule-generator-input" placeholder="Type to search stops...">
                    <div id="rsg-replace-stop-search-results-extra" style="max-height: 200px; overflow-y: auto; border: 1px solid #4A5568; border-radius: 0.25rem; background-color: #34495e; margin-top: 0.25rem;">
                    </div>
                </div>
                <div class="rsg-modal-actions">
                    <button id="rsg-replace-stop-modal-cancel-button-extra" class="button neutral">Cancel</button>
                </div>
                <p id="rsg-replace-stop-modal-status-extra" style="min-height:1.2em; margin-top:0.75em; font-size:0.85em;"></p>
            </div>
        </div>

    </div>
<script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s", // Replace with your actual Firebase API Key
        authDomain: "omsi-c5505.firebaseapp.com", // Replace with your actual Firebase Auth Domain
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app", // Replace with your actual Firebase Database URL
        projectId: "omsi-c5505", // Replace with your actual Firebase Project ID
        storageBucket: "omsi-c5505.appspot.com", // Replace with your actual Firebase Storage Bucket
        messagingSenderId: "503595375440", // Replace with your actual Firebase Messaging Sender ID
        appId: "1:503595375440:web:356be6684b77ff5909ea55", // Replace with your actual Firebase App ID
        measurementId: "G-VN7X65V3F9" // Replace with your actual Firebase Measurement ID
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);

      window.firebaseOMSI = {
          database: database, auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut
      };
      document.dispatchEvent(new CustomEvent('firebaseReady', { detail: window.firebaseOMSI }));
    </script>

<script>
// --- Global State Variables ---
        let rsg_configKeyToRename_extra = null;
        let currentUser_extra = null;
        let pageSpecificSettings = {};
        let rsg_currentlyEditingConfigKey_extra = null;
        let rsg_currentlyEditingConfigDisplayName_extra = null;
        let rsg_isDirty = false;
	let serviceTerminusMappings_extra = {};
	let cv_currentDisplayDate_extra = new Date();
        let rsg_batchScheduleItems = [];
        let allDefinedStops_data = {};
	let dpo_selectedRoutes_extra = []; // New: Stores routes selected for DPO override
        let dpo_currentOverridesForSelectedDate = {}; // New: Stores the route-specific overrides for the currently selected date.
        let rsg_indexOfStopToReplace_extra = -1;
        let sruCancelModalContext = { routeName: null };
        let scheduledRouteDeletions_extra = {};
	let cachedScheduledTasksHTML_extra = null;
	let cachedBatchRadiosHTML_extra = null;
	let isScheduledTasksCacheValid_extra = false;
	let operationalOverrides_data = {};
        let stopToServingRoutesMap_extra = new Map();
        let ukBankHolidaysData_extra = { dates: [], titles: {} };
        let schoolHolidayDateRanges_extra = [];

        let currentWorkingSchedule_extra = []; // This will be populated by flattening the new structure on load
        let closedStopIDs_extra = [];
        let globalCustomRouteColours_extra = {};
        let stopSpecificRouteColours_extra = {};
        let uniqueStopsMasterList_extra = [];
        let processedExcelStopsData_extra = [];
        let rsg_selectedStops_extra = [];
        let rsg_generatedPreviewEntries_extra = [];
        let rsg_loadedConfigs_extra = {};
	let todayKeyTripEvents_extra = []; // Stores { lineName, destinationName, originStopName, departureTime, departureTimeObj, type: 'first'|'last' }
	let shownTripAlerts_extra = {};    // Tracks shown alerts: key = "Route|Dest|Type|Time", value = true
	let lastAlertDataPreparedDate_extra = null; // To know when to refresh todayKeyTripEvents_extra
	let tripAlertIntervalId_extra = null; // To store the setInterval ID
        let rsg_lastLoadedRouteName_extra = null;
        let rsg_lastLoadedDestName_extra = null;
        let rsg_lastLoadedOpProfile_extra = null;
        let rsg_draggedItemIndex_extra = null;
	let rsg_selectedRoute_extra = null; // Stores the currently selected route for RSG
        let scheduledRouteUpdates_extra = {};
	let RSG_OPERATING_PROFILES_LIST = [ // This will now be populated from Firebase or seeded with these defaults
    "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su",
    "MF",
    "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MFSch",
    "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MFNSD",
    "Christmas Eve", "Christmas Day", "Boxing Day", "New Years Eve", "New Years Day", "Special", "SpMo", "SpTu", "SpWe",
    "SpTh", "SpFr", "SpSa", "SpSu"
];



        // --- Firebase Path Constants ---
        const FB_PATH_PAGE_EXTRA_SETTINGS = '/settings/extraModulesPageSettings';
        const FB_PATH_OPERATIONAL_OVERRIDES = '/operationalOverrides';
        const FB_PATH_SCHEDULED_DELETIONS = '/scheduledRouteDeletions';
        const FB_PATH_SCHEDULES_BY_ROUTE = '/liveSchedule/schedulesByRoute'; // New path for structured schedule data
	const FB_PATH_SERVICE_TERMINUS_MAPPINGS = '/settings/serviceTerminusMappings';
        const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
        const FB_PATH_APPSTATE_LAST_UPDATED = '/appState/scheduleLastUpdated';
        const FB_PATH_APPSTATE_CLOSED_STOPS = '/appState/closedStopIDs';
        const FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS = '/settings/customRouteColours';
        const FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS = '/settings/stopSpecificRouteColours';
        const FB_PATH_RSG_CONFIGS = '/rsgConfigs';
        const FB_PATH_ALL_DEFINED_STOPS = '/allDefinedStops';
        const FB_PATH_SCHEDULED_UPDATES = '/scheduledUpdates';
	const ALERT_LEAD_TIME_MINUTES = 15; // Notify 15 minutes before departure
	const ALERT_CHECK_INTERVAL_MS = 30 * 1000; // Check every 30 seconds (adjust as needed)
        const FB_PATH_SCHEDULED_ROUTE_UPDATES = '/scheduledRouteUpdates';
        const BANK_HOLIDAY_CACHE_DURATION_MS = 24 * 60 * 60 * 1000;
	const FB_PATH_EDITABLE_OP_PROFILES = '/settings/operatingProfilesList';
	const FB_PATH_SCHOOL_HOLIDAYS = '/settings/schoolHolidayRanges';
	const DEFAULT_SCHOOL_HOLIDAY_RANGES = [
    { id: 'sh-20250524', start: '2025-05-24', end: '2025-06-01', description: "Summer half term 2025" },
    { id: 'sh-20250719', start: '2025-07-19', end: '2025-09-02', description: "Summer holidays 2025" },
    { id: 'sh-20251025', start: '2025-10-25', end: '2025-11-02', description: "Autumn half term 2025" },
    { id: 'sh-20251220', start: '2025-12-20', end: '2026-01-04', description: "Christmas 2025/26" },
    { id: 'sh-20260214', start: '2026-02-14', end: '2026-02-22', description: "Spring half term 2026" },
    { id: 'sh-20260403', start: '2026-04-03', end: '2026-04-20', description: "Easter 2026" },
    { id: 'sh-20260523', start: '2026-05-23', end: '2026-05-31', description: "Summer half term 2026" },
    { id: 'sh-20260718', start: '2026-07-18', end: '2026-09-02', description: "Summer holidays 2026" },
    { id: 'sh-20261024', start: '2026-10-24', end: '2026-11-01', description: "Autumn half term 2026" },
    { id: 'sh-20261219', start: '2026-12-19', end: '2027-01-04', description: "Christmas 2026/27" },
    { id: 'sh-20270213', start: '2027-02-13', end: '2027-02-21', description: "Spring half term 2027" },
    { id: 'sh-20270326', start: '2027-03-26', end: '2027-04-13', description: "Easter 2027" },
    { id: 'sh-20270529', start: '2027-05-29', end: '2027-06-06', description: "Summer half term 2027" },
    { id: 'sh-20270722', start: '2027-07-22', end: '2027-08-31', description: "Summer holidays 2027" }
];


        // --- DOM Elements ---
        const tteRouteNameSelect_el_extra = document.getElementById('tte-routeName-select-extra');
        const tteRouteNameInput_el_extra = document.getElementById('tte-routeName-input-extra');
	const dpoSelectAllRoutesButton_el_extra = document.getElementById('dpo-select-all-routes-button-extra');
        const tteDownloadTimetableButton_el_extra = document.getElementById('tte-downloadTimetable-button-extra');
        const tteStatusMessage_el_extra = document.getElementById('tte-status-message-extra');
	const selectStopForDeparturesView_extra = document.getElementById('selectStopForDeparturesView_extra');
        const rsgSelectAllConfigsCheckbox_el_extra = document.getElementById('rsg-select-all-configs-checkbox-extra');
	const KEY_DEPARTURES_REFRESH_INTERVAL_MS = 60 * 1000;
        const rsgCopySourceOpProfileSelect_el_extra = document.getElementById('rsg-copy-source-operatingProfile-select-extra');
        const rsgReplaceStopModal_el_extra = document.getElementById('rsg-replace-stop-modal-extra');
const rsgReplaceStopModalTitle_el_extra = document.getElementById('rsg-replace-stop-modal-title-extra');
const rsgReplaceStopModalInfo_el_extra = document.getElementById('rsg-replace-stop-modal-info-extra');
const rsgReplaceStopSearchInput_el_extra = document.getElementById('rsg-replace-stop-search-input-extra');
const rsgReplaceStopSearchResults_el_extra = document.getElementById('rsg-replace-stop-search-results-extra');
const rsgReplaceStopModalCancelButton_el_extra = document.getElementById('rsg-replace-stop-modal-cancel-button-extra');
        const serviceAnalyzerStopSelect_el_extra = document.getElementById('service-analyzer-stop-select-extra');
const serviceAnalyzerStopInput_el_extra = document.getElementById('service-analyzer-stop-input-extra');
const serviceAnalyzerStopSummary_el_extra = document.getElementById('service-analyzer-stop-summary-extra');
        const authSection_el_extra = document.getElementById('auth-section');
        const loginFormContainer_el_extra = document.getElementById('login-form-container_extra');
        const adminLoginForm_el_extra = document.getElementById('adminLoginForm_extra');
        const inputEmail_el_extra = document.getElementById('inputEmail_extra');
        const inputPassword_el_extra = document.getElementById('inputPassword_extra');
        const authStatus_el_extra = document.getElementById('auth-status_extra');
        const logoutContainer_el_extra = document.getElementById('logout-container_extra');
        const loggedInUserEmailDisplay_el_extra = document.getElementById('loggedInUserEmail_extra');
        const topMenuBar_el_extra = document.getElementById('top-menu-bar_extra');
        const toolSectionsWrapper_el_extra = document.getElementById('tool-sections-wrapper_extra');
        const currentProfileDisplayContainer_el = document.getElementById('current-profile-display-container');
        const currentProfileDisplayElement_el = document.getElementById('current-profile-display');
        // Day Profile Override
        const overrideDateInput_el_extra = document.getElementById('overrideDate_extra');
        // REMOVED: const overrideProfileInput_el_extra = document.getElementById('overrideProfile_extra');
        const dpoStatusMessage_el_extra = document.getElementById('dpo-status-message-extra'); // Renamed from overrideStatusMessage_el_extra
        const selectedDateDisplay_el_extra = document.getElementById('selectedDateDisplay_extra');
        // REMOVED: const autoProfileForSelectedDate_el_extra = document.getElementById('autoProfileForSelectedDate_extra');
        // REMOVED: const currentOverrideForSelectedDate_el_extra = document.getElementById('currentOverrideForSelectedDate_extra');
        const activeOverridesList_el_extra = document.getElementById('activeOverridesList_extra');

        // NEW DPO ELEMENTS
        const dpoApplyOverrideToRoutesButton_el_extra = document.getElementById('dpo-apply-override-to-routes-button-extra');
        const dpoClearOverrideForRoutesButton_el_extra = document.getElementById('dpo-clear-override-for-routes-button-extra');
        const dpoRouteSelectionContainer_el_extra = document.getElementById('dpo-route-selection-container-extra');
        const dpoSelectedRoutesDisplay_el_extra = document.getElementById('dpo-selected-routes-display-extra');
        const dpoClearRouteSelectionButton_el_extra = document.getElementById('dpo-clear-route-selection-button-extra');
        const dpoCurrentOverridesList_el_extra = document.getElementById('dpo-current-overrides-list-extra');
        
        // Stop Management & Creation
        const selectNewStopIdFormat_el_extra = document.getElementById('selectNewStopIdFormat_extra');
        const inputNewStopId_el_extra = document.getElementById('inputNewStopId_extra');
        const newStopIdAvailability_el_extra = document.getElementById('newStopIdAvailability_extra');
        const inputNewStopName_el_extra = document.getElementById('inputNewStopName_extra');
        const inputNewStopDirection_el_extra = document.getElementById('inputNewStopDirection_extra');
        const buttonAddNewStop_el_extra = document.getElementById('buttonAddNewStop_extra');
        const addNewStopStatus_el_extra = document.getElementById('addNewStopStatus_extra');
        const fileInputBulkAddStops_el_extra = document.getElementById('fileInputBulkAddStops_extra');
        const fileNameBulkAddStops_el_extra = document.getElementById('fileNameBulkAddStops_extra');
        const buttonBulkAddNewStops_el_extra = document.getElementById('buttonBulkAddNewStops_extra');
        const bulkAddNewStopsStatus_el_extra = document.getElementById('bulkAddNewStopsStatus_extra');
        const masterStopListFilterInput_el_extra = document.getElementById('masterStopListFilterInput_extra');
        const refreshMasterStopListButton_el_extra = document.getElementById('refreshMasterStopListButton_extra');
        const masterStopListUL_el_extra = document.getElementById('masterStopListUL_extra');
        const masterStopListStatus_el_extra = document.getElementById('masterStopListStatus_extra');
        const applyMasterListStopIdChangesButton_el_extra = document.getElementById('applyMasterListStopIdChangesButton_extra');
        const masterListApplyChangesStatus_el_extra = document.getElementById('masterListApplyChangesStatus_extra');
        const exportUniqueStopsButton_el_extra = document.getElementById('exportUniqueStopsButton_extra');
        const findDuplicateStopsByNameDirButton_el_extra = document.getElementById('findDuplicateStopsByNameDirButton_extra');
        const duplicateStopsByNameDirResults_el_extra = document.getElementById('duplicateStopsByNameDirResults_extra');
        // Global Route Deletion
        const globalRouteDeletionListContainer_el_extra = document.getElementById('globalRouteDeletionListContainer_el_extra');
        const deleteEntireRouteButton_el_extra = document.getElementById('deleteEntireRouteButton_el_extra');
        const deleteEntireRouteStatusMessage_el_extra = document.getElementById('deleteEntireRouteStatusMessage_el_extra');
        
	// Route Schedule Generator (RSG)
        // Removed: const rsgRouteNameSelect_el_extra = document.getElementById('rsg-routeName-select-extra'); // REMOVED as it's no longer a <select>
        const rsgRouteNameInput_el_extra = document.getElementById('rsg-routeName-input-extra'); // This now refers to the hidden input
        const rsgRouteSelectionContainer_el_extra = document.getElementById('rsg-route-selection-container-extra'); // NEW: Container for route tiles
        const rsgSelectedRouteDisplay_el_extra = document.getElementById('rsg-selected-route-display-extra'); // NEW: Element to display selected route name
        const rsgRoutesPlaceholder_el_extra = document.getElementById('rsg-routes-placeholder-extra'); // NEW: Placeholder for routes
        const rsgClearRouteSelectionButton_el_extra = document.getElementById('rsg-clear-route-selection-button-extra'); // NEW: Clear button for route selection
        //const rsgOperatingProfileInput_el_extra = document.getElementById('rsg-operatingProfile-input-extra'); // Keep this line if it's currently commented out in your file
        const rsgDestinationNameSelect_el_extra = document.getElementById('rsg-destinationName-select-extra');
        const rsgDestinationNameInput_el_extra = document.getElementById('rsg-destinationName-input-extra');
        const rsgStopSearchInput_el_extra = document.getElementById('rsg-stop-search-input-extra');
        const rsgStopSearchResults_el_extra = document.getElementById('rsg-stop-search-results-extra');
        const rsgStopSequenceList_el_extra = document.getElementById('rsg-stop-sequence-list-extra');
        const rsgStopSequencePlaceholder_el_extra = document.getElementById('rsg-stop-sequence-placeholder-extra');
        const rsgFirstStopTimesContainer_el_extra = document.getElementById('rsg-first-stop-times-container-extra');
        const rsgFirstStopTimesInput_el_extra = document.getElementById('rsg-first-stop-times-input-extra');
        const rsgGenerateScheduleButton_el_extra = document.getElementById('rsg-generate-schedule-button-extra');
        const rsgSaveConfigurationButton_el_extra = document.getElementById('rsg-save-configuration-button-extra');
        const rsgAddToWorkingScheduleButton_el_extra = document.getElementById('rsg-add-to-working-schedule-button-extra');
        const rsgStatusMessage_el_extra = document.getElementById('rsg-status-message-extra');
        const rsgSchedulePreviewContainer_el_extra = document.getElementById('rsg-schedule-preview-container-extra');
        const rsgPreviewTableBody_el_extra = document.getElementById('rsg-preview-table-extra')?.getElementsByTagName('tbody')[0];
        const rsgOpenCopyModalButton_el_extra = document.getElementById('rsg-open-copy-modal-button-extra');
        const rsgCopyModal_el_extra = document.getElementById('rsg-copy-modal-extra');
        const rsgCopySourceRouteNameSelect_el_extra = document.getElementById('rsg-copy-source-routeName-select-extra');
        // Removed: const rsgCopySourceRouteNameInput_el_extra = document.getElementById('rsg-copy-source-routeName-input-extra'); // This was removed in your current code, ensure it's not present if not used.
        const rsgCopySourceOpProfileInput_el_extra = document.getElementById('rsg-copy-source-operatingProfile-input-extra');
        const rsgCopySourceDestNameSelect_el_extra = document.getElementById('rsg-copy-source-destinationName-select-extra');
        // Removed: const rsgCopySourceDestNameInput_el_extra = document.getElementById('rsg-copy-source-destinationName-input-extra'); // This was removed in your current code, ensure it's not present if not used.
        const rsgCopyModalStatus_el_extra = document.getElementById('rsg-copy-modal-status-extra');
        const rsgCopyModalCancelButton_el_extra = document.getElementById('rsg-copy-modal-cancel-button-extra');
        const rsgCopyModalActionButton_el_extra = document.getElementById('rsg-copy-modal-action-button-extra');
       
	// Route Profile Deletion (RPD) - NEW
        const rpdRouteSelect_el_extra = document.getElementById('rpd-route-name-select-extra');
        const rpdRouteInput_el_extra = document.getElementById('rpd-route-name-input-extra');
        const rpdDestinationSelect_el_extra = document.getElementById('rpd-destination-name-select-extra');
        const rpdDestinationInput_el_extra = document.getElementById('rpd-destination-name-input-extra');
        const rpdClearDestinationButton_el_extra = document.getElementById('rpd-clear-destination-button-extra');
        const rpdProfileListContainer_el_extra = document.getElementById('rpd-profile-list-container-extra');
        const rpdDeleteProfilesButton_el_extra = document.getElementById('rpd-delete-profiles-button-extra');
        const rpdStatusMessage_el_extra = document.getElementById('rpd-status-message-extra');
        const srdRouteNameSelect_el_extra = document.getElementById('srd-routeName-select-extra');
const srdRouteNameInput_el_extra = document.getElementById('srd-routeName-input-extra');
const srdGoLiveDateTimeInput_el_extra = document.getElementById('srd-go-live-datetime-input-extra');
const srdScheduleDeletionButton_el_extra = document.getElementById('srd-schedule-deletion-button-extra');
const srdStatusMessage_el_extra = document.getElementById('srd-status-message-extra');
const rsgScheduleSelectedConfigsButton_el_extra = document.getElementById('rsg-schedule-selected-configs-button-extra');
const rsgScheduleThisConfigButton_el_extra = document.getElementById('rsg-schedule-this-config-button-extra');
const rsgScheduleDateTimeConfirmBtn = document.getElementById('rsg-schedule-datetime-confirm-button-extra');
const rsgScheduleDateTimeCancelBtn = document.getElementById('rsg-schedule-datetime-cancel-button-extra');
const rsgScheduleDateTimeModal = document.getElementById('rsg-schedule-datetime-modal-extra');
const sruBatchGoLiveRadiosContainer_el_extra = document.getElementById('sru-batch-golive-radios-container-extra');
const sruApplyAllForTimeButton_el_extra = document.getElementById('sru-apply-all-for-time-button-extra');
const sruApplyAllStatusMessage_el_extra = document.getElementById('sru-apply-all-status-message-extra');
// For the "Cancel Route Updates by Specific Time(s)" Modal
const sruCancelRouteTimeSelectModal_el_extra = document.getElementById('sru-cancel-route-time-select-modal-extra');
const sruCancelModalTitle_el_extra = document.getElementById('sru-cancel-modal-title-extra');
const sruCancelModalRouteInfo_el_extra = document.getElementById('sru-cancel-modal-route-info-extra');
const sruCancelModalCheckboxesContainer_el_extra = document.getElementById('sru-cancel-modal-checkboxes-container-extra');
const sruCancelModalSelectAllCheckbox_el_extra = document.getElementById('sru-cancel-modal-select-all-times-extra');
const sruCancelModalConfirmButton_el_extra = document.getElementById('sru-cancel-modal-confirm-button-extra');
const sruCancelModalCancelButton_el_extra = document.getElementById('sru-cancel-modal-cancel-button-extra');
const sruCancelModalStatus_el_extra = document.getElementById('sru-cancel-modal-status-extra');
let keyDeparturesIntervalId_extra = null;

// For the Global "Cancel ALL Pending Updates" Button
const sruCancelAllPendingUpdatesGloballyButton_el_extra = document.getElementById('sru-cancel-all-pending-updates-globally-button-extra');
const sruCancelAllGlobalStatusMessage_el_extra = document.getElementById('sru-cancel-all-global-status-message-extra');


        // --- Helper Functions ---
        function sanitizeFirebaseKey(text) {
            if (typeof text !== 'string') return '';
            // Replace forbidden characters with an underscore
            // Firebase forbids '.', '#', '$', '[', ']'
            return text.replace(/[.#$[\]]/g, '_');
        }

function showTripAlertPopup_ExtraPage(message, type = 'info') { // Added type for styling
    const banner = document.getElementById('global-notification-banner');
    if (!banner) {
        console.error("Global notification banner not found for in-page trip alert.");
        return;
    }

    // Set banner content and style based on type
    let backgroundColor;
    let textColor = 'white'; // Default text color

    switch (type) {
        case 'error':
            backgroundColor = '#e74c3c'; // Red
            break;
        case 'warning':
            backgroundColor = '#f39c12'; // Yellow
            textColor = '#2c3e50'; // Darker text for yellow bg
            break;
        case 'success':
            backgroundColor = '#27ae60'; // Green
            break;
        case 'info': // Default for trip alerts
        default:
            backgroundColor = '#3498db'; // Blue
            break;
    }

    banner.innerHTML = ''; // Clear previous content (e.g., from a scheduled task alert)

    const messageSpan = document.createElement('span');
    messageSpan.textContent = message;
    messageSpan.style.flexGrow = '1'; // Allow message to take available space
    messageSpan.style.textAlign = 'left'; // Align text to the left

    const closeButton = document.createElement('button');
    closeButton.innerHTML = '&times;'; // '' character for a close symbol
    closeButton.style.marginLeft = '15px';
    closeButton.style.padding = '0.2em 0.5em';
    closeButton.style.fontSize = '1.2em';
    closeButton.style.fontWeight = 'bold';
    closeButton.style.lineHeight = '1';
    closeButton.style.border = 'none';
    closeButton.style.background = 'transparent';
    closeButton.style.color = textColor; // Match banner text color
    closeButton.style.cursor = 'pointer';
    closeButton.title = 'Dismiss';
    closeButton.setAttribute('aria-label', 'Dismiss notification');
    closeButton.onclick = (e) => {
        e.stopPropagation(); // Prevent any parent handlers
        banner.style.display = 'none';
    };

    banner.appendChild(messageSpan);
    banner.appendChild(closeButton);

    // Apply styles to the banner
    banner.style.backgroundColor = backgroundColor;
    banner.style.color = textColor;
    banner.style.display = 'flex'; // Use flex for better alignment
    banner.style.justifyContent = 'space-between';
    banner.style.alignItems = 'center';
    banner.style.padding = '12px 15px'; // Re-apply padding if cleared by innerHTML
    banner.style.position = 'sticky'; // Ensure it's sticky
    banner.style.top = '0';
    banner.style.left = '0';
    banner.style.width = '100%';
    banner.style.zIndex = '1060';
    banner.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
}

function segmentScheduleEntriesIntoTrips(
    scheduleEntriesForServiceLeg,
    minStopsPerTripHeuristic = 2 // Sensible default
) {
    const allTrips = [];
    if (!scheduleEntriesForServiceLeg || scheduleEntriesForServiceLeg.length === 0) {
        return allTrips;
    }

    const sortedEntries = [...scheduleEntriesForServiceLeg].sort((a, b) => {
        const absA = getAbsMinutes(a.scheduledTime, parseInt(a.DayOffset || 0));
        const absB = getAbsMinutes(b.scheduledTime, parseInt(b.DayOffset || 0));
        if (absA === absB) return 0;
        if (absA === null) return 1;
        if (absB === null) return -1;
        return absA - absB;
    });

    let currentTrip = [];
    let previousStopTimeAbs = -1;
    let firstStopTimeOfCurrentLogicalTripAbs = -1;

    for (let i = 0; i < sortedEntries.length; i++) {
        const entry = sortedEntries[i];
        if (!entry.stopID || !entry.scheduledTime) continue;

        const currentStopTimeAbs = getAbsMinutes(entry.scheduledTime, parseInt(entry.DayOffset || 0));
        if (currentStopTimeAbs === null) continue;

        if (currentTrip.length === 0) {
            firstStopTimeOfCurrentLogicalTripAbs = currentStopTimeAbs;
        } else {
            let splitTrip = false;
            if (currentStopTimeAbs < previousStopTimeAbs) {
                splitTrip = true;
            } else if (
                entry.stopID === currentTrip[0].stopID &&
                currentTrip.length >= minStopsPerTripHeuristic &&
                currentStopTimeAbs > firstStopTimeOfCurrentLogicalTripAbs
            ) {
                splitTrip = true;
            }

            if (splitTrip) {
                if (currentTrip.length > 0) {
                    allTrips.push([...currentTrip]);
                }
                currentTrip = [];
                firstStopTimeOfCurrentLogicalTripAbs = currentStopTimeAbs;
            }
        }
        currentTrip.push(entry);
        previousStopTimeAbs = currentStopTimeAbs;
    }

    if (currentTrip.length > 0) {
        allTrips.push([...currentTrip]);
    }
    return allTrips;
}

async function fetchBankHolidays_ExtraPage() {
    const cacheKey = 'ukBankHolidaysData_cache';
    const cachedData = localStorage.getItem(cacheKey);
    const now = new Date().getTime();

    if (cachedData) {
        try {
            const parsedCache = JSON.parse(cachedData);
            if (parsedCache.timestamp && (now - parsedCache.timestamp < BANK_HOLIDAY_CACHE_DURATION_MS) && parsedCache.data) {
                ukBankHolidaysData_extra = parsedCache.data;
                console.log("Bank holidays loaded from cache for division:", ukBankHolidaysData_extra.division);
                // Ensure it has the expected structure after loading from cache
                if (!ukBankHolidaysData_extra.dates || !ukBankHolidaysData_extra.titles) {
                    console.warn("Cached bank holiday data is malformed, fetching fresh.");
                    localStorage.removeItem(cacheKey); // Remove bad cache
                } else {
                    return; // Use cached data
                }
            } else {
                localStorage.removeItem(cacheKey); // Cache expired or invalid
            }
        } catch (e) {
            console.error("Error parsing cached bank holiday data, fetching fresh:", e);
            localStorage.removeItem(cacheKey);
        }
    }

    console.log("Fetching fresh bank holiday data from API...");
    try {
        const response = await fetch('https://www.gov.uk/bank-holidays.json');
        if (!response.ok) {
            throw new Error(`HTTP error when fetching bank holidays! status: ${response.status}`);
        }
        const allDivisionsData = await response.json();

        // Assuming you want 'england-and-wales' - adjust if needed
        const divisionData = allDivisionsData['england-and-wales'];

        if (divisionData && divisionData.events && Array.isArray(divisionData.events)) {
            const datesArray = [];
            const titlesObject = {};
            divisionData.events.forEach(event => {
                if (event.date && event.title) { // Expects "YYYY-MM-DD"
                    datesArray.push(event.date);
                    titlesObject[event.date] = event.title;
                }
            });

            ukBankHolidaysData_extra = {
                division: divisionData.division || 'england-and-wales',
                dates: datesArray,
                titles: titlesObject
            };

            localStorage.setItem(cacheKey, JSON.stringify({ timestamp: now, data: ukBankHolidaysData_extra }));
            console.log("Bank holidays fetched and cached for division:", ukBankHolidaysData_extra.division);
        } else {
            console.error("Bank holiday data for 'england-and-wales' division not found or in unexpected format.", allDivisionsData);
            ukBankHolidaysData_extra = { division: 'england-and-wales', dates: [], titles: {} }; // Set to empty on error
        }
    } catch (error) {
        console.error("Failed to fetch or process bank holidays:", error);
        // Ensure ukBankHolidaysData_extra is in a consistent empty state on error if not using cache
        if (!cachedData) { // Only reset if there was no valid cache to fall back to
             ukBankHolidaysData_extra = { division: '', dates: [], titles: {} };
        }
    }
}

async function prepareKeyTripTimesForAlerts_ExtraPage() {
    const functionStartTime = new Date();
    const allPotentialEvents = [];
    const todayForAlerts = new Date();
    lastAlertDataPreparedDate_extra = todayForAlerts.toDateString();
    
    const operationalDatesToConsider = [
        { date: todayForAlerts, label: "current" },
    ];
    const yesterdayForAlerts = new Date(todayForAlerts);
    yesterdayForAlerts.setDate(todayForAlerts.getDate() - 1);
    operationalDatesToConsider.push({ date: yesterdayForAlerts, label: "previous" });

    if (!rsg_loadedConfigs_extra || Object.keys(rsg_loadedConfigs_extra).length === 0) {
        todayKeyTripEvents_extra = [];
        return;
    }

    for (const opDay of operationalDatesToConsider) {
        const currentOperationalDate = opDay.date;
        const opDayLabel = opDay.label;
        const dateStringYYYYMMDD = getYYYYMMDD_ExtraPage(currentOperationalDate);

        for (const configKey in rsg_loadedConfigs_extra) {
            if (!Object.hasOwnProperty.call(rsg_loadedConfigs_extra, configKey)) continue;
            
            const rsgConfig = rsg_loadedConfigs_extra[configKey];
            const configUserDisplayName = rsgConfig.userDisplayName || configKey;
            const routeName = rsgConfig.routeName;

            if (!routeName) {
                continue;
            }

            const isNRoute = routeName.toUpperCase().startsWith('N');
            const futureDatePattern = /\(from\s*\d{6}\)/;
            if (futureDatePattern.test(configUserDisplayName)) {
                continue;
            }

            const configOperatingProfiles = (rsgConfig.operatingProfile || "").split(',').map(p => p.trim());
            const effectiveProfilesForThisRouteOnThisDate = getOperatingCodesForDate_ExtraPage(currentOperationalDate, routeName);
            const isActiveForThisOpDate = configOperatingProfiles.some(cop => effectiveProfilesForThisRouteOnThisDate.includes(cop));
            
            if (!isActiveForThisOpDate) {
                continue;
            }
            
            // --- RESTORED LOGIC BLOCK ---
            // This block correctly skips non-N routes colored blue (24h services) from this list.
            if (!isNRoute) {
                const routeColorFor24HCheck = getRouteTileColour_ExtraPage(routeName, null).toUpperCase();
                if (routeColorFor24HCheck === (globalCustomRouteColours_extra["NIGHT_DEFAULT"] || NIGHT_BUS_BLUE_COLOR_extra).toUpperCase()) {
                    let allowThis24HourService = false;
                    const configIsForChristmasEve = (rsgConfig.operatingProfile || "").includes("Christmas Eve");
                    const opDayIsEffectivelyChristmasEve = effectiveProfilesForThisRouteOnThisDate.includes("Christmas Eve");
                    if (configIsForChristmasEve && opDayIsEffectivelyChristmasEve) {
                        allowThis24HourService = true;
                    }
                    const configIsForBoxingDay = (rsgConfig.operatingProfile || "").includes("Boxing Day");
                    const opDayIsEffectivelyBoxingDay = effectiveProfilesForThisRouteOnThisDate.includes("Boxing Day");
                    if (!allowThis24HourService && configIsForBoxingDay && opDayIsEffectivelyBoxingDay) {
                        allowThis24HourService = true;
                    }
                    if (!allowThis24HourService) {
                        continue; // This skips the route as intended.
                    }
                }
            }
            // --- END OF RESTORED LOGIC BLOCK ---

            if (!rsgConfig.firstStopTimes || rsgConfig.firstStopTimes.trim() === "" ||
                !rsgConfig.stopSequence || rsgConfig.stopSequence.length === 0) {
                continue;
            }

            const rawDepartureTimes = (rsgConfig.firstStopTimes || "").split(/\s*[\t;,]\s*/)
                                         .map(t => t.trim()).filter(t => t.match(/^\d{2}:\d{2}$/));
            
            if (rawDepartureTimes.length === 0) {
                continue;
            }

            let hasLateNightTimesInList = rawDepartureTimes.some(t => parseInt(t.substring(0,2)) >= 20);
            let hasEarlyMorningTimesInList = rawDepartureTimes.some(t => parseInt(t.substring(0,2)) < 6);

            const departureTimeObjectsSorted = rawDepartureTimes.map(timeStr => {
                let [h, m] = timeStr.split(':').map(Number);
                let sortableMinutes = h * 60 + m;
                if ( (isNRoute && h < 6) ||
                     (h < 4 && hasLateNightTimesInList && hasEarlyMorningTimesInList) ) {
                    sortableMinutes += 1440;
                }
                return { timeStr, sortableMinutes };
            }).sort((a, b) => a.sortableMinutes - b.sortableMinutes);

            if (departureTimeObjectsSorted.length === 0) continue;

            const firstDepartureTimeStr = departureTimeObjectsSorted[0].timeStr;
            const lastDepartureTimeStr = departureTimeObjectsSorted[departureTimeObjectsSorted.length - 1].timeStr;
            const firstStopOfSequence = rsgConfig.stopSequence[0];
            const lastStopOfSequence = rsgConfig.stopSequence[rsgConfig.stopSequence.length - 1];
            const headsignDestinationName = rsgConfig.destinationName;

            const eventBaseData = {
                lineName: routeName, headsignDestinationName: headsignDestinationName,
                originStopName: firstStopOfSequence.stopName || firstStopOfSequence.stopID,
                actualTerminusName: lastStopOfSequence.stopName || lastStopOfSequence.stopID,
                operatingProfile: rsgConfig.operatingProfile,
                rsgConfigUserDisplayName: configUserDisplayName || configKey
            };

            const firstDepartureTimeObj = createEventTimeObjForAlert(firstDepartureTimeStr, currentOperationalDate, hasLateNightTimesInList, hasEarlyMorningTimesInList, isNRoute);
            const lastDepartureTimeObj = createEventTimeObjForAlert(lastDepartureTimeStr, currentOperationalDate, hasLateNightTimesInList, hasEarlyMorningTimesInList, isNRoute);
            
            const firstTripType = isNRoute ? 'n-bus-first-trip' : 'rsg-first-trip';
            const lastTripType = isNRoute ? 'n-bus-last-trip' : 'rsg-last-trip';

            allPotentialEvents.push({
                ...eventBaseData, type: firstTripType, configKey: configKey,
                departureTime: firstDepartureTimeStr,
                departureTimeObj: firstDepartureTimeObj,
            });

            if (lastDepartureTimeStr !== firstDepartureTimeStr || departureTimeObjectsSorted.length > 1) {
                allPotentialEvents.push({
                    ...eventBaseData, type: lastTripType, configKey: configKey,
                    departureTime: lastDepartureTimeStr,
                    departureTimeObj: lastDepartureTimeObj,
                });
            }
        }
    }

    const tomorrowForAlerts = new Date(todayForAlerts);
    tomorrowForAlerts.setDate(todayForAlerts.getDate() + 1);
    const todayDateStrForFilter = todayForAlerts.toDateString();
    const tomorrowDateStrForFilter = tomorrowForAlerts.toDateString();
    
    todayKeyTripEvents_extra = allPotentialEvents.filter(event => {
        if (!event.departureTimeObj) {
            return false;
        }
        const eventCalendarDateStr = event.departureTimeObj.toDateString();
        return eventCalendarDateStr === todayDateStrForFilter || eventCalendarDateStr === tomorrowDateStrForFilter;
    });

    todayKeyTripEvents_extra.sort((a,b) => {
        if (!a.departureTimeObj && !b.departureTimeObj) return 0;
        if (!a.departureTimeObj) return 1;
        if (!b.departureTimeObj) return -1;
        const timeDiff = a.departureTimeObj.getTime() - b.departureTimeObj.getTime();
        if (timeDiff !== 0) return timeDiff;
        return a.type.localeCompare(b.type);
    });

    const uniqueEvents = [];
    const seenEventSignaturesForAlert = new Set();
    for (const event of todayKeyTripEvents_extra) {
        let signatureBase = `${event.type}|${event.configKey || 'no-key'}|${event.lineName}|${event.headsignDestinationName}|${event.departureTime}|${event.originStopName}|${event.departureTimeObj.toDateString()}`;
        if (!seenEventSignaturesForAlert.has(signatureBase)) {
            uniqueEvents.push(event);
            seenEventSignaturesForAlert.add(signatureBase);
        }
    }
    todayKeyTripEvents_extra = uniqueEvents;
}

function checkAndShowTripAlerts_ExtraPage() {
    const checkStartTime = new Date();
    // console.log(`[DEBUG CHECK&SHOW ${checkStartTime.toLocaleTimeString()}] Function Entry: checkAndShowTripAlerts_ExtraPage`);
    const now = new Date();

    if (now.toDateString() !== lastAlertDataPreparedDate_extra) {
        console.log(`[DEBUG CHECK&SHOW ${checkStartTime.toLocaleTimeString()}] Date changed from ${lastAlertDataPreparedDate_extra} to ${now.toDateString()}. Refreshing alert data.`);
        if (typeof prepareKeyTripTimesForAlerts_ExtraPage === 'function') {
            // This is async, but for alerts, it's okay if it runs in background.
            // The *next* call to checkAndShowTripAlerts_ExtraPage will use the refreshed data.
            prepareKeyTripTimesForAlerts_ExtraPage();
        }
        shownTripAlerts_extra = {}; // Reset shown alerts for the new day
    }

    if (!todayKeyTripEvents_extra || todayKeyTripEvents_extra.length === 0) {
        // console.log(`[DEBUG CHECK&SHOW ${checkStartTime.toLocaleTimeString()}] No key trip events to check for alerts.`);
        return;
    }

    // console.log(`[DEBUG CHECK&SHOW ${checkStartTime.toLocaleTimeString()}] Checking ${todayKeyTripEvents_extra.length} events against current time ${now.toISOString()}`);
    todayKeyTripEvents_extra.forEach(event => {
        let alertShownId;
        // Ensure configKey is part of the ID
        alertShownId = `${event.type}|${event.configKey || 'no-key'}|${event.lineName}|${event.headsignDestinationName}|${event.departureTime}|${event.originStopName}`;

        if (shownTripAlerts_extra[alertShownId]) {
            // if (event.lineName.toUpperCase().startsWith('N')) console.log(`[DEBUG CHECK&SHOW N-ROUTE] Alert for ${alertShownId} already shown. Skipping.`);
            return;
        }
        if (!event.departureTimeObj || !(event.departureTimeObj instanceof Date)) {
            // if (event.lineName.toUpperCase().startsWith('N')) console.log(`[DEBUG CHECK&SHOW N-ROUTE] Event ${event.lineName} ${event.type} at ${event.departureTime} missing or invalid departureTimeObj. Skipping.`);
            return;
        }

        const timeDiffMs = event.departureTimeObj.getTime() - now.getTime();
        const timeDiffMinutes = timeDiffMs / (1000 * 60);

        // if (event.lineName.toUpperCase().startsWith('N')) { // Uncomment for very verbose N-route alert checking
        //      console.log(`[DEBUG CHECK&SHOW N-ROUTE] Event: ${event.lineName} ${event.type} ${event.departureTime}. Target Time: ${event.departureTimeObj.toISOString()}. Diff Mins: ${timeDiffMinutes.toFixed(2)}.`);
        // }

        if (timeDiffMinutes > 0 && timeDiffMinutes <= ALERT_LEAD_TIME_MINUTES) {
            let message = "";
            const serviceHeadsignDisplay = `${event.lineName} to ${event.headsignDestinationName}`;
            let tripTypeDescription = "";

            if (event.type === 'rsg-first-trip' || event.type === 'n-bus-first-trip') {
                tripTypeDescription = "first";
            } else if (event.type === 'rsg-last-trip' || event.type === 'n-bus-last-trip') {
                tripTypeDescription = "last";
            }


            if (tripTypeDescription) {
                message = `${serviceHeadsignDisplay} is about to depart its ${tripTypeDescription} trip for today from ${event.originStopName} at ${event.departureTime}.`;
                // if (event.lineName.toUpperCase().startsWith('N')) { // Uncomment for N-route specific alert triggering log
                //     console.log(`[DEBUG CHECK&SHOW N-ROUTE ALERT] SHOWING ALERT for ${event.lineName} ${event.type} at ${event.departureTime}. Message: "${message}"`);
                // }

                const desktopPref = localStorage.getItem('desktopNotificationPreference_omsiExtra');
                let currentNativePermission = "denied";
                if (typeof checkNotificationPermission === 'function') {
                    currentNativePermission = checkNotificationPermission();
                }

                if (desktopPref === 'granted' && currentNativePermission === 'granted') {
                    let notificationTitle = "OMSI Trip Alert";
                    if (event.lineName && event.headsignDestinationName) {
                        notificationTitle = `${event.lineName} to ${event.headsignDestinationName}`;
                    }
                    if (typeof showNativeNotification === 'function') {
                        showNativeNotification(notificationTitle, message, '/live-tracker/assets/icons/icon-192x192.png');
                    } else {
                        if (typeof showTripAlertPopup_ExtraPage === 'function') {
                            showTripAlertPopup_ExtraPage(message);
                        }
                    }
                } else {
                    if (typeof showTripAlertPopup_ExtraPage === 'function') {
                        showTripAlertPopup_ExtraPage(message);
                    }
                }
                shownTripAlerts_extra[alertShownId] = true;
            } else {
                // if (event.lineName.toUpperCase().startsWith('N')) { // Uncomment for N-route specific no-alert log
                //      console.log(`[DEBUG CHECK&SHOW N-ROUTE] Event type ${event.type} for ${event.lineName} did not result in a tripTypeDescription. No alert generated.`);
                // }
            }
        }
    });
    // console.log(`[DEBUG CHECK&SHOW ${new Date().toLocaleTimeString()}] Function Exit: checkAndShowTripAlerts_ExtraPage (Duration: ${(new Date() - checkStartTime)/1000}s)`);
}

function createEventTimeObjForAlert(timeStr, baseDate, hasLateNightTimesInList, hasEarlyMorningTimesInList, isNRoute = false) {
    const [hours, minutes] = timeStr.split(':').map(Number);

    // Create the date object using local time components.
    let eventDate = new Date(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate(), hours, minutes, 0, 0);

    // Handle overnight services by advancing the calendar day if necessary.
    let advanceDate = false;
    if (isNRoute && hours < 6) {
        advanceDate = true;
    } else if (hours < 4 && hasLateNightTimesInList && hasEarlyMorningTimesInList) {
        advanceDate = true;
    }

    if (advanceDate) {
        eventDate.setDate(eventDate.getDate() + 1);
    }

    // --- DIAGNOSTIC LINE ---
    // This will print the exact Date object being created for each key departure time.
    console.log(`[Key Departure Time Check] For schedule time "${timeStr}", created Date object:`, eventDate.toString());

    return eventDate;
}

function checkNotificationPermission() {
    if (!("Notification" in window)) {
        return "unsupported";
    }
    return Notification.permission;
}

async function requestNotificationPermission() {
    if (!("Notification" in window)) {
        alert("This browser does not support desktop notifications.");
        return "unsupported";
    }

    const currentPermission = Notification.permission;

    if (currentPermission === "granted") {
        // Permission is already granted, you could optionally show a gentle confirmation.
        // For example: showNativeNotification("OMSI Tools", "Desktop notifications are already enabled.", '/live-tracker/assets/icons/icon-192x192.png');
        // Or simply do nothing if you only want the test on initial grant.
        localStorage.setItem('desktopNotificationPreference_omsiExtra', 'granted');
        console.log("Notification permission was already granted.");
        // Show a test notification if it wasn't shown before for this session upon granting
        if (typeof showNativeNotification === 'function') {
             showNativeNotification("OMSI Tools Notifications", "Desktop alerts are active!", '/live-tracker/assets/icons/icon-192x192.png'); // Replace with your icon path or ''
        }
        return "granted";
    }

    if (currentPermission === "denied") {
        alert("Notification permission was previously denied. To enable, please go to your browser's site settings and allow notifications for this page.");
        localStorage.setItem('desktopNotificationPreference_omsiExtra', 'denied');
        return "denied";
    }

    // If permission is "default" (i.e., not yet granted or denied)
    // This is where the browser will show its Allow/Block prompt
    const permissionResult = await Notification.requestPermission();

    if (permissionResult === "granted") {
        localStorage.setItem('desktopNotificationPreference_omsiExtra', 'granted');
        console.log("Notification permission granted by user.");
        alert("Desktop notifications have been enabled!"); // An in-page alert confirming

        // *** Trigger a test desktop notification immediately ***
        if (typeof showNativeNotification === 'function') {
            showNativeNotification(
                "OMSI Tools Notifications", // Title of the notification
                "Test successful! You will now receive desktop alerts.", // Body of the notification
                '' // IMPORTANT: Replace with a VALID icon path or use '' for no icon
            );
        } else {
            console.error("showNativeNotification function is not defined. Cannot show test alert.");
        }
        return "granted";
    } else if (permissionResult === "denied") {
        localStorage.setItem('desktopNotificationPreference_omsiExtra', 'denied');
        alert("Desktop notifications were denied. You can change this in your browser's site settings.");
        return "denied";
    } else { // Usually means "default" - user dismissed the prompt
        localStorage.removeItem('desktopNotificationPreference_omsiExtra');
        alert("Notification permission request dismissed or not acted upon.");
        return "default";
    }
}

function rsg_populateRouteTiles_ExtraPage() {
    console.log("[DEBUG RSG_ROUTES] rsg_populateRouteTiles_ExtraPage: Function started."); // New log
    if (!rsgRouteSelectionContainer_el_extra || !rsgRoutesPlaceholder_el_extra || !rsgSelectedRouteDisplay_el_extra) {
        console.error("RSG Route Tiles: Essential container/display elements missing.");
        return;
    }
    rsgRouteSelectionContainer_el_extra.innerHTML = '';
    rsgRoutesPlaceholder_el_extra.textContent = "Loading routes..."; // Ensure placeholder is visible initially
    rsgRoutesPlaceholder_el_extra.style.display = 'block';

    const initialScheduleLength = currentWorkingSchedule_extra.length; // New log
    console.log(`[DEBUG RSG_ROUTES] currentWorkingSchedule_extra has ${initialScheduleLength} entries.`); // New log

    const uniqueRoutes = [...new Set(
        currentWorkingSchedule_extra
            .filter(e => {
                const isValid = e.lineName && e.lineName.trim() !== '';
                // console.log(`[DEBUG RSG_ROUTES_FILTER] Entry lineName: '${e.lineName}', isValid: ${isValid}`); // Uncomment for very verbose filter debug
                return isValid;
            })
            .map(e => e.lineName)
    )].sort(compareLineNames_ExtraPage);

    console.log("DEBUG: rsg_populateRouteTiles_ExtraPage - uniqueRoutes (after robust filter):", uniqueRoutes); // Existing log, now with context

    if (uniqueRoutes.length === 0) {
        console.log("[DEBUG RSG_ROUTES] uniqueRoutes is empty. Displaying 'No routes found' message."); // New log
        rsgRoutesPlaceholder_el_extra.textContent = "No valid routes found in schedule after filtering.";
        rsgRouteSelectionContainer_el_extra.appendChild(rsgRoutesPlaceholder_el_extra);
        rsgRoutesPlaceholder_el_extra.style.display = 'block'; // Ensure placeholder is visible
        rsg_selectedRoute_extra = null;
        rsgRouteNameInput_el_extra.value = '';
        rsgSelectedRouteDisplay_el_extra.textContent = '(None selected)';
        rsg_updateRsgActionButtonsState();
        return;
    }

    console.log(`[DEBUG RSG_ROUTES] Found ${uniqueRoutes.length} unique routes. Proceeding to render tiles.`); // New log

    // If we reach here, it means uniqueRoutes is NOT empty, so hide the placeholder
    rsgRoutesPlaceholder_el_extra.style.display = 'none';

    let selectedRouteExistsInList = false;
    let currentSelectedValue = rsg_selectedRoute_extra;

    uniqueRoutes.forEach(routeName => {
        const tile = document.createElement('span');
        tile.classList.add('selectable-route-tile');
        tile.textContent = routeName;
        tile.dataset.routeName = routeName;

        const bgColor = getRouteTileColour_ExtraPage(routeName);
        tile.style.backgroundColor = bgColor;
        tile.style.color = getTextColourForBackground_ExtraPage(bgColor);

        if (currentSelectedValue && routeName.toUpperCase() === currentSelectedValue.toUpperCase()) {
            tile.classList.add('selected');
            selectedRouteExistsInList = true;
        }

        tile.addEventListener('click', () => {
            rsgRouteSelectionContainer_el_extra.querySelectorAll('.selectable-route-tile.selected').forEach(selectedTile => {
                selectedTile.classList.remove('selected');
            });

            tile.classList.add('selected');
            rsg_selectedRoute_extra = routeName;
            rsgRouteNameInput_el_extra.value = routeName;
            rsgSelectedRouteDisplay_el_extra.textContent = routeName;

            rsg_populateDestinationSelect_ExtraPage();
            rsg_loadOrPullConfiguration_ExtraPage();
            rsg_updateRsgActionButtonsState();
        });
        rsgRouteSelectionContainer_el_extra.appendChild(tile);
        // console.log(`[DEBUG RSG_ROUTES] Appended tile for route: ${routeName}`); // Uncomment for very verbose append debug
    });

    if (!selectedRouteExistsInList) {
        console.log("[DEBUG RSG_ROUTES] No previously selected route found in the new list."); // New log
        rsg_selectedRoute_extra = null;
        rsgRouteNameInput_el_extra.value = '';
        rsgSelectedRouteDisplay_el_extra.textContent = '(None selected)';
    } else {
        console.log(`[DEBUG RSG_ROUTES] Retaining previously selected route: ${rsg_selectedRoute_extra}`); // New log
        rsgRouteNameInput_el_extra.value = rsg_selectedRoute_extra || '';
        rsgSelectedRouteDisplay_el_extra.textContent = rsg_selectedRoute_extra || '(None selected)';
    }
    rsg_updateRsgActionButtonsState();
    console.log("[DEBUG RSG_ROUTES] rsg_populateRouteTiles_ExtraPage: Function finished."); // New log
}

        function rsg_populateDestinationSelect_ExtraPage() {
            if (!rsgDestinationNameSelect_el_extra || !rsgRouteNameInput_el_extra) {
                console.warn("RSG: Destination select or route name input missing for populating destinations.");
                return;
            }

            const selectedRoute = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
            const currentInputValue = rsgDestinationNameInput_el_extra.value.trim();

            rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- Select Destination --</option>';

            if (!selectedRoute) {
                rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- Select Route First --</option>';
                rsgDestinationNameInput_el_extra.value = "";
                return;
            }

            // Filter for entries that have a non-empty lineName (matching selectedRoute) and non-empty destinationName.
            const uniqueDestinations = [...new Set(
                currentWorkingSchedule_extra
                    .filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName && e.destinationName.trim() !== '')
                    .map(e => e.destinationName)
            )].sort();

            if (uniqueDestinations.length > 0) {
                uniqueDestinations.forEach(dest => {
                    const opt = document.createElement('option');
                    opt.value = dest;
                    opt.textContent = dest;
                    rsgDestinationNameSelect_el_extra.appendChild(opt);
                });

                const matchedDest = uniqueDestinations.find(d => d === currentInputValue);
                if (matchedDest) {
                    rsgDestinationNameSelect_el_extra.value = matchedDest;
                    rsgDestinationNameInput_el_extra.value = matchedDest;
                } else {
                    rsgDestinationNameSelect_el_extra.value = "";
                }
            } else {
                rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- No Destinations for this Route --</option>';
                rsgDestinationNameInput_el_extra.value = "";
            }
        }

        function rsg_clearRouteSelection_ExtraPage() {
            rsgRouteSelectionContainer_el_extra.querySelectorAll('.selectable-route-tile.selected').forEach(selectedTile => {
                selectedTile.classList.remove('selected');
            });
            rsg_selectedRoute_extra = null;
            rsgRouteNameInput_el_extra.value = '';
            rsgSelectedRouteDisplay_el_extra.textContent = '(None selected)';
            rsg_populateDestinationSelect_ExtraPage(); // Clear destinations too
            rsg_loadOrPullConfiguration_ExtraPage(); // Reset config loading context
            rsg_updateRsgActionButtonsState();
        }

async function displayKeyDepartures_ExtraPage() {
    const now = new Date();
    const functionDisplayStartTime = new Date();
    
    const firstDepListDiv = document.getElementById('kd-first-departures-list_extra');
    const lastDepListDiv = document.getElementById('kd-last-departures-list_extra');
    const statusMsgEl = document.getElementById('kd-status-message_extra');

    if (!firstDepListDiv || !lastDepListDiv || !statusMsgEl) {
        return;
    }

    firstDepListDiv.innerHTML = '<p>Updating first departures...</p>';
    lastDepListDiv.innerHTML = '<p>Updating last departures...</p>';

    const todayStr = now.toDateString();

    if (lastAlertDataPreparedDate_extra !== todayStr || !todayKeyTripEvents_extra || todayKeyTripEvents_extra.length === 0) {
        if (statusMsgEl) statusMsgEl.textContent = 'Data stale or empty. Preparing/Refreshing key departure data...';
        if (typeof prepareKeyTripTimesForAlerts_ExtraPage === 'function') {
            await prepareKeyTripTimesForAlerts_ExtraPage();
        } else {
            if (statusMsgEl) statusMsgEl.textContent = 'Error: Key departure preparation function missing.';
            return;
        }
    }

    if (!todayKeyTripEvents_extra || todayKeyTripEvents_extra.length === 0) {
        const msg = "No key trip events identified for display based on current configurations and time.";
        if (statusMsgEl) statusMsgEl.textContent = msg;
        firstDepListDiv.innerHTML = `<p style="opacity:0.7;">${msg}</p>`;
        lastDepListDiv.innerHTML = `<p style="opacity:0.7;">${msg}</p>`;
        return;
    }
    
    // Filter for events that haven't happened yet
    const upcomingEvents = todayKeyTripEvents_extra.filter(event => {
        if (!event.departureTimeObj || !(event.departureTimeObj instanceof Date)) {
            return false;
        }
        return event.departureTimeObj >= now;
    });

    const firstTripTypes = ['rsg-first-trip', 'n-bus-first-trip'];
    const lastTripTypes = ['rsg-last-trip', 'n-bus-last-trip'];
    
    const firstDeparturesToDisplay = upcomingEvents.filter(e => firstTripTypes.includes(e.type));
    const lastDeparturesToDisplay = upcomingEvents.filter(e => lastTripTypes.includes(e.type));

    const sortEvents = (a, b) => {
        if (!a.departureTimeObj || !b.departureTimeObj) return 0;
        return a.departureTimeObj.getTime() - b.departureTimeObj.getTime();
    };

    firstDeparturesToDisplay.sort(sortEvents);
    lastDeparturesToDisplay.sort(sortEvents);

    const renderEventList = (eventArray, listDivElement, listTypeForEmptyMessage) => {
        if (eventArray.length > 0) {
            let html = '<ul style="list-style-type:none; padding-left:0;">';
            eventArray.forEach(event => {
                const routeColor = getRouteTileColour_ExtraPage(event.lineName, null);
                const destinationDisplay = `<strong>${toTitleCase_rsg(event.headsignDestinationName || 'N/A')}</strong>`;
                const opProfileDisplay = event.operatingProfile ? event.operatingProfile.split(',').map(p => p.trim()).join(', ') : 'N/A';

                html += `<li style="margin-bottom:0.5em; padding: 0.4em 0.5em; background-color: rgba(255,255,255,0.03); border-radius: 4px; border-left: 3px solid ${routeColor};">
                    <strong style="font-size:1.05em;">${event.departureTime}</strong> -
                    <span style="color: ${routeColor}; font-weight: bold;">${event.lineName}</span>
                    to ${destinationDisplay}
                    from ${toTitleCase_rsg(event.originStopName || 'N/A')}
                    <span style="font-size:0.8em; color:#bdc3c7; display:block; margin-top:2px;">(Op Profile: ${opProfileDisplay})</span>
                </li>`;
            });
            html += '</ul>';
            listDivElement.innerHTML = html;
        } else {
            listDivElement.innerHTML = `<p style="opacity:0.7;">No upcoming ${listTypeForEmptyMessage.toLowerCase()} departures found.</p>`;
        }
    };

    renderEventList(firstDeparturesToDisplay, firstDepListDiv, "First");
    renderEventList(lastDeparturesToDisplay, lastDepListDiv, "Last");

    const tomorrowForDisplayMsg = new Date(now);
    tomorrowForDisplayMsg.setDate(now.getDate() + 1);
    if (statusMsgEl) statusMsgEl.textContent = `Displaying upcoming departures for ${todayStr} & ${tomorrowForDisplayMsg.toLocaleDateString()}. Updated: ${now.toLocaleTimeString()}.`;
}

async function renderCalendarView_ExtraPage() {
    const calendarGrid = document.getElementById('events-calendar-grid_extra');
    const monthYearDisplay = document.getElementById('cv-month-year-display_extra');
    const dayDetailsDisplay = document.getElementById('calendar-day-details_extra');

    if (!calendarGrid || !monthYearDisplay || !dayDetailsDisplay) {
        console.error("Calendar UI elements not found for renderCalendarView_ExtraPage.");
        return;
    }

    calendarGrid.innerHTML = '';
    dayDetailsDisplay.innerHTML = '<p>Click on a day to see details.</p>';

    const actualToday = new Date();
    const actualCurrentYear = actualToday.getFullYear();
    const actualCurrentMonth = actualToday.getMonth();
    const actualCurrentDate = actualToday.getDate();

    const year = cv_currentDisplayDate_extra.getFullYear();
    const month = cv_currentDisplayDate_extra.getMonth();

    if (monthYearDisplay) {
        monthYearDisplay.textContent = `${cv_currentDisplayDate_extra.toLocaleString('default', { month: 'long' })} ${year}`;
    }

    const dayNames = ["Sat", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri"];
    dayNames.forEach(dayName => {
        const headerCell = document.createElement('div');
        headerCell.style.textAlign = 'center';
        headerCell.style.fontWeight = 'bold';
        headerCell.style.padding = '0.5em 0.2em';
        headerCell.style.backgroundColor = 'rgba(0,0,0,0.2)';
        headerCell.style.borderBottom = '1px solid #4A5568';
        headerCell.style.fontSize = '0.8em';
        headerCell.textContent = dayName;
        calendarGrid.appendChild(headerCell);
    });

    const firstDayOfMonth = new Date(year, month, 1);
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const startingDayOfWeek = (firstDayOfMonth.getDay() + 1) % 7;

    const dpoMap = new Map();
    if (typeof operationalOverrides_data === 'object' && operationalOverrides_data !== null) {
        Object.entries(operationalOverrides_data).forEach(([dateStr, profilesOrObject]) => {
            // Ensure that what we put into the map is either the profile string or an empty string if malformed.
            if (typeof profilesOrObject === 'string') {
                dpoMap.set(dateStr, profilesOrObject);
            } else if (typeof profilesOrObject === 'object' && profilesOrObject !== null && !Array.isArray(profilesOrObject)) {
                // If it's an object, it means it's a date with route-specific overrides.
                // For a calendar summary, we might want to indicate this as "Route-Specific Overrides"
                // or concatenate the profiles for a summary, or leave it blank if no *overall* profile.
                // For simplicity here, we'll mark it as an object to distinguish it from the `split` issue.
                // The later `getOperatingCodesForDate_ExtraPage` will handle the full object.
                dpoMap.set(dateStr, profilesOrObject); // Store the object, but handle the split later
            } else {
                console.warn(`Calendar View: Malformed override data for date ${dateStr}:`, profilesOrObject);
                // Optionally set to an empty string or specific error string
                dpoMap.set(dateStr, "");
            }
        });
    }

    for (let i = 0; i < startingDayOfWeek; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.style.borderRight = '1px solid #4A5568';
        emptyCell.style.borderBottom = '1px solid #4A5568';
        if (i === 0) emptyCell.style.borderLeft = '1px solid #4A5568';
        emptyCell.style.minHeight = '100px';
        calendarGrid.appendChild(emptyCell);
    }

    for (let day = 1; day <= daysInMonth; day++) {
        const dayCell = document.createElement('div');
        dayCell.style.minHeight = '100px';
        dayCell.style.padding = '0.3em';
        dayCell.style.cursor = 'pointer';
        dayCell.classList.add('calendar-day-cell');
        dayCell.setAttribute('role', 'button');
        dayCell.setAttribute('tabindex', '0');

        if (year === actualCurrentYear && month === actualCurrentMonth && day === actualCurrentDate) {
            dayCell.classList.add('cv-current-day');
        }

        const dayNumberSpan = document.createElement('strong');
        dayNumberSpan.className = 'cv-day-number-span';
        dayNumberSpan.textContent = day;
        dayCell.appendChild(dayNumberSpan);

        const dateForThisCell = new Date(year, month, day);
        const dateStringYYYYMMDD = getYYYYMMDD_ExtraPage(dateForThisCell);

        let effectiveProfiles = [];
        // Check if the override for this date is a string (legacy direct override) or an object (route-specific)
        const directOverrideValue = dpoMap.has(dateStringYYYYMMDD) ? dpoMap.get(dateStringYYYYMMDD) : undefined;

        if (typeof directOverrideValue === 'string' && directOverrideValue.trim() !== "") {
            effectiveProfiles = directOverrideValue.split(',').map(p => p.trim());
        } else if (typeof directOverrideValue === 'object' && directOverrideValue !== null) {
            // This date has route-specific overrides.
            // We need to summarize them for the calendar cell display.
            // A simple approach is to list unique profiles, or just state "Multiple Overrides".
            const profilesInThisDateOverride = new Set();
            for (const routeName in directOverrideValue) {
                if (Object.hasOwnProperty.call(directOverrideValue, routeName)) {
                    const profileString = directOverrideValue[routeName];
                    if (typeof profileString === 'string' && profileString.trim() !== '') {
                        profileString.split(',').forEach(p => profilesInThisDateOverride.add(p.trim()));
                    }
                }
            }
            if (profilesInThisDateOverride.size > 0) {
                effectiveProfiles = Array.from(profilesInThisDateOverride).sort();
            } else {
                effectiveProfiles = ['(Route-Specific Overrides)']; // Or simply empty if you want no text
            }
        } else {
            // No direct override string or valid object found for this date,
            // so use the automatically determined profiles.
            effectiveProfiles = getOperatingCodesForDate_ExtraPage(dateForThisCell);
        }

        if (effectiveProfiles.length > 0) {
            const profilesDiv = document.createElement('div');
            profilesDiv.classList.add('cv-profile-text');
            profilesDiv.textContent = effectiveProfiles.join(', ');
            profilesDiv.title = `Active Profile(s): ${effectiveProfiles.join(', ')}`;
            dayCell.appendChild(profilesDiv);
        }

        let eventsOnThisDay = [];
        if (ukBankHolidaysData_extra && ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(dateStringYYYYMMDD)) {
            const title = ukBankHolidaysData_extra.titles[dateStringYYYYMMDD] || "Bank Holiday";
            eventsOnThisDay.push({ type: 'Bank Holiday', text: title, color: '#E67E22' });
        }
        if (isSchoolHolidayPeriod_ExtraPage(dateForThisCell)) {
            eventsOnThisDay.push({ type: 'School Holiday', text: 'School Holiday', color: '#3498DB' });
        }
        
        // This check is specifically for where the DPO tool shows "Override Active".
        // It relies on `dpoMap.has(dateStringYYYYMMDD)` to indicate an override exists.
        // It's the `effectiveProfiles` which reflects the *result* of that override.
        // If `directOverrideValue` is an object, it's an override, even if `effectiveProfiles` summarizes.
        if (directOverrideValue !== undefined) { // Any form of override (string or object) is active
            eventsOnThisDay.push({ type: 'DPO Info', text: 'Override Active - See DPO for more information', color: '#F1C40F'});
        }


        Object.values(scheduledRouteUpdates_extra || {}).forEach(task => {
            if (task.goLiveDateTime && getYYYYMMDD_ExtraPage(new Date(task.goLiveDateTime)) === dateStringYYYYMMDD && task.status === 'pending') {
                let updateDetails = `Route ${task.routeName || 'N/A'}`;
                if (task.operatingProfile) {
                    updateDetails += ` (P: ${task.operatingProfile}`;
                    if (task.destinationName) { updateDetails += `, D: ${task.destinationName}`; }
                    updateDetails += `)`;
                } else if (task.destinationName) { updateDetails += ` (D: ${task.destinationName})`; }
                eventsOnThisDay.push({ type: 'Task', text: `Update: ${updateDetails}`, color: '#2ECC71' });
            }
        });
        Object.values(scheduledRouteDeletions_extra || {}).forEach(task => {
            if (task.goLiveDateTime && getYYYYMMDD_ExtraPage(new Date(task.goLiveDateTime)) === dateStringYYYYMMDD && task.status === 'pending') {
                eventsOnThisDay.push({ type: 'Task', text: `Delete Rte: ${task.routeName || 'N/A'}`, color: '#E74C3C' });
            }
        });

        if (eventsOnThisDay.length > 0) {
            if (dayCell.style.backgroundColor === '') {
                 dayCell.style.backgroundColor = 'rgba(255,255,255,0.05)';
            }
            eventsOnThisDay.sort((a, b) => {
                const typeOrder = { 'DPO Info': 0.5, 'Bank Holiday': 1, 'School Holiday': 2, 'Task': 3 };
                const orderA = typeOrder[a.type] || 99;
                const orderB = typeOrder[b.type] || 99;
                if (orderA !== orderB) return orderA - orderB;
                return (a.text || "").localeCompare(b.text || "");
            });

            for (const event of eventsOnThisDay) {
                const eventDiv = document.createElement('div');
                eventDiv.classList.add('cv-event-item');

                let displayText = event.text;
                if (event.type === 'Task') {
                    displayText = event.text.length > 30 ? event.text.substring(0, 27) + "..." : event.text;
                }
                eventDiv.textContent = displayText;
                eventDiv.title = `${event.type}: ${event.text}`;
                eventDiv.style.backgroundColor = event.color;
                eventDiv.style.color = getTextColourForBackground_ExtraPage(event.color);
                eventDiv.style.margin = '1px 0';
                eventDiv.style.padding = '2px 3px';
                eventDiv.style.borderRadius = '3px';
                dayCell.appendChild(eventDiv);
            }
        }

        dayCell.addEventListener('click', () => displayCalendarDayDetails_ExtraPage(dateStringYYYYMMDD, eventsOnThisDay));
        dayCell.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                displayCalendarDayDetails_ExtraPage(dateStringYYYYMMDD, eventsOnThisDay);
            }
        });
        calendarGrid.appendChild(dayCell);
    }

    const totalCells = startingDayOfWeek + daysInMonth;
    const remainingCells = (7 - (totalCells % 7)) % 7;
    for (let i = 0; i < remainingCells; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.style.borderBottom = '1px solid #4A5568';
        if ((totalCells + i) % 7 !== 6) {
             emptyCell.style.borderRight = '1px solid #4A5568';
        }
        if ((totalCells + i) % 7 === 0) {
             emptyCell.style.borderLeft = '1px solid #4A5568';
        }
        emptyCell.style.minHeight = '100px';
        calendarGrid.appendChild(emptyCell);
    }
}

        function dpo_populateRouteSelection_ExtraPage() {
            if (!dpoRouteSelectionContainer_el_extra) return;
            const routePlaceholder = document.getElementById('dpo-routes-placeholder-extra');
            if (!routePlaceholder) return;

            dpoRouteSelectionContainer_el_extra.innerHTML = '';
            
            const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))]
                .filter(Boolean)
                .sort(compareLineNames_ExtraPage);

            if (uniqueRoutes.length === 0) {
                routePlaceholder.textContent = "No routes found in schedule.";
                dpoRouteSelectionContainer_el_extra.appendChild(routePlaceholder);
                return;
            }
            routePlaceholder.style.display = 'none';

            uniqueRoutes.forEach(routeName => {
                const tile = document.createElement('span');
                tile.classList.add('selectable-route-tile');
                tile.textContent = routeName;
                tile.dataset.routeName = routeName;

                const bgColor = getRouteTileColour_ExtraPage(routeName);
                tile.style.backgroundColor = bgColor;
                tile.style.color = getTextColourForBackground_ExtraPage(bgColor);

                tile.addEventListener('click', () => {
                    const isSelected = tile.classList.toggle('selected');
                    if (isSelected) {
                        if (!dpo_selectedRoutes_extra.includes(routeName)) {
                            dpo_selectedRoutes_extra.push(routeName);
                        }
                    } else {
                        dpo_selectedRoutes_extra = dpo_selectedRoutes_extra.filter(r => r !== routeName);
                    }
                    dpo_selectedRoutes_extra.sort(compareLineNames_ExtraPage);
                    dpo_updateSelectedRoutesDisplay();
                    dpo_updateActionButtonsState();
                });
                dpoRouteSelectionContainer_el_extra.appendChild(tile);
            });
            dpo_updateSelectedRoutesDisplay();
        }

        function dpo_updateSelectedRoutesDisplay() {
            if (dpoSelectedRoutesDisplay_el_extra) {
                dpoSelectedRoutesDisplay_el_extra.textContent = dpo_selectedRoutes_extra.length > 0
                    ? dpo_selectedRoutes_extra.join(', ')
                    : '(None selected)';
            }
        }

        function dpo_clearRouteSelections_ExtraPage() {
            dpo_selectedRoutes_extra = [];
            const allTiles = dpoRouteSelectionContainer_el_extra.querySelectorAll('.selectable-route-tile');
            allTiles.forEach(tile => tile.classList.remove('selected'));
            dpo_updateSelectedRoutesDisplay();
            dpo_updateActionButtonsState();
        }

// In omsi_tools_extra.html, after dpo_clearRouteSelections_ExtraPage function
function dpo_selectAllRoutes_ExtraPage() {
    dpo_selectedRoutes_extra = []; // Clear current selections first
    const allTiles = dpoRouteSelectionContainer_el_extra.querySelectorAll('.selectable-route-tile');
    let selectedCount = 0;

    allTiles.forEach(tile => {
        const routeName = tile.dataset.routeName;
        if (routeName && !dpo_selectedRoutes_extra.includes(routeName)) {
            dpo_selectedRoutes_extra.push(routeName);
            tile.classList.add('selected'); // Add the 'selected' class
            selectedCount++;
        }
    });

    dpo_selectedRoutes_extra.sort(compareLineNames_ExtraPage); // Keep sorted
    dpo_updateSelectedRoutesDisplay();
    dpo_updateActionButtonsState();

    const dpoStatusMessageEl = document.getElementById('dpo-status-message-extra');
    if (dpoStatusMessageEl) {
        dpoStatusMessageEl.textContent = `${selectedCount} routes selected.`;
        dpoStatusMessageEl.style.color = '#2ecc71';
    }
}

// --- DOMContent Loaded

document.addEventListener('DOMContentLoaded', () => {
    
    if (dpoSelectAllRoutesButton_el_extra && typeof dpo_selectAllRoutes_ExtraPage === 'function') {
        dpoSelectAllRoutesButton_el_extra.addEventListener('click', dpo_selectAllRoutes_ExtraPage);
    }
});

const departuresSelect = document.getElementById('selectStopForDeparturesView_extra');
    if (departuresSelect) {
        departuresSelect.addEventListener('change', displayDeparturesForSelectedStop_ExtraPage);
    }

        function dpo_updateActionButtonsState() {
            const dateSelected = overrideDateInput_el_extra.value !== "";
            const profilesSelected = dpo_getSelectedOpProfilesString_ExtraPage() !== "";
            const routesSelected = dpo_selectedRoutes_extra.length > 0;

            if (dpoApplyOverrideToRoutesButton_el_extra) {
                dpoApplyOverrideToRoutesButton_el_extra.disabled = !(dateSelected && profilesSelected && routesSelected);
            }
            if (dpoClearOverrideForRoutesButton_el_extra) {
                dpoClearOverrideForRoutesButton_el_extra.disabled = !(dateSelected && routesSelected);
            }
        }

function displayCalendarDayDetails_ExtraPage(dateString, events) {
    const dayDetailsDisplay = document.getElementById('calendar-day-details_extra');
    if (!dayDetailsDisplay) {
        console.error("Day details display element not found.");
        return;
    }

    const sortedEvents = [...events].sort((a, b) => {
        const typeOrder = { 'DPO Info': 0.5, 'DPO': 1, 'Bank Holiday': 2, 'School Holiday': 3, 'Task': 4 };
        const orderA = typeOrder[a.type] || 99;
        const orderB = typeOrder[b.type] || 99;
        if (orderA !== orderB) return orderA - orderB;
        return (a.text || "").localeCompare(b.text || "");
    });

    let html = `<h4 style="margin-top:0; margin-bottom:0.75em;">Details for ${formatDateToDDMonthYYYY_ExtraPage(dateString)}:</h4>`;
    if (sortedEvents.length > 0) {
        html += '<ul style="list-style-type:none; padding-left:0; margin:0;">';
        sortedEvents.forEach(event => {
            html += `<li style="margin-bottom:0.5em; padding:0.4em 0.6em; background-color:${event.color}; color:${getTextColourForBackground_ExtraPage(event.color)}; border-radius:4px; font-size:0.9em;">
                        <strong style="font-weight:bold;">${event.type}:</strong> ${event.text}
                     </li>`;
        });
        html += '</ul>';
    } else {
        html += '<p style="font-size:0.9em; opacity:0.8;">No special events or tasks scheduled for this day.</p>';
    }
    dayDetailsDisplay.innerHTML = html;
}

function triggerStopAnalysisDynamically(stopID) {
    console.log('[Trigger] Analyzing stopID:', stopID); // For debugging
    analyzeStop_ExtraPage(stopID);
}

function displaySchoolHolidays_ExtraPage() {
    const displayDiv = document.getElementById('school-holidays-display-extra');
    if (!displayDiv) return;

    if (!schoolHolidayDateRanges_extra || schoolHolidayDateRanges_extra.length === 0) {
        displayDiv.innerHTML = '<p>No school holiday periods are currently defined in the script.</p>';
        return;
    }

    let html = '<ul style="list-style-type: disc; padding-left: 20px; margin-top:0.5em;">';
    schoolHolidayDateRanges_extra.forEach(range => {
        // Assuming you have formatDateToDDMonthYYYY_ExtraPage or similar
        const startDateFormatted = range.start ? formatDateToDDMonthYYYY_ExtraPage(range.start) : 'N/A';
        const endDateFormatted = range.end ? formatDateToDDMonthYYYY_ExtraPage(range.end) : 'N/A';
        html += `<li style="margin-bottom:0.3em;">${startDateFormatted} - ${endDateFormatted}</li>`;
    });
    html += '</ul>';
    displayDiv.innerHTML = html;
}

async function saveSchoolHolidaysToFirebase_ExtraPage() {
    if (!currentUser_extra || !window.firebaseOMSI) {
        console.error("Cannot save School Holidays: Not logged in or Firebase not available.");
        // Optionally update sh-status-message-extra here
        return false;
    }

    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        // Ensure all holidays have an ID. Those from DEFAULT_SCHOOL_HOLIDAY_RANGES might not initially.
        const holidaysToSave = schoolHolidayDateRanges_extra.map((holiday, index) => ({
            id: holiday.id || `sh-${Date.now()}-${index}`, // Assign ID if missing
            start: holiday.start,
            end: holiday.end,
            description: holiday.description || ""
        }));
        schoolHolidayDateRanges_extra = holidaysToSave; // Update global array with IDs

        await dbSet(dbRef(database, FB_PATH_SCHOOL_HOLIDAYS), schoolHolidayDateRanges_extra);
        console.log("School holiday date ranges saved to Firebase.");
        return true;
    } catch (error) {
        console.error("Error saving school holidays to Firebase:", error);
        const shStatusEl = document.getElementById('sh-status-message-extra');
        if (shStatusEl) {
            shStatusEl.textContent = "Error saving school holidays: " + error.message;
            shStatusEl.style.color = "#e74c3c";
        }
        return false;
    }
}

function displaySchoolHolidays_ExtraPage() {
    const displayDiv = document.getElementById('school-holidays-display-extra');
    const shStatusEl = document.getElementById('sh-status-message-extra');
    if (!displayDiv) return;

    displayDiv.innerHTML = ''; // Clear previous content

    if (!schoolHolidayDateRanges_extra || schoolHolidayDateRanges_extra.length === 0) {
        displayDiv.innerHTML = '<p style="padding:0.5em; opacity:0.7;">No school holiday periods defined. Add one below.</p>';
        return;
    }

    // Sort by start date for display
    const sortedHolidays = [...schoolHolidayDateRanges_extra].sort((a,b) => new Date(a.start) - new Date(b.start));

    const ul = document.createElement('ul');
    ul.style.listStyleType = 'none';
    ul.style.paddingLeft = '0';

    sortedHolidays.forEach(holiday => {
        const li = document.createElement('li');
        li.style.display = 'flex';
        li.style.justifyContent = 'space-between';
        li.style.alignItems = 'center';
        li.style.padding = '0.5em';
        li.style.marginBottom = '0.3em';
        li.style.backgroundColor = 'rgba(255,255,255,0.03)';
        li.style.borderRadius = '0.25rem';

        const textSpan = document.createElement('span');
        const startDateFormatted = holiday.start ? formatDateToDDMonthYYYY_ExtraPage(holiday.start) : 'N/A';
        const endDateFormatted = holiday.end ? formatDateToDDMonthYYYY_ExtraPage(holiday.end) : 'N/A';
        textSpan.innerHTML = `<strong>${startDateFormatted} - ${endDateFormatted}</strong>` +
                           (holiday.description ? ` <span style="font-size:0.9em; color:#bdc3c7;">(${holiday.description})</span>` : '');
        li.appendChild(textSpan);

        const buttonsDiv = document.createElement('div');

        const editButton = document.createElement('button');
        editButton.textContent = 'Edit';
        editButton.classList.add('button', 'small-action', 'neutral');
        editButton.style.marginRight = '0.5em';
        editButton.addEventListener('click', () => populateSchoolHolidayFormForEdit_ExtraPage(holiday.id));
        buttonsDiv.appendChild(editButton);

        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.classList.add('button', 'small-action', 'secondary');
        deleteButton.addEventListener('click', () => handleDeleteSchoolHoliday_ExtraPage(holiday.id));
        buttonsDiv.appendChild(deleteButton);

        li.appendChild(buttonsDiv);
        ul.appendChild(li);
    });
    displayDiv.appendChild(ul);
    if(shStatusEl) shStatusEl.textContent = ''; // Clear status on successful display
}

function clearSchoolHolidayForm_ExtraPage() {
    document.getElementById('sh-editing-id-extra').value = '';
    document.getElementById('sh-start-date-input-extra').value = '';
    document.getElementById('sh-end-date-input-extra').value = '';
    document.getElementById('sh-description-input-extra').value = '';
    const clearBtn = document.getElementById('sh-clear-form-button-extra');
    if (clearBtn) clearBtn.style.display = 'none';
    const saveBtn = document.getElementById('sh-save-button-extra');
    if (saveBtn) saveBtn.textContent = 'Save/Add Period';
}

function populateSchoolHolidayFormForEdit_ExtraPage(holidayId) {
    const holiday = schoolHolidayDateRanges_extra.find(h => h.id === holidayId);
    if (holiday) {
        document.getElementById('sh-editing-id-extra').value = holiday.id;
        document.getElementById('sh-start-date-input-extra').value = holiday.start;
        document.getElementById('sh-end-date-input-extra').value = holiday.end;
        document.getElementById('sh-description-input-extra').value = holiday.description || '';
        const clearBtn = document.getElementById('sh-clear-form-button-extra');
        if (clearBtn) clearBtn.style.display = 'inline-block';
        const saveBtn = document.getElementById('sh-save-button-extra');
        if (saveBtn) saveBtn.textContent = 'Update Period';
        document.getElementById('sh-start-date-input-extra').focus();
    }
}

async function handleSaveSchoolHoliday_ExtraPage() {
    const statusEl = document.getElementById('sh-status-message-extra');
    if (!statusEl) return;

    const editingId = document.getElementById('sh-editing-id-extra').value;
    const startDate = document.getElementById('sh-start-date-input-extra').value;
    const endDate = document.getElementById('sh-end-date-input-extra').value;
    const description = document.getElementById('sh-description-input-extra').value.trim();

    if (!startDate || !endDate) {
        statusEl.textContent = "Start Date and End Date are required.";
        statusEl.style.color = "#f1c40f";
        return;
    }
    if (new Date(endDate) < new Date(startDate)) {
        statusEl.textContent = "End Date cannot be before Start Date.";
        statusEl.style.color = "#f1c40f";
        return;
    }

    if (editingId) { // Editing existing
        const index = schoolHolidayDateRanges_extra.findIndex(h => h.id === editingId);
        if (index > -1) {
            schoolHolidayDateRanges_extra[index].start = startDate;
            schoolHolidayDateRanges_extra[index].end = endDate;
            schoolHolidayDateRanges_extra[index].description = description;
        }
    } else { // Adding new
        schoolHolidayDateRanges_extra.push({
            id: `sh-${Date.now()}`, // Simple unique ID
            start: startDate,
            end: endDate,
            description: description
        });
    }

    if (await saveSchoolHolidaysToFirebase_ExtraPage()) {
        statusEl.textContent = `School holiday period ${editingId ? 'updated' : 'added'} successfully.`;
        statusEl.style.color = "#2ecc71";
        clearSchoolHolidayForm_ExtraPage();
        displaySchoolHolidays_ExtraPage();
        // If other parts of your app depend on school holidays, you might need to trigger a refresh for them.
        // For example, if the current day profile display is affected:
        if (typeof updateCurrentProfileDisplay_ExtraPage === 'function') {
            updateCurrentProfileDisplay_ExtraPage();
        }
    } else {
        // saveSchoolHolidaysToFirebase_ExtraPage will set its own error message
    }
}

async function handleDeleteSchoolHoliday_ExtraPage(holidayId) {
    const statusEl = document.getElementById('sh-status-message-extra');
    if (!confirm("Are you sure you want to delete this school holiday period?")) {
        if(statusEl) statusEl.textContent = "Deletion cancelled.";
        return;
    }
    schoolHolidayDateRanges_extra = schoolHolidayDateRanges_extra.filter(h => h.id !== holidayId);
    if (await saveSchoolHolidaysToFirebase_ExtraPage()) {
        if(statusEl) {
            statusEl.textContent = "School holiday period deleted.";
            statusEl.style.color = "#2ecc71";
        }
        displaySchoolHolidays_ExtraPage();
        if (typeof updateCurrentProfileDisplay_ExtraPage === 'function') {
            updateCurrentProfileDisplay_ExtraPage();
        }
    }
}

async function saveOpProfilesToFirebase_ExtraPage() {
    if (!currentUser_extra || !window.firebaseOMSI) {
        console.error("Cannot save Op Profiles: Not logged in or Firebase not available.");
        if(opProfilesStatus_el_extra) {
            opProfilesStatus_el_extra.textContent = "Error: Not logged in. Cannot save.";
            opProfilesStatus_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        // RSG_OPERATING_PROFILES_LIST is now the source of truth, updated from Firebase or by edits
        await dbSet(dbRef(database, FB_PATH_EDITABLE_OP_PROFILES), RSG_OPERATING_PROFILES_LIST);
        console.log("Operating profiles saved to Firebase.");
        if(opProfilesStatus_el_extra) {
            opProfilesStatus_el_extra.textContent = "Operating profiles list saved to Firebase!";
            opProfilesStatus_el_extra.style.color = "#2ecc71";
             setTimeout(() => { if(opProfilesStatus_el_extra && opProfilesStatus_el_extra.textContent.includes("saved to Firebase")) opProfilesStatus_el_extra.textContent = ""; }, 3000);
        }
        return true;
    } catch (error) {
        console.error("Error saving operating profiles to Firebase:", error);
        if(opProfilesStatus_el_extra) {
            opProfilesStatus_el_extra.textContent = "Error saving operating profiles: " + error.message;
            opProfilesStatus_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
}

function renderEditableOpProfiles_ExtraPage() {
    const listDiv = document.getElementById('op-profiles-list-extra');
    const statusEl = document.getElementById('op-profiles-status-extra');
    if (!listDiv) return;

    listDiv.innerHTML = ''; // Clear current list

    if (!RSG_OPERATING_PROFILES_LIST || RSG_OPERATING_PROFILES_LIST.length === 0) {
        listDiv.innerHTML = '<p>No operating profiles defined. Add one above.</p>';
        return;
    }

    // Sort a copy for display, keeping the original RSG_OPERATING_PROFILES_LIST potentially unsorted if order matters elsewhere (though it's usually sorted for display in checkboxes)
    const profilesToDisplay = [...RSG_OPERATING_PROFILES_LIST].sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a); // Uses your existing sorter
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) return orderA - orderB;
        return String(a).localeCompare(String(b));
    });


    profilesToDisplay.forEach(profileName => {
        const itemDiv = document.createElement('div');
        itemDiv.style.display = 'flex';
        itemDiv.style.justifyContent = 'space-between';
        itemDiv.style.alignItems = 'center';
        itemDiv.style.padding = '0.4em 0.2em';
        itemDiv.style.borderBottom = '1px solid rgba(127,140,141,0.2)';

        const nameSpan = document.createElement('span');
        nameSpan.textContent = profileName;
        itemDiv.appendChild(nameSpan);

        const buttonsDiv = document.createElement('div');

        const editButton = document.createElement('button');
        editButton.textContent = 'Edit';
        editButton.classList.add('button', 'small-action', 'neutral');
        editButton.style.marginRight = '0.5em';
        editButton.addEventListener('click', () => handleEditOpProfile_ExtraPage(profileName));
        buttonsDiv.appendChild(editButton);

        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.classList.add('button', 'small-action', 'secondary');
        deleteButton.addEventListener('click', () => handleDeleteOpProfile_ExtraPage(profileName));
        buttonsDiv.appendChild(deleteButton);

        itemDiv.appendChild(buttonsDiv);
        listDiv.appendChild(itemDiv);
    });
}

async function handleAddOpProfile_ExtraPage() {
    const inputEl = document.getElementById('op-profile-input-extra');
    const statusEl = document.getElementById('op-profiles-status-extra');
    if (!inputEl || !statusEl) return;

    const newProfileName = inputEl.value.trim();
    if (!newProfileName) {
        statusEl.textContent = "Profile name cannot be empty.";
        statusEl.style.color = "#f1c40f";
        return;
    }
    if (RSG_OPERATING_PROFILES_LIST.some(p => p.toLowerCase() === newProfileName.toLowerCase())) {
        statusEl.textContent = `Profile "${newProfileName}" already exists.`;
        statusEl.style.color = "#f1c40f";
        return;
    }

    RSG_OPERATING_PROFILES_LIST.push(newProfileName);
    if (await saveOpProfilesToFirebase_ExtraPage()) {
        statusEl.textContent = `Profile "${newProfileName}" added.`;
        statusEl.style.color = "#2ecc71";
        inputEl.value = '';
        renderEditableOpProfiles_ExtraPage();
        // Refresh dependent UIs
        if (typeof rsg_populateProfileCheckboxes_ExtraPage === 'function') rsg_populateProfileCheckboxes_ExtraPage();
        if (typeof dpo_populateProfileCheckboxes_ExtraPage === 'function') dpo_populateProfileCheckboxes_ExtraPage();
    }
}

function checkProfileUsage_ExtraPage(profileName) {
    let usageMessages = [];
    const profileLower = profileName.toLowerCase();

    // Check live schedule
    if (currentWorkingSchedule_extra.some(entry => entry.OperatingProfile && entry.OperatingProfile.toLowerCase() === profileLower)) {
        usageMessages.push("Live schedule entries");
    }
    // Check RSG saved configs
    if (Object.values(rsg_loadedConfigs_extra).some(config => config.operatingProfile && config.operatingProfile.toLowerCase().split(',').map(p=>p.trim()).includes(profileLower))) {
        usageMessages.push("Saved Route Schedule Generator configurations");
    }
    // Check Day Profile Overrides (assuming overrides are loaded into a variable, e.g., `dayProfileOverrides_data`)
    // For this example, let's assume `activeOverridesList_el_extra` innerHTML can be checked, or better, a data structure.
    // This is a placeholder for actual data checking:
    // if (dayProfileOverrides_data && Object.values(dayProfileOverrides_data).some(override => override.toLowerCase() === profileLower)) {
    //     usageMessages.push("Day Profile Overrides");
    // }

    // Check hardcoded JS constants (simplified check)
    const criticalHardcodedProfiles = ["mo", "tu", "we", "th", "fr", "sa", "su", "mf", "mfsch", "mfnsd"]; // examples
    if (criticalHardcodedProfiles.includes(profileLower) ||
        RSG_PROFILE_GROUPS_TO_MANAGE.some(group => group.groupProfile.toLowerCase() === profileLower || group.individuals.some(ind => ind.toLowerCase() === profileLower)) ||
        MASTER_VALID_PROFILE_COMBINATIONS_LIST_EXTRA.some(combo => combo.toLowerCase().split(',').map(p=>p.trim()).includes(profileLower)) ) {
        usageMessages.push("Hardcoded JavaScript logic (Profile Groups, Valid Combinations). Modifying this may break checkbox selection logic unless JS code is also updated by a developer.");
    }
    return usageMessages;
}

async function handleEditOpProfile_ExtraPage(oldProfileName) {
    const statusEl = document.getElementById('op-profiles-status-extra');
    const newProfileName = prompt(`Enter new name for operating profile "${oldProfileName}":`, oldProfileName);

    if (!newProfileName || newProfileName.trim() === "" || newProfileName.trim() === oldProfileName) {
        statusEl.textContent = "Edit cancelled or name unchanged.";
        statusEl.style.color = "";
        return;
    }
    const trimmedNewName = newProfileName.trim();
    if (RSG_OPERATING_PROFILES_LIST.some(p => p.toLowerCase() === trimmedNewName.toLowerCase() && p.toLowerCase() !== oldProfileName.toLowerCase())) {
        statusEl.textContent = `Profile name "${trimmedNewName}" already exists.`;
        statusEl.style.color = "#f1c40f";
        return;
    }

    const usage = checkProfileUsage_ExtraPage(oldProfileName);
    let confirmMessage = `Are you sure you want to rename "<span class="math-inline">\{oldProfileName\}" to "</span>{trimmedNewName}"?`;
    if (usage.length > 0) {
        confirmMessage += "\n\nWARNING: This profile is currently used in or referenced by:\n- " + usage.join("\n- ");
        confirmMessage += "\n\nRenaming it here will update the list, but will NOT automatically update it in existing schedules, saved RSG configs, or hardcoded JavaScript logic. This might lead to inconsistencies or broken behavior in related tools unless those are also updated (some manually).";
    }

    if (!confirm(confirmMessage)) {
        statusEl.textContent = "Edit cancelled by user.";
        return;
    }

    const index = RSG_OPERATING_PROFILES_LIST.findIndex(p => p === oldProfileName);
    if (index > -1) {
        RSG_OPERATING_PROFILES_LIST[index] = trimmedNewName;
        if (await saveOpProfilesToFirebase_ExtraPage()) {
            statusEl.textContent = `Profile "<span class="math-inline">\{oldProfileName\}" renamed to "</span>{trimmedNewName}".`;
            renderEditableOpProfiles_ExtraPage();
            // Refresh dependent UIs
            if (typeof rsg_populateProfileCheckboxes_ExtraPage === 'function') rsg_populateProfileCheckboxes_ExtraPage();
            if (typeof dpo_populateProfileCheckboxes_ExtraPage === 'function') dpo_populateProfileCheckboxes_ExtraPage();
        }
    } else {
        statusEl.textContent = `Error: Profile "${oldProfileName}" not found to edit.`;
        statusEl.style.color = "#e74c3c";
    }
}

async function handleDeleteOpProfile_ExtraPage(profileNameToDelete) {
    const statusEl = document.getElementById('op-profiles-status-extra');

    const usage = checkProfileUsage_ExtraPage(profileNameToDelete);
    let confirmMessage = `Are you sure you want to delete the operating profile "${profileNameToDelete}"? This action cannot be undone.`;
    if (usage.length > 0) {
        confirmMessage += "\n\nWARNING: This profile is currently used in or referenced by:\n- " + usage.join("\n- ");
        confirmMessage += "\n\nDeleting it will remove it from this list, but will NOT automatically remove it from existing schedules, saved RSG configs, or hardcoded JavaScript logic. This might lead to orphaned data or broken behavior in related tools.";
    }
     if (RSG_OPERATING_PROFILES_LIST.length <= 1) {
        alert("You cannot delete the last operating profile.");
        return;
    }


    if (!confirm(confirmMessage)) {
        statusEl.textContent = "Deletion cancelled by user.";
        return;
    }

    RSG_OPERATING_PROFILES_LIST = RSG_OPERATING_PROFILES_LIST.filter(p => p !== profileNameToDelete);
    if (await saveOpProfilesToFirebase_ExtraPage()) {
        statusEl.textContent = `Profile "${profileNameToDelete}" deleted.`;
        renderEditableOpProfiles_ExtraPage();
        // Refresh dependent UIs
        if (typeof rsg_populateProfileCheckboxes_ExtraPage === 'function') rsg_populateProfileCheckboxes_ExtraPage();
        if (typeof dpo_populateProfileCheckboxes_ExtraPage === 'function') dpo_populateProfileCheckboxes_ExtraPage();
    }
}

function populateServiceAnalyzerDropdowns_ExtraPage() {
    if (!serviceAnalyzerStopSelect_el_extra || !allDefinedStops_data) {
        if (serviceAnalyzerStopSelect_el_extra) {
            serviceAnalyzerStopSelect_el_extra.innerHTML = '<option value="">Error loading stops</option>';
        }
        return;
    }

    const currentSelectedValue = serviceAnalyzerStopSelect_el_extra.value;
    serviceAnalyzerStopSelect_el_extra.innerHTML = '<option value="">-- Select Stop --</option>';

    const stopsArray = Object.values(allDefinedStops_data);

    stopsArray.sort((a, b) => {
        const nameA = (a.stopName || "").toLowerCase();
        const nameB = (b.stopName || "").toLowerCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        return (a.stopID || "").localeCompare(b.stopID || "");
    });

    let selectedStillExists = false;
    stopsArray.forEach(stop => {
        if (stop && stop.stopID && stop.stopName) {
            const option = document.createElement('option');
            option.value = stop.stopID;
            option.textContent = `${stop.stopName} (${stop.stopID})`;
            serviceAnalyzerStopSelect_el_extra.appendChild(option);
            if (stop.stopID === currentSelectedValue) {
                selectedStillExists = true;
            }
        }
    });

    if (selectedStillExists) {
        serviceAnalyzerStopSelect_el_extra.value = currentSelectedValue;
    } else {
        if (serviceAnalyzerStopInput_el_extra && serviceAnalyzerStopInput_el_extra.value) {
            const typedValueLower = serviceAnalyzerStopInput_el_extra.value.toLowerCase().trim();
            const matchedOption = Array.from(serviceAnalyzerStopSelect_el_extra.options).find(opt =>
                opt.text.toLowerCase().includes(typedValueLower) ||
                (opt.value && opt.value.toLowerCase() === typedValueLower)
            );
            if (matchedOption) {
                serviceAnalyzerStopSelect_el_extra.value = matchedOption.value;
            }
        }
    }
}

        function rsg_populateCopySourceOpProfileSelect_ExtraPage() {
    if (!rsgCopySourceOpProfileSelect_el_extra || !rsgCopySourceRouteNameSelect_el_extra || !rsgCopySourceDestNameSelect_el_extra || !currentWorkingSchedule_extra) {
        if (rsgCopySourceOpProfileSelect_el_extra) {
            rsgCopySourceOpProfileSelect_el_extra.innerHTML = '<option value="">-- Error: Deps missing --</option>';
        }
        console.warn("RSG Copy Modal: Missing elements or schedule data for populating profiles.");
        return;
    }

    // Store the previously selected profile value
    const previouslySelectedProfile = rsgCopySourceOpProfileSelect_el_extra.value;

    const sourceRouteName = rsgCopySourceRouteNameSelect_el_extra.value.trim().toUpperCase();
    const sourceDestName = rsgCopySourceDestNameSelect_el_extra.value.trim(); // Read from select

    rsgCopySourceOpProfileSelect_el_extra.innerHTML = '<option value="">-- Select Profile --</option>'; // Default option

    if (!sourceRouteName) {
        rsgCopySourceOpProfileSelect_el_extra.innerHTML = '<option value="">-- Select Route First --</option>';
        return;
    }

    const relevantEntries = currentWorkingSchedule_extra.filter(entry => {
        let matches = entry.lineName && entry.lineName.toUpperCase() === sourceRouteName;
        if (sourceDestName) { // If a destination is specified, filter by it
            matches = matches && entry.destinationName === sourceDestName;
        }
        return matches;
    });

    if (relevantEntries.length === 0) {
        rsgCopySourceOpProfileSelect_el_extra.innerHTML = '<option value="">-- No schedules for selected Route/Dest --</option>';
        return;
    }

    const uniqueProfiles = [...new Set(relevantEntries.map(e => e.OperatingProfile).filter(Boolean))];
    
    uniqueProfiles.sort((a, b) => {
        const orderA = (typeof getDaySortOrder_ExtraPage === 'function') ? getDaySortOrder_ExtraPage(a) : 0;
        const orderB = (typeof getDaySortOrder_ExtraPage === 'function') ? getDaySortOrder_ExtraPage(b) : 0;
        if (orderA !== orderB) return orderA - orderB;
        return String(a).localeCompare(String(b)); 
    });

    if (uniqueProfiles.length === 0) {
        rsgCopySourceOpProfileSelect_el_extra.innerHTML = '<option value="">-- No Profiles Found --</option>';
        return;
    }

    let isPreviouslySelectedProfileStillValid = false;
    uniqueProfiles.forEach(profile => {
        const opt = document.createElement('option');
        opt.value = profile;
        opt.textContent = profile;
        rsgCopySourceOpProfileSelect_el_extra.appendChild(opt);
        if (profile === previouslySelectedProfile) {
            isPreviouslySelectedProfileStillValid = true;
        }
    });

    // If the previously selected profile is still in the new list of options, re-select it.
    if (isPreviouslySelectedProfileStillValid && previouslySelectedProfile !== "") {
        rsgCopySourceOpProfileSelect_el_extra.value = previouslySelectedProfile;
    }
}

async function handleToggleStopStatusFromMasterList_ExtraPage(stopIDToToggle) {
    if (!currentUser_extra || !window.firebaseOMSI) {
        alert("Please log in to change stop status.");
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "Not logged in.";
        return;
    }
    if (!stopIDToToggle) {
        console.error("handleToggleStopStatusFromMasterList_ExtraPage: No stopID provided.");
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "Error: StopID missing for status toggle.";
        return;
    }

    const stopIDUpper = stopIDToToggle.toUpperCase();
    const isCurrentlyClosed = closedStopIDs_extra.includes(stopIDUpper);
    const action = isCurrentlyClosed ? "reopen" : "close";
    const stopNameForConfirm = allDefinedStops_data[stopIDUpper]?.stopName || stopIDToToggle;

    if (!confirm(`Are you sure you want to ${action} the stop: "${stopNameForConfirm}" (${stopIDToToggle})?`)) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `Stop status change for ${stopIDToToggle} cancelled.`;
        return;
    }

    if (isCurrentlyClosed) {
        // Reopen: Remove from closedStopIDs_extra
        const index = closedStopIDs_extra.indexOf(stopIDUpper);
        if (index > -1) {
            closedStopIDs_extra.splice(index, 1);
        }
    } else {
        // Close: Add to closedStopIDs_extra if not already there
        if (!closedStopIDs_extra.includes(stopIDUpper)) {
            closedStopIDs_extra.push(stopIDUpper);
        }
    }

    if (masterStopListStatus_el_extra) {
        masterStopListStatus_el_extra.textContent = `Updating status for stop ${stopIDToToggle}...`;
        masterStopListStatus_el_extra.style.color = "#f1c40f";
    }

    try {
        // Save the updated closedStopIDs_extra array to Firebase
        // Assuming you have a function like saveClosedStopsToFirebase_ExtraPage
        if (typeof saveClosedStopsToFirebase_ExtraPage === 'function') {
            await saveClosedStopsToFirebase_ExtraPage(); // This function should save the 'closedStopIDs_extra' array
        } else {
            console.error("saveClosedStopsToFirebase_ExtraPage function is not defined! Cannot save stop status changes to Firebase.");
            throw new Error("Critical function missing for saving closed stops.");
        }
        
        if (masterStopListStatus_el_extra) {
            masterStopListStatus_el_extra.textContent = `Stop "${stopNameForConfirm}" has been ${action}d.`;
            masterStopListStatus_el_extra.style.color = "#2ecc71";
        }
        // Refresh the master stop list UI to reflect the change
        populateMasterStopList_ExtraPage();
        // Also, if the arrivals page might be open, it will eventually pick up this change from Firebase.
        // If this stop was currently selected in the Service Analyzer or other tools, their display might need refresh.
        renderUIDependentElements_ExtraPage();


    } catch (error) {
        console.error(`Error ${action}ing stop ${stopIDToToggle}:`, error);
        if (masterStopListStatus_el_extra) {
            masterStopListStatus_el_extra.textContent = `Error ${action}ing stop: ${error.message}`;
            masterStopListStatus_el_extra.style.color = "#e74c3c";
        }
        // Revert local change on error
        if (isCurrentlyClosed) { // Was trying to reopen, but failed, so add it back
            if (!closedStopIDs_extra.includes(stopIDUpper)) closedStopIDs_extra.push(stopIDUpper);
        } else { // Was trying to close, but failed, so remove it
            const index = closedStopIDs_extra.indexOf(stopIDUpper);
            if (index > -1) closedStopIDs_extra.splice(index, 1);
        }
        populateMasterStopList_ExtraPage(); // Refresh to show reverted state
    }
}

// Place this function in your <script> tag in omsi_tools_extra.html
// where other helper functions are defined.

function getTextColourForBackground_ExtraPage(hexColour) {
    if (!hexColour || typeof hexColour !== 'string' || !hexColour.startsWith('#')) {
        // console.warn("getTextColourForBackground_ExtraPage: Invalid hexColour provided:", hexColour, "Defaulting to white text.");
        return '#FFFFFF'; // Default to white text on error or if invalid
    }

    let r, g, b;
    if (hexColour.length === 4) { // Expand short hex e.g. #RGB to #RRGGBB
        r = parseInt(hexColour[1] + hexColour[1], 16);
        g = parseInt(hexColour[2] + hexColour[2], 16);
        b = parseInt(hexColour[3] + hexColour[3], 16);
    } else if (hexColour.length === 7) {
        r = parseInt(hexColour.slice(1, 3), 16);
        g = parseInt(hexColour.slice(3, 5), 16);
        b = parseInt(hexColour.slice(5, 7), 16);
    } else {
        // console.warn("getTextColourForBackground_ExtraPage: Hex length invalid:", hexColour, "Defaulting to white text.");
        return '#FFFFFF'; // Invalid length
    }

    if (isNaN(r) || isNaN(g) || isNaN(b)) {
        // console.warn("getTextColourForBackground_ExtraPage: Failed to parse hex:", hexColour, "Defaulting to white text.");
        return '#FFFFFF';
    }
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return luminance > 0.5 ? '#000000' : '#FFFFFF';
}

function rsg_openReplaceStopModal_ExtraPage(indexToReplace) {
    // MODIFICATION: Get the modal element directly inside the function
    const modalElement = document.getElementById('rsg-replace-stop-modal-extra');

    // Log 1: Function entry
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 1: Function called with indexToReplace:", indexToReplace, "Type:", typeof indexToReplace);
    console.log("[rsg_openReplaceStopModal_ExtraPage] Fresh modalElement lookup result:", modalElement); // NEW LOG to see if it's found

    // NEW DIRECT CHECK for the main modal container
    if (!modalElement) {
        alert("Critical Error: The modal container 'rsg-replace-stop-modal-extra' was NOT found in the DOM when trying to open it. Please ensure its HTML is correct and not commented out or removed by another script.");
        console.error("[rsg_openReplaceStopModal_ExtraPage] The element with ID 'rsg-replace-stop-modal-extra' is null at the time of function call.");
        return; // Stop if the main modal div isn't there
    }

    // Original Check 1: Validate rsg_selectedStops_extra (data for the sequence)
    if (rsg_selectedStops_extra === null || typeof rsg_selectedStops_extra === 'undefined') {
        console.error("[rsg_openReplaceStopModal_ExtraPage] ERROR CHECK 1: rsg_selectedStops_extra is null or undefined! Cannot proceed.");
        alert("Critical Error: The stop sequence data is not available for replacement operation.");
        return;
    }
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 2 (original check 1): rsg_selectedStops_extra type:", typeof rsg_selectedStops_extra, "Is Array:", Array.isArray(rsg_selectedStops_extra), "Length:", rsg_selectedStops_extra?.length);

    // Original Check 2: Validate indexToReplace (index within the sequence data)
    if (typeof indexToReplace !== 'number' || isNaN(indexToReplace) || indexToReplace < 0 || indexToReplace >= rsg_selectedStops_extra.length) {
        console.error("[rsg_openReplaceStopModal_ExtraPage] ERROR CHECK 2: Invalid indexToReplace.",
                      "Index:", indexToReplace, "Sequence length:", rsg_selectedStops_extra.length);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Error: Invalid stop position for replacement operation. Index out of bounds.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        } else {
            alert("Error: Invalid stop position for replacement operation.");
        }
        return;
    }
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 3 (original check 2): indexToReplace is valid.");

    rsg_indexOfStopToReplace_extra = indexToReplace;
    const originalStop = rsg_selectedStops_extra[indexToReplace];

    // Original Check 3: Validate originalStop (data for the specific stop being replaced)
    if (!originalStop || typeof originalStop !== 'object') {
        console.error("[rsg_openReplaceStopModal_ExtraPage] ERROR CHECK 3: Could not find valid original stop data at index", indexToReplace, "Data found:", originalStop);
        alert("Error: Could not retrieve data for the stop to be replaced.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Error: Original stop data missing.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 4 (original check 3): Original stop to replace:", JSON.parse(JSON.stringify(originalStop)));

    // Check 4: DOM Elements for the modal *CONTENTS*. The main container (`modalElement`) is already confirmed to exist.
    let allModalInternalElementsPresent = true;
    const modalTitle_el = document.getElementById('rsg-replace-stop-modal-title-extra');
    const modalInfo_el = document.getElementById('rsg-replace-stop-modal-info-extra');
    const modalSearchInput_el = document.getElementById('rsg-replace-stop-search-input-extra');
    const modalSearchResults_el = document.getElementById('rsg-replace-stop-search-results-extra');
    const modalStatus_el = document.getElementById('rsg-replace-stop-modal-status-extra'); // Status paragraph inside the modal

    if (!modalTitle_el) { console.error("[rsg_openReplaceStopModal_ExtraPage] Modal internal part 'rsg-replace-stop-modal-title-extra' is null."); allModalInternalElementsPresent = false; }
    if (!modalInfo_el) { console.error("[rsg_openReplaceStopModal_ExtraPage] Modal internal part 'rsg-replace-stop-modal-info-extra' is null."); allModalInternalElementsPresent = false; }
    if (!modalSearchInput_el) { console.error("[rsg_openReplaceStopModal_ExtraPage] Modal internal part 'rsg-replace-stop-search-input-extra' is null."); allModalInternalElementsPresent = false; }
    if (!modalSearchResults_el) { console.error("[rsg_openReplaceStopModal_ExtraPage] Modal internal part 'rsg-replace-stop-search-results-extra' is null."); allModalInternalElementsPresent = false; }

    if (!allModalInternalElementsPresent) {
        alert("Critical Error: Some internal parts of the 'Replace Stop' dialog are missing from the page, even if the main container was found. Modal may not function correctly. Check console for details.");
        // Optionally, you could still try to show the modal if the main container exists but internals are missing,
        // or return here to prevent showing a broken modal. For now, let's allow it to proceed to show the (potentially empty) modal.
    }
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 5 equivalent: Check for internal modal parts complete. allModalInternalElementsPresent:", allModalInternalElementsPresent);

    // Populate modal content (these will only run if elements were found)
    if (modalTitle_el) {
        modalTitle_el.textContent = `Replace: ${originalStop.stopName || 'N/A'} (${originalStop.stopID || 'N/A'})`;
    }
    if (modalInfo_el) {
        let timeAdjInfo = "";
        if (indexToReplace > 0) {
            timeAdjInfo = `The existing time adjustment of +${originalStop.timeAdjustment || 0} min (from previous stop) will be kept.`;
        } else {
            timeAdjInfo = "This is the first stop in the sequence; its time adjustment is effectively 0.";
        }
        modalInfo_el.textContent = `You are replacing the stop at position ${indexToReplace + 1}. ${timeAdjInfo}`;
    }
    if (modalSearchInput_el) {
        modalSearchInput_el.value = '';
    }
    if (modalSearchResults_el) {
        modalSearchResults_el.innerHTML = '<p style="padding:5px; opacity:0.7;">Type to search for a replacement stop.</p>';
    }
    if (modalStatus_el) {
        modalStatus_el.textContent = '';
    }

    // Display the modal using the locally fetched 'modalElement'
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 6 equivalent: Attempting to display the modal element.");
    modalElement.style.display = 'flex'; // Use the locally fetched modalElement
    if (modalSearchInput_el) {
        modalSearchInput_el.focus();
    }
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 7 equivalent: Modal display style set to 'flex'. Focus set to input (if available).");
}

function rsg_closeReplaceStopModal_ExtraPage() {
    if (rsgReplaceStopModal_el_extra) {
        rsgReplaceStopModal_el_extra.style.display = 'none';
    }
    rsg_indexOfStopToReplace_extra = -1; // Reset index
}

function rsg_handleReplaceStopSearch_ExtraPage() {
    if (!rsgReplaceStopSearchInput_el_extra || !rsgReplaceStopSearchResults_el_extra || !allDefinedStops_data) {
        // Ensure necessary elements and data are available
        if (rsgReplaceStopSearchResults_el_extra) {
             rsgReplaceStopSearchResults_el_extra.innerHTML = '<p style="padding:5px; opacity:0.7; color: #e74c3c;">Error: Search components not ready.</p>';
        }
        return;
    }

    const searchTerm = rsgReplaceStopSearchInput_el_extra.value.toLowerCase().trim();
    rsgReplaceStopSearchResults_el_extra.innerHTML = ''; // Clear previous results

    if (searchTerm.length === 0) {
        rsgReplaceStopSearchResults_el_extra.innerHTML = '<p style="padding:5px; opacity:0.7;">Type to search for a replacement stop.</p>';
        return;
    }
    if (searchTerm.length < 2) { // Optional: you might want to allow 1-char searches or adjust this
        rsgReplaceStopSearchResults_el_extra.innerHTML = '<p style="padding:5px; opacity:0.7;">Please type at least 2 characters to search.</p>';
        return;
    }

    // Ensure allDefinedStops_data is an object before trying to get its values
    const definedStopsArray = (typeof allDefinedStops_data === 'object' && allDefinedStops_data !== null)
                             ? Object.values(allDefinedStops_data)
                             : [];

    if (definedStopsArray.length === 0) {
        rsgReplaceStopSearchResults_el_extra.innerHTML = '<p style="padding:5px; opacity:0.7; color: #f1c40f;">No defined stops available to search.</p>';
        return;
    }
    
    const currentStopBeingReplacedID = (rsg_indexOfStopToReplace_extra !== -1 && 
                                        rsg_selectedStops_extra && // Ensure rsg_selectedStops_extra exists
                                        rsg_selectedStops_extra[rsg_indexOfStopToReplace_extra])
                                    ? rsg_selectedStops_extra[rsg_indexOfStopToReplace_extra].stopID.toUpperCase()
                                    : null;

    const filteredStops = definedStopsArray.filter(stop => {
        // Ensure stop object and its properties are valid before accessing
        const stopName = stop && typeof stop.stopName === 'string' ? stop.stopName : "";
        const stopID = stop && typeof stop.stopID === 'string' ? stop.stopID : "";

        if (!stopID) return false; // Skip if stopID is invalid or missing

        // Exclude the exact stop that is currently at the position being replaced
        if (currentStopBeingReplacedID && stopID.toUpperCase() === currentStopBeingReplacedID) {
            return false;
        }
        return stopName.toLowerCase().includes(searchTerm) || stopID.toLowerCase().includes(searchTerm);
    }).slice(0, 10); // Limit results to the top 10

    if (filteredStops.length > 0) {
        filteredStops.forEach(newStop => { // newStop is an object like { stopID: "X", stopName: "Y", direction: "Z" }
            const itemDiv = document.createElement('div');
            itemDiv.classList.add('rsg-search-result-item');

            // --- CORRECTED CONTENT GENERATION ---
            const stopNameDisplay = newStop.stopName || 'N/A';
            const stopIDDisplay = newStop.stopID || 'N/A'; 

            // Main stop name and ID line
            let content = `<span class="rsg-search-stop-name">${stopNameDisplay} (${stopIDDisplay})</span>`;

            // Add direction if available
            let directionText = "";
            if (newStop.direction && newStop.direction.trim() !== "" && newStop.direction.trim().toUpperCase() !== "NO DIRECTION") {
                directionText = `Towards: ${newStop.direction}`;
            }
            if (directionText) {
                content += `<span class="rsg-search-stop-details">${directionText}</span>`;
            }
            // --- END OF CORRECTION ---
            
            itemDiv.innerHTML = content;

            itemDiv.addEventListener('click', () => {
                // Ensure rsg_confirmStopReplacement_ExtraPage is defined before calling
                if (typeof rsg_confirmStopReplacement_ExtraPage === 'function') {
                    rsg_confirmStopReplacement_ExtraPage(newStop);
                } else {
                    console.error("Error: rsg_confirmStopReplacement_ExtraPage function is not defined.");
                    alert("Error: Cannot confirm stop replacement, function missing.");
                }
            });
            rsgReplaceStopSearchResults_el_extra.appendChild(itemDiv);
        });
    } else {
        rsgReplaceStopSearchResults_el_extra.innerHTML = '<div class="rsg-search-result-item">No other matching stops found.</div>';
    }
}

function rsg_confirmStopReplacement_ExtraPage(newStopData) {
    if (rsg_indexOfStopToReplace_extra < 0 || rsg_indexOfStopToReplace_extra >= rsg_selectedStops_extra.length) {
        console.error("Cannot replace stop, invalid index stored:", rsg_indexOfStopToReplace_extra);
        const modalStatusEl = document.getElementById('rsg-replace-stop-modal-status-extra');
        if (modalStatusEl) {
            modalStatusEl.textContent = "Error: Invalid stop position. Please close and retry.";
            modalStatusEl.style.color = "#e74c3c";
        }
        return;
    }

    const originalStopData = rsg_selectedStops_extra[rsg_indexOfStopToReplace_extra];
    // Preserve time adjustment. For the first stop (index 0), it's always 0.
    const preservedTimeAdjustment = (rsg_indexOfStopToReplace_extra === 0) ? 0 : (originalStopData.timeAdjustment || 0);

    const replacementStop = {
        stopID: newStopData.stopID,
        stopName: newStopData.stopName,
        direction: newStopData.direction || "",
        timeAdjustment: preservedTimeAdjustment
    };

    rsg_selectedStops_extra.splice(rsg_indexOfStopToReplace_extra, 1, replacementStop);

    rsg_isDirty = true;
    rsg_closeReplaceStopModal_ExtraPage();
    rsg_renderStopSequence_ExtraPage();
    rsg_resetPreviewState(`Stop '<span class="math-inline">\{originalStopData\.stopName\}' replaced with '</span>{newStopData.stopName}'. Regenerate preview.`, "info");
    rsg_updateRsgActionButtonsState();

    if (rsgStatusMessage_el_extra) {
        rsgStatusMessage_el_extra.textContent = `Stop at position ${rsg_indexOfStopToReplace_extra + 1} changed to ${newStopData.stopName}.`;
        rsgStatusMessage_el_extra.style.color = "#2ecc71";
    }
}

// In omsi_tools_extra.html

// This function should be called to save the master list of all defined stops
async function saveAllDefinedStopsToFirebase_ExtraPage() {
    if (!currentUser_extra || !window.firebaseOMSI) {
        console.error("saveAllDefinedStopsToFirebase_ExtraPage: Not logged in or Firebase not available.");
        throw new Error("Authentication or Firebase connection issue for saving defined stops.");
    }
    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        // This line saves the entire 'allDefinedStops_data' object to the '/allDefinedStops' path
        await dbSet(dbRef(database, FB_PATH_ALL_DEFINED_STOPS), allDefinedStops_data);
        console.log("All defined stop definitions saved to Firebase path:", FB_PATH_ALL_DEFINED_STOPS);
    } catch (error) {
        console.error("Error saving all defined stop definitions to Firebase:", error);
        throw error; // Propagate error to be handled by the caller
    }
}

// This function is called when you click "Add Stop Definition"
async function handleAddStopDetails_ExtraPage() {
    if (!currentUser_extra || !addNewStopStatus_el_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !inputNewStopDirection_el_extra) {
        if (addNewStopStatus_el_extra) {
            addNewStopStatus_el_extra.textContent = "Error: UI components missing for adding stop.";
            addNewStopStatus_el_extra.style.color = '#e74c3c';
        }
        return;
    }
    const newStopID = inputNewStopId_el_extra.value.trim().toUpperCase(); // Ensure newStopID is uppercase
    const newStopName = inputNewStopName_el_extra.value.trim();
    const newStopDirection = inputNewStopDirection_el_extra.value.trim();

    if (!newStopID) { 
        addNewStopStatus_el_extra.textContent = "New Stop ID is required."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopId_el_extra.focus(); 
        return; 
    }
    if (!/^[A-Z0-9]+$/.test(newStopID)) { 
        addNewStopStatus_el_extra.textContent = "Stop ID: A-Z, 0-9 only (uppercase)."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopId_el_extra.focus(); 
        return; 
    }
    if (!newStopName) { 
        addNewStopStatus_el_extra.textContent = "New Stop Name is required."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopName_el_extra.focus(); 
        return; 
    }

    // Check against the local cache 'allDefinedStops_data'
    // Ensure 'allDefinedStops_data' keys are consistently uppercase
    if (allDefinedStops_data && allDefinedStops_data[newStopID]) { 
        addNewStopStatus_el_extra.textContent = `Stop ID "${newStopID}" already exists as a definition.`; 
        if(newStopIdAvailability_el_extra){ 
            newStopIdAvailability_el_extra.textContent = 'ID already exists!'; 
            newStopIdAvailability_el_extra.style.color = '#e74c3c'; 
        } 
        inputNewStopId_el_extra.focus(); 
        return; 
    }

    const newStopDefinition = {
        stopID: newStopID, // Storing the uppercase version
        stopName: newStopName,
        direction: newStopDirection
    };
    
    // Add to local cache 'allDefinedStops_data' using uppercase key
    if (!allDefinedStops_data) allDefinedStops_data = {};
    allDefinedStops_data[newStopID] = newStopDefinition;

    addNewStopStatus_el_extra.textContent = `Adding stop definition "${newStopID}" to Firebase...`;
    addNewStopStatus_el_extra.style.color = '#f1c40f';

    try {
        // This is the crucial call to save the updated master list to Firebase
        await saveAllDefinedStopsToFirebase_ExtraPage(); 
        
        addNewStopStatus_el_extra.textContent = `Stop definition "${newStopID} - ${newStopName}" added to Firebase.`;
        addNewStopStatus_el_extra.style.color = '#2ecc71';

        // Clear inputs and refresh UI
        inputNewStopId_el_extra.value = ''; 
        inputNewStopName_el_extra.value = ''; 
        inputNewStopDirection_el_extra.value = '';
        if(newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = '';
        if(selectNewStopIdFormat_el_extra) selectNewStopIdFormat_el_extra.selectedIndex = 0;
        
        if (typeof autoGenerateAndSetNewStopId_ExtraPage === 'function' && inputNewStopName_el_extra && inputNewStopId_el_extra) {
            autoGenerateAndSetNewStopId_ExtraPage(); // Suggest ID for the *next* stop
        }
        
        renderUIDependentElements_ExtraPage(); // Refresh UI lists (like master stop list)

    } catch (error) {
        console.error("Error adding new stop definition:", error);
        addNewStopStatus_el_extra.textContent = "Error saving stop definition: " + error.message;
        addNewStopStatus_el_extra.style.color = '#e74c3c';
        
        // Revert local addition if Firebase update failed
        if (allDefinedStops_data && allDefinedStops_data[newStopID]) {
            delete allDefinedStops_data[newStopID];
        }
        renderUIDependentElements_ExtraPage(); // Refresh UI to show the reverted state
    }
}

// Function to populate the route dropdown for Scheduled Route Deletion (SRD)
function srd_populateRouteSelect_ExtraPage() {
    if (!srdRouteNameSelect_el_extra || !currentWorkingSchedule_extra) {
        console.warn("SRD: Route select element or schedule data not available.");
        return;
    }
    // Get unique routes that actually have schedule entries (not just definitions)
    const uniqueRoutesWithSchedules = [...new Set(
        currentWorkingSchedule_extra
            .filter(e => e.lineName && e.scheduledTime) // Ensure it's a route with actual schedule entries
            .map(e => e.lineName)
    )].sort(compareLineNames_ExtraPage);

    const currentInputValue = srdRouteNameInput_el_extra ? srdRouteNameInput_el_extra.value.trim() : "";

    srdRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Route to Delete --</option>';
    uniqueRoutesWithSchedules.forEach(route => {
        const opt = document.createElement('option');
        opt.value = route;
        opt.textContent = route;
        srdRouteNameSelect_el_extra.appendChild(opt);
    });

    if (currentInputValue) {
        const matchedOption = uniqueRoutesWithSchedules.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
        srdRouteNameSelect_el_extra.value = matchedOption ? matchedOption : "";
    } else {
        srdRouteNameSelect_el_extra.value = "";
    }
    if(srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = '';
}

function rsg_pullCurrentFirstStopTimes_ExtraPage() {
    if (!currentUser_extra) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Please log in to pull times.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    if (!rsgRouteNameInput_el_extra || !rsgDestinationNameInput_el_extra || !rsgFirstStopTimesInput_el_extra || !rsgStatusMessage_el_extra) {
        console.error("RSG Pull Times: Essential DOM elements missing.");
        alert("Error: RSG form components for pulling times are missing.");
        return;
    }

    const routeName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
    const opProfilesString = rsg_getSelectedOpProfilesString_ExtraPage(); // Returns comma-separated string like "MF, Sa"
    const destName = rsgDestinationNameInput_el_extra.value.trim();

    if (!routeName) {
        rsgStatusMessage_el_extra.textContent = "Please select/enter a Route Name first.";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }
    if (!opProfilesString) {
        rsgStatusMessage_el_extra.textContent = "Please select Operating Profile(s) first.";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }
    if (!destName) {
        rsgStatusMessage_el_extra.textContent = "Please select/enter a Destination Name first.";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    if (!rsg_selectedStops_extra || rsg_selectedStops_extra.length === 0) {
        rsgStatusMessage_el_extra.textContent = "No stops in the sequence. Add the first stop to pull its times.";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    const firstStopID = rsg_selectedStops_extra[0].stopID;
    const selectedOpProfilesArray = opProfilesString.split(',').map(p => p.trim()).filter(Boolean);
    const uniqueTimesSet = new Set();

    currentWorkingSchedule_extra.forEach(entry => {
        if (entry.lineName && entry.lineName.toUpperCase() === routeName &&
            entry.destinationName === destName &&
            entry.stopID === firstStopID &&
            entry.OperatingProfile && selectedOpProfilesArray.includes(entry.OperatingProfile) &&
            (entry.DayOffset === "0" || !entry.DayOffset) && // Primarily pull times for DayOffset 0
            entry.scheduledTime && entry.scheduledTime.match(/^\d{2}:\d{2}$/)) {
            uniqueTimesSet.add(entry.scheduledTime);
        }
    });

    if (uniqueTimesSet.size > 0) {
        const sortedTimes = Array.from(uniqueTimesSet).sort((a, b) => {
            const timeAVal = parseInt(a.replace(':', ''), 10);
            const timeBVal = parseInt(b.replace(':', ''), 10);
            return timeAVal - timeBVal;
        });
        rsgFirstStopTimesInput_el_extra.value = sortedTimes.join('\t');
        rsgStatusMessage_el_extra.textContent = `Pulled ${sortedTimes.length} unique first stop time(s) for the selected parameters.`;
        rsgStatusMessage_el_extra.style.color = "#2ecc71";
        rsg_isDirty = true; // Mark configuration as dirty
        console.log(`RSG User Edit: First stop times pulled. rsg_isDirty is true. Times: "${rsgFirstStopTimesInput_el_extra.value}"`);
        // Trigger input event for the textarea if other logic depends on it
        rsgFirstStopTimesInput_el_extra.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
    } else {
        rsgFirstStopTimesInput_el_extra.value = ''; // Clear if no times found
        rsgStatusMessage_el_extra.textContent = "No existing first stop times found in the main schedule for the current RSG Route, Profile(s), Destination, and First Stop (with DayOffset 0).";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
    }
}

function sru_openCancelRouteTimeSelectModal_ExtraPage(routeName) {
    if (!sruCancelRouteTimeSelectModal_el_extra || !sruCancelModalTitle_el_extra || 
        !sruCancelModalRouteInfo_el_extra || !sruCancelModalCheckboxesContainer_el_extra || 
        !sruCancelModalStatus_el_extra || !sruCancelModalSelectAllCheckbox_el_extra ||
        !sruCancelModalConfirmButton_el_extra) {
        console.error("SRU Cancel Modal: Essential modal elements are missing from the DOM.");
        alert("Error: Cancellation modal components are not fully available.");
        return;
    }

    sruCancelModalStatus_el_extra.textContent = '';
    sruCancelModalRouteInfo_el_extra.textContent = `Route: ${routeName}`;
    sruCancelModalTitle_el_extra.textContent = `Cancel Updates for Route: ${routeName}`;
    sruCancelModalCheckboxesContainer_el_extra.innerHTML = '<p style="opacity:0.7;">Loading available go-live times...</p>';
    sruCancelModalSelectAllCheckbox_el_extra.checked = false; // Reset select all

    const pendingApplyTasksForRoute = [];
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.values(scheduledRouteUpdates_extra).forEach(task => {
            if (task && task.routeName === routeName &&
                (task.taskType === 'applySchedule' || task.taskTypeDisplay === 'applySchedule') &&
                task.status === 'pending' && task.goLiveDateTime) {
                pendingApplyTasksForRoute.push(task);
            }
        });
    }

    sruCancelModalContext.routeName = routeName; // Store routeName in context

    const uniqueGoLiveTimes = [...new Set(pendingApplyTasksForRoute.map(task => task.goLiveDateTime))]
        .sort((a, b) => new Date(a).getTime() - new Date(b).getTime());

    if (uniqueGoLiveTimes.length === 0) {
        sruCancelModalCheckboxesContainer_el_extra.innerHTML = '<p style="opacity:0.7;">No pending updates with specific go-live times found for this route to cancel.</p>';
        sruCancelModalConfirmButton_el_extra.disabled = true;
        sruCancelModalSelectAllCheckbox_el_extra.disabled = true;
    } else {
        sruCancelModalCheckboxesContainer_el_extra.innerHTML = ''; // Clear "Loading..."
        uniqueGoLiveTimes.forEach((isoTime, index) => {
            const tasksAtThisTimeCount = pendingApplyTasksForRoute.filter(t => t.goLiveDateTime === isoTime).length;
            const checkboxId = `sru-cancel-cb-time-${index}`;
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'sru-cancel-time-item'; // For potential specific styling

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = 'sruCancelSelectedGoLiveTimeCheckbox_extra';
            checkbox.id = checkboxId;
            checkbox.value = isoTime;
            checkbox.dataset.taskCount = tasksAtThisTimeCount; // Store task count for info
            checkbox.addEventListener('change', () => { // Handle individual checkbox changes
                const allTimeCheckboxes = sruCancelModalCheckboxesContainer_el_extra.querySelectorAll('input[type="checkbox"]');
                const allChecked = Array.from(allTimeCheckboxes).every(cb => cb.checked);
                sruCancelModalSelectAllCheckbox_el_extra.checked = allChecked;
            });

            const label = document.createElement('label');
            label.htmlFor = checkboxId;
            label.textContent = `${new Date(isoTime).toLocaleString()} (${tasksAtThisTimeCount} task(s))`;
            
            itemDiv.appendChild(checkbox);
            itemDiv.appendChild(label);
            sruCancelModalCheckboxesContainer_el_extra.appendChild(itemDiv);
        });
        sruCancelModalConfirmButton_el_extra.disabled = false;
        sruCancelModalSelectAllCheckbox_el_extra.disabled = false;
    }
    sruCancelRouteTimeSelectModal_el_extra.style.display = 'flex';
}

function sru_closeCancelRouteTimeSelectModal_ExtraPage() {
    if (sruCancelRouteTimeSelectModal_el_extra) {
        sruCancelRouteTimeSelectModal_el_extra.style.display = 'none';
    }
    sruCancelModalContext.routeName = null; // Clear context
    if (sruCancelModalCheckboxesContainer_el_extra) sruCancelModalCheckboxesContainer_el_extra.innerHTML = ''; // Clear checkboxes
    if (sruCancelModalSelectAllCheckbox_el_extra) sruCancelModalSelectAllCheckbox_el_extra.checked = false;
}

async function sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage() {
    if (!sruCancelModalContext.routeName) {
        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = "Error: Route context is missing. Please close and retry.";
            sruCancelModalStatus_el_extra.style.color = "#e74c3c";
        }
        return;
    }
    const routeName = sruCancelModalContext.routeName;

    const selectedTimeCheckboxes = sruCancelModalCheckboxesContainer_el_extra.querySelectorAll('input[type="checkbox"]:checked');
    const selectedGoLiveTimesISO = Array.from(selectedTimeCheckboxes).map(cb => cb.value);

    if (selectedGoLiveTimesISO.length === 0) {
        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = "No go-live time(s) selected for cancellation.";
            sruCancelModalStatus_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    const tasksToCancelKeys = [];
    let totalTasksAffectedCount = 0;
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.entries(scheduledRouteUpdates_extra).forEach(([key, task]) => {
            if (task && task.routeName === routeName &&
                selectedGoLiveTimesISO.includes(task.goLiveDateTime) &&
                (task.taskType === 'applySchedule' || task.taskTypeDisplay === 'applySchedule') &&
                task.status === 'pending') {
                tasksToCancelKeys.push(key);
                totalTasksAffectedCount++;
            }
        });
    }

    if (tasksToCancelKeys.length === 0) { // Should ideally not happen if checkboxes were based on pending tasks
        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = "No matching pending updates found for the selected criteria. The list might have changed.";
            sruCancelModalStatus_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    
    const selectedTimesReadable = selectedGoLiveTimesISO.map(iso => new Date(iso).toLocaleString()).join(', ');
    const confirmMsg = `Are you sure you want to cancel all ${totalTasksAffectedCount} pending timetable update(s) for Route "${routeName}" scheduled for the following time(s):\n- ${selectedTimesReadable}\nThis action cannot be undone.`;
    
    if (!confirm(confirmMsg)) {
        if(sruCancelModalStatus_el_extra) sruCancelModalStatus_el_extra.textContent = "Cancellation aborted by user.";
        return;
    }

    if(sruCancelModalStatus_el_extra) {
        sruCancelModalStatus_el_extra.textContent = `Cancelling ${totalTasksAffectedCount} task(s) for Route "${routeName}"...`;
        sruCancelModalStatus_el_extra.style.color = "#f1c40f";
    }

    const { database, dbUpdate, dbRef } = window.firebaseOMSI;
    const updatesToRemove = {};
    tasksToCancelKeys.forEach(taskKey => {
        updatesToRemove[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`] = null;
    });

    try {
        await dbUpdate(dbRef(database), updatesToRemove);
        
        tasksToCancelKeys.forEach(taskKey => { // Update local cache
            if (scheduledRouteUpdates_extra && scheduledRouteUpdates_extra[taskKey]) {
                delete scheduledRouteUpdates_extra[taskKey];
            }
        });

        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = `Successfully cancelled ${totalTasksAffectedCount} update(s) for Route "${routeName}".`;
            sruCancelModalStatus_el_extra.style.color = "#2ecc71";
        }
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh the main list
        setTimeout(sru_closeCancelRouteTimeSelectModal_ExtraPage, 1800);

    } catch (error) {
        console.error(`Error cancelling updates for route ${routeName}:`, error);
        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = `Error cancelling updates: ${error.message}`;
            sruCancelModalStatus_el_extra.style.color = "#e74c3c";
        }
    }
}

async function handleCancelAllUpdatesForRoute_Master(routeName) {
    if (!routeName) {
        console.error("handleCancelAllUpdatesForRoute_Master called without routeName");
        return;
    }

    const pendingApplyTasksForRoute = [];
     if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.values(scheduledRouteUpdates_extra).forEach(task => {
            if (task && task.routeName === routeName &&
                (task.taskType === 'applySchedule' || task.taskTypeDisplay === 'applySchedule') &&
                task.status === 'pending' && task.goLiveDateTime) {
                pendingApplyTasksForRoute.push(task);
            }
        });
    }

    if (pendingApplyTasksForRoute.length === 0) {
        alert(`No pending timetable updates found for Route "${routeName}" to cancel.`);
        return;
    }

    const uniqueGoLiveTimesForRoute = [...new Set(pendingApplyTasksForRoute.map(task => task.goLiveDateTime))];

    if (uniqueGoLiveTimesForRoute.length === 1) {
        // Only one go-live time, directly use the execution logic for that single time.
        // We need to pass routeName and the single goLiveDateTimeISO to a function that can handle it.
        // For simplicity, we'll construct what sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage expects.
        sruCancelModalContext.routeName = routeName; // Set context for the execution function
        
        // Simulate selection of this single time to pass to the execution function
        // This is a bit of a workaround; ideally, sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage
        // would take routeName and an array of ISO times.
        // For now, we can directly call a firebase removal.

        const tasksToCancelKeys = pendingApplyTasksForRoute.map(task => {
             // Find the key for this task in scheduledRouteUpdates_extra
            for (const key in scheduledRouteUpdates_extra) {
                if (scheduledRouteUpdates_extra[key] === task) return key;
            }
            return null;
        }).filter(Boolean);


        if (tasksToCancelKeys.length > 0) {
            const confirmMsg = `Are you sure you want to cancel all ${tasksToCancelKeys.length} pending timetable update(s) for Route "${routeName}" scheduled for ${new Date(uniqueGoLiveTimesForRoute[0]).toLocaleString()}?`;
            if (!confirm(confirmMsg)) return;

            if (rsgStatusMessage_el_extra) { // Use a general status message
                 rsgStatusMessage_el_extra.textContent = `Cancelling updates for Route ${routeName}...`;
                 rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }

            const { database, dbUpdate, dbRef } = window.firebaseOMSI;
            const updatesToRemove = {};
            tasksToCancelKeys.forEach(taskKey => {
                updatesToRemove[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`] = null;
            });

            try {
                await dbUpdate(dbRef(database), updatesToRemove);
                tasksToCancelKeys.forEach(taskKey => {
                    if (scheduledRouteUpdates_extra && scheduledRouteUpdates_extra[taskKey]) {
                        delete scheduledRouteUpdates_extra[taskKey];
                    }
                });
                if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = `Successfully cancelled updates for Route "${routeName}".`;
                    rsgStatusMessage_el_extra.style.color = "#2ecc71";
                }
                loadAndDisplayScheduledUpdates_ExtraPage();
            } catch (error) {
                 if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = `Error cancelling updates for ${routeName}: ${error.message}`;
                    rsgStatusMessage_el_extra.style.color = "#e74c3c";
                }
            }
        }

    } else if (uniqueGoLiveTimesForRoute.length > 1) {
        sru_openCancelRouteTimeSelectModal_ExtraPage(routeName); // Open modal for selection
    } else {
        alert(`No specific go-live times found for pending updates on Route "${routeName}". This shouldn't happen if tasks were found.`);
    }
}

async function handleCancelAllUpdatesAllRoutes_Global() {
    console.log("// DEBUG: 1. handleCancelAllUpdatesAllRoutes_Global function CALLED."); // DEBUG: New Log

    if (!currentUser_extra) {
        console.log("// DEBUG: 2. Exiting because currentUser_extra is falsy."); // DEBUG: New Log
        if(sruCancelAllGlobalStatusMessage_el_extra) { sruCancelAllGlobalStatusMessage_el_extra.textContent = "Please log in."; sruCancelAllGlobalStatusMessage_el_extra.style.color = "#e74c3c"; }
        return;
    }
    console.log("// DEBUG: 2a. User is logged in:", currentUser_extra.email); // DEBUG: New Log

    const pendingApplyScheduleTaskKeys = [];
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        console.log("// DEBUG: 3. scheduledRouteUpdates_extra IS an object. Number of keys:", Object.keys(scheduledRouteUpdates_extra).length); // DEBUG: New Log
        // DEBUG: Log a small sample of the tasks to check their structure
        let taskSampleCount = 0;
        for (const key_debug in scheduledRouteUpdates_extra) {
            if (taskSampleCount < 2) { // Log first 2 tasks found
                 console.log(`// DEBUG: Task sample [${key_debug}]:`, JSON.parse(JSON.stringify(scheduledRouteUpdates_extra[key_debug])));
                 taskSampleCount++;
            } else {
                break;
            }
        }

        Object.entries(scheduledRouteUpdates_extra).forEach(([key, task]) => {
            // DEBUG: Log each task being checked and if it matches criteria
            const isApplyScheduleType = task && (task.taskType === 'applySchedule' || task.taskTypeDisplay === 'applySchedule');
            const isPendingStatus = task && task.status === 'pending';
            // console.log(`// DEBUG: Checking task [${key}]: taskType='${task ? task.taskType : 'N/A'}', taskTypeDisplay='${task ? task.taskTypeDisplay : 'N/A'}', status='${task ? task.status : 'N/A'}'. Match: ${isApplyScheduleType && isPendingStatus}`);

            if (isApplyScheduleType && isPendingStatus) {
                pendingApplyScheduleTaskKeys.push(key);
            }
        });
    } else {
        console.log("// DEBUG: 3. scheduledRouteUpdates_extra is NOT an object or is null."); // DEBUG: New Log
    }

    console.log("// DEBUG: 4. Number of pendingApplyScheduleTaskKeys found:", pendingApplyScheduleTaskKeys.length); // DEBUG: New Log
    if (pendingApplyScheduleTaskKeys.length > 0) {
        console.log("// DEBUG: Keys found:", pendingApplyScheduleTaskKeys.join(', ')); // DEBUG: New Log
    }


    if (pendingApplyScheduleTaskKeys.length === 0) {
        console.log("// DEBUG: 5. Exiting because no pending applySchedule tasks found."); // DEBUG: New Log
        if(sruCancelAllGlobalStatusMessage_el_extra) {
            sruCancelAllGlobalStatusMessage_el_extra.textContent = "No pending timetable updates found across all routes to cancel.";
            sruCancelAllGlobalStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    console.log("// DEBUG: 6. About to show confirmation prompt."); // DEBUG: New Log
    const userConfirmation = prompt(`EXTREME CAUTION!\nYou are about to cancel ALL ${pendingApplyScheduleTaskKeys.length} pending timetable updates for ALL routes and ALL go-live times.\nThis action CANNOT BE UNDONE.\n\nTo confirm, please type "CANCEL ALL UPDATES" in the box below:`);
    console.log("// DEBUG: 7. User confirmation input:", userConfirmation); // DEBUG: New Log


    if (userConfirmation !== "CANCEL ALL UPDATES") {
        console.log("// DEBUG: 8. Exiting because user confirmation was not 'CANCEL ALL UPDATES'."); // DEBUG: New Log
        if(sruCancelAllGlobalStatusMessage_el_extra) {
            sruCancelAllGlobalStatusMessage_el_extra.textContent = "Global cancellation aborted by user or incorrect confirmation.";
            sruCancelAllGlobalStatusMessage_el_extra.style.color = "";
        }
        return;
    }

    console.log("// DEBUG: 9. Proceeding with cancellation logic."); // DEBUG: New Log
    if(sruCancelAllGlobalStatusMessage_el_extra) {
        sruCancelAllGlobalStatusMessage_el_extra.textContent = `Processing global cancellation of ${pendingApplyScheduleTaskKeys.length} task(s)...`;
        sruCancelAllGlobalStatusMessage_el_extra.style.color = "#f1c40f";
    }
    if(sruCancelAllPendingUpdatesGloballyButton_el_extra) sruCancelAllPendingUpdatesGloballyButton_el_extra.disabled = true;

    const { database, dbUpdate, dbRef } = window.firebaseOMSI;
    const updatesToNullify = {};
    pendingApplyScheduleTaskKeys.forEach(key => {
        updatesToNullify[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${key}`] = null;
    });
    console.log("// DEBUG: 10. Firebase updatesToNullify object prepared:", updatesToNullify); // DEBUG: New Log


    try {
        await dbUpdate(dbRef(database), updatesToNullify);
        console.log("// DEBUG: 11. Firebase dbUpdate successful."); // DEBUG: New Log

        pendingApplyScheduleTaskKeys.forEach(key => {
            if (scheduledRouteUpdates_extra && scheduledRouteUpdates_extra[key]) {
                delete scheduledRouteUpdates_extra[key];
            }
        });
        
        if(sruCancelAllGlobalStatusMessage_el_extra) {
            sruCancelAllGlobalStatusMessage_el_extra.textContent = `Successfully cancelled all ${pendingApplyScheduleTaskKeys.length} pending timetable updates globally.`;
            sruCancelAllGlobalStatusMessage_el_extra.style.color = "#2ecc71";
        }
        loadAndDisplayScheduledUpdates_ExtraPage();
    } catch (error) {
        console.error("Error performing global cancellation of scheduled updates:", error);
        console.log("// DEBUG: 12. Firebase dbUpdate FAILED. Error:", error); // DEBUG: New Log
         if(sruCancelAllGlobalStatusMessage_el_extra) {
            sruCancelAllGlobalStatusMessage_el_extra.textContent = `Error during global cancellation: ${error.message}`;
            sruCancelAllGlobalStatusMessage_el_extra.style.color = "#e74c3c";
        }
    } finally {
        console.log("// DEBUG: 13. In finally block, re-enabling button."); // DEBUG: New Log
        if(sruCancelAllPendingUpdatesGloballyButton_el_extra) sruCancelAllPendingUpdatesGloballyButton_el_extra.disabled = false;
    }
}

function dpo_getCanonicalProfileString_ExtraPage(profileArray) {
    if (!Array.isArray(profileArray)) return "";
    return profileArray.map(p => String(p).trim()).sort((a,b) => a.localeCompare(b)).join(',');
}

function dpo_simulateAutoGroup_ExtraPage(selectedProfilesArray) {
    let simulatedSelections = [...selectedProfilesArray]; 
    // Assuming RSG_PROFILE_GROUPS_TO_MANAGE is suitable here
    RSG_PROFILE_GROUPS_TO_MANAGE.forEach(group => {
        const allIndividualsPresent = group.individuals.every(ind => simulatedSelections.includes(ind));
        if (allIndividualsPresent) {
            simulatedSelections = simulatedSelections.filter(p => !group.individuals.includes(p)); 
            if (!simulatedSelections.includes(group.groupProfile)) {
                simulatedSelections.push(group.groupProfile); 
            }
        }
    });
    return simulatedSelections;
}

function dpo_populateProfileCheckboxes_ExtraPage() {
    const container = document.getElementById('dpo-selectable-profiles-container-extra');
    const placeholder = document.getElementById('dpo-profiles-placeholder-extra');
    if (!container) {
        console.error("DPO Profile checkbox container not found!");
        return;
    }
    container.innerHTML = ''; // Clear previous content

    if (RSG_OPERATING_PROFILES_LIST.length === 0 && placeholder) {
        placeholder.textContent = "No profiles defined for selection.";
        container.appendChild(placeholder);
        return;
    }
    if (placeholder) placeholder.style.display = 'none';

    RSG_OPERATING_PROFILES_LIST.forEach(profileValue => {
        const wrapper = document.createElement('div');
        // Apply styles to make it look like a tile (these are from your CSS for #dpo-selectable-profiles-container-extra > div)
        wrapper.style.display = 'inline-flex';
        wrapper.style.alignItems = 'center';
        wrapper.style.backgroundColor = '#4A5568';
        wrapper.style.color = '#ecf0f1';
        wrapper.style.padding = '0.4em 0.8em';
        wrapper.style.borderRadius = '0.25rem';
        wrapper.style.border = '1px solid transparent';
        wrapper.style.cursor = 'pointer';
        wrapper.style.transition = 'border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.2s ease-in-out'; // Added background-color transition
        wrapper.style.marginRight = '0.5rem';
        wrapper.style.marginBottom = '0.5rem';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        const safeProfileId = profileValue.replace(/[^a-zA-Z0-9_-]/g, '');
        checkbox.id = `dpo-profile-cb-${safeProfileId}-extra`;
        checkbox.value = profileValue;
        checkbox.name = 'dpoOperatingProfileCheckbox_extra';
        checkbox.classList.add('dpo-profile-checkbox');
        // Apply styles from your CSS for #dpo-selectable-profiles-container-extra > div > input[type="checkbox"]
        checkbox.style.marginRight = '8px';
        checkbox.style.verticalAlign = 'middle';
        checkbox.style.height = '1em';
        checkbox.style.width = '1em';

        const label = document.createElement('label');
        label.htmlFor = checkbox.id; // Important for accessibility and default label click behavior
        label.textContent = profileValue;
        // Apply styles from your CSS for #dpo-selectable-profiles-container-extra > div > label
        label.style.fontSize = '14px';
        label.style.fontWeight = '700';
        label.style.fontFamily = "'NJFont Medium Web', -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif";
        label.style.textShadow = '0 0 1px rgba(255,255,255,0.5)';
        label.style.cursor = 'pointer'; // Label itself is also clickable
        label.style.lineHeight = '1.4';
        label.style.marginLeft = '4px'; // As per your CSS
        label.style.color = '#ecf0f1';

        // Event listener for the checkbox itself (handles logic and visual updates)
        checkbox.addEventListener('change', () => {
            const isChecked = checkbox.checked;
            wrapper.classList.toggle('selected', isChecked); // Use class for selected state if defined in CSS
            if (isChecked) {
                wrapper.style.borderColor = '#f1c40f';
                wrapper.style.boxShadow = '0 0 6px 1px #f1c40f';
                wrapper.style.backgroundColor = '#5D6D7E'; // Keep "hover" style when selected
            } else {
                wrapper.style.borderColor = 'transparent';
                wrapper.style.boxShadow = 'none';
                wrapper.style.backgroundColor = '#4A5568'; // Back to default
            }
            dpo_handleProfileSelectionChange_ExtraPage(); // Your existing logic handler
        });

        // *** NEW: Make the entire wrapper (tile) clickable ***
        wrapper.addEventListener('click', (e) => {
            // If the click was on the checkbox or the label, their native behavior
            // or the checkbox's change listener will handle it.
            // We only act if the click was on the wrapper's padding area.
            if (e.target === wrapper) { // Only toggle if the wrapper div itself was clicked
                checkbox.checked = !checkbox.checked;
                // Manually dispatch the 'change' event on the checkbox
                // to trigger its listener and update styles/logic.
                const changeEvent = new Event('change', { bubbles: true });
                checkbox.dispatchEvent(changeEvent);
            }
        });
        
        // Add hover effect to wrapper (tile)
        wrapper.addEventListener('mouseenter', () => {
            if (!checkbox.checked) { // Only change background if not selected
                 wrapper.style.backgroundColor = '#5D6D7E';
            }
        });
        wrapper.addEventListener('mouseleave', () => {
            if (!checkbox.checked) { // Revert if not selected
                wrapper.style.backgroundColor = '#4A5568';
            }
        });

        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        container.appendChild(wrapper);
    });
    dpo_updateDisabledProfileCheckboxes_ExtraPage(); // Call your existing function to update checkbox states
}

function dpo_updateDisabledProfileCheckboxes_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox'));
    const currentSelectedValues = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

    allCheckboxes.forEach(cb => {
        if (cb.checked) { // Always enable if checked
            cb.disabled = false;
            if (cb.parentElement) {
                cb.parentElement.style.opacity = 1;
                const labelForCb = cb.parentElement.querySelector('label');
                if (labelForCb) labelForCb.style.cursor = 'pointer';
            }
            return;
        }

        const potentialNextRawSelection = [...currentSelectedValues, cb.value];
        // Use DPO specific simulate and canonical functions
        const finalEffectiveSelectionAfterAutoGroup = dpo_simulateAutoGroup_ExtraPage(potentialNextRawSelection); 
        const finalEffectiveSortedString = dpo_getCanonicalProfileString_ExtraPage(finalEffectiveSelectionAfterAutoGroup);

        let canBeEnabled = false;
        // Uses DPO specific set
        if (DPO_VALID_PROFILE_COMBINATIONS_SET.has(finalEffectiveSortedString)) { 
            canBeEnabled = true;
        }

        if (!canBeEnabled) { // Check if it's a valid prefix for DPO combinations
            const prefixToTest = finalEffectiveSortedString + ","; // Important: check if adding another profile would make it valid
            for (const validCombo of DPO_VALID_PROFILE_COMBINATIONS_SET) { 
                if (validCombo.startsWith(prefixToTest)) {
                    canBeEnabled = true;
                    break;
                }
            }
        }

        // Special case: if nothing is currently selected, is this single profile (after its own potential auto-grouping) valid or a prefix?
        if (currentSelectedValues.length === 0) {
             const singleProfileItselfAfterPotentialGroup = dpo_simulateAutoGroup_ExtraPage([cb.value]);
             const singleCanonical = dpo_getCanonicalProfileString_ExtraPage(singleProfileItselfAfterPotentialGroup);
             if (DPO_VALID_PROFILE_COMBINATIONS_SET.has(singleCanonical)) {
                 canBeEnabled = true;
             } else {
                 const prefixToTestForSingle = singleCanonical + ",";
                 for (const validCombo of DPO_VALID_PROFILE_COMBINATIONS_SET) {
                     if (validCombo.startsWith(prefixToTestForSingle)) {
                         canBeEnabled = true;
                         break;
                     }
                 }
             }
        }

        cb.disabled = !canBeEnabled;
        if (cb.parentElement) {
            cb.parentElement.style.opacity = !canBeEnabled ? 0.5 : 1;
            const labelForCb = cb.parentElement.querySelector('label');
            if (labelForCb) {
                labelForCb.style.cursor = !canBeEnabled ? 'not-allowed' : 'pointer';
            }
        }
    });
}

function dpo_handleProfileSelectionChange_ExtraPage(event) {
    let currentSelectionsArray = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox:checked')).map(cb => cb.value);
    const allCheckboxes = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox'));

    // Handle auto-grouping (e.g., Mo-Fr implies individual days)
    // Assuming RSG_PROFILE_GROUPS_TO_MANAGE is suitable
    RSG_PROFILE_GROUPS_TO_MANAGE.forEach(group => {
        const groupCheckbox = allCheckboxes.find(cb => cb.value === group.groupProfile);
        if (!groupCheckbox) return; 
        currentSelectionsArray = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value); // Re-evaluate current selections
        const allIndividualsInGroupSelected = group.individuals.every(day => currentSelectionsArray.includes(day));

        if (allIndividualsInGroupSelected) {
            if (!groupCheckbox.checked) { // If individuals are all selected, but group isn't
                group.individuals.forEach(day => {
                    const cb = allCheckboxes.find(c => c.value === day);
                    if (cb && cb.checked) { cb.checked = false; }
                });
                groupCheckbox.checked = true;
            }
        } else if (groupCheckbox.checked) { // If group is selected, but not all individuals are
            // If the event target was one of the individuals and it's being unchecked, uncheck the group
            if (event && event.target && group.individuals.includes(event.target.value) && !event.target.checked) {
                 groupCheckbox.checked = false;
            }
            // Ensure individuals are unchecked if group is checked
             group.individuals.forEach(day => {
                const cb = allCheckboxes.find(c => c.value === day);
                if(cb && cb.checked) cb.checked = false;
            });
        }
    });

    // Re-get the selections after auto-grouping
    currentSelectionsArray = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox:checked')).map(cb => cb.value);
    
    // Sort for consistent display and storage
    currentSelectionsArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a); // Make sure this helper exists or adapt from RSG
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) return orderA - orderB;
        return a.localeCompare(b);
    });

    const finalSelectedProfilesString = currentSelectionsArray.join(', ');
    const displayElement = document.getElementById('dpo-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }

    dpo_updateDisabledProfileCheckboxes_ExtraPage();
}

function dpo_getSelectedOpProfilesString_ExtraPage() {
    const selectedProfiles = [];
    document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox:checked').forEach(checkbox => {
        selectedProfiles.push(checkbox.value);
    });
    // Sorts alphabetically for consistent storage, e.g., ["Fr", "MF", "Sa"] -> "Fr,MF,Sa"
    selectedProfiles.sort((a,b) => a.localeCompare(b)); 
    
    return selectedProfiles.join(', '); // MODIFIED: Joins with comma AND space
}

function dpo_setCheckedProfiles_ExtraPage(profileString) {
    const profilesToSelect = profileString ? profileString.split(',').map(p => p.trim()).filter(Boolean) : [];
    const allCheckboxes = document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox');
    allCheckboxes.forEach(checkbox => {
        checkbox.checked = profilesToSelect.includes(checkbox.value);
    });
    // After setting, trigger the logic that handles display and disabled states
    dpo_handleProfileSelectionChange_ExtraPage(null); // Pass null as no specific event triggered this
}

function dpo_clearProfileSelections_ExtraPage() {
    const allCheckboxes = document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox');
    allCheckboxes.forEach(cb => cb.checked = false);
    dpo_handleProfileSelectionChange_ExtraPage(null); // Update display and disabled states
}

async function dpo_applyOverrideToRoutes_ExtraPage() {
            if (!currentUser_extra || !overrideDateInput_el_extra || !dpoStatusMessage_el_extra || !window.firebaseOMSI) { 
                if (dpoStatusMessage_el_extra) {
                    dpoStatusMessage_el_extra.textContent = "Error: System not ready or not logged in."; 
                    dpoStatusMessage_el_extra.style.color="#e74c3c";
                }
                return; 
            }

            const selectedDate = overrideDateInput_el_extra.value;
            const profilesToApply = dpo_getSelectedOpProfilesString_ExtraPage();
            const routesToApplyTo = dpo_selectedRoutes_extra;

            if (!selectedDate) { 
                dpoStatusMessage_el_extra.textContent = "Please select a date."; 
                dpoStatusMessage_el_extra.style.color="#e74c3c"; 
                return; 
            }
            if (!profilesToApply) { 
                dpoStatusMessage_el_extra.textContent = "Please select an operating profile(s) using the checkboxes."; 
                dpoStatusMessage_el_extra.style.color="#e74c3c"; 
                return; 
            }
            if (routesToApplyTo.length === 0) {
                dpoStatusMessage_el_extra.textContent = "Please select at least one route to apply the profile to.";
                dpoStatusMessage_el_extra.style.color="#f1c40f";
                return;
            }
            
            const dateObj = new Date(selectedDate + "T00:00:00");
            if (isNaN(dateObj.getTime())) {
                dpoStatusMessage_el_extra.textContent = "Invalid date selected.";
                dpoStatusMessage_el_extra.style.color="#e74c3c";
                return;
            }

            let dateOverrides = operationalOverrides_data[selectedDate] || {};
            let changesMade = false;

            routesToApplyTo.forEach(routeName => {
                if (dateOverrides[routeName] !== profilesToApply) {
                    dateOverrides[routeName] = profilesToApply;
                    changesMade = true;
                }
            });

            if (!changesMade) {
                dpoStatusMessage_el_extra.textContent = "No changes needed for selected routes and profile. Override not applied.";
                dpoStatusMessage_el_extra.style.color="#7f8c8d";
                return;
            }

            if (!confirm(`Are you sure you want to apply "${profilesToApply}" profile(s) to Route(s): ${routesToApplyTo.join(', ')} for ${formatDateToDDMonthYYYY_ExtraPage(selectedDate)}?`)) {
                dpoStatusMessage_el_extra.textContent = "Override application cancelled by user.";
                dpoStatusMessage_el_extra.style.color="";
                return;
            }

            dpoStatusMessage_el_extra.textContent = `Applying override to selected routes...`;
            dpoStatusMessage_el_extra.style.color="#f1c40f";

            const { database, dbSet, dbRef } = window.firebaseOMSI; 
            try {
                await dbSet(dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${selectedDate}`), dateOverrides);
                
                operationalOverrides_data[selectedDate] = dateOverrides;

                dpoStatusMessage_el_extra.textContent = `Successfully applied profile(s) to ${routesToApplyTo.length} route(s) for ${formatDateToDDMonthYYYY_ExtraPage(selectedDate)}.`;
                dpoStatusMessage_el_extra.style.color="#2ecc71";
                
                updateSelectedDateInfo_ExtraPage();
                loadAndDisplayOverrides_ExtraPage();
                dpo_clearRouteSelections_ExtraPage();
                dpo_clearProfileSelections_ExtraPage();
                updateCurrentProfileDisplay_ExtraPage();

            } catch (error) {
                console.error("DPO Apply: Error applying override:", error); 
                dpoStatusMessage_el_extra.textContent = "Error applying override: " + error.message; 
                dpoStatusMessage_el_extra.style.color="#e74c3c";
            } 
        }

// --- END: Day Profile Override (DPO) Checkbox Logic ---

async function handleEditStopFromMasterList_ExtraPage(stopID, currentName, currentDirection) {
    if (!currentUser_extra) {
        alert("Please log in to edit stop details.");
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "Not logged in.";
        return;
    }

    const newStopNamePrompt = prompt(`Editing Stop: ${stopID}\nEnter new Stop Name (current: "${currentName || ''}"):`, currentName || '');
    if (newStopNamePrompt === null) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `Edit cancelled for stop ${stopID}.`;
        return;
    }

    const newDirectionPrompt = prompt(`Editing Stop: ${stopID}\nEnter new "Towards" text (current: "${currentDirection || ''}"):`, currentDirection || '');
    if (newDirectionPrompt === null) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `Edit cancelled for stop ${stopID}.`;
        return;
    }

    const trimmedNewStopName = newStopNamePrompt.trim();
    const trimmedNewDirection = newDirectionPrompt.trim();
    let definitionChanged = false;
    const stopIDUpper = stopID.toUpperCase();

    // 1. Update the master definition in allDefinedStops_data (local cache)
    if (allDefinedStops_data && typeof allDefinedStops_data === 'object' && allDefinedStops_data[stopIDUpper]) {
        if (allDefinedStops_data[stopIDUpper].stopName !== trimmedNewStopName) {
            allDefinedStops_data[stopIDUpper].stopName = trimmedNewStopName;
            definitionChanged = true;
        }
        if (allDefinedStops_data[stopIDUpper].direction !== trimmedNewDirection) {
            allDefinedStops_data[stopIDUpper].direction = trimmedNewDirection;
            definitionChanged = true;
        }
    } else {
        console.error(`Stop definition for ${stopID} not found in allDefinedStops_data during edit. This should not happen if list is correctly populated.`);
        if (masterStopListStatus_el_extra) {
            masterStopListStatus_el_extra.textContent = `Error: Master definition for stop ${stopID} not found. Edit failed.`;
            masterStopListStatus_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    // 2. Update occurrences in currentWorkingSchedule_extra (local cache for live schedules)
    let updatedScheduleEntryCount = 0;
    let scheduleEntriesModified = false;
    if (Array.isArray(currentWorkingSchedule_extra)) {
        currentWorkingSchedule_extra.forEach(entry => {
            if (entry.stopID && entry.stopID.toUpperCase() === stopIDUpper) {
                let entryModifiedThisIteration = false;
                if (entry.stopName !== trimmedNewStopName) {
                    entry.stopName = trimmedNewStopName;
                    entryModifiedThisIteration = true;
                }
                if (entry.direction !== trimmedNewDirection) {
                    entry.direction = trimmedNewDirection;
                    entryModifiedThisIteration = true;
                }
                if (entryModifiedThisIteration) {
                    updatedScheduleEntryCount++;
                    scheduleEntriesModified = true;
                }
            }
        });
    }

    if (!definitionChanged && !scheduleEntriesModified) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `No changes made to Stop ID "${stopID}".`;
        return;
    }

    if (masterStopListStatus_el_extra) {
        masterStopListStatus_el_extra.textContent = `Updating entries for stop ${stopID}...`;
        masterStopListStatus_el_extra.style.color = "#f1c40f";
    }

    try {
        // Save the updated master definition list to Firebase
        if (definitionChanged && typeof saveAllDefinedStopsToFirebase_ExtraPage === 'function') {
            await saveAllDefinedStopsToFirebase_ExtraPage();
        }

        // Rebuild and save the live schedule if its entries or related definitions changed
        if (scheduleEntriesModified || definitionChanged) {
            if (typeof rebuildAndSaveEntireScheduleToFirebase_ExtraPage === 'function') {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
            } else {
                console.error("rebuildAndSaveEntireScheduleToFirebase_ExtraPage is not defined!");
                throw new Error("Cannot save schedule, critical function missing.");
            }
        }
        
        if (masterStopListStatus_el_extra) {
            let message = `Stop ID "${stopID}" updated.`;
            if (definitionChanged) message += ` Master definition changed.`;
            if (scheduleEntriesModified) message += ` ${updatedScheduleEntryCount} live schedule entries affected.`;
            masterStopListStatus_el_extra.textContent = message;
            masterStopListStatus_el_extra.style.color = "#2ecc71";
        }
        
        if (typeof renderUIDependentElements_ExtraPage === 'function') {
            renderUIDependentElements_ExtraPage(); // Refresh UI
        }

    } catch (error) {
        console.error(`Error saving Stop ID ${stopID} changes to Firebase:`, error);
        if (masterStopListStatus_el_extra) {
            masterStopListStatus_el_extra.textContent = `Error saving changes for stop ${stopID}: ${error.message}`;
            masterStopListStatus_el_extra.style.color = "#e74c3c";
        }
        // Consider reloading data on critical error to resync
        if (typeof loadInitialData_ExtraPage === 'function') {
             alert("A critical error occurred while saving stop edits. Attempting to reload all data. Please verify changes.");
             await loadInitialData_ExtraPage();
        }
    }
}

async function handleApplyScheduledRouteBatch_ExtraPage(tasksInBatch) {
    if (!currentUser_extra) {
        alert("Please log in to apply batch updates.");
        return;
    }
    if (!tasksInBatch || tasksInBatch.length === 0) {
        alert("No tasks provided for batch application.");
        return;
    }

    const representativeTask = tasksInBatch[0]; // Assuming all tasks in batch are for the same route & time
    const targetRouteName = representativeTask.routeName.toUpperCase();
    const goLiveDateTimeForDisplay = new Date(representativeTask.goLiveDateTime).toLocaleString();

    let allNewEntriesForRoute = [];
    let involvedProfiles = new Set();
    let involvedDestinations = new Set();
    let taskKeysInBatch = []; // To update status of all processed tasks

    tasksInBatch.forEach(task => {
        // Ensure we only aggregate 'applySchedule' tasks for the correct route
        if ((task.taskTypeDisplay === 'applySchedule' || task.taskType === 'applySchedule') && task.routeName.toUpperCase() === targetRouteName) {
            if (task.scheduledEntries && task.scheduledEntries.length > 0) {
                // Deep copy entries to avoid issues if the same task object is somehow reused
                allNewEntriesForRoute.push(...JSON.parse(JSON.stringify(task.scheduledEntries)));
                involvedProfiles.add(task.operatingProfile);
                involvedDestinations.add(task.destinationName);
            }
            taskKeysInBatch.push(task.key);
        }
    });

    if (allNewEntriesForRoute.length === 0) {
        alert(`No actual schedule entries found within the selected batch for Route "${targetRouteName}". Cannot apply.`);
        return;
    }

    const profileList = Array.from(involvedProfiles).join(', ') || "N/A";
    const destList = Array.from(involvedDestinations).join(', ') || "N/A";

    const confirmMessage = `Apply BATCH update for Route: ${targetRouteName}\n` +
                         `Go-Live: ${goLiveDateTimeForDisplay}\n\n` +
                         `This batch includes ${tasksInBatch.length} update(s) which will define the following for this route:\n` +
                         `Operating Profile(s): ${profileList}\n` +
                         `Destination(s): ${destList}\n\n` +
                         `WARNING: This will DELETE ALL existing schedules for the ENTIRE Route "${targetRouteName}" (across all its current profiles and destinations).\n` +
                         `Then, ${allNewEntriesForRoute.length} new entries from this batch will be added, forming the new complete schedule for this route.\n\n` +
                         `Proceed with wiping the whole route and applying this batch?`;

    if (!confirm(confirmMessage)) {
        alert("Batch application cancelled by user.");
        return;
    }

    if (rsgStatusMessage_el_extra) { // Use a general status message element if available
        rsgStatusMessage_el_extra.textContent = `Processing batch for Route ${targetRouteName}... This may take a moment.`;
        rsgStatusMessage_el_extra.style.color = "#3498db";
    }

    const { database, dbUpdate, dbRef } = window.firebaseOMSI;
    let removedCount = 0;

    // 1. Filter out ALL existing entries for this targetRouteName from the local working schedule
    currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
        const matchesRouteOnly = entry.lineName && entry.lineName.toUpperCase() === targetRouteName;
        if (matchesRouteOnly) {
            removedCount++;
            return false;
        }
        return true;
    });
    console.log(`Batch Apply: Removed <span class="math-inline">\{removedCount\} existing entries for Route "</span>{targetRouteName}".`);

    // 2. Add all new entries from the batch, ensuring unique internalIds
    const entriesToAddWithUniqueIds = allNewEntriesForRoute.map((e, idx) => ({
        ...e,
        internalId: e.internalId || `<span class="math-inline">\{e\.stopID\}\_</span>{e.lineName}_${(e.scheduledTime||"0000").replace(':','')}_batchApply_${Date.now()}_${idx}`
    }));
    currentWorkingSchedule_extra.push(...entriesToAddWithUniqueIds);
    console.log(`Batch Apply: Added <span class="math-inline">\{entriesToAddWithUniqueIds\.length\} new entries for Route "</span>{targetRouteName}".`);

    try {
        // 3. Rebuild and save the entire schedule to Firebase.
        await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
        console.log(`Batch Apply: Main schedule rebuilt and saved to Firebase for Route "${targetRouteName}".`);

        // 4. Update the status of all processed scheduled items in Firebase
        const updatesToFirebaseStatus = {};
        const appliedAtTimestamp = new Date().toISOString();
        const appliedByEmail = currentUser_extra ? currentUser_extra.email : "system (batch)";

        taskKeysInBatch.forEach(taskKey => {
            // This assumes all tasks in the batch were 'applySchedule' tasks from FB_PATH_SCHEDULED_ROUTE_UPDATES
            updatesToFirebaseStatus[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/status`] = 'applied (batch)';
            updatesToFirebaseStatus[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/appliedAt`] = appliedAtTimestamp;
            updatesToFirebaseStatus[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/appliedBy`] = appliedByEmail;
        });

        await dbUpdate(dbRef(database), updatesToFirebaseStatus);
        console.log("DEBUG: Task keys being processed:", JSON.stringify(taskKeysInBatch));
console.log("DEBUG: Data being sent to Firebase for status update:", JSON.stringify(updatesToFirebaseStatus));

        // Refresh UI
        loadAndDisplayScheduledUpdates_ExtraPage(); 
        renderUIDependentElements_ExtraPage(); 

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Batch update for Route ${targetRouteName} applied successfully. Live schedule updated.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
            setTimeout(() => { if (rsgStatusMessage_el_extra.textContent && rsgStatusMessage_el_extra.textContent.includes(`Batch update for Route ${targetRouteName}`)) rsgStatusMessage_el_extra.textContent = ''; }, 7000);
        } else {
            alert(`Batch update for Route ${targetRouteName} applied successfully. Live schedule updated.`);
        }

    } catch (error) {
        console.error("Error applying scheduled batch update:", error);
        alert(`Error applying batch update for Route "${targetRouteName}": ${error.message}. The live schedule may be in an inconsistent state. Review carefully.`);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error applying batch for Route ${targetRouteName}: ${error.message}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // Attempt to mark tasks as 'error' in Firebase
        const errorUpdates = {};
        taskKeysInBatch.forEach(taskKey => {
            errorUpdates[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/status`] = 'error';
            errorUpdates[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/lastError`] = `Batch Apply Error: ${error.message}`;
        });
        await dbUpdate(dbRef(database), errorUpdates).catch(err => console.error("Failed to mark batch tasks as error:", err));
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh to show error state
    }
}

function checkAndDisplayDueUpdatesNotification_ExtraPage() {
    const banner = document.getElementById('global-notification-banner');
    if (!banner || !currentUser_extra) { // Only show if logged in and banner element exists
        if (banner) banner.style.display = 'none'; // Ensure banner is hidden if no user
        return;
    }

    let dueTasksDetails = []; // To store info about due tasks for the banner message
    const now = new Date().getTime();

    console.log("Banner Check: Function called at", new Date().toLocaleString());
    console.log("Banner Check: Current epoch time (now):", now);

    // Check 'applySchedule' tasks (typically from RSG - timetable updates)
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.values(scheduledRouteUpdates_extra).forEach(task => {
            if (task && task.status === 'pending' && task.goLiveDateTime) {
                const goLiveTimeEpoch = new Date(task.goLiveDateTime).getTime();
                // console.log(`Banner Check (Update Task ${task.key || 'N/A'}): Status: ${task.status}, GoLiveISO: ${task.goLiveDateTime}, GoLiveEpoch: ${goLiveTimeEpoch}, Due: ${goLiveTimeEpoch <= now}`);
                if (goLiveTimeEpoch <= now) {
                    dueTasksDetails.push({
                        type: 'Timetable Update',
                        name: `Route ${task.routeName || 'N/A'} (for P: ${task.operatingProfile || 'N/A'} to D: ${task.destinationName || 'N/A'})`,
                        key: task.key,
                        goLive: new Date(task.goLiveDateTime).toLocaleString()
                    });
                }
            }
        });
    }

    // Check 'deleteEntireRoute' tasks
    if (typeof scheduledRouteDeletions_extra === 'object' && scheduledRouteDeletions_extra !== null) {
        Object.values(scheduledRouteDeletions_extra).forEach(task => {
            if (task && task.status === 'pending' && task.goLiveDateTime) {
                const goLiveTimeEpoch = new Date(task.goLiveDateTime).getTime();
                // console.log(`Banner Check (Delete Task ${task.key || 'N/A'}): Status: ${task.status}, GoLiveISO: ${task.goLiveDateTime}, GoLiveEpoch: ${goLiveTimeEpoch}, Due: ${goLiveTimeEpoch <= now}`);
                if (goLiveTimeEpoch <= now) {
                    dueTasksDetails.push({
                        type: 'Route Deletion',
                        name: `Route ${task.routeName || 'N/A'}`,
                        key: task.key,
                        goLive: new Date(task.goLiveDateTime).toLocaleString()
                    });
                }
            }
        });
    }

    console.log("Banner Check: Total dueTasksDetails found:", dueTasksDetails.length, JSON.parse(JSON.stringify(dueTasksDetails)));

    if (dueTasksDetails.length > 0) {
        // Sort by go-live time, earliest first, for display consistency if you show details
        dueTasksDetails.sort((a,b) => new Date(a.goLive).getTime() - new Date(b.goLive).getTime());
        
        let message = `${dueTasksDetails.length} scheduled task(s) are now due or overdue.`;
        // Example: Show details of the first due task in the console for easier debugging
        if (dueTasksDetails[0]) {
           console.log("Banner Check: First due task details:", dueTasksDetails[0]);
        }
        
        banner.innerHTML = `${message} 
            <button id="view-due-tasks-button" class="button small-action neutral" style="margin-left:15px; background-color: #ecf0f1; color: #2c3e50; padding: 0.3em 0.6em; font-size: 0.85em;">
                View & Manage Tasks
            </button>`;
        banner.style.backgroundColor = '#27ae60'; // Green for due tasks
        banner.style.display = 'block';

        const viewButton = document.getElementById('view-due-tasks-button');
        if (viewButton) {
            // Ensure only one listener is attached, or handle re-attachment carefully if innerHTML is used often
            if (!viewButton.dataset.listenerAttached) {
                viewButton.addEventListener('click', () => {
                    showExtraPageSection('scheduled-route-updates-section_extra'); // Navigate to the tasks page
                    // You might choose to hide the banner after click or let it persist
                    // banner.style.display = 'none'; 
                });
                viewButton.dataset.listenerAttached = 'true';
            }
        }
    } else {
        banner.style.display = 'none';
    }
}

// Function to handle confirming and saving the scheduled deletion
async function srd_confirmAndScheduleDeletion_ExtraPage() {
    if (!currentUser_extra || !window.firebaseOMSI || !window.firebaseOMSI.database || !window.firebaseOMSI.auth) { // Added auth check here
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Not logged in or Firebase (database/auth) not available.";
            srdStatusMessage_el_extra.style.color = "#e74c3c";
        }
        console.error("SRD Save: currentUser_extra, window.firebaseOMSI, or its database/auth components are missing.");
        return;
    }

    const routeName = srdRouteNameInput_el_extra.value.trim() || srdRouteNameSelect_el_extra.value;
    const goLiveDateTimeValue = srdGoLiveDateTimeInput_el_extra.value;

    if (!routeName) {
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Please select or enter a route name to schedule for deletion.";
            srdStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    if (!goLiveDateTimeValue) {
        // ... (error handling for goLiveDateTimeValue) ...
        return;
    }

    const goLiveDateObj = new Date(goLiveDateTimeValue);
    if (isNaN(goLiveDateObj.getTime())) {
        // ... (error handling for invalid date) ...
        return;
    }

    if (goLiveDateObj <= new Date()) {
        // ... (error handling for past date) ...
        return;
    }

    // Destructure auth here to ensure it's in scope for this function
    const { database, dbSet, dbRef, auth } = window.firebaseOMSI;

    // Crucial check for UID
    console.log("SRD Save: Current User from auth object:", auth.currentUser ? auth.currentUser.uid : "No user from auth object");
    console.log("SRD Save: Current User from currentUser_extra variable:", currentUser_extra ? currentUser_extra.uid : "No user from currentUser_extra");
    console.log("SRD Save: Expected Admin UID:", 'PBVTn1GvcAfIZWNLzuP1brUtJDu1');

    // Use the UID from the auth object directly for the most reliable check
    if (!auth.currentUser || auth.currentUser.uid !== 'PBVTn1GvcAfIZWNLzuP1brUtJDu1') {
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Permission Denied: You are not authorized to perform this action.";
            srdStatusMessage_el_extra.style.color = "#e74c3c";
        }
        console.error("SRD Save: Permission Denied. UID mismatch or no authenticated user. Actual UID:", auth.currentUser ? auth.currentUser.uid : "null");
        return; // Stop if not the admin user
    }


    if (!confirm(`Are you sure you want to schedule the DELETION of all data for route "${routeName}" to occur on ${goLiveDateObj.toLocaleString()}? This action, once processed, cannot be easily undone.`)) {
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Scheduled deletion cancelled by user.";
            srdStatusMessage_el_extra.style.color = "";
        }
        return;
    }

    const deletionTask = {
        taskType: "deleteEntireRoute",
        routeName: routeName,
        goLiveDateTime: goLiveDateObj.toISOString(),
        scheduledAt: new Date().toISOString(),
        status: "pending",
        userEmail: currentUser_extra.email // currentUser_extra should be the admin user here
    };

    if (srdStatusMessage_el_extra) {
        srdStatusMessage_el_extra.textContent = `Scheduling deletion for route "${routeName}"...`;
        srdStatusMessage_el_extra.style.color = "#3498db";
    }

    try {
        const deletionTaskKey = `delSched_${Date.now()}_${sanitizeFirebaseKey(routeName)}`;
        await dbSet(dbRef(database, `${FB_PATH_SCHEDULED_DELETIONS}/${deletionTaskKey}`), deletionTask);

        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = `Deletion for route "${routeName}" successfully scheduled for ${goLiveDateObj.toLocaleString()}. It will appear in the 'Scheduled Tasks' list.`;
            srdStatusMessage_el_extra.style.color = "#2ecc71";
        }
        if(srdRouteNameInput_el_extra) srdRouteNameInput_el_extra.value = '';
        if(srdRouteNameSelect_el_extra) srdRouteNameSelect_el_extra.value = '';
        if(srdGoLiveDateTimeInput_el_extra) srdGoLiveDateTimeInput_el_extra.value = '';

    } catch (error) {
        console.error("Error scheduling route deletion to Firebase:", error); // This will show the permission denied
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Error scheduling deletion: " + error.message;
            srdStatusMessage_el_extra.style.color = "#e74c3c";
        }
    }
}

        function getYYYYMMDD_ExtraPage(dateSource) { const d = dateSource ? new Date(dateSource) : new Date(); const year = d.getFullYear(); const month = String(d.getMonth() + 1).padStart(2, '0'); const day = String(d.getDate()).padStart(2, '0'); return `${year}-${month}-${day}`; }
        function formatDateToDDMonthYYYY_ExtraPage(dateStringYYYYMMDD) { if (!dateStringYYYYMMDD || !/^\d{4}-\d{2}-\d{2}$/.test(dateStringYYYYMMDD)) return "Invalid Date"; const [year, month, day] = dateStringYYYYMMDD.split('-'); const dateObj = new Date(year, month - 1, day); const options = { day: '2-digit', month: 'long', year: 'numeric' }; return dateObj.toLocaleDateString('en-GB', options); }
        function getUniqueStopsFromSchedule_ExtraPage() { if (!currentWorkingSchedule_extra || currentWorkingSchedule_extra.length === 0) return []; const stopsMap = new Map(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID && !stopsMap.has(entry.stopID.toUpperCase())) { stopsMap.set(entry.stopID.toUpperCase(), { stopID: entry.stopID, stopName: entry.stopName || "Unknown Name", direction: entry.direction || "No Direction" }); } }); return Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase())); }
        function parseLineName_ExtraPage(lineNameStr) { const name = String(lineNameStr || "").toUpperCase().trim(); const numericPrefixRegex = new RegExp(/^(\d+)([A-Z]*)$/); const alphaNumericRegex = new RegExp(/^([A-Z]+)(\d+)?([A-Z]*)$/); const numericPrefixMatch = name.match(numericPrefixRegex); if (numericPrefixMatch) return { type: 'numeric', number: parseInt(numericPrefixMatch[1], 10), suffix: numericPrefixMatch[2] || '', original: name }; const alphaNumericMatch = name.match(alphaNumericRegex); if (alphaNumericMatch) return { type: 'alpha', prefix: alphaNumericMatch[1], number: alphaNumericMatch[2] ? parseInt(alphaNumericMatch[2], 10) : null, suffix: alphaNumericMatch[3] || '', original: name }; return { type: 'other', original: name }; }
        
	function compareLineNames_ExtraPage(lineAStr, lineBStr) { const parsedA = parseLineName_ExtraPage(lineAStr); const parsedB = parseLineName_ExtraPage(lineBStr); if (parsedA.type === 'numeric' && parsedB.type === 'alpha') return -1; if (parsedA.type === 'alpha' && parsedB.type === 'numeric') return 1; if (parsedA.type === 'numeric' && parsedB.type === 'numeric') { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type === 'alpha' && parsedB.type === 'alpha') { const prefixCompare = parsedA.prefix.localeCompare(parsedB.prefix); if (prefixCompare !== 0) return prefixCompare; if (parsedA.number === null && parsedB.number !== null) return -1; if (parsedA.number !== null && parsedB.number === null) return 1; if (parsedA.number !== null && parsedB.number !== null) { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; } return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type !== 'other' && parsedB.type === 'other') return -1; if (parsedA.type === 'other' && parsedB.type !== 'other') return 1; return (parsedA.original || "").localeCompare(parsedB.original || ""); }
        const DEFAULT_ROUTE_COLOUR_TOOLS_extra = "#73809C"; // Default fallback color for routes
        const NIGHT_BUS_BLUE_COLOR_extra = "#4CDBE6"; // Explicit color for N-Routes and 24hr services if no custom override
        const initialRouteColourMapForTools_extra = {}; // This can remain empty if all custom colors are Firebase-driven

        function getRouteTileColour_ExtraPage(lineName, stopID = null) {
    const upName = String(lineName || "").toUpperCase();
    let color;

    // Check stop-specific colors
    if (stopID && stopSpecificRouteColours_extra[stopID.toUpperCase()] &&
        typeof stopSpecificRouteColours_extra[stopID.toUpperCase()][upName] === 'string' &&
        stopSpecificRouteColours_extra[stopID.toUpperCase()][upName].startsWith('#')) {
        color = stopSpecificRouteColours_extra[stopID.toUpperCase()][upName];
    }
    // Check global custom colors if not found above
    else if (globalCustomRouteColours_extra[upName] &&
               typeof globalCustomRouteColours_extra[upName] === 'string' &&
               globalCustomRouteColours_extra[upName].startsWith('#')) {
        color = globalCustomRouteColours_extra[upName];
    }
    // Check initial (hardcoded) map - though yours is empty
    else if (initialRouteColourMapForTools_extra[upName] &&
               typeof initialRouteColourMapForTools_extra[upName] === 'string' &&
               initialRouteColourMapForTools_extra[upName].startsWith('#')) {
        color = initialRouteColourMapForTools_extra[upName];
    }
    // Check specific prefixes like 'N' or 'SL'
    else if (upName.startsWith("N")) {
        color = (globalCustomRouteColours_extra["NIGHT_DEFAULT"] && typeof globalCustomRouteColours_extra["NIGHT_DEFAULT"] === 'string' && globalCustomRouteColours_extra["NIGHT_DEFAULT"].startsWith('#'))
                ? globalCustomRouteColours_extra["NIGHT_DEFAULT"]
                : NIGHT_BUS_BLUE_COLOR_extra; // NIGHT_BUS_BLUE_COLOR_extra should be a valid hex
    } else if (upName.startsWith("SL")) {
        color = (globalCustomRouteColours_extra["SL_DEFAULT"] && typeof globalCustomRouteColours_extra["SL_DEFAULT"] === 'string' && globalCustomRouteColours_extra["SL_DEFAULT"].startsWith('#'))
                ? globalCustomRouteColours_extra["SL_DEFAULT"]
                : "#D32F2F"; // Ensure this default is valid
    }

    // Validate the determined color and provide a final fallback
    if (typeof color === 'string' && color.startsWith('#') && (color.length === 7 || color.length === 4)) {
        return color.toUpperCase();
    }

    // Fallback if no valid color string found from any source
    // console.warn(`getRouteTileColour_ExtraPage: No valid color found for lineName "<span class="math-inline">\{lineName\}", stopID "</span>{stopID || 'N/A'}". Defaulting to ${DEFAULT_ROUTE_COLOUR_TOOLS_extra}.`);
    return DEFAULT_ROUTE_COLOUR_TOOLS_extra.toUpperCase(); // Ensure DEFAULT_ROUTE_COLOUR_TOOLS_extra is valid
}

        function isSchoolHolidayPeriod_ExtraPage(dateObjectForCell) { // dateObjectForCell is local time, e.g., new Date(year, month, day)
    if (!schoolHolidayDateRanges_extra || schoolHolidayDateRanges_extra.length === 0) {
        return false;
    }

    // Normalize the calendar cell's date to midnight local time to represent the whole day
    const cellDateNormalized = new Date(dateObjectForCell.getFullYear(), dateObjectForCell.getMonth(), dateObjectForCell.getDate());
    const cellTime = cellDateNormalized.getTime();

    for (const range of schoolHolidayDateRanges_extra) {
        try {
            // Parse start date string as local midnight
            const startDateParts = range.start.split('-'); // "YYYY-MM-DD"
            const rangeStartDate = new Date(
                parseInt(startDateParts[0]),
                parseInt(startDateParts[1]) - 1, // JS months are 0-11
                parseInt(startDateParts[2])
            );
            const rangeStartTime = rangeStartDate.getTime();

            // Parse end date string as local midnight
            const endDateParts = range.end.split('-'); // "YYYY-MM-DD"
            const rangeEndDate = new Date(
                parseInt(endDateParts[0]),
                parseInt(endDateParts[1]) - 1, // JS months are 0-11
                parseInt(endDateParts[2])
            );
            const rangeEndTime = rangeEndDate.getTime();

            // Check if the cell's date is within the inclusive start and end dates
            if (cellTime >= rangeStartTime && cellTime <= rangeEndTime) {
                return true;
            }
        } catch (e) {
            console.error("Invalid date encountered in schoolHolidayDateRanges_extra during check:", range, e);
        }
    }
    return false;
}
      
  function getOperatingCodesForDate_ExtraPage(dateObject, routeName = null) {
        const n = dateObject;
        const dOW = n.getDay();
        const todayDateString = `${n.getFullYear()}-${String(n.getMonth() + 1).padStart(2, '0')}-${String(n.getDate()).padStart(2, '0')}`;
        let potentialDateCodes = new Set();
        let isBankHolidayToday = false;

        if (routeName && operationalOverrides_data && operationalOverrides_data[todayDateString] && operationalOverrides_data[todayDateString][routeName]) {
            const routeOverrideProfile = operationalOverrides_data[todayDateString][routeName];
            return routeOverrideProfile.split(',').map(p => p.trim()).filter(Boolean);
        }

        if (ukBankHolidaysData_extra && ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(todayDateString)) {
            const holidayTitle = ukBankHolidaysData_extra.titles[todayDateString] || "";
            isBankHolidayToday = true;
            if (holidayTitle.toLowerCase().includes("good friday")) {
                potentialDateCodes.add("Sa");
            } else {
                potentialDateCodes.add("Su");
            }
        }

        if (!isBankHolidayToday) {
            const isSchHol = isSchoolHolidayPeriod_ExtraPage(n);
            const schoolSuffix = isSchHol ? "NSD" : "Sch";
            let dayCode = "";
            switch (dOW) {
                case 0: dayCode = "Su"; break;
                case 1: dayCode = "Mo"; break;
                case 2: dayCode = "Tu"; break;
                case 3: dayCode = "We"; break;
                case 4: dayCode = "Th"; break;
                case 5: dayCode = "Fr"; break;
                case 6: dayCode = "Sa"; break;
            }
            potentialDateCodes.add(dayCode);
            if (dOW >= 1 && dOW <= 5) {
                potentialDateCodes.add(dayCode + schoolSuffix);
                potentialDateCodes.add("MF" + schoolSuffix);
                potentialDateCodes.add("MF");
            }
        }
        
        const finalFilteredCodes = Array.from(potentialDateCodes).filter(code => 
            typeof RSG_OPERATING_PROFILES_LIST !== 'undefined' && RSG_OPERATING_PROFILES_LIST.includes(code)
        );
        
        return finalFilteredCodes;
    }

async function updateCurrentProfileDisplay_ExtraPage() {
            const now = new Date();
            const todayDateString = getYYYYMMDD_ExtraPage(now);
            let displayHtml = "";
            let displayLabel = "Today's Operating Profile:";

            // Get the general auto-determined profiles for today (without considering specific routes yet)
            const autoDeterminedGeneralProfiles = getOperatingCodesForDate_ExtraPage(now);
            const autoDeterminedGeneralProfileString = autoDeterminedGeneralProfiles.length > 0 ? autoDeterminedGeneralProfiles.join(', ') : 'N/A';

            // Check for bank holiday title for display label
            let isBankHolidayToday = false;
            if (ukBankHolidaysData_extra && ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(todayDateString)) {
                isBankHolidayToday = true;
            }

            if (isBankHolidayToday) {
                const holidayTitle = ukBankHolidaysData_extra.titles[todayDateString] || "Bank Holiday";
                displayLabel = `${toTitleCase_display(holidayTitle)}:`;
            } else {
                displayLabel = `Today's Operating Profile:`;
            }

            // Map to store {profileString: Set of routeNames} for all routes that are NOT following the general default
            const customProfileRoutes = new Map();
            let allRoutesWithSchedules = new Set(); // All routes that have schedule entries

            // Populate allRoutesWithSchedules from currentWorkingSchedule_extra
            currentWorkingSchedule_extra.forEach(entry => {
                if (entry.lineName) {
                    allRoutesWithSchedules.add(entry.lineName);
                }
            });

            // Iterate through each unique route to get its specific effective profile for today
            allRoutesWithSchedules.forEach(routeName => {
                // Get the effective profiles for this specific route on this specific date
                const effectiveProfilesForRoute = getOperatingCodesForDate_ExtraPage(now, routeName);
                const effectiveProfileString = effectiveProfilesForRoute.join(', ');

                // If this route's effective profile is different from the general default
                const routeSpecificOverrideInFirebase = operationalOverrides_data[todayDateString] && operationalOverrides_data[todayDateString][routeName] ? true : false;
                
                if (routeSpecificOverrideInFirebase || (effectiveProfileString !== autoDeterminedGeneralProfileString && effectiveProfileString !== 'N/A')) {
                    customProfileRoutes.set(effectiveProfileString, (customProfileRoutes.get(effectiveProfileString) || new Set()).add(routeName));
                }
            });

            // Determine display content
            if (customProfileRoutes.size > 0) {
                displayHtml = `${displayLabel}<br>`;
                let customRouteLines = [];

                // Sort custom profiles for consistent display order
                const sortedCustomProfileStrings = Array.from(customProfileRoutes.keys()).sort();

                sortedCustomProfileStrings.forEach(profileString => {
                    const routesForThisProfile = Array.from(customProfileRoutes.get(profileString)).sort(); // Sort routes alphabetically
                    customRouteLines.push(`${routesForThisProfile.join(', ')}: <strong style="color:#f1c40f;">${profileString}</strong>`);
                });

                // Removed `font-size:0.85em;` from this span
                displayHtml += `<span style="margin-left:1em;">${customRouteLines.join('<br><span style="margin-left:1em;">')}</span>`;

                // Add a final disclaimer about routes not explicitly listed if needed
                let totalCustomRoutesCount = 0;
                customProfileRoutes.forEach(routesSet => totalCustomRoutesCount += routesSet.size);

                if (allRoutesWithSchedules.size > totalCustomRoutesCount) {
                    // Removed `font-size:0.85em;` and `display:block; margin-top:0.7em;`
                    displayHtml += `<br><span style="margin-left:1em; opacity:0.8;">All Other Routes: ${autoDeterminedGeneralProfileString}</span>`;
                }
            } else {
                // Simple display if no custom profiles or all routes follow the general profile
                displayHtml = `${displayLabel} ${autoDeterminedGeneralProfileString}`;
            }

            if (currentProfileDisplayElement_el) {
                currentProfileDisplayElement_el.innerHTML = displayHtml;
            }
        }

        // In omsi_tools_extra.html, inside loadAndDisplayOverrides_ExtraPage
async function loadAndDisplayOverrides_ExtraPage() {
    const activeOverridesListElement = document.getElementById('activeOverridesList_extra');
    const overridesHeadingElement = document.getElementById('dpo-active-overrides-title'); 

    if (!activeOverridesListElement || !window.firebaseOMSI) {
        if(activeOverridesListElement) activeOverridesListElement.innerHTML = '<p>Error: System dependencies missing.</p>';
        return;
    }
    activeOverridesListElement.innerHTML = '<p>Loading all active overrides...</p>';
    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;

    try {
        const snapshot = await dbGet(dbChild(dbRef(database), FB_PATH_OPERATIONAL_OVERRIDES));
        let html = "";
        const today = new Date(); // Current date is Wednesday, June 4, 2025
        today.setHours(0, 0, 0, 0); 

        const currentYear = today.getFullYear(); // 2025
        
        // --- MODIFIED SECTION ---
        const fixedDaysAhead = 365; // Always show 365 days
        const targetYearForDisplay = currentYear + 1; // It will span into the next year if 365 days is used.
        // --- END MODIFIED SECTION ---

        if (overridesHeadingElement) {
            // Updated text: "All Active Overrides Within The Next 365 Days"
            overridesHeadingElement.textContent = `All Active Overrides Within The Next 365 Days`;
        }

        const allOverrides = snapshot.exists() ? snapshot.val() : {};
        const relevantOverrides = [];
        
        // Calculate the actual future cutoff date for filtering overrides based on 365 days from today
        const actualFutureCutoffDate = new Date(today);
        actualFutureCutoffDate.setDate(today.getDate() + fixedDaysAhead);


        for (const dateKey in allOverrides) {
            if (Object.hasOwnProperty.call(allOverrides, dateKey) && /^\d{4}-\d{2}-\d{2}$/.test(dateKey)) {
                const overrideDate = new Date(dateKey + "T00:00:00"); 
                
                // Filter overrides to only show those within the next fixedDaysAhead days from today
                if (overrideDate >= today && overrideDate <= actualFutureCutoffDate) { 
                    const routeOverridesForDate = allOverrides[dateKey];
                    if (routeOverridesForDate && typeof routeOverridesForDate === 'object' && Object.keys(routeOverridesForDate).length > 0) {
                        for (const routeName in routeOverridesForDate) {
                            if (Object.hasOwnProperty.call(routeOverridesForDate, routeName)) {
                                relevantOverrides.push({
                                    date: dateKey,
                                    routeName: routeName,
                                    profile: routeOverridesForDate[routeName]
                                });
                            }
                        }
                    }
                }
            }
        }
        
        relevantOverrides.sort((a,b) => {
            const dateCompare = a.date.localeCompare(b.date);
            if (dateCompare !== 0) return dateCompare;
            return compareLineNames_ExtraPage(a.routeName, b.routeName);
        });

        if (relevantOverrides.length > 0) {
            let groupedHtml = "<ul style='list-style-type: none; padding-left: 0;'>";
            let currentDate = null;
            relevantOverrides.forEach(ov => {
                if (ov.date !== currentDate) {
                    if (currentDate !== null) {
                        groupedHtml += "</div></li>";
                    }
                    currentDate = ov.date;
                    groupedHtml += `<li style="margin-top:0.75em; margin-bottom:0.25em;"><strong>${formatDateToDDMonthYYYY_ExtraPage(ov.date)}:</strong>
                                    <div style="margin-top:0.5em; display:flex; flex-wrap:wrap; gap:0.4em; padding-left:15px;">`;
                }
                
                const displayProfile = String(ov.profile || "").replace(/,/g, ', '); 
                const bgColor = getRouteTileColour_ExtraPage(ov.routeName);
                const textColor = getTextColourForBackground_ExtraPage(bgColor);

                groupedHtml += `
                    <span class="route-tile-tools-list" 
                          style="background-color:${bgColor}; color:${textColor}; padding:0.3em 0.6em; font-size:0.85em; cursor:help;"
                          title="${ov.routeName}: ${displayProfile}">
                        ${ov.routeName}
                        <span style="font-size:0.75em; opacity:0.8; display:block; line-height:1.2;">${displayProfile}</span>
                    </span>`;
            });
            groupedHtml += "</div></li></ul>";
            html = groupedHtml;
        } else {
            html = `<p>No route-specific overrides set for the next ${fixedDaysAhead} day(s).</p>`; 
        }
        activeOverridesListElement.innerHTML = html;
    } catch (error) {
        console.error("Error loading all overrides:", error);
        activeOverridesListElement.innerHTML = "<p>Error loading all overrides.</p>";
        if (overridesHeadingElement) {
            overridesHeadingElement.textContent = "All Active Overrides (Error)";
        }
    }
}
        
async function updateSelectedDateInfo_ExtraPage() {
            if (!overrideDateInput_el_extra || !selectedDateDisplay_el_extra || !dpoCurrentOverridesList_el_extra) return;
            const selectedDateStr = overrideDateInput_el_extra.value;
            dpo_clearRouteSelections_ExtraPage();
            dpoStatusMessage_el_extra.textContent = '';

            selectedDateDisplay_el_extra.textContent = selectedDateStr ? formatDateToDDMonthYYYY_ExtraPage(selectedDateStr) : "(select a date)";
            dpoCurrentOverridesList_el_extra.innerHTML = '<p>Select a date above to see its current overrides.</p>';

            if (!selectedDateStr) {
                return;
            }
            
            if (operationalOverrides_data && operationalOverrides_data[selectedDateStr]) {
                dpo_currentOverridesForSelectedDate = operationalOverrides_data[selectedDateStr];
                const routeOverridesForDate = Object.entries(dpo_currentOverridesForSelectedDate)
                                                .sort((a, b) => compareLineNames_ExtraPage(a[0], b[0]));
                if (routeOverridesForDate.length > 0) {
                    let html = `<ul style="list-style-type: disc; padding-left: 20px; margin: 0;">`;
                    routeOverridesForDate.forEach(([routeName, profile]) => {
                        html += `<li>${routeName}: ${profile}</li>`;
                    });
                    html += `</ul>`;
                    dpoCurrentOverridesList_el_extra.innerHTML = html;
                } else {
                    dpoCurrentOverridesList_el_extra.innerHTML = `<p>No specific route overrides set for ${formatDateToDDMonthYYYY_ExtraPage(selectedDateStr)}.</p>`;
                }
            } else {
                dpo_currentOverridesForSelectedDate = {};
                dpoCurrentOverridesList_el_extra.innerHTML = `<p>No specific route overrides set for ${formatDateToDDMonthYYYY_ExtraPage(selectedDateStr)}.</p>`;
            }
            dpo_updateActionButtonsState();
        }

async function dpo_clearOverrideForRoutes_ExtraPage() {
            if (!currentUser_extra || !overrideDateInput_el_extra || !dpoStatusMessage_el_extra || !window.firebaseOMSI) {
                if (dpoStatusMessage_el_extra) {
                    dpoStatusMessage_el_extra.textContent = "Error: System not ready or not logged in for clear.";
                    dpoStatusMessage_el_extra.style.color="#e74c3c";
                }
                return;
            }
            const selectedDate = overrideDateInput_el_extra.value;
            const routesToClearFor = dpo_selectedRoutes_extra;

            if (!selectedDate) {
                dpoStatusMessage_el_extra.textContent = "Please select a date to clear overrides from.";
                dpoStatusMessage_el_extra.style.color="#e74c3c";
                return;
            }
            if (routesToClearFor.length === 0) {
                dpoStatusMessage_el_extra.textContent = "Please select at least one route to clear its override.";
                dpoStatusMessage_el_extra.style.color="#f1c40f";
                return;
            }

            const { database, dbRemove, dbSet, dbRef } = window.firebaseOMSI;
            let dateOverrides = operationalOverrides_data[selectedDate];

            if (!dateOverrides || Object.keys(dateOverrides).length === 0) {
                dpoStatusMessage_el_extra.textContent = `No overrides found for ${formatDateToDDMonthYYYY_ExtraPage(selectedDate)} to clear.`;
                dpoStatusMessage_el_extra.style.color="#f1c40f";
                dpo_clearRouteSelections_ExtraPage();
                return;
            }
            
            let overridesActuallyCleared = false;
            routesToClearFor.forEach(routeName => {
                if (dateOverrides[routeName]) {
                    delete dateOverrides[routeName];
                    overridesActuallyCleared = true;
                }
            });

            if (!overridesActuallyCleared) {
                dpoStatusMessage_el_extra.textContent = "No existing overrides for the selected routes on this date to clear.";
                dpoStatusMessage_el_extra.style.color="#7f8c8d";
                return;
            }

            if (!confirm(`Are you sure you want to clear the override for Route(s): ${routesToClearFor.join(', ')} on ${formatDateToDDMonthYYYY_ExtraPage(selectedDate)}?`)) {
                dpoStatusMessage_el_extra.textContent = "Clear override cancelled.";
                dpoStatusMessage_el_extra.style.color="#7f8c8d";
                return;
            }
            
            dpoStatusMessage_el_extra.textContent = `Clearing override for selected routes...`;
            dpoStatusMessage_el_extra.style.color="#f1c40f";

            try {
                if (Object.keys(dateOverrides).length === 0) {
                    await dbRemove(dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${selectedDate}`));
                    delete operationalOverrides_data[selectedDate];
                } else {
                    await dbSet(dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${selectedDate}`), dateOverrides);
                    operationalOverrides_data[selectedDate] = dateOverrides;
                }
                
                dpoStatusMessage_el_extra.textContent = `Successfully cleared override for ${routesToClearFor.length} route(s) on ${formatDateToDDMonthYYYY_ExtraPage(selectedDate)}.`;
                dpoStatusMessage_el_extra.style.color="#2ecc71";
                
                updateSelectedDateInfo_ExtraPage();
                loadAndDisplayOverrides_ExtraPage();
                dpo_clearRouteSelections_ExtraPage();
                updateCurrentProfileDisplay_ExtraPage();
            } catch (error) {
                console.error("DPO Clear: Error clearing override:", error);
                dpoStatusMessage_el_extra.textContent = "Error clearing override: " + error.message; 
                dpoStatusMessage_el_extra.style.color="#e74c3c";
            }
        }

        async function updateAncillaryScheduleData_ExtraPage() {
            if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available for ancillary data update.");
            const { database, dbSet, dbUpdate, dbRef } = window.firebaseOMSI;

            // 1. Regenerate uniqueBusStops from the current in-memory flat schedule
            const stopsMap = new Map();
            currentWorkingSchedule_extra.forEach(row => {
                if (row.stopID && !stopsMap.has(row.stopID.toUpperCase())) {
                    stopsMap.set(row.stopID.toUpperCase(), { stopID: row.stopID, stopName: row.stopName, direction: row.direction });
                }
            });
            const finalUniqueStops = Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase()));

            try {
                console.log("Attempting to save unique bus stops (ancillary)...");
                await dbSet(dbRef(database, FB_PATH_LIVE_UNIQUE_STOPS), finalUniqueStops);
                console.log("Unique bus stops saved. Attempting to save last updated timestamp (ancillary)...");
                await dbUpdate(dbRef(database), { [FB_PATH_APPSTATE_LAST_UPDATED]: new Date().toISOString() });
                console.log("Ancillary schedule data (unique stops, timestamp) updated.");
            } catch (error) {
                console.error("Error saving ancillary schedule data:", error);
                // Decide if this error should be propagated or just logged
                throw error; // Propagate for now
            }
        }

        // --- REBUILDS ENTIRE SCHEDULE in new structured format ---
        async function rebuildAndSaveEntireScheduleToFirebase_ExtraPage(flatScheduleDataToSave) {
    if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available.");
    const { database, dbSet, dbRef } = window.firebaseOMSI;

    console.log("Rebuilding entire schedule into new nested structure (in memory)...");
    const newSchedulesByRoute = {}; // This object will be built in memory first
    flatScheduleDataToSave.forEach(entry => {
        if (!entry.lineName || !entry.OperatingProfile || !entry.destinationName) {
            console.warn("Skipping entry with missing route/profile/destination:", entry);
            return;
        }
        const saneRoute = sanitizeFirebaseKey(entry.lineName);
        const saneProfile = sanitizeFirebaseKey(entry.OperatingProfile);
        const saneDest = sanitizeFirebaseKey(entry.destinationName);

        if (!newSchedulesByRoute[saneRoute]) newSchedulesByRoute[saneRoute] = {};
        if (!newSchedulesByRoute[saneRoute][saneProfile]) newSchedulesByRoute[saneRoute][saneProfile] = {};
        if (!newSchedulesByRoute[saneRoute][saneProfile][saneDest]) newSchedulesByRoute[saneRoute][saneProfile][saneDest] = { entries: [] };
        
        const entryForStorage = { ...entry };
        // Ensure these key fields are present in the stored entry, even if they were part of the key structure
        entryForStorage.lineName = entry.lineName;
        entryForStorage.OperatingProfile = entry.OperatingProfile;
        entryForStorage.destinationName = entry.destinationName;

        newSchedulesByRoute[saneRoute][saneProfile][saneDest].entries.push(entryForStorage);
    });

    // Sort entries within each R/P/D for consistency
    for (const routeKey in newSchedulesByRoute) {
        for (const profileKey in newSchedulesByRoute[routeKey]) {
            for (const destKey in newSchedulesByRoute[routeKey][profileKey]) {
                newSchedulesByRoute[routeKey][profileKey][destKey].entries.sort((a, b) => {
                    const timeA = (a.scheduledTime || "9999").replace(':', ''); // Use a sortable time format
                    const timeB = (b.scheduledTime || "9999").replace(':', '');
                    const timeCompare = timeA.localeCompare(timeB);
                    if (timeCompare !== 0) return timeCompare;
                    // Optional: Add secondary sort criteria if needed, e.g., by stopName or internalId
                    return (a.stopName || "").localeCompare(b.stopName || "");
                });
            }
        }
    }
    
    try {
        console.log(`Attempting to save schedule to Firebase using PER-ROUTE writes. Total routes: ${Object.keys(newSchedulesByRoute).length}`);
        
        const writePromises = [];

        // Clear the entire schedulesByRoute path first to ensure a clean slate.
        // This is a single delete operation for the parent path.
        console.log(`Clearing existing data at ${FB_PATH_SCHEDULES_BY_ROUTE} before writing new data...`);
        await dbSet(dbRef(database, FB_PATH_SCHEDULES_BY_ROUTE), null);
        console.log(`Path ${FB_PATH_SCHEDULES_BY_ROUTE} cleared.`);

        // Now write each route's data individually
        for (const saneRoute in newSchedulesByRoute) {
            if (Object.hasOwnProperty.call(newSchedulesByRoute, saneRoute)) { // Ensure it's an own property
                const routeData = newSchedulesByRoute[saneRoute];
                const routePath = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}`;
                console.log(`Writing data for route: ${saneRoute} to path: ${routePath}`);
                writePromises.push(dbSet(dbRef(database, routePath), routeData));
            }
        }

        await Promise.all(writePromises);
        console.log("Entire schedule saved successfully to Firebase using per-route writes.");

        // After a full rebuild, also update ancillary data
        await updateAncillaryScheduleData_ExtraPage(); // Uses the global currentWorkingSchedule_extra

    } catch (error) {
        console.error("Error saving entire rebuilt schedule with per-route writes:", error);
        // This error will be propagated to the calling function (e.g., handleBulkAddStops_ExtraPage)
        // which should then inform the user via its status message element.
        throw error; 
    }
}


        // --- Stop Management Functions ---
        function getBaseStopName_ExtraPage(fullStopName) { if (!fullStopName) return ""; let baseName = String(fullStopName).trim(); baseName = baseName.replace(/\s*\(Stand [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\(Bay [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\(Stop [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\([A-Z0-9]\)\s*$/i, ''); baseName = baseName.replace(/\s*-\s*Bay\s*[A-Z0-9]+\s*$/i,''); baseName = baseName.replace(/\s*Stop\s*[A-Z0-9]+\s*$/i,''); return baseName.trim(); }
        function getRandomIdFormat_ExtraPage() { const formats = ["NUM", "BP", "LE", "RO"]; return formats[Math.floor(Math.random() * formats.length)]; }
        function generateUniqueStopId_ExtraPage(format, stopName = "", allExistingStopIDsSet) { const targetBaseName = getBaseStopName_ExtraPage(stopName).toUpperCase(); let prefix = ""; let numericRegex; let baseStartNumber = 1; const MAX_NUMERIC_PART = 99999; switch (format) { case "NUM": prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; case "BP": prefix = "BP"; numericRegex = /^BP(\d+)$/; baseStartNumber = 1; break; case "LE": prefix = "LE"; numericRegex = /^LE(\d+)$/; baseStartNumber = 1; break; case "RO": prefix = "RO"; numericRegex = /^RO(\d+)$/; baseStartNumber = 1; break; default: console.warn(`generateUniqueStopId_ExtraPage: Unknown format "${format}", defaulting to NUM.`); format="NUM"; prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; if (/^[A-Z]+$/.test(format)) {prefix = format.toUpperCase(); numericRegex = new RegExp(`^${prefix}(\\d+)$`); baseStartNumber = 1;} break; } let highestNumInNameSequence = 0; let nameSpecificSequenceFound = false; if (targetBaseName && currentWorkingSchedule_extra) { currentWorkingSchedule_extra.forEach(entry => { if (entry.stopName && entry.stopID) { const existingEntryBaseName = getBaseStopName_ExtraPage(entry.stopName).toUpperCase(); if (existingEntryBaseName === targetBaseName) { const match = entry.stopID.toUpperCase().match(numericRegex); if (match && match[1]) { const numPart = parseInt(match[1], 10); if (!isNaN(numPart) && numPart <= MAX_NUMERIC_PART && numPart > highestNumInNameSequence) { highestNumInNameSequence = numPart; } nameSpecificSequenceFound = true; } } } }); } let nextNumInSequence = nameSpecificSequenceFound ? highestNumInNameSequence + 1 : baseStartNumber; if (format === "NUM" && nextNumInSequence < 101) nextNumInSequence = 101; if (baseStartNumber > MAX_NUMERIC_PART) { console.warn(`Suggest ID (single): Base start ${baseStartNumber} for ${format} exceeds MAX. Fallback.`); return prefix + "MAX_S_ERR" + Math.floor(Math.random()*1000); } let attempts = 0; const maxAttempts = MAX_NUMERIC_PART + 2000; let candidateId = ""; while (attempts < maxAttempts) { if (nextNumInSequence > MAX_NUMERIC_PART) { console.warn(`Suggest ID (single): All numbers up to ${MAX_NUMERIC_PART} exhausted for ${prefix}, base ${targetBaseName}. Fallback.`); let fA = 0, fId; do { fId = prefix + "RND" + String(Date.now()).slice(-3) + (Math.floor(Math.random()*900)+100); fA++; if (fA > 50) return prefix + "FB_FAIL" + Math.floor(Math.random()*1000); } while (allExistingStopIDsSet.has(fId.toUpperCase())); return fId; } candidateId = prefix + nextNumInSequence; if (!allExistingStopIDsSet.has(candidateId.toUpperCase())) return candidateId; nextNumInSequence++; attempts++; } console.warn(`CRITICAL: Could not generate unique Stop ID for ${format}, name: "${stopName}". Final fallback.`); let fA2 = 0, fId2; do { fId2 = prefix + "ULTRA_FB" + String(Date.now()).slice(-5) + (Math.floor(Math.random()*90)+10); fA2++; if (fA2 > 50) return prefix + "ULTRA_CRIT_FAIL" + Math.floor(Math.random()*100); } while (allExistingStopIDsSet.has(fId2.toUpperCase())); return fId2; }
        function autoGenerateAndSetNewStopId_ExtraPage() { if (!currentUser_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !selectNewStopIdFormat_el_extra) return; const currentStopName = inputNewStopName_el_extra.value.trim(); if (!currentStopName) { inputNewStopId_el_extra.value = ""; selectNewStopIdFormat_el_extra.selectedIndex = 0; if(addNewStopStatus_el_extra) {addNewStopStatus_el_extra.textContent = "Enter stop name for ID suggestion."; addNewStopStatus_el_extra.style.color = "";} if (newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = ''; return; } const actualBaseName = getBaseStopName_ExtraPage(currentStopName).toUpperCase(); let formatToUse = null; if (actualBaseName && currentWorkingSchedule_extra && currentWorkingSchedule_extra.length > 0) { for (const existingEntry of currentWorkingSchedule_extra) { if (existingEntry.stopID && existingEntry.stopName) { const existingEntryBaseName = getBaseStopName_ExtraPage(existingEntry.stopName).toUpperCase(); if (existingEntryBaseName === actualBaseName) { const existingId = existingEntry.stopID.toUpperCase(); if (existingId.startsWith("BP") && /BP\d+/.test(existingId)) formatToUse = "BP"; else if (existingId.startsWith("LE") && /LE\d+/.test(existingId)) formatToUse = "LE"; else if (existingId.startsWith("RO") && /RO\d+/.test(existingId)) formatToUse = "RO"; else if (/^\d+$/.test(existingId) && parseInt(existingId, 10) >= 100) formatToUse = "NUM"; if (formatToUse) break; } } } } if (!formatToUse) formatToUse = getRandomIdFormat_ExtraPage(); selectNewStopIdFormat_el_extra.value = formatToUse; const allCurrentScheduleIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase())); const suggestedId = generateUniqueStopId_ExtraPage(formatToUse, currentStopName, allCurrentScheduleIDs); inputNewStopId_el_extra.value = suggestedId; inputNewStopId_el_extra.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })); if (addNewStopStatus_el_extra) { addNewStopStatus_el_extra.textContent = `Auto-suggested ID: ${suggestedId} (Format: "${formatToUse}").`; addNewStopStatus_el_extra.style.color = '#bdc3c7'; } }
        async function handleAddStopDetails_ExtraPage() {
    if (!currentUser_extra || !addNewStopStatus_el_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !inputNewStopDirection_el_extra) {
        if (addNewStopStatus_el_extra) {
            addNewStopStatus_el_extra.textContent = "Error: UI components missing for adding stop.";
            addNewStopStatus_el_extra.style.color = '#e74c3c';
        }
        return;
    }
    const newStopID = inputNewStopId_el_extra.value.trim().toUpperCase();
    const newStopName = inputNewStopName_el_extra.value.trim();
    const newStopDirection = inputNewStopDirection_el_extra.value.trim();

    if (!newStopID) { 
        addNewStopStatus_el_extra.textContent = "New Stop ID is required."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopId_el_extra.focus(); 
        return; 
    }
    if (!/^[A-Z0-9]+$/.test(newStopID)) { 
        addNewStopStatus_el_extra.textContent = "Stop ID: A-Z, 0-9 only."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopId_el_extra.focus(); 
        return; 
    }
    if (!newStopName) { 
        addNewStopStatus_el_extra.textContent = "New Stop Name is required."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopName_el_extra.focus(); 
        return; 
    }

    // Check against allDefinedStops_data for uniqueness
    if (allDefinedStops_data && allDefinedStops_data[newStopID]) { 
        addNewStopStatus_el_extra.textContent = `Stop ID "${newStopID}" already exists as a definition.`; 
        if(newStopIdAvailability_el_extra){ 
            newStopIdAvailability_el_extra.textContent = 'ID already exists!'; 
            newStopIdAvailability_el_extra.style.color = '#e74c3c'; 
        } 
        inputNewStopId_el_extra.focus(); 
        return; 
    }

    const newStopDefinition = {
        stopID: newStopID,
        stopName: newStopName,
        direction: newStopDirection
    };
    
    // Add to local cache
    if (!allDefinedStops_data) allDefinedStops_data = {};
    allDefinedStops_data[newStopID] = newStopDefinition;

    addNewStopStatus_el_extra.textContent = `Adding stop definition "${newStopID}" to Firebase...`;
    addNewStopStatus_el_extra.style.color = '#f1c40f';

    try {
        await saveAllDefinedStopsToFirebase_ExtraPage(); 
        
        addNewStopStatus_el_extra.textContent = `Stop definition "${newStopID} - ${newStopName}" added to Firebase.`;
        addNewStopStatus_el_extra.style.color = '#2ecc71';

        inputNewStopId_el_extra.value = ''; 
        inputNewStopName_el_extra.value = ''; 
        inputNewStopDirection_el_extra.value = '';
        if(newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = '';
        if(selectNewStopIdFormat_el_extra) selectNewStopIdFormat_el_extra.selectedIndex = 0;
        
        if (typeof autoGenerateAndSetNewStopId_ExtraPage === 'function' && inputNewStopName_el_extra && inputNewStopId_el_extra) {
            autoGenerateAndSetNewStopId_ExtraPage();
        }
        
        renderUIDependentElements_ExtraPage(); // Refresh UI lists (like master stop list)

    } catch (error) {
        console.error("Error adding new stop definition:", error);
        addNewStopStatus_el_extra.textContent = "Error saving stop definition: " + error.message;
        addNewStopStatus_el_extra.style.color = '#e74c3c';
        
        // Revert local addition if Firebase update failed
        if (allDefinedStops_data && allDefinedStops_data[newStopID]) {
            delete allDefinedStops_data[newStopID];
        }
        renderUIDependentElements_ExtraPage();
    }
}

async function handleDeleteStopFromMasterList_ExtraPage(stopIDToDelete) {
    if (!currentUser_extra) {
        alert("Log in to delete stops.");
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "Not logged in.";
        return;
    }
    if (!stopIDToDelete) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "No StopID provided for deletion.";
        console.error("handleDeleteStopFromMasterList_ExtraPage: No stopIDToDelete provided.");
        return;
    }

    // Ensure allDefinedStops_data is an object
    if (typeof allDefinedStops_data !== 'object' || allDefinedStops_data === null) {
        allDefinedStops_data = {};
        console.warn("handleDeleteStopFromMasterList_ExtraPage: allDefinedStops_data was not an object, initialized.");
    }

    const stopNameToDelete = allDefinedStops_data[stopIDToDelete.toUpperCase()]?.stopName || stopIDToDelete;

    if (!confirm(`ARE YOU SURE you want to permanently delete the stop definition for "${stopNameToDelete} (${stopIDToDelete})" AND all its associated schedule entries from Firebase? This cannot be undone.`)) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `Deletion of stop ${stopIDToDelete} cancelled.`;
        return;
    }

    if (masterStopListStatus_el_extra) {
        masterStopListStatus_el_extra.textContent = `Deleting stop ${stopIDToDelete} and its schedules...`;
        masterStopListStatus_el_extra.style.color = '#f1c40f';
    }

    const stopIDUpper = stopIDToDelete.toUpperCase();
    let definitionWasDeleted = false;

    // 1. Remove from defined stops (local cache)
    if (allDefinedStops_data[stopIDUpper]) {
        delete allDefinedStops_data[stopIDUpper];
        definitionWasDeleted = true;
    }

    // 2. Remove any schedule entries for this stop from currentWorkingSchedule_extra (local cache)
    let entriesRemovedCount = 0;
    if (Array.isArray(currentWorkingSchedule_extra)) {
        currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
            if (entry.stopID && entry.stopID.toUpperCase() === stopIDUpper) {
                entriesRemovedCount++;
                return false; // Exclude this entry
            }
            return true; // Keep other entries
        });
    } else {
        currentWorkingSchedule_extra = []; // Ensure it's an array if it wasn't
    }


    // 3. Update related data (local caches)
    if (Array.isArray(closedStopIDs_extra)) {
        closedStopIDs_extra = closedStopIDs_extra.filter(id => id.toUpperCase() !== stopIDUpper);
    } else {
        closedStopIDs_extra = [];
    }

    if (typeof stopSpecificRouteColours_extra === 'object' && stopSpecificRouteColours_extra !== null && stopSpecificRouteColours_extra[stopIDUpper]) {
        delete stopSpecificRouteColours_extra[stopIDUpper];
    } else if (typeof stopSpecificRouteColours_extra !== 'object' || stopSpecificRouteColours_extra === null) {
        stopSpecificRouteColours_extra = {};
    }

    if (stopToServingRoutesMap_extra instanceof Map && stopToServingRoutesMap_extra.has(stopIDToDelete)) {
        stopToServingRoutesMap_extra.delete(stopIDToDelete);
    }


    // 4. Save all changes to Firebase
    try {
        if (definitionWasDeleted) {
            // Ensure saveAllDefinedStopsToFirebase_ExtraPage is defined and handles allDefinedStops_data correctly
            if (typeof saveAllDefinedStopsToFirebase_ExtraPage === 'function') {
                await saveAllDefinedStopsToFirebase_ExtraPage();
            } else {
                console.error("saveAllDefinedStopsToFirebase_ExtraPage function is not defined!");
                throw new Error("Critical function missing for saving defined stops.");
            }
        }

        // Rebuild and save the schedule which now lacks entries for the deleted stop
        // Ensure rebuildAndSaveEntireScheduleToFirebase_ExtraPage exists and is robust
        if (typeof rebuildAndSaveEntireScheduleToFirebase_ExtraPage === 'function') {
            await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
        } else {
            console.error("rebuildAndSaveEntireScheduleToFirebase_ExtraPage function is not defined!");
            throw new Error("Critical function missing for saving schedule data.");
        }
        
        // Ancillary data like uniqueBusStops (stops with service) will be updated by rebuildAndSave...
        if (typeof saveClosedStopsToFirebase_ExtraPage === 'function') await saveClosedStopsToFirebase_ExtraPage();
        if (typeof saveStopSpecificColoursToFirebase_ExtraPage === 'function') await saveStopSpecificColoursToFirebase_ExtraPage();

        if (masterStopListStatus_el_extra) {
            masterStopListStatus_el_extra.textContent = `Stop "${stopNameToDelete}" definition and ${entriesRemovedCount} schedule entries deleted.`;
            masterStopListStatus_el_extra.style.color = '#2ecc71';
        }
        
        // Refresh UI elements that depend on this data
        if (typeof renderUIDependentElements_ExtraPage === 'function') {
            renderUIDependentElements_ExtraPage();
        }

    } catch (error) {
        console.error(`Error deleting stop ${stopIDToDelete}:`, error);
        if (masterStopListStatus_el_extra) {
            masterStopListStatus_el_extra.textContent = `Error deleting stop ${stopIDToDelete}: ${error.message}`;
            masterStopListStatus_el_extra.style.color = '#e74c3c';
        }
        // Attempt to reload initial data to try and resync with Firebase on critical error
        if (typeof loadInitialData_ExtraPage === 'function') {
            alert("A critical error occurred while saving deletions. Attempting to reload all data to ensure consistency. Please check the stop's status after reload.");
            await loadInitialData_ExtraPage();
        }
    }
}

        function generateUniqueStopId_ExtraPage_BulkAware(format, stopName, newlyGeneratedIDsInBatchSet, baseNameAndFormatToGeneratedNumericPartsMap) { const targetBaseName = getBaseStopName_ExtraPage(stopName).toUpperCase(); let prefix = ""; let numericRegex; let baseStartNumber = 1; const MAX_NUMERIC_PART = 99999; switch (format) { case "NUM": prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; case "BP": prefix = "BP"; numericRegex = /^BP(\d+)$/; baseStartNumber = 1; break; case "LE": prefix = "LE"; numericRegex = /^LE(\d+)$/; baseStartNumber = 1; break; case "RO": prefix = "RO"; numericRegex = /^RO(\d+)$/; baseStartNumber = 1; break; default: console.warn(`generateUniqueStopId_ExtraPage_BulkAware (Replace Mode): Unknown format "${format}" for "${stopName}". Defaulting to NUM.`); format = "NUM"; prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; } const keyForMap = `${targetBaseName}_${format}`; if (!baseNameAndFormatToGeneratedNumericPartsMap.has(keyForMap)) { baseNameAndFormatToGeneratedNumericPartsMap.set(keyForMap, new Set()); } const numericPartsForThisGroup = baseNameAndFormatToGeneratedNumericPartsMap.get(keyForMap); let highestNumInGroup = 0; numericPartsForThisGroup.forEach(numStr => { const num = parseInt(numStr, 10); if (!isNaN(num) && num > highestNumInGroup) highestNumInGroup = num; }); let nextNumInSequence = highestNumInGroup > 0 ? highestNumInGroup + 1 : baseStartNumber; if (format === "NUM" && nextNumInSequence < 101) nextNumInSequence = 101; if (baseStartNumber > MAX_NUMERIC_PART) { console.warn(`BulkAware (Replace): Base start ${baseStartNumber} for ${format} exceeds MAX. Fallback.`); return prefix + "B_MAX_S_ERR" + Math.floor(Math.random()*1000); } let attempts = 0; const maxAttempts = MAX_NUMERIC_PART + 2000; let candidateId = ""; while (attempts < maxAttempts) { if (nextNumInSequence > MAX_NUMERIC_PART) { console.warn(`BulkAware (Replace): All numbers up to ${MAX_NUMERIC_PART} exhausted for ${prefix}, base ${targetBaseName}. Fallback.`); let fA = 0, fId; do { fId = prefix + "BRND" + String(Date.now()).slice(-4) + (Math.floor(Math.random()*900)+100); fA++; if (fA > 50) return prefix + "B_FB_FAIL" + Math.floor(Math.random()*1000); } while (newlyGeneratedIDsInBatchSet.has(fId.toUpperCase())); return fId; } candidateId = prefix + nextNumInSequence; if (!newlyGeneratedIDsInBatchSet.has(candidateId.toUpperCase())) { const match = candidateId.match(numericRegex); if(match && match[1]) numericPartsForThisGroup.add(match[1]); return candidateId; } nextNumInSequence++; attempts++; } console.warn(`CRITICAL_BULK (Replace): Could not generate unique Stop ID for ${format}, name: "${stopName}". Final fallback.`); let fA2 = 0, fId2; do { fId2 = prefix + "B_ULTRA_FB" + String(Date.now()).slice(-5) + (Math.floor(Math.random()*9000)+1000); fA2++; if (fA2 > 50) throw new Error("Bulk Fallback ID gen failed catastrophically."); } while (newlyGeneratedIDsInBatchSet.has(fId2.toUpperCase())); return fId2; }
        async function handleBulkAddStops_ExtraPage() {
            if (!currentUser_extra) { alert("Log in."); if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="Not logged in."; bulkAddNewStopsStatus_el_extra.style.color="#e74c3c";} return; }
            const stopsToProcessFromExcel = processedExcelStopsData_extra;
            if (!stopsToProcessFromExcel || stopsToProcessFromExcel.length === 0) { if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="No Excel data processed."; bulkAddNewStopsStatus_el_extra.style.color="#f1c40f";} return; }
            if (!confirm(`DANGER! This will DELETE ALL existing schedules AND ALL MASTER STOP DEFINITIONS, then add ${stopsToProcessFromExcel.length} stop definition(s) from Excel. This action CANNOT BE UNDONE. Proceed?`)) { // Modified confirm message
                if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="Bulk replace operation cancelled."; bulkAddNewStopsStatus_el_extra.style.color="#7f8c8d";} return;
            }
            if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = `Replacing all stops and definitions with ${stopsToProcessFromExcel.length} definitions from file...`; bulkAddNewStopsStatus_el_extra.style.color = '#f1c40f'; }

            let newFlatScheduleEntries = [];
            const newlyGeneratedOrUsedIDsInThisBatch = new Set();
            const baseNameToFormatMapForThisBatch = new Map();
            const baseNameAndFormatToGeneratedNumericPartsMap = new Map();
            let errorsEncountered = 0;
            let totalPlaceholdersCreated = 0;
            let uniqueStopIDsAddedCount = 0; // This will count unique stop *definitions*
            let statusMessages = [`Starting bulk replacement (Excel rows: ${stopsToProcessFromExcel.length})...\n`];

            // +++ NEW: Object to hold the new master stop definitions from this Excel file +++
            const newMasterDefinedStopsFromExcel = {};

            for (const stopData of stopsToProcessFromExcel) {
                const excelStopName = (stopData.stopName || "").trim();
                const excelDirection = (stopData.direction || "").trim();
                const excelUserProvidedStopID = (stopData.userProvidedStopID || "").trim();
                // const excelBaseName = getBaseStopName_ExtraPage(excelStopName).toUpperCase(); // Already in original
                let excelLineNames = (stopData.lineNameInput && stopData.lineNameInput.trim() !== "") ? stopData.lineNameInput.split(',').map(ln => ln.trim().toUpperCase()).filter(ln => ln !== "") : ["INFO_ONLY"];
                if (excelLineNames.length === 0) excelLineNames = ["INFO_ONLY"];

                if (!excelStopName && !excelUserProvidedStopID) {
                    statusMessages.push(`Row ${stopData.originalLineNumber}: Skipped. StopName or StopID required.`); errorsEncountered++; continue;
                }

                let finalStopID = "";
                // let idSourceMessage = ""; // Already in original
                // let chosenFormatForThisStop = ""; // Already in original
                if (excelUserProvidedStopID) {
                    const providedIDUpper = excelUserProvidedStopID.toUpperCase();
                    if (!/^[A-Z0-9]+$/.test(providedIDUpper)) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Provided StopID "${excelUserProvidedStopID}" invalid chars. Skipped.`); errorsEncountered++; continue; }
                    if (newlyGeneratedOrUsedIDsInThisBatch.has(providedIDUpper)) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Provided StopID "${excelUserProvidedStopID}" is duplicated within this Excel file. Skipped.`); errorsEncountered++; continue; }
                    finalStopID = excelUserProvidedStopID; // Use original casing if provided by user for the actual stopID property in the definition
                    // idSourceMessage = "user-provided"; // Already in original
                    // ... (logic for chosenFormatForThisStop from existing code) ...
                } else {
                    // ... (existing logic for auto-generating ID, ensure generateUniqueStopId_ExtraPage_BulkAware returns the ID in the desired case, typically uppercase for consistency but if it preserves original casing for display that's fine too) ...
                    chosenFormatForThisStop = baseNameToFormatMapForThisBatch.get(getBaseStopName_ExtraPage(excelStopName).toUpperCase()) || getRandomIdFormat_ExtraPage();
                    if (!baseNameToFormatMapForThisBatch.has(getBaseStopName_ExtraPage(excelStopName).toUpperCase())) {
                        baseNameToFormatMapForThisBatch.set(getBaseStopName_ExtraPage(excelStopName).toUpperCase(), chosenFormatForThisStop);
                    }
                    finalStopID = generateUniqueStopId_ExtraPage_BulkAware(chosenFormatForThisStop, excelStopName, newlyGeneratedOrUsedIDsInThisBatch, baseNameAndFormatToGeneratedNumericPartsMap);
                    // idSourceMessage = `auto-gen (${chosenFormatForThisStop})`; // Already in original
                }

                if (!finalStopID) {
                    statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Failed to obtain a final StopID. Skipped.`); errorsEncountered++; continue;
                }

                const finalStopIDKey = finalStopID.toUpperCase(); // Use uppercase for the KEY in the definitions object
                newlyGeneratedOrUsedIDsInThisBatch.add(finalStopIDKey);

                // +++ NEW/MODIFIED: Populate the new master defined stops object +++
                // Add definition only if it's a new unique StopID encountered in this file.
                if (!newMasterDefinedStopsFromExcel[finalStopIDKey]) {
                     newMasterDefinedStopsFromExcel[finalStopIDKey] = {
                        stopID: finalStopIDKey, // Store the stopID property itself as uppercase for consistency
                        stopName: excelStopName,
                        direction: excelDirection
                    };
                    uniqueStopIDsAddedCount++; // Count unique definitions being added
                }
                // --- End NEW/MODIFIED ---

                excelLineNames.forEach(ln => {
                    newFlatScheduleEntries.push({
                        internalId: `${finalStopIDKey}_${ln.replace(/[^A-Z0-9]/ig, '')}_phReplace_${Date.now()}_${newFlatScheduleEntries.length}`,
                        stopID: finalStopIDKey, // Use the consistent uppercase ID for schedule entries
                        stopName: excelStopName,
                        direction: excelDirection,
                        lineName: ln,
                        destinationName: "To Be Defined",
                        OperatingProfile: "AllDays",
                        scheduledTime: "00:00",
                        DayOffset: "0"
                    });
                    totalPlaceholdersCreated++;
                });
                statusMessages.push(`Row ${stopData.originalLineNumber}: Processed "${excelStopName}" -> ID: ${finalStopID} (Key: ${finalStopIDKey}). Routes: ${excelLineNames.join(', ')}.`);
            }

            // ... (existing summary message logic and user confirmation for errors) ...
            if (newFlatScheduleEntries.length === 0 && errorsEncountered > 0) { /* ... */ return; }
            else if (newFlatScheduleEntries.length === 0) { /* ... */ return; }


            // +++ NEW/MODIFIED: Update the global allDefinedStops_data with the new master list +++
            allDefinedStops_data = newMasterDefinedStopsFromExcel; // This REPLACES all existing definitions in the local cache
            // --- End NEW/MODIFIED ---

            currentWorkingSchedule_extra = newFlatScheduleEntries; // This is correct
            closedStopIDs_extra = []; // Correct for a full replace
            stopSpecificRouteColours_extra = {}; // Correct for a full replace

            try {
                // +++ NEW/MODIFIED: Save the new master defined stops to Firebase +++
                if (typeof saveAllDefinedStopsToFirebase_ExtraPage === 'function') {
                    await saveAllDefinedStopsToFirebase_ExtraPage(); // This saves the content of `allDefinedStops_data`
                    statusMessages.push(`\nSuccessfully updated master stop definitions in Firebase (${Object.keys(allDefinedStops_data).length} stops).`);
                } else {
                    statusMessages.push(`\nERROR: Function to save master stop definitions is missing! Definitions not saved to Firebase.`);
                    throw new Error("saveAllDefinedStopsToFirebase_ExtraPage function is undefined.");
                }
                // --- End NEW/MODIFIED ---

                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
                await saveClosedStopsToFirebase_ExtraPage(); // Saves empty `closedStopIDs_extra`
                await saveStopSpecificColoursToFirebase_ExtraPage(); // Saves empty `stopSpecificRouteColours_extra`

                statusMessages.push(`\nSuccessfully REPLACED all schedules. Added ${totalPlaceholdersCreated} placeholder entries for ${uniqueStopIDsAddedCount} unique StopIDs to Firebase in the new structure.`);
                if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#2ecc71'; }
                if (fileInputBulkAddStops_el_extra) fileInputBulkAddStops_el_extra.value = '';
                if (fileNameBulkAddStops_el_extra) fileNameBulkAddStops_el_extra.textContent = 'No file selected.';
                processedExcelStopsData_extra = [];
                renderUIDependentElements_ExtraPage(); // This will re-render lists based on new data
            } catch (error) {
                statusMessages.push("\nDATABASE ERROR: Error saving replaced data to Firebase: " + error.message);
                if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; }
                console.error("Error bulk replacing stops and saving to Firebase:", error);
            }
        }

        function handleExcelFileForBulkAdd_ExtraPage(event) { const file = event.target.files[0]; if (!fileInputBulkAddStops_el_extra || !fileNameBulkAddStops_el_extra || !bulkAddNewStopsStatus_el_extra) return; if (!file) { fileNameBulkAddStops_el_extra.textContent = "No file selected."; processedExcelStopsData_extra = []; return; } fileNameBulkAddStops_el_extra.textContent = `Processing ${file.name}...`; bulkAddNewStopsStatus_el_extra.textContent = ""; processedExcelStopsData_extra = []; const reader = new FileReader(); reader.onload = function(e) { try { const data = new Uint8Array(e.target.result); const workbook = XLSX.read(data, {type: 'array'}); const firstSheetName = workbook.SheetNames[0]; const worksheet = workbook.Sheets[firstSheetName]; const jsonData = XLSX.utils.sheet_to_json(worksheet, {header:1, defval:''}); if (jsonData.length === 0) { bulkAddNewStopsStatus_el_extra.textContent = "Excel file empty or no data."; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileNameBulkAddStops_el_extra.textContent = `Error: ${file.name} is empty.`; fileInputBulkAddStops_el_extra.value = ''; return; } let validEntries = 0; let tempProcessedData = []; jsonData.forEach((row, index) => { if (!Array.isArray(row) || row.every(cell => String(cell).trim() === '')) return; const userProvidedStopID = String(row[0] || "").trim(); const stopName = String(row[1] || "").trim(); const direction = String(row[2] || "").trim(); const lineNameInput = String(row[3] || "").trim(); if (!stopName && !userProvidedStopID) { console.warn(`Skipping Excel row ${index + 1}: StopName and StopID both missing.`); return; } tempProcessedData.push({ originalLineNumber: index + 1, userProvidedStopID: userProvidedStopID, stopName: stopName, direction: direction, lineNameInput: lineNameInput }); validEntries++; }); processedExcelStopsData_extra = tempProcessedData; if (validEntries > 0) { fileNameBulkAddStops_el_extra.textContent = `${file.name} (${validEntries} valid rows ready).`; bulkAddNewStopsStatus_el_extra.textContent = `${validEntries} stop definitions processed. Ready for Bulk Replace operation.`; bulkAddNewStopsStatus_el_extra.style.color = '#2ecc71'; } else { fileNameBulkAddStops_el_extra.textContent = `No valid data in ${file.name}.`; bulkAddNewStopsStatus_el_extra.textContent = "No valid definitions (StopName/StopID required)."; bulkAddNewStopsStatus_el_extra.style.color = '#f1c40f'; fileInputBulkAddStops_el_extra.value = ''; } } catch (error) { console.error("Error processing Excel:", error); fileNameBulkAddStops_el_extra.textContent = `Error processing ${file.name}.`; bulkAddNewStopsStatus_el_extra.textContent = "Error processing Excel: " + error.message; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileInputBulkAddStops_el_extra.value = ''; } }; reader.onerror = () => { fileNameBulkAddStops_el_extra.textContent = "Error reading file."; bulkAddNewStopsStatus_el_extra.textContent = "Could not read file."; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileInputBulkAddStops_el_extra.value = ''; }; reader.readAsArrayBuffer(file); }
        
function populateMasterStopList_ExtraPage() {
    if (!masterStopListUL_el_extra || !masterStopListStatus_el_extra) return;

    // Use allDefinedStops_data as the source, convert to array and sort
    const stopsToDisplay = Object.values(allDefinedStops_data || {}).sort((a, b) => {
        const nameA = (a.stopName || "").toLowerCase();
        const nameB = (b.stopName || "").toLowerCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        return (a.stopID || "").toLowerCase().localeCompare((b.stopID || "").toLowerCase());
    });

    const filterText = masterStopListFilterInput_el_extra.value.toLowerCase().trim();
    masterStopListUL_el_extra.innerHTML = '';
    let displayedCount = 0;

    if (stopsToDisplay.length === 0) {
        masterStopListStatus_el_extra.textContent = 'No stop definitions found.';
        masterStopListUL_el_extra.innerHTML = '<p style="text-align:center; padding:1rem; opacity:0.7;">No stops defined in the system.</p>';
        return;
    }

    stopsToDisplay.forEach(stop => {
        if (!stop || !stop.stopID) return;

        // stopToServingRoutesMap_extra is still derived from currentWorkingSchedule_extra (actual services)
        const servingRouteNamesArray = Array.from(stopToServingRoutesMap_extra.get(stop.stopID) || new Set());
        const stopIdLower = stop.stopID.toLowerCase();
        const stopNameLower = (stop.stopName || "").toLowerCase();
        const isClosed = closedStopIDs_extra.includes(stop.stopID.toUpperCase());
        const closureStatus = isClosed ? "Closed" : "Open";

        if (filterText) {
            const stopDirectionLower = (stop.direction || "").toLowerCase();
            const matchesStopId = stopIdLower.includes(filterText);
            const matchesStopName = stopNameLower.includes(filterText);
            const matchesDirection = stopDirectionLower.includes(filterText) ||
                                     (filterText === "no direction" && (stop.direction || "").trim().toUpperCase() === "NO DIRECTION") ||
                                     (filterText === "blank" && !(stop.direction && stop.direction.trim() !== ""));
            const matchesStatus = closureStatus.toLowerCase().includes(filterText);
            const matchesRoute = servingRouteNamesArray.some(routeName =>
                routeName.toLowerCase().includes(filterText)
            );
            if (!(matchesStopId || matchesStopName || matchesDirection || matchesStatus || matchesRoute)) {
                return;
            }
        }

        displayedCount++;
        const li = document.createElement('li');
        li.classList.add('master-stop-list-item');
        li.dataset.originalStopid = stop.stopID;

        const originalInfoDiv = document.createElement('div');
        originalInfoDiv.classList.add('master-stop-original-info');

        let originalContent = `<span class="stop-name-master">${stop.stopName || 'N/A'}</span><br>`;

        let directionHtmlLine = "";
        if (stop.direction &&
            stop.direction.trim() !== "" &&
            stop.direction.trim().toUpperCase() !== "NO DIRECTION") {
            directionHtmlLine = `<span class="stop-direction-master">Towards: ${stop.direction}</span><br>`;
        }
        originalContent += directionHtmlLine;

        originalContent += `<span class="stop-id-master">Stop ID: ${stop.stopID}</span>`;

        originalContent += `<div class="master-stop-original-info .stop-details-grid" style="margin-top:0.3rem;">
                                <span class="detail-label">Status:</span>
                                <span class="detail-value ${isClosed ? 'status-closed' : 'status-open'}">${closureStatus}</span>
                            </div>`;

        if (servingRouteNamesArray.length > 0) {
            const sortedRouteNamesForDisplay = [...servingRouteNamesArray].sort(compareLineNames_ExtraPage);
            originalContent += `<div class="serving-routes-container" style="margin-top:0.3rem;">`;
            sortedRouteNamesForDisplay.slice(0, 10).forEach(lineName => {
                const bgColor = getRouteTileColour_ExtraPage(lineName, stop.stopID);
                const textColor = getTextColourForBackground_ExtraPage(bgColor);
                originalContent += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor}; font-size:0.7em; padding:0.15em 0.4em;">${lineName}</span>`;
            });
            if (sortedRouteNamesForDisplay.length > 10) {
                originalContent += `<span style="font-size:0.7em; opacity:0.8;">...and ${sortedRouteNamesForDisplay.length - 10} more.</span>`;
            }
            originalContent += `</div>`;
        } else { // New: If no serving routes, indicate this explicitly
            originalContent += `<div class="serving-routes-container" style="margin-top:0.3rem; font-size:0.8em; opacity:0.7;">(No routes currently serving this stop)</div>`;
        }
        originalInfoDiv.innerHTML = originalContent;

        const newIdSectionDiv = document.createElement('div');
        newIdSectionDiv.classList.add('master-stop-new-id-section');
        const newIdLabel = document.createElement('label');
        newIdLabel.textContent = 'Propose New ID (optional):';
        const newIdInput = document.createElement('input');
        newIdInput.type = 'text';
        newIdInput.classList.add('schedule-generator-input', 'master-list-new-id-input');
        newIdInput.dataset.originalId = stop.stopID;
        newIdInput.placeholder = "Enter new ID, then Apply Bulk";
        newIdInput.value = stop.stopID;

        const warningP = document.createElement('p');
        warningP.classList.add('master-list-row-warning');

        newIdInput.addEventListener('input', () => {
            const enteredID = newIdInput.value.trim().toUpperCase();
            warningP.textContent = '';
            warningP.style.color = '#f39c12';

            if (!enteredID) return;
            if (enteredID === stop.stopID.toUpperCase()) return;

            if (!/^[A-Z0-9]+$/.test(enteredID)) {
                warningP.textContent = 'Invalid chars in ID.';
                return;
            }
            const allCurrentAndProposedIDs = new Set(Object.keys(allDefinedStops_data || {}).map(id => id.toUpperCase()));
            document.querySelectorAll('#masterStopListUL_extra .master-list-new-id-input').forEach(inp => {
                if (inp !== newIdInput) {
                    const otherProposed = inp.value.trim().toUpperCase();
                    if (otherProposed && otherProposed !== inp.dataset.originalId.toUpperCase()) {
                        allCurrentAndProposedIDs.add(otherProposed);
                    }
                }
            });

            if (allCurrentAndProposedIDs.has(enteredID)) {
                warningP.textContent = 'ID taken or proposed elsewhere!';
            } else {
                warningP.textContent = 'New ID available.';
                warningP.style.color = '#2ecc71';
            }
        });

        newIdSectionDiv.appendChild(newIdLabel);
        newIdSectionDiv.appendChild(newIdInput);
        newIdSectionDiv.appendChild(warningP);

        const actionsDiv = document.createElement('div');
        actionsDiv.classList.add('master-stop-actions');

        const editBtn = document.createElement('button');
        editBtn.className = 'button small-action';
        editBtn.textContent = 'Edit Name / Direction';
        editBtn.addEventListener('click', () => handleEditStopFromMasterList_ExtraPage(stop.stopID, stop.stopName, stop.direction));

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'button small-action secondary';
        deleteBtn.textContent = 'Delete Stop Definition'; // Text changed for clarity
        deleteBtn.addEventListener('click', () => handleDeleteStopFromMasterList_ExtraPage(stop.stopID));

        const toggleBtn = document.createElement('button');
        toggleBtn.className = `button small-action ${isClosed ? "save" : "secondary"}`;
        toggleBtn.textContent = isClosed ? "Reopen Stop" : "Close Stop";
        toggleBtn.addEventListener('click', () => handleToggleStopStatusFromMasterList_ExtraPage(stop.stopID));

        actionsDiv.appendChild(editBtn);
        actionsDiv.appendChild(deleteBtn);
        actionsDiv.appendChild(toggleBtn);

        li.appendChild(originalInfoDiv);
        li.appendChild(newIdSectionDiv);
        li.appendChild(actionsDiv);
        masterStopListUL_el_extra.appendChild(li);
    });

    if (displayedCount === 0 && stopsToDisplay.length > 0 && filterText) {
        masterStopListUL_el_extra.innerHTML = `<p style="text-align:center; padding:1rem; opacity:0.7;">No stops match your filter "${filterText}".</p>`;
    }

    masterStopListStatus_el_extra.textContent = `Showing ${displayedCount} of ${stopsToDisplay.length} defined stops. ${filterText ? `Filter active: "${filterText}"` : ''}`;
}

        function findDuplicateStopsByNameAndDirection_ExtraPage() { if (!currentUser_extra) { alert("Please log in."); if (duplicateStopsByNameDirResults_el_extra) duplicateStopsByNameDirResults_el_extra.textContent = "Please log in."; return; } if (!duplicateStopsByNameDirResults_el_extra) { console.error("Result display element not found."); return; } duplicateStopsByNameDirResults_el_extra.innerHTML = "<p>Checking for duplicates...</p>"; duplicateStopsByNameDirResults_el_extra.style.color = "#f1c40f"; const stopsToCheck = getUniqueStopsFromSchedule_ExtraPage(); if (!stopsToCheck || stopsToCheck.length === 0) { duplicateStopsByNameDirResults_el_extra.textContent = "No stops loaded."; return; } const signatureMap = new Map(); stopsToCheck.forEach(stop => { if (stop.stopName && stop.stopID) { const name = stop.stopName.trim().toLowerCase(); const direction = (stop.direction || "").trim().toLowerCase(); const signature = `${name}|${direction}`; if (!signatureMap.has(signature)) signatureMap.set(signature, []); signatureMap.get(signature).push({id: stop.stopID, name: stop.stopName, direction: stop.direction}); } }); let duplicateSets = []; signatureMap.forEach((stops, signature) => { if (stops.length > 1) { duplicateSets.push({ signature: signature, name: stops[0].name, direction: stops[0].direction || "", stops: stops.map(s => ({ id: s.id, entryCount: currentWorkingSchedule_extra.filter(entry => entry.stopID === s.id).length })).sort((a,b) => b.entryCount - a.id.localeCompare(b.id)) }); } }); if (duplicateSets.length === 0) { duplicateStopsByNameDirResults_el_extra.textContent = "No duplicate stops found (name & direction)."; duplicateStopsByNameDirResults_el_extra.style.color = "#2ecc71"; } else { let html = `<p>${duplicateSets.length} set(s) of duplicate stops found:</p><ul>`; duplicateSets.forEach((set, index) => { html += `<li class="duplicate-set-to-merge">`; html += `<p><strong>Name:</strong> "${set.name}", <strong>Direction:</strong> "${set.direction || '(None)'}"</p>`; html += `<p>Conflicting StopIDs (select one to keep):</p><div class="stop-id-options">`; set.stops.forEach((stop, radioIndex) => { const radioName = `master_for_set_${index}`; const isChecked = radioIndex === 0 ? "checked" : ""; html += `<label><input type="radio" name="${radioName}" value="${stop.id}" ${isChecked}> ${stop.id} (${stop.entryCount} entries)</label><br>`; }); html += `</div></li>`; }); html += `</ul><button id="mergeDuplicateStopsButton_extra" class="button save" style="margin-top:1rem;">Merge Selected Duplicates</button>`; html += `<p id="mergeDuplicateStopsStatus_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>`; duplicateStopsByNameDirResults_el_extra.innerHTML = html; duplicateStopsByNameDirResults_el_extra.style.color = "#e74c3c"; const mergeButton = document.getElementById('mergeDuplicateStopsButton_extra'); if (mergeButton) mergeButton.addEventListener('click', handleMergeDuplicateStops_ExtraPage); } }
        async function handleMergeDuplicateStops_ExtraPage() {
            if (!currentUser_extra) { alert("Log in."); return; }
            const mergeStatusEl = document.getElementById('mergeDuplicateStopsStatus_extra'); if (!mergeStatusEl) return;
            mergeStatusEl.textContent = "Processing merges..."; mergeStatusEl.style.color = "#f1c40f";
            const duplicateSetElements = duplicateStopsByNameDirResults_el_extra.querySelectorAll('.duplicate-set-to-merge'); if (duplicateSetElements.length === 0) { mergeStatusEl.textContent = "No duplicate sets found."; return; }
            let changesMade = false; let totalEntriesReassigned = 0; let stopIDsMergedAwayOverall = new Set();
            for (let i = 0; i < duplicateSetElements.length; i++) { 
                const radioName = `master_for_set_${i}`; const selectedRadio = duplicateStopsByNameDirResults_el_extra.querySelector(`input[name="${radioName}"]:checked`); if (!selectedRadio) continue; const masterStopID = selectedRadio.value; const masterStopDetails = uniqueStopsMasterList_extra.find(s => s.stopID === masterStopID) || currentWorkingSchedule_extra.find(e => e.stopID === masterStopID); if (!masterStopDetails) continue; const masterStopName = masterStopDetails.stopName; const masterStopDirection = masterStopDetails.direction; const allRadiosInSet = duplicateStopsByNameDirResults_el_extra.querySelectorAll(`input[name="${radioName}"]`); const stopIDsInThisSet = Array.from(allRadiosInSet).map(radio => radio.value); const stopIDsToMergeAway = stopIDsInThisSet.filter(id => id !== masterStopID); if (stopIDsToMergeAway.length > 0) { changesMade = true; stopIDsToMergeAway.forEach(idToMerge => { stopIDsMergedAwayOverall.add(idToMerge.toUpperCase()); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === idToMerge) { entry.stopID = masterStopID; entry.stopName = masterStopName; entry.direction = masterStopDirection; totalEntriesReassigned++; } }); }); }
            }
            if (!changesMade) { mergeStatusEl.textContent = "No merges selected."; mergeStatusEl.style.color = "#7f8c8d"; return; }
            closedStopIDs_extra = closedStopIDs_extra.filter(id => !stopIDsMergedAwayOverall.has(id.toUpperCase())); stopIDsMergedAwayOverall.forEach(idToMergeUpper => { if (stopSpecificRouteColours_extra[idToMergeUpper]) delete stopSpecificRouteColours_extra[idToMergeUpper]; });
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra); 
                await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                mergeStatusEl.textContent = `Merged duplicates. ${totalEntriesReassigned} entries reassigned.`; mergeStatusEl.style.color = "#2ecc71";
                renderUIDependentElements_ExtraPage(); findDuplicateStopsByNameAndDirection_ExtraPage();
            } catch (error) { console.error("Error saving merged stops:", error); mergeStatusEl.textContent = "Error saving merged stops: " + error.message; mergeStatusEl.style.color = "#e74c3c"; alert("CRITICAL: Error saving merged stops. Data inconsistent. Refresh."); }
        }
        async function saveClosedStopsToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; const fbClosedObject = {}; closedStopIDs_extra.forEach(id => { if (typeof id === 'string') fbClosedObject[id.toUpperCase()] = true; }); await dbSet(dbRef(database, FB_PATH_APPSTATE_CLOSED_STOPS), fbClosedObject); console.log("Closed stops saved (Extra)."); }
        async function saveGlobalColoursToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; await dbSet(dbRef(database, FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS), globalCustomRouteColours_extra); console.log("Global route colours saved (Extra)."); }
        async function saveStopSpecificColoursToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; await dbSet(dbRef(database, FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS), stopSpecificRouteColours_extra); console.log("Stop-specific colours saved (Extra)."); }

        // --- Global Route Deletion Functions ---
        function populateGlobalRouteToDeleteList_ExtraPage() { if (!globalRouteDeletionListContainer_el_extra) return; globalRouteDeletionListContainer_el_extra.innerHTML = ''; if (!currentWorkingSchedule_extra || currentWorkingSchedule_extra.length === 0) { globalRouteDeletionListContainer_el_extra.innerHTML = '<p>No routes loaded.</p>'; return; } const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName).filter(Boolean))].sort(compareLineNames_ExtraPage); if (uniqueRoutes.length === 0) { globalRouteDeletionListContainer_el_extra.innerHTML = '<p>No valid routes to list.</p>'; return; } const tileContainer = document.createElement('div'); tileContainer.className = 'selectable-route-tile-container'; uniqueRoutes.forEach(lineName => { const tile = document.createElement('span'); tile.className = 'selectable-route-tile'; tile.textContent = lineName; tile.dataset.lineName = lineName; const bgColor = getRouteTileColour_ExtraPage(lineName); tile.style.backgroundColor = bgColor; tile.style.color = getTextColourForBackground_ExtraPage(bgColor); tile.setAttribute('role', 'checkbox'); tile.setAttribute('aria-checked', 'false'); tile.tabIndex = 0; tile.addEventListener('click', () => { const isSelected = tile.classList.toggle('selected'); tile.setAttribute('aria-checked', isSelected.toString()); }); tile.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); tile.click(); }}); tileContainer.appendChild(tile); }); globalRouteDeletionListContainer_el_extra.appendChild(tileContainer); }
        async function handleDeleteEntireRouteGlobally_ExtraPage() {
            if (!currentUser_extra || !deleteEntireRouteStatusMessage_el_extra || !globalRouteDeletionListContainer_el_extra) return;
            const selectedTiles = globalRouteDeletionListContainer_el_extra.querySelectorAll('.selectable-route-tile.selected');
            if (selectedTiles.length === 0) { deleteEntireRouteStatusMessage_el_extra.textContent = "Select route(s) to delete."; deleteEntireRouteStatusMessage_el_extra.style.color = '#f1c40f'; return; }
            const routesToDelete = Array.from(selectedTiles).map(t => t.dataset.lineName);
            if (!confirm(`EXTREME CAUTION!\nDelete ALL data for route(s): ${routesToDelete.join(', ')} from Firebase? CANNOT BE UNDONE.`)) { deleteEntireRouteStatusMessage_el_extra.textContent = "Global deletion cancelled."; return; }
            deleteEntireRouteStatusMessage_el_extra.textContent = `Deleting route(s): ${routesToDelete.join(', ')}...`; deleteEntireRouteStatusMessage_el_extra.style.color = '#f1c40f';
            const { database, dbRemove, dbRef } = window.firebaseOMSI; let firebaseRemovalPromises = [];
            routesToDelete.forEach(routeNameToDelete => {
                const saneRouteName = sanitizeFirebaseKey(routeNameToDelete);
                const routePath = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRouteName}`;
                firebaseRemovalPromises.push(dbRemove(dbRef(database, routePath)));
            });
            const originalScheduleLength = currentWorkingSchedule_extra.length;
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry =>
                !(entry.lineName && routesToDelete.map(r => r.toUpperCase()).includes(entry.lineName.toUpperCase()))
            );
            const scheduleEntriesRemovedCount = originalScheduleLength - currentWorkingSchedule_extra.length;
            let globalColoursRemoved = false; routesToDelete.forEach(route => { if (globalCustomRouteColours_extra[route.toUpperCase()]) { delete globalCustomRouteColours_extra[route.toUpperCase()]; globalColoursRemoved = true; } });
            let specificColoursNeedSave = false; Object.keys(stopSpecificRouteColours_extra).forEach(stopID => { routesToDelete.forEach(route => { if (stopSpecificRouteColours_extra[stopID] && stopSpecificRouteColours_extra[stopID][route.toUpperCase()]) { delete stopSpecificRouteColours_extra[stopID][route.toUpperCase()]; if (Object.keys(stopSpecificRouteColours_extra[stopID]).length === 0) delete stopSpecificRouteColours_extra[stopID]; specificColoursNeedSave = true; } }); });
            try {
                await Promise.all(firebaseRemovalPromises); 
                if (globalColoursRemoved) await saveGlobalColoursToFirebase_ExtraPage();
                if (specificColoursNeedSave) await saveStopSpecificColoursToFirebase_ExtraPage();
                await updateAncillaryScheduleData_ExtraPage(); 
                deleteEntireRouteStatusMessage_el_extra.textContent = `Route(s) ${routesToDelete.join(', ')} deleted. ${scheduleEntriesRemovedCount} entries removed.`;
                deleteEntireRouteStatusMessage_el_extra.style.color = '#2ecc71';
                renderUIDependentElements_ExtraPage();
            } catch (error) {
                console.error("Error deleting route(s) globally:", error);
                deleteEntireRouteStatusMessage_el_extra.textContent = "Error saving deletions: " + error.message;
                deleteEntireRouteStatusMessage_el_extra.style.color = '#e74c3c';
                alert("Critical error saving global route deletions. Data inconsistent. Refresh.");
            }
        }

        // ++ Route Profile Deletion Functions (NEW SECTION) ++
        /**
         * @description Populates the route select dropdown for the Route Profile Deletion tool.
         */
        function rpd_populateRouteSelect_ExtraPage() {
            if (!rpdRouteSelect_el_extra || !rpdRouteInput_el_extra) return;
            const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))]
                .filter(Boolean)
                .sort(compareLineNames_ExtraPage);

            const currentInputValue = rpdRouteInput_el_extra.value.trim();
            rpdRouteSelect_el_extra.innerHTML = '<option value="">-- Select Route --</option>';
            uniqueRoutes.forEach(route => {
                const opt = document.createElement('option');
                opt.value = route;
                opt.textContent = route;
                rpdRouteSelect_el_extra.appendChild(opt);
            });

            const matchedRoute = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
            if (matchedRoute) {
                rpdRouteSelect_el_extra.value = matchedRoute;
            } else if (currentInputValue) {
                rpdRouteSelect_el_extra.value = ""; 
            }
            // Chain updates
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Handles changes to the route name input field for RPD.
         */
        function rpd_handleRouteNameInputChange_ExtraPage() {
            if (!rpdRouteInput_el_extra || !rpdRouteSelect_el_extra) return;
            const typedRouteUpper = rpdRouteInput_el_extra.value.trim().toUpperCase();
            const matchedOption = Array.from(rpdRouteSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper);

            if (matchedOption) {
                rpdRouteSelect_el_extra.value = matchedOption.value;
                if (rpdRouteInput_el_extra.value !== matchedOption.value) {
                    rpdRouteInput_el_extra.value = matchedOption.value;
                }
            } else {
                rpdRouteSelect_el_extra.value = ""; 
            }
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Handles changes to the route name select dropdown for RPD.
         */
        function rpd_handleRouteNameSelectChange_ExtraPage() {
            if (!rpdRouteSelect_el_extra || !rpdRouteInput_el_extra) return;
            rpdRouteInput_el_extra.value = rpdRouteSelect_el_extra.value;
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Populates the destination select dropdown for RPD based on selected route.
         */
        function rpd_populateDestinationSelect_ExtraPage() {
            if (!rpdDestinationSelect_el_extra || !rpdDestinationInput_el_extra || !rpdRouteInput_el_extra) return;

            const selectedRoute = rpdRouteInput_el_extra.value.trim().toUpperCase();
            const currentDestInputValue = rpdDestinationInput_el_extra.value.trim();

            rpdDestinationSelect_el_extra.innerHTML = '<option value="">-- Optional: All Destinations --</option>'; // Modified default text

            if (!selectedRoute) {
                rpdDestinationInput_el_extra.value = ""; 
                rpdDestinationSelect_el_extra.disabled = true;
                rpdDestinationInput_el_extra.disabled = true;
                if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = 'none';
                rpd_populateProfileList_ExtraPage(); 
                return;
            }

            rpdDestinationSelect_el_extra.disabled = false;
            rpdDestinationInput_el_extra.disabled = false;

            const uniqueDestinations = [...new Set(
                currentWorkingSchedule_extra
                    .filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName)
                    .map(e => e.destinationName)
            )].sort();

            if (uniqueDestinations.length > 0) {
                uniqueDestinations.forEach(dest => {
                    const opt = document.createElement('option');
                    opt.value = dest;
                    opt.textContent = dest;
                    rpdDestinationSelect_el_extra.appendChild(opt);
                });
                const matchedDest = uniqueDestinations.find(d => d === currentDestInputValue);
                if (matchedDest) {
                    rpdDestinationSelect_el_extra.value = matchedDest;
                } else {
                     rpdDestinationSelect_el_extra.value = ""; // Default to "All Destinations" if typed value doesn't match
                }
            } else {
                 rpdDestinationSelect_el_extra.innerHTML = '<option value="">-- No Specific Destinations --</option>';
                 rpdDestinationInput_el_extra.value = ""; // Clear input if no destinations exist
            }
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }
        
        /**
         * @description Handles changes to the destination name input field for RPD.
         */
        function rpd_handleDestinationNameInputChange_ExtraPage() {
            if (!rpdDestinationInput_el_extra || !rpdDestinationSelect_el_extra) return;
            const typedDest = rpdDestinationInput_el_extra.value.trim();
            const matchedOption = Array.from(rpdDestinationSelect_el_extra.options).find(opt => opt.value === typedDest);

            if (matchedOption) {
                rpdDestinationSelect_el_extra.value = matchedOption.value;
                if (rpdDestinationInput_el_extra.value !== matchedOption.value) {
                   rpdDestinationInput_el_extra.value = matchedOption.value;
                }
            } else {
                rpdDestinationSelect_el_extra.value = ""; // If typing something not in list, clear select to imply "All Destinations" or new
            }
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }

        /**
         * @description Handles changes to the destination name select dropdown for RPD.
         */
        function rpd_handleDestinationNameSelectChange_ExtraPage() {
            if (!rpdDestinationSelect_el_extra || !rpdDestinationInput_el_extra) return;
            rpdDestinationInput_el_extra.value = rpdDestinationSelect_el_extra.value; // Sync input with select
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }
        
        /**
         * @description Clears the destination selection for RPD.
         */
        function rpd_handleClearDestination_ExtraPage() {
            if (!rpdDestinationInput_el_extra || !rpdDestinationSelect_el_extra || !rpdClearDestinationButton_el_extra) return;
            rpdDestinationInput_el_extra.value = "";
            rpdDestinationSelect_el_extra.value = ""; // This will select "-- Optional: All Destinations --"
            rpdClearDestinationButton_el_extra.style.display = 'none';
            rpd_populateProfileList_ExtraPage(); 
        }

        /**
         * @description Fetches and displays available profiles for selection based on route and optional destination.
         */
        async function rpd_populateProfileList_ExtraPage() {
            if (!rpdProfileListContainer_el_extra || !rpdRouteInput_el_extra || !rpdDestinationInput_el_extra || !window.firebaseOMSI) {
                if (rpdProfileListContainer_el_extra) rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; opacity:0.7;">Required elements missing for profile listing.</p>';
                return;
            }

            const routeName = rpdRouteInput_el_extra.value.trim();
            const destinationName = rpdDestinationInput_el_extra.value.trim(); // This is the specific destination, if selected

            rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; opacity:0.7;">Select a route to see available profiles.</p>';

            if (!routeName) {
                return; 
            }

            rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; color:#f1c40f;">Loading profiles...</p>';

            // Use currentWorkingSchedule_extra to derive profiles to ensure original casing and relevance
            let profilesOfInterest = currentWorkingSchedule_extra.filter(entry => {
                if (entry.lineName !== routeName) return false;
                if (destinationName && entry.destinationName !== destinationName) return false; // Filter by dest if specified
                return true; // Passes if route matches, and dest matches (if dest was specified)
            });

            let availableOriginalProfileNames = [...new Set(profilesOfInterest.map(e => e.OperatingProfile))].sort();

            if (availableOriginalProfileNames.length === 0) {
                if (destinationName) {
                    rpdProfileListContainer_el_extra.innerHTML = `<p style="font-size:0.85em; color:#f1c40f;">No profiles found for route "${routeName}" with destination "${destinationName}".</p>`;
                } else {
                    rpdProfileListContainer_el_extra.innerHTML = `<p style="font-size:0.85em; color:#f1c40f;">No profiles found for route "${routeName}".</p>`;
                }
                return;
            }

            let html = '<div class="selectable-route-tile-container" style="margin-top:0.5rem;">'; 
            availableOriginalProfileNames.forEach(profileName => {
                html += `
                    <label class="selectable-route-tile rpd-profile-tile" style="background-color: #4A5568; color: white; border-color: transparent;" tabindex="0">
                        <input type="checkbox" class="rpd-profile-checkbox sr-only" value="${profileName}">
                        ${profileName}
                    </label>
                `;
            });
            html += '</div>';
            rpdProfileListContainer_el_extra.innerHTML = html;

            rpdProfileListContainer_el_extra.querySelectorAll('.rpd-profile-tile').forEach(tile => {
                const checkbox = tile.querySelector('.rpd-profile-checkbox');
                const toggleSelection = () => {
                    checkbox.checked = !checkbox.checked;
                    tile.classList.toggle('selected', checkbox.checked); 
                    tile.style.borderColor = checkbox.checked ? '#f1c40f' : 'transparent'; // Visual feedback
                    tile.setAttribute('aria-checked', checkbox.checked.toString());
                };
                tile.addEventListener('click', toggleSelection);
                tile.addEventListener('keydown', (e) => {
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        toggleSelection();
                    }
                });
            });
        }


        /**
         * @description Handles the deletion of selected route profiles.
         */
        async function handleDeleteRouteProfiles_ExtraPage() {
            if (!currentUser_extra || !window.firebaseOMSI) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Not logged in or Firebase not available."; rpdStatusMessage_el_extra.style.color = "#e74c3c";}
                return;
            }

            const routeName = rpdRouteInput_el_extra.value.trim();
            const destinationName = rpdDestinationInput_el_extra.value.trim(); // Optional, if empty means all destinations
            const selectedProfileCheckboxes = rpdProfileListContainer_el_extra.querySelectorAll('.rpd-profile-checkbox:checked');

            if (!routeName) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Please select a route."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}
                return;
            }
            if (selectedProfileCheckboxes.length === 0) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Please select at least one profile to delete."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}
                return;
            }

            const profilesToDeleteOriginalNames = Array.from(selectedProfileCheckboxes).map(cb => cb.value);
            const saneRoute = sanitizeFirebaseKey(routeName);
            const saneDest = destinationName ? sanitizeFirebaseKey(destinationName) : null;

            let confirmMessage = `ARE YOU SURE?\nThis will delete ALL schedule entries for:\nRoute: "${routeName}"`;
            if (saneDest) {
                confirmMessage += `\nDestination: "${destinationName}"`;
            } else {
                confirmMessage += ` (across ALL its destinations)`;
            }
            confirmMessage += `\nFor Operating Profile(s): ${profilesToDeleteOriginalNames.join(', ')}\n\nThis action CANNOT BE UNDONE.`;

            if (!confirm(confirmMessage)) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Profile deletion cancelled."; rpdStatusMessage_el_extra.style.color = "";}
                return;
            }

            if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Deleting profiles from Firebase..."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}

            const { database, dbRemove, dbRef } = window.firebaseOMSI;
            const removalPromises = [];

            profilesToDeleteOriginalNames.forEach(profileName => {
                const saneProfile = sanitizeFirebaseKey(profileName);
                let pathToDelete;
                if (saneDest) { // Delete specific destination under profile
                    pathToDelete = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}/${saneProfile}/${saneDest}`;
                } else { // Delete entire profile node for the route
                    pathToDelete = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}/${saneProfile}`;
                }
                console.log("Firebase path marked for deletion:", pathToDelete);
                removalPromises.push(dbRemove(dbRef(database, pathToDelete)));
            });

            try {
                await Promise.all(removalPromises);
                console.log("Firebase removal operations complete for selected profiles.");

                const originalLength = currentWorkingSchedule_extra.length;
                currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
                    const routeMatch = entry.lineName === routeName;
                    const profileMatch = profilesToDeleteOriginalNames.includes(entry.OperatingProfile);
                    // If saneDest is specified, entry must match it. If saneDest is null, destination doesn't matter for removal of whole profile.
                    const destMatch = saneDest ? (entry.destinationName === destinationName) : true;
                    
                    return !(routeMatch && profileMatch && destMatch);
                });
                const removedCount = originalLength - currentWorkingSchedule_extra.length;
                console.log(`${removedCount} entries removed from local currentWorkingSchedule_extra.`);

                await updateAncillaryScheduleData_ExtraPage();

                if(rpdStatusMessage_el_extra) {
                    rpdStatusMessage_el_extra.textContent = `Successfully deleted ${profilesToDeleteOriginalNames.length} profile(s) (${removedCount} schedule entries affected) for route "${routeName}"${saneDest ? ' and destination "' + destinationName + '"' : ' (all destinations for those profiles)'}. Ancillary data updated.`;
                    rpdStatusMessage_el_extra.style.color = "#2ecc71";
                }
                
                rpd_populateProfileList_ExtraPage(); // Refresh profile list
                renderUIDependentElements_ExtraPage(); 

            } catch (error) {
                console.error("Error deleting route profiles:", error);
                if(rpdStatusMessage_el_extra) {
                    rpdStatusMessage_el_extra.textContent = "Error deleting profiles from Firebase: " + error.message;
                    rpdStatusMessage_el_extra.style.color = "#e74c3c";
                }
                alert("Failed to delete profiles from Firebase. Data might be inconsistent. It's recommended to reload data from Firebase or review carefully.");
            }
        }
        // ++ END Route Profile Deletion Functions ++

        const RSG_PROFILE_GROUPS_TO_MANAGE = [
    { individuals: ["Mo", "Tu", "We", "Th", "Fr"], groupProfile: "MF" },
    { individuals: ["MoSch", "TuSch", "WeSch", "ThSch", "FrSch"], groupProfile: "MFSch" },
    { individuals: ["MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"], groupProfile: "MFNSD" }
];

const RSG_PROFILE_INCOMPATIBILITY_RULES = {
    "Mo": ["MoSch", "MoNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MoSch": ["Mo", "MoNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MoNSD": ["Mo", "MoSch", "MF", "MFSch", "MFNSD", "AllDays"],
    "Tu": ["TuSch", "TuNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "TuSch": ["Tu", "TuNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "We": ["WeSch", "WeNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "Th": ["ThSch", "ThNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "Fr": ["FrSch", "FrNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MF": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MFSch", "MFNSD", "AllDays"],
    "MFSch": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MF", "MFNSD", "AllDays"],
    "MFNSD": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MF", "MFSch", "AllDays"],
    "Sa": ["SaNSD", "AllDays"],
    "SaNSD": ["Sa", "AllDays"],
    "Su": ["SuNSD", "AllDays"],
    "SuNSD": ["Su", "AllDays"],
    "AllDays": RSG_OPERATING_PROFILES_LIST.filter(p => p !== "AllDays"),
    "SchoolHoliday": ["AllDays", "MFSch", "MFNSD", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"],
    "BankHoliday": ["AllDays", "MFSch", "MFNSD", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"]
};

for (const keyProfile_extra in RSG_PROFILE_INCOMPATIBILITY_RULES) {
    RSG_PROFILE_INCOMPATIBILITY_RULES[keyProfile_extra].forEach(disabledProfile_extra => {
        if (!RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra]) {
            RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra] = [];
        }
        if (!RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra].includes(keyProfile_extra)) {
            RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra].push(keyProfile_extra);
        }
    });
}

const MASTER_VALID_PROFILE_COMBINATIONS_LIST_EXTRA = [
    "Mo", "Mo,Tu", "Mo,Tu,We", "Mo,Tu,We,Th", "Mo,Tu,We,Th,Sa", "Mo,Tu,We,Th,Sa,Su",
    "Mo,Tu,We,Th,Su", "Mo,Tu,We,Fr", "Mo,Tu,We,Fr,Sa", "Mo,Tu,We,Fr,Sa,Su",
    "Mo,Tu,We,Fr,Su", "Mo,Tu,We,Sa", "Mo,Tu,We,Sa,Su", "Mo,Tu,We,Su", "Mo,Tu,Th", "Mo,Tu,Th,Fr", "Mo,Tu,Th,Fr,Sa", 
    "Mo,Tu,Th,Fr,Su", "Mo,Tu,Th,Fr,Sa,Su", "Mo,Tu,Th,Sa", "Mo,Tu,Th,Sa,Su", "Mo,Tu,Th,Su", "Mo,Tu,Fr",
    "Mo,Tu,Fr,Sa", "Mo,Tu,Fr,Sa,Su", "Mo,Tu,Fr,Su", "Mo,Tu,Sa", "Mo,Tu,Sa,Su", "Mo,Tu,Su", "Mo,We",
    "Mo,We,Th", "Mo,We,Th,Fr", "Mo,We,Th,Fr,Sa", "Mo,We,Th,Fr,Sa,Su", "Mo,We,Th,Fr,Su",
    "Mo,We,Th,Sa", "Mo,We,Th,Sa,Su", "Mo,We,Th,Su", "Mo,We,Fr", "Mo,We,Fr,Sa",
    "Mo,We,Fr,Sa,Su", "Mo,We,Fr,Su", "Mo,We,Sa", "Mo,We,Sa,Su", "Mo,We,Su", "Mo,Th",
    "Mo,Th,Fr", "Mo,Th,Fr,Sa", "Mo,Th,Fr,Sa,Su", "Mo,Th,Fr,Su", "Mo,Th,Sa",
    "Mo,Th,Sa,Su", "Mo,Th,Su", "Mo,Fr", "Mo,Fr,Sa", "Mo,Fr,Sa,Su", "Mo,Fr,Su", "Mo,Sa",
    "Mo,Sa,Su", "Mo,Su",
    "MoSch", "MoSch,TuSch", "MoSch,TuSch,WeSch", "MoSch,TuSch,WeSch,ThSch", "MoSch,TuSch,WeSch,FrSch",
    "MoSch,TuSch,ThSch", "MoSch,TuSch,ThSch,FrSch", "MoSch,TuSch,FrSch", "MoSch,WeSch",
    "MoSch,WeSch,ThSch", "MoSch,WeSch,ThSch,FrSch", "MoSch,WeSch,FrSch", "MoSch,ThSch",
    "MoSch,ThSch,FrSch", "MoSch,FrSch",
    "MoNSD", "MoNSD,TuNSD", "MoNSD,TuNSD,WeNSD", "MoNSD,TuNSD,WeNSD,ThNSD", "MoNSD,TuNSD,WeNSD,FrNSD",
    "MoNSD,TuNSD,ThNSD", "MoNSD,TuNSD,ThNSD,FrNSD", "MoNSD,TuNSD,FrNSD", "MoNSD,WeNSD",
    "MoNSD,WeNSD,ThNSD", "MoNSD,WeNSD,ThNSD,FrNSD", "MoNSD,WeNSD,FrNSD", "MoNSD,ThNSD",
    "MoNSD,ThNSD,FrNSD", "MoNSD,FrNSD",
    "Tu", "Tu,We", "Tu,We,Th", "Tu,We,Th,Fr", "Tu,We,Th,Fr,Sa", "Tu,We,Th,Fr,Sa,Su",
    "Tu,We,Th,Fr,Su", "Tu,We,Th,Sa", "Tu,We,Th,Sa,Su", "Tu,We,Th,Su", "Tu,We,Fr",
    "Tu,We,Fr,Sa", "Tu,We,Fr,Sa,Su", "Tu,We,Fr,Su", "Tu,We,Sa", "Tu,We,Sa,Su", "Tu,We,Su",
    "Tu,Th", "Tu,Th,Fr", "Tu,Th,Fr,Sa", "Tu,Th,Fr,Sa,Su", "Tu,Th,Fr,Su", "Tu,Th,Sa",
    "Tu,Th,Sa,Su", "Tu,Th,Su", "Tu,Fr", "Tu,Fr,Sa", "Tu,Fr,Sa,Su", "Tu,Fr,Su", "Tu,Sa",
    "Tu,Sa,Su", "Tu,Su",
    "TuSch", "TuSch,WeSch", "TuSch,WeSch,ThSch", "TuSch,WeSch,FrSch", "TuSch,ThSch", "TuSch,ThSch,FrSch",
    "TuSch,FrSch",
    "TuNSD", "TuNSD,WeNSD", "TuNSD,WeNSD,ThNSD", "TuNSD,WeNSD,ThNSD,FrNSD", "TuNSD,WeNSD,FrNSD",
    "TuNSD,ThNSD", "TuNSD,ThNSD,FrNSD", "TuNSD,FrNSD",
    "We", "We,Th", "We,Th,Fr", "We,Th,Fr,Sa", "We,Th,Fr,Sa,Su", "We,Th,Fr,Su", "We,Th,Sa",
    "We,Th,Sa,Su", "We,Th,Su", "We,Fr", "We,Fr,Sa", "We,Fr,Sa,Su", "We,Fr,Su", "We,Sa",
    "We,Sa,Su", "We,Su",
    "WeSch", "WeSch,ThSch", "WeSch,ThSch,FrSch", "WeSch,FrSch",
    "WeNSD", "WeNSD,ThNSD", "WeNSD,ThNSD,FrNSD", "WeNSD,FrNSD",
    "Th", "Th,Fr", "Th,Fr,Sa", "Th,Fr,Sa,Su", "Th,Fr,Su", "Th,Sa", "Th,Sa,Su", "Th,Su",
    "ThSch", "ThSch,FrSch",
    "ThNSD", "ThNSD,FrNSD",
    "Fr", "Fr,Sa", "Fr,Sa,Su", "Fr,Su",
    "FrSch", "FrNSD",
    "MF", "MF,Sa", "MF,Sa,Su", "MF,Su",
    "MFSch", "MFNSD",
    "Sa", "Sa,Su",
    "Su",
    "Christmas Eve",
    "Christmas Day",
    "Boxing Day",
    "New Years Eve",
    "New Years Day",
    "Special",
    "SpMo",
    "SpTu",
    "SpWe",
    "SpTh",
    "SpFr",
    "SpSa",
    "SpSu"
];

// --- DPO Specific Rules ---
const DPO_PROFILE_GROUPS_TO_MANAGE = [
    { individuals: ["Mo", "Tu", "We", "Th", "Fr"], groupProfile: "MF" },
    { individuals: ["MoSch", "TuSch", "WeSch", "ThSch", "FrSch"], groupProfile: "MFSch" },
    { individuals: ["MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"], groupProfile: "MFNSD" }
];

const DPO_MASTER_VALID_PROFILE_COMBINATIONS_LIST = [
    "Mo", "Mo,Tu", "Mo,Tu,We", "Mo,Tu,We,Th", "Mo,Tu,We,Th,Sa", "Mo,Tu,We,Th,Sa,Su",
    "Mo,Tu,We,Th,Su", "Mo,Tu,We,Fr", "Mo,Tu,We,Fr,Sa", "Mo,Tu,We,Fr,Sa,Su",
    "Mo,Tu,We,Fr,Su", "Mo,Tu,We,Sa", "Mo,Tu,We,Sa,Su", "Mo,Tu,We,Su", "Mo,Tu,Th", "Mo,Tu,Th,Fr", "Mo,Tu,Th,Fr,Sa", 
    "Mo,Tu,Th,Fr,Su", "Mo,Tu,Th,Fr,Sa,Su", "Mo,Tu,Th,Sa", "Mo,Tu,Th,Sa,Su", "Mo,Tu,Th,Su", "Mo,Tu,Fr",
    "Mo,Tu,Fr,Sa", "Mo,Tu,Fr,Sa,Su", "Mo,Tu,Fr,Su", "Mo,Tu,Sa", "Mo,Tu,Sa,Su", "Mo,Tu,Su", "Mo,We",
    "Mo,We,Th", "Mo,We,Th,Fr", "Mo,We,Th,Fr,Sa", "Mo,We,Th,Fr,Sa,Su", "Mo,We,Th,Fr,Su",
    "Mo,We,Th,Sa", "Mo,We,Th,Sa,Su", "Mo,We,Th,Su", "Mo,We,Fr", "Mo,We,Fr,Sa",
    "Mo,We,Fr,Sa,Su", "Mo,We,Fr,Su", "Mo,We,Sa", "Mo,We,Sa,Su", "Mo,We,Su", "Mo,Th",
    "Mo,Th,Fr", "Mo,Th,Fr,Sa", "Mo,Th,Fr,Sa,Su", "Mo,Th,Fr,Su", "Mo,Th,Sa",
    "Mo,Th,Sa,Su", "Mo,Th,Su", "Mo,Fr", "Mo,Fr,Sa", "Mo,Fr,Sa,Su", "Mo,Fr,Su", "Mo,Sa",
    "Mo,Sa,Su", "Mo,Su",
    "MoSch", "MoSch,TuSch", "MoSch,TuSch,WeSch", "MoSch,TuSch,WeSch,ThSch", "MoSch,TuSch,WeSch,FrSch",
    "MoSch,TuSch,ThSch", "MoSch,TuSch,ThSch,FrSch", "MoSch,TuSch,FrSch", "MoSch,WeSch",
    "MoSch,WeSch,ThSch", "MoSch,WeSch,ThSch,FrSch", "MoSch,WeSch,FrSch", "MoSch,ThSch",
    "MoSch,ThSch,FrSch", "MoSch,FrSch",
    "MoNSD", "MoNSD,TuNSD", "MoNSD,TuNSD,WeNSD", "MoNSD,TuNSD,WeNSD,ThNSD", "MoNSD,TuNSD,WeNSD,FrNSD",
    "MoNSD,TuNSD,ThNSD", "MoNSD,TuNSD,ThNSD,FrNSD", "MoNSD,TuNSD,FrNSD", "MoNSD,WeNSD",
    "MoNSD,WeNSD,ThNSD", "MoNSD,WeNSD,ThNSD,FrNSD", "MoNSD,WeNSD,FrNSD", "MoNSD,ThNSD",
    "MoNSD,ThNSD,FrNSD", "MoNSD,FrNSD",
    "Tu", "Tu,We", "Tu,We,Th", "Tu,We,Th,Fr", "Tu,We,Th,Fr,Sa", "Tu,We,Th,Fr,Sa,Su",
    "Tu,We,Th,Fr,Su", "Tu,We,Th,Sa", "Tu,We,Th,Sa,Su", "Tu,We,Th,Su", "Tu,We,Fr",
    "Tu,We,Fr,Sa", "Tu,We,Fr,Sa,Su", "Tu,We,Fr,Su", "Tu,We,Sa", "Tu,We,Sa,Su", "Tu,We,Su",
    "Tu,Th", "Tu,Th,Fr", "Tu,Th,Fr,Sa", "Tu,Th,Fr,Sa,Su", "Tu,Th,Fr,Su", "Tu,Th,Sa",
    "Tu,Th,Sa,Su", "Tu,Th,Su", "Tu,Fr", "Tu,Fr,Sa", "Tu,Fr,Sa,Su", "Tu,Fr,Su", "Tu,Sa",
    "Tu,Sa,Su", "Tu,Su",
    "TuSch", "TuSch,WeSch", "TuSch,WeSch,ThSch", "TuSch,WeSch,FrSch", "TuSch,ThSch", "TuSch,ThSch,FrSch",
    "TuSch,FrSch",
    "TuNSD", "TuNSD,WeNSD", "TuNSD,WeNSD,ThNSD", "TuNSD,WeNSD,ThNSD,FrNSD", "TuNSD,WeNSD,FrNSD",
    "TuNSD,ThNSD", "TuNSD,ThNSD,FrNSD", "TuNSD,FrNSD",
    "We", "We,Th", "We,Th,Fr", "We,Th,Fr,Sa", "We,Th,Fr,Sa,Su", "We,Th,Fr,Su", "We,Th,Sa",
    "We,Th,Sa,Su", "We,Th,Su", "We,Fr", "We,Fr,Sa", "We,Fr,Sa,Su", "We,Fr,Su", "We,Sa",
    "We,Sa,Su", "We,Su",
    "WeSch", "WeSch,ThSch", "WeSch,ThSch,FrSch", "WeSch,FrSch",
    "WeNSD", "WeNSD,ThNSD", "WeNSD,ThNSD,FrNSD", "WeNSD,FrNSD",
    "Th", "Th,Fr", "Th,Fr,Sa", "Th,Fr,Sa,Su", "Th,Fr,Su", "Th,Sa", "Th,Sa,Su", "Th,Su",
    "ThSch", "ThSch,FrSch",
    "ThNSD", "ThNSD,FrNSD",
    "Fr", "Fr,Sa", "Fr,Sa,Su", "Fr,Su",
    "FrSch", "FrNSD",
    "MF", "MF,Sa", "MF,Sa,Su", "MF,Su",
    "MFSch", "MFNSD",
    "Sa", "Sa,Su",
    "Su",
    "Christmas Eve", "Christmas Eve,Sa",
    "Christmas Day",
    "Boxing Day", "Boxing Day,Sa,Su",
    "New Years Eve", "New Years Eve,Sa",
    "New Years Day", "New Years Day,Su",
    "Special",
    "SpMo",
    "SpTu",
    "SpWe",
    "SpTh",
    "SpFr",
    "SpSa",
    "SpSu"
];

// Helper function for DPO (can be identical to rsg_getCanonicalProfileString)
function dpo_getCanonicalProfileString_ExtraPage(profileArray) {
    if (!Array.isArray(profileArray)) return "";
    return profileArray.map(p => String(p).trim()).sort((a,b) => a.localeCompare(b)).join(',');
}

// Create the Set for DPO valid combinations
const DPO_VALID_PROFILE_COMBINATIONS_SET = new Set(
    DPO_MASTER_VALID_PROFILE_COMBINATIONS_LIST.map(s => dpo_getCanonicalProfileString_ExtraPage(s.split(',')))
);

function showNativeNotification(title, body, iconUrl = '/live-tracker/assets/icons/icon-192x192.png') {
    if (!("Notification" in window)) {
        console.warn("Desktop notifications not supported by this browser.");
        // Optionally, call your popup here as a fallback if browser doesn't support Notification API
        // if (typeof showTripAlertPopup_ExtraPage === 'function') { showTripAlertPopup_ExtraPage(title + ": " + body); }
        return;
    }
    if (Notification.permission === "granted") {
        try {
            const options = {
                body: body,
                // Ensure the icon path is correct and accessible from your domain.
                // If unsure, test with icon: undefined or icon: '' first.
                icon: iconUrl || undefined 
            };
            const notification = new Notification(title, options);

            // You can add event listeners to the notification if needed
            // notification.onclick = () => { console.log('Notification clicked'); window.focus(); this.close(); };
        } catch (e) {
            console.error("Error creating native notification:", e);
            // Fallback to the popup if native notification fails (e.g., bad icon, browser issue)
            if (typeof showTripAlertPopup_ExtraPage === 'function') {
                showTripAlertPopup_ExtraPage(`Native Notification Error: ${title} - ${body}. Details: ${e.message}`);
            }
        }
    } else {
        // If permission isn't granted, it means the conditions in checkAndShowTripAlerts_ExtraPage
        // should have already routed to the popup. This is an extra check.
        console.warn("Native notification requested, but permission is not 'granted'. Current permission: " + Notification.permission);
        // Optionally, show the popup here too if it's an unexpected state
        // if (typeof showTripAlertPopup_ExtraPage === 'function') { showTripAlertPopup_ExtraPage(title + ": " + body + " (Permission: " + Notification.permission + ")");}
    }
}

function dpo_simulateAutoGroup_ExtraPage(selectedProfilesArray) {
    let simulatedSelections = [...selectedProfilesArray]; 
    // Use DPO_PROFILE_GROUPS_TO_MANAGE defined above
    DPO_PROFILE_GROUPS_TO_MANAGE.forEach(group => { 
        const allIndividualsPresent = group.individuals.every(ind => simulatedSelections.includes(ind));
        if (allIndividualsPresent) {
            // If all individuals in a group are selected, replace them with the group profile
            simulatedSelections = simulatedSelections.filter(p => !group.individuals.includes(p)); 
            if (!simulatedSelections.includes(group.groupProfile)) {
                simulatedSelections.push(group.groupProfile); 
            }
        }
        // If a group profile is selected, ensure individuals are not also in the simulated selection
        // (This part of logic might need refinement based on desired DPO behavior vs RSG)
        // For DPO, typically you select what you want, and grouping might be less about auto-checking
        // and more about what the final "effective" profile string is.
        // If DPO_PROFILE_GROUPS_TO_MANAGE is empty, this loop does nothing.
    });
    return simulatedSelections; // Return the (potentially modified) array of selected profiles
}

// Helper function to create a canonical string (sorted, comma-separated)
function rsg_getCanonicalProfileString(profileArray) {
    if (!Array.isArray(profileArray)) return "";
    return profileArray.map(p => String(p).trim()).sort((a,b) => a.localeCompare(b)).join(',');
}

const VALID_PROFILE_COMBINATIONS_SET = new Set(
    MASTER_VALID_PROFILE_COMBINATIONS_LIST_EXTRA.map(s => rsg_getCanonicalProfileString(s.split(',')))
);

function rsg_showSaveConfigModal_ExtraPage() {
    const routeNameInput = rsgRouteNameInput_el_extra;
    const destinationNameInput = rsgDestinationNameInput_el_extra;
    // rsg_getSelectedOpProfilesString_ExtraPage() will be called to get current profiles
    const configNameInput = document.getElementById('rsg-config-name-input-extra');
    const modal = document.getElementById('rsg-save-config-modal-extra');
    const modalStatus = document.getElementById('rsg-save-config-modal-status-extra');

    if (!routeNameInput || !destinationNameInput || !configNameInput || !modal || !modalStatus) {
        console.error("RSG Save Modal Error: One or more essential DOM elements are missing.");
        if (rsgStatusMessage_el_extra) { 
            rsgStatusMessage_el_extra.textContent = "Error: Save dialog components missing.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const currentRouteName = routeNameInput.value.trim();
    const currentDestName = destinationNameInput.value.trim();
    const currentOpProfiles = rsg_getSelectedOpProfilesString_ExtraPage();

    if (!currentRouteName || !currentDestName || !currentOpProfiles) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route, Destination, and at least one Operating Profile must be selected to suggest a name for saving.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    
    if (!rsg_selectedStops_extra || rsg_selectedStops_extra.length === 0 || !rsgFirstStopTimesInput_el_extra || !rsgFirstStopTimesInput_el_extra.value.trim()) {
       if (rsgStatusMessage_el_extra) {
           rsgStatusMessage_el_extra.textContent = "Stop Sequence and First Stop Times are required to save a configuration.";
           rsgStatusMessage_el_extra.style.color = "#f1c40f";
       }
       return;
   }

    let defaultConfigName;

    if (rsg_currentlyEditingConfigKey_extra && rsg_currentlyEditingConfigDisplayName_extra) {
        defaultConfigName = rsg_currentlyEditingConfigDisplayName_extra;
    } else {
        const defaultNameRoutePart = currentRouteName.replace(/[^a-zA-Z0-9\s,-]/g, '').trim() || "Route";
        const defaultNameDestPart = currentDestName.replace(/[^a-zA-Z0-9\s,-]/g, '').trim() || "Dest";
        const defaultNameProfilePart = currentOpProfiles.replace(/[^a-zA-Z0-9\s,-]/g, '').trim() || "Profile";
        defaultConfigName = `${defaultNameRoutePart} to ${defaultNameDestPart} - ${defaultNameProfilePart}`;
    }

    configNameInput.value = defaultConfigName;
    if (modalStatus) { // Ensure modalStatus element exists before setting its properties
        modalStatus.textContent = ''; 
        modalStatus.style.color = ''; // Reset color
    }
    modal.style.display = 'flex';
}

function rsg_hideSaveConfigModal_ExtraPage() {
    const modal = document.getElementById('rsg-save-config-modal-extra');
    if (modal) modal.style.display = 'none';
}

async function saveSpecificRouteDataToFirebase_ExtraPage(targetRouteName) {
    if (!currentUser_extra || !window.firebaseOMSI || !window.firebaseOMSI.database) {
        console.error("saveSpecificRouteDataToFirebase_ExtraPage: Not logged in or Firebase not available.");
        // Potentially update a status message for the user
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Error: Cannot save route - not logged in or Firebase connection issue.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        throw new Error("Authentication or Firebase connection issue.");
    }

    const { database, dbSet, dbRef, dbRemove } = window.firebaseOMSI; // Ensure dbRemove is destructured
    const saneRouteToUpdate = sanitizeFirebaseKey(targetRouteName); // Assuming sanitizeFirebaseKey is globally available
    const routePathInFirebase = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRouteToUpdate}`;

    console.log(`saveSpecificRouteDataToFirebase_ExtraPage: Preparing to update route "${targetRouteName}" (sanitized: "${saneRouteToUpdate}") in Firebase.`);

    // Filter currentWorkingSchedule_extra to get all entries ONLY for the targetRouteName
    const entriesForThisRoute = currentWorkingSchedule_extra.filter(
        e => e.lineName && e.lineName.toUpperCase() === targetRouteName.toUpperCase()
    );

    if (entriesForThisRoute.length === 0) {
        // If the route now has no entries (e.g., user deleted all its schedules via RSG overwrite with empty)
        // then we should delete this route's node in Firebase.
        console.log(`Route "${targetRouteName}" has no schedule entries in currentWorkingSchedule_extra. Removing its node from Firebase at ${routePathInFirebase}.`);
        try {
            await dbRemove(dbRef(database, routePathInFirebase));
            console.log(`Successfully removed node for route "${targetRouteName}" from Firebase.`);
        } catch (error) {
            console.error(`Error removing node for empty route "${targetRouteName}" from Firebase:`, error);
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Error clearing empty route "${targetRouteName}" in Firebase: ${error.message}`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            // We should still proceed to update ancillary data even if removal fails,
            // as the local schedule (which ancillary data is based on) reflects the route as empty.
        }
    } else {
        // Build the structured data for this specific route
        const routeDataForFirebase = {}; // This will hold { profileKey: { destKey: { entries: [] } } }

        entriesForThisRoute.forEach(entry => {
            // Ensure necessary fields are present for structuring
            if (!entry.OperatingProfile || !entry.destinationName) {
                console.warn("saveSpecificRouteDataToFirebase_ExtraPage: Skipping entry with missing OperatingProfile or destinationName:", entry);
                return;
            }
            const saneProfile = sanitizeFirebaseKey(entry.OperatingProfile);
            const saneDest = sanitizeFirebaseKey(entry.destinationName);

            if (!routeDataForFirebase[saneProfile]) {
                routeDataForFirebase[saneProfile] = {};
            }
            if (!routeDataForFirebase[saneProfile][saneDest]) {
                routeDataForFirebase[saneProfile][saneDest] = { entries: [] };
            }

            const entryForStorage = { ...entry };
            // Ensure these key fields are explicitly part of the stored entry object
            entryForStorage.lineName = entry.lineName;
            entryForStorage.OperatingProfile = entry.OperatingProfile;
            entryForStorage.destinationName = entry.destinationName;

            routeDataForFirebase[saneProfile][saneDest].entries.push(entryForStorage);
        });

        // Sort entries within each R/P/D for consistency
        for (const profileKey in routeDataForFirebase) {
            for (const destKey in routeDataForFirebase[profileKey]) {
                if (routeDataForFirebase[profileKey][destKey].entries) {
                    routeDataForFirebase[profileKey][destKey].entries.sort((a, b) => {
                        const timeA = (a.scheduledTime || "9999").replace(':', '');
                        const timeB = (b.scheduledTime || "9999").replace(':', '');
                        const timeCompare = timeA.localeCompare(timeB);
                        if (timeCompare !== 0) return timeCompare;
                        return (a.stopName || "").localeCompare(b.stopName || ""); // Secondary sort
                    });
                }
            }
        }
        
        console.log(`Attempting to save data for route "${targetRouteName}" to Firebase path: ${routePathInFirebase}`);
        try {
            await dbSet(dbRef(database, routePathInFirebase), routeDataForFirebase);
            console.log(`Successfully saved data for route "${targetRouteName}" to Firebase.`);
        } catch (error) {
             console.error(`Error saving data for route "${targetRouteName}" to Firebase:`, error);
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Error saving route "${targetRouteName}" to Firebase: ${error.message}`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            throw error; // Propagate error to the caller
        }
    }

    // After saving the specific route (or removing it if empty),
    // always update ancillary data based on the full currentWorkingSchedule_extra
    try {
        console.log(`Updating ancillary data after changes to route "${targetRouteName}".`);
        await updateAncillaryScheduleData_ExtraPage(); // This function should be async
        console.log(`Ancillary data updated successfully.`);
    } catch (error) {
        console.error(`Error updating ancillary data after saving route "${targetRouteName}":`, error);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Route data saved, but error updating ancillary data (like unique stops): ${error.message}`;
            // Keep the color as potentially error, or change to warning
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // Decide if this error should also be propagated
    }
}

async function rsg_performSaveConfiguration_ExtraPage() {
            console.log("RSG Save Process: Triggered.");
            const configNameInput = document.getElementById('rsg-config-name-input-extra');
            const modalStatus = document.getElementById('rsg-save-config-modal-status-extra');

            if (!configNameInput || !modalStatus) { /* ... error handling ... */ return; }

            const userDefinedConfigName = configNameInput.value.trim();
            if (!userDefinedConfigName) { /* ... error handling ... */ return; }

            console.log(`RSG Save Process: Modal name: "${userDefinedConfigName}". Currently Editing Key: '${rsg_currentlyEditingConfigKey_extra}', DisplayName: '${rsg_currentlyEditingConfigDisplayName_extra}'`);

            let firebaseKey = null;
            let operationType = ""; 
            // ... (your existing logic for determining firebaseKey and operationType) ...
            if (rsg_currentlyEditingConfigKey_extra && userDefinedConfigName === rsg_currentlyEditingConfigDisplayName_extra) {
                firebaseKey = rsg_currentlyEditingConfigKey_extra;
                operationType = "overwrite_loaded_config";
            } else { /* ... logic to findMatchForKey or create new ... */ 
                let foundMatchForKey = null;
                for (const keyInCache in rsg_loadedConfigs_extra) {
                    if (Object.hasOwnProperty.call(rsg_loadedConfigs_extra, keyInCache)) {
                        const existingConfig = rsg_loadedConfigs_extra[keyInCache];
                        if (existingConfig.userDisplayName === userDefinedConfigName) {
                            foundMatchForKey = keyInCache; break;
                        }
                    }
                }
                if (foundMatchForKey) {
                    firebaseKey = foundMatchForKey; operationType = "overwrite_other_by_display_name";
                } else {
                    firebaseKey = sanitizeFirebaseKey(userDefinedConfigName); operationType = "save_new_config";
                }
            }
            console.log(`RSG Save Process: Operation determined: ${operationType}, Firebase Key: ${firebaseKey}`);
            if (!firebaseKey) { /* ... error handling ... */ return; }
            
            // Synchronization step (ensure this accurately reflects the current UI for time adjustments)
            // The 'input' listeners on timeAdjInput should have already updated rsg_selectedStops_extra items.
            // This block can serve as a final explicit sync if needed, or can be simplified if array is trusted.
            console.log("RSG Save Process: Beginning final sync of time adjustments from UI to rsg_selectedStops_extra array.");
            if (rsgStopSequenceList_el_extra && rsg_selectedStops_extra) {
                const displayedStopItems = rsgStopSequenceList_el_extra.querySelectorAll('li[data-index]');
                displayedStopItems.forEach(li => {
                    const index = parseInt(li.dataset.index);
                    if (rsg_selectedStops_extra[index]) {
                        if (index === 0) { 
                            if(rsg_selectedStops_extra[index].timeAdjustment !== 0) rsg_selectedStops_extra[index].timeAdjustment = 0;
                        } else {
                            const timeAdjInput = li.querySelector('.rsg-time-adjustment-input');
                            if (timeAdjInput) {
                                const uiValue = parseInt(timeAdjInput.value, 10);
                                const currentArrayValue = rsg_selectedStops_extra[index].timeAdjustment;
                                if (!isNaN(uiValue) && uiValue >= 0) {
                                    if (currentArrayValue !== uiValue) {
                                        console.log(`RSG Save Sync: Updating index ${index} from UI value ${uiValue} (was ${currentArrayValue})`);
                                        rsg_selectedStops_extra[index].timeAdjustment = uiValue;
                                    }
                                } else {
                                    if (currentArrayValue !== 0) {
                                        console.log(`RSG Save Sync: Invalid UI value for index ${index} ("${timeAdjInput.value}"), setting to 0 (was ${currentArrayValue})`);
                                        rsg_selectedStops_extra[index].timeAdjustment = 0;
                                    }
                                }
                            } else if (typeof rsg_selectedStops_extra[index].timeAdjustment === 'undefined' || rsg_selectedStops_extra[index].timeAdjustment === null) {
                                 console.log(`RSG Save Sync: No input or undefined adjustment for index ${index}, setting to 0.`);
                                rsg_selectedStops_extra[index].timeAdjustment = 0; 
                            }
                        }
                    }
                });
            }
            console.log("RSG Save Process: Finished final sync of time adjustments.");

            const currentRouteName = rsgRouteNameInput_el_extra.value.trim();
            const currentDestName = rsgDestinationNameInput_el_extra.value.trim();
            const currentOpProfiles = rsg_getSelectedOpProfilesString_ExtraPage();
            const stopSequenceToSave = rsg_selectedStops_extra; // This array should reflect removed stops and time edits
            const firstStopTimesToSave = rsgFirstStopTimesInput_el_extra.value.trim();

            // Detailed logging of what's about to be saved
            console.log("RSG Save Process: Data to be packaged for Firebase:");
            console.log(`  - User Display Name: "${userDefinedConfigName}"`);
            console.log(`  - Route Name: "${currentRouteName}"`);
            console.log(`  - Dest Name: "${currentDestName}"`);
            console.log(`  - Op Profiles: "${currentOpProfiles}"`);
            console.log(`  - First Stop Times: "${firstStopTimesToSave}"`);
            console.log(`  - Stop Sequence Length: ${stopSequenceToSave.length}`);
            console.log("  - Stop Sequence (sample - first 5, with ID, Name, Adjustment):", 
                stopSequenceToSave.slice(0,5).map(s => ({id:s.stopID, name:s.stopName, adj:s.timeAdjustment}))
            );

            if (!currentRouteName || !currentDestName || !currentOpProfiles || stopSequenceToSave.length === 0 || !firstStopTimesToSave) {
                modalStatus.textContent = "Cannot save: All fields (Route, Dest, Profile, Sequence, Times) are required.";
                modalStatus.style.color = "#e74c3c";
                return;
            }

            const configurationToSave = {
                userDisplayName: userDefinedConfigName, 
                routeName: currentRouteName,
                destinationName: currentDestName,
                operatingProfile: currentOpProfiles,
                stopSequence: JSON.parse(JSON.stringify(stopSequenceToSave)), 
                firstStopTimes: firstStopTimesToSave,
                lastSaved: new Date().toISOString()
            };
            
            modalStatus.textContent = `Saving configuration "${userDefinedConfigName}"...`;
            // ... (Firebase save logic as before) ...
            const { database, dbSet, dbRef } = window.firebaseOMSI;
            try {
                const fullSavePath = `${FB_PATH_RSG_CONFIGS}/${firebaseKey}`;
                await dbSet(dbRef(database, fullSavePath), configurationToSave);
                
                rsg_loadedConfigs_extra[firebaseKey] = JSON.parse(JSON.stringify(configurationToSave)); 
                rsg_renderSavedConfigsList_ExtraPage(); 

                modalStatus.textContent = `Configuration "${userDefinedConfigName}" saved successfully!`;
                // ... (status updates and context variable updates as before) ...
                rsg_currentlyEditingConfigKey_extra = firebaseKey;
                rsg_currentlyEditingConfigDisplayName_extra = userDefinedConfigName;
                rsg_lastLoadedRouteName_extra = currentRouteName;
                rsg_lastLoadedDestName_extra = currentDestName;
                rsg_lastLoadedOpProfile_extra = currentOpProfiles;
                
                rsg_isDirty = false; 
                console.log("RSG State: Configuration saved successfully, rsg_isDirty reset to false.");

                setTimeout(rsg_hideSaveConfigModal_ExtraPage, 1500);
            } catch (error) {
                // ... (error handling as before) ...
                console.error("Error saving RSG configuration to Firebase:", error);
                modalStatus.textContent = "Error saving configuration: " + error.message;
            }
        }

async function rsg_performRenameConfiguration_ExtraPage(configKeyToRename, newDisplayName) {
    const statusElement = document.getElementById('rsg-load-status-message-extra'); // Use the status message for the saved configs list

    if (!configKeyToRename) {
        if (statusElement) {
            statusElement.textContent = "Error: No configuration key provided for renaming.";
            statusElement.style.color = "#e74c3c";
        }
        console.error("rsg_performRenameConfiguration_ExtraPage: configKeyToRename is missing.");
        return;
    }

    // newDisplayName is assumed to be non-empty and trimmed by the caller
    // If it could still be empty, an additional check here would be good. For now, we assume caller handles it.

    const configToUpdate = rsg_loadedConfigs_extra[configKeyToRename];
    if (!configToUpdate) {
        if (statusElement) {
            statusElement.textContent = "Error: Original configuration data could not be found. Cannot rename.";
            statusElement.style.color = "#e74c3c";
        }
        console.error(`Failed to find config data for key: ${configKeyToRename} in rsg_loadedConfigs_extra.`);
        return;
    }

    if (statusElement) {
        statusElement.textContent = `Renaming configuration to "${newDisplayName}"...`;
        statusElement.style.color = "#f1c40f";
    }

    const updatedConfigData = {
        ...configToUpdate,
        userDisplayName: newDisplayName, // Already trimmed by caller
        lastSaved: new Date().toISOString()
    };

    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        await dbSet(dbRef(database, `${FB_PATH_RSG_CONFIGS}/${configKeyToRename}`), updatedConfigData);
        rsg_loadedConfigs_extra[configKeyToRename] = updatedConfigData; // Update local cache
        rsg_renderSavedConfigsList_ExtraPage(); // Refresh the displayed list

        if (statusElement) {
            statusElement.textContent = `Configuration successfully renamed to "${newDisplayName}"!`;
            statusElement.style.color = "#2ecc71";
        }
        // No modal to hide anymore for this process
    } catch (error) {
        console.error("Error renaming RSG configuration in Firebase:", error);
        if (statusElement) {
            statusElement.textContent = "Error renaming configuration: " + error.message;
            statusElement.style.color = "#e74c3c";
        }
    }
}

function toTitleCase_rsg(str) {
    if (!str || typeof str !== 'string') return "";
    // This will convert "LAKESIDE" to "Lakeside", "HIGH STREET" to "High Street", etc.
    return str.replace(/\w\S*/g, function(txt){
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
}

function rsg_handleSavedConfigCheckboxChange_ExtraPage() {
    const checkboxes = document.querySelectorAll('.rsg-saved-config-checkbox');
    const tickedCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox:checked');
    const tickedCount = tickedCheckboxes.length;

    if (rsgScheduleSelectedConfigsButton_el_extra) {
        rsgScheduleSelectedConfigsButton_el_extra.disabled = (tickedCount === 0);
    }

    const disableMainActions = tickedCount > 1;

    if (rsgGenerateScheduleButton_el_extra) {
        rsgGenerateScheduleButton_el_extra.disabled = disableMainActions;
    }
    if (rsgSaveConfigurationButton_el_extra) {
        rsgSaveConfigurationButton_el_extra.disabled = disableMainActions;
    }
    if (rsgAddToWorkingScheduleButton_el_extra) {
        if (disableMainActions) {
            rsgAddToWorkingScheduleButton_el_extra.disabled = true;
            rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
            rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
        } else {
            const previewExistsForMainForm = rsg_generatedPreviewEntries_extra && rsg_generatedPreviewEntries_extra.length > 0;
            rsgAddToWorkingScheduleButton_el_extra.disabled = !previewExistsForMainForm;
             if (previewExistsForMainForm) {
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.add('save');
            } else {
                rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
            }
        }
    }
    rsg_updateSelectAllCheckboxesStates();
}

async function rsg_handleScheduleSelectedConfigs_ExtraPage() {
    console.log("Batch Scheduling: Starting for selected saved configs.");
    if (!currentUser_extra) {
        alert("Please log in to schedule configurations.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Please log in.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const tickedCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox:checked');
    if (tickedCheckboxes.length === 0) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "No saved configurations selected to schedule.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    rsg_batchScheduleItems = []; // Clear previous batch items
    let validConfigsForBatchCount = 0;
    let firstInvalidConfigName = null;

    for (const checkbox of tickedCheckboxes) {
        const configKey = checkbox.dataset.configKey;
        const configData = rsg_loadedConfigs_extra[configKey];

        if (configData) {
            // Validate this config by trying to generate its preview entries (isPreCheck = true)
            // rsg_handleGenerateSchedulePreview_ExtraPage will populate rsg_generatedPreviewEntries_extra
            if (rsg_handleGenerateSchedulePreview_ExtraPage(true, configData)) {
                rsg_batchScheduleItems.push({
                    configKey: configKey, // Keep key for reference
                    userDisplayName: configData.userDisplayName || configKey,
                    routeName: configData.routeName,
                    destinationName: configData.destinationName,
                    operatingProfile: configData.operatingProfile,
                    stopSequence: JSON.parse(JSON.stringify(configData.stopSequence)), // Deep copy
                    firstStopTimes: configData.firstStopTimes,
                    scheduledEntries: JSON.parse(JSON.stringify(rsg_generatedPreviewEntries_extra)) // Crucial: copy the generated entries for this config
                });
                validConfigsForBatchCount++;
            } else {
                console.warn(`Batch Scheduling: Config "${configData.userDisplayName || configKey}" is invalid or produced no entries. Skipping.`);
                if (!firstInvalidConfigName) firstInvalidConfigName = configData.userDisplayName || configKey;
            }
        } else {
            console.warn(`Batch Scheduling: Could not find config data for key ${configKey}. Skipping.`);
             if (!firstInvalidConfigName) firstInvalidConfigName = `Key: ${configKey}`;
        }
    }
    
    // Clear the global preview entries after batch processing is done, so it doesn't interfere with main form.
    rsg_generatedPreviewEntries_extra = [];

    if (rsg_batchScheduleItems.length > 0) {
        const scheduleModal = document.getElementById('rsg-schedule-datetime-modal-extra');
        if (scheduleModal) {
            const modalStatus = document.getElementById('rsg-schedule-datetime-modal-status-extra');
            if (modalStatus) {
                 modalStatus.textContent = `Preparing to schedule ${rsg_batchScheduleItems.length} configuration(s). ${firstInvalidConfigName ? `Some (${tickedCheckboxes.length - validConfigsForBatchCount}) were skipped due to issues (e.g., ${firstInvalidConfigName}).` : ''}`;
                 modalStatus.style.color = firstInvalidConfigName ? "#f1c40f" : ""; // Yellow if some skipped
            }
            
            const goLiveInput = document.getElementById('rsg-go-live-datetime-input-extra');
            if (goLiveInput) { // Set default go-live time
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(5, 0, 0, 0); // Default 05:00 AM
                goLiveInput.value = `${tomorrow.getFullYear()}-${String(tomorrow.getMonth() + 1).padStart(2, '0')}-${String(tomorrow.getDate()).padStart(2, '0')}T${String(tomorrow.getHours()).padStart(2, '0')}:${String(tomorrow.getMinutes()).padStart(2, '0')}`;
            }
            scheduleModal.style.display = 'flex';
        } else {
            console.error("Batch Scheduling: Schedule DateTime modal not found!");
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Error: Scheduling modal component is missing.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
        }
    } else {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `No valid configurations to schedule. ${firstInvalidConfigName ? `Problem with "${firstInvalidConfigName}".` : 'Please check selected items.'}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
    }
}

function rsg_renderSavedConfigsList_ExtraPage() {
    const container = document.getElementById('rsg-saved-configs-list-extra');
    if (!container) {
        return;
    }
    container.innerHTML = '';

    const activeRouteNamesFromSchedule = [...new Set(
        currentWorkingSchedule_extra
            .map(entry => entry.lineName)
            .filter(Boolean)
    )];

    const configsByRouteFromSaved = {};
    if (rsg_loadedConfigs_extra && typeof rsg_loadedConfigs_extra === 'object') {
        Object.keys(rsg_loadedConfigs_extra).forEach(key => {
            const configData = rsg_loadedConfigs_extra[key];
            const routeNameFromConfig = configData.routeName || "Unspecified Route";
            if (!configsByRouteFromSaved[routeNameFromConfig]) {
                configsByRouteFromSaved[routeNameFromConfig] = [];
            }
            configsByRouteFromSaved[routeNameFromConfig].push({ key: key, data: configData });
        });
    }

    const allRouteNamesToDisplaySet = new Set([
        ...activeRouteNamesFromSchedule,
        ...Object.keys(configsByRouteFromSaved).filter(rn => rn !== "Unspecified Route")
    ]);
    const sortedAllRouteNamesToDisplay = Array.from(allRouteNamesToDisplaySet).sort(compareLineNames_ExtraPage);

    if (sortedAllRouteNamesToDisplay.length === 0 && !(configsByRouteFromSaved["Unspecified Route"] && configsByRouteFromSaved["Unspecified Route"].length > 0)) {
        const p = document.createElement('p');
        p.id = "rsg-no-saved-configs-message-extra";
        p.style.padding = "0.5em";
        p.style.textAlign = "center";
        p.style.opacity = "0.7";
        p.textContent = "No active routes in schedule and no configurations saved yet.";
        container.appendChild(p);
        rsg_updateSelectAllCheckboxesStates(); // Update even if no items
        return;
    }

    sortedAllRouteNamesToDisplay.forEach(routeName => {
        const routeHeadingContainer = document.createElement('div');
        routeHeadingContainer.style.display = 'flex';
        routeHeadingContainer.style.alignItems = 'center';
        routeHeadingContainer.style.marginTop = "0.8em";
        routeHeadingContainer.style.marginBottom = "0.4em";
        routeHeadingContainer.style.borderBottom = "1px solid rgba(127,140,141,0.3)";
        routeHeadingContainer.style.paddingBottom = "0.2em";
         if (container.children.length > 0 && container.lastChild.tagName !== 'H4' && container.lastChild.firstChild?.tagName !== 'H4') { // check if previous was not a heading
            routeHeadingContainer.style.marginTop = "1.2em";
        }


        const routeSelectAllCheckbox = document.createElement('input');
        routeSelectAllCheckbox.type = 'checkbox';
        routeSelectAllCheckbox.classList.add('rsg-select-route-configs-checkbox-extra');
        routeSelectAllCheckbox.dataset.routeName = routeName;
        routeSelectAllCheckbox.style.marginRight = '8px';
        routeSelectAllCheckbox.style.verticalAlign = 'middle';
        routeSelectAllCheckbox.addEventListener('change', rsg_handleSelectRouteConfigsChange_ExtraPage);
        routeHeadingContainer.appendChild(routeSelectAllCheckbox);

        const routeHeading = document.createElement('h4');
        routeHeading.textContent = `Route ${routeName}:`;
        routeHeading.style.margin = "0"; // Reset margin as it's inside a flex container
        routeHeading.style.fontSize = "1.1em";
        routeHeading.style.color = "#ecf0f1";
        routeHeadingContainer.appendChild(routeHeading);
        container.appendChild(routeHeadingContainer);

        const configsForThisRoute = configsByRouteFromSaved[routeName];

        if (configsForThisRoute && configsForThisRoute.length > 0) {
            configsForThisRoute.sort((a, b) => {
                const nameA = (a.data.userDisplayName || a.key).toLowerCase();
                const nameB = (b.data.userDisplayName || b.key).toLowerCase();
                const nameCompare = nameA.localeCompare(nameB);
                if (nameCompare !== 0) return nameCompare;
                const destA = a.data.destinationName || "";
                const destB = b.data.destinationName || "";
                return destA.localeCompare(destB);
            });

            configsForThisRoute.forEach(configItem => {
                const configKey = configItem.key;
                const configData = configItem.data;
                const originalUserDisplayName = configData.userDisplayName || configKey;
                const routeNameForDesc = configData.routeName || "N/A";
                let destinationNameForDesc = configData.destinationName || "N/A";
                if (destinationNameForDesc !== "N/A") {
                    destinationNameForDesc = toTitleCase_rsg(destinationNameForDesc);
                }
                let operatingProfileForDesc = configData.operatingProfile || "N/A";
                if (operatingProfileForDesc !== "N/A" && typeof operatingProfileForDesc === 'string') {
                    operatingProfileForDesc = operatingProfileForDesc.split(',')
                                                 .map(p => p.trim())
                                                 .join(', ');
                }
                const descriptiveParametersString = `${routeNameForDesc} to ${destinationNameForDesc} - ${operatingProfileForDesc}`;

                const itemDiv = document.createElement('div');
                itemDiv.style.padding = "0.4em 0.6em 0.4em 28px"; // Indent items under route's select all
                itemDiv.style.marginBottom = "0.3em";
                itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)";
                itemDiv.style.borderRadius = "0.25rem";
                itemDiv.style.display = "flex";
                itemDiv.style.justifyContent = "space-between";
                itemDiv.style.alignItems = "center";
                itemDiv.addEventListener('mouseover', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.1)");
                itemDiv.addEventListener('mouseout', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)");
                itemDiv.title = `Load: ${originalUserDisplayName}\n(Parameters: ${descriptiveParametersString})\n(Key: ${configKey})`;

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `rsg-config-checkbox-${configKey}`;
                checkbox.dataset.configKey = configKey;
                checkbox.dataset.parentRouteName = routeName; // Link to parent route for per-route select all
                checkbox.classList.add('rsg-saved-config-checkbox');
                checkbox.style.marginRight = '10px';
                checkbox.style.verticalAlign = 'middle';
                checkbox.addEventListener('change', rsg_handleSavedConfigCheckboxChange_ExtraPage);
                itemDiv.appendChild(checkbox);

                const nameSpan = document.createElement('span');
                nameSpan.textContent = originalUserDisplayName;
                nameSpan.style.flexGrow = "1";
                nameSpan.style.cursor = "pointer";
                nameSpan.addEventListener('click', () => rsg_handleLoadSelectedConfig_ExtraPage(configKey));
                itemDiv.appendChild(nameSpan);

                const actionButtonsDiv = document.createElement('div');
                actionButtonsDiv.style.display = 'flex';
                actionButtonsDiv.style.alignItems = 'center';

                const renameBtn = document.createElement('button');
                renameBtn.textContent = 'Rename';
                renameBtn.classList.add('button', 'small-action', 'neutral');
                renameBtn.style.marginRight = "0.3em";
                renameBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const statusElement = document.getElementById('rsg-load-status-message-extra');
                    if (statusElement) statusElement.textContent = "";
                    const newNameFromPrompt = prompt(`Enter new name for configuration currently named "${originalUserDisplayName}":`, originalUserDisplayName);
                    if (newNameFromPrompt === null) { }
                    else if (newNameFromPrompt.trim() === "") { }
                    else if (newNameFromPrompt.trim() === originalUserDisplayName) { }
                    else { rsg_performRenameConfiguration_ExtraPage(configKey, newNameFromPrompt.trim()); }
                });
                actionButtonsDiv.appendChild(renameBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '';
                deleteBtn.classList.add('button', 'small-action', 'secondary');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    rsg_handleDeleteSavedConfig_ExtraPage(configKey, originalUserDisplayName);
                });
                actionButtonsDiv.appendChild(deleteBtn);

                itemDiv.appendChild(actionButtonsDiv);
                container.appendChild(itemDiv);
            });
        } else {
            const noConfigsForRouteMsg = document.createElement('p');
            noConfigsForRouteMsg.textContent = "(No saved RSG configurations for this route)";
            noConfigsForRouteMsg.style.fontSize = "0.85em";
            noConfigsForRouteMsg.style.fontStyle = "italic";
            noConfigsForRouteMsg.style.opacity = "0.7";
            noConfigsForRouteMsg.style.paddingLeft = "28px"; // Indent message as well
            noConfigsForRouteMsg.style.marginBottom = "0.5em";
            container.appendChild(noConfigsForRouteMsg);
            routeSelectAllCheckbox.disabled = true; // Disable select all if no items for this route
        }
    });

    if (configsByRouteFromSaved["Unspecified Route"] && configsByRouteFromSaved["Unspecified Route"].length > 0) {
        const unspecifiedHeadingContainer = document.createElement('div');
        unspecifiedHeadingContainer.style.display = 'flex';
        unspecifiedHeadingContainer.style.alignItems = 'center';
        unspecifiedHeadingContainer.style.marginTop = "1.2em";
        unspecifiedHeadingContainer.style.marginBottom = "0.4em";
        unspecifiedHeadingContainer.style.borderBottom = "1px solid rgba(127,140,141,0.3)";
        unspecifiedHeadingContainer.style.paddingBottom = "0.2em";

        const unspecifiedSelectAllCheckbox = document.createElement('input');
        unspecifiedSelectAllCheckbox.type = 'checkbox';
        unspecifiedSelectAllCheckbox.classList.add('rsg-select-route-configs-checkbox-extra');
        unspecifiedSelectAllCheckbox.dataset.routeName = "Unspecified Route";
        unspecifiedSelectAllCheckbox.style.marginRight = '8px';
        unspecifiedSelectAllCheckbox.style.verticalAlign = 'middle';
        unspecifiedSelectAllCheckbox.addEventListener('change', rsg_handleSelectRouteConfigsChange_ExtraPage);
        unspecifiedHeadingContainer.appendChild(unspecifiedSelectAllCheckbox);

        const unspecifiedHeading = document.createElement('h4');
        unspecifiedHeading.textContent = "Route: Unspecified Route (from saved configs)";
        unspecifiedHeading.style.margin = "0";
        unspecifiedHeading.style.fontSize = "1.1em";
        unspecifiedHeading.style.color = "#ecf0f1";
        unspecifiedHeadingContainer.appendChild(unspecifiedHeading);
        container.appendChild(unspecifiedHeadingContainer);

        configsByRouteFromSaved["Unspecified Route"].forEach(configItem => {
             const configKey = configItem.key;
            const configData = configItem.data;
            const originalUserDisplayName = configData.userDisplayName || configKey;
            const descriptiveParametersString = `Unspecified Route - Profile: ${configData.operatingProfile || 'N/A'} - Dest: ${toTitleCase_rsg(configData.destinationName || 'N/A')}`;

            const itemDiv = document.createElement('div');
            itemDiv.style.padding = "0.4em 0.6em 0.4em 28px";
            itemDiv.style.marginBottom = "0.3em";
            itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)";
            itemDiv.style.borderRadius = "0.25rem";
            itemDiv.style.display = "flex";
            itemDiv.style.justifyContent = "space-between";
            itemDiv.style.alignItems = "center";
            itemDiv.addEventListener('mouseover', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.1)");
            itemDiv.addEventListener('mouseout', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)");
            itemDiv.title = `Load: ${originalUserDisplayName}\n(Parameters: ${descriptiveParametersString})\n(Key: ${configKey})`;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `rsg-config-checkbox-${configKey}`;
            checkbox.dataset.configKey = configKey;
            checkbox.dataset.parentRouteName = "Unspecified Route";
            checkbox.classList.add('rsg-saved-config-checkbox');
            checkbox.style.marginRight = '10px';
            checkbox.style.verticalAlign = 'middle';
            checkbox.addEventListener('change', rsg_handleSavedConfigCheckboxChange_ExtraPage);
            itemDiv.appendChild(checkbox);

            const nameSpan = document.createElement('span');
            nameSpan.textContent = originalUserDisplayName;
            nameSpan.style.flexGrow = "1";
            nameSpan.style.cursor = "pointer";
            nameSpan.addEventListener('click', () => rsg_handleLoadSelectedConfig_ExtraPage(configKey));
            itemDiv.appendChild(nameSpan);

            const actionButtonsDiv = document.createElement('div');
            actionButtonsDiv.style.display = 'flex';
            actionButtonsDiv.style.alignItems = 'center';

            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Rename';
            renameBtn.classList.add('button', 'small-action', 'neutral');
            renameBtn.style.marginRight = "0.3em";
            renameBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const statusElement = document.getElementById('rsg-load-status-message-extra');
                if (statusElement) statusElement.textContent = "";
                const newNameFromPrompt = prompt(`Enter new name for configuration currently named "${originalUserDisplayName}":`, originalUserDisplayName);
                if (newNameFromPrompt === null) {}
                else if (newNameFromPrompt.trim() === "") {}
                else if (newNameFromPrompt.trim() === originalUserDisplayName) {}
                else { rsg_performRenameConfiguration_ExtraPage(configKey, newNameFromPrompt.trim()); }
            });
            actionButtonsDiv.appendChild(renameBtn);

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = '';
            deleteBtn.classList.add('button', 'small-action', 'secondary');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                rsg_handleDeleteSavedConfig_ExtraPage(configKey, originalUserDisplayName);
            });
            actionButtonsDiv.appendChild(deleteBtn);

            itemDiv.appendChild(actionButtonsDiv);
            container.appendChild(itemDiv);
        });
         if (configsByRouteFromSaved["Unspecified Route"].length === 0) {
            unspecifiedSelectAllCheckbox.disabled = true;
        }
    }
    rsg_handleSavedConfigCheckboxChange_ExtraPage();
    rsg_updateSelectAllCheckboxesStates();
}

function rsg_handleSelectAllConfigsChange_ExtraPage() {
    const isChecked = rsgSelectAllConfigsCheckbox_el_extra.checked;
    const individualCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox');
    const perRouteCheckboxes = document.querySelectorAll('.rsg-select-route-configs-checkbox-extra');

    individualCheckboxes.forEach(cb => cb.checked = isChecked);
    perRouteCheckboxes.forEach(cb => {
        // Only check per-route if it's not disabled (i.e., has items under it)
        if (!cb.disabled) {
            cb.checked = isChecked;
        }
    });

    rsg_handleSavedConfigCheckboxChange_ExtraPage(); // Update main button states
}

function rsg_handleSelectRouteConfigsChange_ExtraPage(event) {
    const sourceCheckbox = event.target;
    const routeName = sourceCheckbox.dataset.routeName;
    const isChecked = sourceCheckbox.checked;

    const individualCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox');
    individualCheckboxes.forEach(cb => {
        if (cb.dataset.parentRouteName === routeName) {
            cb.checked = isChecked;
        }
    });

    rsg_updateSelectAllCheckboxesStates(); // Update global select all based on this change
    rsg_handleSavedConfigCheckboxChange_ExtraPage(); // Update main button states
}

function rsg_updateSelectAllCheckboxesStates() {
    // Update Per-Route "Select All" Checkboxes
    const perRouteCheckboxes = document.querySelectorAll('.rsg-select-route-configs-checkbox-extra');
    perRouteCheckboxes.forEach(perRouteCb => {
        if (perRouteCb.disabled) return; // Skip if it has no items

        const routeName = perRouteCb.dataset.routeName;
        const individualCheckboxesForRoute = document.querySelectorAll(`.rsg-saved-config-checkbox[data-parent-route-name="${routeName}"]`);
        
        if (individualCheckboxesForRoute.length > 0) {
            const allCheckedForRoute = Array.from(individualCheckboxesForRoute).every(cb => cb.checked);
            perRouteCb.checked = allCheckedForRoute;
        } else {
            perRouteCb.checked = false; // No items, so can't be "all checked"
        }
    });

    // Update Global "Select All (Everything)" Checkbox
    if (rsgSelectAllConfigsCheckbox_el_extra) {
        const allIndividualCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox');
        if (allIndividualCheckboxes.length > 0) {
            const allItemsCheckedOverall = Array.from(allIndividualCheckboxes).every(cb => cb.checked);
            rsgSelectAllConfigsCheckbox_el_extra.checked = allItemsCheckedOverall;
        } else {
            rsgSelectAllConfigsCheckbox_el_extra.checked = false; // No items to select
        }
    }
}

async function rsg_handleDeleteSavedConfig_ExtraPage(configKey, displayName) {
    if (!confirm(`Are you sure you want to delete the saved configuration: "${displayName}"? This cannot be undone.`)) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Deletion cancelled.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    if (!window.firebaseOMSI || !window.firebaseOMSI.database || !window.firebaseOMSI.dbGet) { // Added dbGet check
        alert("Firebase components not available. Cannot delete configuration.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Firebase components not available.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    // Make sure dbGet is correctly aliased as get if you use it directly like in the check below
    const { database, dbRemove, dbRef, dbGet: get } = window.firebaseOMSI; // Using alias 'get' for dbGet
    const configPath = `${FB_PATH_RSG_CONFIGS}/${configKey}`;

    if (rsgStatusMessage_el_extra) {
        rsgStatusMessage_el_extra.textContent = `Attempting to delete "${displayName}" (key: ${configKey}) from Firebase path: ${configPath}...`;
        rsgStatusMessage_el_extra.style.color = "#3498db"; // Blue for processing
    }
    console.log(`Attempting to delete from Firebase path: ${configPath}`);

    try {
        await dbRemove(dbRef(database, configPath));
        console.log(`Firebase dbRemove promise resolved for path: ${configPath}. Attempting to verify deletion from server...`);

        // VERIFICATION STEP: Try to fetch the data again immediately after deletion.
        // This helps confirm if the server actually processed the delete.
        const checkSnapshot = await get(dbRef(database, configPath)); // Using the aliased 'get'

        if (checkSnapshot.exists()) {
            // If it still exists, the delete didn't work on the server.
            console.error(`VERIFICATION FAILED: Config "${displayName}" (key: ${configKey}) still exists in Firebase at ${configPath} after dbRemove was called and resolved. This is unexpected.`);
            alert(`Error: Deletion for "${displayName}" appeared to succeed client-side, but the data is still present on the server. Please check Firebase rules for path "${FB_PATH_RSG_CONFIGS}" and its children, and network connectivity. Refreshing the list to reflect the server state.`);
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Deletion of "${displayName}" failed to persist on server. List refreshed.`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            // Force a reload of all RSG configs from Firebase to ensure UI matches the server.
            loadInitialData_ExtraPage(); // Or a more targeted reload for RSG configs if available
            return;
        } else {
            console.log(`VERIFICATION SUCCESS: Config "${displayName}" (key: ${configKey}) confirmed deleted from Firebase server path: ${configPath}.`);
        }

        // If verification passes (or if you skip verification), update local cache and UI.
        delete rsg_loadedConfigs_extra[configKey];
        rsg_renderSavedConfigsList_ExtraPage();

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Configuration "${displayName}" deleted successfully.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
        }

    } catch (error) { // This catch is for errors from dbRemove or the verification 'get'
        console.error(`Error during Firebase operation for configuration "${displayName}" (key: ${configKey}):`, error);
        alert(`Failed to delete configuration "${displayName}". Error: ${error.message}. The list may be out of sync. Please refresh.`);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error deleting configuration "${displayName}": ${error.message}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // On error, it's good practice to reload data to ensure UI consistency.
        loadInitialData_ExtraPage(); // Or a more targeted reload for RSG configs
    }
}

function rsg_getOtherRouteAdjustmentsForStop(targetStopID, currentEditingConfigKey) {
    const adjustmentsMap = new Map(); // Key: adjustmentValue, Value: { count: N, routeNames: Set() }

    if (!rsg_loadedConfigs_extra || typeof rsg_loadedConfigs_extra !== 'object') {
        return { hasDiscrepancies: false, mostCommonValue: null, suggestionTitle: '' };
    }

    for (const configKey in rsg_loadedConfigs_extra) {
        // Skip the configuration currently being edited to avoid comparing with its own (potentially unsaved) state
        if (configKey === currentEditingConfigKey) {
            continue;
        }

        const config = rsg_loadedConfigs_extra[configKey];
        if (config && Array.isArray(config.stopSequence)) {
            for (let i = 0; i < config.stopSequence.length; i++) {
                const stopInOtherConfig = config.stopSequence[i];
                // We only care about adjustments for the same stopID,
                // and only if it's not the first stop in that other sequence (index > 0),
                // and if timeAdjustment is a valid number.
                if (stopInOtherConfig.stopID === targetStopID &&
                    i > 0 && // Not the first stop (as first stop has no preceding adjustment)
                    typeof stopInOtherConfig.timeAdjustment === 'number' &&
                    !isNaN(stopInOtherConfig.timeAdjustment)) {

                    const adjValue = stopInOtherConfig.timeAdjustment;
                    if (!adjustmentsMap.has(adjValue)) {
                        adjustmentsMap.set(adjValue, { count: 0, routeNames: new Set() });
                    }
                    const existingEntry = adjustmentsMap.get(adjValue);
                    existingEntry.count++;
                    existingEntry.routeNames.add(config.routeName || "Unknown Route");
                }
            }
        }
    }

    if (adjustmentsMap.size === 0) {
        return { hasDiscrepancies: false, mostCommonValue: null, suggestionTitle: '' }; // No other routes use this stop with an adjustment
    }

    let mostCommonValue = null;
    let maxCount = 0;
    let allUniqueAdjustmentsFromOthers = [];

    adjustmentsMap.forEach((data, adjValue) => {
        allUniqueAdjustmentsFromOthers.push(adjValue);
        if (data.count > maxCount) {
            maxCount = data.count;
            mostCommonValue = adjValue;
        } else if (data.count === maxCount) {
            // Tie-breaking rule: prefer the smaller adjustment value if counts are equal
            if (mostCommonValue === null || adjValue < mostCommonValue) {
                mostCommonValue = adjValue;
            }
        }
    });
    
    let suggestionTitle = '';
    if (mostCommonValue !== null) {
        const routesUsingMostCommon = Array.from(adjustmentsMap.get(mostCommonValue)?.routeNames || []).slice(0,3).join(', ');
        const andMore = (adjustmentsMap.get(mostCommonValue)?.routeNames.size || 0) > 3 ? ' & more' : '';
        suggestionTitle = `Commonly +${mostCommonValue} min (on routes: ${routesUsingMostCommon}${andMore}). Click to apply.`;
    }


    return {
        // hasDiscrepancies: true if there are other adjustments and the current one differs from the mostCommon
        // This will be checked in the rendering function against the current stop's actual adjustment.
        allUniqueAdjustmentsFromOthers: allUniqueAdjustmentsFromOthers.sort((a,b) => a-b),
        mostCommonValue: mostCommonValue, // The adjustment value to suggest
        suggestionTitle: suggestionTitle  // Tooltip for the warning icon
    };
}

function rsg_handleLoadSelectedConfig_ExtraPage(configKey) {
    const loadStatusMsg = document.getElementById('rsg-load-status-message-extra');
    if (!rsg_loadedConfigs_extra || !rsg_loadedConfigs_extra[configKey]) {
        if (loadStatusMsg) {
            loadStatusMsg.textContent = "Error: Could not find configuration data for " + configKey;
            loadStatusMsg.style.color = "#e74c3c";
        }
        rsg_currentlyEditingConfigKey_extra = null; 
        rsg_currentlyEditingConfigDisplayName_extra = null;
        rsg_isDirty = false; // No valid config loaded to be dirty relative to
        rsg_updateRsgActionButtonsState();
        return;
    }

    const configData = rsg_loadedConfigs_extra[configKey];
    let loadedConfig = JSON.parse(JSON.stringify(configData)); // Deep copy to modify

    rsg_currentlyEditingConfigKey_extra = configKey;
    rsg_currentlyEditingConfigDisplayName_extra = loadedConfig.userDisplayName || configKey;

    rsgRouteNameInput_el_extra.value = loadedConfig.routeName || "";
    rsgDestinationNameInput_el_extra.value = loadedConfig.destinationName || "";
    rsg_setCheckedProfiles_ExtraPage(loadedConfig.operatingProfile || "");

    let namesUpdatedInSequence = false;
    if (loadedConfig.stopSequence && Array.isArray(loadedConfig.stopSequence) && 
        allDefinedStops_data && typeof allDefinedStops_data === 'object') {
        loadedConfig.stopSequence.forEach(stopInSeq => {
            if (stopInSeq.stopID) { // Ensure stopID exists
                const masterStopDef = allDefinedStops_data[stopInSeq.stopID.toUpperCase()];
                if (masterStopDef) {
                    if (stopInSeq.stopName !== masterStopDef.stopName) {
                        stopInSeq.stopName = masterStopDef.stopName;
                        namesUpdatedInSequence = true;
                    }
                    // Ensure direction is compared against a possibly empty master direction
                    const masterDirection = masterStopDef.direction || "";
                    if ((stopInSeq.direction || "") !== masterDirection) {
                        stopInSeq.direction = masterDirection;
                        namesUpdatedInSequence = true;
                    }
                } else {
                    // StopID in sequence not found in master definitions - might be an old/deleted stop
                    // You could mark it visually or log this
                    console.warn(`RSG Load: StopID ${stopInSeq.stopID} from loaded config sequence not found in master definitions. Name/direction may be stale.`);
                }
            }
        });
    }

    rsg_selectedStops_extra = loadedConfig.stopSequence || [];
    if (rsgFirstStopTimesInput_el_extra) {
         rsgFirstStopTimesInput_el_extra.value = loadedConfig.firstStopTimes || "";
    }

    rsg_lastLoadedRouteName_extra = loadedConfig.routeName || "";
    rsg_lastLoadedDestName_extra = loadedConfig.destinationName || "";
    rsg_lastLoadedOpProfile_extra = loadedConfig.operatingProfile || "";

    rsg_renderStopSequence_ExtraPage(); 

    let statusMessageText = `Loaded configuration: "${rsg_currentlyEditingConfigDisplayName_extra}".`;
    if (namesUpdatedInSequence) {
        statusMessageText += " Stop names/directions in the form have been updated to the latest master definitions. Save this RSG configuration to persist these updates within it.";
        rsg_isDirty = true; // Mark as dirty because the in-memory version of the config changed
        if (loadStatusMsg) loadStatusMsg.style.color = "#27ae60"; // Indicate update with different color
    } else {
        rsg_isDirty = false; 
        if (loadStatusMsg) loadStatusMsg.style.color = "#2ecc71"; // Standard success
    }
    
    rsg_resetPreviewState(statusMessageText, "success"); // Use statusMessageText for preview reset too
    if (loadStatusMsg) loadStatusMsg.textContent = statusMessageText;
    
    if (rsgRouteNameInput_el_extra) rsgRouteNameInput_el_extra.dispatchEvent(new Event('blur'));
    if (rsgDestinationNameInput_el_extra) {
        setTimeout(() => {
            rsgDestinationNameInput_el_extra.dispatchEvent(new Event('blur'));
        },50);
    }
    rsg_updateRsgActionButtonsState();
}

function getDaySortOrder_ExtraPage(profile) {
    if (!profile) return 9999;
    const p = String(profile).toUpperCase().replace(/\s+/g, ''); 
    const has = (keywords) => keywords.some(kw => p.includes(kw));
    let baseScore = 9000;

    if (has(["MONDAY", "MO"])) baseScore = 100;
    else if (has(["TUESDAY", "TU"])) baseScore = 200;
    else if (has(["WEDNESDAY", "WE"])) baseScore = 300;
    else if (has(["THURSDAY", "TH"])) baseScore = 400;
    else if (has(["FRIDAY", "FR"]) && !p.includes("GOODFRIDAY")) baseScore = 500;
    else if (has(["MON-FRI", "MONTOFRI", "WEEKDAY", "MF"])) baseScore = 600; 
    else if (has(["SATURDAY", "SA"]) && !p.includes("GOODFRIDAY")) baseScore = 700; 
    else if (has(["SUNDAY", "SU"])) baseScore = 800;

    if (baseScore < 9000) { 
        if (has(["SCH"])) return baseScore + 1;    
        if (has(["NSD"])) return baseScore + 2;    
        return baseScore; 
    }
    // Specific holiday scores (ensure these match what's in RSG_OPERATING_PROFILES_LIST if they are standalone)
    if (has(["CHRISTMASDAY"])) return 9030; // Example scores
    if (has(["BOXINGDAY"])) return 9040;
    if (has(["NEWYEARSDAY"])) return 9050;
    // Removed GoodFriday, SchoolHoliday, BankHoliday, AllDays from here if they are no longer primary types

    if (String(profile).includes(',')) { // For sorting already combined strings if needed elsewhere
        const parts = String(profile).split(',');
        let minScoreForParts = 9999;
        for (const part of parts) {
            minScoreForParts = Math.min(minScoreForParts, getDaySortOrder_ExtraPage(part.trim())); 
        }
        return minScoreForParts;
    }
    return baseScore; 
}

function rsg_populateProfileCheckboxes_ExtraPage() {
    const container = document.getElementById('rsg-selectable-profiles-container-extra');
    const placeholder = document.getElementById('rsg-profiles-placeholder-extra');
    if (!container) {
        console.error("RSG Profile checkbox container not found!");
        return;
    }
    container.innerHTML = ''; // Clear previous content

    if (RSG_OPERATING_PROFILES_LIST.length === 0 && placeholder) {
        placeholder.textContent = "No profiles defined to display.";
        container.appendChild(placeholder);
        return;
    }
    // Ensure placeholder is hidden if there are profiles to display
    if (placeholder) {
        placeholder.style.display = 'none';
    }

    RSG_OPERATING_PROFILES_LIST.forEach(profileValue => {
        const wrapper = document.createElement('div');
        wrapper.classList.add('selectable-route-tile'); // This class controls the visual styling
        // These styles are already in your CSS for .selectable-route-tile,
        // but explicitly setting background here might be good for consistency if default isn't applied otherwise.
        wrapper.style.backgroundColor = '#4A5568'; // Default background for unselected profile tiles
        wrapper.style.color = '#ecf0f1'; // Default text color

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        const safeProfileId = profileValue.replace(/[^a-zA-Z0-9_-]/g, '');
        checkbox.id = `rsg-profile-cb-${safeProfileId}-extra`;
        checkbox.value = profileValue;
        checkbox.name = 'rsgOperatingProfileCheckbox_extra';
        checkbox.classList.add('rsg-profile-checkbox'); // Keep this class for identification

        // The core change: Event listener on the wrapper (the tile itself)
        wrapper.addEventListener('click', (e) => {
            // Prevent toggling if the click was directly on the checkbox itself (optional, but good practice)
            if (e.target === checkbox) {
                // If clicked checkbox directly, let its native change event handle it
            } else {
                // If clicked on wrapper or label, manually toggle checkbox and then dispatch change event
                checkbox.checked = !checkbox.checked;
                const changeEvent = new Event('change', { bubbles: true });
                checkbox.dispatchEvent(changeEvent); // Trigger the change event
            }
        });

        // Add a change listener directly to the checkbox for the core logic
        // This listener will run whether the checkbox was clicked directly OR programmatically toggled by the wrapper click.
        checkbox.addEventListener('change', () => {
            wrapper.classList.toggle('selected', checkbox.checked); // Toggle 'selected' class on parent wrapper
            wrapper.style.borderColor = checkbox.checked ? '#f1c40f' : 'transparent'; // Visual border for selected
            wrapper.style.boxShadow = checkbox.checked ? '0 0 8px 1px #f1c40f' : '0 1px 3px rgba(0,0,0,0.3)'; // Visual shadow for selected
            
            // Now call the main logic function that handles overall selection state and disables
            rsg_handleProfileSelectionChange_ExtraPage(null); // Pass null as no specific event object is needed
        });


        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.textContent = profileValue;
        label.style.marginLeft = "4px"; 
        label.style.cursor = "pointer"; // Cursor for label is handled by wrapper now
        label.style.color = "#ecf0f1"; 

        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        container.appendChild(wrapper);
    });

    // Initial population/setting of states after all checkboxes are created:
    // This is crucial to ensure that if a configuration is loaded (which calls rsg_setCheckedProfiles_ExtraPage),
    // the visual state of the tiles correctly reflects the loaded profile string.
    // rsg_setCheckedProfiles_ExtraPage will then internally call rsg_handleProfileSelectionChange_ExtraPage,
    // which then calls rsg_updateDisabledProfileCheckboxes_ExtraPage.
    // So, we just need to ensure rsg_setCheckedProfiles_ExtraPage is called with the *current* selection state.
    // However, rsg_populateProfileCheckboxes_ExtraPage is called BEFORE rsg_loadOrPullConfiguration_ExtraPage.
    // To ensure initial state is correct for existing configurations, rsg_loadOrPullConfiguration_ExtraPage
    // should be the one responsible for calling rsg_setCheckedProfiles_ExtraPage after setting form values.
    // So, we need to ensure the visual state is updated here after rendering,
    // and let rsg_loadOrPullConfiguration_ExtraPage set the checked states.

    // Let's call rsg_updateDisabledProfileCheckboxes_ExtraPage directly to set initial disabled states.
    // The rsg_setCheckedProfiles_ExtraPage function (called by rsg_loadOrPullConfiguration_ExtraPage)
    // will correctly set the 'checked' state and trigger the 'change' event on relevant checkboxes,
    // which then updates the 'selected' class and calls rsg_handleProfileSelectionChange_ExtraPage.
    if (typeof rsg_updateDisabledProfileCheckboxes_ExtraPage === 'function') {
        rsg_updateDisabledProfileCheckboxes_ExtraPage();
    }
    // We do NOT need to call rsg_handleProfileSelectionChange_ExtraPage(null) here anymore,
    // because rsg_setCheckedProfiles_ExtraPage (which is called by rsg_loadOrPullConfiguration_ExtraPage after this function)
    // will trigger the 'change' event on the checkboxes, which in turn calls rsg_handleProfileSelectionChange_ExtraPage.
}

function populateTimetableExporterRouteSelect_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !currentWorkingSchedule_extra) {
        console.warn("Timetable Exporter: Route select element or schedule data not available.");
        return;
    }
    const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName).filter(Boolean))].sort(compareLineNames_ExtraPage);
    
    const currentInputValue = tteRouteNameInput_el_extra ? tteRouteNameInput_el_extra.value.trim() : "";
    
    tteRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Route --</option>';
    uniqueRoutes.forEach(route => {
        const opt = document.createElement('option');
        opt.value = route;
        opt.textContent = route;
        tteRouteNameSelect_el_extra.appendChild(opt);
    });

    if (currentInputValue) {
        const matchedOption = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
        tteRouteNameSelect_el_extra.value = matchedOption ? matchedOption : "";
    } else {
        tteRouteNameSelect_el_extra.value = "";
    }
}

// --- Helper Functions for PDF Timetable Generation ---

// Helper to convert HH:MM time string to absolute minutes from start of day
function getAbsMinutes(timeStr, dayOffset = 0) {
    // Check if timeStr is valid and in HH:MM format
    if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {
        // console.warn("getAbsMinutes: Invalid timeStr provided:", timeStr);
        return null; 
    }
    const parts = timeStr.split(':');
    if (parts.length !== 2) {
        // console.warn("getAbsMinutes: timeStr not in HH:MM format:", timeStr);
        return null;
    }

    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    
    // Ensure hours and minutes are valid numbers
    if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
        // console.warn("getAbsMinutes: Invalid hours or minutes in timeStr:", timeStr);
        return null;
    }

    // Ensure dayOffset is treated as a number, default to 0 if NaN or invalid
    const numericDayOffset = parseInt(dayOffset, 10);
    const validDayOffset = isNaN(numericDayOffset) ? 0 : numericDayOffset;
    
    return (validDayOffset * 1440) + (hours * 60) + minutes;
}

function toTitleCase_display(str) {
    if (!str || typeof str !== 'string') return "";
    return str.toLowerCase().split(' ').map(function(word) {
        if (word.length > 0) {
            // Handle special cases like "Year's" correctly
            if (word.includes("'")) {
                const parts = word.split("'");
                parts[0] = parts[0].charAt(0).toUpperCase() + parts[0].substring(1);
                return parts.join("'");
            }
            return word.charAt(0).toUpperCase() + word.substring(1);
        }
        return "";
    }).join(' ');
}

async function handleDownloadTimetable_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !tteRouteNameInput_el_extra || !tteStatusMessage_el_extra) {
        console.warn("Timetable Exporter: Essential UI elements are missing for download.");
        if(tteStatusMessage_el_extra) {
             tteStatusMessage_el_extra.textContent = "Initialization error. Try refreshing.";
             tteStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const routeName = tteRouteNameInput_el_extra.value.trim() || tteRouteNameSelect_el_extra.value;

    if (!routeName) {
        tteStatusMessage_el_extra.textContent = "Please select or enter a route name.";
        tteStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    if (!currentUser_extra || typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined' || typeof window.jspdf.jsPDF.API.autoTable === 'undefined') {
        tteStatusMessage_el_extra.textContent = "Error: PDF library not ready or not logged in.";
        tteStatusMessage_el_extra.style.color = "#e74c3c";
        console.error("jsPDF or jsPDF-AutoTable not correctly loaded. window.jspdf:", window.jspdf);
        return;
    }

    tteStatusMessage_el_extra.textContent = `Processing PDF timetable for route: ${routeName}...`;
    tteStatusMessage_el_extra.style.color = "#3498db";

    try {
        const routeEntries = currentWorkingSchedule_extra.filter(e => e.lineName === routeName);
        if (routeEntries.length === 0) {
            tteStatusMessage_el_extra.textContent = `No schedule data found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'landscape',
            unit: 'pt',
            format: 'a4'
        });
        let isFirstTableInPDF = true;

        const uniqueProfileDestPairs = new Map();
        routeEntries.forEach(e => {
            if (e.OperatingProfile && e.destinationName) {
                uniqueProfileDestPairs.set(`${e.OperatingProfile}|${e.destinationName}`, true);
            }
        });

        if (uniqueProfileDestPairs.size === 0) {
            tteStatusMessage_el_extra.textContent = `No operating profile/destination combinations found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }
        
        const sortedPairs = Array.from(uniqueProfileDestPairs.keys()).sort((a,b) => {
            const [profA, destA] = a.split('|');
            const [profB, destB] = b.split('|');
            const profCompare = profA.localeCompare(profB);
            if (profCompare !== 0) return profCompare;
            return destA.localeCompare(destB);
        });

        let tablesAddedToPDF = 0;

        for (const pair of sortedPairs) {
            const [opProfile, destName] = pair.split('|');
            let specificEntries = routeEntries.filter(e =>
                e.OperatingProfile === opProfile && e.destinationName === destName
            );

            if (specificEntries.length === 0) continue;

            specificEntries.sort((a, b) => {
                const dayOffsetA = parseInt(a.DayOffset || 0);
                const dayOffsetB = parseInt(b.DayOffset || 0);
                if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
                const timeA = (a.scheduledTime || "99:99").replace(':', '');
                const timeB = (b.scheduledTime || "99:99").replace(':', '');
                return timeA.localeCompare(timeB);
            });

            const trips = segmentEntriesIntoTrips_forTimetable(specificEntries);
            if (trips.length === 0) continue;

            const stopOrderMap = new Map();
            let globalStopIndexForOrdering = 0;
            trips.forEach(trip => { // Use all trips to define the superset of stops in order
                trip.forEach(entry => {
                    if (!entry.stopID || !entry.scheduledTime) return;
                    const currentStopTimeAbsVal = (parseInt(entry.DayOffset || 0) * 1440) +
                                             parseInt(entry.scheduledTime.split(':')[0]) * 60 +
                                             parseInt(entry.scheduledTime.split(':')[1]);
                    if (!stopOrderMap.has(entry.stopID)) {
                        stopOrderMap.set(entry.stopID, {
                            stopID: entry.stopID, name: entry.stopName, direction: entry.direction,
                            earliestTimeAbs: currentStopTimeAbsVal, 
                            firstSeenIndex: globalStopIndexForOrdering++
                        });
                    }
                });
            });
            const canonicalStopSequence = Array.from(stopOrderMap.values()).sort((a,b) => a.firstSeenIndex - b.firstSeenIndex);

            if (canonicalStopSequence.length === 0) continue;

            const tableHead = [["Stop ID", "Stop Name", "Stop Aim"]];
            trips.forEach((trip, index) => {
                tableHead[0].push(trip[0] ? `${trip[0].scheduledTime}` : `Trip ${index + 1}`);
            });

            const tableBody = [];
            canonicalStopSequence.forEach(stopInfo => {
                const row = [stopInfo.stopID || "", stopInfo.name || "", stopInfo.direction || ""];
                trips.forEach(trip => {
                    const entryForStopInTrip = trip.find(e => e.stopID === stopInfo.stopID);
                    row.push(entryForStopInTrip ? entryForStopInTrip.scheduledTime : "-");
                });
                tableBody.push(row);
            });

            if (tableBody.length > 0) {
                if (!isFirstTableInPDF) {
                    doc.addPage('a4', 'landscape');
                }
                isFirstTableInPDF = false;

                doc.setFontSize(14);
                doc.text(`Route: ${routeName}`, 40, 40);
                doc.setFontSize(11);
                doc.text(`Direction: Towards ${destName}`, 40, 55); // Adjusted Y for spacing
                doc.text(`Operating Profile: ${opProfile}`, 40, 70); // Adjusted Y for spacing

                doc.autoTable({
                    head: tableHead,
                    body: tableBody,
                    startY: 85, // Adjusted startY
                    theme: 'grid',
                    styles: { fontSize: 6, cellPadding: 1.5, overflow: 'visible' }, // 'ellipsize' or 'visible' or 'linebreak'
                    headStyles: { fillColor: [44, 62, 80], textColor: 255, fontSize: 7, fontStyle: 'bold', halign: 'center' },
                    columnStyles: {
                        0: { cellWidth: 50, fontStyle: 'bold' }, 
                        1: { cellWidth: 120 },
                        2: { cellWidth: 100 },
                        // For time columns, you might let them auto-adjust or set a small fixed width if many
                    },
                    margin: { top: 25, right: 30, bottom: 30, left: 40 }, // Adjusted top margin
                    tableWidth: 'auto',
                });
                tablesAddedToPDF++;
            }
        }

        if (tablesAddedToPDF > 0) {
            doc.save(`${sanitizeFirebaseKey(routeName)}_Timetable.pdf`);
            tteStatusMessage_el_extra.textContent = `Timetable PDF for ${routeName} generated successfully!`;
            tteStatusMessage_el_extra.style.color = "#2ecc71";
        } else {
            tteStatusMessage_el_extra.textContent = `No valid trip data found to generate PDF for route ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
        }

    } catch (error) {
        console.error("Error generating PDF timetable:", error);
        tteStatusMessage_el_extra.textContent = "Error generating PDF: " + error.message;
        tteStatusMessage_el_extra.style.color = "#e74c3c";
    }
}

// --- Helper function to segment entries into individual trips for PDF Timetable ---

function segmentEntriesIntoTrips_forTimetable(profileDestEntries, minStopsPerTripHeuristic = 1) { // <-- SET TO 200
    const allTrips = [];
    if (!profileDestEntries || profileDestEntries.length === 0) {
        return allTrips;
    }

    profileDestEntries.sort((a, b) => {
        const dayOffsetA = parseInt(a.DayOffset || 0);
        const dayOffsetB = parseInt(b.DayOffset || 0);
        if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
        const timeA = (a.scheduledTime || "99:99").replace(':', '');
        const timeB = (b.scheduledTime || "99:99").replace(':', '');
        return timeA.localeCompare(timeB);
    });

    let currentTrip = [];
    let previousStopTimeInAbsoluteMinutes = -1;
    let firstStopTimeOfCurrentLogicalTrip = -1;

    const rpdContext = profileDestEntries.length > 0 ? `(Route: ${profileDestEntries[0].lineName}, Profile: ${profileDestEntries[0].OperatingProfile}, Dest: ${profileDestEntries[0].destinationName})` : "";

    for (let i = 0; i < profileDestEntries.length; i++) {
        const entry = profileDestEntries[i];
        if (!entry.stopID || !entry.scheduledTime) continue;

        const currentStopTimeInAbsoluteMinutes =
            (parseInt(entry.DayOffset || 0) * 1440) +
            parseInt(entry.scheduledTime.split(':')[0]) * 60 +
            parseInt(entry.scheduledTime.split(':')[1]);

        if (currentTrip.length === 0) { 
            firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes;
        }
        
        if (currentTrip.length > 0) {
            // Condition 1: Time goes backward
            if (currentStopTimeInAbsoluteMinutes < previousStopTimeInAbsoluteMinutes) {
                console.log(`TRIP SPLIT (Time Regression) ${rpdContext}: Prev Stop ${currentTrip[currentTrip.length-1].stopID} (${currentTrip[currentTrip.length-1].scheduledTime} Day ${currentTrip[currentTrip.length-1].DayOffset || 0} / Abs: ${previousStopTimeInAbsoluteMinutes}), Curr Stop ${entry.stopID} (${entry.scheduledTime} Day ${entry.DayOffset || 0} / Abs: ${currentStopTimeInAbsoluteMinutes})`);
                allTrips.push([...currentTrip]); 
                currentTrip = []; 
                firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes; 
            } 
            // Condition 2: The STARTING STOP OF THE CURRENT TRIP is seen again
            // This condition is now very unlikely to be met with minStopsPerTripHeuristic = 9000
            else if (entry.stopID === currentTrip[0].stopID && 
                     currentTrip.length >= minStopsPerTripHeuristic && 
                     currentStopTimeInAbsoluteMinutes !== firstStopTimeOfCurrentLogicalTrip
                    ) {
                console.log(`TRIP SPLIT (Current Trip Start Stop Repeat) ${rpdContext}: Curr Stop ${entry.stopID} at ${entry.scheduledTime} (Abs: ${currentStopTimeInAbsoluteMinutes}), CurrentTripStartStopID: ${currentTrip[0].stopID}, TripLength: ${currentTrip.length}, minHeuristic: ${minStopsPerTripHeuristic}, FirstTimeOfCurrentTrip: ${firstStopTimeOfCurrentLogicalTrip}`);
                allTrips.push([...currentTrip]); 
                currentTrip = []; 
                firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes; 
            }
        }
        
        currentTrip.push(entry);
        previousStopTimeInAbsoluteMinutes = currentStopTimeInAbsoluteMinutes;
    }

    if (currentTrip.length > 0) {
        allTrips.push([...currentTrip]);
    }
    return allTrips;
}

// Helper to format a single time object for display
function formatTimeForDisplay(timeObject) {
    // timeObject = { absMinutes, displayTime, dayOffset }
    return timeObject.displayTime; 
}

function determineCanonicalStopSequence(specificEntriesForRPD) {
    const stopData = new Map(); // stopID -> { stopID, name, earliestAbsMinutes, firstSeenOriginalIndex }

    // The specificEntriesForRPD should already be sorted chronologically 
    // by the time this function is called in handleDownloadTimetable_ExtraPage
    specificEntriesForRPD.forEach((entry, index) => {
        if (entry.stopID && entry.scheduledTime) {
            const absMinutes = getAbsMinutes(entry.scheduledTime, parseInt(entry.DayOffset || 0));
            if (absMinutes === null) return;

            if (!stopData.has(entry.stopID)) {
                stopData.set(entry.stopID, {
                    stopID: entry.stopID,
                    name: entry.stopName,
                    earliestAbsMinutes: absMinutes, // Store the time of its first actual encountered entry
                    firstSeenOriginalIndex: index  // Store the index from the master sorted list
                });
            }
            // If you wanted to update earliestAbsMinutes for a stop if it appeared later with an even earlier time
            // (which shouldn't happen if specificEntriesForRPD is perfectly sorted), you could add logic here.
            // For now, we assume the first encounter sets its primary ordering criteria.
        }
    });

    return Array.from(stopData.values()).sort((a, b) => {
        if (a.firstSeenOriginalIndex !== b.firstSeenOriginalIndex) {
            return a.firstSeenOriginalIndex - b.firstSeenOriginalIndex;
        }
        return a.earliestAbsMinutes - b.earliestAbsMinutes; // Fallback sort
    });
}

function analyzeAndSummarizeTimes(sortedTimes) { // sortedTimes is array of { absMinutes, displayTime, dayOffset }
    // Define constants used within this function
    const MAX_INITIAL_INDIVIDUAL_TIMES = 2; 
    const MIN_TIMES_FOR_PATTERN_BLOCK = 4;  
    const MIN_INTERVALS_FOR_PATTERN = MIN_TIMES_FOR_PATTERN_BLOCK - 1;

    const n = sortedTimes.length;
    if (n === 0) return "-";

    if (n < MIN_TIMES_FOR_PATTERN_BLOCK) { 
        return sortedTimes.map(t => formatTimeForDisplay(t)).join(", ");
    }

    let resultParts = [];
    let currentIndex = 0;

    while (currentIndex < n) {
        let bestRun = {
            startIdx: -1, numIntervals: 0, interval: 0, 
            startTimeObj: null, endTimeObj: null
        };

        // Determine the limit for starting a pattern search.
        // We look for a pattern starting at currentIndex, or up to MAX_INITIAL_INDIVIDUAL_TIMES beyond it.
        // Ensure we don't search beyond where a minimal pattern could form.
        let searchStartLimit = Math.min(currentIndex + MAX_INITIAL_INDIVIDUAL_TIMES, n - MIN_INTERVALS_FOR_PATTERN);
        // If currentIndex itself is already very close to the end, adjust searchStartLimit to at least allow one check from currentIndex
        if (searchStartLimit <= currentIndex && currentIndex <= n - MIN_TIMES_FOR_PATTERN_BLOCK ) { 
            searchStartLimit = currentIndex + 1; 
        }


        for (let i = currentIndex; i < searchStartLimit; i++) {
            // Ensure there are enough elements from 'i' to form at least MIN_INTERVALS_FOR_PATTERN
            if (i + MIN_INTERVALS_FOR_PATTERN >= n) break; 

            const t1Abs = sortedTimes[i].absMinutes;
            const t2Abs = sortedTimes[i + 1].absMinutes;

            if (t1Abs === null || t2Abs === null) continue;
            let currentRunInterval = t2Abs - t1Abs;

            // Ignore intervals that are non-positive or too large for typical summaries
            if (currentRunInterval <= 0 || currentRunInterval >= 90) continue; 

            let currentRunNumIntervals = 1; // We found one interval (between sortedTimes[i] and sortedTimes[i+1])
            // Now count how many more *consecutive* intervals match currentRunInterval
            for (let k = i + 1; k < n - 1; k++) { // k is the index of the start of the next interval
                const tkAbs = sortedTimes[k].absMinutes;
                const tk1Abs = sortedTimes[k + 1].absMinutes;
                if (tkAbs === null || tk1Abs === null) break; 

                if ((tk1Abs - tkAbs) === currentRunInterval) {
                    currentRunNumIntervals++;
                } else {
                    break; 
                }
            }

            if (currentRunNumIntervals >= MIN_INTERVALS_FOR_PATTERN) {
                // Found a valid run of intervals. Check if it's better than any previously found bestRun.
                if (currentRunNumIntervals > bestRun.numIntervals || 
                    (currentRunNumIntervals === bestRun.numIntervals && i < bestRun.startIdx) || 
                    bestRun.startIdx === -1) { // Prioritize longer runs, or earlier starting runs of same length
                    bestRun = {
                        startIdx: i, // Index in sortedTimes of the first time in this pattern
                        endIdx: i + currentRunNumIntervals, // Index in sortedTimes of the last time in this pattern
                        interval: currentRunInterval,
                        numIntervals: currentRunNumIntervals, // Number of matching intervals
                        startTimeObj: sortedTimes[i],
                        endTimeObj: sortedTimes[i + currentRunNumIntervals]
                    };
                }
            }
        } 

        if (bestRun.startIdx !== -1 && bestRun.startIdx >= currentIndex) { 
            // A frequency pattern was found starting at or after currentIndex.
            // 1. Add any individual times from currentIndex UP TO the start of the identified pattern block
            for (let j = currentIndex; j < bestRun.startIdx; j++) {
                resultParts.push(formatTimeForDisplay(sortedTimes[j]));
            }

            // 2. Add the actual start time of the frequency block
            const formattedRunStartTime = formatTimeForDisplay(bestRun.startTimeObj);
            resultParts.push(formattedRunStartTime);
            
            // 3. Construct the core summary phrase (without "then" and without "from [start time]")
            let summaryCorePhrase = "";
            const formattedRunEndTime = formatTimeForDisplay(bestRun.endTimeObj);

            if (bestRun.interval < 15) {
                summaryCorePhrase = `every ${bestRun.interval} mins until ${formattedRunEndTime}`;
            } else { // Interval is 15 minutes or more
                const minutesPastHourSet = new Set();
                for (let k = bestRun.startIdx; k <= bestRun.endIdx; k++) { // Iterate through times in the actual run
                    if (sortedTimes[k].displayTime.includes(':')) {
                        minutesPastHourSet.add(sortedTimes[k].displayTime.substring(3, 5));
                    }
                }
                if (minutesPastHourSet.size >= 1 && minutesPastHourSet.size <= 4 && (bestRun.interval % 5 === 0)) {
                    let numericallySortedMinutes = Array.from(minutesPastHourSet).sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
                    
                    const startMinuteOfBlock = bestRun.startTimeObj.displayTime.substring(3,5);
                    if (numericallySortedMinutes.length > 1 && numericallySortedMinutes[0] === startMinuteOfBlock) {
                        const firstMin = numericallySortedMinutes.shift(); 
                        numericallySortedMinutes.push(firstMin);      
                    }
                    const displayMinutes = numericallySortedMinutes.join(', ');                                        
                    summaryCorePhrase = `at these mins past each hour: ${displayMinutes} until ${formattedRunEndTime}`;
                } else { 
                    summaryCorePhrase = `approx. every ${bestRun.interval} mins until ${formattedRunEndTime}`;
                }
            }
            resultParts.push("then " + summaryCorePhrase); // Add "then" before the core summary
            currentIndex = bestRun.endIdx + 1; // Advance currentIndex past this summarized block
        } else { // No suitable frequency block found from currentIndex, or remaining times are too few.
            if (currentIndex < n) {
                 resultParts.push(formatTimeForDisplay(sortedTimes[currentIndex]));
                 currentIndex++;
            } else { 
                break; // End of times
            }
        }
    } 

    // Final joining logic
    if (resultParts.length === 0) return "-";
    let finalStr = resultParts[0] || "";
    for (let i = 1; i < resultParts.length; i++) {
        const prevPartStr = resultParts[i-1] || "";
        const currentPartStr = resultParts[i] || "";
        
        if (currentPartStr.startsWith("then") && !prevPartStr.startsWith("then")) {
            // Previous was a time, current is its summary: "TIME then SUMMARY"
            finalStr += " " + currentPartStr; 
        } else {
            // All other cases (summary; summary, summary; time, time; time if it's a new segment after summary)
            finalStr += "; " + currentPartStr;
        }
    }
    return finalStr || "-";
}

async function handleDownloadTimetable_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !tteRouteNameInput_el_extra || !tteStatusMessage_el_extra) {
        console.warn("Timetable Exporter: Essential UI elements missing.");
        if(tteStatusMessage_el_extra) { tteStatusMessage_el_extra.textContent = "Init error."; tteStatusMessage_el_extra.style.color = "#e74c3c"; }
        return;
    }

    const routeName = tteRouteNameInput_el_extra.value.trim() || tteRouteNameSelect_el_extra.value;
    if (!routeName) {
        tteStatusMessage_el_extra.textContent = "Please select a route.";
        tteStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    if (!currentUser_extra || typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined' || typeof window.jspdf.jsPDF.API.autoTable === 'undefined') {
        tteStatusMessage_el_extra.textContent = "Error: PDF library not ready or not logged in.";
        tteStatusMessage_el_extra.style.color = "#e74c3c";
        return;
    }

    tteStatusMessage_el_extra.textContent = `Processing PDF timetable for route: ${routeName}...`;
    tteStatusMessage_el_extra.style.color = "#3498db";

    try {
        const routeEntries = currentWorkingSchedule_extra.filter(e => e.lineName === routeName);
        if (routeEntries.length === 0) {
            tteStatusMessage_el_extra.textContent = `No schedule data found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'portrait', 
            unit: 'pt',
            format: 'a4'
        });
        let isFirstTableInPDF = true;

        const uniqueProfileDestPairs = new Map();
        routeEntries.forEach(e => {
            if (e.OperatingProfile && e.destinationName) {
                uniqueProfileDestPairs.set(`${e.OperatingProfile}|${e.destinationName}`, true);
            }
        });

        if (uniqueProfileDestPairs.size === 0) {
            tteStatusMessage_el_extra.textContent = `No operating profile/destination combinations found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }
        
        const sortedPairs = Array.from(uniqueProfileDestPairs.keys()).sort((a,b) => {
            const [profA, destA] = a.split('|');
            const [profB, destB] = b.split('|');
            const profCompare = profA.localeCompare(profB);
            if (profCompare !== 0) return profCompare;
            return destA.localeCompare(destB);
        });

        let tablesAddedToPDF = 0;

        for (const pair of sortedPairs) {
            const [opProfile, destName] = pair.split('|');
            
            const specificEntriesForRPD = routeEntries
                .filter(e => e.OperatingProfile === opProfile && e.destinationName === destName && e.scheduledTime)
                .sort((a,b) => { 
                    const absA = getAbsMinutes(a.scheduledTime, parseInt(a.DayOffset || 0));
                    const absB = getAbsMinutes(b.scheduledTime, parseInt(b.DayOffset || 0));
                    if (absA === null && absB === null) return 0;
                    if (absA === null) return 1;
                    if (absB === null) return -1;
                    return absA - absB;
                });

            if (specificEntriesForRPD.length === 0) continue;

            const canonicalStopSequence = determineCanonicalStopSequence(specificEntriesForRPD);
            if (canonicalStopSequence.length === 0) continue;

            const tableHead = [["Stop ID", "Stop Name", "Scheduled Times"]];
            const tableBody = [];

            canonicalStopSequence.forEach(stopInfo => {
                const allTimesAtThisStop = specificEntriesForRPD
                    .filter(e => e.stopID === stopInfo.stopID) 
                    .map(e => ({ 
                        absMinutes: getAbsMinutes(e.scheduledTime, parseInt(e.DayOffset || 0)),
                        displayTime: e.scheduledTime,
                        dayOffset: parseInt(e.DayOffset || 0)
                    }));
                // This map preserves the pre-sorted order of times for this stop from specificEntriesForRPD

                const serviceDetailString = analyzeAndSummarizeTimes(allTimesAtThisStop);
                
                tableBody.push([
                    stopInfo.stopID || "",
                    stopInfo.name || "",
                    serviceDetailString
                ]);
            });

            if (tableBody.length > 0) {
                if (!isFirstTableInPDF) {
                    doc.addPage('a4', 'portrait');
                }
                isFirstTableInPDF = false;

                doc.setFontSize(14);
                doc.text(`Route: ${routeName}`, 40, 40); 
                doc.setFontSize(11);
                doc.text(`Destination: ${destName}`, 40, 55); 
                doc.text(`Operating Profile: ${opProfile}`, 40, 70);

                doc.autoTable({
                    head: tableHead,
                    body: tableBody,
                    startY: 85,
                    theme: 'grid',
                    styles: { 
                        fontSize: 7, 
                        cellPadding: 2,
                        overflow: 'linebreak' 
                    }, 
                    headStyles: { 
                        fillColor: [44, 62, 80], 
                        textColor: 255, 
                        fontSize: 8,       
                        fontStyle: 'bold', 
                        halign: 'left' 
                    },
                    columnStyles: {
                        0: { cellWidth: 55, fontStyle: 'bold' }, 
                        1: { cellWidth: 130 }, 
                        2: { cellWidth: 'auto' } 
                    },
                    margin: { top: 25, right: 30, bottom: 30, left: 40 },
                });
                tablesAddedToPDF++;
            }
        }

        if (tablesAddedToPDF > 0) {
            doc.save(`${sanitizeFirebaseKey(routeName)}_Timetable_Summary.pdf`);
            tteStatusMessage_el_extra.textContent = `Summarized Timetable PDF for ${routeName} generated successfully!`;
            tteStatusMessage_el_extra.style.color = "#2ecc71";
        } else {
            tteStatusMessage_el_extra.textContent = `No valid data to generate summarized PDF for ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
        }

    } catch (error) {
        console.error("Error generating summarized PDF timetable:", error);
        tteStatusMessage_el_extra.textContent = "Error generating summarized PDF: " + error.message;
        tteStatusMessage_el_extra.style.color = "#e74c3c";
    }
}

function rsg_getSelectedOpProfilesString_ExtraPage() {
    const selectedProfiles = [];
    document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox:checked').forEach(checkbox => {
        selectedProfiles.push(checkbox.value);
    });
    // Sorts alphabetically, e.g., ["Fr", "MF", "Sa"]
    selectedProfiles.sort((a,b) => a.localeCompare(b)); 
    
    // Joins with a comma AND a space
    return selectedProfiles.join(', ');
}

function rsg_updateDisabledProfileCheckboxes_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));
    const currentSelectedValues = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

    allCheckboxes.forEach(cb => {
        if (cb.checked) {
            cb.disabled = false;
            if (cb.parentElement) {
                cb.parentElement.style.opacity = 1;
                cb.parentElement.style.pointerEvents = 'auto';
                const labelForCb = cb.parentElement.querySelector('label');
                if (labelForCb) labelForCb.style.cursor = 'pointer';
            }
            return;
        }

        const potentialNextRawSelection = [...currentSelectedValues, cb.value];
        const finalEffectiveSelectionAfterAutoGroup = rsg_simulateAutoGroup(potentialNextRawSelection);
        const finalEffectiveSortedString = rsg_getCanonicalProfileString(finalEffectiveSelectionAfterAutoGroup);

        let canBeEnabled = false;

        if (VALID_PROFILE_COMBINATIONS_SET.has(finalEffectiveSortedString)) {
            canBeEnabled = true;
        }

        if (!canBeEnabled) {
            const prefixToTest = finalEffectiveSortedString + ",";
            for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                if (validCombo.startsWith(prefixToTest)) {
                    canBeEnabled = true;
                    break;
                }
            }
        }

        if (currentSelectedValues.length === 0) {
             const singleProfileItselfAfterPotentialGroup = rsg_simulateAutoGroup([cb.value]);
             const singleCanonical = rsg_getCanonicalProfileString(singleProfileItselfAfterPotentialGroup);
             if (VALID_PROFILE_COMBINATIONS_SET.has(singleCanonical)) {
                 canBeEnabled = true;
             } else {
                 const prefixToTestForSingle = singleCanonical + ",";
                 for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                     if (validCombo.startsWith(prefixToTestForSingle)) {
                         canBeEnabled = true;
                         break;
                     }
                 }
             }
        }

        cb.disabled = !canBeEnabled;
        if (cb.parentElement) {
            cb.parentElement.style.opacity = !canBeEnabled ? 0.5 : 1;
            cb.parentElement.style.pointerEvents = !canBeEnabled ? 'none' : 'auto';
            const labelForCb = cb.parentElement.querySelector('label');
            if (labelForCb) {
                labelForCb.style.cursor = !canBeEnabled ? 'not-allowed' : 'pointer';
            }
        }
    });
}

function rsg_simulateAutoGroup(selectedProfilesArray) {
    let simulatedSelections = [...selectedProfilesArray]; 

    for (const group of RSG_PROFILE_GROUPS_TO_MANAGE) {
        const allIndividualsPresent = group.individuals.every(ind => simulatedSelections.includes(ind));

        if (allIndividualsPresent) {
            simulatedSelections = simulatedSelections.filter(p => !group.individuals.includes(p)); 
            if (!simulatedSelections.includes(group.groupProfile)) {
                simulatedSelections.push(group.groupProfile); 
            }
        }
    }
    return simulatedSelections;
}

function rsg_handleProfileSelectionChange_ExtraPage(event) { // event can be null if called programmatically
    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));
    let selectionChangedByLogic = false;

    // Loop through each defined group (e.g., MF, MFSch, MFNSD)
    RSG_PROFILE_GROUPS_TO_MANAGE.forEach(group => {
        const groupCheckbox = allCheckboxes.find(cb => cb.value === group.groupProfile);
        if (!groupCheckbox) return; // Should not happen if profiles are populated correctly

        const individualCheckboxesInGroup = group.individuals.map(indVal => allCheckboxes.find(cb => cb.value === indVal)).filter(Boolean);
        const allIndividualsCurrentlySelected = individualCheckboxesInGroup.length === group.individuals.length && individualCheckboxesInGroup.every(cb => cb.checked);

        // Case 1: All individual days of a group are ticked
        if (allIndividualsCurrentlySelected) {
            if (!groupCheckbox.checked) { // And the group itself is not yet ticked
                // Uncheck all individuals in this group
                individualCheckboxesInGroup.forEach(cb => {
                    if (cb.checked) {
                        cb.checked = false;
                        selectionChangedByLogic = true;
                    }
                });
                // Check the group profile
                groupCheckbox.checked = true;
                selectionChangedByLogic = true;
            }
        }
        // Case 2: The group profile is ticked
        else if (groupCheckbox.checked) {
            // If the event was specifically unchecking an individual that belongs to this *currently checked* group,
            // then uncheck the group profile itself.
            if (event && event.target && group.individuals.includes(event.target.value) && !event.target.checked) {
                groupCheckbox.checked = false;
                selectionChangedByLogic = true;
            }
            // If the group profile is (still) checked, ensure all its individual members are unchecked.
            // This handles user directly clicking group, or auto-grouping just occurred.
            if (groupCheckbox.checked) {
                individualCheckboxesInGroup.forEach(cb => {
                    if (cb.checked) { // If an individual is somehow still checked along with the group
                        cb.checked = false;
                        selectionChangedByLogic = true;
                    }
                });
            }
        }
    });

    // After all programmatic changes to checkbox.checked states are complete,
    // update the visual appearance of ALL tiles to match their current checkbox state.
    allCheckboxes.forEach(cb => {
        const wrapper = cb.closest('.selectable-route-tile'); // Get the parent tile
        if (wrapper) {
            const isChecked = cb.checked;
            wrapper.classList.toggle('selected', isChecked);
            // Ensure you have a CSS variable for --default-box-shadow or use the explicit string
            const defaultBoxShadow = getComputedStyle(wrapper).getPropertyValue('--default-box-shadow').trim() || '0 1px 3px rgba(0,0,0,0.3)';
            wrapper.style.borderColor = isChecked ? '#f1c40f' : 'transparent';
            wrapper.style.boxShadow = isChecked ? '0 0 8px 1px #f1c40f' : defaultBoxShadow;
        }
    });

    // Now, get the final selected profiles string based on the updated checkbox states
    const finalCurrentSelectionsArray = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

    // Sort for consistent display and storage
    finalCurrentSelectionsArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a);
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) return orderA - orderB;
        return a.localeCompare(b);
    });
    const finalSelectedProfilesString = finalCurrentSelectionsArray.join(', ');

    // Update the display string
    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }

    // Update which checkboxes are enabled/disabled based on rules
    rsg_updateDisabledProfileCheckboxes_ExtraPage();

    // If a change was made by user interaction (event is not null) or by the grouping logic,
    // then the configuration might need to be re-evaluated against saved configs.
    if (event || selectionChangedByLogic) {
        if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') {
            rsg_loadOrPullConfiguration_ExtraPage();
        }
    }
    rsg_updateRsgActionButtonsState();
}

function rsg_setCheckedProfiles_ExtraPage(profileString) {
    // Determine which profiles to select based on the input string
    const profilesToSelect = profileString ? profileString.split(',').map(p => p.trim()).filter(Boolean) : [];

    // Get all profile checkboxes
    const allProfileCheckboxes = document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox');

    // Set the checked state for each checkbox
    allProfileCheckboxes.forEach(checkbox => {
        checkbox.checked = profilesToSelect.includes(checkbox.value);
    });

    // --- MODIFICATION START ---
    // After programmatically setting checkbox states,
    // directly update the "Currently Selected & Active" display string.

    // Use the 'profilesToSelect' array as the source of truth for what should be displayed,
    // as this is what the checkboxes were just set to.
    // Create a mutable copy if further manipulation of this array specific to display is needed,
    // otherwise, direct use is fine for sorting and joining.
    const currentDisplayProfilesArray = [...profilesToSelect];

    // Sort them for consistent display order using your existing sorting logic
    currentDisplayProfilesArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a); // Ensure getDaySortOrder_ExtraPage is robust
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) {
            return orderA - orderB;
        }
        return a.localeCompare(b); // Default alphabetical sort if order is the same
    });

    // Join the sorted profiles into a string for display
    const finalSelectedProfilesString = currentDisplayProfilesArray.join(', ');

    // Get the display element
    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');

    // Update the text content of the display element
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }
    // --- MODIFICATION END ---

    // This function correctly updates which checkboxes are enabled/disabled
    // based on your incompatibility rules and the newly set checkbox states.
    // This should always be called after checkbox states are modified.
    if (typeof rsg_updateDisabledProfileCheckboxes_ExtraPage === 'function') {
        rsg_updateDisabledProfileCheckboxes_ExtraPage();
    }
}

function rsg_clearProfileSelections_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));
    let selectionActuallyChanged = false;

    allCheckboxes.forEach(cb => {
        if (cb.checked) {
            cb.checked = false;
            selectionActuallyChanged = true;
        }
    });

    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = '(None selected)';
    }

    if (typeof rsg_updateDisabledProfileCheckboxes_ExtraPage === 'function') {
        rsg_updateDisabledProfileCheckboxes_ExtraPage();
    }

    if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') {
        rsg_loadOrPullConfiguration_ExtraPage();
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_createConfigKey_ExtraPage(routeName, opProfile, destName) { if (!routeName || !opProfile || !destName) return null; const normRoute = sanitizeFirebaseKey(String(routeName).toUpperCase()); const normProfile = sanitizeFirebaseKey(String(opProfile).toUpperCase()); const normDest = sanitizeFirebaseKey(String(destName).toUpperCase()); return `${normRoute}|${normProfile}|${normDest}`; } 

        async function rsg_loadOrPullConfiguration_ExtraPage(configKeyToLoad = null, isInitialLoadForSection = false) {
    if (!rsgRouteNameInput_el_extra || !rsgDestinationNameInput_el_extra || !rsgFirstStopTimesInput_el_extra || !rsgStatusMessage_el_extra || !window.firebaseOMSI) {
        console.warn("RSG Load/Pull: Aborted - Essential DOM element or Firebase missing.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "RSG components missing or Firebase not ready.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const routeNameFromForm = rsgRouteNameInput_el_extra.value.trim();
    const opProfileFromForm = rsg_getSelectedOpProfilesString_ExtraPage();
    const destNameFromForm = rsgDestinationNameInput_el_extra.value.trim();
    const loadStatusMsg = document.getElementById('rsg-load-status-message-extra');


    if (configKeyToLoad) { // A specific saved configuration is being loaded
        const configData = rsg_loadedConfigs_extra[configKeyToLoad];
        if (configData) {
            let loadedConfig = JSON.parse(JSON.stringify(configData)); // Deep copy

            rsg_currentlyEditingConfigKey_extra = configKeyToLoad;
            rsg_currentlyEditingConfigDisplayName_extra = loadedConfig.userDisplayName || configKeyToLoad;

            rsgRouteNameInput_el_extra.value = loadedConfig.routeName || "";
            rsgDestinationNameInput_el_extra.value = loadedConfig.destinationName || "";
            rsg_setCheckedProfiles_ExtraPage(loadedConfig.operatingProfile || "");

            let namesOrDirectionsUpdatedInLoadedConfig = false;
            if (loadedConfig.stopSequence && Array.isArray(loadedConfig.stopSequence) && allDefinedStops_data) {
                loadedConfig.stopSequence.forEach(stopInSeq => {
                    if (stopInSeq.stopID) {
                        const masterStopDef = allDefinedStops_data[stopInSeq.stopID.toUpperCase()];
                        if (masterStopDef) {
                            if (stopInSeq.stopName !== masterStopDef.stopName) {
                                stopInSeq.stopName = masterStopDef.stopName;
                                namesOrDirectionsUpdatedInLoadedConfig = true;
                            }
                            const masterDirection = masterStopDef.direction || "";
                            if ((stopInSeq.direction || "") !== masterDirection) {
                                stopInSeq.direction = masterDirection;
                                namesOrDirectionsUpdatedInLoadedConfig = true;
                            }
                        }
                    }
                });
            }

            rsg_selectedStops_extra = loadedConfig.stopSequence || [];
            if (rsgFirstStopTimesInput_el_extra) {
                rsgFirstStopTimesInput_el_extra.value = loadedConfig.firstStopTimes || '';
            }

            rsg_lastLoadedRouteName_extra = loadedConfig.routeName || "";
            rsg_lastLoadedDestName_extra = loadedConfig.destinationName || "";
            rsg_lastLoadedOpProfile_extra = loadedConfig.operatingProfile || "";
            
            let statusMessageText = `Loaded configuration: "${rsg_currentlyEditingConfigDisplayName_extra}".`;
            if (namesOrDirectionsUpdatedInLoadedConfig) {
                statusMessageText += " Stop names/directions updated to latest. Save to persist.";
                rsg_isDirty = true; // Mark as dirty as it differs from originally saved state due to refresh
                if (loadStatusMsg) loadStatusMsg.style.color = "#27ae60";
            } else {
                rsg_isDirty = false;
                if (loadStatusMsg) loadStatusMsg.style.color = "#2ecc71";
            }

            rsg_resetPreviewState(statusMessageText, "success");
            if (loadStatusMsg) loadStatusMsg.textContent = statusMessageText;

        } else { // Config key provided, but data not found
            if (loadStatusMsg) {
                loadStatusMsg.textContent = `Error: Could not find data for saved configuration key "${configKeyToLoad}". Current sequence retained.`;
                loadStatusMsg.style.color = "#e74c3c";
            }
            rsg_currentlyEditingConfigKey_extra = null;
            rsg_currentlyEditingConfigDisplayName_extra = null;
            rsg_isDirty = true; 
            rsg_resetPreviewState("Failed to load saved configuration. Review inputs or continue.", "error");
        }
    } else { 
        // No specific configKeyToLoad: This means the RSG section is being displayed/refreshed,
        // or form parameters (route/dest/profile) changed.
        // Refresh the current rsg_selectedStops_extra with latest master definitions.
        let namesOrDirectionsUpdatedInCurrentSequence = false;
        if (rsg_selectedStops_extra && Array.isArray(rsg_selectedStops_extra) && allDefinedStops_data) {
            rsg_selectedStops_extra.forEach(stopInSeq => {
                if (stopInSeq.stopID) {
                    const masterStopDef = allDefinedStops_data[stopInSeq.stopID.toUpperCase()];
                    if (masterStopDef) {
                        let changed = false;
                        if (stopInSeq.stopName !== masterStopDef.stopName) {
                            stopInSeq.stopName = masterStopDef.stopName;
                            changed = true;
                        }
                        const masterDirection = masterStopDef.direction || "";
                        if ((stopInSeq.direction || "") !== masterDirection) {
                            stopInSeq.direction = masterDirection;
                            changed = true;
                        }
                        if (changed) namesOrDirectionsUpdatedInCurrentSequence = true;
                    }
                }
            });
        }

        let identityHasChangedBasedOnFormInputs =
            (routeNameFromForm.toUpperCase() !== (rsg_lastLoadedRouteName_extra || "").toUpperCase()) ||
            (destNameFromForm !== (rsg_lastLoadedDestName_extra || "")) ||
            (opProfileFromForm !== (rsg_lastLoadedOpProfile_extra || ""));

        if (identityHasChangedBasedOnFormInputs || rsg_currentlyEditingConfigKey_extra) {
            if (rsg_currentlyEditingConfigKey_extra && identityHasChangedBasedOnFormInputs) {
                 if (rsgStatusMessage_el_extra && !isInitialLoadForSection) { 
                    rsgStatusMessage_el_extra.textContent = "Route/Destination/Profile parameters changed from loaded config. Edits are for a new setup.";
                    rsgStatusMessage_el_extra.style.color = "#f1c40f";
                 }
            } else if (!rsg_currentlyEditingConfigKey_extra && identityHasChangedBasedOnFormInputs && (rsg_lastLoadedRouteName_extra || rsg_lastLoadedDestName_extra || rsg_lastLoadedOpProfile_extra) && !isInitialLoadForSection) {
                 if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = "Route/Destination/Profile parameters changed. Current sequence retained for new setup.";
                    rsgStatusMessage_el_extra.style.color = "#f1c40f";
                 }
            }
            rsg_currentlyEditingConfigKey_extra = null; 
            rsg_currentlyEditingConfigDisplayName_extra = null;
            if (!isInitialLoadForSection && (identityHasChangedBasedOnFormInputs || namesOrDirectionsUpdatedInCurrentSequence) ) { 
                rsg_isDirty = true; 
            }
        } else if (namesOrDirectionsUpdatedInCurrentSequence && !isInitialLoadForSection) {
             rsg_isDirty = true; // if only names/dirs changed in current sequence
        }


        rsg_lastLoadedRouteName_extra = routeNameFromForm;
        rsg_lastLoadedDestName_extra = destNameFromForm;
        rsg_lastLoadedOpProfile_extra = opProfileFromForm; 
        
        if (namesOrDirectionsUpdatedInCurrentSequence && !isInitialLoadForSection && rsgStatusMessage_el_extra) {
            if (!(rsgStatusMessage_el_extra.textContent && rsgStatusMessage_el_extra.textContent.includes("parameters changed"))) {
                // Avoid overwriting the "parameters changed" message if it was just set
                rsgStatusMessage_el_extra.textContent = "RSG sequence refreshed with latest stop details from master list.";
                rsgStatusMessage_el_extra.style.color = "#27ae60"; 
            }
        } else if (isInitialLoadForSection && rsg_selectedStops_extra.length === 0 && rsgFirstStopTimesInput_el_extra && rsgFirstStopTimesInput_el_extra.value === '') {
            rsg_resetPreviewState("Build a sequence or load a saved configuration.", "info");
        } else if (!isInitialLoadForSection) { // Not initial load, no specific config, no params changed, no names changed
            rsg_resetPreviewState("Review sequence or make changes. Regenerate preview if needed.", "info");
        }
    }

    rsg_renderStopSequence_ExtraPage(); // This will now use the potentially updated names/directions
    rsg_updateRsgActionButtonsState();
}

        function rsg_handleSaveConfiguration_ExtraPage() {
    if (!currentUser_extra) {
        alert("Please log in to save configurations.");
        return;
    }
    // Basic check: ensure essential fields for naming are present before opening modal
    const routeName = rsgRouteNameInput_el_extra.value.trim();
    const destName = rsgDestinationNameInput_el_extra.value.trim();
    const opProfiles = rsg_getSelectedOpProfilesString_ExtraPage();

    if (!routeName || !destName || !opProfiles) {
         if(rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route, Destination, and Operating Profile(s) must be selected to save.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    if (rsg_selectedStops_extra.length === 0 || !rsgFirstStopTimesInput_el_extra.value.trim()) {
         if(rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Stop Sequence and First Stop Times are required to save.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    rsg_showSaveConfigModal_ExtraPage();
}

        function rsg_handleDestinationNameInputChange_ExtraPage() { 
            if (!rsgDestinationNameInput_el_extra || !rsgDestinationNameSelect_el_extra) return; 
            const typedDest = rsgDestinationNameInput_el_extra.value.trim(); 
            const matchedOption = Array.from(rsgDestinationNameSelect_el_extra.options).find(opt => opt.value === typedDest); 
            if (matchedOption) { 
                rsgDestinationNameSelect_el_extra.value = matchedOption.value; 
                if (rsgDestinationNameInput_el_extra.value !== matchedOption.value) rsgDestinationNameInput_el_extra.value = matchedOption.value; 
            } else {
                // If typed value doesn't match an existing option, clear the select to imply "custom" or "none"
                rsgDestinationNameSelect_el_extra.value = ""; 
            }
            // Now call rsg_loadOrPullConfiguration_ExtraPage immediately after a change that affects the identity of the config.
            // This is done to check if this new combination of Route+Profile+Dest matches a saved config.
            rsg_loadOrPullConfiguration_ExtraPage(); 
            rsg_updateRsgActionButtonsState(); // Added call
        }

        function rsg_handleDestinationNameInputChange_ExtraPage() { 
    if (!rsgDestinationNameInput_el_extra || !rsgDestinationNameSelect_el_extra) return; 
    const typedDest = rsgDestinationNameInput_el_extra.value.trim(); 
    const matchedOption = Array.from(rsgDestinationNameSelect_el_extra.options).find(opt => opt.value === typedDest); 
    if (matchedOption) { 
        rsgDestinationNameSelect_el_extra.value = matchedOption.value; 
        if (rsgDestinationNameInput_el_extra.value !== matchedOption.value) rsgDestinationNameInput_el_extra.value = matchedOption.value; 
    } else {
        rsgDestinationNameSelect_el_extra.value = ""; 
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

        async function rsg_loadOrPullConfiguration_ExtraPage(configKeyToLoad = null, isInitialLoadForSection = false) {
    if (!rsgRouteNameInput_el_extra || // Now refers to hidden input
        !rsgDestinationNameInput_el_extra ||
        !rsgFirstStopTimesInput_el_extra ||
        !rsgStatusMessage_el_extra || !window.firebaseOMSI) {
        console.warn("RSG Load/Pull: Aborted - Essential DOM element or Firebase missing.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "RSG components missing or Firebase not ready.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    // Now get the route name directly from rsg_selectedRoute_extra (or its hidden input for safety)
    const routeNameFromForm = rsg_selectedRoute_extra || rsgRouteNameInput_el_extra.value.trim();
    const opProfileFromForm = rsg_getSelectedOpProfilesString_ExtraPage();
    const destNameFromForm = rsgDestinationNameInput_el_extra.value.trim();
    const loadStatusMsg = document.getElementById('rsg-load-status-message-extra');


    if (configKeyToLoad) { // A specific saved configuration is being loaded (e.g., from the saved configs list)
        const configData = rsg_loadedConfigs_extra[configKeyToLoad];
        if (configData) {
            let loadedConfig = JSON.parse(JSON.stringify(configData)); // Deep copy

            rsg_currentlyEditingConfigKey_extra = configKeyToLoad;
            rsg_currentlyEditingConfigDisplayName_extra = loadedConfig.userDisplayName || configKeyToLoad;

            // Update the global selected route and the hidden input
            rsg_selectedRoute_extra = loadedConfig.routeName || ""; 
            rsgRouteNameInput_el_extra.value = rsg_selectedRoute_extra;
            // Update the display for the route tile selection
            if (rsgSelectedRouteDisplay_el_extra) {
                rsgSelectedRouteDisplay_el_extra.textContent = rsg_selectedRoute_extra || '(None selected)';
            }
            // Visually select the tile
            rsgRouteSelectionContainer_el_extra.querySelectorAll('.selectable-route-tile').forEach(tile => {
                if (tile.dataset.routeName && tile.dataset.routeName.toUpperCase() === rsg_selectedRoute_extra.toUpperCase()) {
                    tile.classList.add('selected');
                } else {
                    tile.classList.remove('selected');
                }
            });


            rsgDestinationNameInput_el_extra.value = loadedConfig.destinationName || "";
            rsg_setCheckedProfiles_ExtraPage(loadedConfig.operatingProfile || "");

            let namesOrDirectionsUpdatedInLoadedConfig = false;
            if (loadedConfig.stopSequence && Array.isArray(loadedConfig.stopSequence) && allDefinedStops_data) {
                loadedConfig.stopSequence.forEach(stopInSeq => {
                    if (stopInSeq.stopID) {
                        const masterStopDef = allDefinedStops_data[stopInSeq.stopID.toUpperCase()];
                        if (masterStopDef) {
                            if (stopInSeq.stopName !== masterStopDef.stopName) {
                                stopInSeq.stopName = masterStopDef.stopName;
                                namesOrDirectionsUpdatedInLoadedConfig = true;
                            }
                            const masterDirection = masterStopDef.direction || "";
                            if ((stopInSeq.direction || "") !== masterDirection) {
                                stopInSeq.direction = masterDirection;
                                namesOrDirectionsUpdatedInLoadedConfig = true;
                            }
                        }
                    }
                });
            }

            rsg_selectedStops_extra = loadedConfig.stopSequence || [];
            if (rsgFirstStopTimesInput_el_extra) {
                rsgFirstStopTimesInput_el_extra.value = loadedConfig.firstStopTimes || '';
            }

            // Update last loaded context variables from the loaded config
            rsg_lastLoadedRouteName_extra = loadedConfig.routeName || "";
            rsg_lastLoadedDestName_extra = loadedConfig.destinationName || "";
            rsg_lastLoadedOpProfile_extra = loadedConfig.operatingProfile || "";
            
            let statusMessageText = `Loaded configuration: "${rsg_currentlyEditingConfigDisplayName_extra}".`;
            if (namesOrDirectionsUpdatedInLoadedConfig) {
                statusMessageText += " Stop names/directions updated to latest. Save to persist.";
                rsg_isDirty = true; // Mark as dirty as it differs from originally saved state due to refresh
                if (loadStatusMsg) loadStatusMsg.style.color = "#27ae60";
            } else {
                rsg_isDirty = false;
                if (loadStatusMsg) loadStatusMsg.style.color = "#2ecc71";
            }

            rsg_resetPreviewState(statusMessageText, "success");
            if (loadStatusMsg) loadStatusMsg.textContent = statusMessageText;

        } else { // Config key provided, but data not found
            if (loadStatusMsg) {
                loadStatusMsg.textContent = `Error: Could not find data for saved configuration key "${configKeyToLoad}". Current sequence retained.`;
                loadStatusMsg.style.color = "#e74c3c";
            }
            rsg_currentlyEditingConfigKey_extra = null;
            rsg_currentlyEditingConfigDisplayName_extra = null;
            rsg_isDirty = true; 
            rsg_resetPreviewState("Failed to load saved configuration. Review inputs or continue.", "error");
        }
    } else { 
        // No specific configKeyToLoad: This means the RSG section is being displayed/refreshed,
        // or form parameters (route/dest/profile) changed.

        // First, check if the currently selected route (from tiles) is still valid in rsg_selectedRoute_extra.
        // If not, clear the form to ensure a fresh start for a new config.
        if (!rsg_selectedRoute_extra) { // If no route is selected via tiles, clear other related fields
            rsgDestinationNameInput_el_extra.value = '';
            rsg_setCheckedProfiles_ExtraPage(''); // Clear profiles
            rsgFirstStopTimesInput_el_extra.value = '';
            rsg_selectedStops_extra = []; // Clear stop sequence
            rsg_currentlyEditingConfigKey_extra = null;
            rsg_currentlyEditingConfigDisplayName_extra = null;
            rsg_isDirty = false;
            rsg_renderStopSequence_ExtraPage(); // Re-render sequence to show empty
            rsg_resetPreviewState("Please select a route to begin a new configuration or load a saved one.", "info");
            // No need to proceed further if no route is selected, as other parameters are cleared.
            rsg_lastLoadedRouteName_extra = "";
            rsg_lastLoadedDestName_extra = "";
            rsg_lastLoadedOpProfile_extra = "";
            rsg_populateDestinationSelect_ExtraPage(); // Refresh destinations based on empty route
            return;
        }

        // Refresh the current rsg_selectedStops_extra with latest master definitions.
        let namesOrDirectionsUpdatedInCurrentSequence = false;
        if (rsg_selectedStops_extra && Array.isArray(rsg_selectedStops_extra) && allDefinedStops_data) {
            rsg_selectedStops_extra.forEach(stopInSeq => {
                if (stopInSeq.stopID) {
                    const masterStopDef = allDefinedStops_data[stopInSeq.stopID.toUpperCase()];
                    if (masterStopDef) {
                        let changed = false;
                        if (stopInSeq.stopName !== masterStopDef.stopName) {
                            stopInSeq.stopName = masterStopDef.stopName;
                            changed = true;
                        }
                        const masterDirection = masterStopDef.direction || "";
                        if ((stopInSeq.direction || "") !== masterDirection) {
                            stopInSeq.direction = masterDirection;
                            changed = true;
                        }
                        if (changed) namesOrDirectionsUpdatedInCurrentSequence = true;
                    }
                }
            });
        }

        // Compare current form state with the "last loaded" state to detect changes
        let identityHasChangedBasedOnFormInputs =
            (routeNameFromForm.toUpperCase() !== (rsg_lastLoadedRouteName_extra || "").toUpperCase()) ||
            (destNameFromForm !== (rsg_lastLoadedDestName_extra || "")) ||
            (opProfileFromForm !== (rsg_lastLoadedOpProfile_extra || ""));

        // If something fundamental about the "identity" of the configuration has changed (route, dest, profile)
        // AND we were previously editing a saved config, then we should clear the editing context.
        if (rsg_currentlyEditingConfigKey_extra && identityHasChangedBasedOnFormInputs) {
            if (rsgStatusMessage_el_extra && !isInitialLoadForSection) { 
                rsgStatusMessage_el_extra.textContent = "Route/Destination/Profile parameters changed from loaded config. Edits are for a new setup.";
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }
            rsg_currentlyEditingConfigKey_extra = null; 
            rsg_currentlyEditingConfigDisplayName_extra = null;
            rsg_isDirty = true; // Mark as dirty because the user is now working on a new/modified config
        } 
        // If not editing a saved config, but identity changed or names updated in sequence, it's a dirty state.
        else if (!rsg_currentlyEditingConfigKey_extra && (identityHasChangedBasedOnFormInputs || namesOrDirectionsUpdatedInCurrentSequence)) {
            if (!isInitialLoadForSection && rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Configuration parameters or stop details updated. Review and generate preview.";
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }
            rsg_isDirty = true; // Mark as dirty
        } 
        // If nothing changed, and we were previously editing a config, stay clean.
        else if (rsg_currentlyEditingConfigKey_extra && !identityHasChangedBasedOnFormInputs && !namesOrDirectionsUpdatedInCurrentSequence) {
             rsg_isDirty = false; // Stay clean if nothing truly changed
        }


        // Always update last loaded context to current form state for future comparisons
        rsg_lastLoadedRouteName_extra = routeNameFromForm;
        rsg_lastLoadedDestName_extra = destNameFromForm;
        rsg_lastLoadedOpProfile_extra = opProfileFromForm; 
        
        rsg_renderStopSequence_ExtraPage(); // This will now use the potentially updated names/directions
        
        // Initial message for empty RSG when first loading section, or after clear.
        if (isInitialLoadForSection && rsg_selectedStops_extra.length === 0 && rsgFirstStopTimesInput_el_extra && rsgFirstStopTimesInput_el_extra.value === '') {
            rsg_resetPreviewState("Build a sequence or load a saved configuration.", "info");
        } else if (!rsg_isDirty && rsgStatusMessage_el_extra && rsgStatusMessage_el_extra.textContent === "Configuration changed. Please (re)generate preview or add short workings.") {
            // If it was already set to "Configuration changed" and now is clean, keep the status if it's info/success.
            // But if it was an error, clear it.
            if (rsgStatusMessage_el_extra.style.color !== 'rgb(231, 76, 60)' && rsgStatusMessage_el_extra.style.color !== '#e74c3c') {
                rsg_resetPreviewState(`Ready for generation. Current status: ${rsg_isDirty ? 'Dirty' : 'Clean'}.`, "info");
            }
        }
        else if (rsg_isDirty && !isInitialLoadForSection && rsgStatusMessage_el_extra && !rsgStatusMessage_el_extra.textContent.includes("parameters changed")) {
            // Only set if not initial load, is dirty, and not already showing a more specific "parameters changed" message.
             rsg_resetPreviewState("Changes detected. Regenerate preview or save.", "info");
        }
        // If an error message is already displayed, don't overwrite it here.
    }

    rsg_updateRsgActionButtonsState(); // Update button states based on final form/selection state
}

        // ++ RSG Helper Function to create 'Copy Time Adjustment' buttons (sorted) ++
        function rsg_createCopyAdjustmentButtons_ExtraPage(currentStopInSequence, stopIndexInCurrentSequence, buttonsContainer) {
            if (!currentStopInSequence || !buttonsContainer || !rsg_loadedConfigs_extra || typeof rsg_loadedConfigs_extra !== 'object') {
                return;
            }

            buttonsContainer.innerHTML = ''; // Clear any existing buttons or placeholder text

            const currentRsgRouteName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
            const targetStopID = currentStopInSequence.stopID;
            
            const potentialButtonsData = [];
            const addedButtonSignatures = new Set(); // To track added "RouteName|Adjustment" for uniqueness

            for (const configKey in rsg_loadedConfigs_extra) {
                const sourceConfig = rsg_loadedConfigs_extra[configKey];

                if (!sourceConfig.routeName || sourceConfig.routeName.toUpperCase() === currentRsgRouteName || !Array.isArray(sourceConfig.stopSequence)) {
                    continue;
                }

                let sourceStopData = null;
                let sourceStopIndexInItsConfig = -1;

                for (let i = 0; i < sourceConfig.stopSequence.length; i++) {
                    if (sourceConfig.stopSequence[i].stopID === targetStopID) {
                        sourceStopData = sourceConfig.stopSequence[i];
                        sourceStopIndexInItsConfig = i;
                        break; 
                    }
                }

                if (sourceStopData && sourceStopIndexInItsConfig > 0) { // Must exist and not be the first stop in its own sequence
                    const timeAdjustmentToCopy = sourceConfig.stopSequence[sourceStopIndexInItsConfig].timeAdjustment;

                    if (typeof timeAdjustmentToCopy === 'number') {
                        const buttonSignature = `${sourceConfig.routeName}|${timeAdjustmentToCopy}`;

                        if (!addedButtonSignatures.has(buttonSignature)) {
                            potentialButtonsData.push({
                                routeName: sourceConfig.routeName,
                                timeAdjustment: timeAdjustmentToCopy,
                                operatingProfile: sourceConfig.operatingProfile || 'N/A',
                                destinationName: sourceConfig.destinationName || 'N/A'
                            });
                            addedButtonSignatures.add(buttonSignature);
                        }
                    }
                }
            }

            if (potentialButtonsData.length > 0) {
                // Sort the collected button data by routeName
                potentialButtonsData.sort((a, b) => compareLineNames_ExtraPage(a.routeName, b.routeName));

                // Now create and append buttons in sorted order
                potentialButtonsData.forEach(data => {
                    const button = document.createElement('button');
                    button.classList.add('button', 'small-action', 'neutral', 'copy-adj-button');
                    button.textContent = `Copy From ${data.routeName} (+${data.timeAdjustment} min)`;
                    button.title = `Copy ${data.timeAdjustment} min from ${data.routeName} (Profile: ${data.operatingProfile}, Dest: ${data.destinationName})`;

                    button.addEventListener('click', () => {
                        rsg_selectedStops_extra[stopIndexInCurrentSequence].timeAdjustment = data.timeAdjustment;
                        const listItem = rsgStopSequenceList_el_extra.querySelector(`li[data-index="${stopIndexInCurrentSequence}"]`);
                        if (listItem) {
                            const timeAdjInput = listItem.querySelector('.rsg-time-adjustment-input');
                            if (timeAdjInput) {
                                timeAdjInput.value = data.timeAdjustment;
                            }
                        }
                        rsg_resetPreviewState(`Time adjustment (${data.timeAdjustment} min) copied from Route ${data.routeName}. Regenerate preview.`, "info");
                    });
                    buttonsContainer.appendChild(button);
                });
            } else {
                 buttonsContainer.innerHTML = `<span style="font-size:0.75em; opacity:0.7; display:block; margin-top:0.3rem; width:100%;">No other routes serve this stop to copy adjustment from.</span>`;
            }
        }

        // In omsi_tools_extra.html

function rsg_renderStopSequence_ExtraPage() {
    if (!rsgStopSequenceList_el_extra || !rsgStopSequencePlaceholder_el_extra || !rsgFirstStopTimesContainer_el_extra) {
        console.error("RSG Render: Critical elements for rendering stop sequence are missing.");
        return;
    }

    // console.log(`RSG Render: Starting. Stop count in sequence: ${rsg_selectedStops_extra.length}. IsDirty flag: ${rsg_isDirty}.`);

    rsgStopSequenceList_el_extra.innerHTML = ''; // Clear existing items

    if (rsg_selectedStops_extra.length === 0) {
        rsgStopSequencePlaceholder_el_extra.style.display = 'block';
        rsgFirstStopTimesContainer_el_extra.style.display = 'none';
        // console.log("RSG Render: No stops in sequence, showing placeholder.");
    } else {
        rsgStopSequencePlaceholder_el_extra.style.display = 'none';
        rsgFirstStopTimesContainer_el_extra.style.display = 'block';

        rsg_selectedStops_extra.forEach((stop, loopIndex) => {
            if (!stop || typeof stop.stopID === 'undefined') {
                console.warn(`RSG Render: Skipping invalid stop data at index ${loopIndex}.`, stop);
                return; 
            }
            // console.log(`RSG Render: Processing stop at index ${loopIndex}, ID: ${stop.stopID}, Name: ${stop.stopName}`);

            const li = document.createElement('li');
            li.dataset.index = loopIndex; 
            li.draggable = true;

            const mainContentDiv = document.createElement('div');
            mainContentDiv.classList.add('rsg-li-main-content');

            const stopInfoDiv = document.createElement('div');
            stopInfoDiv.classList.add('rsg-stop-info');

            let directionTextForRsgDisplay = "";
            if (stop.direction &&
                stop.direction.trim() !== "" &&
                stop.direction.trim().toUpperCase() !== "NO DIRECTION") {
                directionTextForRsgDisplay = `Towards: ${stop.direction}`;
            }
            
            stopInfoDiv.innerHTML = `<span class="rsg-stop-name">${stop.stopName || 'N/A'}</span> <span class="rsg-stop-id">(${stop.stopID})</span>`;
            if (directionTextForRsgDisplay) { 
                 stopInfoDiv.innerHTML += `<br><small style="opacity:0.7;">${directionTextForRsgDisplay}</small>`;
            }

            const actionsDiv = document.createElement('div');
            actionsDiv.classList.add('rsg-stop-actions');

            let timeAdjInput = null;

            const renderOrUpdateWarningIcon = (currentIndex, currentStopData, inputElementForWarning, parentActionsDivForWarning) => {
                if (!inputElementForWarning || !parentActionsDivForWarning) {
                    // console.warn("renderOrUpdateWarningIcon: Missing inputElement or parentActionsDiv for index:", currentIndex);
                    return;
                }
                const existingWarning = parentActionsDivForWarning.querySelector('.rsg-time-adj-warning');
                if (existingWarning) {
                    existingWarning.remove();
                }

                const otherAdjustmentsInfo = rsg_getOtherRouteAdjustmentsForStop(currentStopData.stopID, rsg_currentlyEditingConfigKey_extra);
                const currentStopActualAdjustment = (typeof rsg_selectedStops_extra[currentIndex]?.timeAdjustment === 'number' && !isNaN(rsg_selectedStops_extra[currentIndex].timeAdjustment))
                    ? rsg_selectedStops_extra[currentIndex].timeAdjustment
                    : 0;

                if (otherAdjustmentsInfo.mostCommonValue !== null &&
                    currentStopActualAdjustment !== otherAdjustmentsInfo.mostCommonValue) {

                    const warningIcon = document.createElement('span');
                    warningIcon.className = 'rsg-time-adj-warning';
                    warningIcon.textContent = ' '; 
                    warningIcon.style.cursor = 'pointer';
                    warningIcon.style.color = '#f39c12'; 
                    warningIcon.style.fontSize = '1.1em';
                    warningIcon.style.marginLeft = '5px';
                    warningIcon.title = otherAdjustmentsInfo.suggestionTitle || `Commonly +${otherAdjustmentsInfo.mostCommonValue} min on other routes. Click to apply.`;

                    warningIcon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const targetAdjustment = otherAdjustmentsInfo.mostCommonValue;
                        if (targetAdjustment !== null && rsg_selectedStops_extra[currentIndex]) {
                            rsg_selectedStops_extra[currentIndex].timeAdjustment = targetAdjustment;
                            if (inputElementForWarning) inputElementForWarning.value = targetAdjustment;
                            warningIcon.remove();
                            rsg_isDirty = true;
                            if (rsgStatusMessage_el_extra) {
                                rsgStatusMessage_el_extra.textContent = `Time adjustment for '${currentStopData.stopName}' updated to +${targetAdjustment} min. Regenerate preview.`;
                                rsgStatusMessage_el_extra.style.color = '#2ecc71';
                            }
                            rsg_resetPreviewState("Time adjustment updated from suggestion. Regenerate preview.", "info");
                            rsg_updateRsgActionButtonsState();
                        }
                    });
                    const removeBtnInTheseActions = parentActionsDivForWarning.querySelector('button.secondary');
                    if (removeBtnInTheseActions) {
                        parentActionsDivForWarning.insertBefore(warningIcon, removeBtnInTheseActions);
                    } else {
                        parentActionsDivForWarning.appendChild(warningIcon);
                    }
                }
            };

            if (loopIndex > 0) { 
                timeAdjInput = document.createElement('input');
                timeAdjInput.type = 'number';
                timeAdjInput.classList.add('schedule-generator-input', 'rsg-time-adjustment-input');
                timeAdjInput.min = '0'; 
                timeAdjInput.max = '120'; 
                timeAdjInput.title = 'Minutes from previous stop';
                timeAdjInput.value = (typeof stop.timeAdjustment === 'number' && !isNaN(stop.timeAdjustment)) ? stop.timeAdjustment : 0;
                
                actionsDiv.appendChild(timeAdjInput); 

                renderOrUpdateWarningIcon(loopIndex, stop, timeAdjInput, actionsDiv); 

                timeAdjInput.addEventListener('input', (e) => {
                    e.stopPropagation();
                    rsg_isDirty = true;
                    const currentLiElement = timeAdjInput.closest('li');
                    if (!currentLiElement) return;
                    const changedIndex = parseInt(currentLiElement.dataset.index);
                    
                    if (rsg_selectedStops_extra[changedIndex]) {
                        let newValueFromInput = parseInt(timeAdjInput.value, 10);
                        if (!isNaN(newValueFromInput) && newValueFromInput >= 0) {
                            rsg_selectedStops_extra[changedIndex].timeAdjustment = newValueFromInput;
                        } else { 
                            rsg_selectedStops_extra[changedIndex].timeAdjustment = 0;
                            if (isNaN(newValueFromInput) || newValueFromInput < 0) timeAdjInput.value = 0; 
                        }
                        renderOrUpdateWarningIcon(changedIndex, rsg_selectedStops_extra[changedIndex], timeAdjInput, actionsDiv);
                        rsg_updateRsgActionButtonsState();
                        rsg_resetPreviewState("Time adjustment changed. Regenerate preview.", "info");
                    }
                });
            }

            const changeStopButton = document.createElement('button');
            changeStopButton.innerHTML = ''; 
            changeStopButton.classList.add('button', 'small-action', 'neutral');
            changeStopButton.title = 'Change this stop in the sequence';
            changeStopButton.style.marginRight = '4px';
            changeStopButton.addEventListener('click', (e) => {
                e.stopPropagation(); 
                const currentIndex = parseInt(li.dataset.index); 
                // --- ADD LOGGING ---
                console.log("[RSG Change Button] Clicked! Index from li.dataset.index:", li.dataset.index, "Parsed currentIndex:", currentIndex);
                if (isNaN(currentIndex)) {
                    console.error("[RSG Change Button] Error: currentIndex is NaN. li.dataset.index was:", li.dataset.index);
                    alert("Error: Could not determine which stop to change.");
                    return;
                }
                // --- END LOGGING ---
                if (typeof rsg_openReplaceStopModal_ExtraPage === 'function') {
                    // --- ADD LOGGING ---
                    console.log("[RSG Change Button] Calling rsg_openReplaceStopModal_ExtraPage with index:", currentIndex);
                    // --- END LOGGING ---
                    rsg_openReplaceStopModal_ExtraPage(currentIndex);
                } else {
                    console.error("[RSG Change Button] Error: rsg_openReplaceStopModal_ExtraPage function is not defined.");
                    alert("Error: The action for changing a stop is currently unavailable.");
                }
            });
            actionsDiv.appendChild(changeStopButton);

            const removeButton = document.createElement('button');
            removeButton.textContent = ''; 
            removeButton.classList.add('button', 'small-action', 'secondary');
            removeButton.title = 'Remove this stop from sequence';
            removeButton.addEventListener('click', (e) => {
                e.stopPropagation();
                rsg_removeStopFromSequence_ExtraPage(parseInt(li.dataset.index));
            });
            actionsDiv.appendChild(removeButton);

            mainContentDiv.appendChild(stopInfoDiv);
            mainContentDiv.appendChild(actionsDiv);
            li.appendChild(mainContentDiv);

            if (loopIndex > 0 && timeAdjInput) { 
                const copyButtonsContainer = document.createElement('div');
                copyButtonsContainer.classList.add('rsg-copy-adjustment-buttons-container');
                if (typeof rsg_createCopyAdjustmentButtons_ExtraPage === 'function') {
                    rsg_createCopyAdjustmentButtons_ExtraPage(stop, loopIndex, copyButtonsContainer, timeAdjInput, actionsDiv, renderOrUpdateWarningIcon);
                }
                li.appendChild(copyButtonsContainer);
            }
            
            rsgStopSequenceList_el_extra.appendChild(li);

            li.addEventListener('dragstart', rsg_handleDragStart_ExtraPage);
            li.addEventListener('dragover', rsg_handleDragOver_ExtraPage);
            li.addEventListener('dragleave', rsg_handleDragLeave_ExtraPage);
            li.addEventListener('drop', rsg_handleDrop_ExtraPage);
            li.addEventListener('dragend', rsg_handleDragEnd_ExtraPage);
        });
        // console.log("RSG Render: Sequence item rendering loop finished.");
    }
}

async function handleApplyMasterListStopIdChangesButton_ExtraPage() {
    if (!currentUser_extra || !masterStopListUL_el_extra || !masterListApplyChangesStatus_el_extra) {
        if (masterListApplyChangesStatus_el_extra) {
            masterListApplyChangesStatus_el_extra.textContent = "Error: System not ready or user not logged in.";
            masterListApplyChangesStatus_el_extra.style.color = '#e74c3c';
        }
        return;
    }

    masterListApplyChangesStatus_el_extra.textContent = "Processing proposed Stop ID changes...";
    masterListApplyChangesStatus_el_extra.style.color = '#f1c40f';

    const idChangeProposals = []; // Stores { originalId: string, newId: string (uppercase) }
    const allInputs = masterStopListUL_el_extra.querySelectorAll('.master-list-new-id-input');
    let hasErrors = false;
    const newProposedIDsInThisBatchSet = new Set(); // Tracks new IDs proposed in this specific batch
    const existingDefinedIDsUppercaseSet = new Set(Object.keys(allDefinedStops_data || {}).map(id => id.toUpperCase()));

    allInputs.forEach(input => {
        const originalIdFromDataset = input.dataset.originalId; // Original case from when list was rendered
        const newIdProposed = input.value.trim().toUpperCase(); // New IDs are proposed in uppercase
        const warningElement = input.parentElement.querySelector('.master-list-row-warning');
        if (warningElement) warningElement.textContent = '';

        if (newIdProposed && newIdProposed !== originalIdFromDataset.toUpperCase()) { // Only process actual changes
            if (!/^[A-Z0-9]+$/.test(newIdProposed)) {
                if (warningElement) warningElement.textContent = "Invalid characters in new ID.";
                hasErrors = true; return;
            }
            if (newProposedIDsInThisBatchSet.has(newIdProposed)) {
                if (warningElement) warningElement.textContent = "This new ID is duplicated in another proposal in this batch.";
                hasErrors = true; return;
            }
            // Check if new ID conflicts with an existing defined stop that ISN'T the one being renamed
            if (existingDefinedIDsUppercaseSet.has(newIdProposed) && newIdProposed !== originalIdFromDataset.toUpperCase()) {
                if (warningElement) warningElement.textContent = "This new ID already exists for a different stop.";
                hasErrors = true; return;
            }
            idChangeProposals.push({ originalId: originalIdFromDataset, newId: newIdProposed });
            newProposedIDsInThisBatchSet.add(newIdProposed);
        }
    });

    if (hasErrors) {
        masterListApplyChangesStatus_el_extra.textContent = "Errors in proposed IDs. Please correct and retry.";
        masterListApplyChangesStatus_el_extra.style.color = '#e74c3c';
        return;
    }

    if (idChangeProposals.length === 0) {
        masterListApplyChangesStatus_el_extra.textContent = "No actual Stop ID changes were proposed.";
        masterListApplyChangesStatus_el_extra.style.color = '#7f8c8d';
        return;
    }

    if (!confirm(`Are you sure you want to apply these ${idChangeProposals.length} Stop ID changes? This will update definitions, schedules, and related settings in Firebase.`)) {
        masterListApplyChangesStatus_el_extra.textContent = "Bulk Stop ID change operation cancelled by user.";
        masterListApplyChangesStatus_el_extra.style.color = '';
        return;
    }

    let definitionsModifiedInCache = false;
    let scheduleEntriesModifiedCount = 0;
    let closedStopsListModifiedInCache = false;
    let stopColorsModifiedInCache = false;

    // 1. Update allDefinedStops_data (local cache)
    // Keys in allDefinedStops_data should already be uppercase from loading/normalization.
    idChangeProposals.forEach(proposal => {
        const originalIdUpper = proposal.originalId.toUpperCase();
        const newIdUpper = proposal.newId; // Already uppercase

        if (allDefinedStops_data && allDefinedStops_data[originalIdUpper]) {
            const stopObjectToMove = { ...allDefinedStops_data[originalIdUpper] }; // Clone
            stopObjectToMove.stopID = newIdUpper; // Update the stopID property within the object

            delete allDefinedStops_data[originalIdUpper];
            allDefinedStops_data[newIdUpper] = stopObjectToMove;
            definitionsModifiedInCache = true;
        } else {
            console.warn(`Cannot rename stop definition: Original ID ${originalIdUpper} not found in allDefinedStops_data.`);
        }
    });

    // 2. Update stopID in currentWorkingSchedule_extra (local cache)
    if (Array.isArray(currentWorkingSchedule_extra) && currentWorkingSchedule_extra.length > 0) {
        currentWorkingSchedule_extra.forEach(entry => {
            if (entry.stopID) {
                const originalEntryStopIDUpper = entry.stopID.toUpperCase();
                let newStopIDForThisEntry = null;

                for (const proposal of idChangeProposals) {
                    if (proposal.originalId.toUpperCase() === originalEntryStopIDUpper) {
                        newStopIDForThisEntry = proposal.newId;
                        break;
                    }
                }

                if (newStopIDForThisEntry) {
                    entry.stopID = newStopIDForThisEntry; // Update to new (uppercase) ID
                    const masterDefForNewID = allDefinedStops_data[newStopIDForThisEntry];
                    if (masterDefForNewID) { // Refresh name/direction from master
                        entry.stopName = masterDefForNewID.stopName;
                        entry.direction = masterDefForNewID.direction;
                    }
                    scheduleEntriesModifiedCount++;
                }
            }
        });
    }

    // 3. Update closedStopIDs_extra (local cache)
    if (Array.isArray(closedStopIDs_extra) && closedStopIDs_extra.length > 0) {
        const originalClosedStopIDsSnapshot = [...closedStopIDs_extra];
        const updatedClosedStopIDsSet = new Set();
        closedStopIDs_extra.forEach(closedId => {
            const closedIdUpper = closedId.toUpperCase();
            let correspondingNewId = closedIdUpper;
            for (const proposal of idChangeProposals) {
                if (proposal.originalId.toUpperCase() === closedIdUpper) {
                    correspondingNewId = proposal.newId;
                    break;
                }
            }
            updatedClosedStopIDsSet.add(correspondingNewId);
        });
        closedStopIDs_extra = Array.from(updatedClosedStopIDsSet);
        if (closedStopIDs_extra.length !== originalClosedStopIDsSnapshot.length || 
            !originalClosedStopIDsSnapshot.every(id => updatedClosedStopIDsSet.has(id.toUpperCase()))) {
            closedStopsListModifiedInCache = true;
        }
    }

    // 4. Update stopSpecificRouteColours_extra (local cache)
    // Ensure keys become uppercase if they weren't already.
    if (stopSpecificRouteColours_extra && typeof stopSpecificRouteColours_extra === 'object' && Object.keys(stopSpecificRouteColours_extra).length > 0) {
        const newColoursObject = {};
        let actualColorChangeOccurred = false;
        for (const originalColorKey in stopSpecificRouteColours_extra) {
            const originalColorKeyUpper = originalColorKey.toUpperCase();
            let newKeyForColorData = originalColorKeyUpper;

            for (const proposal of idChangeProposals) {
                if (proposal.originalId.toUpperCase() === originalColorKeyUpper) {
                    newKeyForColorData = proposal.newId;
                    break;
                }
            }
            newColoursObject[newKeyForColorData] = stopSpecificRouteColours_extra[originalColorKey];
            if (newKeyForColorData !== originalColorKey || originalColorKey !== originalColorKeyUpper) { // Catches rename or case normalization
                actualColorChangeOccurred = true;
            }
        }
        if (actualColorChangeOccurred || Object.keys(newColoursObject).length !== Object.keys(stopSpecificRouteColours_extra).length) {
            stopSpecificRouteColours_extra = newColoursObject;
            stopColorsModifiedInCache = true;
        }
    }

    // 5. Persist all changes to Firebase
    if (definitionsModifiedInCache || scheduleEntriesModifiedCount > 0 || closedStopsListModifiedInCache || stopColorsModifiedInCache) {
        masterListApplyChangesStatus_el_extra.textContent = "Saving changes to Firebase...";
        try {
            if (definitionsModifiedInCache && typeof saveAllDefinedStopsToFirebase_ExtraPage === 'function') {
                await saveAllDefinedStopsToFirebase_ExtraPage();
            }

            // Always rebuild schedule if definitions changed OR schedule entries were touched,
            // as ancillary data (like uniqueBusStops with service) needs recalculation.
            if ((definitionsModifiedInCache || scheduleEntriesModifiedCount > 0) && typeof rebuildAndSaveEntireScheduleToFirebase_ExtraPage === 'function') {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
            }

            if (closedStopsListModifiedInCache && typeof saveClosedStopsToFirebase_ExtraPage === 'function') {
                await saveClosedStopsToFirebase_ExtraPage();
            }
            if (stopColorsModifiedInCache && typeof saveStopSpecificColoursToFirebase_ExtraPage === 'function') {
                await saveStopSpecificColoursToFirebase_ExtraPage();
            }

            let summaryMessage = `Successfully applied ${idChangeProposals.length} Stop ID change(s). `;
            summaryMessage += `Definitions updated: ${definitionsModifiedInCache}. `;
            summaryMessage += `Schedule entries affected: ${scheduleEntriesModifiedCount}. `;
            summaryMessage += `Closed stops list updated: ${closedStopsListModifiedInCache}. `;
            summaryMessage += `Colors map updated: ${stopColorsModifiedInCache}.`;
            masterListApplyChangesStatus_el_extra.textContent = summaryMessage;
            masterListApplyChangesStatus_el_extra.style.color = '#2ecc71';
            
            if (typeof renderUIDependentElements_ExtraPage === 'function') {
                renderUIDependentElements_ExtraPage(); // Refresh the UI with persisted changes
            }

        } catch (error) {
            console.error("Error applying bulk Stop ID changes and saving to Firebase:", error);
            masterListApplyChangesStatus_el_extra.textContent = "Error saving bulk ID changes: " + error.message;
            masterListApplyChangesStatus_el_extra.style.color = '#e74c3c';
            alert("A critical error occurred while saving bulk Stop ID changes. Some data might be inconsistent. It is recommended to refresh the page and verify the changes or reload from a backup if necessary.");
            if (typeof loadInitialData_ExtraPage === 'function') {
                 await loadInitialData_ExtraPage(); // Try to resync with DB
            }
        }
    } else {
        masterListApplyChangesStatus_el_extra.textContent = "No data changes were made that required saving to Firebase.";
        masterListApplyChangesStatus_el_extra.style.color = '#7f8c8d';
    }
}

        function rsg_handleDragStart_ExtraPage(event) {  
            rsg_draggedItemIndex_extra = parseInt(event.target.closest('li').dataset.index); event.dataTransfer.effectAllowed = 'move'; event.dataTransfer.setData('text/plain', rsg_draggedItemIndex_extra); setTimeout(() => { event.target.closest('li').classList.add('rsg-dragging-item'); }, 0); if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = "Dragging stop..."; rsgStatusMessage_el_extra.style.color = "#3498db"; }
        }

        function rsg_handleDragOver_ExtraPage(event) { 
            event.preventDefault(); event.dataTransfer.dropEffect = 'move'; const targetLi = event.target.closest('li'); if (targetLi && parseInt(targetLi.dataset.index) !== rsg_draggedItemIndex_extra) { Array.from(rsgStopSequenceList_el_extra.children).forEach(child => child.classList.remove('rsg-dragover-target')); targetLi.classList.add('rsg-dragover-target'); }
        }

        function rsg_handleDragLeave_ExtraPage(event) { 
            const targetLi = event.target.closest('li'); if (targetLi) { targetLi.classList.remove('rsg-dragover-target');}
        }

        function rsg_handleDrop_ExtraPage(event) { 
    event.preventDefault(); 
    const targetLi = event.target.closest('li'); 
    if (!targetLi) return; 
    const droppedOnItemIndex = parseInt(targetLi.dataset.index); 
    Array.from(rsgStopSequenceList_el_extra.children).forEach(child => child.classList.remove('rsg-dragover-target')); 
    if (rsg_draggedItemIndex_extra !== null && rsg_draggedItemIndex_extra !== droppedOnItemIndex) { 
        const itemToMove = rsg_selectedStops_extra.splice(rsg_draggedItemIndex_extra, 1)[0]; 
        rsg_selectedStops_extra.splice(droppedOnItemIndex, 0, itemToMove); 
        rsg_renderStopSequence_ExtraPage(); 
        rsg_resetPreviewState("Stop order changed. Regenerate preview.", "info"); 
        rsg_isDirty = true;
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_handleDragEnd_ExtraPage(event) { 
             Array.from(rsgStopSequenceList_el_extra.children).forEach(childLi => { childLi.classList.remove('rsg-dragging-item'); childLi.classList.remove('rsg-dragover-target'); }); rsg_draggedItemIndex_extra = null;
        }

        function rsg_handleStopSearch_ExtraPage(event) {
    if (!rsgStopSearchInput_el_extra || !rsgStopSearchResults_el_extra) return;
    const searchTerm = rsgStopSearchInput_el_extra.value.toLowerCase().trim();
    rsgStopSearchResults_el_extra.innerHTML = '';

    if (searchTerm.length < 2) {
        return; // Don't search if term is too short
    }

    // Use allDefinedStops_data as the source for all known stops
    // Ensure allDefinedStops_data is an object before calling Object.values
    const definedStopsArray = Object.values(allDefinedStops_data || {});

    const filteredStops = definedStopsArray.filter(stop => {
        // Ensure stop and its properties exist before trying to access them
        const stopName = stop.stopName || "";
        const stopID = stop.stopID || ""; // stop.stopID should be guaranteed if from allDefinedStops_data
        return stopName.toLowerCase().includes(searchTerm) || stopID.toLowerCase().includes(searchTerm);
    }).slice(0, 15); // Show up to 15 results

    if (filteredStops.length > 0) {
        filteredStops.forEach(stop => { // 'stop' here is an object like {stopID, stopName, direction}
            const itemDiv = document.createElement('div');
            itemDiv.classList.add('rsg-search-result-item');

            let content = `<span class="rsg-search-stop-name">${stop.stopName || 'N/A'} (${stop.stopID})</span>`;
            
            // Display direction using the consistent logic
            let directionTextForResult = "";
            if (stop.direction && stop.direction.trim() !== "" && stop.direction.trim().toUpperCase() !== "NO DIRECTION") {
                directionTextForResult = `Towards: ${stop.direction}`;
            }
            // If direction is empty or "No Direction", directionTextForResult remains "", and the line won't be added.
            if (directionTextForResult) {
                content += `<span class="rsg-search-stop-details">${directionTextForResult}</span>`;
            }


            // Display serving routes (will be empty if none serve it)
            // stopToServingRoutesMap_extra is correctly derived from currentWorkingSchedule_extra (active services)
            const servingRoutes = stopToServingRoutesMap_extra.get(stop.stopID) || new Set();

            if (servingRoutes.size > 0) {
                content += `<div class="rsg-search-serving-routes">`;
                Array.from(servingRoutes).sort(compareLineNames_ExtraPage).slice(0, 5).forEach(line => {
                    const bgColor = getRouteTileColour_ExtraPage(line, stop.stopID);
                    const textColor = getTextColourForBackground_ExtraPage(bgColor);
                    content += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor};font-size:0.7em;padding:0.1em 0.3em;">${line}</span>`;
                });
                if (servingRoutes.size > 5) content += `<span style="font-size:0.7em;opacity:0.8;"> +${servingRoutes.size - 5} more</span>`;
                content += `</div>`;
            } else {
                // Indicate that no routes currently serve this defined stop
                content += `<div class="rsg-search-serving-routes" style="font-size:0.7em;opacity:0.7;margin-top:0.2em;">(No routes currently serve this stop)</div>`;
            }

            itemDiv.innerHTML = content;
            itemDiv.addEventListener('click', () => {
                rsg_addStopToSequence_ExtraPage(stop.stopID, stop.stopName, stop.direction);
                rsgStopSearchInput_el_extra.value = '';
                rsgStopSearchResults_el_extra.innerHTML = '';
                rsgStopSearchInput_el_extra.focus();
            });
            rsgStopSearchResults_el_extra.appendChild(itemDiv);
        });
    } else {
        rsgStopSearchResults_el_extra.innerHTML = '<div class="rsg-search-result-item">No defined stops match your search.</div>';
    }
}

        function rsg_addStopToSequence_ExtraPage(stopID, stopName, direction) { 
    if (rsg_selectedStops_extra.length > 0 && rsg_selectedStops_extra[rsg_selectedStops_extra.length -1].stopID === stopID) { 
        if(rsgStatusMessage_el_extra) { 
            rsgStatusMessage_el_extra.textContent = "Stop already last in sequence."; 
            rsgStatusMessage_el_extra.style.color = "#f1c40f"; 
        } 
        return; 
    } 
    rsg_selectedStops_extra.push({ 
        stopID: stopID, 
        stopName: stopName, 
        direction: direction, 
        timeAdjustment: rsg_selectedStops_extra.length > 0 ? 2 : 0 
    }); 
    rsg_renderStopSequence_ExtraPage(); 
    rsg_resetPreviewState("Stop added. Regenerate preview if needed.", "info"); 
    rsg_isDirty = true;
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_removeStopFromSequence_ExtraPage(index) {
    if (rsg_selectedStops_extra && rsg_selectedStops_extra.length > index) {
        rsg_selectedStops_extra.splice(index, 1);
    }
    rsg_isDirty = true;
    rsg_renderStopSequence_ExtraPage();
    rsg_resetPreviewState("Stop removed. Regenerate preview if needed.", "info");
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_handleGenerateSchedulePreview_ExtraPage(isPreCheck = false, configDataToProcess = null) {
    if (!rsgRouteNameInput_el_extra ||
        !rsgDestinationNameInput_el_extra ||
        !rsgFirstStopTimesInput_el_extra ||
        !rsgStatusMessage_el_extra) {
        if (!isPreCheck && rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Critical Error: RSG form components missing.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }

    let routeName, opProfileForGeneration, destName, firstStopTimesStr, currentStopSequence;

    if (configDataToProcess) {
        routeName = (configDataToProcess.routeName || "").trim().toUpperCase();
        opProfileForGeneration = configDataToProcess.operatingProfile || "";
        destName = (configDataToProcess.destinationName || "").trim();
        firstStopTimesStr = (configDataToProcess.firstStopTimes || "").trim();
        currentStopSequence = configDataToProcess.stopSequence || [];
    } else {
        routeName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
        opProfileForGeneration = rsg_getSelectedOpProfilesString_ExtraPage();
        destName = rsgDestinationNameInput_el_extra.value.trim();
        firstStopTimesStr = rsgFirstStopTimesInput_el_extra.value.trim();
        currentStopSequence = rsg_selectedStops_extra;
    }

    if (!routeName) {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "Route Name is required.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
    if (!opProfileForGeneration && !configDataToProcess) {
        if (rsg_lastLoadedOpProfile_extra &&
            routeName.toUpperCase() === (rsg_lastLoadedRouteName_extra || "").toUpperCase() &&
            destName === (rsg_lastLoadedDestName_extra || "")) {
            opProfileForGeneration = rsg_lastLoadedOpProfile_extra;
            if (!isPreCheck && rsgStatusMessage_el_extra && !configDataToProcess) {
                rsgStatusMessage_el_extra.dataset.profileAssumed = 'true';
            }
        } else {
            if (!isPreCheck && !configDataToProcess) {
                rsgStatusMessage_el_extra.textContent = "Operating Profile is required.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            return false;
        }
    } else if (!opProfileForGeneration && configDataToProcess) {
        if (!isPreCheck && rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error: Saved configuration for route ${routeName} is missing an operating profile.`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }

    if (!destName) {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "Destination Name is required.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
    if (!currentStopSequence || currentStopSequence.length === 0) {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "Please add at least one stop to the sequence.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }

    const firstStopTimes = firstStopTimesStr.split(/\t|,|;/).map(t => t.trim()).filter(t => t.match(/^\d{2}:\d{2}$/));
    if (firstStopTimes.length === 0 && firstStopTimesStr !== "") {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "Invalid format or no valid times for first stop (HH:MM, TAB/comma/semicolon separated).";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
     if (firstStopTimes.length === 0 && firstStopTimesStr === "") {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "First stop times are required.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }

    rsg_generatedPreviewEntries_extra = [];

    firstStopTimes.forEach(startTimeHHMM => {
        const startParts = startTimeHHMM.split(':');
        let currentMinutesFromMidnight = parseInt(startParts[0], 10) * 60 + parseInt(startParts[1], 10);
        let currentDayOffset = 0;

        currentStopSequence.forEach((stop, index) => {
            if (!stop || typeof stop.stopID === 'undefined') return;
            if (index > 0) {
                const adjustment = (typeof stop.timeAdjustment === 'number' && !isNaN(stop.timeAdjustment)) ? stop.timeAdjustment : 0;
                currentMinutesFromMidnight += adjustment;
            }
            while (currentMinutesFromMidnight >= 1440) {
                currentMinutesFromMidnight -= 1440; currentDayOffset++;
            }
            while (currentMinutesFromMidnight < 0) {
                currentMinutesFromMidnight += 1440; currentDayOffset--;
            }
            const hours = Math.floor(currentMinutesFromMidnight / 60);
            const minutes = currentMinutesFromMidnight % 60;
            const scheduledTimeOutput = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            
            rsg_generatedPreviewEntries_extra.push({
                internalId: `${stop.stopID}_${routeName}_${scheduledTimeOutput.replace(':', '')}_${opProfileForGeneration.replace(/[^a-zA-Z0-9]/g, '')}_rsg${Date.now()}${index}`,
                stopID: stop.stopID, stopName: stop.stopName, direction: stop.direction,
                lineName: routeName, destinationName: destName, scheduledTime: scheduledTimeOutput,
                OperatingProfile: opProfileForGeneration, DayOffset: String(currentDayOffset)
            });
        });
    });

    if (!isPreCheck && !configDataToProcess) {
        rsg_renderPreviewTable_ExtraPage();

        if (rsgAddToWorkingScheduleButton_el_extra) {
            const canAdd = rsg_generatedPreviewEntries_extra.length > 0;
            rsgAddToWorkingScheduleButton_el_extra.disabled = !canAdd;
            if (canAdd) {
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.add('save');
            } else {
                rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
            }
        }

        if (rsgSchedulePreviewContainer_el_extra) {
            rsgSchedulePreviewContainer_el_extra.style.display = rsg_generatedPreviewEntries_extra.length > 0 ? 'block' : 'none';
        }

        let statusMsg = "";
        let statusColor = "";
        if (rsgStatusMessage_el_extra.dataset.profileAssumed === 'true') {
             statusMsg = `Preview with assumed profile '${opProfileForGeneration}' `;
             statusMsg += rsg_generatedPreviewEntries_extra.length > 0 ? `generated ${rsg_generatedPreviewEntries_extra.length} entries.` : `generated 0 entries. Check inputs.`;
             statusColor = rsg_generatedPreviewEntries_extra.length > 0 ? '#2ecc71' : '#f1c40f';
             statusMsg += " Save will require explicit profile selection if assumption is not desired.";
        } else {
            statusMsg = rsg_generatedPreviewEntries_extra.length > 0 ? `Preview generated for ${rsg_generatedPreviewEntries_extra.length} entries.` : `Preview generated 0 entries. Check inputs.`;
            statusColor = rsg_generatedPreviewEntries_extra.length > 0 ? '#2ecc71' : '#f1c40f';
        }
        rsgStatusMessage_el_extra.textContent = statusMsg;
        rsgStatusMessage_el_extra.style.color = statusColor;
        delete rsgStatusMessage_el_extra.dataset.profileAssumed;
        rsg_updateRsgActionButtonsState(); // Added call
    }
    return rsg_generatedPreviewEntries_extra.length > 0;
}

        function rsg_renderPreviewTable_ExtraPage() { 
            if (!rsgPreviewTableBody_el_extra || !rsgSchedulePreviewContainer_el_extra) return; rsgPreviewTableBody_el_extra.innerHTML = ''; if (rsg_generatedPreviewEntries_extra.length === 0) { return; } rsg_generatedPreviewEntries_extra.forEach(entry => { const row = rsgPreviewTableBody_el_extra.insertRow(); row.insertCell().textContent = entry.stopID; row.insertCell().textContent = entry.stopName; row.insertCell().textContent = entry.scheduledTime; row.insertCell().textContent = entry.lineName; row.insertCell().textContent = entry.destinationName; row.insertCell().textContent = entry.OperatingProfile; row.insertCell().textContent = entry.DayOffset; });
        }
        
        function rsg_resetPreviewState(message = "Configuration changed. Please (re)generate preview or add short workings.", messageType = "info") {
    rsg_generatedPreviewEntries_extra = [];

    if(rsgPreviewTableBody_el_extra) {
        rsgPreviewTableBody_el_extra.innerHTML = '';
    }
    if(rsgSchedulePreviewContainer_el_extra) {
        rsgSchedulePreviewContainer_el_extra.style.display = 'none';
    }

    if(rsgAddToWorkingScheduleButton_el_extra) {
        rsgAddToWorkingScheduleButton_el_extra.disabled = true;
        rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
        rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
    }

    if(rsgStatusMessage_el_extra) {
        const isCurrentMessageError = rsgStatusMessage_el_extra.style.color === 'rgb(231, 76, 60)' || rsgStatusMessage_el_extra.style.color === '#e74c3c';
        if (!isCurrentMessageError || messageType !== "info" ) {
            rsgStatusMessage_el_extra.textContent = message;
            if (messageType === "info") {
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            } else if (messageType === "success") {
                rsgStatusMessage_el_extra.style.color = "#2ecc71";
            } else if (messageType === "error") {
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            } else {
                rsgStatusMessage_el_extra.style.color = "";
            }
        }
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

async function rsg_handleAddGeneratedToWorkingSchedule_ExtraPage() {
    if (!currentUser_extra) {
        alert("Please log in to modify the working schedule.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Not logged in.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    if (!rsg_generatedPreviewEntries_extra || rsg_generatedPreviewEntries_extra.length === 0) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "No schedule entries generated in the preview to add.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    // Get target details from RSG form inputs
    const targetRouteName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
    let targetOpProfile = rsg_getSelectedOpProfilesString_ExtraPage(); // From checkboxes
    const targetDestName = rsgDestinationNameInput_el_extra.value.trim();

    const previewSample = rsg_generatedPreviewEntries_extra[0]; // Assuming preview is not empty here

    // If checkboxes were empty, but preview was generated (e.g. from a loaded config or assumed profile),
    // use the profile from the preview sample for consistency in the confirmation and subsequent operations.
    if (!targetOpProfile && previewSample && previewSample.OperatingProfile) {
        targetOpProfile = previewSample.OperatingProfile;
        console.log("rsg_handleAddGeneratedToWorkingSchedule: Using Operating Profile from preview sample as checkboxes were empty:", targetOpProfile);
    }

    // Validate that the preview matches the current form settings for Route, Destination, and final Operating Profile
    if (previewSample.lineName.toUpperCase() !== targetRouteName ||
        previewSample.destinationName !== targetDestName ||
        previewSample.OperatingProfile !== targetOpProfile) {

        let mismatchDetail = "";
        if (previewSample.lineName.toUpperCase() !== targetRouteName) mismatchDetail += `Route (Preview: ${previewSample.lineName}, Form: ${targetRouteName}). `;
        if (previewSample.destinationName !== targetDestName) mismatchDetail += `Destination (Preview: ${previewSample.destinationName}, Form: ${targetDestName}). `;
        if (previewSample.OperatingProfile !== targetOpProfile) mismatchDetail += `Profile (Preview: ${previewSample.OperatingProfile}, Form: ${targetOpProfile}). `;

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Form settings (Route/Dest/Profile) do not match the generated preview. Mismatches: ${mismatchDetail}Please re-generate preview if settings changed.`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }
    
    if (!targetRouteName || !targetOpProfile || !targetDestName) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route Name, Operating Profile, and Destination Name must be defined in Section 1 to update the schedule.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const actionChoice = prompt(
        `Choose action for the ${rsg_generatedPreviewEntries_extra.length} previewed entries for:\n` +
        `Route: ${targetRouteName}\nProfile: ${targetOpProfile}\nDestination: ${targetDestName}\n\n` +
        `1. OVERWRITE existing entries for this specific Route, Profile, and Destination.\n` +
        `2. ADD these new entries (will append if R/P/D exists, or create if new).\n\n` +
        `Enter 1 or 2 (or Cancel):`
    );

    let newEntriesCount = rsg_generatedPreviewEntries_extra.length;
    let operationPerformed = false;
    // Deep copy the preview entries to avoid modifying the preview state directly
    const entriesToAdd = JSON.parse(JSON.stringify(rsg_generatedPreviewEntries_extra));

    if (actionChoice === "1") { // OVERWRITE for specific R/P/D
        if (confirm(`ARE YOU SURE you want to REMOVE all existing entries for Route "${targetRouteName}", Profile "${targetOpProfile}", Destination "${targetDestName}" AND THEN ADD these ${newEntriesCount} new entries?`)) {
            let removedCount = 0;
            // Filter out existing entries that match the exact R/P/D
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
                const matchesRPD = entry.lineName && entry.lineName.toUpperCase() === targetRouteName &&
                                   entry.OperatingProfile === targetOpProfile &&
                                   entry.destinationName === targetDestName;
                if (matchesRPD) {
                    removedCount++;
                    return false; // Exclude this entry
                }
                return true; // Keep other entries
            });
            
            // Add the new entries from the preview
            currentWorkingSchedule_extra.push(...entriesToAdd);
            
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Locally removed ${removedCount} existing entries. Will add ${newEntriesCount} new entries for ${targetRouteName}/${targetOpProfile}/${targetDestName}. Preparing to save...`;
                rsgStatusMessage_el_extra.style.color = "#f1c40f"; // Yellow for processing
            }
            operationPerformed = true;
        } else {
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Overwrite operation cancelled by user.";
                rsgStatusMessage_el_extra.style.color = ""; // Neutral
            }
            return; // User cancelled overwrite confirmation
        }
    } else if (actionChoice === "2") { // ADD (append)
        currentWorkingSchedule_extra.push(...entriesToAdd); // Append new entries
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `${newEntriesCount} entries will be ADDED to the working schedule (for ${targetRouteName}/${targetOpProfile}/${targetDestName} if applicable). Preparing to save...`;
            rsgStatusMessage_el_extra.style.color = "#f1c40f"; // Yellow for processing
        }
        operationPerformed = true;
    } else {
        if (actionChoice !== null && rsgStatusMessage_el_extra) { // User entered something other than 1 or 2
            rsgStatusMessage_el_extra.textContent = "Invalid choice. Operation cancelled.";
        } else if (rsgStatusMessage_el_extra) { // User pressed Cancel on the prompt
             rsgStatusMessage_el_extra.textContent = "Add to working schedule cancelled.";
        }
        if (rsgStatusMessage_el_extra) rsgStatusMessage_el_extra.style.color = ""; // Neutral
        return; // Invalid choice or cancelled
    }

    if (operationPerformed) {
        // Ensure targetRouteName for the save operation is correctly from the RSG form
        const rsgRouteNameForSave = rsgRouteNameInput_el_extra.value.trim().toUpperCase(); 

        if (!rsgRouteNameForSave) { // Should have been caught earlier, but a good final check
            console.error("RSG Add to Working: Critical error - targetRouteName is empty before Firebase save.");
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Error: Route name missing for save operation. Cannot proceed.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            return; 
        }

        try {
            // *** THIS IS THE MODIFIED PART ***
            // Call the new targeted save function, passing only the route name.
            // The save function will then extract all data for this route (across all its R/P/Ds)
            // from the currentWorkingSchedule_extra and update Firebase accordingly.
            if (rsgStatusMessage_el_extra) { // Update status before await
                 rsgStatusMessage_el_extra.textContent = `Saving changes for route "${rsgRouteNameForSave}" to Firebase...`;
                 rsgStatusMessage_el_extra.style.color = "#3498db"; // Blue for in-progress
            }
            await saveSpecificRouteDataToFirebase_ExtraPage(rsgRouteNameForSave); 
            
            // Success message after saveSpecificRouteDataToFirebase_ExtraPage completes
            if (rsgStatusMessage_el_extra) {
                const messageAction = actionChoice === "1" 
                    ? `Overwrote entries for R/P/D "${targetRouteName}/${targetOpProfile}/${targetDestName}" and added ${newEntriesCount} new ones.` 
                    : `Added ${newEntriesCount} entries for R/P/D "${targetRouteName}/${targetOpProfile}/${targetDestName}".`;
                rsgStatusMessage_el_extra.textContent = `Successfully saved to Firebase. ${messageAction} Working schedule now has ${currentWorkingSchedule_extra.length} total entries.`;
                rsgStatusMessage_el_extra.style.color = "#2ecc71"; // Green for success
            }
            
            // Reset the RSG preview and update UI elements
            rsg_resetPreviewState("Successfully added to working schedule and saved to Firebase. Ready for new generation.", "success");
            renderUIDependentElements_ExtraPage(); // Refresh any UI elements dependent on the schedule

        } catch (error) {
            // Error handling specifically for the saveSpecificRouteDataToFirebase_ExtraPage call
            // The saveSpecificRouteDataToFirebase_ExtraPage function might set its own detailed error message.
            console.error("Error in rsg_handleAddGeneratedToWorkingSchedule_ExtraPage (calling targeted save to Firebase):", error);
            if (rsgStatusMessage_el_extra && !rsgStatusMessage_el_extra.textContent.includes("Error saving route")) { 
                // Check if a more specific error wasn't already set by the save function
                rsgStatusMessage_el_extra.textContent = "Error saving to Firebase: " + error.message + ". Local changes might not be live. Please review.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            // At this point, currentWorkingSchedule_extra reflects the local changes,
            // but Firebase save failed. The user needs to be aware.
        }
    }
}
        // ++ END Route Schedule Generator Functions ++

// ++ Functions for "Schedule This Configuration" -- START ++
        function rsg_closeScheduleDateTimeModal_ExtraPage() {
    const modal = document.getElementById('rsg-schedule-datetime-modal-extra');
    if (modal) modal.style.display = 'none';
    rsg_batchScheduleItems = [];
}

        async function rsg_confirmScheduleGoLive_ExtraPage() {
    const goLiveInput = document.getElementById(
        "rsg-go-live-datetime-input-extra"
    );
    const modalStatus = document.getElementById(
        "rsg-schedule-datetime-modal-status-extra"
    );

    if (!goLiveInput || !modalStatus) {
        return;
    }
    const goLiveDateTime = goLiveInput.value;

    if (!goLiveDateTime) {
        modalStatus.textContent =
            "Please select a go-live date and time.";
        modalStatus.style.color = "#e74c3c";
        return;
    }
    const goLiveDateObj = new Date(goLiveDateTime);
    if (isNaN(goLiveDateObj.getTime())) {
        modalStatus.textContent = "Invalid date/time format.";
        modalStatus.style.color = "#e74c3c";
        return;
    }

    if (goLiveDateObj <= new Date()) {
        modalStatus.textContent =
            "Go-live date/time must be in the future.";
        modalStatus.style.color = "#e74c3c";
        return;
    }

    const { database, dbSet, dbRef } = window.firebaseOMSI;
    let successCount = 0;
    let errorCount = 0;
    const scheduledByUser = currentUser_extra
        ? currentUser_extra.email
        : "unknown";
    const scheduledAtTimestamp = new Date().toISOString();

    if (
        rsg_batchScheduleItems &&
        rsg_batchScheduleItems.length > 0
    ) {
        modalStatus.textContent = `Processing ${rsg_batchScheduleItems.length} configurations for scheduling...`;
        modalStatus.style.color = "#f1c40f";

        for (const batchItem of rsg_batchScheduleItems) {
            const configurationToSchedule = {
                taskType: "applySchedule",
                routeName: batchItem.routeName,
                destinationName: batchItem.destinationName,
                operatingProfile: batchItem.operatingProfile,
                stopSequence: batchItem.stopSequence,
                firstStopTimes: batchItem.firstStopTimes,
                scheduledEntries: batchItem.scheduledEntries,
                goLiveDateTime: goLiveDateObj.toISOString(),
                scheduledAt: scheduledAtTimestamp,
                status: "pending",
                userEmail: scheduledByUser,
                sourceConfigKey: batchItem.configKey,
                sourceConfigName: batchItem.userDisplayName,
            };

            try {
                const scheduleKey = `sched_${Date.now()}_${sanitizeFirebaseKey(
                    batchItem.routeName
                )}_${successCount}`;
                await dbSet(
                    dbRef(
                        database,
                        `<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{scheduleKey}`
                    ),
                    configurationToSchedule
                );
                successCount++;
            } catch (error) {
                errorCount++;
            }
        }

        modalStatus.textContent = `Batch scheduling complete. Success: ${successCount}, Failed: ${errorCount}.`;
        modalStatus.style.color =
            errorCount > 0 ? "#e74c3c" : "#2ecc71";
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Batch scheduling: ${successCount} succeeded, ${errorCount} failed. Go-live: ${goLiveDateObj.toLocaleString()}.`;
            rsgStatusMessage_el_extra.style.color =
                errorCount > 0 ? "#e74c3c" : "#2ecc71";
        }
        rsg_batchScheduleItems = [];
        setTimeout(
            rsg_closeScheduleDateTimeModal_ExtraPage,
            errorCount > 0 ? 4000 : 2000
        );
    } else {
        const routeName = rsgRouteNameInput_el_extra.value.trim();
        let operatingProfile =
            rsg_getSelectedOpProfilesString_ExtraPage();
        const destinationName =
            rsgDestinationNameInput_el_extra.value.trim();

        if (
            !operatingProfile &&
            rsg_lastLoadedOpProfile_extra &&
            routeName.toUpperCase() ===
                (
                    rsg_lastLoadedRouteName_extra || ""
                ).toUpperCase() &&
            destinationName === (rsg_lastLoadedDestName_extra || "")
        ) {
            operatingProfile = rsg_lastLoadedOpProfile_extra;
        }

        if (
            !routeName ||
            !operatingProfile ||
            !destinationName ||
            rsg_selectedStops_extra.length === 0 ||
            !rsgFirstStopTimesInput_el_extra.value.trim()
        ) {
            modalStatus.textContent =
                "Cannot schedule: Main RSG form is incomplete (Route, Profile, Dest, Sequence, Times).";
            modalStatus.style.color = "#e74c3c";
            return;
        }

        if (
            !rsg_generatedPreviewEntries_extra ||
            rsg_generatedPreviewEntries_extra.length === 0
        ) {
            modalStatus.textContent =
                "No preview entries generated for the current RSG setup. Please generate preview first.";
            modalStatus.style.color = "#e74c3c";
            return;
        }

        const configurationToSchedule = {
            taskType: "applySchedule",
            routeName: routeName,
            destinationName: destinationName,
            operatingProfile: operatingProfile,
            stopSequence: JSON.parse(
                JSON.stringify(rsg_selectedStops_extra)
            ),
            firstStopTimes:
                rsgFirstStopTimesInput_el_extra.value.trim(),
            scheduledEntries: JSON.parse(
                JSON.stringify(rsg_generatedPreviewEntries_extra)
            ),
            goLiveDateTime: goLiveDateObj.toISOString(),
            scheduledAt: scheduledAtTimestamp,
            status: "pending",
            userEmail: scheduledByUser,
        };

        modalStatus.textContent =
            "Scheduling current configuration...";
        modalStatus.style.color = "#f1c40f";

        try {
            const scheduleKey = `sched_${Date.now()}_${sanitizeFirebaseKey(
                routeName
            )}`;
            await dbSet(
                dbRef(
                    database,
                    `<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{scheduleKey}`
                ),
                configurationToSchedule
            );
            modalStatus.textContent =
                "Configuration scheduled successfully!";
            modalStatus.style.color = "#2ecc71";
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Current configuration for <span class="math-inline">\{routeName\} \(</span>{operatingProfile}) scheduled for ${goLiveDateObj.toLocaleString()}.`;
                rsgStatusMessage_el_extra.style.color = "#2ecc71";
            }
            setTimeout(
                rsg_closeScheduleDateTimeModal_ExtraPage,
                2000
            );
        } catch (error) {
            modalStatus.textContent =
                "Error scheduling: " + error.message;
            modalStatus.style.color = "#e74c3c";
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent =
                    "Error scheduling configuration.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
        }
    }

    isScheduledTasksCacheValid_extra = false;
    if (
        typeof loadAndDisplayScheduledUpdates_ExtraPage ===
        "function"
    ) {
        loadAndDisplayScheduledUpdates_ExtraPage();
    }
}

        function handleScheduleThisConfiguration() {
            console.log("Schedule This Configuration button clicked!");
            const scheduleModal = document.getElementById('rsg-schedule-datetime-modal-extra');
            
            if (!currentUser_extra) {
                alert("Please log in to schedule configurations.");
                if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = "Please log in.";
                    rsgStatusMessage_el_extra.style.color = "#e74c3c";
                }
                return;
            }

            if (scheduleModal) {
                // Perform a pre-check to ensure the current RSG form state can generate a valid preview.
                // The rsg_handleGenerateSchedulePreview_ExtraPage(true) function itself will set status messages if validation fails.
                if (!rsg_handleGenerateSchedulePreview_ExtraPage(true)) { // Pass true for isPreCheck
                    // rsg_handleGenerateSchedulePreview_ExtraPage(true) will already set rsgStatusMessage_el_extra on failure.
                    // We could add an additional, more direct message here if desired, but it might be redundant.
                    // e.g., if(rsgStatusMessage_el_extra) rsgStatusMessage_el_extra.textContent = "Cannot schedule: current RSG form is invalid. Please correct and generate a preview.";
                    return; 
                }
                
                // If pre-check passes (meaning a valid schedule *could* be generated), then proceed to show modal.
                const modalStatus = document.getElementById('rsg-schedule-datetime-modal-status-extra');
                if (modalStatus) modalStatus.textContent = ''; // Clear previous modal status

                const goLiveInput = document.getElementById('rsg-go-live-datetime-input-extra');
                if (goLiveInput) {
                    const tomorrow = new Date();
                    tomorrow.setDate(tomorrow.getDate() + 1); // Default to tomorrow
                    tomorrow.setHours(5, 0, 0, 0); // Default to 05:00 AM (typical service change time)
                    
                    const year = tomorrow.getFullYear();
                    const month = String(tomorrow.getMonth() + 1).padStart(2, '0');
                    const day = String(tomorrow.getDate()).padStart(2, '0');
                    const hours = String(tomorrow.getHours()).padStart(2, '0');
                    const minutes = String(tomorrow.getMinutes()).padStart(2, '0');
                    goLiveInput.value = `${year}-${month}-${day}T${hours}:${minutes}`;
                }
                scheduleModal.style.display = 'flex';
            } else {
                console.error("Schedule DateTime modal (rsg-schedule-datetime-modal-extra) not found!");
                if (rsgStatusMessage_el_extra) {
                     rsgStatusMessage_el_extra.textContent = "Error: Scheduling modal component is missing.";
                     rsgStatusMessage_el_extra.style.color = "#e74c3c";
                }
            }
        }
        // ++ Functions for "Schedule This Configuration" -- END ++

// ++ Scheduled Route Updates (SRU) Functions -- START ++

        async function loadAndDisplayScheduledUpdates_ExtraPage() {
    const listContainer = document.getElementById('sru-updates-list-container-extra');
    if (!listContainer || !window.firebaseOMSI) {
        if (listContainer) listContainer.innerHTML = '<p>Error: Firebase not available.</p>';
        console.error("SRU/SRD Load: Firebase or list container not available.");
        return;
    }
    listContainer.innerHTML = '<p>Loading all scheduled tasks...</p>';
    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;

    // Initialize with empty objects
    scheduledRouteUpdates_extra = {};
    scheduledRouteDeletions_extra = {};

    try {
        // Fetch timetable application updates
        console.log("SRU Load: Attempting to fetch schedule application tasks...");
        const updatesSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULED_ROUTE_UPDATES));
        if (updatesSnap.exists()) {
            scheduledRouteUpdates_extra = updatesSnap.val() || {}; // Ensure it's an object
        }
        console.log(`SRU Load: Fetched ${Object.keys(scheduledRouteUpdates_extra).length} schedule application tasks.`);

        // Fetch route deletion tasks
        console.log("SRU Load: Attempting to fetch route deletion tasks...");
        const deletionsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULED_DELETIONS));
        if (deletionsSnap.exists()) {
            scheduledRouteDeletions_extra = deletionsSnap.val() || {}; // Ensure it's an object
        } else {
            scheduledRouteDeletions_extra = {}; // Path doesn't exist or is null
        }
        // --- THIS IS THE DETAILED LOG YOU WERE ASKING FOR ---
        console.log(`SRU Load: Fetched ${Object.keys(scheduledRouteDeletions_extra).length} route deletion tasks. Content:`, JSON.parse(JSON.stringify(scheduledRouteDeletions_extra)));
        // --- END OF DETAILED LOG ---

        renderScheduledUpdatesList_ExtraPage();
        
        // *** ADD THIS LINE ***
        checkAndDisplayDueUpdatesNotification_ExtraPage();

    } catch (error) {
        console.error("Error loading scheduled tasks (updates and/or deletions):", error);
        listContainer.innerHTML = `<p style="color:#e74c3c;">Error loading tasks: ${error.message}</p>`;
        // Ensure they are reset on error too
        scheduledRouteUpdates_extra = {};
        scheduledRouteDeletions_extra = {};
    }
}

        function renderScheduledUpdatesList_ExtraPage() {
    const listContainer = document.getElementById(
        "sru-updates-list-container-extra"
    );
    const batchRadiosContainer = document.getElementById(
        "sru-batch-golive-radios-container-extra"
    );

    if (!listContainer || !batchRadiosContainer) {
        if (listContainer)
            listContainer.innerHTML =
                "<p>Error: UI container missing for tasks.</p>";
        if (batchRadiosContainer)
            batchRadiosContainer.innerHTML =
                "<p>Error: UI container missing for batch apply radios.</p>";
        return;
    }

    listContainer.innerHTML =
        "<p>Processing scheduled tasks list...</p>";
    batchRadiosContainer.innerHTML =
        "<p>Processing go-live times...</p>";

    let allApplyScheduleTasks = [];
    let allDeleteTasks = [];

    if (
        typeof scheduledRouteUpdates_extra === "object" &&
        scheduledRouteUpdates_extra !== null
    ) {
        Object.entries(scheduledRouteUpdates_extra).forEach(
            ([key, value]) => {
                if (
                    value &&
                    typeof value === "object" &&
                    (value.taskType === "applySchedule" ||
                        value.taskTypeDisplay === "applySchedule")
                ) {
                    if (
                        value.status === "pending" ||
                        value.status === "error"
                    ) {
                        allApplyScheduleTasks.push({
                            key,
                            ...value,
                            taskTypeDisplay: "applySchedule",
                        });
                    }
                }
            }
        );
    }
    if (
        typeof scheduledRouteDeletions_extra === "object" &&
        scheduledRouteDeletions_extra !== null
    ) {
        Object.entries(scheduledRouteDeletions_extra).forEach(
            ([key, value]) => {
                if (
                    value &&
                    typeof value === "object" &&
                    (value.taskType === "deleteEntireRoute" ||
                        value.taskTypeDisplay ===
                            "deleteEntireRoute")
                ) {
                    if (
                        value.status === "pending" ||
                        value.status === "error"
                    ) {
                        allDeleteTasks.push({
                            key,
                            ...value,
                            taskTypeDisplay: "deleteEntireRoute",
                        });
                    }
                }
            }
        );
    }

    const allKnownRouteNamesFromSchedule = [
        ...new Set(
            currentWorkingSchedule_extra
                .map((e) => e.lineName)
                .filter(Boolean)
        ),
    ];
    const applyTasksGroupedByRouteThenTime = {};
    allApplyScheduleTasks.forEach((task) => {
        const routeNameForGrouping =
            task.routeName || "UnspecifiedRoute";
        const goLiveISO = task.goLiveDateTime;
        if (!goLiveISO) {
            if (
                !applyTasksGroupedByRouteThenTime[
                    "InvalidGoLiveTime"
                ]
            ) {
                applyTasksGroupedByRouteThenTime[
                    "InvalidGoLiveTime"
                ] = { UnknownTime: [] };
            }
            applyTasksGroupedByRouteThenTime["InvalidGoLiveTime"][
                "UnknownTime"
            ].push(task);
            return;
        }
        if (
            !applyTasksGroupedByRouteThenTime[routeNameForGrouping]
        ) {
            applyTasksGroupedByRouteThenTime[routeNameForGrouping] =
                {};
        }
        if (
            !applyTasksGroupedByRouteThenTime[routeNameForGrouping][
                goLiveISO
            ]
        ) {
            applyTasksGroupedByRouteThenTime[routeNameForGrouping][
                goLiveISO
            ] = [];
        }
        applyTasksGroupedByRouteThenTime[routeNameForGrouping][
            goLiveISO
        ].push(task);
    });

    const individualTasksFragment =
        document.createDocumentFragment();
    let anyContentRenderedOverall = false;

    const allRoutesToDisplaySet = new Set([
        ...allKnownRouteNamesFromSchedule,
        ...Object.keys(applyTasksGroupedByRouteThenTime).filter(
            (rn) =>
                rn !== "UnspecifiedRoute" &&
                rn !== "InvalidGoLiveTime"
        ),
        ...allDeleteTasks
            .map((t) => t.routeName)
            .filter(Boolean)
            .filter((rn) => rn !== "UnspecifiedRoute"),
    ]);
    const sortedRoutesToDisplay = Array.from(
        allRoutesToDisplaySet
    ).sort(compareLineNames_ExtraPage);

    if (
        sortedRoutesToDisplay.length > 0 ||
        (applyTasksGroupedByRouteThenTime["UnspecifiedRoute"] &&
            Object.keys(
                applyTasksGroupedByRouteThenTime["UnspecifiedRoute"]
            ).length > 0) ||
        (applyTasksGroupedByRouteThenTime["InvalidGoLiveTime"] &&
            Object.keys(
                applyTasksGroupedByRouteThenTime[
                    "InvalidGoLiveTime"
                ]
            ).length > 0) ||
        allDeleteTasks.some(
            (task) =>
                !task.routeName ||
                task.routeName === "UnspecifiedRoute"
        )
    ) {
        const sectionTitle = document.createElement("h3");
        sectionTitle.className = "subsection-title";
        sectionTitle.textContent =
            "Individually Pending & Actionable Scheduled Tasks (Grouped by Route)";
        sectionTitle.style.color = "#B2DFDB";
        sectionTitle.style.marginBottom = "1em";
        individualTasksFragment.appendChild(sectionTitle);
    }

    sortedRoutesToDisplay.forEach((routeName) => {
        const tasksByTimeForThisRoute =
            applyTasksGroupedByRouteThenTime[routeName];
        const deleteTasksForThisRoute = allDeleteTasks.filter(
            (task) =>
                task.routeName === routeName &&
                (task.status === "pending" ||
                    task.status === "error")
        );

        if (
            (tasksByTimeForThisRoute &&
                Object.keys(tasksByTimeForThisRoute).length > 0) ||
            deleteTasksForThisRoute.length > 0
        ) {
            anyContentRenderedOverall = true;
            const routeGroupDiv = document.createElement("div");
            routeGroupDiv.className = "sru-route-group subsection";
            routeGroupDiv.style.marginBottom = "2rem";
            routeGroupDiv.style.paddingTop = "0.5rem";
            routeGroupDiv.style.borderLeft = "3px solid #607D8B";

            const routeHeading = document.createElement("h4");
            routeHeading.style.marginTop = "0.2em";
            routeHeading.style.marginBottom = "0.5em";
            routeHeading.style.fontSize = "1.2em";
            routeHeading.style.borderBottom = "1px solid #555";
            routeHeading.style.paddingBottom = "0.4em";
            routeHeading.textContent = `Route: ${routeName}`;
            routeGroupDiv.appendChild(routeHeading);

            const cancelAllForRouteButton =
                document.createElement("button");
            cancelAllForRouteButton.className =
                "button tertiary sru-cancel-all-for-route-btn";
            cancelAllForRouteButton.textContent =
                "Cancel All Pending Updates for This Route";
            cancelAllForRouteButton.title = `Review and cancel all pending timetable updates for Route ${routeName}`;
            cancelAllForRouteButton.style.display = "block";
            cancelAllForRouteButton.style.width = "fit-content";
            cancelAllForRouteButton.style.marginBottom = "1em";
            cancelAllForRouteButton.style.fontSize = "0.85em";
            cancelAllForRouteButton.style.backgroundColor =
                "#b33930";
            cancelAllForRouteButton.style.color = "white";
            cancelAllForRouteButton.dataset.routeName = routeName;
            routeGroupDiv.appendChild(cancelAllForRouteButton);

            let contentAddedForThisRouteSection = false;

            if (
                tasksByTimeForThisRoute &&
                Object.keys(tasksByTimeForThisRoute).length > 0
            ) {
                contentAddedForThisRouteSection = true;
                const applyUpdatesSubheading =
                    document.createElement("h5");
                applyUpdatesSubheading.textContent =
                    "Timetable Updates for this route:";
                applyUpdatesSubheading.style.color = "#DAF7A6";
                applyUpdatesSubheading.style.fontSize = "1em";
                applyUpdatesSubheading.style.marginBottom = "0.5em";
                routeGroupDiv.appendChild(applyUpdatesSubheading);

                const sortedGoLiveTimes = Object.keys(
                    tasksByTimeForThisRoute
                ).sort(
                    (a, b) =>
                        new Date(a).getTime() -
                        new Date(b).getTime()
                );
                sortedGoLiveTimes.forEach((goLiveISO) => {
                    const batchOfTasks =
                        tasksByTimeForThisRoute[goLiveISO];
                    batchOfTasks.sort((a, b) => {
                        const opA = a.operatingProfile || "";
                        const opB = b.operatingProfile || "";
                        const destA = a.destinationName || "";
                        const destB = b.destinationName || "";
                        if (opA.localeCompare(opB) !== 0)
                            return opA.localeCompare(opB);
                        return destA.localeCompare(destB);
                    });

                    const batchContainerDiv =
                        document.createElement("div");
                    batchContainerDiv.className =
                        "sru-batch-container subsection";
                    batchContainerDiv.style.marginLeft = "1em";
                    batchContainerDiv.style.marginBottom = "1rem";
                    batchContainerDiv.style.padding = "0.8rem";
                    batchContainerDiv.style.borderLeft =
                        "4px solid #3498db";
                    batchContainerDiv.dataset.scheduleKey =
                        goLiveISO + "_" + routeName;

                    let batchStatusSummary = batchOfTasks.some(
                        (t) => t.status === "error"
                    )
                        ? "error (in batch)"
                        : "pending";
                    let batchDetailsHTML = `<h6 class="sru-task-title-heading" style="margin-top:0; margin-bottom:0.6em; font-size:1.0em; color: #ecf0f1;">Batch Go-Live: ${new Date(
                        goLiveISO
                    ).toLocaleString()} <span style="font-weight:bold; color:${
                        batchStatusSummary === "pending"
                            ? "#f39c12"
                            : "#e74c3c"
                    }">(${batchStatusSummary})</span></h6>`; // Added class here
                    batchDetailsHTML += `<p style="font-size:0.85em; margin-bottom:0.5em;">Contains ${batchOfTasks.length} update(s). Applying replaces <strong>entire Route ${routeName}</strong>.</p>`;
                    batchDetailsHTML +=
                        '<ul style="font-size:0.8em; padding-left:1.5em; margin-bottom:0.75em;">';
                    batchOfTasks.forEach((task) => {
                        let taskStatusColor =
                            task.status === "pending"
                                ? "#f1c40f"
                                : task.status === "error"
                                ? "#e74c3c"
                                : "#bdc3c7";
                        batchDetailsHTML += `<li style="margin-bottom:0.2em;">Target: (P: ${
                            task.operatingProfile || "N/A"
                        }, D: ${task.destinationName || "N/A"}) - ${
                            task.scheduledEntries
                                ? task.scheduledEntries.length
                                : 0
                        } entries. Status: <span style="color:${taskStatusColor}; font-weight:bold;">${
                            task.status || "N/A"
                        }</span></li>`;
                    });
                    batchDetailsHTML += "</ul>";

                    const batchActionsDiv =
                        document.createElement("div");
                    batchActionsDiv.style.marginTop = "0.5em";

                    const applyBatchButton =
                        document.createElement("button");
                    applyBatchButton.className =
                        "button save sru-apply-batch-btn";
                    applyBatchButton.textContent = `Apply This Batch Now`;
                    applyBatchButton.title = `Delete all for Route ${routeName}, apply ${batchOfTasks.length} updates.`;
                    applyBatchButton.addEventListener("click", () =>
                        handleApplyScheduledRouteBatch_ExtraPage(
                            batchOfTasks
                        )
                    );
                    batchActionsDiv.appendChild(applyBatchButton);

                    batchOfTasks.forEach((task) => {
                        const cancelTaskButton =
                            document.createElement("button");
                        cancelTaskButton.className =
                            "button small-action neutral sru-cancel-task-btn";
                        cancelTaskButton.textContent = `Cancel Update: (P: ${
                            task.operatingProfile || "N/A"
                        }, D: ${task.destinationName || "N/A"})`;
                        cancelTaskButton.style.marginLeft = "8px";
                        cancelTaskButton.style.fontSize = "0.75em";
                        cancelTaskButton.title = `Cancel only this specific update task: ${task.key}`;
                        cancelTaskButton.dataset.key = task.key;
                        cancelTaskButton.dataset.taskType =
                            "applySchedule";
                        batchActionsDiv.appendChild(
                            cancelTaskButton
                        );
                    });
                    batchContainerDiv.innerHTML = batchDetailsHTML;
                    batchContainerDiv.appendChild(batchActionsDiv);
                    routeGroupDiv.appendChild(batchContainerDiv);
                });
            }

            if (deleteTasksForThisRoute.length > 0) {
                contentAddedForThisRouteSection = true;
                const routeDeletionsSubheading =
                    document.createElement("h5");
                routeDeletionsSubheading.textContent =
                    "Scheduled Withdrawal for this Route:";
                routeDeletionsSubheading.style.color = "#E74C3C";
                routeDeletionsSubheading.style.marginTop =
                    tasksByTimeForThisRoute &&
                    Object.keys(tasksByTimeForThisRoute).length > 0
                        ? "1.5em"
                        : "0.5em";
                routeDeletionsSubheading.style.fontSize = "1em";
                routeDeletionsSubheading.style.borderTop =
                    tasksByTimeForThisRoute &&
                    Object.keys(tasksByTimeForThisRoute).length > 0
                        ? "1px dashed #555"
                        : "none";
                routeDeletionsSubheading.style.paddingTop =
                    tasksByTimeForThisRoute &&
                    Object.keys(tasksByTimeForThisRoute).length > 0
                        ? "0.75em"
                        : "0";
                routeGroupDiv.appendChild(routeDeletionsSubheading);

                deleteTasksForThisRoute.sort(
                    (a, b) =>
                        new Date(a.goLiveDateTime).getTime() -
                        new Date(b.goLiveDateTime).getTime()
                );
                deleteTasksForThisRoute.forEach((task) => {
                    const itemDiv = document.createElement("div");
                    itemDiv.classList.add("subsection");
                    itemDiv.style.marginBottom = "0.75rem";
                    itemDiv.style.padding = "0.75rem";
                    itemDiv.style.marginLeft = "1em";
                    itemDiv.style.borderLeft = "4px solid #c0392b";
                    itemDiv.dataset.scheduleKey = task.key;
                    itemDiv.dataset.taskType = "deleteEntireRoute";

                    let statusColor =
                        task.status === "pending"
                            ? "#f39c12"
                            : task.status === "error"
                            ? "#e74c3c"
                            : "#ecf0f1";
                    let actionsHTML = "";
                    if (
                        task.status === "pending" ||
                        task.status === "error"
                    ) {
                        actionsHTML = `<button class="button small-action tertiary sru-execute-deletion-btn" data-key="${
                            task.key
                        }" style="background-color:${
                            task.status === "error"
                                ? "#d35400"
                                : "#e67e22"
                        };">${
                            task.status === "error"
                                ? "Retry"
                                : "Withdraw Route Now"
                        }</button> `;
                    }
                    actionsHTML += `<button class="button small-action neutral sru-cancel-task-btn" data-key="${task.key}" data-task-type="deleteEntireRoute" style="margin-left:8px;">Cancel</button>`;

                    itemDiv.innerHTML = `
                        <h6 class="sru-task-title-heading" style="margin-top:0; margin-bottom:0.4em; font-size:1.0em; color: #e74c3c;">ROUTE WITHDRAWN (Go-Live: ${new Date(
                            task.goLiveDateTime
                        ).toLocaleString()})</h6>
                        <p style="font-size:0.9em;">Status: <span style="font-weight:bold; color:${statusColor};">${
                        task.status || "N/A"
                    }</span></p>
                        <p style="font-size:0.8em; opacity:0.8;">By: ${
                            task.userEmail || "System"
                        } (ID: ${
                        task.key ? task.key.substring(0, 10) : "N/A"
                    }...)</p>
                        ${
                            task.lastError
                                ? `<p style="font-size:0.8em; color:#e74c3c;">Error: ${task.lastError}</p>`
                                : ""
                        }
                        <div class="scheduled-update-actions" style="margin-top:0.75em;">${actionsHTML}</div>`; // Added class here
                    routeGroupDiv.appendChild(itemDiv);
                });
            }

            if (!contentAddedForThisRouteSection) {
                const noTasksMsg = document.createElement("p");
                noTasksMsg.textContent = `(No pending or error tasks currently scheduled for Route ${routeName})`;
                noTasksMsg.style.fontSize = "0.85em";
                noTasksMsg.style.opacity = "0.7";
                noTasksMsg.style.paddingLeft = "1em";
                noTasksMsg.style.fontStyle = "italic";
                routeGroupDiv.appendChild(noTasksMsg);
            }
            individualTasksFragment.appendChild(routeGroupDiv);
        }
    });

    function renderSpecialCategoryTasksToFragment(
        fragment,
        categoryName,
        categoryKey,
        tasksByTime,
        deleteTasks,
        headingColor = "#f1c40f"
    ) {
        const categoryApplyTasksByTime = tasksByTime
            ? tasksByTime[categoryKey]
            : null;
        const categoryDeleteTasksFiltered = deleteTasks
            ? deleteTasks.filter(
                    (task) =>
                        (task.routeName || "UnspecifiedRoute") ===
                            categoryKey &&
                        (task.status === "pending" ||
                            task.status === "error")
                )
            : [];

        if (
            (categoryApplyTasksByTime &&
                Object.keys(categoryApplyTasksByTime).length > 0) ||
            categoryDeleteTasksFiltered.length > 0
        ) {
            anyContentRenderedOverall = true;
            const specialRouteGroupDiv =
                document.createElement("div");
            specialRouteGroupDiv.className =
                "sru-route-group subsection";
            specialRouteGroupDiv.style.marginBottom = "2rem";
            specialRouteGroupDiv.style.paddingTop = "0.5rem";
            specialRouteGroupDiv.style.borderLeft = `3px solid ${headingColor}`;

            const specialRouteHeading =
                document.createElement("h4");
            specialRouteHeading.style.marginTop = "0.2em";
            specialRouteHeading.style.marginBottom = "1em";
            specialRouteHeading.style.fontSize = "1.2em";
            specialRouteHeading.style.borderBottom =
                "1px solid #555";
            specialRouteHeading.style.paddingBottom = "0.4em";
            specialRouteHeading.style.color = headingColor;
            specialRouteHeading.textContent = `Category: ${categoryName}`;
            specialRouteGroupDiv.appendChild(specialRouteHeading);

            let contentAddedForThisSpecialCategory = false;

            if (
                categoryApplyTasksByTime &&
                Object.keys(categoryApplyTasksByTime).length > 0
            ) {
                contentAddedForThisSpecialCategory = true;
                const applyUpdatesSubheading =
                    document.createElement("h5");
                applyUpdatesSubheading.textContent =
                    "Timetable Updates in this category:";
                applyUpdatesSubheading.style.color = "#DAF7A6";
                applyUpdatesSubheading.style.fontSize = "1em";
                applyUpdatesSubheading.style.marginBottom = "0.5em";
                specialRouteGroupDiv.appendChild(
                    applyUpdatesSubheading
                );

                Object.keys(categoryApplyTasksByTime)
                    .sort(
                        (a, b) =>
                            new Date(a).getTime() -
                            new Date(b).getTime()
                    )
                    .forEach((goLiveISO) => {
                        const batchOfTasks =
                            categoryApplyTasksByTime[goLiveISO];
                        const batchContainerDiv =
                            document.createElement("div");
                        batchContainerDiv.className =
                            "sru-batch-container subsection";
                        batchContainerDiv.style.marginLeft = "1em";
                        batchContainerDiv.style.marginBottom =
                            "1rem";
                        batchContainerDiv.style.padding = "0.8rem";
                        batchContainerDiv.style.borderLeft =
                            "4px solid #aaa";
                        batchContainerDiv.dataset.scheduleKey =
                            goLiveISO + "_" + categoryKey;

                        let batchStatusSummary = batchOfTasks.some(
                            (t) => t.status === "error"
                        )
                            ? "error (in batch)"
                            : "pending";
                        let batchDetailsHTML = `<h6 class="sru-task-title-heading" style="margin-top:0; margin-bottom:0.6em; font-size:1.0em; color: #ecf0f1;">Batch Go-Live: ${ // Added class here
                            goLiveISO === "UnknownTime"
                                ? "Unknown"
                                : new Date(
                                        goLiveISO
                                    ).toLocaleString()
                        } <span style="font-weight:bold; color:${
                            batchStatusSummary === "pending"
                                ? "#f39c12"
                                : "#e74c3c"
                        }">(${batchStatusSummary})</span></h6>`;
                        batchDetailsHTML += `<p style="font-size:0.85em; margin-bottom:0.5em;">Contains ${batchOfTasks.length} update(s). Review route names if "Unspecified".</p>`;
                        batchDetailsHTML +=
                            '<ul style="font-size:0.8em; padding-left:1.5em; margin-bottom:0.75em;">';
                        batchOfTasks.forEach((task) => {
                            let taskStatusColor =
                                task.status === "pending"
                                    ? "#f1c40f"
                                    : task.status === "error"
                                    ? "#e74c3c"
                                    : "#bdc3c7";
                            batchDetailsHTML += `<li style="margin-bottom:0.2em;">Route: ${
                                task.routeName || "N/A"
                            }, P: ${
                                task.operatingProfile || "N/A"
                            }, D: ${
                                task.destinationName || "N/A"
                            } - ${
                                task.scheduledEntries
                                    ? task.scheduledEntries.length
                                    : 0
                            } entries. Status: <span style="color:${taskStatusColor}; font-weight:bold;">${
                                task.status || "N/A"
                            }</span></li>`;
                        });
                        batchDetailsHTML += "</ul>";
                        batchContainerDiv.innerHTML =
                            batchDetailsHTML;

                        const batchActionsDiv =
                            document.createElement("div");
                        batchActionsDiv.style.marginTop = "0.5em";
                        batchOfTasks.forEach((task) => {
                            const cancelTaskButton =
                                document.createElement("button");
                            cancelTaskButton.className =
                                "button small-action neutral sru-cancel-task-btn";
                            cancelTaskButton.textContent = `Cancel Update for Route ${
                                task.routeName || "N/A"
                            }`;
                            cancelTaskButton.style.marginLeft =
                                "8px";
                            cancelTaskButton.style.fontSize =
                                "0.75em";
                            cancelTaskButton.title = `Cancel only this specific update task: ${task.key}`;
                            cancelTaskButton.dataset.key = task.key;
                            cancelTaskButton.dataset.taskType =
                                "applySchedule";
                            batchActionsDiv.appendChild(
                                cancelTaskButton
                            );
                        });
                        batchContainerDiv.appendChild(
                            batchActionsDiv
                        );
                        specialRouteGroupDiv.appendChild(
                            batchContainerDiv
                        );
                    });
            }

            if (categoryDeleteTasksFiltered.length > 0) {
                contentAddedForThisSpecialCategory = true;
                const routeDeletionsSubheading =
                    document.createElement("h5");
                routeDeletionsSubheading.textContent =
                    "Scheduled Deletions in this category:";
                routeDeletionsSubheading.style.color = "#E74C3C";
                routeDeletionsSubheading.style.marginTop =
                    categoryApplyTasksByTime &&
                    Object.keys(categoryApplyTasksByTime).length > 0
                        ? "1.5em"
                        : "0.5em";
                routeDeletionsSubheading.style.fontSize = "1em";
                specialRouteGroupDiv.appendChild(
                    routeDeletionsSubheading
                );

                categoryDeleteTasksFiltered.forEach((task) => {
                    const itemDiv = document.createElement("div");
                    itemDiv.classList.add("subsection");
                    itemDiv.style.marginBottom = "0.75rem";
                    itemDiv.style.padding = "0.75rem";
                    itemDiv.style.marginLeft = "1em";
                    itemDiv.style.borderLeft = "4px solid #c0392b";
                    itemDiv.dataset.scheduleKey = task.key;
                    itemDiv.dataset.taskType = "deleteEntireRoute";

                    let statusColor =
                        task.status === "pending"
                            ? "#f39c12"
                            : task.status === "error"
                            ? "#e74c3c"
                            : "#ecf0f1";
                    let actionsHTML = "";
                    if (
                        task.status === "pending" ||
                        task.status === "error"
                    ) {
                        actionsHTML = `<button class="button small-action tertiary sru-execute-deletion-btn" data-key="${
                            task.key
                        }" style="background-color:${
                            task.status === "error"
                                ? "#d35400"
                                : "#e67e22"
                        };">${
                            task.status === "error"
                                ? "Retry"
                                : "Withdraw Route Now"
                        }</button> `;
                    }
                    actionsHTML += `<button class="button small-action neutral sru-cancel-task-btn" data-key="${task.key}" data-task-type="deleteEntireRoute" style="margin-left:8px;">Cancel</button>`;
                    itemDiv.innerHTML = `<h6 class="sru-task-title-heading" style="margin-top:0; margin-bottom:0.4em; font-size:1.0em; color: #e74c3c;">DELETE ENTIRE ROUTE ${ // Added class here
                        task.routeName || ""
                    } (Go-Live: ${new Date(
                        task.goLiveDateTime
                    ).toLocaleString()})</h6> <p style="font-size:0.9em;">Status: <span style="font-weight:bold; color:${statusColor};">${
                        task.status || "N/A"
                    }</span></p> <p style="font-size:0.8em; opacity:0.8;">By: ${
                        task.userEmail || "System"
                    } (ID: ${
                        task.key ? task.key.substring(0, 10) : "N/A"
                    }...)</p> ${
                        task.lastError
                            ? `<p style="font-size:0.8em; color:#e74c3c;">Error: ${task.lastError}</p>`
                            : ""
                    } <div class="scheduled-update-actions" style="margin-top:0.75em;">${actionsHTML}</div>`;
                    specialRouteGroupDiv.appendChild(itemDiv);
                });
            }

            if (!contentAddedForThisSpecialCategory) {
                const noTasksMsg = document.createElement("p");
                noTasksMsg.textContent = `(No pending or error tasks found in category: ${categoryName})`;
                noTasksMsg.style.fontSize = "0.85em";
                noTasksMsg.style.opacity = "0.7";
                noTasksMsg.style.paddingLeft = "1em";
                noTasksMsg.style.fontStyle = "italic";
                specialRouteGroupDiv.appendChild(noTasksMsg);
            }
            fragment.appendChild(specialRouteGroupDiv);
        }
    }

    renderSpecialCategoryTasksToFragment(
        individualTasksFragment,
        "Tasks with Unspecified Route Name",
        "UnspecifiedRoute",
        applyTasksGroupedByRouteThenTime,
        allDeleteTasks,
        "#BCAAA4"
    );
    renderSpecialCategoryTasksToFragment(
        individualTasksFragment,
        "Tasks with Invalid Go-Live Time",
        "InvalidGoLiveTime",
        applyTasksGroupedByRouteThenTime,
        [], // No delete tasks for this special category typically
        "#EF9A9A"
    );

    listContainer.innerHTML = "";
    if (!anyContentRenderedOverall) {
        listContainer.innerHTML =
            '<p style="text-align:center; opacity:0.8;">No pending or error tasks found to display.</p>';
    } else {
        listContainer.appendChild(individualTasksFragment);
    }
    cachedScheduledTasksHTML_extra = listContainer.innerHTML;


    const batchRadiosFragment = document.createDocumentFragment();
    const sruApplyAllForTimeButton = document.getElementById(
        "sru-apply-all-for-time-button-extra"
    );
    const sruApplyAllStatusMessage = document.getElementById(
        "sru-apply-all-status-message-extra"
    );

    if (batchRadiosContainer && sruApplyAllForTimeButton) {
        const allPendingApplyScheduleTasksForRadioPopulation = [];
        if (
            typeof scheduledRouteUpdates_extra === "object" &&
            scheduledRouteUpdates_extra !== null
        ) {
            Object.values(scheduledRouteUpdates_extra).forEach(
                (value) => {
                    if (
                        value &&
                        typeof value === "object" &&
                        (value.taskType === "applySchedule" ||
                            value.taskTypeDisplay ===
                                "applySchedule") &&
                        value.status === "pending" &&
                        value.goLiveDateTime
                    ) {
                        allPendingApplyScheduleTasksForRadioPopulation.push(
                            value
                        );
                    }
                }
            );
        }

        const uniqueGoLiveTimesForRadio = [
            ...new Set(
                allPendingApplyScheduleTasksForRadioPopulation.map(
                    (task) => task.goLiveDateTime
                )
            ),
        ].sort(
            (a, b) => new Date(a).getTime() - new Date(b).getTime()
        );

        if (uniqueGoLiveTimesForRadio.length > 0) {
            uniqueGoLiveTimesForRadio.forEach((isoTime) => {
                const tasksForThisTime =
                    allPendingApplyScheduleTasksForRadioPopulation.filter(
                        (t) => t.goLiveDateTime === isoTime
                    );
                const affectedRoutesAtThisTime = [
                    ...new Set(
                        tasksForThisTime.map(
                            (t) => t.routeName || "Unspecified"
                        )
                    ),
                ].sort(compareLineNames_ExtraPage);
                const totalUpdatesForThisTime =
                    tasksForThisTime.length;
                const radioId = `sru-batch-golive-${new Date(
                    isoTime
                ).getTime()}`;
                const radioLabel = document.createElement("label");
                radioLabel.htmlFor = radioId;
                radioLabel.style.display = "block";
                radioLabel.style.marginBottom = "0.5em";
                radioLabel.style.cursor = "pointer";
                radioLabel.style.color = "#ecf0f1";
                const radioButton = document.createElement("input");
                radioButton.type = "radio";
                radioButton.name = "sruBatchGoLiveTime_extra";
                radioButton.id = radioId;
                radioButton.value = isoTime;
                radioButton.style.marginRight = "10px";
                radioButton.style.verticalAlign = "middle";
                radioButton.addEventListener("change", () => {
                    if (sruApplyAllForTimeButton)
                        sruApplyAllForTimeButton.disabled = false;
                    if (sruApplyAllStatusMessage) {
                        sruApplyAllStatusMessage.textContent = `Selected Go-Live: ${new Date(
                            isoTime
                        ).toLocaleString()}. This will affect ${
                            affectedRoutesAtThisTime.length
                        } route(s): ${affectedRoutesAtThisTime.join(
                            ", "
                        )} with ${totalUpdatesForThisTime} total update task(s).`;
                        sruApplyAllStatusMessage.style.color =
                            "#f1c40f";
                    }
                });
                radioLabel.appendChild(radioButton);
                radioLabel.appendChild(
                    document.createTextNode(
                        `${new Date(
                            isoTime
                        ).toLocaleString()} (${totalUpdatesForThisTime} tasks for ${
                            affectedRoutesAtThisTime.length
                        } routes: ${affectedRoutesAtThisTime.join(
                            ", "
                        )})`
                    )
                );
                batchRadiosFragment.appendChild(radioLabel);
            });
            if (sruApplyAllForTimeButton)
                sruApplyAllForTimeButton.disabled = true;
        } else {
            const p = document.createElement("p");
            p.style.opacity = "0.7";
            p.textContent =
                "No pending batches with valid go-live times available to apply globally by time.";
            batchRadiosFragment.appendChild(p);
            if (sruApplyAllForTimeButton)
                sruApplyAllForTimeButton.disabled = true;
        }
        batchRadiosContainer.innerHTML = "";
        batchRadiosContainer.appendChild(batchRadiosFragment);
        cachedBatchRadiosHTML_extra = batchRadiosContainer.innerHTML;
    }
    isScheduledTasksCacheValid_extra = true;
}

async function handleApplyAllBatchesForSelectedTime_ExtraPage() {
    if (!currentUser_extra) {
        if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = "Please log in."; sruApplyAllStatusMessage_el_extra.style.color = "#e74c3c"; }
        return;
    }

    const selectedRadio = document.querySelector('input[name="sruBatchGoLiveTime_extra"]:checked');
    if (!selectedRadio) {
        if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = "Please select a Go-Live Time from the list above."; sruApplyAllStatusMessage_el_extra.style.color = "#f1c40f"; }
        return;
    }

    const selectedGoLiveDateTimeISO = selectedRadio.value;
    if(sruApplyAllStatusMessage_el_extra) {
        sruApplyAllStatusMessage_el_extra.textContent = `Preparing to apply all batches for ${new Date(selectedGoLiveDateTimeISO).toLocaleString()}...`;
        sruApplyAllStatusMessage_el_extra.style.color = "#3498db";
    }

    const tasksToProcessForSelectedTime = [];
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.entries(scheduledRouteUpdates_extra).forEach(([key, task]) => {
            if (task && task.taskType === 'applySchedule' && task.status === 'pending' && task.goLiveDateTime === selectedGoLiveDateTimeISO && task.scheduledEntries && task.scheduledEntries.length > 0) {
                tasksToProcessForSelectedTime.push({ key, ...task });
            }
        });
    }

    if (tasksToProcessForSelectedTime.length === 0) {
        if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = "No valid pending timetable updates found for the selected time. The list might have refreshed."; sruApplyAllStatusMessage_el_extra.style.color = "#f1c40f"; }
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh the list as something changed
        return;
    }

    const tasksGroupedByRoute = tasksToProcessForSelectedTime.reduce((acc, task) => {
        const routeName = task.routeName || "UnspecifiedRoute";
        if (!acc[routeName]) {
            acc[routeName] = [];
        }
        acc[routeName].push(task);
        return acc;
    }, {});

    const affectedRouteNames = Object.keys(tasksGroupedByRoute).sort(compareLineNames_ExtraPage);
    const confirmMessage = `EXTREME CAUTION!\n\nYou are about to apply ALL pending timetable updates scheduled for:\nGo-Live Time: ${new Date(selectedGoLiveDateTimeISO).toLocaleString()}\n\nThis will affect the following ${affectedRouteNames.length} route(s):\n- ${affectedRouteNames.join('\n- ')}\n\nFor EACH of these routes, ALL of their current schedule data will be DELETED and REPLACED with the new schedule from these batches.\n\nThis action is IRREVERSIBLE for the live schedule data.\nAre you absolutely sure you want to proceed?`;

    if (!confirm(confirmMessage)) {
        if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = "Bulk batch application cancelled by user."; sruApplyAllStatusMessage_el_extra.style.color = ""; }
        return;
    }

    if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = `Processing ${tasksToProcessForSelectedTime.length} tasks for ${affectedRouteNames.length} routes. This may take some time...`; }
    if(sruApplyAllForTimeButton_el_extra) sruApplyAllForTimeButton_el_extra.disabled = true;


    let allAffectedTaskKeys = [];
    let totalEntriesAdded = 0;
    let errorsDuringLocalProcessing = [];

    // Create a deep copy of the working schedule to modify
    let tempWorkingSchedule = JSON.parse(JSON.stringify(currentWorkingSchedule_extra));

    for (const routeName of affectedRouteNames) {
        const tasksForThisRoute = tasksGroupedByRoute[routeName];
        if (!tasksForThisRoute || tasksForThisRoute.length === 0) continue;

        let allNewEntriesForThisRoute = [];
        tasksForThisRoute.forEach(task => {
            allNewEntriesForThisRoute.push(...JSON.parse(JSON.stringify(task.scheduledEntries))); // Deep copy entries
            if (task.key) allAffectedTaskKeys.push(task.key);
        });

        if (allNewEntriesForThisRoute.length === 0) {
            errorsDuringLocalProcessing.push(`Route ${routeName}: No schedule entries found in its tasks for this batch time. Skipped adding new entries, but existing data for this route (if any) will be removed as part of the overwrite.`);
            // Continue to remove existing entries for this route to fulfill "overwrite"
        }
        
        // Remove all existing entries for this route from the temporary schedule
        let removedCountForRoute = 0;
        tempWorkingSchedule = tempWorkingSchedule.filter(entry => {
            if (entry.lineName && entry.lineName.toUpperCase() === routeName.toUpperCase()) {
                removedCountForRoute++;
                return false;
            }
            return true;
        });

        // Add new (or potentially empty if error above) entries for this route
        const entriesToAddWithUniqueIds = allNewEntriesForThisRoute.map((e, idx) => ({
            ...e,
            internalId: e.internalId || `${e.stopID}_${e.lineName}_${(e.scheduledTime||"0000").replace(':','')}_applyAllBatches_${Date.now()}_${idx}`
        }));
        tempWorkingSchedule.push(...entriesToAddWithUniqueIds);
        totalEntriesAdded += entriesToAddWithUniqueIds.length;
    }

    if (errorsDuringLocalProcessing.length > 0) {
        alert("Some issues were found during local processing:\n" + errorsDuringLocalProcessing.join("\n") + "\n\nProceeding with Firebase update based on processed data. Review affected routes carefully after completion.");
    }

    try {
        // Update the main global working schedule with the processed data
        currentWorkingSchedule_extra = tempWorkingSchedule; 
        
        await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
        console.log("Bulk apply: Main schedule rebuilt and saved to Firebase.");

        const { database, dbUpdate, dbRef } = window.firebaseOMSI;
        const appliedAtTimestamp = new Date().toISOString();
        const appliedByEmail = currentUser_extra ? currentUser_extra.email : "system (bulk apply)";
        const statusUpdates = {};
        allAffectedTaskKeys.forEach(taskKey => {
            statusUpdates[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}/status`] = 'applied (all batches for time)';
            statusUpdates[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}/appliedAt`] = appliedAtTimestamp;
            statusUpdates[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}/appliedBy`] = appliedByEmail;
        });

        await dbUpdate(dbRef(database), statusUpdates);
        console.log("Bulk apply: Status of affected tasks updated in Firebase.");

        if(sruApplyAllStatusMessage_el_extra) {
            sruApplyAllStatusMessage_el_extra.textContent = `Successfully applied all batches for ${new Date(selectedGoLiveDateTimeISO).toLocaleString()}. ${affectedRouteNames.length} routes updated, ${totalEntriesAdded} total new entries added. Schedule is live.`;
            sruApplyAllStatusMessage_el_extra.style.color = "#2ecc71";
        }
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh the list
        renderUIDependentElements_ExtraPage();     // Refresh other UI if needed

    } catch (error) {
        console.error("Error applying all batches for selected time:", error);
        if(sruApplyAllStatusMessage_el_extra) {
            sruApplyAllStatusMessage_el_extra.textContent = `CRITICAL ERROR applying batches: ${error.message}. Schedule may be inconsistent. MANUAL REVIEW REQUIRED.`;
            sruApplyAllStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // Attempt to mark tasks as error if main save failed
        const { database, dbUpdate, dbRef } = window.firebaseOMSI; // ensure it's in scope
        const errorStatusUpdates = {};
         allAffectedTaskKeys.forEach(taskKey => {
            errorStatusUpdates[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}/status`] = 'error';
            errorStatusUpdates[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}/lastError`] = `Bulk Apply Error (Main Schedule): ${error.message}`;
        });
        await dbUpdate(dbRef(database), errorStatusUpdates).catch(err => console.error("Failed to mark batch tasks as error:", err));
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh to show error state
    } finally {
        if(sruApplyAllForTimeButton_el_extra) sruApplyAllForTimeButton_el_extra.disabled = false;
    }
}

        async function handleCancelScheduledTask_ExtraPage(
    taskKey,
    taskType
) {
    if (!taskKey || !taskType) {
        alert(
            "Error: Invalid task key or type for cancellation/deletion provided to handler."
        );
        return;
    }

    let taskCollection;
    let firebasePath;
    let taskDescription = "";
    let userFriendlyTaskName = "";

    if (taskType === "deleteEntireRoute") {
        taskCollection = scheduledRouteDeletions_extra;
        firebasePath = FB_PATH_SCHEDULED_DELETIONS;
        taskDescription = "route deletion task";
        userFriendlyTaskName = "Scheduled Route Deletion";
    } else if (taskType === "applySchedule") {
        taskCollection = scheduledRouteUpdates_extra;
        firebasePath = FB_PATH_SCHEDULED_ROUTE_UPDATES;
        taskDescription = "schedule application/update task";
        userFriendlyTaskName = "Scheduled Timetable Update";
    } else {
        alert(
            `Error: Unknown task type "${taskType}" for cancellation/deletion.`
        );
        return;
    }

    if (
        !taskCollection ||
        typeof taskCollection !== "object" ||
        taskCollection === null
    ) {
        alert(
            `Error: Task data for type "${userFriendlyTaskName}" is not loaded or is invalid in the system. The list will attempt to refresh.`
        );
        if (
            typeof loadAndDisplayScheduledUpdates_ExtraPage ===
            "function"
        )
            loadAndDisplayScheduledUpdates_ExtraPage();
        return;
    }

    if (!taskCollection[taskKey]) {
        alert(
            `Error: Task with key "<span class="math-inline">\{taskKey\}" not found for type "</span>{userFriendlyTaskName}". It might have already been processed or deleted. The list will refresh.`
        );
        if (
            typeof loadAndDisplayScheduledUpdates_ExtraPage ===
            "function"
        )
            loadAndDisplayScheduledUpdates_ExtraPage();
        return;
    }

    const taskToCancel = taskCollection[taskKey];
    const routeNameForConfirm =
        taskToCancel.routeName || "Unknown Route";
    const goLiveForConfirm = taskToCancel.goLiveDateTime
        ? new Date(taskToCancel.goLiveDateTime).toLocaleString()
        : "Unknown Go-Live";
    const profileForConfirm =
        taskType === "applySchedule"
            ? taskToCancel.operatingProfile || "N/A"
            : "N/A (Deletion Task)";

    let actionVerb = "DELETE RECORD of";
    if (
        taskToCancel.status === "pending" ||
        taskToCancel.status === "error"
    ) {
        actionVerb = "CANCEL and DELETE record of";
    }

    if (
        !confirm(
            `Are you sure you want to ${actionVerb} the <span class="math-inline">\{taskDescription\} for\:\\nRoute\: "</span>{routeNameForConfirm}"\nProfile(s): "${profileForConfirm}"\nGo-Live: ${goLiveForConfirm}\n\nThis action cannot be undone.`
        )
    ) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent =
                "Operation cancelled by user.";
            rsgStatusMessage_el_extra.style.color = "";
            setTimeout(() => {
                if (
                    rsgStatusMessage_el_extra.textContent ===
                    "Operation cancelled by user."
                )
                    rsgStatusMessage_el_extra.textContent = "";
            }, 3000);
        }
        return;
    }

    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        alert(
            "Firebase components not available. Cannot process cancellation."
        );
        return;
    }
    const { database, dbRemove, dbRef } = window.firebaseOMSI;

    try {
        await dbRemove(
            dbRef(database, `<span class="math-inline">\{firebasePath\}/</span>{taskKey}`)
        );

        if (taskCollection && taskCollection[taskKey]) {
            delete taskCollection[taskKey];
        }

        isScheduledTasksCacheValid_extra = false; 

        if (
            typeof loadAndDisplayScheduledUpdates_ExtraPage ===
            "function"
        )
            loadAndDisplayScheduledUpdates_ExtraPage();
        if (
            typeof checkAndDisplayDueUpdatesNotification_ExtraPage ===
            "function"
        )
            checkAndDisplayDueUpdatesNotification_ExtraPage();

        const successMsg = `<span class="math-inline">\{userFriendlyTaskName\} for "</span>{routeNameForConfirm}" (Profile: ${profileForConfirm}, Go-Live: ${goLiveForConfirm}) has been cancelled/record deleted.`;
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = successMsg;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
            setTimeout(() => {
                if (
                    rsgStatusMessage_el_extra.textContent ===
                    successMsg
                )
                    rsgStatusMessage_el_extra.textContent = "";
            }, 4000);
        } else {
            alert(successMsg);
        }
    } catch (error) {
        alert(
            `Error deleting task record from Firebase: ${error.message}. Please try refreshing the list.`
        );
        if (
            typeof loadAndDisplayScheduledUpdates_ExtraPage ===
            "function"
        )
            loadAndDisplayScheduledUpdates_ExtraPage();
    }
}

        async function handleApplyScheduledRouteBatch_ExtraPage(tasksInBatch) {
    if (!currentUser_extra) {
        alert("Please log in to apply batch updates.");
        return;
    }
    if (!tasksInBatch || tasksInBatch.length === 0) {
        alert("No tasks provided for batch application.");
        return;
    }

    const representativeTask = tasksInBatch[0];
    const targetRouteName = representativeTask.routeName.toUpperCase();
    const goLiveDateTimeForDisplay = new Date(representativeTask.goLiveDateTime).toLocaleString();

    let allNewEntriesForRoute = [];
    let involvedProfiles = new Set();
    let involvedDestinations = new Set();
    let taskKeysInBatch = [];

    tasksInBatch.forEach(task => {
        if ((task.taskTypeDisplay === 'applySchedule' || task.taskType === 'applySchedule') && task.routeName.toUpperCase() === targetRouteName) {
            if (task.scheduledEntries && task.scheduledEntries.length > 0) {
                allNewEntriesForRoute.push(...JSON.parse(JSON.stringify(task.scheduledEntries)));
                involvedProfiles.add(task.operatingProfile);
                involvedDestinations.add(task.destinationName);
            }
            if (task.key) {
                taskKeysInBatch.push(task.key);
            }
        }
    });

    if (allNewEntriesForRoute.length === 0) {
        alert(`No actual schedule entries found within the selected batch for Route "${targetRouteName}". Cannot apply.`);
        return;
    }

    const profileList = Array.from(involvedProfiles).join(', ') || "N/A";
    const destList = Array.from(involvedDestinations).join(', ') || "N/A";

    const confirmMessage = `Apply BATCH update for Route: ${targetRouteName}\n` +
                         `Go-Live: ${goLiveDateTimeForDisplay}\n\n` +
                         `This batch includes ${tasksInBatch.length} update(s) which will define the following for this route:\n` +
                         `Operating Profile(s): ${profileList}\n` +
                         `Destination(s): ${destList}\n\n` +
                         `WARNING: This will DELETE ALL existing schedules for the ENTIRE Route "${targetRouteName}" (across all its current profiles and destinations).\n` +
                         `Then, ${allNewEntriesForRoute.length} new entries from this batch will be added, forming the new complete schedule for this route.\n\n` +
                         `Proceed with wiping the whole route and applying this batch?`;

    if (!confirm(confirmMessage)) {
        alert("Batch application cancelled by user.");
        return;
    }

    if (rsgStatusMessage_el_extra) {
        rsgStatusMessage_el_extra.textContent = `Processing batch for Route ${targetRouteName}... This may take a moment.`;
        rsgStatusMessage_el_extra.style.color = "#3498db";
    }

    const { database, dbRef, dbUpdate } = window.firebaseOMSI; 
    let removedCount = 0;

    currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
        const matchesRouteOnly = entry.lineName && entry.lineName.toUpperCase() === targetRouteName;
        if (matchesRouteOnly) {
            removedCount++;
            return false;
        }
        return true;
    });

    const entriesToAddWithUniqueIds = allNewEntriesForRoute.map((e, idx) => ({
        ...e,
        internalId: e.internalId || `${e.stopID}_${e.lineName}_${(e.scheduledTime||"0000").replace(':','')}_batchApply_${Date.now()}_${idx}`
    }));
    currentWorkingSchedule_extra.push(...entriesToAddWithUniqueIds);

    try {
        await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);

        const appliedAtTimestamp = new Date().toISOString();
        const appliedByEmail = currentUser_extra ? currentUser_extra.email : "system (batch)";
        
        let individualUpdateSuccessCount = 0;
        let individualUpdateFailureCount = 0;
        
        for (const taskKey of taskKeysInBatch) {
            if (!taskKey || typeof taskKey !== 'string' || taskKey.trim() === "") {
                individualUpdateFailureCount++;
                continue;
            }

            const taskNodeRef = dbRef(database, `${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`);
            const updatesForThisIndividualTask = {
                status: 'applied (batch)', 
                appliedAt: appliedAtTimestamp,             
                appliedBy: appliedByEmail                  
            };

            try {
                await dbUpdate(taskNodeRef, updatesForThisIndividualTask); 
                individualUpdateSuccessCount++;
            } catch (e) {
                individualUpdateFailureCount++;
            }
        }

        loadAndDisplayScheduledUpdates_ExtraPage();
        renderUIDependentElements_ExtraPage();

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Batch update for Route ${targetRouteName} applied successfully. Live schedule updated. Status update attempts: ${individualUpdateSuccessCount} success, ${individualUpdateFailureCount} fail.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
            setTimeout(() => { if (rsgStatusMessage_el_extra.textContent && rsgStatusMessage_el_extra.textContent.includes(`Batch update for Route ${targetRouteName}`)) rsgStatusMessage_el_extra.textContent = ''; }, 7000);
        } else {
            alert(`Batch update for Route ${targetRouteName} applied successfully. Live schedule updated. Status update attempts: ${individualUpdateSuccessCount} success, ${individualUpdateFailureCount} fail.`);
        }

    } catch (error) {
        alert(`Error applying batch update for Route "${targetRouteName}": ${error.message}. The live schedule may be in an inconsistent state. Review carefully.`);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error applying batch for Route ${targetRouteName}: ${error.message}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        
        taskKeysInBatch.forEach(taskKey => {
            if (taskKey && typeof taskKey === 'string' && taskKey.trim() !== "") {
                const taskErrorPath = `${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`;
                const errorUpdatesForThisTask = {
                    status: 'error',
                    lastError: `Batch Apply Error (Main Schedule): ${error.message}`
                };
                dbUpdate(dbRef(database, taskErrorPath), errorUpdatesForThisTask)
                    .catch(err => {});
            }
        });
        loadAndDisplayScheduledUpdates_ExtraPage(); 
    }
}

function rsg_updateRsgActionButtonsState() {
    const routeName = rsgRouteNameInput_el_extra.value.trim();
    const opProfiles = rsg_getSelectedOpProfilesString_ExtraPage();
    const destName = rsgDestinationNameInput_el_extra.value.trim();
    const firstStopTimes = rsgFirstStopTimesInput_el_extra.value.trim();
    // stopSequenceHasItems is no longer part of formIsComplete for enabling Generate button
    // const stopSequenceHasItems = rsg_selectedStops_extra && rsg_selectedStops_extra.length > 0;

    const formIsComplete = routeName && opProfiles && destName && firstStopTimes; // Removed stopSequenceHasItems
    const previewExists = rsg_generatedPreviewEntries_extra && rsg_generatedPreviewEntries_extra.length > 0;

    const tickedCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox:checked');
    const tickedSavedConfigsCount = tickedCheckboxes.length;
    const disableMainFormActionsDueToBatchSelection = tickedSavedConfigsCount > 1;

    let shouldGenerateButtonBeDisabled;
    let shouldSaveButtonBeDisabled;
    let shouldScheduleThisButtonBeDisabled;
    let shouldAddPreviewButtonBeDisabled;

    if (disableMainFormActionsDueToBatchSelection) {
        shouldGenerateButtonBeDisabled = true;
        shouldSaveButtonBeDisabled = true;
        shouldScheduleThisButtonBeDisabled = true;
        shouldAddPreviewButtonBeDisabled = true;
    } else {
        shouldGenerateButtonBeDisabled = !formIsComplete;
        shouldSaveButtonBeDisabled = !formIsComplete || !previewExists;
        shouldScheduleThisButtonBeDisabled = !formIsComplete || !previewExists;
        shouldAddPreviewButtonBeDisabled = !formIsComplete || !previewExists;
    }

    if (rsgGenerateScheduleButton_el_extra) {
        rsgGenerateScheduleButton_el_extra.disabled = shouldGenerateButtonBeDisabled;
    }

    if (rsgSaveConfigurationButton_el_extra) {
        rsgSaveConfigurationButton_el_extra.disabled = shouldSaveButtonBeDisabled;
    }

    if (rsgScheduleThisConfigButton_el_extra) {
        rsgScheduleThisConfigButton_el_extra.disabled = shouldScheduleThisButtonBeDisabled;
    }

    if (rsgAddToWorkingScheduleButton_el_extra) {
        rsgAddToWorkingScheduleButton_el_extra.disabled = shouldAddPreviewButtonBeDisabled;
        if (!shouldAddPreviewButtonBeDisabled) {
            rsgAddToWorkingScheduleButton_el_extra.classList.remove('neutral');
            rsgAddToWorkingScheduleButton_el_extra.classList.add('save');
        } else {
            rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
            rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
        }
    }

    if (rsgScheduleSelectedConfigsButton_el_extra) {
        rsgScheduleSelectedConfigsButton_el_extra.disabled = (tickedSavedConfigsCount === 0);
    }
}

function rsg_openCopyFromModal_ExtraPage() { 
    if (!rsgCopyModal_el_extra || !rsgCopySourceRouteNameSelect_el_extra || !rsgCopySourceDestNameSelect_el_extra || !rsgCopyModalStatus_el_extra || !rsgCopySourceOpProfileSelect_el_extra) {
        console.error("RSG Copy Modal: One or more essential DOM elements are missing for modal open.");
        return;
    }
    const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))].filter(Boolean).sort(compareLineNames_ExtraPage); 
    
    // Populate Source Route Select
    rsgCopySourceRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route --</option>'; 
    uniqueRoutes.forEach(route => { 
        const opt = document.createElement('option'); 
        opt.value = route; 
        opt.textContent = route; 
        rsgCopySourceRouteNameSelect_el_extra.appendChild(opt); 
    }); 
    
    // Trigger population of dependent dropdowns (Destination, then Profile)
    // Call rsg_populateCopySourceDestinationSelect_ExtraPage which will in turn call profile population
    if (typeof rsg_populateCopySourceDestinationSelect_ExtraPage === 'function') {
        rsg_populateCopySourceDestinationSelect_ExtraPage(); 
    } else { // Fallback if dest populator somehow not ready, at least try to clear profiles
        if (typeof rsg_populateCopySourceOpProfileSelect_ExtraPage === 'function') {
            rsg_populateCopySourceOpProfileSelect_ExtraPage();
        }
    }
    
    if (rsgCopyModalStatus_el_extra) rsgCopyModalStatus_el_extra.textContent = ''; 
    if (rsgCopyModal_el_extra) rsgCopyModal_el_extra.style.display = 'flex';
}

        function rsg_closeCopyFromModal_ExtraPage() { 
             if (rsgCopyModal_el_extra) rsgCopyModal_el_extra.style.display = 'none';
        }

        function rsg_populateCopySourceDestinationSelect_ExtraPage() { 
    if (!rsgCopySourceDestNameSelect_el_extra || !rsgCopySourceRouteNameSelect_el_extra) { // Removed check for text input
        console.warn("RSG Copy Modal: Destination select or route select missing for populating destinations.");
        // Attempt to populate profiles even if destination can't be fully processed, as profiles might depend only on route
        if (typeof rsg_populateCopySourceOpProfileSelect_ExtraPage === 'function') {
            rsg_populateCopySourceOpProfileSelect_ExtraPage();
        }
        return;
    }

    // Read directly from the route SELECT element
    const selectedRoute = rsgCopySourceRouteNameSelect_el_extra.value.trim().toUpperCase(); 
    
    rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Destination --</option>'; 
    
    if (!selectedRoute) { 
        rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route First --</option>'; 
    } else {
        const uniqueDestinations = [...new Set(currentWorkingSchedule_extra.filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName).map(e => e.destinationName))].sort(); 
        if (uniqueDestinations.length > 0) { 
            uniqueDestinations.forEach(dest => { 
                const opt = document.createElement('option'); 
                opt.value = dest; 
                opt.textContent = dest; 
                rsgCopySourceDestNameSelect_el_extra.appendChild(opt); 
            }); 
        } else { 
            rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- No Destinations for this Route --</option>';
        }
    }
    // Call to populate profiles after destinations are set/cleared
    if (typeof rsg_populateCopySourceOpProfileSelect_ExtraPage === 'function') {
        rsg_populateCopySourceOpProfileSelect_ExtraPage();
    }
}

       async function rsg_handleCopyDataFromSource_ExtraPage() {
    if (!rsgCopySourceRouteNameSelect_el_extra || !rsgCopySourceOpProfileSelect_el_extra || !rsgCopySourceDestNameSelect_el_extra || !rsgCopyModalStatus_el_extra || !window.firebaseOMSI) {
        if (rsgCopyModalStatus_el_extra) {
            rsgCopyModalStatus_el_extra.textContent = "Error: Required elements for copy are missing.";
            rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
        }
        return;
    }
    // Read all values from SELECT elements
    const sourceRouteName = rsgCopySourceRouteNameSelect_el_extra.value;
    const sourceOpProfile = rsgCopySourceOpProfileSelect_el_extra.value;
    const sourceDestName = rsgCopySourceDestNameSelect_el_extra.value;

    if (!sourceRouteName || !sourceOpProfile || !sourceDestName) {
        rsgCopyModalStatus_el_extra.textContent = "All source fields (Route, Operating Profile, Destination) must be selected.";
        rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
        return;
    }

    rsgCopyModalStatus_el_extra.textContent = "Fetching source data...";
    rsgCopyModalStatus_el_extra.style.color = "#f1c40f";

    let sourceConfigData = null;
    let sourceStopSequence = [];
    let sourceFirstStopTimes = "";

    const sourceConfigKey = rsg_createConfigKey_ExtraPage(sourceRouteName, sourceOpProfile, sourceDestName);
    if (rsg_loadedConfigs_extra && rsg_loadedConfigs_extra[sourceConfigKey]) {
        sourceConfigData = rsg_loadedConfigs_extra[sourceConfigKey];
        console.log(`Copy From: Found matching saved RSG config: ${sourceConfigKey}`);
    }

    if (sourceConfigData) {
        sourceStopSequence = sourceConfigData.stopSequence || [];
        sourceFirstStopTimes = sourceConfigData.firstStopTimes || "";
    } else {
        console.log(`Copy From: No saved RSG config found for ${sourceRouteName}/${sourceOpProfile}/${sourceDestName}. Deriving from live schedule.`);
        const sourceRouteNameUpper = sourceRouteName.toUpperCase();
        const relevantEntries = currentWorkingSchedule_extra.filter(entry =>
            entry.lineName && entry.lineName.toUpperCase() === sourceRouteNameUpper &&
            entry.OperatingProfile === sourceOpProfile &&
            entry.destinationName === sourceDestName
        );

        if (relevantEntries.length > 0) {
            relevantEntries.sort((a, b) => {
                const absA = getAbsMinutes(a.scheduledTime, parseInt(a.DayOffset || 0));
                const absB = getAbsMinutes(b.scheduledTime, parseInt(b.DayOffset || 0));
                if (absA === null && absB === null) return 0;
                if (absA === null) return 1;
                if (absB === null) return -1;
                return absA - absB;
            });
            
            const firstTripSequence = [];
            if (relevantEntries.length > 0) {
                const firstStopIDOfJourney = relevantEntries[0].stopID;
                const firstDepartureTimeOfJourneyAbs = getAbsMinutes(relevantEntries[0].scheduledTime, parseInt(relevantEntries[0].DayOffset || 0));
                let absTimeOfPrevStopInSequence = -1; 
                const MIN_STOPS_BEFORE_START_ID_REPEAT_CONSIDERED_NEW_TRIP = 3; 

                for (let i = 0; i < relevantEntries.length; i++) {
                    const entry = relevantEntries[i];
                    if (!entry.stopID || !entry.scheduledTime) continue;
                    const currentTimeAbs = getAbsMinutes(entry.scheduledTime, parseInt(entry.DayOffset || 0));
                    if (currentTimeAbs === null) continue;

                    if (firstTripSequence.length > 0 && absTimeOfPrevStopInSequence !== -1) {
                        if (currentTimeAbs < absTimeOfPrevStopInSequence) break; 
                        if (entry.stopID === firstStopIDOfJourney) {
                            if (firstDepartureTimeOfJourneyAbs !== null && 
                                currentTimeAbs > (firstDepartureTimeOfJourneyAbs + 15) &&
                                firstTripSequence.length >= MIN_STOPS_BEFORE_START_ID_REPEAT_CONSIDERED_NEW_TRIP) {
                                break; 
                            }
                        }
                    }
                    
                    let calculatedTimeAdjustment = 0;
                    if (firstTripSequence.length > 0 && absTimeOfPrevStopInSequence !== -1) {
                         calculatedTimeAdjustment = currentTimeAbs - absTimeOfPrevStopInSequence;
                         if (calculatedTimeAdjustment < 0) calculatedTimeAdjustment = 2; 
                         else if (calculatedTimeAdjustment > 180) calculatedTimeAdjustment = 60; 
                    }
                    firstTripSequence.push({ 
                        stopID: entry.stopID, 
                        stopName: entry.stopName || entry.stopID, 
                        direction: entry.direction || "", 
                        timeAdjustment: calculatedTimeAdjustment
                    }); 
                    absTimeOfPrevStopInSequence = currentTimeAbs;
                }
            }
            sourceStopSequence = firstTripSequence;

            if (sourceStopSequence.length > 0) {
                const firstStopIdInPulledSequence = sourceStopSequence[0].stopID;
                const departuresForFirstStop = [...new Set(
                    relevantEntries
                        .filter(e => e.stopID === firstStopIdInPulledSequence && (e.DayOffset === "0" || !e.DayOffset))
                        .map(e => e.scheduledTime)
                        .filter(t => t && t.match(/^\d{2}:\d{2}$/))
                )].sort((a,b) => parseInt(a.replace(':','')) - parseInt(b.replace(':','')));
                sourceFirstStopTimes = departuresForFirstStop.join('\t'); 
            }
        }
    }

    if (sourceStopSequence.length > 0) {
        rsg_selectedStops_extra = JSON.parse(JSON.stringify(sourceStopSequence)); 
        if (rsgFirstStopTimesInput_el_extra) {
            rsgFirstStopTimesInput_el_extra.value = sourceFirstStopTimes;
        }
        rsg_renderStopSequence_ExtraPage(); 

        rsg_lastLoadedRouteName_extra = rsgRouteNameInput_el_extra.value.trim(); 
        rsg_lastLoadedDestName_extra = rsgDestinationNameInput_el_extra.value.trim();   
        rsg_lastLoadedOpProfile_extra = rsg_getSelectedOpProfilesString_ExtraPage(); 
        
        rsg_currentlyEditingConfigKey_extra = null; 
        rsg_currentlyEditingConfigDisplayName_extra = null;
        rsg_isDirty = true;

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Sequence and times successfully copied from source [${sourceRouteName} / ${sourceOpProfile} / ${sourceDestName}]. Please review.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
        }
        rsg_resetPreviewState("Data copied from source. Regenerate preview if settings are complete.", "success");
        rsg_closeCopyFromModal_ExtraPage();
    } else {
        rsgCopyModalStatus_el_extra.textContent = `No sequence data found or derived for source: ${sourceRouteName} (Profile: ${sourceOpProfile}, Dest: ${sourceDestName}). Nothing copied.`;
        rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
    }
    if(typeof rsg_updateRsgActionButtonsState === 'function') rsg_updateRsgActionButtonsState();
}

        function showExtraPageSection(sectionId) {
    if (!toolSectionsWrapper_el_extra) {
        return;
    }

    const allSections = toolSectionsWrapper_el_extra.querySelectorAll(".tool-content-section");
    allSections.forEach((s) => {
        s.style.display = "none";
    });

    const sectionToShow = document.getElementById(sectionId);
    if (sectionToShow) {
        sectionToShow.style.display = "block";
        localStorage.setItem("omsiExtraToolsActiveSection", sectionId);

        if (keyDeparturesIntervalId_extra) {
            clearInterval(keyDeparturesIntervalId_extra);
            keyDeparturesIntervalId_extra = null;
        }

        if (sectionId === "day-profile-override-section_extra") {
            if (typeof loadAndDisplayOverrides_ExtraPage === 'function') loadAndDisplayOverrides_ExtraPage();
            if (typeof dpo_populateProfileCheckboxes_ExtraPage === 'function') dpo_populateProfileCheckboxes_ExtraPage();
            if (typeof dpo_populateRouteSelection_ExtraPage === 'function') dpo_populateRouteSelection_ExtraPage();
            if (typeof updateSelectedDateInfo_ExtraPage === 'function') updateSelectedDateInfo_ExtraPage();
            if (typeof dpo_updateActionButtonsState === 'function') dpo_updateActionButtonsState();
        } else if (sectionId === "key-departures-section_extra") {
            if (typeof displayKeyDepartures_ExtraPage === 'function') {
                displayKeyDepartures_ExtraPage();
                keyDeparturesIntervalId_extra = setInterval(displayKeyDepartures_ExtraPage, KEY_DEPARTURES_REFRESH_INTERVAL_MS);
            }
        } else if (sectionId === "stop-manager-tool-section_extra") {
            if (typeof populateMasterStopList_ExtraPage === 'function') populateMasterStopList_ExtraPage();
            if (inputNewStopName_el_extra && inputNewStopId_el_extra &&
                !inputNewStopName_el_extra.value && !inputNewStopId_el_extra.value &&
                typeof autoGenerateAndSetNewStopId_ExtraPage === 'function') {
                autoGenerateAndSetNewStopId_ExtraPage();
            }
            if (duplicateStopsByNameDirResults_el_extra) {
                duplicateStopsByNameDirResults_el_extra.innerHTML = 'Click "Find Duplicates (Name/Dir)" to check.';
            }
        } else if (sectionId === "global-route-deletion-section_extra") {
            if (typeof populateGlobalRouteToDeleteList_ExtraPage === 'function') populateGlobalRouteToDeleteList_ExtraPage();
        } else if (sectionId === "route-schedule-generator-section_extra") {
            if (typeof rsg_populateRouteTiles_ExtraPage === 'function') rsg_populateRouteTiles_ExtraPage();
            if (typeof rsg_populateProfileCheckboxes_ExtraPage === 'function') rsg_populateProfileCheckboxes_ExtraPage();
            if (typeof rsg_renderSavedConfigsList_ExtraPage === 'function') rsg_renderSavedConfigsList_ExtraPage();
            if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') rsg_loadOrPullConfiguration_ExtraPage(null, true);
            if (typeof rsg_updateRsgActionButtonsState === 'function') rsg_updateRsgActionButtonsState();
        } else if (sectionId === "route-profile-deletion-section_extra") {
            if (typeof rpd_populateRouteSelect_ExtraPage === 'function') rpd_populateRouteSelect_ExtraPage();
        } else if (sectionId === "view-departures-section_extra") {
            if (typeof populateStopSelectorForDeparturesView_ExtraPage === 'function') {
                populateStopSelectorForDeparturesView_ExtraPage();
            }
            if (typeof displayDeparturesForSelectedStop_ExtraPage === 'function') {
                displayDeparturesForSelectedStop_ExtraPage();
            }
        } else if (sectionId === "timetable-exporter-section_extra") {
            if (typeof populateTimetableExporterRouteSelect_ExtraPage === 'function') populateTimetableExporterRouteSelect_ExtraPage();
            if (tteRouteNameInput_el_extra) tteRouteNameInput_el_extra.value = "";
            if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = "Select a route to download its timetable.";
        } else if (sectionId === "scheduled-route-updates-section_extra") {
            if (isScheduledTasksCacheValid_extra && cachedScheduledTasksHTML_extra && cachedBatchRadiosHTML_extra) {
                const listContainer = document.getElementById("sru-updates-list-container-extra");
                const batchRadiosContainer = document.getElementById("sru-batch-golive-radios-container-extra");
                if (listContainer) listContainer.innerHTML = cachedScheduledTasksHTML_extra;
                if (batchRadiosContainer) batchRadiosContainer.innerHTML = cachedBatchRadiosHTML_extra;
                if (typeof checkAndDisplayDueUpdatesNotification_ExtraPage === 'function') checkAndDisplayDueUpdatesNotification_ExtraPage();
            } else {
                if (typeof loadAndDisplayScheduledUpdates_ExtraPage === 'function') loadAndDisplayScheduledUpdates_ExtraPage();
            }
        } else if (sectionId === "scheduled-route-deletion-section_extra") {
            if (typeof srd_populateRouteSelect_ExtraPage === 'function') srd_populateRouteSelect_ExtraPage();
            if (srdGoLiveDateTimeInput_el_extra) srdGoLiveDateTimeInput_el_extra.value = "";
            if (srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = "Select a route and future date/time for deletion.";
        } else if (sectionId === 'config-data-section_extra') {
            if (typeof displaySchoolHolidays_ExtraPage === 'function') displaySchoolHolidays_ExtraPage();
            if (typeof renderEditableOpProfiles_ExtraPage === 'function') renderEditableOpProfiles_ExtraPage();
            const opStatusEl = document.getElementById('op-profiles-status-extra');
            if (opStatusEl) opStatusEl.textContent = '';
            const shStatusEl = document.getElementById('sh-status-message-extra');
            if (shStatusEl) shStatusEl.textContent = '';
        } else if (sectionId === 'calendar-view-section_extra') {
             if (typeof renderCalendarView_ExtraPage === 'function') {
                cv_currentDisplayDate_extra = new Date();
                renderCalendarView_ExtraPage();
             }
        } 
    }
}

        async function updateAuthUI_ExtraPage(user) { // Added async
    currentUser_extra = user;
    if (user) { // User is logged in
        if (authSection_el_extra) authSection_el_extra.style.display = 'none';
        if (topMenuBar_el_extra) topMenuBar_el_extra.style.display = 'block';
        if (logoutContainer_el_extra) logoutContainer_el_extra.style.display = 'flex'; 
        if (loginFormContainer_el_extra) loginFormContainer_el_extra.style.display = 'none';
        if (authStatus_el_extra) authStatus_el_extra.textContent = '';
        if (loggedInUserEmailDisplay_el_extra) loggedInUserEmailDisplay_el_extra.textContent = user.email;
        if (currentProfileDisplayContainer_el) currentProfileDisplayContainer_el.style.display = 'block'; 

        await loadInitialData_ExtraPage(); // *** CRITICAL: Added await here ***

        // Logic to determine which section to show after data is loaded
        const lastSection = localStorage.getItem('omsiExtraToolsActiveSection');
        const firstButton = topMenuBar_el_extra ? topMenuBar_el_extra.querySelector('.menu-button') : null;

        let sectionToActuallyShow = null;
        if (lastSection && document.getElementById(lastSection) && topMenuBar_el_extra && Array.from(topMenuBar_el_extra.querySelectorAll('.menu-button')).some(b => b.dataset.section === lastSection)) {
            sectionToActuallyShow = lastSection;
        } else if (firstButton && firstButton.dataset.section) {
            sectionToActuallyShow = firstButton.dataset.section;
        } else if (currentUser_extra && typeof showExtraPageSection === 'function' && !sectionToActuallyShow) {
            // Fallback if no valid section found yet, and user is logged in, show a default (e.g., first button if it exists)
            // This part might be redundant if renderUIDependentElements_ExtraPage always handles it.
            // For safety, this ensures *something* is attempted if firstButton logic didn't catch it.
             if (firstButton && firstButton.dataset.section) {
                sectionToActuallyShow = firstButton.dataset.section;
             }
        }

        // The actual showing of the section is typically handled by renderUIDependentElements_ExtraPage,
        // which is called at the end of the now-awaited loadInitialData_ExtraPage.
        // If a specific section needs to be forced here, ensure it doesn't conflict.
        // The current structure should be sufficient as renderUIDependentElements_ExtraPage calls showExtraPageSection.

        if (inputEmail_el_extra) inputEmail_el_extra.style.border = "1px solid #7f8c8d";
        if (inputPassword_el_extra) inputPassword_el_extra.style.border = "1px solid #7f8c8d";

    } else { // User is logged out
        if (authSection_el_extra) authSection_el_extra.style.display = 'block';
        if (topMenuBar_el_extra) topMenuBar_el_extra.style.display = 'none';
        if (logoutContainer_el_extra) logoutContainer_el_extra.style.display = 'none';
        if (loginFormContainer_el_extra) loginFormContainer_el_extra.style.display = 'block';
        if (authStatus_el_extra) authStatus_el_extra.textContent = 'Please log in.';

        if (inputEmail_el_extra) {
            inputEmail_el_extra.placeholder = "Email";
            inputEmail_el_extra.style.border = "1px solid #7f8c8d"; 
        }
        if (inputPassword_el_extra) {
            inputPassword_el_extra.placeholder = "Password";
            inputPassword_el_extra.style.border = "1px solid #7f8c8d"; 
        }

        if (loggedInUserEmailDisplay_el_extra) loggedInUserEmailDisplay_el_extra.textContent = '';
        if (currentProfileDisplayContainer_el) currentProfileDisplayContainer_el.style.display = 'none';
        if (toolSectionsWrapper_el_extra) {
            toolSectionsWrapper_el_extra.querySelectorAll('.tool-content-section').forEach(s => s.style.display = 'none');
        }

        // Clear all global data on logout
        currentWorkingSchedule_extra = [];
        closedStopIDs_extra = [];
        globalCustomRouteColours_extra = {};
        stopSpecificRouteColours_extra = {};
        pageSpecificSettings = {};
        rsg_loadedConfigs_extra = {};
        rsg_lastLoadedRouteName_extra = null;
        rsg_lastLoadedDestName_extra = null;
        rsg_lastLoadedOpProfile_extra = null;
        allDefinedStops_data = {};
        schoolHolidayDateRanges_extra = [];
        operationalOverrides_data = {};
        scheduledRouteDeletions_extra = {};
        scheduledRouteUpdates_extra = {};
        stopToServingRoutesMap_extra.clear();
        todayKeyTripEvents_extra = [];
        shownTripAlerts_extra = {};
        lastAlertDataPreparedDate_extra = null;
        isScheduledTasksCacheValid_extra = false;
        cachedBatchRadiosHTML_extra = null;
        cachedScheduledTasksHTML_extra = null;


        if (tripAlertIntervalId_extra) {
            clearInterval(tripAlertIntervalId_extra);
            tripAlertIntervalId_extra = null;
        }
        if (keyDeparturesIntervalId_extra) {
            clearInterval(keyDeparturesIntervalId_extra);
            keyDeparturesIntervalId_extra = null;
        }

        // Render UI elements to their default logged-out state (e.g., clear lists)
        if (typeof renderUIDependentElements_ExtraPage === 'function') {
            renderUIDependentElements_ExtraPage(); 
        }
    }
}
        
async function loadInitialData_ExtraPage() {
    let msg = "Loading data for Extra Modules...";
    console.log("loadInitialData_ExtraPage: Starting...");

    // Initialize/reset local data structures
    currentWorkingSchedule_extra = [];
    closedStopIDs_extra = [];
    globalCustomRouteColours_extra = {};
    stopSpecificRouteColours_extra = {};
    rsg_loadedConfigs_extra = {};
    allDefinedStops_data = {};
    schoolHolidayDateRanges_extra = [];
    operationalOverrides_data = {};
    scheduledRouteDeletions_extra = scheduledRouteDeletions_extra || {};
    scheduledRouteUpdates_extra = scheduledRouteUpdates_extra || {};

    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        msg = "Firebase not connected. Using default configurations where possible.";
        console.error(msg);
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = msg;
        // Fallback to hardcoded defaults
        if (DEFAULT_SCHOOL_HOLIDAY_RANGES && Array.isArray(DEFAULT_SCHOOL_HOLIDAY_RANGES)) {
             schoolHolidayDateRanges_extra = DEFAULT_SCHOOL_HOLIDAY_RANGES.map((h, index) => ({
                id: h.id || `sh-default-fb-err-${Date.now()}-${index}`, ...h
            }));
        } else { schoolHolidayDateRanges_extra = []; }
        // RSG_OPERATING_PROFILES_LIST retains its global 'let' default
        renderUIDependentElements_ExtraPage();
        if (typeof checkAndDisplayDueUpdatesNotification_ExtraPage === 'function') {
            checkAndDisplayDueUpdatesNotification_ExtraPage();
        }
        return;
    }

    const { database, dbGet, dbSet, dbRef, dbChild } = window.firebaseOMSI;

    try {
        console.log("loadInitialData_ExtraPage: Attempting to load core data from Firebase...");
        // 1. Load actual schedule entries
        const scheduleSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULES_BY_ROUTE));
        const flatScheduleFromDB = [];
        
        // MODIFICATION START
        console.log(`[DEBUG LIDI] Checking if schedule data exists at ${FB_PATH_SCHEDULES_BY_ROUTE}:`, scheduleSnap.exists());
        if (scheduleSnap.exists() && typeof scheduleSnap.val() === 'object' && scheduleSnap.val() !== null) {
            const schedulesByRoute = scheduleSnap.val();
            console.log("[DEBUG LIDI] Raw schedulesByRoute data:", schedulesByRoute);

            let routesCount = 0;
            let profilesCount = 0;
            let destinationsCount = 0;
            let entriesCount = 0;

            for (const routeKey in schedulesByRoute) { // Iterate safely
                if (Object.hasOwnProperty.call(schedulesByRoute, routeKey)) {
                    routesCount++;
                    const routeData = schedulesByRoute[routeKey];
                    if (routeData && typeof routeData === 'object') {
                        for (const profileKey in routeData) {
                            if (Object.hasOwnProperty.call(routeData, profileKey)) {
                                profilesCount++;
                                const profileData = routeData[profileKey];
                                if (profileData && typeof profileData === 'object') {
                                    for (const destKey in profileData) {
                                        if (Object.hasOwnProperty.call(profileData, destKey)) {
                                            destinationsCount++;
                                            const destData = profileData[destKey];
                                            if (destData && Array.isArray(destData.entries)) {
                                                destData.entries.forEach(entry => {
                                                    if (entry) {
                                                        flatScheduleFromDB.push({ ...entry });
                                                        entriesCount++;
                                                    }
                                                });
                                            } else {
                                                console.warn(`[DEBUG LIDI] Missing or invalid 'entries' array for ${routeKey}/${profileKey}/${destKey}:`, destData);
                                            }
                                        }
                                    }
                                } else {
                                    console.warn(`[DEBUG LIDI] Invalid profileData for ${routeKey}/${profileKey}:`, profileData);
                                }
                            }
                        }
                    } else {
                        console.warn(`[DEBUG LIDI] Invalid routeData for ${routeKey}:`, routeData);
                    }
                }
            }
            console.log(`[DEBUG LIDI] Summarizing loaded schedule data: Routes: ${routesCount}, Profiles: ${profilesCount}, Destinations: ${destinationsCount}, Entries: ${entriesCount}.`);
        } else {
            console.log("[DEBUG LIDI] scheduleSnap does not exist or its value is not an object/is null.");
        }
        currentWorkingSchedule_extra = flatScheduleFromDB.map((e, i) => ({
            ...e,
            internalId: e.internalId || `${(e.stopID || 's')}_${(e.lineName || 'l')}_${(e.scheduledTime || "").replace(':', '')}_${i}_fbloadX_flat`
        }));
        console.log(`Loaded ${currentWorkingSchedule_extra.length} schedule entries into currentWorkingSchedule_extra.`);
        // MODIFICATION END

        // 2. Load and Normalize/Migrate stop definitions
        const definedStopsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_ALL_DEFINED_STOPS));
        if (definedStopsSnap.exists() && typeof definedStopsSnap.val() === 'object' && definedStopsSnap.val() !== null) {
             const rawDataFromFirebase = definedStopsSnap.val();
             for (const keyInFirebase in rawDataFromFirebase) {
                 if (Object.hasOwnProperty.call(rawDataFromFirebase, keyInFirebase)) {
                     const stopObject = rawDataFromFirebase[keyInFirebase];
                     if (stopObject && typeof stopObject.stopID === 'string') {
                         const normalizedStopID = stopObject.stopID.toUpperCase();
                         allDefinedStops_data[normalizedStopID] = { ...stopObject, stopID: normalizedStopID };
                     } else if (stopObject && typeof stopObject.stopName === 'string') {
                         const normalizedKey = keyInFirebase.toUpperCase();
                         allDefinedStops_data[normalizedKey] = { stopID: normalizedKey, stopName: stopObject.stopName, direction: stopObject.direction || "" };
                     }
                 }
             }
         } else { /* ... your potential migration logic ... */ }
        console.log(`Loaded/Migrated ${Object.keys(allDefinedStops_data).length} stop definitions.`);


        // 3. Load Editable Operating Profiles
        const opProfilesSnap = await dbGet(dbRef(database, FB_PATH_EDITABLE_OP_PROFILES));
        if (opProfilesSnap.exists() && Array.isArray(opProfilesSnap.val()) && opProfilesSnap.val().length > 0) {
            RSG_OPERATING_PROFILES_LIST = opProfilesSnap.val();
        } else {
            console.log(`No Op Profiles in Firebase or list empty. Seeding with defaults (${RSG_OPERATING_PROFILES_LIST.length} from global).`);
            if (RSG_OPERATING_PROFILES_LIST && RSG_OPERATING_PROFILES_LIST.length > 0) {
                try { await dbSet(dbRef(database, FB_PATH_EDITABLE_OP_PROFILES), RSG_OPERATING_PROFILES_LIST); }
                catch (e) { console.error("Error seeding default Op Profiles:", e); }
            }
        }
        console.log(`Loaded ${RSG_OPERATING_PROFILES_LIST.length} operating profiles.`);

        // 4. Load School Holiday Dates
        const shSnap = await dbGet(dbRef(database, FB_PATH_SCHOOL_HOLIDAYS));
        let holidaysLoadedFromFirebase = false;
        if (shSnap.exists() && Array.isArray(shSnap.val())) {
            const firebaseHolidays = shSnap.val();
            schoolHolidayDateRanges_extra = firebaseHolidays.map((h, index) => ({
                id: h.id || `sh-loaded-${Date.now()}-${index}`, start: h.start, end: h.end, description: h.description || ""
            }));
            if (schoolHolidayDateRanges_extra.length > 0) holidaysLoadedFromFirebase = true;
        }
        if (!holidaysLoadedFromFirebase) {
            console.log(`No/empty school holidays in Firebase. Using/seeding defaults (count: ${DEFAULT_SCHOOL_HOLIDAY_RANGES ? DEFAULT_SCHOOL_HOLIDAY_RANGES.length : 'N/A'}).`);
            if (DEFAULT_SCHOOL_HOLIDAY_RANGES && Array.isArray(DEFAULT_SCHOOL_HOLIDAY_RANGES)) {
                schoolHolidayDateRanges_extra = DEFAULT_SCHOOL_HOLIDAY_RANGES.map((h, index) => ({ id: h.id || `sh-default-${Date.now()}-${index}`, ...h }));
                if (schoolHolidayDateRanges_extra.length > 0) {
                    try { await dbSet(dbRef(database, FB_PATH_SCHOOL_HOLIDAYS), schoolHolidayDateRanges_extra); }
                    catch (e) { console.error("Error seeding default School Holidays:", e); }
                }
            } else { schoolHolidayDateRanges_extra = []; console.error("DEFAULT_SCHOOL_HOLIDAY_RANGES is not a valid array for fallback.");}
        }
        console.log(`Loaded ${schoolHolidayDateRanges_extra.length} school holiday ranges.`);

        // 5. Load Day Profile Overrides
        const dpoSnap = await dbGet(dbChild(dbRef(database), FB_PATH_OPERATIONAL_OVERRIDES));
        operationalOverrides_data = dpoSnap.exists() ? dpoSnap.val() || {} : {};
        console.log(`Loaded ${Object.keys(operationalOverrides_data).length} day profile overrides.`);

        // 6. Pre-calculate stop to serving routes map
        stopToServingRoutesMap_extra.clear();
        currentWorkingSchedule_extra.forEach(entry => {
            if (entry.stopID && entry.lineName && entry.lineName.trim() !== "") {
                if (!stopToServingRoutesMap_extra.has(entry.stopID)) {
                    stopToServingRoutesMap_extra.set(entry.stopID, new Set());
                }
                stopToServingRoutesMap_extra.get(entry.stopID).add(entry.lineName);
            }
        });

        // 7. Load other settings/data
        const closedSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_CLOSED_STOPS));
        closedStopIDs_extra = (closedSnap.exists() && closedSnap.val()) ? Object.keys(closedSnap.val()).filter(id => closedSnap.val()[id] === true).map(id => id.toUpperCase()) : [];

        const globalCSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS));
        globalCustomRouteColours_extra = globalCSnap.exists() ? globalCSnap.val() || {} : {};

        const stopSpecificCSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS));
        stopSpecificRouteColours_extra = stopSpecificCSnap.exists() ? stopSpecificCSnap.val() || {} : {};

        const rsgConfigsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_RSG_CONFIGS));
        rsg_loadedConfigs_extra = rsgConfigsSnap.exists() ? rsgConfigsSnap.val() || {} : {};
        
        const scheduledDeletionsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULED_DELETIONS));
        scheduledRouteDeletions_extra = scheduledDeletionsSnap.exists() ? scheduledDeletionsSnap.val() || {} : {};

        const scheduledUpdatesSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULED_ROUTE_UPDATES));
        scheduledRouteUpdates_extra = scheduledUpdatesSnap.exists() ? scheduledUpdatesSnap.val() || {} : {};

        msg = `Extra Modules: Data loading complete.`;
    } catch (error) {
        console.error("Firebase Load Error (Extra Tools):", error);
        msg = "Error loading data (Extra Tools): " + error.message;
        // Reset all data structures
        currentWorkingSchedule_extra = []; closedStopIDs_extra = []; globalCustomRouteColours_extra = {};
        stopSpecificRouteColours_extra = {}; rsg_loadedConfigs_extra = {}; allDefinedStops_data = {};
        operationalOverrides_data = {}; scheduledRouteDeletions_extra = {}; scheduledRouteUpdates_extra = {};
        // Fallback to defaults
        if (DEFAULT_SCHOOL_HOLIDAY_RANGES && Array.isArray(DEFAULT_SCHOOL_HOLIDAY_RANGES)) {
            schoolHolidayDateRanges_extra = DEFAULT_SCHOOL_HOLIDAY_RANGES.map((h, index) => ({id: h.id || `sh-loaderr-${Date.now()}-${index}`, ...h}));
        } else { schoolHolidayDateRanges_extra = []; }
        // RSG_OPERATING_PROFILES_LIST retains its initial 'let' definition
        stopToServingRoutesMap_extra.clear();
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = msg;
    }
    
    console.log("loadInitialData_ExtraPage: " + msg);
    console.log("loadInitialData_ExtraPage: Final schoolHolidayDateRanges_extra:", JSON.stringify(schoolHolidayDateRanges_extra));
    console.log("loadInitialData_ExtraPage: Final RSG_OPERATING_PROFILES_LIST:", JSON.stringify(RSG_OPERATING_PROFILES_LIST));

    if (typeof fetchBankHolidays_ExtraPage === 'function') await fetchBankHolidays_ExtraPage();
console.log("Content of ukBankHolidaysData_extra AFTER fetch:", JSON.stringify(ukBankHolidaysData_extra, null, 2));
    if (typeof updateCurrentProfileDisplay_ExtraPage === 'function') await updateCurrentProfileDisplay_ExtraPage();
    
    renderUIDependentElements_ExtraPage();

    if (typeof checkAndDisplayDueUpdatesNotification_ExtraPage === 'function') {
        checkAndDisplayDueUpdatesNotification_ExtraPage();
    }

    // Start the trip alert monitor if a user is logged in
    if (currentUser_extra) { // Check if user is available (set by updateAuthUI_ExtraPage)
        if (typeof prepareKeyTripTimesForAlerts_ExtraPage === 'function' &&
            typeof checkAndShowTripAlerts_ExtraPage === 'function') {
            prepareKeyTripTimesForAlerts_ExtraPage().then(() => {
                if (tripAlertIntervalId_extra) clearInterval(tripAlertIntervalId_extra);
                tripAlertIntervalId_extra = setInterval(checkAndShowTripAlerts_ExtraPage, ALERT_CHECK_INTERVAL_MS);
                console.log("Trip alert monitor started after data load.");
            }).catch(err => {
                console.error("Error during initial preparation for trip alerts:", err);
            });
        }
    } else {
        if (tripAlertIntervalId_extra) { // Ensure it's stopped if no user somehow
            clearInterval(tripAlertIntervalId_extra);
            tripAlertIntervalId_extra = null;
        }
    }
    console.log("loadInitialData_ExtraPage: Finished.");
}

function renderUIDependentElements_ExtraPage() {
    const lastSectionFromStorage = localStorage.getItem('omsiExtraToolsActiveSection');
    let sectionIdToShow = null;
    let calledShowSection = false; // Flag to ensure showExtraPageSection is called at most once initially by this function

    console.log(`[RenderUI] Attempting to determine initial section. Last from storage: ${lastSectionFromStorage}`);

    // Priority 1: Try to show the section from localStorage if it's valid
    if (lastSectionFromStorage && document.getElementById(lastSectionFromStorage)) {
        // Further check: Is it a real tool section linked to a menu button?
        const isKnownToolSection = topMenuBar_el_extra && Array.from(topMenuBar_el_extra.querySelectorAll('.menu-button')).some(b => b.dataset.section === lastSectionFromStorage);
        if (isKnownToolSection) {
            sectionIdToShow = lastSectionFromStorage;
            console.log(`[RenderUI] Valid section found in localStorage: ${sectionIdToShow}`);
        } else {
            // The stored section ID might be old or invalid (e.g., tool removed)
            console.log(`[RenderUI] Section from localStorage ('${lastSectionFromStorage}') is not a known tool section. Clearing from storage.`);
            localStorage.removeItem('omsiExtraToolsActiveSection');
            sectionIdToShow = null; // Ensure it's null so we try the default next
        }
    }

    // Priority 2: If no valid section from localStorage, and user is logged in, try the first menu button
    if (!sectionIdToShow && currentUser_extra && topMenuBar_el_extra) {
        const firstButton = topMenuBar_el_extra.querySelector('.menu-button');
        if (firstButton && firstButton.dataset.section) {
            sectionIdToShow = firstButton.dataset.section;
            console.log(`[RenderUI] No valid localStorage section. Defaulting to first menu button section: ${sectionIdToShow}`);
        }
    }

    // Now, actually show the determined section (if any)
    if (sectionIdToShow && typeof showExtraPageSection === 'function') {
        showExtraPageSection(sectionIdToShow);
        calledShowSection = true;
    } else if (currentUser_extra && !calledShowSection) {
        // User is logged in, but no section could be determined (e.g., localStorage empty/invalid, and no menu buttons)
        // This state would result in the "blue screen" if not handled.
        console.warn("[RenderUI] User is logged in, but no default section could be determined to display. All tool sections will remain hidden.");
        // Ensure all tool sections are indeed hidden if no specific one is chosen.
        // `showExtraPageSection` normally handles hiding others, but if it's not called,
        // we might want an explicit hide here, though `updateAuthUI_ExtraPage(null)` initial call usually does this.
        if (toolSectionsWrapper_el_extra) {
            toolSectionsWrapper_el_extra.querySelectorAll(".tool-content-section.section").forEach((s) => {
                s.style.display = "none";
            });
        }
    }
    // If not logged in (currentUser_extra is null), updateAuthUI_ExtraPage(null) would have hidden all sections
    // and the top menu bar, so no specific section showing logic is needed here for that case.
}

        document.addEventListener('DOMContentLoaded', () => {
    console.log("OMSI Tools Extra DOMContentLoaded");
    if (typeof updateAuthUI_ExtraPage === 'function') {
        updateAuthUI_ExtraPage(null); // Initialize UI for logged-out state
    }

    // --- General UI Listeners ---
    const iphoneTestBtn = document.getElementById('iphoneTestNotificationBtn');
    if (iphoneTestBtn) {
        iphoneTestBtn.addEventListener('click', () => {
            if (!("Notification" in window)) {
                alert("Notifications not supported on this browser/PWA.");
                return;
            }
            if (Notification.permission === "granted") {
                try {
                    new Notification("iPhone Test Notification!", {
                        body: "Success! This is a desktop/OS notification from your Home Screen app.",
                        icon: '/live-tracker/assets/icons/icon-192x192.png'
                    });
                } catch (e) {
                    alert("Error creating notification: " + e.toString());
                }
            } else {
                alert("Permission not granted. Please tap 'Enable Desktop Alerts' first.");
            }
        });
    }

    const enableDesktopBtn = document.getElementById('enableDesktopNotificationsBtn_extra');
    if (enableDesktopBtn) {
        enableDesktopBtn.addEventListener('click', async () => {
            // This uses the newer requestNotificationPermission function which handles localStorage
            if (typeof requestNotificationPermission === 'function') {
                await requestNotificationPermission();
            } else if (!("Notification" in window)) { // Fallback if new function isn't there
                alert("This browser does not support desktop notifications.");
            } else { // Original simpler logic if new function is missing
                const permission = await Notification.requestPermission();
                if (permission === "granted") {
                    alert("Desktop notifications enabled!");
                    localStorage.setItem('desktopNotificationPreference_omsiExtra', 'granted');
                } else if (permission === "denied") {
                    alert("Desktop notifications denied. You can change this in your browser's site settings if you change your mind.");
                    localStorage.setItem('desktopNotificationPreference_omsiExtra', 'denied');
                } else {
                    alert("Notification permission request dismissed or not acted upon.");
                }
            }
        });
    }

    const kdRefreshBtn = document.getElementById('kd-refresh-btn_extra');
    if (kdRefreshBtn && typeof displayKeyDepartures_ExtraPage === 'function') {
        kdRefreshBtn.addEventListener('click', displayKeyDepartures_ExtraPage);
    }

    const cvPrevMonthBtn = document.getElementById('cv-prev-month-btn_extra');
    const cvNextMonthBtn = document.getElementById('cv-next-month-btn_extra');

    if (cvPrevMonthBtn && typeof renderCalendarView_ExtraPage === 'function') {
        cvPrevMonthBtn.addEventListener('click', () => {
            cv_currentDisplayDate_extra.setMonth(cv_currentDisplayDate_extra.getMonth() - 1);
            renderCalendarView_ExtraPage();
        });
    }
    if (cvNextMonthBtn && typeof renderCalendarView_ExtraPage === 'function') {
        cvNextMonthBtn.addEventListener('click', () => {
            cv_currentDisplayDate_extra.setMonth(cv_currentDisplayDate_extra.getMonth() + 1);
            renderCalendarView_ExtraPage();
        });
    }

    // --- Firebase Auth Initialization ---
    function initializeExtraAppLogic() {
        console.log("Firebase ready, Extra app logic init.");
        if (!window.firebaseOMSI || !window.firebaseOMSI.auth) {
            console.error("Extra Tools: Firebase OMSI object not found during initializeExtraAppLogic.");
            if (typeof updateAuthUI_ExtraPage === 'function') updateAuthUI_ExtraPage(null);
            if (authStatus_el_extra) authStatus_el_extra.textContent = 'Critical Firebase init error for app logic.';
            return;
        }
        const {
            auth,
            authOnAuthStateChanged,
            authSignInWithEmailAndPassword,
            authSignOut
        } = window.firebaseOMSI;

        authOnAuthStateChanged(auth, async user => { // Made async for await updateAuthUI_ExtraPage
            if (typeof updateAuthUI_ExtraPage === 'function') {
                await updateAuthUI_ExtraPage(user); // Await to ensure data loads before other UI updates
            }
            // This auto-suggest logic should ideally run *after* data loading within updateAuthUI_ExtraPage is complete.
            // updateAuthUI_ExtraPage calls loadInitialData, which then calls renderUIDependentElements.
            // For now, this placement is okay but keep an eye on timing if issues arise.
            if (user && selectNewStopIdFormat_el_extra && inputNewStopName_el_extra && inputNewStopId_el_extra &&
                !inputNewStopName_el_extra.value && !inputNewStopId_el_extra.value &&
                typeof autoGenerateAndSetNewStopId_ExtraPage === 'function') {
                autoGenerateAndSetNewStopId_ExtraPage();
            }
        });

        if (adminLoginForm_el_extra && inputEmail_el_extra && inputPassword_el_extra && authStatus_el_extra) {
            adminLoginForm_el_extra.addEventListener('submit', (e) => {
                e.preventDefault();
                authStatus_el_extra.textContent = 'Logging in...';
                authStatus_el_extra.style.color = '#f1c40f'; // Yellow for processing
                authSignInWithEmailAndPassword(auth, inputEmail_el_extra.value, inputPassword_el_extra.value)
                    .catch(err => {
                        authStatus_el_extra.textContent = `Login Error: ${err.message}`;
                        authStatus_el_extra.style.color = '#e74c3c'; // Red for error
                    });
            });
        }

        const logoutButtonElement = document.getElementById('logoutButton_extra');
        if (logoutButtonElement) {
            logoutButtonElement.addEventListener('click', () => {
                console.log("Logout button clicked. Cleaning up...");
                localStorage.removeItem('omsiExtraToolsActiveSection');

                if (tripAlertIntervalId_extra) { clearInterval(tripAlertIntervalId_extra); tripAlertIntervalId_extra = null; console.log("Trip alert monitor stopped."); }
                if (keyDeparturesIntervalId_extra) { clearInterval(keyDeparturesIntervalId_extra); keyDeparturesIntervalId_extra = null; console.log("Key departures monitor stopped.");}
                
                todayKeyTripEvents_extra = [];
                shownTripAlerts_extra = {};
                lastAlertDataPreparedDate_extra = null;
                
                const globalBanner = document.getElementById('global-notification-banner');
                if (globalBanner) globalBanner.style.display = 'none';

                authSignOut(auth).catch(e => console.error("Sign-out error (Extra):", e));
                // updateAuthUI_ExtraPage(null) will be called by onAuthStateChanged, which handles UI reset and data clearing.
            });
        }
    }

    if (window.firebaseOMSI && window.firebaseOMSI.auth) {
        initializeExtraAppLogic();
    } else {
        document.addEventListener('firebaseReady', () => {
            if (window.firebaseOMSI && window.firebaseOMSI.auth) {
                initializeExtraAppLogic();
            } else {
                console.error("Extra Tools: Firebase still not ready after firebaseReady event!");
                if (typeof updateAuthUI_ExtraPage === 'function') updateAuthUI_ExtraPage(null);
                if (authStatus_el_extra) authStatus_el_extra.textContent = 'Fatal: Firebase did not initialize.';
            }
        }, {
            once: true
        });
    }

    // --- Main Menu Button Listeners ---
    const menuButtons = topMenuBar_el_extra ? topMenuBar_el_extra.querySelectorAll('.menu-button') : [];
    menuButtons.forEach(button => button.addEventListener('click', () => {
        if (currentUser_extra && typeof showExtraPageSection === 'function') {
            showExtraPageSection(button.dataset.section);
        } else if (!currentUser_extra) {
            alert("Please log in to access this section.");
        }
    }));

    // --- Day Profile Override (DPO) Section Listeners ---
    if (overrideDateInput_el_extra && typeof updateSelectedDateInfo_ExtraPage === 'function') {
        overrideDateInput_el_extra.addEventListener('change', updateSelectedDateInfo_ExtraPage);
    }
    if (dpoApplyOverrideToRoutesButton_el_extra && typeof dpo_applyOverrideToRoutes_ExtraPage === 'function') {
        dpoApplyOverrideToRoutesButton_el_extra.addEventListener('click', dpo_applyOverrideToRoutes_ExtraPage);
    }
    if (dpoClearOverrideForRoutesButton_el_extra && typeof dpo_clearOverrideForRoutes_ExtraPage === 'function') {
        dpoClearOverrideForRoutesButton_el_extra.addEventListener('click', dpo_clearOverrideForRoutes_ExtraPage);
    }
    if (dpoClearRouteSelectionButton_el_extra && typeof dpo_clearRouteSelections_ExtraPage === 'function') {
        dpoClearRouteSelectionButton_el_extra.addEventListener('click', dpo_clearRouteSelections_ExtraPage);
    }
    if (dpoSelectAllRoutesButton_el_extra && typeof dpo_selectAllRoutes_ExtraPage === 'function') {
        dpoSelectAllRoutesButton_el_extra.addEventListener('click', dpo_selectAllRoutes_ExtraPage);
    }
    const dpoClearProfileCBsBtn = document.getElementById('dpo-clear-profile-checkboxes-button-extra');
    if (dpoClearProfileCBsBtn && typeof dpo_clearProfileSelections_ExtraPage === 'function') {
        dpoClearProfileCBsBtn.addEventListener('click', dpo_clearProfileSelections_ExtraPage);
    }


    // --- Stop Manager & Creation Section Listeners ---
    if (selectNewStopIdFormat_el_extra && typeof autoGenerateAndSetNewStopId_ExtraPage === 'function') {
         selectNewStopIdFormat_el_extra.addEventListener('change', autoGenerateAndSetNewStopId_ExtraPage);
    }
    if (inputNewStopName_el_extra && typeof autoGenerateAndSetNewStopId_ExtraPage === 'function') {
        inputNewStopName_el_extra.addEventListener('input', autoGenerateAndSetNewStopId_ExtraPage);
    }
    if (inputNewStopId_el_extra && newStopIdAvailability_el_extra) {
        inputNewStopId_el_extra.addEventListener('input', () => {
            const newStopId = inputNewStopId_el_extra.value.trim().toUpperCase();
            if (!newStopId) {
                newStopIdAvailability_el_extra.textContent = '';
                return;
            }
            if (!/^[A-Z0-9]+$/.test(newStopId)) { // Ensure only A-Z, 0-9
                newStopIdAvailability_el_extra.textContent = 'ID invalid chars (A-Z, 0-9 only).';
                newStopIdAvailability_el_extra.style.color = '#e74c3c';
                return;
            }
            // Check against allDefinedStops_data keys (which should be uppercase)
            const definedStopIDsUppercase = allDefinedStops_data ? Object.keys(allDefinedStops_data) : [];
            if (definedStopIDsUppercase.includes(newStopId)) {
                newStopIdAvailability_el_extra.textContent = 'ID already exists in definitions!';
                newStopIdAvailability_el_extra.style.color = '#e74c3c';
            } else {
                newStopIdAvailability_el_extra.textContent = 'ID available.';
                newStopIdAvailability_el_extra.style.color = '#2ecc71';
            }
        });
    }
    if (buttonAddNewStop_el_extra && typeof handleAddStopDetails_ExtraPage === 'function') {
        buttonAddNewStop_el_extra.addEventListener('click', handleAddStopDetails_ExtraPage);
    }
    if (fileInputBulkAddStops_el_extra && typeof handleExcelFileForBulkAdd_ExtraPage === 'function') {
        fileInputBulkAddStops_el_extra.addEventListener('change', handleExcelFileForBulkAdd_ExtraPage);
    }
    if (buttonBulkAddNewStops_el_extra && typeof handleBulkAddStops_ExtraPage === 'function') {
        buttonBulkAddNewStops_el_extra.addEventListener('click', handleBulkAddStops_ExtraPage);
    }
    if (masterStopListFilterInput_el_extra && typeof populateMasterStopList_ExtraPage === 'function') {
        masterStopListFilterInput_el_extra.addEventListener('input', populateMasterStopList_ExtraPage);
    }
    if (refreshMasterStopListButton_el_extra && typeof loadInitialData_ExtraPage === 'function' && typeof populateMasterStopList_ExtraPage === 'function') {
        refreshMasterStopListButton_el_extra.addEventListener('click', async () => { // made async
            if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "Refreshing stop data...";
            await loadInitialData_ExtraPage(); // Data loading can be awaited
            populateMasterStopList_ExtraPage(); // Then populate
            if (masterStopListStatus_el_extra && masterStopListStatus_el_extra.textContent.includes("Refreshing")) {
                masterStopListStatus_el_extra.textContent = "Stop list refreshed.";
            }
        });
    }
    if (applyMasterListStopIdChangesButton_el_extra && typeof handleApplyMasterListStopIdChangesButton_ExtraPage === 'function') {
        applyMasterListStopIdChangesButton_el_extra.addEventListener('click', handleApplyMasterListStopIdChangesButton_ExtraPage);
    }
    if (exportUniqueStopsButton_el_extra) { /* Export logic is complex, assumed correct from previous state */ }
    if (findDuplicateStopsByNameDirButton_el_extra && typeof findDuplicateStopsByNameAndDirection_ExtraPage === 'function') {
        findDuplicateStopsByNameDirButton_el_extra.addEventListener('click', findDuplicateStopsByNameAndDirection_ExtraPage);
    }

    // --- Global Route Deletion Section Listeners ---
    if (deleteEntireRouteButton_el_extra && typeof handleDeleteEntireRouteGlobally_ExtraPage === 'function') {
        deleteEntireRouteButton_el_extra.addEventListener('click', handleDeleteEntireRouteGlobally_ExtraPage);
    }

    // --- Route Profile Deletion (RPD) Section Listeners ---
    if (rpdRouteSelect_el_extra && typeof rpd_handleRouteNameSelectChange_ExtraPage === 'function') {
        rpdRouteSelect_el_extra.addEventListener('change', rpd_handleRouteNameSelectChange_ExtraPage);
    }
    if (rpdRouteInput_el_extra && typeof rpd_handleRouteNameInputChange_ExtraPage === 'function') {
        // Using 'input' for more responsive update than 'blur'
        rpdRouteInput_el_extra.addEventListener('input', rpd_handleRouteNameInputChange_ExtraPage);
    }
    if (rpdDestinationSelect_el_extra && typeof rpd_handleDestinationNameSelectChange_ExtraPage === 'function') {
        rpdDestinationSelect_el_extra.addEventListener('change', rpd_handleDestinationNameSelectChange_ExtraPage);
    }
    if (rpdDestinationInput_el_extra && typeof rpd_handleDestinationNameInputChange_ExtraPage === 'function') {
        // Using 'input' for more responsive update
        rpdDestinationInput_el_extra.addEventListener('input', rpd_handleDestinationNameInputChange_ExtraPage);
    }
    if (rpdClearDestinationButton_el_extra && typeof rpd_handleClearDestination_ExtraPage === 'function') {
        rpdClearDestinationButton_el_extra.addEventListener('click', rpd_handleClearDestination_ExtraPage);
    }
    if (rpdDeleteProfilesButton_el_extra && typeof handleDeleteRouteProfiles_ExtraPage === 'function') {
        rpdDeleteProfilesButton_el_extra.addEventListener('click', handleDeleteRouteProfiles_ExtraPage);
    }

    // --- Route Schedule Generator (RSG) Section Listeners ---
    if (rsgClearRouteSelectionButton_el_extra && typeof rsg_clearRouteSelection_ExtraPage === 'function') {
        rsgClearRouteSelectionButton_el_extra.addEventListener('click', rsg_clearRouteSelection_ExtraPage);
    }
    const rsgClearProfileCBsBtn = document.getElementById('rsg-clear-profile-checkboxes-button-extra');
    if (rsgClearProfileCBsBtn && typeof rsg_clearProfileSelections_ExtraPage === 'function') {
        rsgClearProfileCBsBtn.addEventListener('click', rsg_clearProfileSelections_ExtraPage);
    }
    if (rsgDestinationNameSelect_el_extra && typeof rsg_handleDestinationNameSelectChange_ExtraPage === 'function') {
        rsgDestinationNameSelect_el_extra.addEventListener('change', rsg_handleDestinationNameSelectChange_ExtraPage);
    }
    if (rsgDestinationNameInput_el_extra && typeof rsg_handleDestinationNameInputChange_ExtraPage === 'function') {
        rsgDestinationNameInput_el_extra.addEventListener('blur', rsg_handleDestinationNameInputChange_ExtraPage); // Or 'input' if preferred
    }
    if (rsgStopSearchInput_el_extra && typeof rsg_handleStopSearch_ExtraPage === 'function') {
        rsgStopSearchInput_el_extra.addEventListener('input', rsg_handleStopSearch_ExtraPage);
    }
    if (rsgGenerateScheduleButton_el_extra && typeof rsg_handleGenerateSchedulePreview_ExtraPage === 'function') {
        rsgGenerateScheduleButton_el_extra.addEventListener('click', () => rsg_handleGenerateSchedulePreview_ExtraPage(false));
    }
    if (rsgSaveConfigurationButton_el_extra && typeof rsg_handleSaveConfiguration_ExtraPage === 'function') {
        rsgSaveConfigurationButton_el_extra.addEventListener('click', rsg_handleSaveConfiguration_ExtraPage);
    }
    if (rsgAddToWorkingScheduleButton_el_extra && typeof rsg_handleAddGeneratedToWorkingSchedule_ExtraPage === 'function') {
        rsgAddToWorkingScheduleButton_el_extra.addEventListener('click', rsg_handleAddGeneratedToWorkingSchedule_ExtraPage);
    }
    if (rsgScheduleThisConfigButton_el_extra && typeof handleScheduleThisConfiguration === 'function') {
        rsgScheduleThisConfigButton_el_extra.addEventListener('click', handleScheduleThisConfiguration);
    }
    if (rsgScheduleDateTimeConfirmBtn && typeof rsg_confirmScheduleGoLive_ExtraPage === 'function') {
        rsgScheduleDateTimeConfirmBtn.addEventListener('click', rsg_confirmScheduleGoLive_ExtraPage);
    }
    if (rsgScheduleDateTimeCancelBtn && typeof rsg_closeScheduleDateTimeModal_ExtraPage === 'function') {
        rsgScheduleDateTimeCancelBtn.addEventListener('click', rsg_closeScheduleDateTimeModal_ExtraPage);
    }
    if (rsgScheduleDateTimeModal && typeof rsg_closeScheduleDateTimeModal_ExtraPage === 'function') {
        rsgScheduleDateTimeModal.addEventListener('click', (event) => {
            if (event.target === rsgScheduleDateTimeModal) rsg_closeScheduleDateTimeModal_ExtraPage();
        });
    }
    if (rsgFirstStopTimesInput_el_extra && typeof rsg_updateRsgActionButtonsState === 'function') {
        rsgFirstStopTimesInput_el_extra.addEventListener('input', () => {
            rsg_isDirty = true; console.log("RSG User Edit: First stop times changed. rsg_isDirty is true.");
            rsg_updateRsgActionButtonsState();
        });
        rsgFirstStopTimesInput_el_extra.addEventListener('keydown', function(event) {
            if (event.key === 'Tab') {
                event.preventDefault(); let start = this.selectionStart; let end = this.selectionEnd;
                this.value = this.value.substring(0, start) + '\t' + this.value.substring(end);
                this.selectionStart = this.selectionEnd = start + 1;
                this.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
            }
        });
    }
    const rsgPullFirstStopTimesButton_local = document.getElementById('rsg-pull-first-stop-times-button-extra');
    if (rsgPullFirstStopTimesButton_local && typeof rsg_pullCurrentFirstStopTimes_ExtraPage === 'function') {
        rsgPullFirstStopTimesButton_local.addEventListener('click', rsg_pullCurrentFirstStopTimes_ExtraPage);
    }
    const rsgScheduleSelectedBtn_local = document.getElementById('rsg-schedule-selected-configs-button-extra');
    if (rsgScheduleSelectedBtn_local && typeof rsg_handleScheduleSelectedConfigs_ExtraPage === 'function') {
        rsgScheduleSelectedBtn_local.addEventListener('click', rsg_handleScheduleSelectedConfigs_ExtraPage);
    }
    const rsgSelectAllGlobalCheckbox_local = document.getElementById('rsg-select-all-configs-checkbox-extra');
    if (rsgSelectAllGlobalCheckbox_local && typeof rsg_handleSelectAllConfigsChange_ExtraPage === 'function') {
        rsgSelectAllGlobalCheckbox_local.addEventListener('change', rsg_handleSelectAllConfigsChange_ExtraPage);
    }
    if (rsgOpenCopyModalButton_el_extra && typeof rsg_openCopyFromModal_ExtraPage === 'function') {
        rsgOpenCopyModalButton_el_extra.addEventListener('click', rsg_openCopyFromModal_ExtraPage);
    }
    if (rsgCopyModalCancelButton_el_extra && typeof rsg_closeCopyFromModal_ExtraPage === 'function') {
        rsgCopyModalCancelButton_el_extra.addEventListener('click', rsg_closeCopyFromModal_ExtraPage);
    }
    if (rsgCopyModalActionButton_el_extra && typeof rsg_handleCopyDataFromSource_ExtraPage === 'function') {
        rsgCopyModalActionButton_el_extra.addEventListener('click', rsg_handleCopyDataFromSource_ExtraPage);
    }
    if (rsgCopyModal_el_extra && typeof rsg_closeCopyFromModal_ExtraPage === 'function') {
        rsgCopyModal_el_extra.addEventListener('click', (event) => {
            if (event.target === rsgCopyModal_el_extra) rsg_closeCopyFromModal_ExtraPage();
        });
    }
    if (rsgCopySourceRouteNameSelect_el_extra && typeof rsg_populateCopySourceDestinationSelect_ExtraPage === 'function') {
        rsgCopySourceRouteNameSelect_el_extra.addEventListener('change', rsg_populateCopySourceDestinationSelect_ExtraPage);
    }
    if (rsgCopySourceDestNameSelect_el_extra && typeof rsg_populateCopySourceOpProfileSelect_ExtraPage === 'function') {
        rsgCopySourceDestNameSelect_el_extra.addEventListener('change', rsg_populateCopySourceOpProfileSelect_ExtraPage);
    }

    const rsgSaveConfirmBtn_local = document.getElementById('rsg-save-config-confirm-button-extra');
    if (rsgSaveConfirmBtn_local && typeof rsg_performSaveConfiguration_ExtraPage === 'function') {
        rsgSaveConfirmBtn_local.addEventListener('click', rsg_performSaveConfiguration_ExtraPage);
    }
    const rsgSaveCancelBtn_local = document.getElementById('rsg-save-config-cancel-button-extra');
    if (rsgSaveCancelBtn_local && typeof rsg_hideSaveConfigModal_ExtraPage === 'function') {
        rsgSaveCancelBtn_local.addEventListener('click', rsg_hideSaveConfigModal_ExtraPage);
    }
    const rsgSaveModal_local = document.getElementById('rsg-save-config-modal-extra');
    if (rsgSaveModal_local && typeof rsg_hideSaveConfigModal_ExtraPage === 'function') {
        rsgSaveModal_local.addEventListener('click', (event) => {
            if (event.target === rsgSaveModal_local) rsg_hideSaveConfigModal_ExtraPage();
        });
    }
    // Listeners for RSG Rename Config Modal (if it exists and has these IDs)
    // const rsgRenameConfirmBtn_local = document.getElementById('rsg-rename-config-confirm-button-extra');
    // if (rsgRenameConfirmBtn_local && typeof rsg_performRenameConfiguration_ExtraPage === 'function') {
    //    rsgRenameConfirmBtn_local.addEventListener('click', () => rsg_performRenameConfiguration_ExtraPage(rsg_configKeyToRename_extra));
    // }
    // const rsgRenameCancelBtn_local = document.getElementById('rsg-rename-config-cancel-button-extra');
    // if (rsgRenameCancelBtn_local && typeof rsg_hideRenameConfigModal_ExtraPage === 'function') {
    //    rsgRenameCancelBtn_local.addEventListener('click', rsg_hideRenameConfigModal_ExtraPage);
    // }
    // const rsgRenameModal_local = document.getElementById('rsg-rename-config-modal-extra');
    // if (rsgRenameModal_local && typeof rsg_hideRenameConfigModal_ExtraPage === 'function') {
    //     rsgRenameModal_local.addEventListener('click', (event) => { if (event.target === rsgRenameModal_local) rsg_hideRenameConfigModal_ExtraPage(); });
    // }

    if (rsgReplaceStopSearchInput_el_extra && typeof rsg_handleReplaceStopSearch_ExtraPage === 'function') {
        rsgReplaceStopSearchInput_el_extra.addEventListener('input', rsg_handleReplaceStopSearch_ExtraPage);
    }
    if (rsgReplaceStopModalCancelButton_el_extra && typeof rsg_closeReplaceStopModal_ExtraPage === 'function') {
        rsgReplaceStopModalCancelButton_el_extra.addEventListener('click', rsg_closeReplaceStopModal_ExtraPage);
    }
    if (rsgReplaceStopModal_el_extra && typeof rsg_closeReplaceStopModal_ExtraPage === 'function') {
        rsgReplaceStopModal_el_extra.addEventListener('click', (event) => {
            if (event.target === rsgReplaceStopModal_el_extra) rsg_closeReplaceStopModal_ExtraPage();
        });
    }

    // --- Scheduled Route Deletion (SRD) Section Listeners ---
    if (srdRouteNameSelect_el_extra && srdRouteNameInput_el_extra) {
        srdRouteNameSelect_el_extra.addEventListener('change', () => {
            if (srdRouteNameInput_el_extra) srdRouteNameInput_el_extra.value = srdRouteNameSelect_el_extra.value;
            if (srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = '';
        });
        srdRouteNameInput_el_extra.addEventListener('input', () => {
            const typedValue = srdRouteNameInput_el_extra.value.trim().toUpperCase();
            let matchedSelectValue = "";
            if (srdRouteNameSelect_el_extra) {
                const matchedOption = Array.from(srdRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedValue);
                if (matchedOption) matchedSelectValue = matchedOption.value;
                if (srdRouteNameSelect_el_extra.value !== matchedSelectValue) srdRouteNameSelect_el_extra.value = matchedSelectValue;
            }
            if (srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = '';
        });
    }
    if (srdScheduleDeletionButton_el_extra && typeof srd_confirmAndScheduleDeletion_ExtraPage === 'function') {
        srdScheduleDeletionButton_el_extra.addEventListener('click', srd_confirmAndScheduleDeletion_ExtraPage);
    }

    // --- Scheduled Route Updates (SRU) Section Listeners ---
    const sruRefreshButton_local = document.getElementById('sru-refresh-list-button-extra');
    if (sruRefreshButton_local && typeof loadAndDisplayScheduledUpdates_ExtraPage === 'function') {
        sruRefreshButton_local.addEventListener('click', () => {
            isScheduledTasksCacheValid_extra = false; // Invalidate cache on manual refresh
            loadAndDisplayScheduledUpdates_ExtraPage();
        });
    }
    if (sruApplyAllForTimeButton_el_extra && typeof handleApplyAllBatchesForSelectedTime_ExtraPage === 'function') {
        sruApplyAllForTimeButton_el_extra.addEventListener('click', handleApplyAllBatchesForSelectedTime_ExtraPage);
    }
    // Delegated listener for SRU list items (includes the fix for sru-cancel-all-for-route-btn)
    const sruListContainer_local = document.getElementById('sru-updates-list-container-extra');
    if (sruListContainer_local) {
        if (!sruListContainer_local.dataset.listenerAttachedSruMain) {
            sruListContainer_local.addEventListener('click', function(event) {
                const targetCancelAllForRouteButton = event.target.closest('button.sru-cancel-all-for-route-btn');
                if (targetCancelAllForRouteButton) {
                    const routeName = targetCancelAllForRouteButton.dataset.routeName;
                    if (routeName && typeof handleCancelAllUpdatesForRoute_Master === 'function') {
                        handleCancelAllUpdatesForRoute_Master(routeName);
                    } else {
                        console.error("SRU: 'Cancel All For Route' button missing routeName or handler.", targetCancelAllForRouteButton.dataset);
                        alert("Error processing per-route cancellation.");
                    }
                    return;
                }
                const targetCancelButton = event.target.closest('button.sru-cancel-task-btn');
                if (targetCancelButton) {
                    const taskKey = targetCancelButton.dataset.key;
                    const taskType = targetCancelButton.dataset.taskType;
                    if (taskKey && taskType && typeof handleCancelScheduledTask_ExtraPage === 'function') {
                        handleCancelScheduledTask_ExtraPage(taskKey, taskType);
                    } else {
                        console.error("SRU: Individual cancel button missing data or handler.", targetCancelButton.dataset);
                        alert("Error processing individual task cancellation.");
                    }
                    return;
                }
                const targetExecuteDeletionButton = event.target.closest('button.sru-execute-deletion-btn');
                if (targetExecuteDeletionButton) {
                    const taskKey = targetExecuteDeletionButton.dataset.key;
                    if (taskKey && typeof handleExecuteScheduledDeletion_ExtraPage === 'function') {
                        handleExecuteScheduledDeletion_ExtraPage(taskKey);
                    } else {
                        console.error("SRU: Execute deletion button missing data or handler.", targetExecuteDeletionButton.dataset);
                        alert("Error processing route deletion execution.");
                    }
                    return;
                }
                // Placeholder for Apply This Batch Now (sru-apply-batch-btn)
                const targetApplyBatchButton = event.target.closest('button.sru-apply-batch-btn');
                if (targetApplyBatchButton) {
                    // This requires finding the tasks associated with this specific batch to pass to handleApplyScheduledRouteBatch_ExtraPage
                    // For example, you might need to traverse up to its parent '.sru-batch-container'
                    // then use a data attribute on that container (e.g., data-batch-key or similar that was set during rendering)
                    // to retrieve the correct array of tasks from scheduledRouteUpdates_extra.
                    // const batchContainer = targetApplyBatchButton.closest('.sru-batch-container');
                    // const batchIdentifier = batchContainer ? batchContainer.dataset.scheduleKey : null; // If you set such a key
                    // if (batchIdentifier && typeof handleApplyScheduledRouteBatch_ExtraPage === 'function') {
                    //      const tasksForThisBatch = ... logic to find tasks using batchIdentifier ...
                    //      if (tasksForThisBatch && tasksForThisBatch.length > 0) {
                    //          handleApplyScheduledRouteBatch_ExtraPage(tasksForThisBatch);
                    //      } else { alert('Could not find tasks for this specific batch.'); }
                    // } else {
                    //      alert('Cannot apply this specific batch - identifier or handler missing.');
                    // }
                    console.log("SRU: 'Apply This Batch Now' button clicked. Specific batch application logic needs to be fully implemented here if desired.");
                    if (rsgStatusMessage_el_extra) {
                        rsgStatusMessage_el_extra.textContent = "'Apply this batch' not yet fully wired up here. Use 'Apply All for Selected Go-Live Time' for now.";
                        rsgStatusMessage_el_extra.style.color = "#f1c40f";
                    }
                    return;
                }
            });
            sruListContainer_local.dataset.listenerAttachedSruMain = 'true';
        }
    }
    if (sruCancelModalConfirmButton_el_extra && sruCancelModalCancelButton_el_extra && sruCancelModalSelectAllCheckbox_el_extra && sruCancelModalCheckboxesContainer_el_extra) {
        if (typeof sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage === 'function') {
            sruCancelModalConfirmButton_el_extra.addEventListener('click', sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage);
        }
        if (typeof sru_closeCancelRouteTimeSelectModal_ExtraPage === 'function') {
            sruCancelModalCancelButton_el_extra.addEventListener('click', sru_closeCancelRouteTimeSelectModal_ExtraPage);
        }
        sruCancelModalSelectAllCheckbox_el_extra.addEventListener('change', (event) => {
            const isChecked = event.target.checked;
            const timeCheckboxes = sruCancelModalCheckboxesContainer_el_extra.querySelectorAll('input[type="checkbox"][name="sruCancelSelectedGoLiveTimeCheckbox_extra"]');
            timeCheckboxes.forEach(cb => { cb.checked = isChecked; });
            const anyChecked = Array.from(timeCheckboxes).some(cb => cb.checked);
            if (sruCancelModalConfirmButton_el_extra) sruCancelModalConfirmButton_el_extra.disabled = !anyChecked;
        });
        if (sruCancelRouteTimeSelectModal_el_extra && typeof sru_closeCancelRouteTimeSelectModal_ExtraPage === 'function') {
             sruCancelRouteTimeSelectModal_el_extra.addEventListener('click', (event) => {
                if (event.target === sruCancelRouteTimeSelectModal_el_extra) sru_closeCancelRouteTimeSelectModal_ExtraPage();
            });
        }
    }
    if (sruCancelAllPendingUpdatesGloballyButton_el_extra && typeof handleCancelAllUpdatesAllRoutes_Global === 'function') {
        sruCancelAllPendingUpdatesGloballyButton_el_extra.addEventListener('click', handleCancelAllUpdatesAllRoutes_Global);
    }


    // --- Timetable Exporter Section Listeners ---
    if (tteRouteNameSelect_el_extra && tteRouteNameInput_el_extra) {
        tteRouteNameSelect_el_extra.addEventListener('change', () => {
            if (tteRouteNameInput_el_extra) tteRouteNameInput_el_extra.value = tteRouteNameSelect_el_extra.value;
            if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = '';
        });
        tteRouteNameInput_el_extra.addEventListener('input', () => {
            const typedValue = tteRouteNameInput_el_extra.value.trim().toUpperCase();
            let matchedSelectValue = "";
            if (tteRouteNameSelect_el_extra) {
                const matchedOption = Array.from(tteRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedValue);
                if (matchedOption) matchedSelectValue = matchedOption.value;
                if (tteRouteNameSelect_el_extra.value !== matchedSelectValue) tteRouteNameSelect_el_extra.value = matchedSelectValue;
            }
            if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = '';
        });
    }
    if (tteDownloadTimetableButton_el_extra && typeof handleDownloadTimetable_ExtraPage === 'function') {
        tteDownloadTimetableButton_el_extra.addEventListener('click', handleDownloadTimetable_ExtraPage);
    }

    // --- Service Analyzer Section Listeners ---
    if (serviceAnalyzerStopSelect_el_extra && typeof triggerStopAnalysisDynamically === 'function') {
        serviceAnalyzerStopSelect_el_extra.addEventListener('change', function() {
            const selectedStopID = this.value;
            if (serviceAnalyzerStopInput_el_extra) {
                const selectedOption = this.options[this.selectedIndex];
                serviceAnalyzerStopInput_el_extra.value = (selectedOption && selectedOption.value) ? selectedOption.text : "";
            }
            triggerStopAnalysisDynamically(selectedStopID);
        });
    }
    if (serviceAnalyzerStopInput_el_extra && serviceAnalyzerStopSelect_el_extra && typeof triggerStopAnalysisDynamically === 'function') {
        serviceAnalyzerStopInput_el_extra.addEventListener('input', function() { // 'input' for immediate feedback
            const typedValueLower = this.value.toLowerCase().trim();
            if (typedValueLower === "") {
                if (serviceAnalyzerStopSelect_el_extra.value !== "") serviceAnalyzerStopSelect_el_extra.value = "";
                if(serviceAnalyzerStopSummary_el_extra) serviceAnalyzerStopSummary_el_extra.innerHTML = `<span style="color:#f1c40f;">Please select or enter a stop.</span>`;
                return;
            }
            const options = Array.from(serviceAnalyzerStopSelect_el_extra.options);
            const matchedOption = options.find(opt =>
                opt.text.toLowerCase().includes(typedValueLower) ||
                (opt.value && opt.value.toLowerCase() === typedValueLower)
            );
            if (matchedOption) {
                if (serviceAnalyzerStopSelect_el_extra.value !== matchedOption.value) {
                    serviceAnalyzerStopSelect_el_extra.value = matchedOption.value;
                    // Trigger analysis if select value changes due to typing
                    triggerStopAnalysisDynamically(matchedOption.value);
                }
            } else {
                if (serviceAnalyzerStopSelect_el_extra.value !== "") serviceAnalyzerStopSelect_el_extra.value = "";
                 // If typing and no match, you might want to clear summary or show "no match"
                 if(serviceAnalyzerStopSummary_el_extra) serviceAnalyzerStopSummary_el_extra.innerHTML = `<span style="color:#f1c40f;">Searching for stop matching "${this.value}"...</span>`;
            }
        });
        serviceAnalyzerStopInput_el_extra.addEventListener('blur', function() { // Analyze on blur if a value is present
            const typedValue = this.value.trim();
            // If select has a value, it means a match was found during 'input' or already selected
            // So, we only analyze typed value if dropdown didn't make a selection
            if (typedValue && !serviceAnalyzerStopSelect_el_extra.value) {
                triggerStopAnalysisDynamically(typedValue);
            } else if (!typedValue && !serviceAnalyzerStopSelect_el_extra.value){
                if(serviceAnalyzerStopSummary_el_extra) serviceAnalyzerStopSummary_el_extra.innerHTML = `<span style="color:#f1c40f;">Please select or enter a stop.</span>`;
            }
            // if serviceAnalyzerStopSelect_el_extra.value IS set, analysis would have happened on change or input sync
        });
    }

    // --- Config Data Section Listeners ---
    const shSaveButton_el_extra = document.getElementById('sh-save-button-extra');
    const shClearFormButton_el_extra = document.getElementById('sh-clear-form-button-extra');
    const opProfileAddButton_el_extra = document.getElementById('op-profile-add-button-extra');

    if (shSaveButton_el_extra && typeof handleSaveSchoolHoliday_ExtraPage === 'function') {
        shSaveButton_el_extra.addEventListener('click', handleSaveSchoolHoliday_ExtraPage);
    }
    if (shClearFormButton_el_extra && typeof clearSchoolHolidayForm_ExtraPage === 'function') {
        shClearFormButton_el_extra.addEventListener('click', clearSchoolHolidayForm_ExtraPage);
    }
    if (opProfileAddButton_el_extra && typeof handleAddOpProfile_ExtraPage === 'function') {
        opProfileAddButton_el_extra.addEventListener('click', handleAddOpProfile_ExtraPage);
    }

});



// Helper function to generate sequence HTML for a given set of profiles
function generateSequenceMapForProfiles(
    profilesToAnalyze,
    currentDestName,
    allEntriesForRoute // All schedule entries for the main route being analyzed
) {
    const sequencesMap = new Map(); // Key: sequenceSignature, Value: { sequence: [stopObjects], profiles: Set() }

    if (!profilesToAnalyze || profilesToAnalyze.length === 0) {
        return sequencesMap; // Return an empty map if no profiles to analyze
    }

    const sortedProfiles = [...profilesToAnalyze].sort(); // Process profiles in a consistent order

    for (const opProfile of sortedProfiles) {
        // Filter entries for the current operating profile and destination
        const specificProfileEntries = allEntriesForRoute.filter(e =>
            e.destinationName === currentDestName && e.OperatingProfile === opProfile
        );

        if (specificProfileEntries.length === 0) continue; // No entries for this specific profile/destination

        // Sort these specificProfileEntries chronologically to correctly identify the first trip
        specificProfileEntries.sort((a, b) => {
            const dayOffsetA = parseInt(a.DayOffset || 0);
            const dayOffsetB = parseInt(b.DayOffset || 0);
            if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;

            const timeA = (a.scheduledTime || "99:99").replace(':', ''); // Fallback for missing time
            const timeB = (b.scheduledTime || "99:99").replace(':', '');
            return timeA.localeCompare(timeB);
        });

        const sequenceForThisProfileTrip = [];
        if (specificProfileEntries.length > 0) {
            const firstStopIDOfThisJourneyPattern = specificProfileEntries[0].stopID;
            let previousStopTimeInAbsoluteMinutes = -1;
            // Heuristic: Minimum stops to process before considering a repeat of the first stop ID as a new trip.
            // This helps distinguish a genuine new trip from a route that might loop back to its start ID quickly.
            // Adjust if necessary. If routes are very short (e.g. 2-stop shuttles that repeat often), this might need tuning.
            const MIN_STOPS_BEFORE_FIRST_ID_REVISIT_BREAK = 3;

            for (let i = 0; i < specificProfileEntries.length; i++) {
                const entry = specificProfileEntries[i];

                if (!entry.stopID || !entry.scheduledTime) {
                    console.warn(`Service Analyzer: Skipping entry for ${opProfile} (Dest: ${currentDestName}) due to missing stopID/time:`, entry);
                    continue;
                }

                const currentStopTimeInAbsoluteMinutes =
                    (parseInt(entry.DayOffset || 0) * 1440) +
                    parseInt(entry.scheduledTime.split(':')[0]) * 60 +
                    parseInt(entry.scheduledTime.split(':')[1]);

                // These break conditions apply only after the very first stop (i > 0)
                if (i > 0) {
                    // Condition 1: Time regresses (e.g., next day's service, or data error)
                    if (currentStopTimeInAbsoluteMinutes < previousStopTimeInAbsoluteMinutes) {
                        break; // End of the current trip's sequence
                    }
                    // Condition 2: Encountered the starting stop ID again *after* a few other stops
                    if (entry.stopID === firstStopIDOfThisJourneyPattern &&
                        sequenceForThisProfileTrip.length >= MIN_STOPS_BEFORE_FIRST_ID_REVISIT_BREAK) {
                        break; // Assumed start of the next iteration of this trip pattern
                    }
                }

                sequenceForThisProfileTrip.push({
                    stopID: entry.stopID,
                    name: entry.stopName || entry.stopID,
                    direction: entry.direction || 'N/A'
                });
                previousStopTimeInAbsoluteMinutes = currentStopTimeInAbsoluteMinutes;
            }
        }

        if (sequenceForThisProfileTrip.length > 0) {
            const sequenceSignature = sequenceForThisProfileTrip.map(s => s.stopID).join('->');
            if (!sequencesMap.has(sequenceSignature)) {
                sequencesMap.set(sequenceSignature, {
                    sequence: sequenceForThisProfileTrip,
                    profiles: new Set()
                });
            }
            sequencesMap.get(sequenceSignature).profiles.add(opProfile);
        }
    } // End opProfile loop
    return sequencesMap;
}

function populateStopSelectorForDeparturesView_ExtraPage() {
    // This function now uses the global constants defined above
    if (!selectStopForDeparturesView_extra) {
        console.error("View Departures: Stop selector element not found.");
        return;
    }
    
    const currentVal = selectStopForDeparturesView_extra.value;
    selectStopForDeparturesView_extra.innerHTML = '<option value="">-- Select Stop --</option>';

    if (currentWorkingSchedule_extra.length === 0) {
        selectStopForDeparturesView_extra.innerHTML = '<option value="">-- No Stops Loaded --</option>';
        return;
    }

    const stopsMap = new Map();
    // Iterates over the globally available schedule data
    currentWorkingSchedule_extra.forEach(e => {
        if (e.stopID && !stopsMap.has(e.stopID.toUpperCase())) {
            stopsMap.set(e.stopID.toUpperCase(), { stopID: e.stopID, stopName: e.stopName || e.stopID });
        }
    });
    
    const sortedStops = Array.from(stopsMap.values()).sort((a,b) => (a.stopName || "").toLowerCase().localeCompare((b.stopName || "").toLowerCase()));

    sortedStops.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s.stopID;
        opt.textContent = `${s.stopName} (${s.stopID})`;
        selectStopForDeparturesView_extra.appendChild(opt);
    });

    if (stopsMap.has(currentVal.toUpperCase())) {
        selectStopForDeparturesView_extra.value = currentVal;
    }
}

function displayDeparturesForSelectedStop_ExtraPage() {
    const selectEl = document.getElementById('selectStopForDeparturesView_extra');
    const listEl = document.getElementById('stopDeparturesList_extra');
    const noDeparturesMsg = document.getElementById('noDeparturesForStopMessage_extra');

    if (!selectEl || !listEl || !noDeparturesMsg) return;
    
    const selectedStopID = selectEl.value;
    listEl.innerHTML = '';

    if (!selectedStopID) {
        noDeparturesMsg.textContent = 'Select a stop to view its scheduled departures.';
        noDeparturesMsg.style.display = 'block';
        return;
    }

    const todaysActiveProfiles = getOperatingCodesForDate_ExtraPage(new Date());

    const departures = currentWorkingSchedule_extra
        .filter(e => {
            if (e.stopID !== selectedStopID || !e.scheduledTime) {
                return false;
            }
            const departureProfiles = e.OperatingProfile.split(',').map(p => p.trim());
            return departureProfiles.some(dp => todaysActiveProfiles.includes(dp));
        })
        .sort((a, b) => {
            // --- NEW: Simplified sort by time on the clock, ignoring DayOffset ---

            // Level 1: Time of Day
            const timeA = (a.scheduledTime || "99:99").replace(':', '');
            const timeB = (b.scheduledTime || "99:99").replace(':', '');
            if (timeA !== timeB) return timeA.localeCompare(timeB);

            // Level 2: Route Name (as a tie-breaker)
            const routeCompare = compareLineNames_ExtraPage(a.lineName, b.lineName);
            if (routeCompare !== 0) return routeCompare;

            // Level 3: Destination Name (as a final tie-breaker)
            return (a.destinationName || "").localeCompare(b.destinationName || "");
        });


    if (departures.length === 0) {
        noDeparturesMsg.textContent = 'No scheduled departures found for this stop today.';
        noDeparturesMsg.style.display = 'block';
    } else {
        noDeparturesMsg.style.display = 'none';
        departures.forEach(d => {
            const li = document.createElement('li');
            const tile = document.createElement('span');
            tile.className = 'route-tile-tools-list';
            tile.textContent = d.lineName || 'N/A';
            const bgColor = getRouteTileColour_ExtraPage(d.lineName, selectedStopID);
            tile.style.backgroundColor = bgColor;
            tile.style.color = getTextColourForBackground_ExtraPage(bgColor);

            const span = document.createElement('span');
            span.style.marginLeft = '0.5em';
            span.innerHTML = `to ${d.destinationName || 'Unknown'} <strong style="margin-left:0.5em;">at ${d.scheduledTime}</strong> <small style="opacity:0.7;margin-left:0.75em;">(P: ${d.OperatingProfile || 'N/A'})</small>${d.DayOffset && d.DayOffset !== "0" ? `<small style="opacity:0.7;margin-left:0.3em;color:#FFD700;">(+${d.DayOffset}d)</small>`: ''}`;
            
            li.appendChild(tile);
            li.appendChild(span);
            listEl.appendChild(li);
        });
    }
}

</script>
</body>
</html>
