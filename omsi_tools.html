<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMSI Countdown - Tools</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        @font-face {
            font-family: 'NJFont Medium Web';
            src: url('fonts/NJFont-Medium.ttf') format('truetype');
            font-weight: normal;font-style: normal;font-display: swap;
        }
        body {
            font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            margin:0;
        }
        .page-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        #top-menu-bar {
            background-color: rgba(0,0,0,0.25);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center;
            display: none; /* Hidden by default, shown after login */
        }
        .menu-button {
            cursor: pointer; 
            background-color: #3498db; 
            color: white;
            padding: 0.6rem 1.2rem; 
            border-radius: 0.25rem; 
            font-size: 0.9rem;
            transition: background-color 0.2s; 
            border: none; 
            margin: 0.25rem;
        }
        .menu-button:hover { 
            background-color: #2980b9; 
        }

        .tool-content-section {
            display: none; /* All tool sections hidden by default */
        }

        #auth-section { 
             margin-bottom: 1.5rem;
        }
        #current-profile-display-container {
            text-align: center; 
            margin-bottom: 1.5rem; 
            padding: 0.75rem; 
            background-color: rgba(255,255,255,0.05); 
            border-radius: 0.25rem;
            display: none; /* Hidden by default, shown after login */
        }
        #current-profile-display { font-size: 0.9rem; opacity: 0.9; font-style: italic;}


        h1 { font-size: 2rem; margin-bottom: 1.5rem; font-weight: normal; text-align: center; color: #ffffff; }
        h2 { font-size: 1.5rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: normal; border-bottom: 1px solid #7f8c8d; padding-bottom: 0.25rem;}
        h3.subsection-title { font-size: 1.25rem; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: normal; color: #e0e0e0; border-bottom: 1px solid rgba(127,140,141,0.5); padding-bottom: 0.2rem;}


        .section {
            background-color: rgba(0,0,0,0.15);
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .subsection { /* For subsections within a tool-content-section */
            background-color: rgba(0,0,0,0.1);
            padding: 1rem;
            border-radius: 0.375rem; /* slightly smaller radius */
            margin-top: 1rem;
            margin-bottom: 1rem;
             border: 1px solid rgba(127,140,141,0.2);
        }


        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;}
        .form-section div { margin-bottom: 0.75rem; }

        label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.85rem;
            color: #bdc3c7;
        }

        input[type="text"],
        input[type="email"],
        input[type="password"],
        input[type="time"],
        input[type="color"],
        select {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size:0.9rem;
        }
        input[type="color"] { height: 2.75rem; padding: 0.25rem; }
        #inputOperatingProfile, #analyticsOperatingProfileSelect { max-width: 100%;}
        #selectDayOffset, #selectRouteNameColour, #selectStopForDeparturesView { max-width: 100%; }
        /* Ensure new select dropdowns also get this styling */
        #editMasterStopIdSelect, #routesForStopSelect_StopManagement, #selectStopForDiversion_RD { max-width: 100%; }
        #selectDayOffset option, #selectRouteNameColour option, #selectStopForDeparturesView option, #analyticsOperatingProfileSelect option,
        #editMasterStopIdSelect option, #routesForStopSelect_StopManagement option, #selectStopForDiversion_RD option { background-color: #34495e; color: #ecf0f1; }


        #inputStopID, #inputLineName, #bulkEditTargetStopID, #bulkEditTargetLineName,
        #editMasterStopIdInput, #findStopIdScheduleInput, #replaceStopIdScheduleInput {
            text-transform: uppercase;
        }

        .button { 
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin-right: 0.5rem; margin-top:0.5rem;
        }
        .button:hover { background-color: #2980b9; }
        .button.small-action { padding: 0.2rem 0.4rem; font-size: 0.9rem; margin: 0 0.15rem; line-height: 1; min-width: 20px; text-align:center;}
        .button.secondary { background-color: #e74c3c; }
        .button.secondary:hover { background-color: #c0392b; }
        .button.tertiary { background-color: #f39c12; }
        .button.tertiary:hover { background-color: #e67e22; }
        .button.neutral { background-color: #7f8c8d; }
        .button.neutral:hover { background-color: #95a5a6; color: #2c3e50; }


        .file-upload-label { display: inline-block; cursor: pointer; background-color: #95a5a6; color: #2c3e50; padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem; transition: background-color 0.2s; margin-bottom: 0.5rem; }
        .file-upload-label:hover { background-color: #7f8c8d; }
        #file-status { font-size: 0.9rem; margin-top: 0.25rem; margin-bottom:1rem; opacity: 0.9; min-height: 1.2em; }

        #currentScheduleTableContainer {
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid #7f8c8d;
            margin-top: 0.5rem;
            border-radius: 0.25rem;
        }
        table { width: 100%; border-collapse: collapse; font-size: 0.8rem;}
        th, td {
            padding: 0.4rem 0.5rem;
            text-align: left;
            border-bottom: 1px solid #34495e;
            white-space: nowrap;
        }
        th { background-color: rgba(0,0,0,0.2); font-weight: normal; color: #bdc3c7; cursor: pointer; user-select:none;}
        th:hover { background-color: rgba(0,0,0,0.3); }
        th .sort-arrow { margin-left: 5px; font-size: 0.7em; display:inline-block; width:10px; }

        .actions-section { margin-top: 1.5rem; }
        #stageScheduleButton { background-color: #27ae60; }
        #stagingStatusMessage { text-align:center; margin-bottom: 1rem; font-size: 0.9em; color: #f1c40f; min-height:1.2em; }


        .info-section { margin-top:2rem; padding:1rem; background-color: rgba(0,0,0,0.1); border-radius:0.25rem; font-size:0.8rem; }
        .info-section h3 { font-size:1rem; margin-bottom:0.5rem; color: #ffffff; }
        .info-section p { line-height:1.6; color:#bdc3c7; }

        .tooltip { position: relative; display: inline-block; cursor: help; margin-left: 4px; font-size:0.8em; background-color:#7f8c8d; color:white; border-radius:50%; width:14px; height:14px; text-align:center; line-height:14px;}
        .tooltip .tooltiptext {
            visibility: hidden; width: 280px; background-color: #34495e; color: #fff;
            text-align: left; border-radius: 6px; padding: 8px; position: absolute;
            z-index: 10; bottom: 135%; left: 50%; margin-left: -140px; opacity: 0; transition: opacity 0.3s;
            font-size: 0.75rem; line-height: 1.4; border: 1px solid #7f8c8d;
        }
        .tooltip .tooltiptext::after {
            content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px;
            border-width: 5px; border-style: solid; border-color: #34495e transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .filter-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; margin-bottom: 1rem; align-items: end;}
        .filter-controls div { margin-bottom: 0; }
        .filter-controls input[type="text"] { margin-bottom:0; }
        .filter-controls button { margin-top:0; }

        .current-details-display {
            margin-top: 0.5rem;
            font-size: 0.85em;
            background-color: rgba(0,0,0,0.2);
            padding: 0.5rem;
            border-radius: 0.25rem;
            color: #bdc3c7;
        }
        .current-details-display p { margin: 0.2rem 0; }
        .current-details-display span { font-style: italic; color: #ecf0f1; }

        .event-section div, .stop-status-section div, .route-colour-management-subsection div, 
        .view-stop-departures div, .analytics-subsection div, 
        /* Added for new section */
        #route-diversion-tool-section .section > .form-grid div {
            margin-bottom: 0.75rem;
        }
        .event-section label, .stop-status-section label, .route-colour-management-subsection label, 
        .view-stop-departures label, .analytics-subsection label,
        /* Added for new section */
        #route-diversion-tool-section .section > .form-grid label {
             margin-bottom: 0.25rem;
        }


        #currentRouteColoursListContainer, #duplicateEntriesResults, #serviceFrequencyResults {
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            padding: 0.75rem;
            margin-top: 1rem;
            max-height: 300px; 
            overflow-y: auto;
            background-color: rgba(0,0,0,0.05);
        }
        #currentRouteColoursList li, #duplicateEntriesResults li, #serviceFrequencyResults li {
            display: block; 
            padding: 0.5rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #currentRouteColoursList li:last-child, #duplicateEntriesResults li:last-child, #serviceFrequencyResults li:last-child { border-bottom: none; }
        
        #duplicateEntriesResults .duplicate-set { margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 1px dashed #4A5568;}
        #duplicateEntriesResults .duplicate-set:last-child { border-bottom: none; }
        #duplicateEntriesResults .entry-detail { display: block; font-size: 0.85rem; margin-left: 1rem; opacity: 0.9;}


        .colour-preview-box {
            width: 20px;
            height: 20px;
            border: 1px solid #ecf0f1;
            margin-right: 10px;
            display: inline-block;
            vertical-align: middle;
        }
        #currentRouteColoursList .route-info { flex-grow: 1; }

        .route-tile-tools-list {
            display: inline-block;
            padding: 0.2em 0.55em;
            margin-right: 0.6em;
            border-radius: 0.25rem;
            font-size: 0.8em;
            font-weight: bold;
            color: white;
            text-align: center;
            line-height: 1.3;
            min-width: 28px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.25);
            vertical-align: middle;
        }
        #stopDeparturesList li {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.1rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #stopDeparturesList li:last-child {
            border-bottom: none;
        }

        #masterStopListUL_SM li {
            padding: 0.6rem 0.5rem;
            border-bottom: 1px solid #34495e;
            cursor: pointer;
            transition: background-color 0.15s ease-in-out;
        }
        #masterStopListUL_SM li:last-child {
            border-bottom: none;
        }
        #masterStopListUL_SM li:hover {
            background-color: #34495e;
        }
        #masterStopListUL_SM li .stop-id-master { font-weight: bold; color: #ecf0f1;}
        #masterStopListUL_SM li .stop-name-master { color: #bdc3c7; }
        #masterStopListUL_SM li .stop-direction-master { font-style: italic; font-size: 0.85em; color: #95a5a6; }

        #routesServingStopList_SM li {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.1rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #routesServingStopList_SM li:last-child {
            border-bottom: none;
        }

        /* Styles for Route Diversion Tool list items */
        #routesListForDiversion_RD div {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.2rem; /* Adjust padding as needed */
            border-bottom: 1px solid #34495e;
        }
        #routesListForDiversion_RD div:last-child {
            border-bottom: none;
        }
        #routesListForDiversion_RD input[type="checkbox"] {
            transform: scale(1.1); /* Slightly larger checkbox */
            margin-right: 0.8rem;
        }
        #routesListForDiversion_RD label {
            cursor: pointer;
            font-size: 0.9rem;
        }
        #routesListForDiversion_RD label.diverted {
            text-decoration: line-through;
            color: #e74c3c; /* Reddish color for diverted routes in tools */
            font-style: italic;
        }

    </style>
</head>
<body lang="en-GB">
    <div class="page-container">
        <h1>Bus Schedule Setup & Management</h1>

        <div id="auth-section" class="section">
            <h2>Admin Login</h2>
            <div id="login-form-container">
                <form id="adminLoginForm">
                    <div class="form-grid" style="grid-template-columns: 1fr;">
                        <div><label for="inputEmail">Email</label><input type="email" id="inputEmail" autocomplete="email"></div>
                        <div><label for="inputPassword">Password</label><input type="password" id="inputPassword" autocomplete="current-password"></div>
                    </div>
                    <button id="loginButton" type="submit" class="button">Login</button>
                </form>
                <p id="auth-status" style="margin-top: 0.5em; color: #f1c40f;"></p>
            </div>
            <div id="logout-container" style="display:none;">
                <p>Logged in as: <span id="loggedInUserEmail"></span></p>
                <button id="logoutButton" class="button secondary">Logout</button>
            </div>
        </div>

        <div id="current-profile-display-container" class="section">
            <p id="current-profile-display">Today's Auto Profile: (determining...)</p>
        </div>

        <div id="top-menu-bar">
            <div id="main-menu-buttons">
                <button class="menu-button" data-section="bulk-edit-tools-section">Bulk Edit & Colours</button>
                <button class="menu-button" data-section="event-generator-section">Event Generator</button>
                <button class="menu-button" data-section="stop-status-section">Stop Status</button>
                <button class="menu-button" data-section="view-departures-section">View Departures</button>
                <button class="menu-button" data-section="schedule-display-section">Working Schedule Table</button>
                <button class="menu-button" data-section="deployment-tools-section">Deployment & Entry</button>
                <button class="menu-button" data-section="analytics-validation-section">Analytics & Validation</button>
                <button class="menu-button" data-section="stop-management-tool-section">Stop Management</button>
                <button class="menu-button" data-section="route-diversion-tool-section">Route Diversions</button>
            </div>
        </div>
        
        <div id="tool-sections-wrapper">
            <div id="bulk-edit-tools-section" class="tool-content-section">
                <div class="section bulk-edit-stop-details-section">
                    <h2>Update Stop Name & Direction by Stop ID</h2>
                    <div class="form-grid" style="grid-template-columns: 1fr; gap: 0.75rem;">
                        <div><label for="bulkEditTargetStopID">Target Stop ID</label><input type="text" id="bulkEditTargetStopID" placeholder="Enter Stop ID" autocomplete="off"></div>
                        <div class="current-details-display"><p><strong>Current Name:</strong> <span id="currentBulkEditStopNameDisplay">-</span></p><p><strong>Current Direction:</strong> <span id="currentBulkEditDirectionDisplay">-</span></p></div>
                        <div><label for="bulkEditNewStopName">New Stop Name</label><input type="text" id="bulkEditNewStopName" placeholder="New stop name" autocomplete="off"></div>
                        <div><label for="bulkEditNewDirection">New "Towards" Text</label><input type="text" id="bulkEditNewDirection" placeholder="New direction" autocomplete="off"></div>
                        <div style="margin-top: 0.5rem;"><button id="bulkUpdateDetailsButton" class="button">Update Stop Details</button></div>
                    </div>
                </div>
                <div class="section bulk-edit-route-destination">
                    <h2>Update Destination for a Route</h2>
                    <div class="form-grid" style="grid-template-columns: 1fr 1.5fr 1.5fr auto; align-items:end; gap: 0.75rem;">
                        <div><label for="bulkEditTargetLineName">Target Line</label><input type="text" id="bulkEditTargetLineName" placeholder="e.g., 186" autocomplete="off"></div>
                        <div><label for="bulkEditOldDestination">Old Destination (optional)</label><input type="text" id="bulkEditOldDestination" placeholder="Blank to update all" autocomplete="off"></div>
                        <div><label for="bulkEditNewDestination">New Destination</label><input type="text" id="bulkEditNewDestination" placeholder="New destination" autocomplete="off"></div>
                        <div style="padding-bottom:0.05rem;"><button id="bulkUpdateRouteDestinationButton" class="button">Update Destination</button></div>
                    </div>
                </div>
                <div class="section route-colour-management-subsection">
                    <h2>Route Tile Colour Management</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">Define custom colours for routes on the arrivals board.</p>
                    <div class="form-grid" style="grid-template-columns: 1.5fr 1fr auto; align-items: end; gap: 0.75rem;">
                        <div><label for="selectRouteNameColour">Route Name</label><select id="selectRouteNameColour"><option value="">-- Select Route --</option></select></div>
                        <div><label for="inputRouteColour">Select Colour</label><input type="color" id="inputRouteColour" value="#73809C" autocomplete="off"></div>
                        <div style="padding-bottom:0.05rem;"><button id="saveRouteColourButton" class="button">Save Colour</button></div>
                    </div>
                    <div id="currentRouteColoursListContainer"><h3 style="font-size: 1.1rem; margin-bottom: 0.5rem;">Current Custom Colours</h3><ul id="currentRouteColoursList"></ul><p id="noCustomColoursMessage">No custom colours set.</p></div>
                    <p id="routeColourStatusMessage" style="min-height:1.2em;"></p>
                </div>
            </div>

            <div id="event-generator-section" class="tool-content-section">
                 <div class="section random-event-generator">
                    <h2>Random Event Generator</h2>
                    <div class="form-grid event-section" style="grid-template-columns: 1.5fr 1.5fr auto; align-items:end;">
                        <div><label for="selectEventRoute">Route</label><select id="selectEventRoute"><option value="">-- Select Route --</option></select></div>
                        <div><label for="selectEventImpactStop">Impact From Stop (Optional)</label><select id="selectEventImpactStop"><option value="">-- Route Wide --</option></select></div>
                        <div style="padding-bottom:0.05rem;"><button id="triggerEventButton" class="button tertiary">Trigger Event</button></div>
                    </div>
                    <p id="eventStatusMessage" style="min-height:1.2em;"></p>
                </div>
            </div>

            <div id="stop-status-section" class="tool-content-section">
                <div class="section stop-status-section">
                    <h2>Manage Bus Stop Status (Live)</h2>
                    <div class="form-grid stop-status-section" style="grid-template-columns: 2fr auto auto; align-items:end;">
                        <div><label for="selectStopForStatusChange">Stop</label><select id="selectStopForStatusChange"><option value="">-- Select Stop --</option></select></div>
                        <div style="padding-bottom:0.05rem;"><button id="closeStopButton" class="button secondary">Close Stop</button></div>
                        <div style="padding-bottom:0.05rem;"><button id="reopenStopButton" class="button" style="background-color: #2ecc71;">Reopen Stop</button></div>
                    </div>
                    <p id="stopStatusMessage" style="min-height:1.2em;"></p>
                </div>
            </div>
            
            <div id="view-departures-section" class="tool-content-section">
                <div class="section view-stop-departures">
                    <h2>View Scheduled Departures by Stop</h2>
                    <div class="form-grid" style="grid-template-columns: 1fr 2fr; align-items: start; gap: 1.5rem;">
                        <div><label for="selectStopForDeparturesView">Bus Stop</label><select id="selectStopForDeparturesView"><option value="">-- Select Stop --</option></select></div>
                        <div><label>Departures</label><div id="stopDeparturesListContainer"><ul id="stopDeparturesList"></ul><p id="noDeparturesForStopMessage">Select stop to view.</p></div></div>
                    </div>
                </div>
            </div>
            
            <div id="schedule-display-section" class="tool-content-section">
                 <div class="section schedule-display">
                    <h2>Working Schedule Table (<span id="entryCount">0</span> entries)</h2>
                    <div class="filter-controls">
                        <div><label for="filterStopID">Filter Stop ID</label><input type="text" id="filterStopID" placeholder="e.g. EDGWHLS" autocomplete="off"></div>
                        <div><label for="filterLineName">Filter Line</label><input type="text" id="filterLineName" placeholder="e.g. 186" autocomplete="off"></div>
                        <div><label for="filterOperatingProfile">Filter Profile</label><input type="text" id="filterOperatingProfile" placeholder="e.g. MoSch" autocomplete="off"></div>
                        <div><label>&nbsp;</label><button id="clearFiltersButton" class="button neutral" style="width:100%;">Clear Filters</button></div>
                    </div>
                    <div id="currentScheduleTableContainer"><table><thead><tr><th data-sortkey="stopID">Stop ID <span class="sort-arrow"></span></th><th data-sortkey="stopName">Stop Name <span class="sort-arrow"></span></th><th data-sortkey="direction">Direction <span class="sort-arrow"></span></th><th data-sortkey="lineName">Line <span class="sort-arrow"></span></th><th data-sortkey="destinationName">Destination <span class="sort-arrow"></span></th><th data-sortkey="scheduledTime">Time <span class="sort-arrow"></span></th><th data-sortkey="OperatingProfile">Profile(s) <span class="sort-arrow"></span></th><th data-sortkey="DayOffset">Offset <span class="sort-arrow"></span></th><th style="width:100px;">Actions</th></tr></thead><tbody id="currentScheduleTableBody"></tbody></table></div>
                </div>
            </div>

            <div id="deployment-tools-section" class="tool-content-section">
                <div class="section manual-entry-form">
                    <h2>Add / Edit Schedule Entry</h2>
                    <input type="hidden" id="editingEntryIndex" value="-1">
                    <div class="form-grid">
                        <div><label for="inputStopID">Stop ID</label><input type="text" id="inputStopID" autocomplete="off"></div>
                        <div><label for="inputStopName">Stop Name</label><input type="text" id="inputStopName" autocomplete="off"></div>
                        <div><label for="inputDirection">Direction</label><input type="text" id="inputDirection" autocomplete="off"></div>
                        <div><label for="inputLineName">Line Name</label><input type="text" id="inputLineName" autocomplete="off"></div>
                        <div><label for="inputDestinationName">Destination Name</label><input type="text" id="inputDestinationName" autocomplete="off"></div>
                        <div><label for="inputScheduledTime">Scheduled Time (HH:MM)</label><input type="time" id="inputScheduledTime" autocomplete="off"></div>
                    </div>
                    <div>
                        <label for="inputOperatingProfile">Operating Profile(s)
                            <span class="tooltip">?
                                <span class="tooltiptext">Comma-separated codes: Mo, Tu, We, Th, Fr, Sa, Su, Mo-Fr, Sch (School Day), NSD (Non-School Day/Hol), BankHoliday, etc. Combine: MoSch, MFNSD.</span>
                            </span>
                        </label>
                        <input type="text" id="inputOperatingProfile" placeholder="e.g., MoSch, Sa, BankHoliday" autocomplete="off">
                    </div>
                    <div>
                        <label for="selectDayOffset">Day Offset</label>
                        <select id="selectDayOffset">
                            <option value="0">0 (Same Day)</option>
                            <option value="1">1 (Next Day)</option>
                        </select>
                    </div>
                    <div style="margin-top:1rem;">
                        <button id="addEntryButton" class="button">Add Entry</button>
                        <button id="updateEntryButton" class="button tertiary" style="display:none;">Update Entry</button>
                        <button id="cancelEditButton" class="button secondary" style="display:none;">Cancel Edit</button>
                    </div>
                </div>
                <div class="section count-file-upload">
                    <h2>Upload Full Schedule</h2>
                    <p style="font-size:0.8em; margin-bottom:0.5em;">Replaces current working schedule.</p>
                    <label for="count-file-input" class="file-upload-label">Choose .COUNT File</label>
                    <input type="file" id="count-file-input" accept=".COUNT,.txt" style="display: none;">
                    <p id="file-status">No file selected.</p>
                </div>
                <div class="actions-section section">
                    <h2>Schedule Deployment Actions</h2>
                    <div id="stagingStatusMessage" style="min-height:1.2em;">Checking status...</div>
                    <button id="stageScheduleButton" class="button">Stage Working Schedule</button>
                    <button id="applyNowButton" class="button tertiary">Apply Staged Live NOW</button>
                    <hr style="margin: 1.5rem 0; border-color: rgba(255,255,255,0.1);">
                    <button id="viewArrivalsButton" class="button">View Arrivals Board</button>
                </div>
            </div>

            <div id="analytics-validation-section" class="tool-content-section">
                <div class="section">
                    <h2>Schedule Analytics & Validation</h2>

                    <div class="subsection analytics-subsection">
                        <h3 class="subsection-title">Duplicate Entry Detection</h3>
                        <button id="detectDuplicatesButton" class="button">Find Duplicate Entries</button>
                        <div id="duplicateEntriesResults" style="margin-top: 0.75rem;">
                            <p>Click the button to scan the current working schedule for duplicate entries.</p>
                        </div>
                    </div>

                    <div class="subsection analytics-subsection">
                        <h3 class="subsection-title">Service Frequency Overview</h3>
                        <div>
                            <label for="analyticsOperatingProfileSelect">Filter by Operating Profile (Optional):</label>
                            <select id="analyticsOperatingProfileSelect">
                                <option value="">-- All Profiles in Schedule --</option>
                                </select>
                        </div>
                        <button id="calculateFrequencyButton" class="button">Analyze Service Frequencies</button>
                        <div id="serviceFrequencyResults" style="margin-top: 0.75rem;">
                            <p>Select an operating profile (optional) and click the button to analyze frequencies.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div id="stop-management-tool-section" class="tool-content-section">
                <div class="section"> <h2>Master List of Unique Stops</h2>
                    <div class="filter-controls" style="grid-template-columns: 1fr auto; gap: 0.75rem; margin-bottom: 0.5rem;">
                        <input type="text" id="masterStopListFilterInput_SM" placeholder="Filter by Stop ID, Name, or Direction...">
                        <button id="refreshMasterStopListButton_SM" class="button neutral">Refresh List</button>
                    </div>
                    <div id="masterStopListContainer_SM" class="subsection" style="max-height: 350px; overflow-y: auto; padding: 0.5rem; background-color: rgba(0,0,0,0.05);">
                        <ul id="masterStopListUL_SM" style="list-style: none; padding: 0;">
                            </ul>
                    </div>
                    <p id="masterStopListStatus_SM" style="text-align: center; margin-top: 0.5rem; min-height: 1.2em;">Click "Refresh List" to load stops from the current working schedule.</p>
                </div>

                <div class="section">
                    <h2>Edit Stop Details (from Master List)</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.75rem;">Select a stop from the master list above by clicking on it, or enter its ID directly below. Changes here update the master representation (name/direction for a unique Stop ID) and can be propagated to all matching entries in the 'Working Schedule Table'.</p>
                    <div class="form-grid" style="grid-template-columns: 1fr; gap: 0.75rem;">
                        <div>
                            <label for="editMasterStopIdInput_SM">Stop ID to Edit</label>
                            <input type="text" id="editMasterStopIdInput_SM" placeholder="Enter Stop ID or select from list above">
                        </div>
                        <div class="current-details-display">
                            <p><strong>Current Name (for this Stop ID):</strong> <span id="currentMasterEditStopNameDisplay_SM">-</span></p>
                            <p><strong>Current Direction (for this Stop ID):</strong> <span id="currentMasterEditDirectionDisplay_SM">-</span></p>
                        </div>
                        <div><label for="newMasterStopNameInput_SM">New Stop Name</label><input type="text" id="newMasterStopNameInput_SM" placeholder="Enter new stop name"></div>
                        <div><label for="newMasterStopDirectionInput_SM">New "Towards" Direction</label><input type="text" id="newMasterStopDirectionInput_SM" placeholder="Enter new direction text (e.g., Edgware Station)"></div>
                        <div style="margin-top: 0.5rem;">
                            <input type="checkbox" id="propagateStopChangesCheckbox_SM" checked style="vertical-align: middle;">
                            <label for="propagateStopChangesCheckbox_SM" style="display: inline; font-size: 0.85rem;">Propagate these name/direction changes to all entries with this Stop ID in the 'Working Schedule Table'?</label>
                        </div>
                        <button id="saveMasterStopDetailsButton_SM" class="button">Save Stop Details & Propagate</button>
                        <p id="editMasterStopStatusMessage_SM" style="min-height: 1.2em; margin-top: 0.5rem;">-</p>
                    </div>
                </div>

                <div class="section">
                    <h2>Find and Replace Stop IDs in Working Schedule</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.75rem;">This utility directly modifies the 'Working Schedule Table'. It changes all occurrences of an old Stop ID to a new Stop ID. The Stop Name and Direction for the new Stop ID will be taken from the first found instance of the 'New Stop ID' in the schedule, or from the 'Edit Stop Details' section if the 'New Stop ID' is currently being edited there. If the 'New Stop ID' is not found and not being edited, you might be prompted or it might use blank values.</p>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr auto; align-items: end; gap: 0.75rem;">
                        <div><label for="findStopIdScheduleInput_SM">Stop ID to Find in Schedule</label><input type="text" id="findStopIdScheduleInput_SM" placeholder="e.g., OLDSTOPID"></div>
                        <div><label for="replaceStopIdScheduleInput_SM">Replace with New Stop ID</label><input type="text" id="replaceStopIdScheduleInput_SM" placeholder="e.g., NEWSTOPID"></div>
                        <div style="padding-bottom:0.05rem;"><button id="findReplaceStopIdScheduleButton_SM" class="button tertiary">Execute Find & Replace</button></div>
                    </div>
                    <p id="findReplaceStatusMessage_SM" style="min-height: 1.2em; margin-top: 0.5rem;">-</p>
                </div>

                <div class="section">
                    <h2>Routes Serving a Selected Stop (from Working Schedule)</h2>
                    <div class="form-grid" style="grid-template-columns: 1fr auto; align-items: end; gap: 0.75rem;">
                        <div>
                            <label for="routesForStopSelect_SM">Select Stop ID</label>
                            <select id="routesForStopSelect_SM">
                                <option value="">-- Select Stop --</option>
                                </select>
                        </div>
                         <div style="padding-bottom:0.05rem;"><button id="refreshRoutesForStopSelectButton_SM" class="button neutral">Refresh Stop List</button></div>
                    </div>
                    <div id="routesServingStopListContainer_SM" class="subsection" style="margin-top: 0.5rem; max-height: 250px; overflow-y:auto; background-color: rgba(0,0,0,0.05); padding:0.5rem;">
                        <ul id="routesServingStopList_SM" style="list-style: none; padding: 0;">
                            </ul>
                    </div>
                    <p id="routesServingStopStatus_SM" style="min-height: 1.2em; margin-top: 0.5rem;">Select a stop to see serving routes.</p>
                </div>
            </div>

            <div id="route-diversion-tool-section" class="tool-content-section">
                <div class="section">
                    <h2>Short Term Route Diversions</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        Select a stop and then mark routes that are temporarily diverted from that stop.
                        This will display a red 'X' on the route tile on the arrivals board for that specific stop.
                    </p>
                    <div class="form-grid" style="grid-template-columns: 1.5fr; gap: 1rem;"> <div>
                            <label for="selectStopForDiversion_RD">Select Stop</label>
                            <select id="selectStopForDiversion_RD">
                                <option value="">-- Select Stop --</option>
                            </select>
                        </div>
                    </div>
                    <div id="routesForDiversionContainer_RD" class="subsection" style="margin-top: 1rem; display: none;">
                        <h3 class="subsection-title" id="routesForDiversionTitle_RD">Routes at Selected Stop</h3>
                        <div id="routesListForDiversion_RD" style="max-height: 250px; overflow-y: auto; padding: 0.5rem; background-color: rgba(0,0,0,0.05);">
                            </div>
                        <div style="margin-top: 1rem;">
                            <button id="applyDiversionsButton_RD" class="button">Apply Selected Diversions</button>
                            <button id="clearAllDiversionsForStopButton_RD" class="button neutral" style="margin-left: 0.5rem;">Clear All Diversions for This Stop</button>
                        </div>
                    </div>
                    <p id="routeDiversionStatusMessage_RD" style="min-height: 1.2em; margin-top: 0.75rem;"></p>
                </div>
            </div>
            </div> 
    </div> 

    <script type="module">
      // Firebase App initialization (NO CHANGES NEEDED HERE FOR THIS REQUEST)
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s", 
        authDomain: "omsi-c5505.firebaseapp.com",       
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app", 
        projectId: "omsi-c5505",                         
        storageBucket: "omsi-c5505.appspot.com",         
        messagingSenderId: "503595375440",               
        appId: "1:503595375440:web:356be6684b77ff5909ea55",             
        measurementId: "G-VN7X65V3F9"                 
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);

      window.firebaseOMSI = {
          database: database, auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut
      };
      console.log("Firebase Initialized for OMSI Tools.");
    </script>

    <script>
        // --- DOM Elements ---
const inputStopID = document.getElementById('inputStopID');
const inputStopName = document.getElementById('inputStopName');
const inputDirection = document.getElementById('inputDirection');
const inputLineName = document.getElementById('inputLineName');
const inputDestinationName = document.getElementById('inputDestinationName');
const inputScheduledTime = document.getElementById('inputScheduledTime');
const inputOperatingProfile = document.getElementById('inputOperatingProfile');
const selectDayOffset = document.getElementById('selectDayOffset');
const addEntryButton = document.getElementById('addEntryButton');
const updateEntryButton = document.getElementById('updateEntryButton');
const cancelEditButton = document.getElementById('cancelEditButton');
const editingEntryIndexInput = document.getElementById('editingEntryIndex');
const countFileInput = document.getElementById('count-file-input');
const fileStatusElement = document.getElementById('file-status');
const currentProfileDisplayContainer = document.getElementById('current-profile-display-container');
const currentProfileDisplayElement = document.getElementById('current-profile-display');
const currentScheduleTableBody = document.getElementById('currentScheduleTableBody');
const entryCountElement = document.getElementById('entryCount');
const filterStopIDInput = document.getElementById('filterStopID');
const filterLineNameInput = document.getElementById('filterLineName');
const filterOperatingProfileInput = document.getElementById('filterOperatingProfile');
const clearFiltersButton = document.getElementById('clearFiltersButton');
const bulkEditTargetStopIDInput = document.getElementById('bulkEditTargetStopID');
const currentBulkEditStopNameDisplay = document.getElementById('currentBulkEditStopNameDisplay');
const currentBulkEditDirectionDisplay = document.getElementById('currentBulkEditDirectionDisplay');
const bulkEditNewStopNameInput = document.getElementById('bulkEditNewStopName');
const bulkEditNewDirectionInput = document.getElementById('bulkEditNewDirection');
const bulkUpdateDetailsButton = document.getElementById('bulkUpdateDetailsButton');
const bulkEditTargetLineNameInput = document.getElementById('bulkEditTargetLineName');
const bulkEditOldDestinationInput = document.getElementById('bulkEditOldDestination');
const bulkEditNewDestinationInput = document.getElementById('bulkEditNewDestination');
const bulkUpdateRouteDestinationButton = document.getElementById('bulkUpdateRouteDestinationButton');
const selectEventRoute = document.getElementById('selectEventRoute');
const selectEventImpactStop = document.getElementById('selectEventImpactStop');
const triggerEventButton = document.getElementById('triggerEventButton');
const eventStatusMessage = document.getElementById('eventStatusMessage');
const selectStopForStatusChange = document.getElementById('selectStopForStatusChange');
const closeStopButton = document.getElementById('closeStopButton');
const reopenStopButton = document.getElementById('reopenStopButton');
const stopStatusMessage = document.getElementById('stopStatusMessage');
const stageScheduleButton = document.getElementById('stageScheduleButton');
const applyNowButton = document.getElementById('applyNowButton');
const viewArrivalsButton = document.getElementById('viewArrivalsButton');
const stagingStatusMessage = document.getElementById('stagingStatusMessage');
const selectRouteNameColour = document.getElementById('selectRouteNameColour');
const inputRouteColour = document.getElementById('inputRouteColour');
const saveRouteColourButton = document.getElementById('saveRouteColourButton');
const currentRouteColoursList = document.getElementById('currentRouteColoursList');
const noCustomColoursMessage = document.getElementById('noCustomColoursMessage');
const routeColourStatusMessage = document.getElementById('routeColourStatusMessage');
const selectStopForDeparturesView = document.getElementById('selectStopForDeparturesView');
const stopDeparturesList = document.getElementById('stopDeparturesList');
const noDeparturesForStopMessage = document.getElementById('noDeparturesForStopMessage');
const topMenuBar = document.getElementById('top-menu-bar');
const adminLoginSection = document.getElementById('auth-section');
const loginFormContainer = document.getElementById('login-form-container');
const logoutContainer = document.getElementById('logout-container');
const loginButton = document.getElementById('loginButton');
const logoutButton = document.getElementById('logoutButton');
const inputEmail = document.getElementById('inputEmail');
const inputPassword = document.getElementById('inputPassword');
const authStatus = document.getElementById('auth-status');
const loggedInUserEmailDisplay = document.getElementById('loggedInUserEmail');
const mainMenuButtons = document.querySelectorAll('#main-menu-buttons .menu-button');
const allToolContentSections = document.querySelectorAll('.tool-content-section');

const detectDuplicatesButton = document.getElementById('detectDuplicatesButton');
const duplicateEntriesResults = document.getElementById('duplicateEntriesResults');
const calculateFrequencyButton = document.getElementById('calculateFrequencyButton');
const serviceFrequencyResults = document.getElementById('serviceFrequencyResults');
const analyticsOperatingProfileSelect = document.getElementById('analyticsOperatingProfileSelect');

// DOM Elements for Stop Management Tool
const masterStopListFilterInput_SM = document.getElementById('masterStopListFilterInput_SM');
const refreshMasterStopListButton_SM = document.getElementById('refreshMasterStopListButton_SM');
const masterStopListUL_SM = document.getElementById('masterStopListUL_SM');
const masterStopListStatus_SM = document.getElementById('masterStopListStatus_SM');
const editMasterStopIdInput_SM = document.getElementById('editMasterStopIdInput_SM');
const currentMasterEditStopNameDisplay_SM = document.getElementById('currentMasterEditStopNameDisplay_SM');
const currentMasterEditDirectionDisplay_SM = document.getElementById('currentMasterEditDirectionDisplay_SM');
const newMasterStopNameInput_SM = document.getElementById('newMasterStopNameInput_SM');
const newMasterStopDirectionInput_SM = document.getElementById('newMasterStopDirectionInput_SM');
const propagateStopChangesCheckbox_SM = document.getElementById('propagateStopChangesCheckbox_SM');
const saveMasterStopDetailsButton_SM = document.getElementById('saveMasterStopDetailsButton_SM');
const editMasterStopStatusMessage_SM = document.getElementById('editMasterStopStatusMessage_SM');
const findStopIdScheduleInput_SM = document.getElementById('findStopIdScheduleInput_SM');
const replaceStopIdScheduleInput_SM = document.getElementById('replaceStopIdScheduleInput_SM');
const findReplaceStopIdScheduleButton_SM = document.getElementById('findReplaceStopIdScheduleButton_SM');
const findReplaceStatusMessage_SM = document.getElementById('findReplaceStatusMessage_SM');
const routesForStopSelect_SM = document.getElementById('routesForStopSelect_SM');
const refreshRoutesForStopSelectButton_SM = document.getElementById('refreshRoutesForStopSelectButton_SM');
const routesServingStopList_SM = document.getElementById('routesServingStopList_SM');
const routesServingStopStatus_SM = document.getElementById('routesServingStopStatus_SM');

// NEW: DOM Elements for Route Diversion Tool
const selectStopForDiversion_RD = document.getElementById('selectStopForDiversion_RD');
const routesForDiversionContainer_RD = document.getElementById('routesForDiversionContainer_RD');
const routesForDiversionTitle_RD = document.getElementById('routesForDiversionTitle_RD');
const routesListForDiversion_RD = document.getElementById('routesListForDiversion_RD');
const applyDiversionsButton_RD = document.getElementById('applyDiversionsButton_RD');
const clearAllDiversionsForStopButton_RD = document.getElementById('clearAllDiversionsForStopButton_RD');
const routeDiversionStatusMessage_RD = document.getElementById('routeDiversionStatusMessage_RD');


// --- Global State ---
let currentUser = null;
let currentWorkingSchedule = [];
let ukBankHolidaysData = { dates: [], titles: {} };
const schoolHolidayDateRanges = [ ]; // Define your school holiday ranges here if any
let activeFilters = { stopID: '', lineName: '', operatingProfile: '' };
let sortConfig = { key: null, direction: 'asc' };
let closedStopIDs = [];
let customRouteColours = {};
let effectiveRouteColourMapTools = {};
let uniqueStopsMasterList_SM = []; // For Stop Management Tool

// NEW: Global State for Route Diversions
let currentRouteDiversions = {}; // Stores { stopID: { LINE_NAME_UPPERCASE: true } }


// --- Constants ---
const LOCAL_STORAGE_ACTIVE_SECTION_KEY = 'omsiToolsActiveSection';
const FB_PATH_LIVE_SCHEDULE_DATA = '/liveSchedule/allScheduledBusData';
const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
const FB_PATH_PENDING_SCHEDULE_DATA = '/pendingSchedule/allScheduledBusData';
const FB_PATH_PENDING_UNIQUE_STOPS = '/pendingSchedule/uniqueBusStops';
const FB_PATH_PENDING_TIMESTAMP = '/pendingSchedule/uploadTimestamp';
const FB_PATH_APPSTATE_STATUS = '/appState/scheduleStatus';
const FB_PATH_APPSTATE_LAST_UPDATED = '/appState/scheduleLastUpdated';
const FB_PATH_APPSTATE_CLOSED_STOPS = '/appState/closedStopIDs';
const FB_PATH_SETTINGS_CUSTOM_COLOURS = '/settings/customRouteColours';
// NEW: Firebase Path Constant for Route Diversions
const FB_PATH_APPSTATE_ROUTE_DIVERSIONS = '/appState/routeDiversions';

const initialRouteColourMapForTools = { "1": "#DC2626", "2": "#DC2626", "3": "#DC2626", "4": "#00783A", "5": "#00783A", "6": "#00783A", "7": "#FFD300", "8": "#FFD300", "9": "#FFD300", "10": "#970006", "11": "#76D0BD", "12": "#F3A9BB", "186": "#E32017", "32":  "#00A4A7", "N5":  "#0019A8", "C11": "#FFD300","107": "#76D0BD", "221": "#93002F", "240": "#C9A0DC", "251": "#F8A960","303": "#868F98", "305": "#CF7EA2", "SL1": "#5F259F", "SL10": "#A05A2C" };
const DEFAULT_ROUTE_COLOUR_TOOLS = "#73809C";
const eventTypes = [
    { name: "Delay Route (5-15 min)", type: "DELAY_ROUTE", minDelay: 5, maxDelay: 15 },
    { name: "Delay From Stop (3-10 min)", type: "DELAY_FROM_STOP", minDelay: 3, maxDelay: 10 },
    { name: "Curtail Service", type: "CURTAIL" }
];

// --- UI Navigation & State ---
function showSection(sectionId) {
    allToolContentSections.forEach(section => {
        section.style.display = 'none';
    });
    const sectionToShow = document.getElementById(sectionId);
    if (sectionToShow) {
        sectionToShow.style.display = 'block';
        const isMainButtonSection = Array.from(mainMenuButtons).some(btn => btn.getAttribute('data-section') === sectionId);
        if (isMainButtonSection) {
            localStorage.setItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY, sectionId);
            if (sectionId === 'stop-management-tool-section') {
                populateMasterStopList_SM();
                populateRoutesForStopSelector_SM();
            }
            // NEW: Populate for Diversion Tool when shown
            if (sectionId === 'route-diversion-tool-section') {
                populateStopSelectorForDiversions_RD();
                 // displayRoutesForDiversion_RD will be called by populateStopSelectorForDiversions_RD
            }
        }
    } else {
        console.warn(`Attempted to show non-existent section: ${sectionId}`);
        localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
    }
}

function hideAllToolSections() {
    allToolContentSections.forEach(section => {
        section.style.display = 'none';
    });
}

function updateAuthUI(user) {
    currentUser = user;
    hideAllToolSections();

    if (user) {
        if (adminLoginSection) adminLoginSection.style.display = 'none';
        if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'block';
        if (topMenuBar) topMenuBar.style.display = 'block';
        if (logoutContainer) logoutContainer.style.display = 'block';
        if (loginFormContainer) loginFormContainer.style.display = 'none';
        if (authStatus) authStatus.textContent = '';
        if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = user.email;

        const lastActiveSection = localStorage.getItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        if (lastActiveSection) {
            const sectionElement = document.getElementById(lastActiveSection);
            const isKnownMenuSection = Array.from(mainMenuButtons).some(btn => btn.getAttribute('data-section') === lastActiveSection);
            if (sectionElement && isKnownMenuSection) {
                showSection(lastActiveSection);
            } else {
                localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
            }
        }
        populateAnalyticsOperatingProfileFilter();
    } else {
        if (adminLoginSection) adminLoginSection.style.display = 'block';
        if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'none';
        if (topMenuBar) topMenuBar.style.display = 'none';
        if (logoutContainer) logoutContainer.style.display = 'none';
        if (loginFormContainer) loginFormContainer.style.display = 'block';
        if (authStatus) authStatus.textContent = 'Please log in to use the tools.';
        if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = '';
        localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
    }
}

// --- Analytics Functions ---
function detectDuplicateEntries() {
    if (!currentUser || currentWorkingSchedule.length === 0) {
        duplicateEntriesResults.innerHTML = '<p>No schedule data loaded or not logged in.</p>';
        return;
    }
    const signatures = new Map();
    const duplicates = [];
    currentWorkingSchedule.forEach((entry, index) => {
        const signature = [
            (entry.stopID || "").toUpperCase(),
            (entry.lineName || "").toUpperCase(),
            entry.scheduledTime || "00:00",
            (entry.OperatingProfile || "").toLowerCase().split(',').map(s => s.trim()).sort().join(','),
            entry.DayOffset || "0",
            (entry.destinationName || "").trim()
        ].join('|');
        if (signatures.has(signature)) {
            signatures.get(signature).push(index);
        } else {
            signatures.set(signature, [index]);
        }
    });
    signatures.forEach((indices, sig) => {
        if (indices.length > 1) {
            duplicates.push(indices.map(originalIndex => ({...currentWorkingSchedule[originalIndex], originalIndex})));
        }
    });
    if (duplicates.length === 0) {
        duplicateEntriesResults.innerHTML = '<p>No duplicate entries found in the current working schedule.</p>';
    } else {
        let html = `<p>Found ${duplicates.length} set(s) of duplicate entries:</p><ul>`;
        duplicates.forEach((set, i) => {
            html += `<li class="duplicate-set"><strong>Set ${i + 1}:</strong> (Appears ${set.length} times)`;
            set.forEach(entry => {
                html += `<span class="entry-detail"> - Stop: ${entry.stopID}, Line: ${entry.lineName}, Time: ${entry.scheduledTime}, Profile: ${entry.OperatingProfile}, Dest: ${entry.destinationName} (Original Index: ${entry.originalIndex})</span>`;
            });
            html += `</li>`;
        });
        html += `</ul>`;
        duplicateEntriesResults.innerHTML = html;
    }
}

function timeToMinutes(timeStr) {
    if (!timeStr || !timeStr.includes(':')) return NaN;
    const parts = timeStr.split(':');
    return parseInt(parts[0], 10) * 60 + parseInt(parts[1], 10);
}

function populateAnalyticsOperatingProfileFilter() {
    if (!analyticsOperatingProfileSelect || currentWorkingSchedule.length === 0) {
         if(analyticsOperatingProfileSelect) analyticsOperatingProfileSelect.innerHTML = '<option value="">-- All Profiles in Schedule --</option>';
        return;
    }
    const existingValue = analyticsOperatingProfileSelect.value;
    analyticsOperatingProfileSelect.innerHTML = '<option value="">-- All Profiles in Schedule --</option>';
    const profiles = new Set();
    currentWorkingSchedule.forEach(entry => {
        if (entry.OperatingProfile) {
            entry.OperatingProfile.split(',').map(p => p.trim()).forEach(p => {
                if (p) profiles.add(p);
            });
        }
    });
    const sortedProfiles = Array.from(profiles).sort();
    sortedProfiles.forEach(p => {
        const option = document.createElement('option');
        option.value = p;
        option.textContent = p;
        analyticsOperatingProfileSelect.appendChild(option);
    });
    if (sortedProfiles.includes(existingValue)) {
        analyticsOperatingProfileSelect.value = existingValue;
    }
}

function calculateServiceFrequency() {
    if (!currentUser || currentWorkingSchedule.length === 0) {
        serviceFrequencyResults.innerHTML = '<p>No schedule data loaded or not logged in.</p>';
        return;
    }
    const selectedProfileFilter = analyticsOperatingProfileSelect.value;
    let scheduleToAnalyze = currentWorkingSchedule;

    if (selectedProfileFilter) {
        scheduleToAnalyze = currentWorkingSchedule.filter(entry => {
            return entry.OperatingProfile && entry.OperatingProfile.toLowerCase().split(',').map(s => s.trim()).includes(selectedProfileFilter.toLowerCase());
        });
        if(scheduleToAnalyze.length === 0) {
             serviceFrequencyResults.innerHTML = `<p>No entries found for Operating Profile: ${selectedProfileFilter}.</p>`;
             return;
        }
    }

    const routesData = {};
    scheduleToAnalyze.forEach(entry => {
        if (!entry.lineName || !entry.scheduledTime) return;
        if (!routesData[entry.lineName]) {
            routesData[entry.lineName] = [];
        }
        const timeInMinutes = timeToMinutes(entry.scheduledTime) + (parseInt(entry.DayOffset || "0", 10) * 1440);
        if (!isNaN(timeInMinutes)) {
             routesData[entry.lineName].push(timeInMinutes);
        }
    });

    let html = `<p>Service Frequency Analysis ${selectedProfileFilter ? `(Profile: ${selectedProfileFilter})` : '(All Profiles)'}:</p><ul>`;
    let foundAnyData = false;

    for (const lineName in routesData) {
        const times = routesData[lineName].sort((a, b) => a - b);
        if (times.length < 2) {
            html += `<li><strong>Route ${lineName}:</strong> Not enough data points (found ${times.length}).</li>`;
            continue;
        }
        foundAnyData = true;
        const headways = [];
        for (let i = 1; i < times.length; i++) {
            headways.push(times[i] - times[i-1]);
        }

        if (headways.length > 0) {
            const sum = headways.reduce((acc, val) => acc + val, 0);
            const avgHeadway = Math.round(sum / headways.length);
            const minHeadway = Math.min(...headways);
            const maxHeadway = Math.max(...headways);
            let freqDesc = `about every ${avgHeadway} mins`;
            if (minHeadway !== maxHeadway && headways.length > 1) {
                 if (Math.abs(minHeadway - avgHeadway) < 5 && Math.abs(maxHeadway - avgHeadway) < 5 && maxHeadway - minHeadway < 10) {
                    freqDesc = `about every ${minHeadway}-${maxHeadway} mins`;
                 } else {
                    freqDesc = `avg ${avgHeadway} mins (range: ${minHeadway}-${maxHeadway} mins)`;
                 }
            } else if (headways.length === 1) {
                freqDesc = `one interval of ${headways[0]} mins found`;
            }
            html += `<li><strong>Route ${lineName}:</strong> ${freqDesc}. (${headways.length} intervals analyzed)</li>`;
        } else {
            html += `<li><strong>Route ${lineName}:</strong> Only one service found, cannot calculate frequency.</li>`;
        }
    }
     if (!foundAnyData && Object.keys(routesData).length > 0) {
        html += '<li>No routes with enough services to calculate frequency for the selected criteria.</li>';
    } else if (Object.keys(routesData).length === 0) {
         html += `<li>No schedule data found matching the criteria ${selectedProfileFilter ? `for profile "${selectedProfileFilter}"` : ""}.</li>`;
    }
    html += `</ul>`;
    serviceFrequencyResults.innerHTML = html;
}


// --- Utility Functions (Date, Sorting, Parsing etc.) ---
function parseLineName(lineNameStr) { const name = String(lineNameStr || "").toUpperCase().trim(); const numericPrefixRegex = new RegExp(/^(\d+)([A-Z]*)$/); const alphaNumericRegex = new RegExp(/^([A-Z]+)(\d+)?([A-Z]*)$/); const numericPrefixMatch = name.match(numericPrefixRegex); if (numericPrefixMatch) return { type: 'numeric', number: parseInt(numericPrefixMatch[1], 10), suffix: numericPrefixMatch[2] || '', original: name }; const alphaNumericMatch = name.match(alphaNumericRegex); if (alphaNumericMatch) return { type: 'alpha', prefix: alphaNumericMatch[1], number: alphaNumericMatch[2] ? parseInt(alphaNumericMatch[2], 10) : null, suffix: alphaNumericMatch[3] || '', original: name }; return { type: 'other', original: name }; }
function compareLineNames(lineAStr, lineBStr) { const parsedA = parseLineName(lineAStr); const parsedB = parseLineName(lineBStr); if (parsedA.type === 'numeric' && parsedB.type === 'alpha') return -1; if (parsedA.type === 'alpha' && parsedB.type === 'numeric') return 1; if (parsedA.type === 'numeric' && parsedB.type === 'numeric') { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type === 'alpha' && parsedB.type === 'alpha') { const prefixCompare = parsedA.prefix.localeCompare(parsedB.prefix); if (prefixCompare !== 0) return prefixCompare; if (parsedA.number === null && parsedB.number !== null) return -1; if (parsedA.number !== null && parsedB.number === null) return 1; if (parsedA.number !== null && parsedB.number !== null) { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; } return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type !== 'other' && parsedB.type === 'other') return -1; if (parsedA.type === 'other' && parsedB.type !== 'other') return 1; return (parsedA.original || "").localeCompare(parsedB.original || ""); }
async function fetchBankHolidaysForSetup() { try { const response = await fetch('https://www.gov.uk/bank-holidays.json'); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); if (data['england-and-wales'] && data['england-and-wales'].events) { const events = data['england-and-wales'].events; ukBankHolidaysData = { dates: events.map(event => event.date), titles: events.reduce((acc, event) => { acc[event.date] = event.title; return acc; }, {}) }; } else { console.warn("Setup: Bank holiday data not in expected format."); } } catch (error) { console.error("Setup: Failed to fetch UK bank holidays:", error); if(currentProfileDisplayElement) currentProfileDisplayElement.textContent = "Current Auto Profile: (Bank Hol. check failed)"; } updateCurrentProfileDisplayOnSetup(); }
function isSchoolHolidayPeriodForSetup(dateObject) { if (!schoolHolidayDateRanges || schoolHolidayDateRanges.length === 0) return false; const checkTime = dateObject.getTime(); for (const range of schoolHolidayDateRanges) { try { const startTime = new Date(range.start + "T00:00:00").getTime(); const endTime = new Date(range.end + "T23:59:59").getTime(); if (checkTime >= startTime && checkTime <= endTime) return true; } catch (e) { console.error("Invalid date in schoolHolidayDateRanges (setup):", range, e); } } return false; }
function updateCurrentProfileDisplayOnSetup() { const now = new Date(); const dayOfWeek = now.getDay(); const todayDateString = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`; let profileDisplayText = ""; let isBankHol = false; let serviceTypeDisplay = ""; if (ukBankHolidaysData && ukBankHolidaysData.dates.includes(todayDateString)) { const holidayTitle = ukBankHolidaysData.titles[todayDateString] || "Bank Holiday"; isBankHol = true; if (holidayTitle.toLowerCase().includes("good friday")) { profileDisplayText = "Good Friday"; serviceTypeDisplay = "(Sat Service)"; } else { profileDisplayText = holidayTitle; serviceTypeDisplay = "(Sun Service)"; } } let dayName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][dayOfWeek]; if (!isBankHol) { profileDisplayText = dayName; const isSchHol = isSchoolHolidayPeriodForSetup(now); if (isSchHol) { profileDisplayText += " (School Hol)"; } else if (dayOfWeek >= 1 && dayOfWeek <= 5) { profileDisplayText += " (School Term)"; } } else { profileDisplayText += ` ${serviceTypeDisplay} - Observed on a ${dayName}`; const isSchHolOnBH = isSchoolHolidayPeriodForSetup(now); if (isSchHolOnBH) { profileDisplayText += " (School Hol)"; } } if (currentProfileDisplayElement) { currentProfileDisplayElement.textContent = `Today's Auto Profile: ${profileDisplayText}`; } }
function applyFiltersAndSort(schedule) { let dataToDisplay = [...schedule]; if (activeFilters.stopID) dataToDisplay = dataToDisplay.filter(e=>(e.stopID||"").toLowerCase().includes(activeFilters.stopID.toLowerCase())); if (activeFilters.lineName) dataToDisplay = dataToDisplay.filter(e=>(e.lineName||"").toLowerCase().includes(activeFilters.lineName.toLowerCase())); if (activeFilters.operatingProfile) dataToDisplay = dataToDisplay.filter(e=>(e.OperatingProfile||"").toLowerCase().includes(activeFilters.operatingProfile.toLowerCase())); if (sortConfig.key) { dataToDisplay.sort((a,b) => { let valA=a[sortConfig.key]||"", valB=b[sortConfig.key]||""; if(sortConfig.key==='scheduledTime'){valA=(String(valA)||"").replace(':','');valB=(String(valB)||"").replace(':','');} else if(sortConfig.key==='lineName')return compareLineNames(valA,valB)*(sortConfig.direction==='asc'?1:-1); else if(sortConfig.key==='DayOffset'){valA=parseInt(valA||"0");valB=parseInt(valB||"0");} else if(typeof valA==='string'&&typeof valB==='string'){valA=valA.toLowerCase();valB=valB.toLowerCase();} if(valA<valB)return sortConfig.direction==='asc'?-1:1; if(valA>valB)return sortConfig.direction==='asc'?1:-1; return 0; }); } else { dataToDisplay.sort((a,b)=>{ const lineCmp = compareLineNames(a.lineName, b.lineName); if (lineCmp !== 0) return lineCmp; const timeA = (a.scheduledTime || "").replace(':', ''); const timeB = (b.scheduledTime || "").replace(':', ''); const timeCmp = timeA.localeCompare(timeB); if (timeCmp !== 0) return timeCmp; const stopIDCmp = (a.stopID || "").localeCompare(b.stopID || ""); return stopIDCmp; }); } return dataToDisplay; }
function updateSortArrows() { document.querySelectorAll('#currentScheduleTableContainer th[data-sortkey]').forEach(th=>{const s=th.querySelector('.sort-arrow');if(s)s.textContent='';if(th.dataset.sortkey===sortConfig.key&&s)s.textContent=sortConfig.direction==='asc'?' ▲':' ▼';});}

// --- Form & Data Handling Functions ---
function resetForm() { inputStopID.value=''; inputStopName.value=''; inputDirection.value=''; inputLineName.value=''; inputDestinationName.value=''; inputScheduledTime.value=''; inputOperatingProfile.value=''; selectDayOffset.value='0'; editingEntryIndexInput.value='-1'; addEntryButton.style.display='inline-block'; updateEntryButton.style.display='none'; cancelEditButton.style.display='none'; inputStopID.focus(); }
function loadEntryForEdit(idx) { const dataToRender = applyFiltersAndSort(currentWorkingSchedule); if (idx < 0 || idx >= dataToRender.length) return; const entryToLoad = dataToRender[idx]; const actualEditIndex = currentWorkingSchedule.findIndex(item => item.internalId === entryToLoad.internalId); if(actualEditIndex < 0) return; const entry = currentWorkingSchedule[actualEditIndex]; inputStopID.value=entry.stopID||''; inputStopName.value=entry.stopName||''; inputDirection.value=entry.direction||''; inputLineName.value=entry.lineName||''; inputDestinationName.value=entry.destinationName||''; inputScheduledTime.value=entry.scheduledTime||''; inputOperatingProfile.value=entry.OperatingProfile||''; selectDayOffset.value=entry.DayOffset||'0'; editingEntryIndexInput.value = actualEditIndex; addEntryButton.style.display='none'; updateEntryButton.style.display='inline-block'; cancelEditButton.style.display='inline-block'; inputStopID.focus(); }
function handleInputStopIDChange() { const currentStopId = inputStopID.value.trim().toUpperCase(); const editingIdx = parseInt(editingEntryIndexInput.value); if (currentStopId && (editingIdx === -1 || (currentWorkingSchedule[editingIdx] && currentWorkingSchedule[editingIdx].stopID.toUpperCase() !== currentStopId))) { let existingEntry = null; for (let i = currentWorkingSchedule.length - 1; i >= 0; i--) { if (currentWorkingSchedule[i].stopID.toUpperCase() === currentStopId) { existingEntry = currentWorkingSchedule[i]; break; } } if (existingEntry) { if (!inputStopName.value) inputStopName.value = existingEntry.stopName; if (!inputDirection.value) inputDirection.value = existingEntry.direction; } } }
function handleAddOrUpdateEntry() { const schedTime=inputScheduledTime.value; if(!schedTime.match(/^([01]\d|2[0-3]):([0-5]\d)$/)){ alert("Scheduled Time must be in HH:MM format (e.g., 09:30 or 23:15)."); inputScheduledTime.focus();return; } if(!inputStopID.value.trim()||!inputLineName.value.trim()||!inputOperatingProfile.value.trim()){ alert("Stop ID, Line Name, and Operating Profile are required.");return; } const entry={ stopID:inputStopID.value.trim().toUpperCase(), stopName:inputStopName.value.trim(), direction:inputDirection.value.trim(), lineName:inputLineName.value.trim().toUpperCase(), destinationName:inputDestinationName.value.trim(), scheduledTime:schedTime, OperatingProfile:inputOperatingProfile.value.trim(), DayOffset:selectDayOffset.value, internalId:'' }; const editIdx=parseInt(editingEntryIndexInput.value); if(editIdx > -1 && editIdx < currentWorkingSchedule.length){ entry.internalId=currentWorkingSchedule[editIdx].internalId; currentWorkingSchedule[editIdx]=entry; } else { entry.internalId=`manual_${Date.now()}_${Math.random().toString(36).substr(2,5)}`; currentWorkingSchedule.push(entry); } sortConfig = { key: null, direction: 'asc' }; renderScheduleTable(); resetForm(); }
function handleDeleteEntry(originalIndexPassed) { if(originalIndexPassed <0 || originalIndexPassed >=currentWorkingSchedule.length) { console.warn("Delete: Invalid index", originalIndexPassed); return; } if(confirm(`Delete ${currentWorkingSchedule[originalIndexPassed].lineName} at ${currentWorkingSchedule[originalIndexPassed].scheduledTime} from working schedule?`)){ currentWorkingSchedule.splice(originalIndexPassed,1); renderScheduleTable(); } }
function isValidScheduleDataFromText(jsonData) { if (!jsonData || jsonData.length === 0) return false; const requiredColumns = ['StopID', 'StopName', 'Direction', 'LineName', 'DestinationName', 'ScheduledTime', 'OperatingProfile']; const firstEntry = jsonData[0]; const allColumnsPresent = requiredColumns.every(col => col in firstEntry); if (!allColumnsPresent) { const missingCols = requiredColumns.filter(col => !(col in firstEntry)); alert(`Uploaded .COUNT file is missing expected headers: ${missingCols.join(', ')}.\nExpected: StopID, StopName, Direction, LineName, DestinationName, ScheduledTime, OperatingProfile. Case matters.`); return false; } return true; }
function handleCountFileUpload(event) { const file = event.target.files[0]; if (file) { if (fileStatusElement) fileStatusElement.textContent = `Processing ${file.name}...`; setTimeout(() => { const reader = new FileReader(); reader.onload = function(e) { try { const fileContent = e.target.result; const lines = fileContent.split(/\r?\n/); if (lines.length < 2) { alert("File empty or no data (header + one entry needed)."); if (fileStatusElement) fileStatusElement.textContent = "File processing failed."; if (countFileInput) countFileInput.value = ""; return; } const headers = lines[0].split('\t').map(h => h.trim()); const jsonData = []; for (let i = 1; i < lines.length; i++) { const line = lines[i].trim(); if (line === "") continue; const values = line.split('\t').map(v => v.trim()); if (values.length < headers.length && values.every(v => v === "")) continue; if (values.length < headers.length && values.length > 0) { for(let k = values.length; k < headers.length; k++) { values.push(''); } } let entry = {}; headers.forEach((header, index) => { entry[header] = values[index] !== undefined ? values[index] : ""; }); jsonData.push(entry); } if (isValidScheduleDataFromText(jsonData)) { if (currentWorkingSchedule.length > 0 && !confirm("Replace current working schedule with this file?")) { if (fileStatusElement) fileStatusElement.textContent = "Upload cancelled."; if (countFileInput) countFileInput.value = ""; return; } currentWorkingSchedule = jsonData.map((row, index) => { let scheduledTime = String(row.ScheduledTime || "").trim(); if (scheduledTime.match(/^\d{1,2}:\d{2}(:\d{2})?$/)) { const parts = scheduledTime.split(':'); scheduledTime = `${String(parts[0]).padStart(2, '0')}:${String(parts[1]).padStart(2, '0')}`; } else if (scheduledTime.length === 4 && !scheduledTime.includes(':')) { scheduledTime = `${scheduledTime.substring(0,2)}:${scheduledTime.substring(2,4)}`; } else if (scheduledTime.length === 3 && !scheduledTime.includes(':')) { scheduledTime = `0${scheduledTime.substring(0,1)}:${scheduledTime.substring(1,3)}`; } return { internalId: `${String(row.StopID||'s').trim().toUpperCase()}_${String(row.LineName||'l').trim().toUpperCase()}_${scheduledTime.replace(':','')}_${index}_countfile`, stopID: String(row.StopID || "").trim().toUpperCase(), stopName: String(row.StopName || "").trim(), direction: String(row.Direction || "").trim(), lineName: String(row.LineName || "").trim().toUpperCase(), destinationName: String(row.DestinationName || "").trim(), scheduledTime: scheduledTime, OperatingProfile: String(row.OperatingProfile || "").trim(), DayOffset: String(row.DayOffset || "0").trim() }; }); sortConfig = { key: null, direction: 'asc' }; renderScheduleTable(); if (fileStatusElement) fileStatusElement.textContent = `${file.name} processed. ${currentWorkingSchedule.length} entries loaded.`; } else { if (fileStatusElement) fileStatusElement.textContent = "File processing failed: Invalid structure/headers."; } } catch (error) { console.error("Error processing .COUNT file:", error); alert(`Error: ${error.message}.`); if (fileStatusElement) fileStatusElement.textContent = "Error loading file."; } if (countFileInput) countFileInput.value = ""; }; reader.onerror = () => { alert("Could not read file."); if (fileStatusElement) fileStatusElement.textContent = "Error reading file."; if (countFileInput) countFileInput.value = ""; }; reader.readAsText(file); }, 50); } }
function handleBulkUpdateStopDetails() { if (!currentUser) { alert("Please log in."); return; } const targetStopID = bulkEditTargetStopIDInput.value.trim().toUpperCase(); const newStopName = bulkEditNewStopNameInput.value.trim(); const newDirection = bulkEditNewDirectionInput.value.trim(); if (!targetStopID) { alert("Target Stop ID required."); bulkEditTargetStopIDInput.focus(); return; } if (!newStopName && !newDirection) { alert("New Stop Name or Direction required."); return; } let updatedCount = 0; currentWorkingSchedule.forEach(entry => { if (entry.stopID && entry.stopID.toUpperCase() === targetStopID) { let entryChanged = false; if (newStopName) { entry.stopName = newStopName; entryChanged = true; } if (newDirection) { entry.direction = newDirection; entryChanged = true; } if (entryChanged) updatedCount++; } }); if (updatedCount > 0) { renderScheduleTable(); alert(`${updatedCount} entries for Stop ID "${targetStopID}" updated.`); bulkEditNewStopNameInput.value = ''; bulkEditNewDirectionInput.value = ''; displayCurrentDetailsForBulkStopEdit(); } else { alert(`No entries found for Stop ID "${targetStopID}".`); } }
function handleBulkUpdateRouteDestination() { if (!currentUser) { alert("Please log in."); return; } const targetLineName = bulkEditTargetLineNameInput.value.trim().toUpperCase(); const oldDestination = bulkEditOldDestinationInput.value.trim(); const newDestination = bulkEditNewDestinationInput.value.trim(); if (!targetLineName) { alert("Target Line Name required."); bulkEditTargetLineNameInput.focus(); return; } if (!newDestination) { alert("New Destination Name required."); bulkEditNewDestinationInput.focus(); return; } let updatedCount = 0; currentWorkingSchedule.forEach(entry => { if (entry.lineName && entry.lineName.toUpperCase() === targetLineName) { if (oldDestination) { if (entry.destinationName && entry.destinationName.toLowerCase() === oldDestination.toLowerCase()) { entry.destinationName = newDestination; updatedCount++; } } else { entry.destinationName = newDestination; updatedCount++; } } }); if (updatedCount > 0) { renderScheduleTable(); alert(`${updatedCount} entries for Line "${targetLineName}" updated to "${newDestination}".`); } else { alert(`No entries for Line "${targetLineName}"` + (oldDestination ? ` with Old Destination "${oldDestination}"` : "") + " found."); } }
function displayCurrentDetailsForBulkStopEdit() { const targetStopID = bulkEditTargetStopIDInput.value.trim().toUpperCase(); if (!targetStopID) { currentBulkEditStopNameDisplay.textContent = "-"; currentBulkEditDirectionDisplay.textContent = "-"; return; } const existingEntry = currentWorkingSchedule.find(entry => entry.stopID && entry.stopID.toUpperCase() === targetStopID); if (existingEntry) { currentBulkEditStopNameDisplay.textContent = existingEntry.stopName || "N/A"; currentBulkEditDirectionDisplay.textContent = existingEntry.direction || "N/A"; } else { currentBulkEditStopNameDisplay.textContent = "- Not found -"; currentBulkEditDirectionDisplay.textContent = "- Not found -"; } }

// --- Firebase Data Interaction ---
function handleStageSchedule() { if (!currentUser) { alert("Log in to stage."); return; } if (currentWorkingSchedule.length === 0 && !confirm("Working schedule empty. Stage empty schedule?")) { stagingStatusMessage.textContent = "Staging empty schedule cancelled."; stagingStatusMessage.style.color = "#e74c3c"; return; } let dataToStage = JSON.parse(JSON.stringify(currentWorkingSchedule)); dataToStage.sort((a, b) => { const lineCmp = compareLineNames(a.lineName, b.lineName); if (lineCmp !== 0) return lineCmp; const timeA = (a.scheduledTime || "").replace(':', ''); const timeB = (b.scheduledTime || "").replace(':', ''); const timeCmp = timeA.localeCompare(timeB); if (timeCmp !== 0) return timeCmp; return (a.stopID || "").localeCompare(b.stopID || ""); }); const finalScheduleData = dataToStage.map((entry, index) => ({ ...entry, internalId: entry.internalId || `${entry.stopID.toUpperCase()}_${entry.lineName.toUpperCase()}_${(entry.scheduledTime||"").replace(':','')}_${index}_staged` })); const stopsMap = new Map(); finalScheduleData.forEach(row => { if (row.stopID && !stopsMap.has(row.stopID)) { stopsMap.set(row.stopID, { stopID: row.stopID, stopName: row.stopName, direction: row.direction }); } }); const finalUniqueStops = Array.from(stopsMap.values()).sort((a,b)=>{ const nC=(a.stopName||"").localeCompare(b.stopName||""); return nC!==0?nC:(a.direction||"").localeCompare(b.direction||""); }); if (window.firebaseOMSI) { const { database, dbUpdate, dbRef } = window.firebaseOMSI; const updates = {}; updates[FB_PATH_PENDING_SCHEDULE_DATA] = finalScheduleData; updates[FB_PATH_PENDING_UNIQUE_STOPS] = finalUniqueStops; updates[FB_PATH_PENDING_TIMESTAMP] = new Date().toISOString(); updates[FB_PATH_APPSTATE_STATUS] = 'update_staged'; dbUpdate(dbRef(database), updates) .then(() => { alert("Schedule STAGED to Firebase."); updateStagingStatusDisplay(); }) .catch((e) => { console.error("FB Staging Error: ", e); alert("FB Staging Error. Check console."); if(stagingStatusMessage) { stagingStatusMessage.textContent = "FB Staging Error."; stagingStatusMessage.style.color = "#e74c3c"; } }); } else { alert("Firebase not available."); } }
function handleApplyNow() { if (!currentUser) { alert("Log in to apply."); return; } if (window.firebaseOMSI) { const { database, dbGet, dbUpdate, dbRef, dbChild } = window.firebaseOMSI; dbGet(dbChild(dbRef(database), '/pendingSchedule')) .then((snapshot) => { if (snapshot.exists()) { const pendingData = snapshot.val(); if (!confirm("Apply Firebase staged schedule LIVE NOW?")) { if (stagingStatusMessage) { stagingStatusMessage.textContent = "Apply cancelled."; stagingStatusMessage.style.color = "#e74c3c"; } return; } let liveAllScheduledBusData = Array.isArray(pendingData.allScheduledBusData) ? pendingData.allScheduledBusData.filter(item => item != null) : (typeof pendingData.allScheduledBusData === 'object' && pendingData.allScheduledBusData !== null ? Object.values(pendingData.allScheduledBusData).filter(item => item != null) : []); let liveUniqueBusStops = Array.isArray(pendingData.uniqueBusStops) ? pendingData.uniqueBusStops.filter(item => item != null) : (typeof pendingData.uniqueBusStops === 'object' && pendingData.uniqueBusStops !== null ? Object.values(pendingData.uniqueBusStops).filter(item => item != null) : []); let hasInvalidKey = false; function check(obj, path) { if (typeof obj !== 'object' || obj === null) return; for (const key in obj) { if (/[.#$/\[\]]/.test(key)) { console.error(`INVALID KEY at ${path}: key='${key}'`); hasInvalidKey = true; } if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) { check(obj[key], `${path}.${key}`); } } } liveAllScheduledBusData.forEach((item, i) => { if (typeof item !== 'object' || item === null) { hasInvalidKey = true; return; } check(item, `schedule[${i}]`); }); liveUniqueBusStops.forEach((item, i) => { if (typeof item !== 'object' || item === null) { hasInvalidKey = true; return; } check(item, `stops[${i}]`); }); if (hasInvalidKey) { alert("Invalid keys in data. Cannot apply. Check console."); return; } const liveUpdates = {}; liveUpdates[FB_PATH_LIVE_SCHEDULE_DATA] = liveAllScheduledBusData; liveUpdates[FB_PATH_LIVE_UNIQUE_STOPS] = liveUniqueBusStops; dbUpdate(dbRef(database), liveUpdates) .then(() => { const appUpdates = {}; appUpdates[FB_PATH_APPSTATE_LAST_UPDATED] = new Date().toISOString(); appUpdates[FB_PATH_APPSTATE_STATUS] = 'idle'; appUpdates['/pendingSchedule'] = null; return dbUpdate(dbRef(database), appUpdates); }) .then(() => { alert("Staged schedule APPLIED LIVE!"); updateStagingStatusDisplay(); }) .catch(e => { console.error("FB Apply Error: ", e); alert("FB Apply Error. Check console: " + e.message); }); } else { alert("No Firebase staged schedule to apply."); if (stagingStatusMessage) { stagingStatusMessage.textContent = "No FB staged schedule."; stagingStatusMessage.style.color = "#e74c3c"; } } }).catch(e => { console.error("FB Fetch Pending Error: ", e); alert("FB Fetch Pending Error. Check console: " + e.message); }); } else { alert("Firebase not available."); } }
async function loadInitialData() {
    console.log("Tools: Loading initial data from Firebase...");
    let msg = "Loading data...";
    if (fileStatusElement) fileStatusElement.textContent = msg;
    currentWorkingSchedule = [];
    closedStopIDs = [];
    customRouteColours = {};
    currentRouteDiversions = {}; // Initialize diversions

    if (!window.firebaseOMSI) {
        msg = "Firebase not connected.";
    } else {
        const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
        try {
            const liveSnap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_SCHEDULE_DATA));
            if (liveSnap.exists() && Array.isArray(liveSnap.val())) {
                currentWorkingSchedule = liveSnap.val().map((e, i) => ({ ...e, internalId: e.internalId || `${(e.stopID||'s')}_${(e.lineName||'l')}_${(e.scheduledTime||"").replace(':','')}_${i}_fb` }));
            }
            const closedSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_CLOSED_STOPS));
            if (closedSnap.exists()) {
                const fbClosed = closedSnap.val();
                for (const id in fbClosed) { if (fbClosed[id] === true) closedStopIDs.push(id); }
            }
            const coloursSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_CUSTOM_COLOURS));
            if (coloursSnap.exists()) customRouteColours = coloursSnap.val();

            // Load diversions
            await loadRouteDiversionsFromFirebase();

            msg = `Data loaded from Firebase. ${currentWorkingSchedule.length} entries.`;
        } catch (e) {
            console.error("FB Load Error:", e);
            msg = "FB Load Error. Check console.";
        }
    }
    if (fileStatusElement) fileStatusElement.textContent = msg;
    loadAndApplyCustomRouteColoursForTools();
    renderScheduleTable(); // This will also trigger populating selectors for new tool if visible
    updateStagingStatusDisplay();
    populateStopStatusSelector();
    populateAnalyticsOperatingProfileFilter();
}
async function updateStagingStatusDisplay() { let pTime = null; let lTime = null; let fbStatus = "Checking..."; if (window.firebaseOMSI) { const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const pSnap = await dbGet(dbChild(dbRef(database), FB_PATH_PENDING_TIMESTAMP)); if (pSnap.exists()) pTime = pSnap.val(); const lSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_LAST_UPDATED)); if (lSnap.exists()) lTime = lSnap.val(); const sSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_STATUS)); const currentFbSt = sSnap.exists() ? sSnap.val() : 'unknown'; fbStatus = `Firebase status: ${currentFbSt}.`; applyNowButton.disabled = !(currentFbSt === 'update_staged' && pTime); } catch (e) { fbStatus = "FB Status Error."; console.error(fbStatus, e); applyNowButton.disabled = true;} } else { fbStatus = "Firebase not available."; applyNowButton.disabled = true;} let msg = ""; if (pTime && applyNowButton.disabled === false) { msg = `STAGED on: ${new Date(pTime).toLocaleString()}.<br>Ready to 'Apply Staged Live NOW'.`; if(stagingStatusMessage) stagingStatusMessage.style.color = "#2ecc71"; } else { msg = "No schedule staged. Changes can be staged."; if(stagingStatusMessage) stagingStatusMessage.style.color = "#f1c40f"; } msg += lTime ? `<br>LIVE schedule last updated: ${new Date(lTime).toLocaleString()}` : "<br>No LIVE schedule set yet."; msg += `<br><small>(${fbStatus})</small>`; if(stagingStatusMessage) stagingStatusMessage.innerHTML = msg; }
function saveClosedStops() { if (!currentUser) return; if (window.firebaseOMSI) { const { database, dbSet, dbRef } = window.firebaseOMSI; const fbClosed = {}; closedStopIDs.forEach(id => fbClosed[id] = true); dbSet(dbRef(database, FB_PATH_APPSTATE_CLOSED_STOPS), fbClosed) .then(() => dbSet(dbRef(database, FB_PATH_APPSTATE_LAST_UPDATED), new Date().toISOString())) .catch(e => console.error("FB Save Closed Stops Error: ", e)); } }
function saveCustomRouteColours() { if (!currentUser) return; if (window.firebaseOMSI) { const { database, dbSet, dbRef } = window.firebaseOMSI; dbSet(dbRef(database, FB_PATH_SETTINGS_CUSTOM_COLOURS), customRouteColours) .then(() => dbSet(dbRef(database, FB_PATH_APPSTATE_LAST_UPDATED), new Date().toISOString())) .catch(e => console.error("FB Save Colours Error: ", e)); } if (routeColourStatusMessage) { routeColourStatusMessage.textContent = 'Custom colours saved.'; setTimeout(() => { if(routeColourStatusMessage) routeColourStatusMessage.textContent = ''; }, 3000); } loadAndApplyCustomRouteColoursForTools(); if(selectStopForDeparturesView.value) displayDeparturesForSelectedStop(); renderCustomRouteColours(); }

// --- UI Population & Rendering ---
function populateRouteSelectorForEvents() { if (!selectEventRoute) return; const currentVal = selectEventRoute.value; selectEventRoute.innerHTML = '<option value="">-- Select Route --</option>'; const uniqueLines = [...new Set(currentWorkingSchedule.map(e => e.lineName))].sort(compareLineNames); uniqueLines.forEach(ln => { if (ln) { const opt = document.createElement('option'); opt.value = ln; opt.textContent = ln; selectEventRoute.appendChild(opt); } }); selectEventRoute.value = uniqueLines.includes(currentVal) ? currentVal : ""; populateImpactStopSelector(); }
function populateImpactStopSelector() { if (!selectEventImpactStop || !selectEventRoute) return; const selRoute = selectEventRoute.value; const currentVal = selectEventImpactStop.value; selectEventImpactStop.innerHTML = '<option value="">-- Route Wide --</option>'; if (selRoute) { const stops = currentWorkingSchedule.filter(e => e.lineName === selRoute).map(e => ({ id: e.stopID, name: e.stopName, time: e.scheduledTime })).sort((a,b) => (a.time||"").localeCompare(b.time||"")); const uniqueStops = []; const seen=new Set(); stops.forEach(s => { if (s.id && !seen.has(s.id)) { uniqueStops.push(s); seen.add(s.id); }}); uniqueStops.forEach(s => { const opt = document.createElement('option'); opt.value = s.id; opt.textContent = `${s.id} - ${s.name || 'Unknown'}`; selectEventImpactStop.appendChild(opt); }); selectEventImpactStop.value = seen.has(currentVal) ? currentVal : ""; } }
async function populateStopStatusSelector() { if (!selectStopForStatusChange || !window.firebaseOMSI) return; const currentVal = selectStopForStatusChange.value; selectStopForStatusChange.innerHTML = '<option value="">-- Select Stop --</option>'; const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const snap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_UNIQUE_STOPS)); let stops = []; if (snap.exists()) stops = Array.isArray(snap.val()) ? snap.val() : Object.values(snap.val()); stops.sort((a,b) => (a.stopName||"").localeCompare(b.stopName||"")); stops.forEach(s => { if(!s || !s.stopID) return; const opt = document.createElement('option'); opt.value = s.stopID; const isClosed = closedStopIDs.includes(s.stopID); opt.textContent = `${s.stopName||s.stopID} (${s.stopID})${isClosed?' (Closed)':''}`; selectStopForStatusChange.appendChild(opt); }); selectStopForStatusChange.value = currentVal && stops.find(s => s && s.stopID === currentVal) ? currentVal : ""; } catch (e) {console.error("Error populating stop status selector", e)} }
function handleStopStatusChange(action) { if (!currentUser) return; const stopID = selectStopForStatusChange.value; if (!stopID) { stopStatusMessage.textContent = "Select a stop."; return; } const idx = closedStopIDs.indexOf(stopID); const name = selectStopForStatusChange.options[selectStopForStatusChange.selectedIndex].text.split(' (')[0]; if (action === 'close') { if (idx === -1) { closedStopIDs.push(stopID); stopStatusMessage.textContent = `Stop '${name}' closed.`; } else { stopStatusMessage.textContent = `Stop '${name}' already closed.`; } } else if (action === 'reopen') { if (idx !== -1) { closedStopIDs.splice(idx, 1); stopStatusMessage.textContent = `Stop '${name}' reopened.`; } else { stopStatusMessage.textContent = `Stop '${name}' not closed.`; } } saveClosedStops(); populateStopStatusSelector(); }
function applyRandomEvent() { if (!currentUser) return; const selRoute = selectEventRoute.value; const impactStop = selectEventImpactStop.value; if (!selRoute) { eventStatusMessage.textContent = "Select route."; return; } const eventPool = [...eventTypes].filter(e => e.type !== "DELAY_FROM_STOP" || impactStop); if (eventPool.length === 0) { eventStatusMessage.textContent = "No applicable events."; return; } const choice = eventPool[Math.floor(Math.random() * eventPool.length)]; eventStatusMessage.textContent = `Applying: ${choice.name} to ${selRoute}...`; let applied = false; let details = `Event: ${choice.name}. `; switch (choice.type) { case "DELAY_ROUTE": case "DELAY_FROM_STOP": const delay = Math.floor(Math.random()*(choice.maxDelay-choice.minDelay+1))+choice.minDelay; let apply = (choice.type === "DELAY_ROUTE"); let count = 0; currentWorkingSchedule.forEach(e => { if (e.lineName === selRoute) { if (!apply && choice.type === "DELAY_FROM_STOP" && e.stopID === impactStop) apply = true; if (apply && e.scheduledTime) { const parts = e.scheduledTime.split(':'); if (parts.length===2) { let h=parseInt(parts[0]), m=parseInt(parts[1]);m+=delay;h+=Math.floor(m/60);m%=60;h%=24;e.scheduledTime=`${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;e.eventNotes=(e.eventNotes||"")+` Delayed +${delay}m.`;count++;applied=true;}} }}); details += `${count} entries for ${selRoute} delayed by ${delay} mins.`; if(!applied&&choice.type==="DELAY_FROM_STOP"&&impactStop) details+=" (Impact stop not found/no subsequent services)."; break; case "CURTAIL": const entries = currentWorkingSchedule.filter(e=>e.lineName===selRoute); if(entries.length>0){const uniqueStops = [], seen=new Set(); [...entries].sort((a,b)=>(a.scheduledTime||"").localeCompare(b.scheduledTime||"")).forEach(e=>{if(!seen.has(e.stopID)){uniqueStops.push({id:e.stopID,name:e.stopName});seen.add(e.stopID);}}); if(uniqueStops.length>1){let newDest,curtailIdx=-1;if(impactStop){curtailIdx=uniqueStops.findIndex(s=>s.id===impactStop);if(curtailIdx>=0&&curtailIdx<uniqueStops.length-1)newDest=uniqueStops[curtailIdx];else if(curtailIdx===uniqueStops.length-1&&uniqueStops.length>1){newDest=uniqueStops[curtailIdx-1];curtailIdx--;}}if(!newDest&&uniqueStops.length>1){curtailIdx=Math.floor(Math.random()*(uniqueStops.length-1));newDest=uniqueStops[curtailIdx];}if(newDest){let rem=0,upd=0;currentWorkingSchedule=currentWorkingSchedule.filter(e=>{if(e.lineName===selRoute){const idx=uniqueStops.findIndex(s=>s.id===e.stopID);if(idx>curtailIdx){rem++;applied=true;return false;}}return true;});currentWorkingSchedule.forEach(e=>{if(e.lineName===selRoute&&e.destinationName!==newDest.name){e.destinationName=newDest.name;e.eventNotes=(e.eventNotes||"")+` Curtailed to ${newDest.name}.`;upd++;applied=true;}});if(rem>0||upd>0)details+=`${selRoute} services terminate at ${newDest.name}. ${rem} stops removed, ${upd} destinations updated.`;else details+="No changes from curtailment.";}else details+="Cannot determine curtailment point.";}else details+="Route too short to curtail.";} break;} if(applied)renderScheduleTable(); eventStatusMessage.textContent = details + (applied?" Changes in 'Working Schedule'.":" No changes applied."); populateRouteSelectorForEvents(); if(selectEventRoute)selectEventRoute.value=""; populateImpactStopSelector();}
function loadAndApplyCustomRouteColoursForTools() { effectiveRouteColourMapTools = { ...initialRouteColourMapForTools, ...customRouteColours }; }
function renderCustomRouteColours() { if (!currentRouteColoursList || !noCustomColoursMessage) return; currentRouteColoursList.innerHTML = ''; const routes = [...new Set(currentWorkingSchedule.map(e => e.lineName))].filter(n => n && n.trim() !== "").sort(compareLineNames); if (routes.length === 0) { noCustomColoursMessage.textContent = 'No routes in working schedule.'; noCustomColoursMessage.style.display = 'block'; return; } noCustomColoursMessage.style.display = 'none'; routes.forEach(rName => { const upName = rName.toUpperCase(); const isCustom = customRouteColours.hasOwnProperty(upName); const color = isCustom ? customRouteColours[upName] : DEFAULT_ROUTE_COLOUR_TOOLS; const li = document.createElement('li'); const box = document.createElement('span'); box.className = 'colour-preview-box'; box.style.backgroundColor = color; const info = document.createElement('span'); info.className = 'route-info'; info.innerHTML = `Route: ${rName} - Colour: ${color.toUpperCase()}${isCustom?"":` <small style="opacity:0.7;">(Default)</small>`}`; const actions = document.createElement('div'); actions.style.marginLeft = 'auto'; if (isCustom) { const btn = document.createElement('button'); btn.textContent = 'Remove'; btn.classList.add('button','small-action','secondary'); btn.onclick=()=>handleRemoveRouteColour(upName); actions.appendChild(btn); } li.appendChild(box); li.appendChild(info); li.appendChild(actions); currentRouteColoursList.appendChild(li); }); }
function populateRouteSelectorForColours() { if (!selectRouteNameColour) return; const currentVal = selectRouteNameColour.value; selectRouteNameColour.innerHTML = '<option value="">-- Select Route --</option>'; const lines = [...new Set(currentWorkingSchedule.map(e => e.lineName))].filter(n => n && n.trim() !== "").sort(compareLineNames); lines.forEach(ln => { const opt = document.createElement('option'); opt.value = ln; opt.textContent = ln; selectRouteNameColour.appendChild(opt); }); if (lines.includes(currentVal)) selectRouteNameColour.value = currentVal; selectRouteNameColour.dispatchEvent(new Event('change')); }
function handleSaveRouteColour() { if (!currentUser) return; if (!selectRouteNameColour || !inputRouteColour || !routeColourStatusMessage) return; const rName = selectRouteNameColour.value; const color = inputRouteColour.value; if (!rName) { routeColourStatusMessage.textContent = 'Select route name.'; routeColourStatusMessage.style.color = '#e74c3c'; return; } if (!color.match(/^#[0-9a-fA-F]{6}$/)) { routeColourStatusMessage.textContent = 'Invalid hex colour (e.g., #RRGGBB).'; routeColourStatusMessage.style.color = '#e74c3c'; return; } customRouteColours[rName.toUpperCase()] = color.toUpperCase(); saveCustomRouteColours(); }
function handleRemoveRouteColour(key) { if (!currentUser) return; if (customRouteColours.hasOwnProperty(key) && confirm(`Remove custom colour for route ${key}?`)) { delete customRouteColours[key]; saveCustomRouteColours(); if (selectRouteNameColour.value.toUpperCase() === key) inputRouteColour.value = DEFAULT_ROUTE_COLOUR_TOOLS; } }
function getRouteTileColourForTools(lineName) { const upName = String(lineName||"").toUpperCase(); if(effectiveRouteColourMapTools[upName]) return effectiveRouteColourMapTools[upName]; if(upName.startsWith("N")) return effectiveRouteColourMapTools["N5"]||DEFAULT_ROUTE_COLOUR_TOOLS; if(upName.startsWith("SL")) return effectiveRouteColourMapTools["SL1"]||DEFAULT_ROUTE_COLOUR_TOOLS; return DEFAULT_ROUTE_COLOUR_TOOLS;}
function getTextColourForBackgroundTools(hex) { if(!hex||hex.length<7)return'#FFFFFF'; const r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16); return((0.299*r+0.587*g+0.114*b)/255)>0.5?'#000000':'#FFFFFF';}
function getDaySortOrder(profile) { if(!profile)return 99;const p=profile.toUpperCase().split(',').map(s=>s.trim());if(p.some(s=>s.startsWith("MO")&&!s.startsWith("MO-FR")))return 1;if(p.some(s=>s.startsWith("TU")))return 2;if(p.some(s=>s.startsWith("WE")))return 3;if(p.some(s=>s.startsWith("TH")))return 4;if(p.some(s=>s.startsWith("FR")&&!s.startsWith("MO-FR")))return 5;if(p.some(s=>s.startsWith("MF")||s.startsWith("MO-FR")))return 6;if(p.some(s=>s.startsWith("SA")))return 7;if(p.some(s=>s.startsWith("SU")))return 8;if(p.includes("GOODFRIDAY"))return 10;if(p.includes("BANKHOLIDAY"))return 11; return 99;}
function populateStopSelectorForDeparturesView() { if (!selectStopForDeparturesView) return; const currentVal = selectStopForDeparturesView.value; selectStopForDeparturesView.innerHTML = '<option value="">-- Select Stop --</option>'; if (currentWorkingSchedule.length === 0) { displayDeparturesForSelectedStop(); return; } const stopsMap = new Map(); currentWorkingSchedule.forEach(e => { if (e.stopID && !stopsMap.has(e.stopID)) stopsMap.set(e.stopID, { stopID: e.stopID, stopName: e.stopName || e.stopID }); }); const sorted = Array.from(stopsMap.values()).sort((a,b)=>(a.stopName.toLowerCase()).localeCompare(b.stopName.toLowerCase())); sorted.forEach(s => { const opt = document.createElement('option'); opt.value = s.stopID; opt.textContent = `${s.stopName} (${s.stopID})`; selectStopForDeparturesView.appendChild(opt); }); if (stopsMap.has(currentVal)) selectStopForDeparturesView.value = currentVal; displayDeparturesForSelectedStop(); }
function displayDeparturesForSelectedStop() { if (!selectStopForDeparturesView || !stopDeparturesList || !noDeparturesForStopMessage) return; const selStopID = selectStopForDeparturesView.value; stopDeparturesList.innerHTML = ''; if (!selStopID) { noDeparturesForStopMessage.textContent = 'Select stop to view.'; noDeparturesForStopMessage.style.display = 'block'; return; } const deps = currentWorkingSchedule.filter(e => e.stopID === selStopID).sort((a,b) => {const dayA=getDaySortOrder(a.OperatingProfile),dayB=getDaySortOrder(b.OperatingProfile);if(dayA!==dayB)return dayA-dayB;const timeA=(a.scheduledTime||"9999").replace(':',''),timeB=(b.scheduledTime||"9999").replace(':','');if(timeA!==timeB)return timeA.localeCompare(timeB);const lineComp=compareLineNames(a.lineName,b.lineName);if(lineComp!==0)return lineComp;return(a.OperatingProfile||"").localeCompare(b.OperatingProfile||"");}); if(deps.length===0){noDeparturesForStopMessage.textContent='No departures for this stop.';noDeparturesForStopMessage.style.display='block';}else{noDeparturesForStopMessage.style.display='none';deps.forEach(d=>{const li=document.createElement('li');const tile=document.createElement('span');tile.className='route-tile-tools-list';tile.textContent=d.lineName||'N/A';const bg=getRouteTileColourForTools(d.lineName);tile.style.backgroundColor=bg;tile.style.color=getTextColourForBackgroundTools(bg);const span=document.createElement('span');span.innerHTML=` to ${d.destinationName||'Unknown'} <strong style="margin-left:0.5em;">at ${d.scheduledTime||'N/A'}</strong> <small style="opacity:0.7;margin-left:0.75em;">(Profile: ${d.OperatingProfile||'N/A'})</small>${d.DayOffset&&d.DayOffset!=="0"?`<small style="opacity:0.7;margin-left:0.3em;color:#FFD700;">(+${d.DayOffset}d)</small>`:''}`;li.appendChild(tile);li.appendChild(span);stopDeparturesList.appendChild(li);});}}
function renderScheduleTable() {
    if (!currentScheduleTableBody || !entryCountElement) return;
    const data = applyFiltersAndSort(currentWorkingSchedule);
    currentScheduleTableBody.innerHTML = '';
    entryCountElement.textContent = data.length + (currentWorkingSchedule.length !== data.length ? ` of ${currentWorkingSchedule.length} total` : '');
    if (data.length === 0) {
        const r=currentScheduleTableBody.insertRow(),c=r.insertCell();c.colSpan=9;c.textContent=activeFilters.stopID||activeFilters.lineName||activeFilters.operatingProfile?"No entries match filters.":"Schedule empty.";c.style.textAlign="center";c.style.padding="1rem";c.style.fontStyle="italic";
    } else {
        data.forEach(e => {
            const origIdx = currentWorkingSchedule.findIndex(item => item.internalId === e.internalId);
            const r=currentScheduleTableBody.insertRow();
            r.insertCell().textContent=e.stopID||'';
            r.insertCell().textContent=e.stopName||'';
            r.insertCell().textContent=e.direction||'';
            r.insertCell().textContent=e.lineName||'';
            r.insertCell().textContent=e.destinationName||'';
            r.insertCell().textContent=e.scheduledTime||'';
            r.insertCell().textContent=e.OperatingProfile||'';
            r.insertCell().textContent=e.DayOffset||'0';
            const act=r.insertCell();
            const edBtn=document.createElement('button');edBtn.textContent="Edit";edBtn.classList.add('button','small-action','tertiary');edBtn.onclick=()=>loadEntryForEdit(origIdx);act.appendChild(edBtn);
            const delBtn=document.createElement('button');delBtn.textContent="Del";delBtn.classList.add('button','small-action','secondary');delBtn.onclick=()=>handleDeleteEntry(origIdx);act.appendChild(delBtn);
        });
    }
    updateSortArrows();
    populateRouteSelectorForEvents();
    populateStopStatusSelector();
    populateRouteSelectorForColours();
    populateStopSelectorForDeparturesView();
    renderCustomRouteColours();
    populateAnalyticsOperatingProfileFilter();
    if (document.getElementById('stop-management-tool-section').style.display === 'block') {
        populateMasterStopList_SM();
        populateRoutesForStopSelector_SM();
    }
    // NEW: Refresh diversion tool selectors if section is active
    if (document.getElementById('route-diversion-tool-section').style.display === 'block') {
        populateStopSelectorForDiversions_RD();
    }
}

// --- Stop Management Tool Functions ---
function getUniqueStopsFromSchedule() {
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) return [];
    const stopsMap = new Map();
    for (let i = currentWorkingSchedule.length - 1; i >= 0; i--) {
        const entry = currentWorkingSchedule[i];
        if (entry.stopID && !stopsMap.has(entry.stopID.toUpperCase())) { // Ensure StopID is consistently cased
            stopsMap.set(entry.stopID.toUpperCase(), {
                stopID: entry.stopID.toUpperCase(),
                stopName: entry.stopName || "Unknown Name",
                direction: entry.direction || "No Direction"
            });
        }
    }
    return Array.from(stopsMap.values()).sort((a, b) => (a.stopName.toLowerCase()).localeCompare(b.stopName.toLowerCase()));
}

function populateMasterStopList_SM() {
    if (!masterStopListUL_SM || !masterStopListStatus_SM) return;
    uniqueStopsMasterList_SM = getUniqueStopsFromSchedule();
    const filterText = masterStopListFilterInput_SM.value.toLowerCase();
    masterStopListUL_SM.innerHTML = '';
    let displayedCount = 0;

    if (uniqueStopsMasterList_SM.length === 0) {
        masterStopListStatus_SM.textContent = 'No unique stops found in the current working schedule.';
        return;
    }

    uniqueStopsMasterList_SM.forEach(stop => {
        if (!stop || !stop.stopID) return;
        const matchesFilter = !filterText ||
                            (stop.stopID && stop.stopID.toLowerCase().includes(filterText)) ||
                            (stop.stopName && stop.stopName.toLowerCase().includes(filterText)) ||
                            (stop.direction && stop.direction.toLowerCase().includes(filterText));

        if (matchesFilter) {
            displayedCount++;
            const li = document.createElement('li');
            li.innerHTML = `<span class="stop-id-master">${stop.stopID}</span><br>
                            <span class="stop-name-master">${stop.stopName}</span><br>
                            <span class="stop-direction-master">Towards: ${stop.direction}</span>`;
            li.dataset.stopid = stop.stopID;
            li.dataset.stopname = stop.stopName;
            li.dataset.direction = stop.direction;
            li.addEventListener('click', handleMasterStopSelection_SM);
            masterStopListUL_SM.appendChild(li);
        }
    });

    if (displayedCount === 0 && uniqueStopsMasterList_SM.length > 0) {
        masterStopListStatus_SM.textContent = 'No stops match your filter.';
    } else {
        masterStopListStatus_SM.textContent = `Showing ${displayedCount} of ${uniqueStopsMasterList_SM.length} unique stops.`;
    }
}

function handleMasterStopSelection_SM(event) {
    const li = event.currentTarget;
    editMasterStopIdInput_SM.value = li.dataset.stopid;
    newMasterStopNameInput_SM.value = li.dataset.stopname;
    newMasterStopDirectionInput_SM.value = li.dataset.direction;
    displayCurrentDetailsForMasterStopEdit_SM();
    newMasterStopNameInput_SM.focus();
}

function displayCurrentDetailsForMasterStopEdit_SM() {
    const stopID = editMasterStopIdInput_SM.value.trim().toUpperCase();
    if (!stopID) {
        currentMasterEditStopNameDisplay_SM.textContent = "-";
        currentMasterEditDirectionDisplay_SM.textContent = "-";
        return;
    }
    let stopDetails = uniqueStopsMasterList_SM.find(s => s.stopID === stopID);
    if (!stopDetails) {
         const firstEntry = currentWorkingSchedule.find(e => e.stopID.toUpperCase() === stopID);
         if (firstEntry) {
            stopDetails = { stopID: firstEntry.stopID.toUpperCase(), stopName: firstEntry.stopName, direction: firstEntry.direction };
         }
    }

    if (stopDetails) {
        currentMasterEditStopNameDisplay_SM.textContent = stopDetails.stopName || "N/A";
        currentMasterEditDirectionDisplay_SM.textContent = stopDetails.direction || "N/A";
    } else {
        currentMasterEditStopNameDisplay_SM.textContent = "- Not found -";
        currentMasterEditDirectionDisplay_SM.textContent = "- Not found -";
    }
}

function handleSaveMasterStopDetails_SM() {
    if (!currentUser) { alert("Please log in."); return; }
    const targetStopID = editMasterStopIdInput_SM.value.trim().toUpperCase();
    const newStopName = newMasterStopNameInput_SM.value.trim();
    const newDirection = newMasterStopDirectionInput_SM.value.trim();

    if (!targetStopID) {
        editMasterStopStatusMessage_SM.textContent = "Target Stop ID is required.";
        editMasterStopStatusMessage_SM.style.color = '#e74c3c';
        return;
    }
    if (!newStopName && !newDirection) {
        editMasterStopStatusMessage_SM.textContent = "At least a New Stop Name or New Direction is required.";
         editMasterStopStatusMessage_SM.style.color = '#e74c3c';
        return;
    }

    let updatedCount = 0;
    if (propagateStopChangesCheckbox_SM.checked) {
        currentWorkingSchedule.forEach(entry => {
            if (entry.stopID && entry.stopID.toUpperCase() === targetStopID) {
                let entryChanged = false;
                if (newStopName && entry.stopName !== newStopName) {
                    entry.stopName = newStopName;
                    entryChanged = true;
                }
                if (newDirection && entry.direction !== newDirection) {
                    entry.direction = newDirection;
                    entryChanged = true;
                }
                if (entryChanged) updatedCount++;
            }
        });
    }

    if (updatedCount > 0) {
        renderScheduleTable();
        editMasterStopStatusMessage_SM.textContent = `Propagated changes to ${updatedCount} schedule entries for Stop ID "${targetStopID}". Master list will update on refresh.`;
        editMasterStopStatusMessage_SM.style.color = '#2ecc71';
    } else if (propagateStopChangesCheckbox_SM.checked) {
        editMasterStopStatusMessage_SM.textContent = `No schedule entries found or no changes needed for Stop ID "${targetStopID}".`;
        editMasterStopStatusMessage_SM.style.color = '#f1c40f';
    } else {
         editMasterStopStatusMessage_SM.textContent = `Stop details noted. Propagation to schedule was not selected. Refresh master list to see if it reflects (if stop ID was already present).`;
         editMasterStopStatusMessage_SM.style.color = '#3498db';
    }
    populateMasterStopList_SM();
}

function handleFindReplaceStopIdInSchedule_SM() {
    if (!currentUser) { alert("Please log in."); return; }
    const findStopID = findStopIdScheduleInput_SM.value.trim().toUpperCase();
    const replaceStopID = replaceStopIdScheduleInput_SM.value.trim().toUpperCase();

    if (!findStopID || !replaceStopID) {
        findReplaceStatusMessage_SM.textContent = "Both 'Stop ID to Find' and 'Replace with New Stop ID' are required.";
        findReplaceStatusMessage_SM.style.color = '#e74c3c';
        return;
    }
    if (findStopID === replaceStopID) {
        findReplaceStatusMessage_SM.textContent = "Find and Replace Stop IDs cannot be the same.";
        findReplaceStatusMessage_SM.style.color = '#f1c40f';
        return;
    }

    if (!confirm(`Are you sure you want to replace ALL occurrences of Stop ID "${findStopID}" with "${replaceStopID}" in the working schedule? This action cannot be undone easily.`)) {
        findReplaceStatusMessage_SM.textContent = "Find and replace operation cancelled.";
        findReplaceStatusMessage_SM.style.color = '#7f8c8d';
        return;
    }

    let replacedCount = 0;
    let newNameForReplaced = "";
    let newDirectionForReplaced = "";

    if (editMasterStopIdInput_SM.value.toUpperCase() === replaceStopID && (newMasterStopNameInput_SM.value.trim() || newMasterStopDirectionInput_SM.value.trim())) {
        newNameForReplaced = newMasterStopNameInput_SM.value.trim();
        newDirectionForReplaced = newMasterStopDirectionInput_SM.value.trim();
    } else {
        const existingNewStopEntry = currentWorkingSchedule.find(e => e.stopID.toUpperCase() === replaceStopID);
        if (existingNewStopEntry) {
            newNameForReplaced = existingNewStopEntry.stopName;
            newDirectionForReplaced = existingNewStopEntry.direction;
        }
    }

    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && entry.stopID.toUpperCase() === findStopID) {
            entry.stopID = replaceStopID;
            entry.stopName = newNameForReplaced || entry.stopName;
            entry.direction = newDirectionForReplaced || entry.direction;
            replacedCount++;
        }
    });

    if (replacedCount > 0) {
        renderScheduleTable();
        findReplaceStatusMessage_SM.textContent = `Replaced ${replacedCount} occurrences of "${findStopID}" with "${replaceStopID}". Name/Direction for "${replaceStopID}" set to: "${newNameForReplaced}" / "${newDirectionForReplaced}".`;
        findReplaceStatusMessage_SM.style.color = '#2ecc71';
        findStopIdScheduleInput_SM.value = '';
        replaceStopIdScheduleInput_SM.value = '';
    } else {
        findReplaceStatusMessage_SM.textContent = `No occurrences of Stop ID "${findStopID}" found in the working schedule.`;
        findReplaceStatusMessage_SM.style.color = '#f1c40f';
    }
}

function populateRoutesForStopSelector_SM() {
    if (!routesForStopSelect_SM) return;
    const currentVal = routesForStopSelect_SM.value;
    routesForStopSelect_SM.innerHTML = '<option value="">-- Select Stop --</option>';
    const uniqueStops = getUniqueStopsFromSchedule();

    if (uniqueStops.length === 0) {
        routesServingStopStatus_SM.textContent = 'No stops in working schedule to select from.';
        displayRoutesServingSelectedStop_SM();
        return;
    }

    uniqueStops.forEach(stop => {
        const opt = document.createElement('option');
        opt.value = stop.stopID;
        opt.textContent = `${stop.stopName} (${stop.stopID})`;
        routesForStopSelect_SM.appendChild(opt);
    });

    if (uniqueStops.find(s => s.stopID === currentVal)) {
        routesForStopSelect_SM.value = currentVal;
    }
    displayRoutesServingSelectedStop_SM();
}

function displayRoutesServingSelectedStop_SM() {
    if (!routesForStopSelect_SM || !routesServingStopList_SM || !routesServingStopStatus_SM) return;
    const selectedStopID = routesForStopSelect_SM.value;
    routesServingStopList_SM.innerHTML = '';

    if (!selectedStopID) {
        routesServingStopStatus_SM.textContent = 'Select a stop to view its serving routes.';
        return;
    }

    const servingRoutes = new Set();
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID.toUpperCase() === selectedStopID && entry.lineName) {
            servingRoutes.add(entry.lineName);
        }
    });

    const sortedRoutes = Array.from(servingRoutes).sort(compareLineNames);

    if (sortedRoutes.length === 0) {
        routesServingStopStatus_SM.textContent = `No routes found serving stop ${selectedStopID} in the current schedule.`;
    } else {
        routesServingStopStatus_SM.textContent = `Routes serving stop ${selectedStopID}:`;
        sortedRoutes.forEach(lineName => {
            const li = document.createElement('li');
            const tile = document.createElement('span');
            tile.className = 'route-tile-tools-list';
            tile.textContent = lineName;
            const bgColor = getRouteTileColourForTools(lineName);
            tile.style.backgroundColor = bgColor;
            tile.style.color = getTextColourForBackgroundTools(bgColor);
            li.appendChild(tile);
            const lineText = document.createTextNode(" " + lineName);
            li.appendChild(lineText);
            routesServingStopList_SM.appendChild(li);
        });
    }
}

// --- NEW: Route Diversion Tool Functions ---
function populateStopSelectorForDiversions_RD() {
    if (!selectStopForDiversion_RD) return;
    const currentVal = selectStopForDiversion_RD.value;
    selectStopForDiversion_RD.innerHTML = '<option value="">-- Select Stop --</option>';

    const uniqueStops = getUniqueStopsFromSchedule();

    if (uniqueStops.length === 0 && routesForDiversionContainer_RD) {
        routesForDiversionContainer_RD.style.display = 'none';
        if (routeDiversionStatusMessage_RD) routeDiversionStatusMessage_RD.textContent = 'No stops available in the working schedule.';
        return;
    }

    uniqueStops.sort((a, b) => (a.stopName || "").localeCompare(b.stopName || ""));
    uniqueStops.forEach(stop => {
        if (!stop || !stop.stopID) return;
        const opt = document.createElement('option');
        opt.value = stop.stopID.toUpperCase(); // Ensure consistent casing
        opt.textContent = `${stop.stopName || stop.stopID} (${stop.stopID.toUpperCase()})`;
        selectStopForDiversion_RD.appendChild(opt);
    });

    if (uniqueStops.find(s => s.stopID.toUpperCase() === currentVal)) {
        selectStopForDiversion_RD.value = currentVal;
    }
    displayRoutesForDiversion_RD(); // Call this to populate routes for the (newly) selected stop
}

function displayRoutesForDiversion_RD() {
    if (!currentUser || !selectStopForDiversion_RD || !routesListForDiversion_RD || !routesForDiversionContainer_RD) return;
    const selectedStopID = selectStopForDiversion_RD.value; // This will be uppercase due to populate function
    routesListForDiversion_RD.innerHTML = '';

    if (!selectedStopID) {
        routesForDiversionContainer_RD.style.display = 'none';
        if (routeDiversionStatusMessage_RD) routeDiversionStatusMessage_RD.textContent = 'Select a stop to see its routes.';
        return;
    }

    routesForDiversionContainer_RD.style.display = 'block';
    if (routesForDiversionTitle_RD) routesForDiversionTitle_RD.textContent = `Routes at ${selectStopForDiversion_RD.options[selectStopForDiversion_RD.selectedIndex].text}`;

    const routesServingStop = new Set();
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID.toUpperCase() === selectedStopID && entry.lineName) {
            routesServingStop.add(entry.lineName.toUpperCase()); // Store and check uppercase
        }
    });

    const sortedRoutes = Array.from(routesServingStop).sort(compareLineNames);

    if (sortedRoutes.length === 0) {
        routesListForDiversion_RD.innerHTML = '<p style="padding: 0.5rem; font-style: italic;">No routes found serving this stop in the schedule.</p>';
        if (routeDiversionStatusMessage_RD) routeDiversionStatusMessage_RD.textContent = 'No routes to manage for this stop.';
        return;
    }

    sortedRoutes.forEach(lineName => { // lineName is already uppercase here
        const div = document.createElement('div');
        // div.style.padding = '0.3rem 0'; // Style already in CSS
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `diversion_${selectedStopID}_${lineName}`;
        checkbox.value = lineName; // Value is uppercase
        // checkbox.style.marginRight = '0.5rem'; // Style already in CSS

        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.textContent = lineName;

        if (currentRouteDiversions[selectedStopID] && currentRouteDiversions[selectedStopID][lineName]) {
            checkbox.checked = true;
            label.classList.add('diverted');
        }

        div.appendChild(checkbox);
        div.appendChild(label);
        routesListForDiversion_RD.appendChild(div);
    });
    if (routeDiversionStatusMessage_RD) routeDiversionStatusMessage_RD.textContent = 'Manage diversions using the checkboxes.';
}

function handleApplyDiversions_RD() {
    if (!currentUser || !selectStopForDiversion_RD) return;
    const selectedStopID = selectStopForDiversion_RD.value; // Uppercase
    if (!selectedStopID) {
        if (routeDiversionStatusMessage_RD) {
            routeDiversionStatusMessage_RD.textContent = 'Please select a stop first.';
            routeDiversionStatusMessage_RD.style.color = '#e74c3c';
        }
        return;
    }

    const { database, dbUpdate, dbRef } = window.firebaseOMSI;
    // No need to initialize currentRouteDiversions[selectedStopID] here if it might not exist,
    // dbUpdate handles path creation.

    const checkboxes = routesListForDiversion_RD.querySelectorAll('input[type="checkbox"]');
    let changesMade = false;
    const updates = {};

    checkboxes.forEach(cb => {
        const lineName = cb.value; // Already uppercase
        const firebasePathForRoute = `${FB_PATH_APPSTATE_ROUTE_DIVERSIONS}/${selectedStopID}/${lineName}`;

        const isCurrentlyDivertedInFbState = currentRouteDiversions[selectedStopID] && currentRouteDiversions[selectedStopID][lineName];

        if (cb.checked) {
            if (!isCurrentlyDivertedInFbState) { // Only update if state changes
                updates[firebasePathForRoute] = true;
                changesMade = true;
            }
        } else {
            if (isCurrentlyDivertedInFbState) { // Only update if state changes
                updates[firebasePathForRoute] = null;
                changesMade = true;
            }
        }
    });
    
    // After processing all checkboxes, update local state based on what will be written
    if (!currentRouteDiversions[selectedStopID] && Object.values(updates).some(v => v === true)) {
         currentRouteDiversions[selectedStopID] = {}; // Initialize if we are adding routes to it
    }

    for (const path in updates) {
        const pathParts = path.split('/');
        const stop = pathParts[pathParts.length - 2];
        const route = pathParts[pathParts.length - 1];
        if (updates[path] === true) {
             if (!currentRouteDiversions[stop]) currentRouteDiversions[stop] = {};
            currentRouteDiversions[stop][route] = true;
        } else if (updates[path] === null && currentRouteDiversions[stop]) {
            delete currentRouteDiversions[stop][route];
            if (Object.keys(currentRouteDiversions[stop]).length === 0) {
                delete currentRouteDiversions[stop];
            }
        }
    }


    if (changesMade) {
        dbUpdate(dbRef(database), updates)
            .then(() => {
                if (routeDiversionStatusMessage_RD) {
                    routeDiversionStatusMessage_RD.textContent = 'Diversions updated successfully for stop ' + selectedStopID + '.';
                    routeDiversionStatusMessage_RD.style.color = '#2ecc71';
                }
                displayRoutesForDiversion_RD(); // Refresh the display with new state
            })
            .catch(error => {
                console.error("Error saving route diversions:", error);
                if (routeDiversionStatusMessage_RD) {
                    routeDiversionStatusMessage_RD.textContent = 'Error saving diversions. Check console.';
                    routeDiversionStatusMessage_RD.style.color = '#e74c3c';
                }
            });
    } else {
        if (routeDiversionStatusMessage_RD) {
            routeDiversionStatusMessage_RD.textContent = 'No changes to apply.';
            routeDiversionStatusMessage_RD.style.color = '#f1c40f';
        }
    }
}

function handleClearAllDiversionsForStop_RD() {
    if (!currentUser || !selectStopForDiversion_RD) return;
    const selectedStopID = selectStopForDiversion_RD.value; // Uppercase
    if (!selectedStopID) {
        if (routeDiversionStatusMessage_RD) {
            routeDiversionStatusMessage_RD.textContent = 'Please select a stop first.';
            routeDiversionStatusMessage_RD.style.color = '#e74c3c';
        }
        return;
    }

    if (!currentRouteDiversions[selectedStopID] || Object.keys(currentRouteDiversions[selectedStopID]).length === 0) {
        if (routeDiversionStatusMessage_RD) {
            routeDiversionStatusMessage_RD.textContent = 'No diversions active for this stop to clear.';
            routeDiversionStatusMessage_RD.style.color = '#f1c40f';
        }
        return;
    }

    if (confirm(`Are you sure you want to clear ALL route diversions for stop ${selectedStopID}?`)) {
        const { database, dbSet, dbRef } = window.firebaseOMSI;
        
        dbSet(dbRef(database, `${FB_PATH_APPSTATE_ROUTE_DIVERSIONS}/${selectedStopID}`), null)
            .then(() => {
                delete currentRouteDiversions[selectedStopID]; // Update local state
                if (routeDiversionStatusMessage_RD) {
                    routeDiversionStatusMessage_RD.textContent = 'All diversions cleared for stop ' + selectedStopID + '.';
                    routeDiversionStatusMessage_RD.style.color = '#2ecc71';
                }
                displayRoutesForDiversion_RD();
            })
            .catch(error => {
                console.error("Error clearing diversions for stop:", error);
                if (routeDiversionStatusMessage_RD) {
                    routeDiversionStatusMessage_RD.textContent = 'Error clearing diversions. Check console.';
                    routeDiversionStatusMessage_RD.style.color = '#e74c3c';
                }
            });
    }
}

async function loadRouteDiversionsFromFirebase() {
    if (!window.firebaseOMSI || !currentUser) {
        currentRouteDiversions = {}; // Reset if not logged in or Firebase not ready
        return;
    }
    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
    try {
        const snapshot = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_ROUTE_DIVERSIONS));
        if (snapshot.exists()) {
            currentRouteDiversions = snapshot.val();
        } else {
            currentRouteDiversions = {};
        }
        console.log("Tools: Route diversions loaded:", currentRouteDiversions);
        if (selectStopForDiversion_RD && selectStopForDiversion_RD.value && document.getElementById('route-diversion-tool-section').style.display === 'block') {
            displayRoutesForDiversion_RD();
        }
    } catch (error) {
        console.error("Error loading route diversions:", error);
        currentRouteDiversions = {};
    }
}


// --- Event Listeners & Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    if (adminLoginSection) adminLoginSection.style.display = 'block';
    if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'none';
    if (topMenuBar) topMenuBar.style.display = 'none';
    hideAllToolSections();

    const allMainMenuButtons = document.querySelectorAll('#main-menu-buttons .menu-button');
    allMainMenuButtons.forEach(button => {
        button.addEventListener('click', () => {
            const sectionId = button.getAttribute('data-section');
            if (currentUser) showSection(sectionId);
        });
    });

    if(detectDuplicatesButton) detectDuplicatesButton.addEventListener('click', detectDuplicateEntries);
    if(calculateFrequencyButton) calculateFrequencyButton.addEventListener('click', calculateServiceFrequency);

    if (window.firebaseOMSI && window.firebaseOMSI.auth) {
        const { auth, authOnAuthStateChanged, authSignInWithEmailAndPassword, authSignOut, database, dbOnValue, dbRef } = window.firebaseOMSI;
        authOnAuthStateChanged(auth, (user) => {
            updateAuthUI(user);
            if (user) {
                console.log("Firebase: User is signed in.");
                fetchBankHolidaysForSetup();
                loadInitialData(); // This now includes loadRouteDiversionsFromFirebase

                // Setup listener for route diversions after user logs in
                const routeDiversionsRefTools = dbRef(database, FB_PATH_APPSTATE_ROUTE_DIVERSIONS);
                dbOnValue(routeDiversionsRefTools, (snapshot) => {
                    console.log("Firebase Tools: Route diversions data updated via listener.");
                    currentRouteDiversions = snapshot.exists() ? snapshot.val() : {};
                    if (selectStopForDiversion_RD && selectStopForDiversion_RD.value && document.getElementById('route-diversion-tool-section').style.display === 'block') {
                        displayRoutesForDiversion_RD();
                    }
                });

            } else {
                console.log("Firebase: User is signed out.");
                currentWorkingSchedule = [];
                currentRouteDiversions = {}; // Clear diversions on logout
                renderScheduleTable();
                updateStagingStatusDisplay();
                if(analyticsOperatingProfileSelect) analyticsOperatingProfileSelect.innerHTML = '<option value="">-- All Profiles in Schedule --</option>';
            }
        });
        if (loginButton) {
            loginButton.addEventListener('click', (event) => {
                event.preventDefault();
                const email = inputEmail.value;
                const password = inputPassword.value;
                if(authStatus) authStatus.textContent = 'Logging in...';
                authSignInWithEmailAndPassword(auth, email, password)
                    .catch((error) => {
                        console.error("Login Error:", error);
                        if(authStatus) authStatus.textContent = `Login Error: ${error.message}`;
                    });
            });
        }
        if (logoutButton) {
            logoutButton.addEventListener('click', () => {
                localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
                authSignOut(auth).catch((e) => console.error("Sign-out Error:", e));
            });
        }
    } else {
        console.warn("Firebase Auth not available.");
        updateAuthUI(null);
    }

    if (stageScheduleButton) stageScheduleButton.addEventListener('click', handleStageSchedule);
    if (applyNowButton) applyNowButton.addEventListener('click', handleApplyNow);
    if (viewArrivalsButton) viewArrivalsButton.addEventListener('click', () => { window.location.href = "omsi_arrivals.html"; });
    if (addEntryButton) addEntryButton.addEventListener('click', handleAddOrUpdateEntry);
    if (updateEntryButton) updateEntryButton.addEventListener('click', handleAddOrUpdateEntry);
    if (cancelEditButton) cancelEditButton.addEventListener('click', resetForm);
    if (countFileInput) countFileInput.addEventListener('change', handleCountFileUpload);
    if(filterStopIDInput) filterStopIDInput.addEventListener('input', () => { activeFilters.stopID = filterStopIDInput.value; renderScheduleTable(); });
    if(filterLineNameInput) filterLineNameInput.addEventListener('input', () => { activeFilters.lineName = filterLineNameInput.value; renderScheduleTable(); });
    if(filterOperatingProfileInput) filterOperatingProfileInput.addEventListener('input', () => { activeFilters.operatingProfile = filterOperatingProfileInput.value; renderScheduleTable(); });
    if(clearFiltersButton) clearFiltersButton.addEventListener('click', () => { filterStopIDInput.value = ''; activeFilters.stopID = ''; filterLineNameInput.value = ''; activeFilters.lineName = ''; filterOperatingProfileInput.value = ''; activeFilters.operatingProfile = ''; sortConfig = { key: null, direction: 'asc' }; renderScheduleTable(); });
    document.querySelectorAll('#currentScheduleTableContainer th[data-sortkey]').forEach(headerCell => { headerCell.addEventListener('click', () => { const sortKey = headerCell.dataset.sortkey; if (sortConfig.key === sortKey) { sortConfig.direction = sortConfig.direction === 'asc' ? 'desc' : 'asc'; } else { sortConfig.key = sortKey; sortConfig.direction = 'asc'; } renderScheduleTable(); }); });
    if(inputStopID) { inputStopID.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); handleInputStopIDChange(); }); inputStopID.addEventListener('blur', handleInputStopIDChange); }
    if(inputLineName) { inputLineName.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); }); }
    if(bulkEditTargetStopIDInput) { bulkEditTargetStopIDInput.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); displayCurrentDetailsForBulkStopEdit(); }); bulkEditTargetStopIDInput.addEventListener('blur', displayCurrentDetailsForBulkStopEdit); }
    if(bulkEditTargetLineNameInput) { bulkEditTargetLineNameInput.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); }); }
    if(bulkUpdateDetailsButton) bulkUpdateDetailsButton.addEventListener('click', handleBulkUpdateStopDetails);
    if(bulkUpdateRouteDestinationButton) bulkUpdateRouteDestinationButton.addEventListener('click', handleBulkUpdateRouteDestination);
    if (selectEventRoute) selectEventRoute.addEventListener('change', populateImpactStopSelector);
    if (triggerEventButton) triggerEventButton.addEventListener('click', applyRandomEvent);
    if (closeStopButton) closeStopButton.addEventListener('click', () => handleStopStatusChange('close'));
    if (reopenStopButton) reopenStopButton.addEventListener('click', () => handleStopStatusChange('reopen'));
    if (saveRouteColourButton) saveRouteColourButton.addEventListener('click', handleSaveRouteColour);
    if (selectRouteNameColour) { selectRouteNameColour.addEventListener('change', () => { const selectedRoute = selectRouteNameColour.value; if (selectedRoute && customRouteColours[selectedRoute.toUpperCase()]) { inputRouteColour.value = customRouteColours[selectedRoute.toUpperCase()]; } else { inputRouteColour.value = DEFAULT_ROUTE_COLOUR_TOOLS; } }); }
    if (selectStopForDeparturesView) { selectStopForDeparturesView.addEventListener('change', displayDeparturesForSelectedStop); }

    // Event Listeners for Stop Management Tool
    if (refreshMasterStopListButton_SM) refreshMasterStopListButton_SM.addEventListener('click', populateMasterStopList_SM);
    if (masterStopListFilterInput_SM) masterStopListFilterInput_SM.addEventListener('input', populateMasterStopList_SM);
    if (editMasterStopIdInput_SM) {
        editMasterStopIdInput_SM.addEventListener('input', (e) => {
            e.target.value = e.target.value.toUpperCase();
            displayCurrentDetailsForMasterStopEdit_SM();
        });
        editMasterStopIdInput_SM.addEventListener('blur', displayCurrentDetailsForMasterStopEdit_SM);
    }
    if (saveMasterStopDetailsButton_SM) saveMasterStopDetailsButton_SM.addEventListener('click', handleSaveMasterStopDetails_SM);
    if (findStopIdScheduleInput_SM) findStopIdScheduleInput_SM.addEventListener('input', (e) => e.target.value = e.target.value.toUpperCase());
    if (replaceStopIdScheduleInput_SM) replaceStopIdScheduleInput_SM.addEventListener('input', (e) => e.target.value = e.target.value.toUpperCase());
    if (findReplaceStopIdScheduleButton_SM) findReplaceStopIdScheduleButton_SM.addEventListener('click', handleFindReplaceStopIdInSchedule_SM);
    if (routesForStopSelect_SM) routesForStopSelect_SM.addEventListener('change', displayRoutesServingSelectedStop_SM);
    if (refreshRoutesForStopSelectButton_SM) refreshRoutesForStopSelectButton_SM.addEventListener('click', populateRoutesForStopSelector_SM);

    // NEW: Event Listeners for Route Diversion Tool
    if (selectStopForDiversion_RD) selectStopForDiversion_RD.addEventListener('change', displayRoutesForDiversion_RD);
    if (applyDiversionsButton_RD) applyDiversionsButton_RD.addEventListener('click', handleApplyDiversions_RD);
    if (clearAllDiversionsForStopButton_RD) clearAllDiversionsForStopButton_RD.addEventListener('click', handleClearAllDiversionsForStop_RD);

    fetchBankHolidaysForSetup(); // Initial call
});

</script>
</body>
</html>
