<!DOCTYPE html>
<html>
<head>
    <title>Live Bus Tracker</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* Basic Reset & Font */
        body, html { margin: 0; padding: 0; box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f9f9f9; }
        h1 { margin-bottom: 10px; text-align: center; }
         .info-container { display: flex; justify-content: space-between; flex-wrap: wrap; margin-bottom: 20px; font-size: 18px; }
         .update-time, .counter { margin-bottom: 5px; }
         table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 0.9em; }
         th, td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; white-space: nowrap; }
         th { background-color: #f4f4f4; position: sticky; top: 0; z-index: 1; }
         tr:nth-child(even) { background-color: #f9f9f9; }
         /* Style for rows representing buses seen recently but not in current feed */
         tr.ghost-bus td { color: #777; font-style: italic; }
         /* Specifically target the ETA cell for ghosts if needed */
         tr.ghost-bus td:nth-child(5) { /* font-weight: bold; */ } /* Example styling */
         th select { margin-left: 5px; padding: 2px; font-size: 0.9em;}
         td[colspan="5"] { text-align: center; font-style: italic; color: #555; padding: 15px 8px; white-space: normal; }
         td:nth-child(3), td:nth-child(4) { white-space: normal; } /* Allow destination and stop name to wrap */
         h2 { margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px; text-align: center;}
         /* Style for the initial route selector */
         #route-selector { display: none; text-align: center; padding: 30px; border: 1px solid #ccc; border-radius: 8px; margin: 30px auto; max-width: 450px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
         #route-selector h2 { margin-top: 0; margin-bottom: 20px; border: none; padding: 0; }
         #route-selector input[type="text"] { width: 80%; max-width: 250px; padding: 10px; margin-bottom: 15px; font-size: 1.1em; border: 1px solid #ccc; border-radius: 4px; text-align: center; text-transform: uppercase; }
         #route-selector button { padding: 10px 25px; font-size: 1.1em; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; transition: background-color 0.2s ease; }
         #route-selector button:hover { background-color: #0056b3; }
         #route-search-error { color: red; min-height: 1em; margin-top: 15px; font-size: 0.9em; }

         /* Styles for the top search bar */
         #top-route-search-container { text-align: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #eee; }
         #top-route-search-input { width: 60%; max-width: 200px; padding: 8px; font-size: 1em; border: 1px solid #ccc; border-radius: 4px; text-transform: uppercase; margin-right: 5px; vertical-align: middle; }
         #top-route-search-button { padding: 8px 15px; font-size: 1em; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; vertical-align: middle; transition: background-color 0.2s ease; }
         #top-route-search-button:hover { background-color: #0056b3; }
         #top-route-search-error { color: red; min-height: 1em; margin-top: 5px; font-size: 0.9em; }
    </style>
</head>
<body>
    <div id="route-selector">
        <h2>Enter Route to Track</h2>
        <input type="text" id="route-search-input" placeholder="e.g., 184, N20" aria-label="Route ID Input">
        <button id="route-search-button" onclick="loadSelectedRoute()">Load Route</button>
        <p id="route-search-error"></p>
    </div>

    <div id="tracker-content" style="display: none;">

        <div id="top-route-search-container">
            <input type="text" id="top-route-search-input" placeholder="Change Route (e.g., N91)" aria-label="Change Route ID Input">
            <button id="top-route-search-button" onclick="loadTopRoute()">Go</button>
            <p id="top-route-search-error"></p>
        </div>
        <h1 id="main-heading">Live Bus Tracker</h1>
        <div class="info-container">
            <div class="update-time" id="update-time">Last Updated: --</div>
            <div class="counter" id="bus-counter">Buses on Route: 0</div>
        </div>
        <table>
            <thead>
                <tr>
                    <th>Fleet No.<select id="filter-fleet"><option value="">All</option></select></th>
                    <th>Registration<select id="filter-reg"><option value="">All</option></select></th>
                    <th>Destination<select id="filter-destination"><option value="">All</option></select></th>
                    <th>Next Predicted Stop / Status<select id="filter-stop"><option value="">All</option></select></th>
                    <th>ETA / Last Seen<select id="filter-arrival"><option value="">All</option></select></th>
                </tr>
            </thead>
            <tbody id="tracker-table">
                <tr><td colspan="5">Fetching live data...</td></tr>
            </tbody>
        </table>

        <h2 id="curtailments-heading">Curtailments Today</h2>
        <table>
            <thead>
                <tr>
                    <th>Route</th>
                    <th>Fleet No.</th>
                    <th>Registration</th>
                    <th>Curtailed To</th>
                    <th>Time Logged</th>
                </tr>
            </thead>
            <tbody id="curtailed-buses-table">
                <tr><td colspan="5">Loading curtailment data...</td></tr>
            </tbody>
        </table>
    </div>

    <script>
         console.log('--- FULL TRACKER SCRIPT STARTED (v7 - Ghost ETA Update) ---');

         // Get references needed for showing/hiding sections
         const routeSelectorDiv = document.getElementById('route-selector');
         const trackerContentDiv = document.getElementById('tracker-content');

         // --- Dynamic Route ID Setup ---
         const urlParams = new URLSearchParams(window.location.search);
         let dynamicRouteId = urlParams.get('route')?.trim().toUpperCase();

         // --- Function to handle loading route from INITIAL input ---
         function loadSelectedRoute() {
             const input = document.getElementById('route-search-input');
             const errorP = document.getElementById('route-search-error');
             if (!input || !errorP) return;
             const enteredRoute = input.value.trim().toUpperCase();
             errorP.textContent = '';
             if (!enteredRoute) { errorP.textContent = 'Please enter a Route ID.'; input.focus(); return; }
             if (!/^[A-Z0-9]+$/i.test(enteredRoute) || enteredRoute.length > 5) { errorP.textContent = 'Invalid Route ID format entered.'; input.focus(); return; }
             window.location.href = `tracker.html?route=${enteredRoute}`; // Assumes filename is tracker.html
         }

         // --- Function to handle loading route from the TOP search bar ---
         function loadTopRoute() {
             const input = document.getElementById('top-route-search-input');
             const errorP = document.getElementById('top-route-search-error');
             if (!input || !errorP) return;
             const enteredRoute = input.value.trim().toUpperCase();
             errorP.textContent = '';
             if (!enteredRoute) { errorP.textContent = 'Please enter a Route ID.'; input.focus(); return; }
             if (!/^[A-Z0-9]+$/i.test(enteredRoute) || enteredRoute.length > 5) { errorP.textContent = 'Invalid Route ID format.'; input.focus(); return; }
             window.location.href = `tracker.html?route=${enteredRoute}`;
         }


         // Add listener for Enter key in the initial search input
         const routeSearchInput = document.getElementById('route-search-input');
         if (routeSearchInput) { routeSearchInput.addEventListener('keyup', function(event) { if (event.key === 'Enter') { event.preventDefault(); loadSelectedRoute(); } }); }

         // Add listener for Enter key in the TOP search input
         const topRouteSearchInput = document.getElementById('top-route-search-input');
         if (topRouteSearchInput) { topRouteSearchInput.addEventListener('keyup', function(event) { if (event.key === 'Enter') { event.preventDefault(); loadTopRoute(); } }); }


         // --- Main Logic Execution ---
         if (!dynamicRouteId) {
             // --- NO ROUTE IN URL ---
             document.title = "Select Route - Live Bus Tracker";
             if (routeSelectorDiv) routeSelectorDiv.style.display = 'block';
             if (trackerContentDiv) trackerContentDiv.style.display = 'none';
             console.log("No route ID in URL, showing selector.");
         } else {
             // --- ROUTE FOUND IN URL ---
              if (routeSelectorDiv) routeSelectorDiv.style.display = 'none';
              if (trackerContentDiv) trackerContentDiv.style.display = 'block';
              console.log(`Route ID found: ${dynamicRouteId}. Initializing tracker...`);

             // --- Constants ---
             const apiUrl = `https://api.tfl.gov.uk/Line/${dynamicRouteId}/Arrivals`;
             const curtailedBusesKey = `curtailedBusesArray_${dynamicRouteId}`;
             const tmpMapKey = "tmpRegistrationMap";
             const filterStateKey = `arrivalsFilterState_${dynamicRouteId}_all`;
             const busLastSeenKey = `busLastSeenWithDest_${dynamicRouteId}`;
             const settingsKey = "trackerGlobalSettings";
             const defaultSettings = { debounceMinutes: 60, timeoutMinutes: 30 }; // Default timeout is 30 mins
             const routeDestinationSettingsKey = 'routeDestinationSettings';
             const tmpGenerationInfoKey = "tmpGenerationInfo";
             const destinationOverrideKey = 'destinationOverrides';

             // --- Update Title and Headings ---
             document.title = `Live Tracker - Route ${dynamicRouteId}`;
             const mainHeading = document.getElementById('main-heading');
             if(mainHeading) mainHeading.textContent = `Live Tracker for Route ${dynamicRouteId}`;
             const busCounterElement = document.getElementById('bus-counter');
             if(busCounterElement) busCounterElement.textContent = `Buses on Route ${dynamicRouteId}: 0`;
             const curtailmentsHeading = document.getElementById('curtailments-heading');
              if(curtailmentsHeading) curtailmentsHeading.textContent = `Curtailments Today for Route ${dynamicRouteId}`;

             // --- Storage Functions ---
             function loadFromStorage(key, defaultValue = {}) { try { const data = localStorage.getItem(key); if (data) { const parsed = JSON.parse(data); if (typeof parsed === 'object' && parsed !== null) return parsed; } return defaultValue; } catch (e) { console.error(`Error loading ${key}:`, e); return defaultValue; } }
             function saveToStorage(key, data) { try { localStorage.setItem(key, JSON.stringify(data)); } catch (e) { console.error(`Error saving ${key}:`, e); } }

             // --- Advanced TMP Number Generation ---
             function generateTMPNumber(registration) { const seed=12345;const combined=registration+seed.toString();let hash=0;if(combined.length===0)return"TMP0000";for(let i=0;i<combined.length;i++){const t=combined.charCodeAt(i);hash=(hash<<5)-hash+t,hash|=0}return`TMP${Math.abs(hash%1e4).toString().padStart(4,"0")}` }
             function getTMPForRegistration(registration) { if (!registration) return 'TMP????'; let tmpMap = loadFromStorage(tmpMapKey, {}); if (typeof tmpMap !== 'object' || tmpMap === null) tmpMap = {}; if (tmpMap.hasOwnProperty(registration)) { return tmpMap[registration]; } let attempt = 0; let uniqueTMP = null; let generatedTMP; const MAX_ATTEMPTS = 100; const isTMPValueUsed = (map, tmpValue, currentReg) => { for (const reg in map) { if (map.hasOwnProperty(reg) && reg !== currentReg && map[reg] === tmpValue) { return true; } } return false; }; while (uniqueTMP === null && attempt < MAX_ATTEMPTS) { const inputForHash = attempt === 0 ? registration : `${registration}_${attempt}`; generatedTMP = generateTMPNumber(inputForHash); if (!isTMPValueUsed(tmpMap, generatedTMP, registration)) { uniqueTMP = generatedTMP; } else { console.warn(`TMP collision for ${registration}: ${generatedTMP}. Retrying...`); attempt++; } } if (uniqueTMP === null) { console.error(`Could not generate unique TMP for ${registration}.`); uniqueTMP = `ERR${Math.floor(1000 + Math.random() * 9000)}`; } tmpMap[registration] = uniqueTMP; saveToStorage(tmpMapKey, tmpMap); try { let genInfo = loadFromStorage(tmpGenerationInfoKey, {}); if (typeof genInfo !== 'object' || genInfo === null) genInfo = {}; genInfo[registration] = { route: dynamicRouteId, timestamp: Date.now() }; saveToStorage(tmpGenerationInfoKey, genInfo); } catch(e) { console.error(`Failed to save TMP generation info for ${registration}:`, e); } return uniqueTMP; }


             // --- Destination Override Logic ---
             function getEffectiveDestination(busReg, busDirectionId, originalApiDest) {
                 const reg = String(busReg || '').toUpperCase();
                 const routeId = dynamicRouteId;
                 const directionId = parseInt(busDirectionId, 10);
                 const overrides = loadFromStorage(destinationOverrideKey, {});
                 const globalOverride = overrides['*'] || null;
                 // 1. Specific Bus Override
                 if (overrides.hasOwnProperty(reg)) { const regOverride = overrides[reg]; if (typeof regOverride === 'object' && regOverride !== null && regOverride.hasOwnProperty('dir1') && regOverride.hasOwnProperty('dir2')) { let d = null; if (directionId === 1 && regOverride.dir1) d = regOverride.dir1; else if (directionId === 2 && regOverride.dir2) d = regOverride.dir2; if (d && (directionId === 1 || directionId === 2)) return d; } else if (typeof regOverride === 'string' && regOverride.trim() !== '') { console.warn(`Applying legacy specific override for ${reg}`); return regOverride; } }
                 // 2. Route-Wide Override
                 if (overrides.hasOwnProperty(routeId)) { const routeOverride = overrides[routeId]; if (typeof routeOverride === 'object' && routeOverride !== null && routeOverride.hasOwnProperty('dir1') && routeOverride.hasOwnProperty('dir2')) { let d = null; if (directionId === 1 && routeOverride.dir1) d = routeOverride.dir1; else if (directionId === 2 && routeOverride.dir2) d = routeOverride.dir2; if (d && (directionId === 1 || directionId === 2)) return d; } else if (typeof routeOverride === 'string' && routeOverride.trim() !== '') { console.warn(`Applying legacy route override for ${routeId}`); return routeOverride; } }
                 // 3. Global Override
                 if (globalOverride && typeof globalOverride === 'string' && globalOverride.trim() !== '') return globalOverride;
                 // 4. Original
                 return String(originalApiDest || 'N/A');
             }


             // --- Curtailment Handling ---
             function populateCurtailmentsTable() {
                  const allCurtailments = loadFromStorage(curtailedBusesKey, []); const curtailedBusesTable = document.getElementById("curtailed-buses-table"); if (!curtailedBusesTable) return; curtailedBusesTable.innerHTML = ""; if (!Array.isArray(allCurtailments)) { curtailedBusesTable.innerHTML = `<tr><td colspan="5">Error loading curtailment data.</td></tr>`; return; } const todayStart = new Date(); todayStart.setHours(0, 0, 0, 0); const todayTimestamp = todayStart.getTime(); const todaysCurtailments = allCurtailments.filter(c => c && c.route === dynamicRouteId && c.timestamp >= todayTimestamp); const sortedTodaysCurtailments = todaysCurtailments.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); if (sortedTodaysCurtailments.length > 0) { sortedTodaysCurtailments.forEach(bus => { const fleetNumber = getTMPForRegistration(bus.regNumber); let displayTime = 'N/A'; if (bus.timestamp && !isNaN(bus.timestamp)) { try { const dateObject = new Date(bus.timestamp); displayTime = dateObject.toLocaleTimeString('en-GB', { timeZone: 'Europe/London', hour: '2-digit', minute: '2-digit' }); } catch (e) { displayTime = bus.curtailmentTime || 'N/A'; } } else if (bus.curtailmentTime) { displayTime = bus.curtailmentTime; } const row = document.createElement("tr"); row.innerHTML = `<td>${bus.route || 'N/A'}</td><td>${fleetNumber}</td><td>${bus.regNumber || 'N/A'}</td><td>${bus.curtailedDestination || 'N/A'}</td><td>${displayTime}</td>`; curtailedBusesTable.appendChild(row); }); } else { curtailedBusesTable.innerHTML = `<tr><td colspan="5">No curtailments recorded for Route ${dynamicRouteId} today.</td></tr>`; }
             }

             // --- Live Data Fetching and Processing (with Timeout Fix & Relative Time) ---
             async function fetchLiveBusData() {
                  const trackerTable = document.getElementById("tracker-table");
                  const busCounter = document.getElementById("bus-counter");
                  const updateTime = document.getElementById("update-time");
                  const filterFleet = document.getElementById("filter-fleet");
                  const filterReg = document.getElementById("filter-reg");
                  const filterDestination = document.getElementById("filter-destination");
                  const filterStop = document.getElementById("filter-stop");
                  const filterArrival = document.getElementById("filter-arrival");

                  if (!trackerTable || !busCounter || !updateTime || !filterFleet || !filterReg || !filterDestination || !filterStop || !filterArrival) { console.error("Essential elements missing."); return; }

                  try {
                       const loadedSettings = loadFromStorage(settingsKey, defaultSettings);
                       const debounceMinutes = loadedSettings.debounceMinutes || defaultSettings.debounceMinutes;
                       const timeoutMinutes = loadedSettings.timeoutMinutes || defaultSettings.timeoutMinutes;
                       const debounceMs = debounceMinutes * 60 * 1000;
                       const timeoutMs = timeoutMinutes * 60 * 1000;
                       const allDestSettings = loadFromStorage(routeDestinationSettingsKey, {});
                       const finalDestinations = allDestSettings[dynamicRouteId] || [];

                       const response = await fetch(apiUrl);
                       if (!response.ok) { trackerTable.innerHTML = `<tr><td colspan="5">Error fetching API data (${response.status}). Route ${dynamicRouteId} may be invalid.</td></tr>`; throw new Error(`API error: ${response.status}`); }
                       const arrivals = await response.json();
                       const now = Date.now();

                       let busLastSeen = loadFromStorage(busLastSeenKey, {});
                       let tmpMap = loadFromStorage(tmpMapKey, {});
                       let allCurtailments = loadFromStorage(curtailedBusesKey, []);
                       if (!Array.isArray(allCurtailments)) { allCurtailments = []; }

                       const activeBuses = {};
                       let newCurtailmentDetected = false;

                       // Process current arrivals
                       if (arrivals && Array.isArray(arrivals) && arrivals.length > 0) {
                           arrivals.forEach(bus => {
                               const regNumber = bus.vehicleId; if (!regNumber) return;
                               const expectedArrivalTime = new Date(bus.expectedArrival).getTime();
                               const apiDestination = bus.destinationName || "Unknown";
                               const apiDirectionValue = bus.direction;
                               let directionId = undefined; if (apiDirectionValue === 'outbound') { directionId = 1; } else if (apiDirectionValue === 'inbound') { directionId = 2; }
                               const lastSeenInfo = busLastSeen[regNumber]; const previousDestination = lastSeenInfo?.destination;
                               // Curtailment Check
                               if (previousDestination && apiDestination && apiDestination !== previousDestination && !finalDestinations.includes(apiDestination)) { const alreadyLoggedRecently = allCurtailments.some(c => c.regNumber === regNumber && c.curtailedDestination === apiDestination && c.timestamp && (now - c.timestamp) < debounceMs); if (!alreadyLoggedRecently) { const logDate = new Date(); const newEntry = { route: dynamicRouteId, regNumber: regNumber, curtailedDestination: apiDestination, curtailmentTime: logDate.toLocaleString('en-GB', { timeZone: 'Europe/London', dateStyle: 'short', timeStyle: 'short'}), timestamp: logDate.getTime() }; allCurtailments.push(newEntry); newCurtailmentDetected = true; console.log(`Auto-detected curtailment for ${regNumber} to ${apiDestination}`); } }
                               // Update last seen
                               busLastSeen[regNumber] = { time: now, destination: apiDestination, direction: directionId };
                               // Add to active list
                               const existingPredictionTime = activeBuses[regNumber]?.expectedArrivalTimeMs;
                               if (!isNaN(expectedArrivalTime) && expectedArrivalTime >= now) {
                                   if (!existingPredictionTime || expectedArrivalTime < existingPredictionTime) {
                                       const fleetNumber = getTMPForRegistration(regNumber);
                                       const displayDestination = getEffectiveDestination(regNumber, directionId, apiDestination);
                                       // Calculate Relative Time
                                       const diffMs = expectedArrivalTime - now; const diffMins = Math.round(diffMs / 60000);
                                       let relativeTimeString; if (diffMins <= 0) { relativeTimeString = "Due"; } else if (diffMins === 1) { relativeTimeString = "1 min"; } else { relativeTimeString = `${diffMins} mins`; }
                                       activeBuses[regNumber] = { fleetNumber: fleetNumber, regNumber: regNumber, apiDestination: apiDestination, displayDestination: displayDestination, stopName: bus.stationName || "Unknown", stopArrivalRelative: relativeTimeString, expectedArrivalTimeMs: expectedArrivalTime, isGhost: false };
                                   }
                               }
                           });
                       }

                       // --- Combine Active and Ghost Buses ---
                       const displayBuses = Object.values(activeBuses);
                       for (const reg in busLastSeen) {
                           if (!activeBuses[reg]) {
                               const lastSeenTime = busLastSeen[reg]?.time || 0;
                               if (now - lastSeenTime < timeoutMs) {
                                   const lastDest = busLastSeen[reg]?.destination || 'Unknown';
                                   const lastDirId = busLastSeen[reg]?.direction;
                                   const lastSeenDate = new Date(lastSeenTime);
                                   const lastSeenTimeString = lastSeenDate.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                                   const ghostBus = {
                                       fleetNumber: getTMPForRegistration(reg),
                                       regNumber: reg,
                                       apiDestination: lastDest,
                                       displayDestination: getEffectiveDestination(reg, lastDirId, lastDest),
                                       // *** CHANGE HERE: Set stopName, not ETA ***
                                       stopName: "N/A", // Or "(No prediction)"
                                       stopArrivalRelative: `(Last seen ${lastSeenTimeString})`, // *** CHANGE HERE: Set ETA to last seen ***
                                       expectedArrivalTimeMs: 0,
                                       isGhost: true
                                   };
                                   displayBuses.push(ghostBus);
                               }
                           }
                       }
                       // --- End Combine ---

                       if (newCurtailmentDetected) { saveToStorage(curtailedBusesKey, allCurtailments); populateCurtailmentsTable(); }

                       // Cleanup logic for truly timed out buses
                       tmpMap = loadFromStorage(tmpMapKey, {}); let updatedTmpMap = false; let busLastSeenUpdated = false;
                       for (const reg in busLastSeen) { if (now - (busLastSeen[reg]?.time || 0) > timeoutMs) { console.log(`Permanently removing timed out bus ${reg}`); delete busLastSeen[reg]; busLastSeenUpdated = true; if (tmpMap[reg] && (tmpMap[reg].startsWith('TMP') || tmpMap[reg].startsWith('ERR'))) { delete tmpMap[reg]; updatedTmpMap = true; try { let g = loadFromStorage(tmpGenerationInfoKey,{}); if(g[reg]){ delete g[reg]; saveToStorage(tmpGenerationInfoKey,g); console.log(`Removed gen info ${reg}`); } } catch(e){ console.error(`Err removing gen ${reg}`,e); } } } }
                       if (busLastSeenUpdated) { saveToStorage(busLastSeenKey, busLastSeen); } if (updatedTmpMap) { saveToStorage(tmpMapKey, tmpMap); }

                       const sortedBuses = displayBuses.sort((a, b) => (a.fleetNumber || '').localeCompare(b.fleetNumber || ''));

                       // --- Update Filter Options ---
                       const options = { fleet: new Set(), reg: new Set(), destination: new Set(), stop: new Set(), arrival: new Set() };
                       sortedBuses.forEach(bus => { options.fleet.add(bus.fleetNumber); options.reg.add(bus.regNumber); options.destination.add(bus.displayDestination); options.stop.add(bus.stopName); options.arrival.add(bus.stopArrivalRelative); }); // stopArrivalRelative now includes "(Last seen...)"
                       const filters = [filterFleet, filterReg, filterDestination, filterStop, filterArrival];
                       const currentFilterValues = { fleet: filterFleet.value, reg: filterReg.value, destination: filterDestination.value, stop: filterStop.value, arrival: filterArrival.value };
                       filters.forEach(f => { if(f) while (f.options.length > 1) f.remove(1); });
                       // Sort helper for relative/status times
                       const sortRelativeTimes = (a, b) => {
                            if (a === b) return 0;
                            const isGhostA = a.startsWith('(Last seen'); const isGhostB = b.startsWith('(Last seen');
                            const isNaA = a === 'N/A'; const isNaB = b === 'N/A';
                            const isDueA = a === 'Due'; const isDueB = b === 'Due';
                            // Order: Due -> X mins -> (Last seen...) -> N/A
                            if (isNaA) return 1; if (isNaB) return -1;
                            if (isGhostA && !isGhostB) return 1; if (!isGhostA && isGhostB) return -1; if (isGhostA && isGhostB) return 0; // Equal sort value if both ghosts
                            if (isDueA) return -1; if (isDueB) return 1;
                            // Handle "X mins"
                            const numA = parseInt(a); const numB = parseInt(b);
                            if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                            return a.localeCompare(b); // Fallback
                       };
                       // Populate filters
                       [...options.fleet].sort().forEach(val => filterFleet?.add(new Option(val, val))); [...options.reg].sort().forEach(val => filterReg?.add(new Option(val, val))); [...options.destination].sort().forEach(val => filterDestination?.add(new Option(val, val))); [...options.stop].sort().forEach(val => filterStop?.add(new Option(val, val))); [...options.arrival].sort(sortRelativeTimes).forEach(val => filterArrival?.add(new Option(val, val))); // Use new sort
                       // Restore filter values
                       const restoreFilterValue = (el, val) => { if (el && val && [...el.options].some(opt => opt.value === val)) el.value = val; else if (el) el.value = ""; };
                       restoreFilterValue(filterFleet, currentFilterValues.fleet); restoreFilterValue(filterReg, currentFilterValues.reg); restoreFilterValue(filterDestination, currentFilterValues.destination); restoreFilterValue(filterStop, currentFilterValues.stop); restoreFilterValue(filterArrival, currentFilterValues.arrival);
                       // --- End Update Filters ---

                       // Populate Tracker Table
                       trackerTable.innerHTML = "";
                       if (sortedBuses.length === 0) { trackerTable.innerHTML = `<tr><td colspan="5">No buses currently tracking or recently seen on Route ${dynamicRouteId}.</td></tr>`; }
                       else {
                           sortedBuses.forEach(bus => {
                               const row = document.createElement("tr");
                               if (bus.isGhost) { row.classList.add('ghost-bus'); }
                               // Use stopArrivalRelative for the 5th column (ETA / Last Seen)
                               row.innerHTML = `
                                   <td>${bus.fleetNumber || 'N/A'}</td>
                                   <td>${bus.regNumber || 'N/A'}</td>
                                   <td>${bus.displayDestination}</td>
                                   <td>${bus.stopName || 'N/A'}</td>
                                   <td>${bus.stopArrivalRelative || 'N/A'}</td>`; // Use the relative/status string here
                               trackerTable.appendChild(row);
                           });
                       }

                       // Update counters and timestamp
                       const busCounterElem = document.getElementById('bus-counter'); if(busCounterElem) busCounterElem.textContent = `Buses on Route ${dynamicRouteId}: ${sortedBuses.length}`;
                       if(updateTime) updateTime.textContent = `Last Updated: ${new Date().toLocaleTimeString()}`;
                       filterArrivalsTable();

                  } catch (error) { console.error(`Error fetching/processing [${dynamicRouteId}]:`, error); if (!trackerTable.innerHTML.includes("Error")) { trackerTable.innerHTML = `<tr><td colspan="5">Error updating data. Check console.</td></tr>`; } }
             } // --- End fetchLiveBusData ---

             // --- Filter Application Logic ---
             const filterFleet = document.getElementById("filter-fleet"); const filterReg = document.getElementById("filter-reg"); const filterDestination = document.getElementById("filter-destination"); const filterStop = document.getElementById("filter-stop"); const filterArrival = document.getElementById("filter-arrival"); const arrivalsTableBody = document.getElementById("tracker-table");
             function saveFilterState() { const filterState = { fleet: filterFleet ? filterFleet.value : "", reg: filterReg ? filterReg.value : "", destination: filterDestination ? filterDestination.value : "", stop: filterStop ? filterStop.value : "", arrival: filterArrival ? filterArrival.value : "" }; saveToStorage(filterStateKey, filterState); }
             function filterArrivalsTable() { if (!arrivalsTableBody || !filterFleet || !filterReg || !filterDestination || !filterStop || !filterArrival) return; const fleetFilter = filterFleet.value; const regFilter = filterReg.value; const destinationFilter = filterDestination.value; const stopFilter = filterStop.value; const arrivalFilter = filterArrival.value; let visibleRowCount = 0; const rows = arrivalsTableBody.querySelectorAll("tr"); rows.forEach(row => { if (row.cells.length < 5) { if (fleetFilter || regFilter || destinationFilter || stopFilter || arrivalFilter) { row.style.display = "none"; } else { row.style.display = ""; } return; } const fleet = row.cells[0].textContent; const reg = row.cells[1].textContent; const destination = row.cells[2].textContent; const stop = row.cells[3].textContent; const arrival = row.cells[4].textContent; // This now includes "(Last seen...)" / "Due" / "X mins" / "N/A"
                 const fleetMatch = !fleetFilter || fleet === fleetFilter; const regMatch = !regFilter || reg === regFilter; const destinationMatch = !destinationFilter || destination === destinationFilter; const stopMatch = !stopFilter || stop === stopFilter; const arrivalMatch = !arrivalFilter || arrival === arrivalFilter; const showRow = fleetMatch && regMatch && destinationMatch && stopMatch && arrivalMatch; row.style.display = showRow ? "" : "none"; if (showRow) { visibleRowCount++; } }); }

             // --- Attach Event Listeners ---
             if (filterFleet) filterFleet.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); }); if (filterReg) filterReg.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); }); if (filterDestination) filterDestination.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); }); if (filterStop) filterStop.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); }); if (filterArrival) filterArrival.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); });

             // --- Initial Load Logic ---
             function initialize() { console.log(`Initializing full tracker for route: ${dynamicRouteId}`); populateCurtailmentsTable(); const initialFilterState = loadFromStorage(filterStateKey, {}); if (initialFilterState && typeof initialFilterState === 'object' && Object.keys(initialFilterState).length > 0) { if (filterFleet) filterFleet.value = initialFilterState.fleet || ""; if (filterReg) filterReg.value = initialFilterState.reg || ""; if (filterDestination) filterDestination.value = initialFilterState.destination || ""; if (filterStop) filterStop.value = initialFilterState.stop || ""; if (filterArrival) filterArrival.value = initialFilterState.arrival || ""; } fetchLiveBusData(); setInterval(fetchLiveBusData, 30000); }

             // --- Run Initialization ---
              if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initialize); } else { initialize(); }

         } // End of the main 'else' block (if dynamicRouteId was valid)
     </script>
</body>
</html>
