<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMSI Tools</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <link rel="manifest" href="/live-tracker/manifest-omsitools.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OMSI Tools">
    <meta name="theme-color" content="#2c3e50">
    <link rel="apple-touch-icon" href="/live-tracker/assets/icons/apple-touch-icon-180x180.png">

    <style>
        @font-face {
            font-family: 'NJFont Medium Web';
            src: url('fonts/NJFont-Medium.ttf') format('truetype'); /* Relative path */
            font-weight: normal;font-style: normal;font-display: swap;
        }
        body {
            font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            margin:0;
        }
        .page-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        #top-menu-bar {
            background-color: rgba(0,0,0,0.25);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center;
            display: none; /* Hidden by default, shown after login */
        }
        .menu-button {
            cursor: pointer;
            background-color: #3498db;
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 0.25rem;
            font-size: 0.9rem;
            transition: background-color 0.2s;
            border: none;
            margin: 0.25rem;
        }
        .menu-button:hover {
            background-color: #2980b9;
        }

        button.menu-button[data-section="deployment-tools-section"] {
            background-color: #27ae60; 
        }

        button.menu-button[data-section="deployment-tools-section"]:hover {
            background-color: #229954; 
        }

        .tool-content-section {
            display: none; /* All tool sections hidden by default */
        }

        #auth-section {
             margin-bottom: 1.5rem;
        }
        #current-profile-display-container {
            text-align: center;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background-color: rgba(255,255,255,0.05);
            border-radius: 0.25rem;
            display: none; /* Hidden by default, shown after login */
        }
        #current-profile-display { font-size: 0.9rem; opacity: 1; font-style: normal; color: #FFFFFF;}


        h1 { font-size: 2rem; margin-bottom: 1.5rem; font-weight: normal; text-align: center; color: #ffffff; }
        h2 { font-size: 1.5rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: normal; border-bottom: 1px solid #7f8c8d; padding-bottom: 0.25rem;}
        h3.subsection-title { font-size: 1.25rem; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: normal; color: #e0e0e0; border-bottom: 1px solid rgba(127,140,141,0.5); padding-bottom: 0.2rem;}
        /* Added for multi-table titles in Timetable Generator */
        .timetable-category-section h4 {
            font-size: 1.1rem; /* Slightly smaller than h3 */
            color: #e0e0e0;
            margin-bottom: 0.75rem;
            padding-bottom: 0.3rem;
            border-bottom: 1px solid rgba(127,140,141,0.3);
        }


        .section {
            background-color: rgba(0,0,0,0.15);
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .subsection {
            background-color: rgba(0,0,0,0.1);
            padding: 1rem;
            border-radius: 0.375rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
             border: 1px solid rgba(127,140,141,0.2);
        }


        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;}
        .form-field-group { margin-bottom: 1rem; }


        label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.85rem;
            color: #bdc3c7;
        }

        input[type="text"],
        input[type="email"],
        input[type="password"],
        input[type="time"],
        input[type="color"],
        input[type="number"],
        select, 
        textarea { /* Added textarea for consistency */
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size:0.9rem;
            box-sizing: border-box; /* Added for better width handling */
        }
        input[type="color"] { height: 2.75rem; padding: 0.25rem; }
        select option { background-color: #34495e; color: #ecf0f1; }


        #inputStopID,
        #bulkEditTargetStopID, #bulkEditTargetLineName,
        #findStopIdScheduleInput, #replaceStopIdScheduleInput,
        #gen_stopId, #inputNewStopId_ARS {
            text-transform: uppercase;
        }
        #gen_lineName, #gen_destinationName, #consolidateNewProfileInput {
            text-transform: none;
        }


        .button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin-right: 0.5rem; margin-top:0.5rem;
            display: inline-block;
            text-align: center;
            vertical-align: middle;
        }
        .button:hover { background-color: #2980b9; }
        .button.small-action { padding: 0.2rem 0.4rem; font-size: 0.8rem; margin: 0 0.15rem; line-height: 1; min-width: 20px; text-align:center;}
        .button.secondary { background-color: #e74c3c; }
        .button.secondary:hover { background-color: #c0392b; }
        .button.tertiary { background-color: #f39c12; }
        .button.tertiary:hover { background-color: #e67e22; }
        .button.neutral { background-color: #7f8c8d; }
        .button.neutral:hover { background-color: #95a5a6; color: #2c3e50; }


        .file-upload-label { display: inline-block; cursor: pointer; background-color: #95a5a6; color: #2c3e50; padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem; transition: background-color 0.2s; margin-bottom: 0.5rem; }
        .file-upload-label:hover { background-color: #7f8c8d; }
        #file-status { font-size: 0.9rem; margin-top: 0.25rem; margin-bottom:1rem; opacity: 0.9; min-height: 1.2em; }

        .actions-section { margin-top: 1.5rem; }
        #stageScheduleButton { background-color: #27ae60; }
        #stagingStatusMessage { text-align:center; margin-bottom: 1rem; font-size: 0.9em; color: #f1c40f; min-height:1.2em; }


        .info-section { margin-top:2rem; padding:1rem; background-color: rgba(0,0,0,0.1); border-radius:0.25rem; font-size:0.8rem; }
        .info-section h3 { font-size:1rem; margin-bottom:0.5rem; color: #ffffff; }
        .info-section p { line-height:1.6; color:#bdc3c7; }

        .tooltip { position: relative; display: inline-block; cursor: help; margin-left: 4px; font-size:0.8em; background-color:#7f8c8d; color:white; border-radius:50%; width:14px; height:14px; text-align:center; line-height:14px;}
        .tooltip .tooltiptext {
            visibility: hidden; width: 280px; background-color: #34495e; color: #fff;
            text-align: left; border-radius: 6px; padding: 8px; position: absolute;
            z-index: 10; bottom: 135%; left: 50%; margin-left: -140px; opacity: 0; transition: opacity 0.3s;
            font-size: 0.75rem; line-height: 1.4; border: 1px solid #7f8c8d;
        }
        .tooltip .tooltiptext::after {
            content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px;
            border-width: 5px; border-style: solid; border-color: #34495e transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .filter-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; margin-bottom: 1rem; align-items: end;}

        .current-details-display {
            margin-top: 0.5rem;
            font-size: 0.85em;
            background-color: rgba(0,0,0,0.2);
            padding: 0.5rem;
            border-radius: 0.25rem;
            color: #bdc3c7;
        }
        .current-details-display p { margin: 0.2rem 0; }
        .current-details-display span { font-style: italic; color: #ecf0f1; }

        .event-section div, .stop-status-section div,
        .route-colour-management-subsection div,
        .stop-specific-route-colour-subsection div,
        .view-stop-departures div, .analytics-subsection div {
            margin-bottom: 0.75rem;
        }
        .event-section label, .stop-status-section label,
        .route-colour-management-subsection label,
        .stop-specific-route-colour-subsection label,
        .view-stop-departures label, .analytics-subsection label {
             margin-bottom: 0.25rem;
        }


        #currentRouteColoursListContainer,
        #currentStopSpecificColoursListContainer,
        #duplicateEntriesResults {
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            padding: 0.75rem;
            margin-top: 1rem;
            max-height: 300px;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.05);
        }
        #currentRouteColoursList li,
        #currentStopSpecificColoursList ul,
        #currentStopSpecificColoursList li,
        #duplicateEntriesResults li {
            display: block;
            padding: 0.5rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #currentRouteColoursList li:last-child,
        #currentStopSpecificColoursList li:last-child,
        #duplicateEntriesResults li:last-child { border-bottom: none; }

        #currentStopSpecificColoursList .stop-group-title {
            font-weight: bold;
            margin-top: 0.5rem;
            padding-bottom: 0.2rem;
            border-bottom: 1px dashed #566573;
        }
        #currentStopSpecificColoursList .stop-group-title:first-child {
            margin-top: 0;
        }
        #currentStopSpecificColoursList ul {
            list-style-type: none;
            padding-left: 1rem;
            margin:0;
        }


        #duplicateEntriesResults .duplicate-set { margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 1px dashed #4A5568;}
        #duplicateEntriesResults .duplicate-set:last-child { border-bottom: none; }
        #duplicateEntriesResults .entry-detail { display: block; font-size: 0.85rem; margin-left: 1rem; opacity: 0.9;}


        .colour-preview-box {
            width: 20px;
            height: 20px;
            border: 1px solid #ecf0f1;
            margin-right: 10px;
            display: inline-block;
            vertical-align: middle;
        }
        #currentRouteColoursList .route-info,
        #currentStopSpecificColoursList .route-info {
            flex-grow: 1;
            display: inline-flex;
            align-items: center;
        }


        .route-tile-tools-list {
            display: inline-block;
            padding: 0.2em 0.55em;
            margin-right: 0.3em;
            margin-bottom: 0.3em;
            border-radius: 0.25rem;
            font-size: 0.8em;
            font-weight: bold;
            color: white;
            text-align: center;
            line-height: 1.3;
            min-width: 28px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.25);
            vertical-align: middle;
        }
        #stopDeparturesList li {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.1rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #stopDeparturesList li:last-child {
            border-bottom: none;
        }

        /* Enhanced Master Stop List Styles START */
        #masterStopListUL_SM li {
            padding: 0.75rem 0.5rem; 
            border-bottom: 1px solid #34495e;
            transition: background-color 0.15s ease-in-out;
        }
        #masterStopListUL_SM li:last-child {
            border-bottom: none;
        }
        #masterStopListUL_SM li .stop-id-master { 
            font-weight: normal; 
            color: #bdc3c7;     
            font-size: 0.95em;  
        }
        #masterStopListUL_SM li .stop-name-master { 
            font-weight: bold;  
            color: #ecf0f1;      
            font-size: 1.05em; 
        }
        #masterStopListUL_SM li .stop-direction-master {
            font-style: italic;
            font-size: 0.85em;
            color: #95a5a6;
            margin-bottom: 0.3rem;
        }

        #masterStopListUL_SM li .stop-details-grid {
            display: grid;
            grid-template-columns: auto 1fr; 
            gap: 0.2rem 0.5rem; 
            font-size: 0.85em;
            margin-top: 0.4rem;
        }
        #masterStopListUL_SM li .detail-label {
            font-weight: normal; 
            color: #bdc3c7;
            opacity: 0.8;
        }
        #masterStopListUL_SM li .detail-value {
            color: #ecf0f1;
        }
        #masterStopListUL_SM li .detail-value.status-closed {
            color: #e74c3c; 
            font-weight: bold;
        }
        #masterStopListUL_SM li .detail-value.status-open {
            color: #2ecc71; 
        }

        #masterStopListUL_SM li .serving-routes-container {
            margin-top: 0.4rem;
            margin-bottom: 0.2rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3em;
            padding: 0.25rem 0;
        }
        #masterStopListUL_SM li .service-times-info { 
            font-size: 0.8em;
            opacity: 0.9;
            margin-top: 0.3rem;
            padding: 0.25rem;
            background-color: rgba(0,0,0,0.1);
            border-radius: 0.2rem;
        }
        #masterStopListUL_SM li .stop-actions {
            margin-top: 0.75rem;
            padding-top: 0.5rem;
            border-top: 1px dashed rgba(127,140,141,0.3);
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        /* Enhanced Master Stop List Styles END */


        #routesServingStopListContainer_SM {
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.05);
            padding:0.75rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
        }
        #routesServingStopList_SM {
            list-style: none;
            padding: 0;
            margin:0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5em;
        }
        #routesServingStopList_SM li {
            padding: 0;
            border-bottom: none;
        }

        /* Schedule Generator Specific Styles (from original file) */
        #schedule-generator-section h2,
        #schedule-generator-section h3.subsection-title,
        #schedule-generator-section h4 {
            color: #ecf0f1;
            border-bottom-color: #4A5568;
        }
        #schedule-generator-section label {
            display: block;
            color: #bdc3c7;
            margin-top: 10px;
            margin-bottom: 0.35rem;
            font-weight: 500;
            font-size: 0.85rem;
        }
        .schedule-generator-select {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        .schedule-generator-select option {
            background-color: #34495e;
            color: #ecf0f1;
        }
        #gen_stopId.schedule-generator-input {
             text-transform: uppercase;
        }
        #gen_lineName.schedule-generator-input,
        #gen_destinationName.schedule-generator-input {
            text-transform: none;
        }
        .gen_interval-rule {
            border: 1px solid #4A5568;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 0.375rem;
            background-color: rgba(0,0,0,0.1);
        }
        .gen_input-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }
        #gen_resultsTable {
            width: 100%;
            margin-top: 1.5rem;
            border-collapse: collapse;
            color: #ecf0f1;
        }
        #gen_resultsTable th, #gen_resultsTable td {
            border: 1px solid #4A5568;
            padding: 8px 10px;
            text-align: left;
        }
        #gen_resultsTable th {
            background-color: #34495e;
            color: white;
            font-weight: 500;
        }
        #gen_resultsTable tbody tr:nth-child(odd) {
            background-color: rgba(0,0,0,0.1);
        }
         #gen_resultsTable tbody tr:nth-child(even) {
            background-color: rgba(0,0,0,0.2);
        }
        .gen_action-buttons {
            margin-top: 1.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }
        .gen_footer-note {
            text-align: center;
            margin-top: 1.5rem;
            font-size: 0.85em;
            color: #bdc3c7;
        }

        #newStopIdAvailability_ARS {
            font-size: 0.8em;
            min-height: 1.1em;
            margin-top: 0.25rem;
        }

        #sgCopierSourceRoutesContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5em;
            padding: 0.75rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            background-color: rgba(0,0,0,0.05);
            min-height: 40px;
        }
        .copier-route-tile {
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out, outline 0.1s ease-in-out;
            border: 1px solid transparent;
        }
        .copier-route-tile:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .copier-route-tile.selected-tile {
            outline: 2px solid #3498db;
            box-shadow: 0 0 0 2px #3498db, 0 2px 5px rgba(0,0,0,0.4);
        }
        #sgCopierSourceRoutesPlaceholder {
            width: 100%;
            text-align: center;
            opacity: 0.7;
            padding: 0.5rem;
        }

        #specificRouteColourTilesContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5em;
            padding: 0.75rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            background-color: rgba(0,0,0,0.05);
            min-height: 40px;
            margin-bottom: 1rem;
        }
        .specific-colour-route-tile {
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out, outline 0.1s ease-in-out;
            border: 1px solid transparent;
            cursor: pointer;
        }
        .specific-colour-route-tile:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .specific-colour-route-tile.selected-for-color-edit {
            outline: 2px solid #f39c12;
            box-shadow: 0 0 0 2px #f39c12, 0 2px 5px rgba(0,0,0,0.4);
        }
        #specificRouteColourTilesPlaceholder {
             width: 100%;
            text-align: center;
            opacity: 0.7;
            padding: 0.5rem;
        }

        /* START: Styles for Route Stops Explorer */
        #route-stops-explorer-section .form-grid {
            grid-template-columns: 1fr; 
            margin-bottom: 1.5rem;
        }
        .route-stops-columns-container {
            display: grid;
            grid-template-columns: 1fr 1fr; 
            gap: 1.5rem;
        }
        .route-stops-column {
            background-color: rgba(0,0,0,0.1);
            padding: 1rem;
            border-radius: 0.375rem;
            border: 1px solid rgba(127,140,141,0.2);
        }
        .route-stops-column h4 {
            font-size: 1.1rem;
            color: #e0e0e0;
            margin-bottom: 0.75rem;
            border-bottom: 1px solid rgba(127,140,141,0.3);
            padding-bottom: 0.3rem;
        }
        .route-stops-column ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
            max-height: 400px; 
            overflow-y: auto;
        }
        .route-stops-column li {
            padding: 0.5rem 0.25rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        .route-stops-column li:last-child {
            border-bottom: none;
        }
        .route-stops-column .stop-name {
            font-weight: bold;
        }
        .route-stops-column .stop-id {
            font-size: 0.85em;
            opacity: 0.8;
            margin-left: 0.5em;
        }
        #rse_direction1_placeholder, #rse_direction2_placeholder {
            text-align: center;
            opacity: 0.7;
            padding: 1rem;
        }
        /* END: Styles for Route Stops Explorer */

        /* START: Styles for Timetable Generator (Multi-table) */
        #timetable-generator-section .subsection-title { 
            color: #ecf0f1;
            border-bottom-color: #4A5568;
        }
        #timetable-generator-section label {
            display: block;
            color: #bdc3c7;
            margin-bottom: 0.25rem;
            font-weight: 500;
            font-size: 0.85rem;
        }
        .tg_timetableTable_styles {
            width: 100%;
            margin-top: 0.5rem; 
            border-collapse: collapse;
            color: #ecf0f1;
            display: none; 
        }
        .tg_timetableTable_styles th, 
        .tg_timetableTable_styles td {
            border: 1px solid #4A5568;
            padding: 6px 8px; 
            text-align: left;
            font-size: 0.85em; 
        }
        .tg_timetableTable_styles th {
            background-color: #34495e;
            color: white;
            font-weight: 500;
        }
        .tg_timetableTable_styles tbody tr:nth-child(odd) {
            background-color: rgba(0,0,0,0.05); 
        }
        .tg_timetableTable_styles tbody tr:nth-child(even) {
            background-color: rgba(0,0,0,0.1);
        }
        .tg_timetablePlaceholder_styles {
             text-align: center; 
             opacity: 0.7; 
             padding: 1rem;
             font-size: 0.9em;
             display: block; 
        }
        .timetable-category-section { 
            margin-top: 1rem; 
            padding: 0.75rem; 
        }
        /* END: Styles for Timetable Generator */

        /* Styles for Operating Profiles Viewer (including 3-column layout for reference list) */
        #uniqueOperatingProfilesListContainer,
        #referenceOperatingProfilesListContainer { /* Shared styles for both list containers */
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            padding: 0.75rem;
            margin-top: 1rem;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.05);
        }

        #uniqueOperatingProfilesUL { /* Discovered profiles - standard list */
            list-style: disc;
            padding-left: 20px;
        }
        #uniqueOperatingProfilesUL li {
            padding-bottom: 0.2em; /* Spacing for single column list */
        }

        /* NEW: Styles for 3-column reference list */
        #referenceOperatingProfilesUL {
            list-style: disc; /* Retain disc for now, can be changed */
            padding-left: 20px; /* Space for the bullets if list-style is disc */
            margin: 0; /* Reset default ul margin */
            column-count: 3;
            column-gap: 25px; /* Space between columns */
            -webkit-column-count: 3;
            -moz-column-count: 3;
        }
        #referenceOperatingProfilesUL li {
            padding-bottom: 0.3em; /* Spacing between items in columns */
            break-inside: avoid-column; /* Attempt to keep items from splitting across columns */
            page-break-inside: avoid;
            -webkit-column-break-inside: avoid;
        }
        /* END: Styles for Operating Profiles Viewer */


        /* For screen-reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    </style>
</head>
<body>
    <div class="page-container">
        <h1>OMSI Tools</h1>

        <div id="auth-section" class="section">
            <h2>Admin Login</h2>
            <div id="login-form-container">
                <form id="adminLoginForm">
                    <div class="form-grid" style="grid-template-columns: 1fr;">
                        <div><label for="inputEmail">Email</label><input type="email" id="inputEmail" autocomplete="email"></div>
                        <div><label for="inputPassword">Password</label><input type="password" id="inputPassword" autocomplete="current-password"></div>
                    </div>
                    <button id="loginButton" type="submit" class="button">Login</button>
                </form>
                <p id="auth-status" style="margin-top: 0.5em; color: #f1c40f;"></p>
            </div>
            <div id="logout-container" style="display:none;">
                <p>Logged in as: <span id="loggedInUserEmail"></span></p>
                <button id="logoutButton" class="button secondary">Logout</button>
            </div>
        </div>

        <div id="current-profile-display-container" class="section"> <p id="current-profile-display">Today's Operating Profile: (loading...)</p>
        </div>

        <div id="top-menu-bar">
            <div id="main-menu-buttons">
                <button class="menu-button" data-section="bulk-edit-tools-section">Bulk Edit & Colours</button>
                <button class="menu-button" data-section="view-departures-section">View Departures</button>
                <button class="menu-button" data-section="schedule-generator-section">Schedule Generator & Copier</button>
                <button class="menu-button" data-section="route-timetable-overwrite-section">Route Timetable Overwrite</button>
                <button class="menu-button" data-section="operating-profiles-section">View Operating Profiles</button>
                <button class="menu-button" data-section="analytics-validation-section">Analytics & Validation</button>
                <button class="menu-button" data-section="route-stops-explorer-section">Route Stops Explorer</button>
                <button class="menu-button" data-section="timetable-generator-section">Timetable Generator</button>
                <button class="menu-button" data-section="deployment-tools-section">Deployment & Upload</button>
            </div>
        </div>

        <div id="tool-sections-wrapper">

            <div id="timetable-generator-section" class="tool-content-section section">
                <h2>Timetable Generator</h2>
                <p style="opacity:0.8; margin-bottom:1.5rem; font-size:0.9em;">
                    Select a route and primary direction to view categorized service timetables.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">1. Select Route and Primary Direction</h3>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div>
                            <label for="tg_selectRoute">Route:</label>
                            <select id="tg_selectRoute" class="schedule-generator-select">
                                <option value="">-- Select Route --</option>
                            </select>
                        </div>
                        <div>
                            <label for="tg_selectDirection">Primary Destination / Direction:</label>
                            <select id="tg_selectDirection" class="schedule-generator-select">
                                <option value="">-- Select Route First --</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="subsection"> <h3 class="subsection-title">2. Categorized Timetables</h3>
                    <div id="tg_timetableDisplayContainer">
                        <div class="subsection timetable-category-section">
                            <h4 data-table-for="tg_fullJourneyTableBody_tools" data-default-title="Full Journeys">Full Journeys</h4>
                            <table id="tg_fullJourneyTable_tools" class="tg_timetableTable_styles">
                                <thead id="tg_fullJourneyTableHead_tools"></thead>
                                <tbody id="tg_fullJourneyTableBody_tools"></tbody>
                            </table>
                            <p id="tg_fullJourneyPlaceholder_tools" class="tg_timetablePlaceholder_styles">Select route and direction.</p>
                        </div>

                        <div class="subsection timetable-category-section" style="margin-top:1.5rem;">
                            <h4 data-table-for="tg_shortJourneyTableBody_tools" data-default-title="Short Journeys">Short Journeys</h4>
                            <table id="tg_shortJourneyTable_tools" class="tg_timetableTable_styles">
                                <thead id="tg_shortJourneyTableHead_tools"></thead>
                                <tbody id="tg_shortJourneyTableBody_tools"></tbody>
                            </table>
                            <p id="tg_shortJourneyPlaceholder_tools" class="tg_timetablePlaceholder_styles">Select route and direction.</p>
                        </div>

                        <div class="subsection timetable-category-section" style="margin-top:1.5rem;">
                            <h4 data-table-for="tg_diversionJourneyTableBody_tools" data-default-title="Diversions / School Journeys">Diversions / School Journeys</h4>
                            <table id="tg_diversionJourneyTable_tools" class="tg_timetableTable_styles">
                                <thead id="tg_diversionJourneyTableHead_tools"></thead>
                                <tbody id="tg_diversionJourneyTableBody_tools"></tbody>
                            </table>
                            <p id="tg_diversionJourneyPlaceholder_tools" class="tg_timetablePlaceholder_styles">Select route and direction.</p>
                        </div>
                    </div>
                    <p id="tg_statusMessage" style="min-height:1.2em; margin-top: 0.75rem; font-weight:bold; text-align:center;"></p>
                </div>
            </div>
            
            <div id="route-stops-explorer-section" class="tool-content-section section">
                <h2>Route Stops Explorer</h2>
                <p style="opacity:0.8; margin-bottom:1.5rem; font-size:0.9em;">
                    Select a route to view the sequence of stops it serves in each direction.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">1. Select Route</h3>
                    <div class="form-grid">
                        <div>
                            <label for="rse_selectRoute">Route (LineName):</label>
                            <select id="rse_selectRoute" class="schedule-generator-select">
                                <option value="">-- Select Route --</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="subsection">
                    <h3 class="subsection-title">2. Stops Served</h3>
                    <div class="route-stops-columns-container">
                        <div id="rse_direction1_container" class="route-stops-column">
                            <h4 id="rse_direction1_title">Direction 1: (Select Route)</h4>
                            <ul id="rse_direction1_stopsList">
                            </ul>
                            <p id="rse_direction1_placeholder">Select a route to view stops.</p>
                        </div>
                        <div id="rse_direction2_container" class="route-stops-column">
                            <h4 id="rse_direction2_title">Direction 2: (Select Route)</h4>
                            <ul id="rse_direction2_stopsList">
                            </ul>
                             <p id="rse_direction2_placeholder">Select a route to view stops.</p>
                        </div>
                    </div>
                </div>
                 <p id="rse_statusMessage" style="min-height:1.2em; margin-top: 0.75rem; font-weight:bold; text-align:center;"></p>
            </div>

            <div id="route-timetable-overwrite-section" class="tool-content-section section">
                <h2>Route Timetable Overwrite</h2>
                <p style="opacity:0.8; margin-bottom:1.5rem; font-size:0.9em;">
                    This tool replaces all scheduled times for a selected route, operating profile, and (optionally) specific destination with new timetable data from an uploaded file.
                    The uploaded file should be in .COUNT or .txt format. It's best if the file only contains data for the exact route, profile, and destination you intend to replace.
                    The tool will filter the uploaded data to only use entries matching your selections.
                </p>

                <div class="subsection">
                    <h3 class="subsection-title">1. Select Target for Timetable Overwrite</h3>
                    <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));">
                        <div>
                            <label for="rto_selectRoute">Route:</label>
                            <select id="rto_selectRoute" class="schedule-generator-select">
                                <option value="">-- Select Route --</option>
                            </select>
                        </div>
                        <div>
                            <label for="rto_selectProfile">Operating Profile:</label>
                            <select id="rto_selectProfile" class="schedule-generator-select">
                                <option value="">-- Select Route First --</option>
                            </select>
                        </div>
                        <div>
                            <label for="rto_selectDestination">Destination (Optional - for specific direction):</label>
                            <select id="rto_selectDestination" class="schedule-generator-select">
                                <option value="">-- All Destinations for Route / Profile --</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">2. Upload New Timetable File</h3>
                    <div style="margin-top: 1rem; margin-bottom: 1rem;">
                        <label for="rto_fileInput" class="file-upload-label">Choose New Timetable File (.COUNT, .txt)</label>
                        <input type="file" id="rto_fileInput" accept=".COUNT,.txt" style="display: none;">
                        <p id="rto_fileStatus" style="font-size: 0.9rem; margin-top: 0.25rem; opacity: 0.9; min-height: 1.2em;">No file selected.</p>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">3. Execute Overwrite</h3>
                    <button id="rto_overwriteButton" class="button tertiary" style="padding: 0.7rem 1.5rem;">Overwrite Timetable for Selected Criteria</button>
                    <p id="rto_statusMessage" style="min-height:1.2em; margin-top: 0.75rem; font-weight:bold;"></p>
                </div>
            </div>

            <div id="operating-profiles-section" class="tool-content-section section">
                <h2>Unique Operating Profiles Viewer</h2>
                <p style="opacity:0.8; margin-bottom:1.5rem; font-size:0.9em;">
                    This tool lists all unique "OperatingProfile" strings currently found in your working schedule.
                    Below that is a reference list of all conventionally defined profile strings.
                </p>

                <div class="subsection">
                    <h3 class="subsection-title">Discovered Operating Profiles (from current data)</h3>
                    <button id="refreshOperatingProfilesButton" class="button" style="margin-bottom: 1rem;">Refresh Lists</button>
                    <p id="operatingProfilesStatusMessage" style="min-height:1.2em; margin-bottom: 0.75rem; font-style: italic;"></p>
                    <div id="uniqueOperatingProfilesListContainer"> <ul id="uniqueOperatingProfilesUL">
                        </ul>
                    </div>
                </div>

                <div class="subsection" style="margin-top: 2rem;">
                    <h3 class="subsection-title">Reference List of All Profile Strings</h3>
                    <div id="referenceOperatingProfilesListContainer"> <ul id="referenceOperatingProfilesUL">
                        </ul>
                    </div>
                </div>
            </div>

            <div id="bulk-edit-tools-section" class="tool-content-section section"> <h2 style="margin-bottom:1rem;">Bulk Edit Tools & Colour Management</h2> <div class="subsection bulk-edit-route-destination"> <h3 class="subsection-title">Update Destination for a Route</h3>
                    <div class="form-grid" style="grid-template-columns: 1fr 1.5fr 1.5fr auto; align-items:end; gap: 0.75rem;">
                        <div><label for="bulkEditTargetLineName">Target Line</label><input type="text" id="bulkEditTargetLineName" placeholder="e.g., 186" autocomplete="off"></div>
                        <div><label for="bulkEditOldDestination">Old Destination (optional)</label><input type="text" id="bulkEditOldDestination" placeholder="Blank to update all" autocomplete="off"></div>
                        <div><label for="bulkEditNewDestination">New Destination</label><input type="text" id="bulkEditNewDestination" placeholder="New destination" autocomplete="off"></div>
                        <div style="padding-bottom:0.05rem;"><button id="bulkUpdateRouteDestinationButton" class="button">Update Destination</button></div>
                    </div>
                </div>

                <div class="subsection route-colour-management-subsection"> <h3 class="subsection-title">Global Route Tile Colour Management</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">Define global custom colours for routes. These apply unless a stop-specific colour is set.</p>
                    <div class="form-grid" style="grid-template-columns: 1.5fr 1fr auto auto auto auto auto; align-items: end; gap: 0.75rem;">
                        <div><label for="selectRouteNameColour">Route Name</label><select id="selectRouteNameColour"><option value="">-- Select Route --</option></select></div>
                        <div><label for="inputRouteColour">Select Colour</label><input type="color" id="inputRouteColour" value="#73809C" autocomplete="off"></div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #73809C; color: #FFFFFF;">Day Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #4CDBE6; color: #000000;">24 Hr / Night Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #AC5099; color: #FFFFFF;">School Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #CBC51A; color: #000000;">Rail Replacement</button>
                        </div>
                        <div style="padding-bottom:0.05rem;"><button id="saveRouteColourButton" class="button">Save Global Colour</button></div>
                    </div>
                    <div id="currentRouteColoursListContainer"><h3 class="subsection-title" style="font-size: 1.1rem; margin-bottom: 0.5rem;">Current Global Custom Colours</h3><ul id="currentRouteColoursList"></ul><p id="noCustomColoursMessage">No global custom colours set.</p></div>
                    <p id="routeColourStatusMessage" style="min-height:1.2em;"></p>
                </div>

                <div class="subsection stop-specific-route-colour-subsection"> <h3 class="subsection-title">Stop-Specific Route Tile Colours</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">Override global route colours for specific stops.</p>
                    <div>
                        <label for="selectStopForSpecificRouteColour">1. Select Stop:</label>
                        <select id="selectStopForSpecificRouteColour" class="schedule-generator-select">
                            <option value="">-- Select Stop --</option>
                        </select>
                    </div>
                    <div>
                        <label>2. Select Route(s) at this stop to colour (click one to enable delete option below):</label>
                        <div id="specificRouteColourTilesContainer">
                            <p id="specificRouteColourTilesPlaceholder">Select a stop to see its routes.</p>
                        </div>
                    </div>
                    <div style="margin-top: 0.5rem; margin-bottom: 1rem;">
                        <button id="deleteRouteFromStopButton" class="button secondary" style="display: none;">Delete Selected Route from This Stop</button>
                        <p id="deleteRouteFromStopStatusMessage" style="min-height:1.2em; margin-top:0.5rem; font-size:0.85em;"></p>
                    </div>

                    <div class="form-grid" style="grid-template-columns: 1fr auto auto auto auto auto; align-items:end; gap:0.75rem; margin-top:0.5rem;">
                        <div>
                            <label for="inputStopSpecificRouteColour">3. Select Colour:</label>
                            <input type="color" id="inputStopSpecificRouteColour" value="#73809C">
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #73809C; color: #FFFFFF;">Day Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #4CDBE6; color: #000000;">24 Hr / Night Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #AC5099; color: #FFFFFF;">School Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #CBC51A; color: #000000;">Rail Replacement</button>
                        </div>
                        <div style="padding-bottom:0.05rem;">
                            <button id="saveStopSpecificRouteColourButton" class="button tertiary">Save Colour for Selected Route(s) at this Stop</button>
                        </div>
                    </div>
                    <p id="stopSpecificRouteColourStatusMessage" style="min-height:1.2em; margin-top:0.5rem;"></p>

                    <div id="currentStopSpecificColoursListContainer">
                        <h3 class="subsection-title" style="font-size: 1.1rem; margin-bottom: 0.5rem;">Current Stop-Specific Colour Overrides</h3>
                        <div id="currentStopSpecificColoursList">
                            <p id="noStopSpecificColoursMessage">No stop-specific colours are currently set.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div id="view-departures-section" class="tool-content-section section"> <h2 style="margin-bottom:1rem;">View Departures</h2> <div class="subsection view-stop-departures"> <h3 class="subsection-title">Scheduled Departures by Stop</h3>
                    <div class="form-grid" style="grid-template-columns: 1fr 2fr; align-items: start; gap: 1.5rem;">
                        <div><label for="selectStopForDeparturesView">Bus Stop</label><select id="selectStopForDeparturesView"><option value="">-- Select Stop --</option></select></div>
                        <div><label>Departures (Sorted by Day Offset -> Profile Day -> Time)</label><div id="stopDeparturesListContainer" style="max-height: 400px; overflow-y: auto; border: 1px solid #4A5568; padding: 0.5rem; border-radius: 0.25rem;"><ul id="stopDeparturesList"></ul><p id="noDeparturesForStopMessage">Select stop to view.</p></div></div>
                    </div>
                </div>
            </div>

            <div id="schedule-generator-section" class="tool-content-section section">
                <h2>Transit Schedule Generator & Copier</h2>
                <p style="opacity:0.8; margin-bottom:1rem;">Create, export, copy, and adjust transit schedules.</p>
                <div class="subsection">
                    <h3 class="subsection-title">Base Data (First Entry for Generation)</h3>
                    <div class="form-field-group">
                        <label for="gen_stopNameSelect">Select Stop:</label>
                        <select id="gen_stopNameSelect" class="schedule-generator-select">
                            <option value="">-- Loading Stops --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label for="gen_stopId">Stop ID (auto-filled from selection):</label>
                        <input type="text" id="gen_stopId" class="schedule-generator-input" placeholder="" readonly>
                    </div>
                    <div class="gen_input-group">
                        <div>
                            <label for="gen_stopName">Stop Name (auto-filled from selection):</label>
                            <input type="text" id="gen_stopName" class="schedule-generator-input" placeholder="" readonly>
                        </div>
                        <div>
                            <label for="gen_direction">Direction (auto-filled from selection):</label>
                            <input type="text" id="gen_direction" class="schedule-generator-input" placeholder="" readonly>
                        </div>
                    </div>
                    <div class="form-field-group">
                        <label for="gen_routeSelect">Select Existing Route (populates Line Name below):</label>
                        <select id="gen_routeSelect" class="schedule-generator-select">
                            <option value="">-- Select Existing Route --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label for="gen_lineName">Route (Type new or select above):</label>
                        <input type="text" id="gen_lineName" class="schedule-generator-input" placeholder="e.g., 12, N35 or type a new route"autocomplete="off">
                    </div>
                    <div class="form-field-group">
                        <label for="gen_destinationSelect">Select Existing Destination (for chosen Route):</label>
                        <select id="gen_destinationSelect" class="schedule-generator-select">
                            <option value="">-- Enter / Select Route First --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label for="gen_destinationName">Destination Name (type new or select above):</label>
                        <input type="text" id="gen_destinationName" class="schedule-generator-input" placeholder="e.g., Amcotts or type a new destination"autocomplete="off">
                    </div>
                    <div class="gen_input-group">
                        <div>
                            <label for="gen_operatingProfile">Operating Days:</label>
                            <input type="text" id="gen_operatingProfile" class="schedule-generator-input" placeholder="e.g., MF or Su"autocomplete="off">
                        </div>
                        <div>
                            <label for="gen_initialScheduledTime">Scheduled Time (HHMM):</label>
                            <input type="text" id="gen_initialScheduledTime" class="schedule-generator-input" placeholder="e.g., 0845">
                        </div>
                        <div>
                            <label for="gen_initialDayOffset">Day Offset:</label>
                            <input type="number" id="gen_initialDayOffset" class="schedule-generator-input" min="0" value="0" placeholder="0"autocomplete="off">
                        </div>
                    </div>
                </div>
                <div class="subsection">
                    <h3 class="subsection-title">Interval Definitions for Additional Entries (Generation)</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.5rem;">
                        <strong>Day Offset Logic for Generated Times:</strong><br>
                        - If an interval rule starts <em>before</em> midnight (e.g., at 22:00) and generates times that cross into the 00:00-03:59 window, those specific post-midnight times get <code>DayOffset = 1</code>.<br>
                        - If an interval rule itself starts <em>at or after</em> midnight (e.g., "00:15", "01:00", up to "03:59"), all times it generates get <code>DayOffset = 0</code>.<br>
                        - All other generated times get <code>DayOffset = 0</code>.
                    </p>
                    <div id="gen_intervalRulesContainer"> </div>
                    <button id="gen_addIntervalRuleButton" class="button" style="margin-top:10px;">+ Add Interval Rule</button>
                </div>
                <div class="subsection" id="schedule-copier-subsection-sg">
                    <h3 class="subsection-title">Copy & Adjust Schedules (from Working Schedule)</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        Select a source stop from the current working schedule, choose routes, copy, then select a target stop, adjust times, and paste the new entries back into the main working schedule.
                    </p>
                    <div class="form-field-group">
                        <label for="sgCopierSourceStopSelect">1. Source Stop:</label>
                        <select id="sgCopierSourceStopSelect" class="schedule-generator-select">
                            <option value="">-- Select Source Stop --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label>2. Routes serving Source Stop (click tiles to select / deselect for copying):</label>
                        <div id="sgCopierSourceRoutesContainer">
                            <p id="sgCopierSourceRoutesPlaceholder">Select a source stop to see routes.</p>
                        </div>
                    </div>
                    <button id="sgCopierCopySchedulesButton" class="button" style="margin-top: 0.5rem; margin-bottom:1rem;">Copy Selected Schedules from Source</button>
                    <hr style="margin: 1.5rem 0; border-color: rgba(255,255,255,0.1);">
                    <div class="form-field-group">
                        <label for="sgCopierTargetStopSelect">3. Target Stop:</label>
                        <select id="sgCopierTargetStopSelect" class="schedule-generator-select">
                            <option value="">-- Select Target Stop --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label for="sgCopierTimeAdjustmentInput">4. Time Adjustment (minutes, e.g., 5 or -10):</label>
                        <input type="text" id="sgCopierTimeAdjustmentInput" class="schedule-generator-input" placeholder="e.g., 5 or -10" value="0">
                    </div>
                    <button id="sgCopierPasteSchedulesButton" class="button tertiary" style="margin-top: 0.5rem;">Paste Schedules to Target Stop (in Working Schedule)</button>
                    <div id="sgCopierStatusMessage" style="margin-top: 1rem; padding: 0.5rem; background-color: rgba(0,0,0,0.08); border-radius: 0.25rem; min-height: 1.5em; text-align: center;">
                        Status will appear here.
                    </div>
                </div>

                <div class="subsection">
                    <div class="gen_action-buttons">
                        <button id="gen_generateScheduleButton" class="button">Generate Schedule</button>
                        <button id="gen_exportToCountButton" class="button" style="background-color: #27ae60;">Export to .COUNT</button>
                        <button id="gen_addToWorkingScheduleButton" class="button" style="background-color: #1abc9c;">Add Generated to Working Schedule</button>
                        <button id="gen_getWorkingScheduleButton" class="button" style="background-color: #9b59b6;">Load Full Schedule to Generator Table</button>
                        <button id="gen_loadStopScheduleButton" class="button" style="background-color: #34495e;">Load Selected Stop's Schedule to Table</button>
                        <button id="gen_clearAllDataButton" class="button secondary">Clear All Generator Data & Table</button>
                    </div>
                    <h3 class="subsection-title" style="margin-top:1.5rem;">Generated Schedule / Loaded Data Table</h3>
                    <div style="max-height: 400px; overflow-y: auto;">
                        <table id="gen_resultsTable">
                            <thead>
                                <tr>
                                    <th>Stop ID</th><th>StopName</th><th>Direction</th><th>Route</th><th>Destination</th><th>Scheduled Time (HH:MM)</th><th>OperatingProfile</th><th>DayOffset</th><th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
                <div class="gen_footer-note">
                    <p>Generator data (base data, intervals, table content) is saved in your browser's local storage. Copied schedules are added directly to the main "Working Schedule".</p>
                </div>
            </div>

            <div id="deployment-tools-section" class="tool-content-section section"> <h2 style="margin-bottom:1rem;">Deployment & File Upload</h2> <div class="subsection count-file-upload"> <h3 class="subsection-title">Upload Full Schedule</h3>
                    <p style="font-size:0.8em; margin-bottom:0.5em;">Replaces current working schedule. Ensure file has correct headers: StopID, StopName, Direction, LineName, DestinationName, ScheduledTime, OperatingProfile, DayOffset.</p>
                    <label for="count-file-input" class="file-upload-label">Choose .COUNT or .txt File</label>
                    <input type="file" id="count-file-input" accept=".COUNT,.txt" style="display: none;">
                    <p id="file-status">No file selected.</p>
                </div>
                <div class="subsection actions-section"> <h3 class="subsection-title">Schedule Deployment Actions</h3>
                    <div id="stagingStatusMessage" style="min-height:1.2em;">Checking status...</div>
                    <button id="stageScheduleButton" class="button">Stage Working Schedule</button>
                    <button id="applyNowButton" class="button tertiary">Apply Staged Live NOW</button>
                    <hr style="margin: 1.5rem 0; border-color: rgba(255,255,255,0.1);">
                    <button id="viewArrivalsButton" class="button">View Arrivals Board</button>
                </div>
            </div>

            <div id="analytics-validation-section" class="tool-content-section section"> <h2 style="margin-bottom:1rem;">Schedule Analytics & Validation</h2> <div class="subsection analytics-subsection">
                    <h3 class="subsection-title">Duplicate Entry Detection</h3>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <button id="detectDuplicatesButton" class="button">Find Duplicate Entries</button>
                        <button id="removeDuplicateEntriesButton" class="button secondary">Remove All Duplicates (Keep First)</button>
                    </div>
                    <p id="removeDuplicatesStatusMessage" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                    <div id="duplicateEntriesResults" style="margin-top: 0.75rem;">
                        <p>Click "Find Duplicate Entries" to scan the current working schedule.</p>
                    </div>
                </div>
                <div class="subsection">
                    <h3 class="subsection-title">Consolidate Operating Days for Route at Stop</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        Select a stop and a route. This tool will find entries with the same time, destination, and day offset, and consolidate their Operating Profiles into one entry, removing the redundant ones.
                    </p>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr 1fr auto; align-items: end; gap: 0.75rem;">
                        <div>
                            <label for="consolidateStopSelect">Select Stop ID:</label>
                            <select id="consolidateStopSelect" class="schedule-generator-select"></select>
                        </div>
                        <div>
                            <label for="consolidateRouteSelect">Select Route:</label>
                            <select id="consolidateRouteSelect" class="schedule-generator-select"></select>
                        </div>
                        <div>
                            <label for="consolidateNewProfileInput">New Combined Operating Profile:</label>
                            <input type="text" id="consolidateNewProfileInput" class="schedule-generator-input" placeholder="e.g., MF,Sa,Su">
                        </div>
                        <div style="padding-bottom:0.05rem;">
                            <button id="consolidateOperatingDaysButton" class="button tertiary">Consolidate</button>
                        </div>
                    </div>
                    <p id="consolidateOpDaysStatusMessage" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                </div>
            </div>

        </div> </div> </body>
<script type="module">
      // Firebase App initialization
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s", // Replace with your actual Firebase API Key
        authDomain: "omsi-c5505.firebaseapp.com", // Replace with your actual Firebase Auth Domain
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app", // Replace with your actual Firebase Database URL
        projectId: "omsi-c5505", // Replace with your actual Firebase Project ID
        storageBucket: "omsi-c5505.appspot.com", // Replace with your actual Firebase Storage Bucket
        messagingSenderId: "503595375440", // Replace with your actual Firebase Messaging Sender ID
        appId: "1:503595375440:web:356be6684b77ff5909ea55", // Replace with your actual Firebase App ID
        measurementId: "G-VN7X65V3F9" // Replace with your actual Firebase Measurement ID
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);

      window.firebaseOMSI = {
          database: database, auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut
      };
      console.log("Firebase Initialized for OMSI Tools.");
document.dispatchEvent(new CustomEvent('firebaseReady', { detail: window.firebaseOMSI }));
</script>

<script>  

// --- DOM Elements ---
const countFileInput = document.getElementById('count-file-input');
const fileStatusElement = document.getElementById('file-status');
const currentProfileDisplayContainer = document.getElementById('current-profile-display-container');
const currentProfileDisplayElement = document.getElementById('current-profile-display');

const refreshOperatingProfilesButton = document.getElementById('refreshOperatingProfilesButton');
const operatingProfilesStatusMessage = document.getElementById('operatingProfilesStatusMessage');
const uniqueOperatingProfilesUL = document.getElementById('uniqueOperatingProfilesUL');

const bulkEditTargetLineNameInput = document.getElementById('bulkEditTargetLineName');
const bulkEditOldDestinationInput = document.getElementById('bulkEditOldDestination');
const bulkEditNewDestinationInput = document.getElementById('bulkEditNewDestination');
const bulkUpdateRouteDestinationButton = document.getElementById('bulkUpdateRouteDestinationButton');

const rto_selectRoute = document.getElementById('rto_selectRoute');
const rto_selectProfile = document.getElementById('rto_selectProfile');
const rto_selectDestination = document.getElementById('rto_selectDestination');
const rto_fileInput = document.getElementById('rto_fileInput');
const rto_fileStatus = document.getElementById('rto_fileStatus');
const rto_overwriteButton = document.getElementById('rto_overwriteButton');
const rto_statusMessage = document.getElementById('rto_statusMessage');

const stageScheduleButton = document.getElementById('stageScheduleButton');
const applyNowButton = document.getElementById('applyNowButton');
const viewArrivalsButton = document.getElementById('viewArrivalsButton');
const stagingStatusMessage = document.getElementById('stagingStatusMessage');

const selectRouteNameColour = document.getElementById('selectRouteNameColour');
const inputRouteColour = document.getElementById('inputRouteColour');
const saveRouteColourButton = document.getElementById('saveRouteColourButton');
const currentRouteColoursList = document.getElementById('currentRouteColoursList');
const noCustomColoursMessage = document.getElementById('noCustomColoursMessage');
const routeColourStatusMessage = document.getElementById('routeColourStatusMessage');

const selectStopForSpecificRouteColour = document.getElementById('selectStopForSpecificRouteColour');
const specificRouteColourTilesContainer = document.getElementById('specificRouteColourTilesContainer');
const specificRouteColourTilesPlaceholder = document.getElementById('specificRouteColourTilesPlaceholder');
const inputStopSpecificRouteColour = document.getElementById('inputStopSpecificRouteColour');
const saveStopSpecificRouteColourButton = document.getElementById('saveStopSpecificRouteColourButton');
const stopSpecificRouteColourStatusMessage = document.getElementById('stopSpecificRouteColourStatusMessage');
const currentStopSpecificColoursListContainer = document.getElementById('currentStopSpecificColoursListContainer');
const currentStopSpecificColoursList = document.getElementById('currentStopSpecificColoursList');
const noStopSpecificColoursMessageEl = document.getElementById('currentStopSpecificColoursListContainer')?.querySelector('#noStopSpecificColoursMessage');

const deleteRouteFromStopButton = document.getElementById('deleteRouteFromStopButton');
const deleteRouteFromStopStatusMessage = document.getElementById('deleteRouteFromStopStatusMessage');

const selectStopForDeparturesView = document.getElementById('selectStopForDeparturesView');
const stopDeparturesList = document.getElementById('stopDeparturesList');
const noDeparturesForStopMessage = document.getElementById('noDeparturesForStopMessage');

const topMenuBar = document.getElementById('top-menu-bar');
const adminLoginSection = document.getElementById('auth-section');
const loginFormContainer = document.getElementById('login-form-container');
const logoutContainer = document.getElementById('logout-container');
const loginButton = document.getElementById('loginButton');
const logoutButton = document.getElementById('logoutButton');
const inputEmail = document.getElementById('inputEmail');
const inputPassword = document.getElementById('inputPassword');
const authStatus = document.getElementById('auth-status');
const loggedInUserEmailDisplay = document.getElementById('loggedInUserEmail');
const mainMenuButtons = document.querySelectorAll('#main-menu-buttons .menu-button');
const allToolContentSections = document.querySelectorAll('.tool-content-section');

const detectDuplicatesButton = document.getElementById('detectDuplicatesButton');
const duplicateEntriesResults = document.getElementById('duplicateEntriesResults');
const removeDuplicateEntriesButton = document.getElementById('removeDuplicateEntriesButton');
const removeDuplicatesStatusMessage = document.getElementById('removeDuplicatesStatusMessage');

const consolidateStopSelect = document.getElementById('consolidateStopSelect');
const consolidateRouteSelect = document.getElementById('consolidateRouteSelect');
const consolidateNewProfileInput = document.getElementById('consolidateNewProfileInput');
const consolidateOperatingDaysButton = document.getElementById('consolidateOperatingDaysButton');
const consolidateOpDaysStatusMessage = document.getElementById('consolidateOpDaysStatusMessage');

const sgCopierSourceStopSelect = document.getElementById('sgCopierSourceStopSelect');
const sgCopierSourceRoutesContainer = document.getElementById('sgCopierSourceRoutesContainer');
const sgCopierSourceRoutesPlaceholder = document.getElementById('sgCopierSourceRoutesPlaceholder');
const sgCopierCopySchedulesButton = document.getElementById('sgCopierCopySchedulesButton');
const sgCopierTargetStopSelect = document.getElementById('sgCopierTargetStopSelect');
const sgCopierTimeAdjustmentInput = document.getElementById('sgCopierTimeAdjustmentInput');
const sgCopierPasteSchedulesButton = document.getElementById('sgCopierPasteSchedulesButton');
const sgCopierStatusMessage = document.getElementById('sgCopierStatusMessage');

const rse_selectRoute = document.getElementById('rse_selectRoute');
const rse_direction1_container = document.getElementById('rse_direction1_container');
const rse_direction1_title = document.getElementById('rse_direction1_title');
const rse_direction1_stopsList = document.getElementById('rse_direction1_stopsList');
const rse_direction1_placeholder = document.getElementById('rse_direction1_placeholder');
const rse_direction2_container = document.getElementById('rse_direction2_container');
const rse_direction2_title = document.getElementById('rse_direction2_title');
const rse_direction2_stopsList = document.getElementById('rse_direction2_stopsList');
const rse_direction2_placeholder = document.getElementById('rse_direction2_placeholder');
const rse_statusMessage = document.getElementById('rse_statusMessage');

// ADDED/MODIFIED: DOM Elements for Timetable Generator
const tg_selectRoute = document.getElementById('tg_selectRoute');
const tg_selectDirection = document.getElementById('tg_selectDirection');
const tg_timetableTableBody = document.getElementById('tg_timetableTable')?.getElementsByTagName('tbody')[0];
const tg_timetablePlaceholder = document.getElementById('tg_timetablePlaceholder');
const tg_statusMessage = document.getElementById('tg_statusMessage');


// --- Global State ---
let currentUser = null;
let currentWorkingSchedule = [];
let ukBankHolidaysData = { dates: [], titles: {} };
const schoolHolidayDateRanges = [
    { start: '2025-05-24', end: '2025-06-01' }, // Summer half term 2025
    { start: '2025-07-19', end: '2025-09-02' }, // Summer holidays 2025
    { start: '2025-10-25', end: '2025-11-02' }, // Autumn half term 2025
    { start: '2025-12-20', end: '2026-01-04' }, // Christmas 2025/26
    { start: '2026-02-14', end: '2026-02-22' }, // Spring half term 2026
    { start: '2026-04-03', end: '2026-04-20' }, // Easter 2026
    { start: '2026-05-23', end: '2026-05-31' }, // Summer half term 2026
    { start: '2026-07-18', end: '2026-09-02' }, // Summer holidays 2026
    { start: '2026-10-24', end: '2026-11-01' }, // Autumn half term 2026
    { start: '2026-12-19', end: '2027-01-04' }, // Christmas 2026/27
    { start: '2027-02-13', end: '2027-02-21' }, // Spring half term 2027
    { start: '2027-03-26', end: '2027-04-13' }, // Easter 2027
    { start: '2027-05-29', end: '2027-06-06' }, // Summer half term 2027
    { start: '2027-07-22', end: '2027-08-31' }  // Summer holidays 2027 (END DATE TBC)
];
const VALID_OPERATING_PROFILE_CODES_FOR_TOOLS = [
    "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su",
    "MF",
    "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MFSch",
    "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MFNSD",
    "Christmas Day", "Boxing Day", "New Years Day"
    ];
let closedStopIDs = [];
let globalCustomRouteColours = {};
let stopSpecificRouteColours = {};
let autoApplyIntervalId = null;
let copiedScheduleEntries = [];

// --- Constants ---
const LOCAL_STORAGE_ACTIVE_SECTION_KEY = 'omsiToolsActiveSection';
const FB_PATH_LIVE_SCHEDULE_DATA = '/liveSchedule/schedulesByRoute';
const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
const FB_PATH_PENDING_SCHEDULE_DATA = '/pendingSchedule/schedulesByRoute';
const FB_PATH_PENDING_UNIQUE_STOPS = '/pendingSchedule/uniqueBusStops';
const FB_PATH_PENDING_TIMESTAMP = '/pendingSchedule/uploadTimestamp';
const FB_PATH_APPSTATE_STATUS = '/appState/scheduleStatus';
const FB_PATH_APPSTATE_LAST_UPDATED = '/appState/scheduleLastUpdated';
const FB_PATH_APPSTATE_CLOSED_STOPS = '/appState/closedStopIDs';
const FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS = '/settings/customRouteColours';
const FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS = '/settings/stopSpecificRouteColours';

const initialRouteColourMapForTools = {};
const DEFAULT_ROUTE_COLOUR_TOOLS = "#73809C";
const NIGHT_BUS_BLUE_COLOR = (initialRouteColourMapForTools["N35"] || "#4CDBE6").toUpperCase();
const DAY_BUS_GREY_COLOR = DEFAULT_ROUTE_COLOUR_TOOLS.toUpperCase();

function toTitleCase_display(str) {
    if (!str || typeof str !== 'string') return "";
    return str.toLowerCase().split(' ').map(function(word) {
        if (word.length > 0) {
            // Handle special cases like "Year's" correctly
            if (word.includes("'")) {
                const parts = word.split("'");
                parts[0] = parts[0].charAt(0).toUpperCase() + parts[0].substring(1);
                return parts.join("'");
            }
            return word.charAt(0).toUpperCase() + word.substring(1);
        }
        return "";
    }).join(' ');
}

function sanitizeFirebaseKey(text) {
    if (typeof text !== 'string') return '';
    return text.replace(/[.#$[\]]/g, '_');
}

// --- START: Schedule Generator (from COUNT_generator.html) ---
let gen_ruleCounter = 0;
let gen_currentScheduleEntries = [];
const GEN_APP_DATA_KEY = 'transitScheduleAppData_tools_v1';
let gen_isInitialized = false;

let rto_uploadedScheduleData = [];

// --- START: Schedule Generator Population & Interaction ---
function gen_populateStopNameSelect() {
    const selectEl = document.getElementById('gen_stopNameSelect');
    if (!selectEl) return;

    const previouslySelectedStopId = selectEl.value;
    selectEl.innerHTML = '<option value="">-- Select Stop --</option>';

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        selectEl.innerHTML = '<option value="">-- No Stops Loaded --</option>';
        const stopIdEl = document.getElementById('gen_stopId');
        const stopNameEl = document.getElementById('gen_stopName');
        const directionEl = document.getElementById('gen_direction');
        if (stopIdEl) stopIdEl.value = '';
        if (stopNameEl) stopNameEl.value = '';
        if (directionEl) directionEl.value = '';
        gen_populateRouteSelect();
        return;
    }

    const stopMap = new Map();
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && !stopMap.has(entry.stopID.toUpperCase())) {
            stopMap.set(entry.stopID.toUpperCase(), {
                id: entry.stopID,
                name: entry.stopName || entry.stopID,
                direction: entry.direction || ""
            });
        }
    });

    const sortedStops = Array.from(stopMap.values()).sort((a, b) => {
        const nameA = String(a.name || "").toLowerCase();
        const nameB = String(b.name || "").toLowerCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        return 0;
    });

    sortedStops.forEach(stop => {
        const opt = document.createElement('option');
        opt.value = stop.id;
        opt.textContent = `${stop.name} (${stop.id})`;
        opt.dataset.stopname = stop.name;
        opt.dataset.direction = stop.direction;
        selectEl.appendChild(opt);
    });

    if (previouslySelectedStopId && stopMap.has(previouslySelectedStopId.toUpperCase())) {
        selectEl.value = previouslySelectedStopId;
    }
    selectEl.dispatchEvent(new Event('change'));
}

function displayUniqueOperatingProfiles() {
    if (!currentUser) {
        if (operatingProfilesStatusMessage) operatingProfilesStatusMessage.textContent = "Please log in to view operating profiles.";
        if (uniqueOperatingProfilesUL) uniqueOperatingProfilesUL.innerHTML = '';
        return;
    }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        if (operatingProfilesStatusMessage) operatingProfilesStatusMessage.textContent = "Working schedule is empty. No operating profiles to display.";
        if (uniqueOperatingProfilesUL) uniqueOperatingProfilesUL.innerHTML = '<li>No schedule data loaded.</li>';
        return;
    }

    const profileStrings = new Set();
    currentWorkingSchedule.forEach(entry => {
        if (entry.OperatingProfile && typeof entry.OperatingProfile === 'string' && entry.OperatingProfile.trim() !== '') {
            profileStrings.add(entry.OperatingProfile.trim());
        }
    });

    const sortedProfiles = Array.from(profileStrings).sort((a, b) => { // MODIFIED SORTING LOGIC
        const orderA = getDaySortOrder(a);
        const orderB = getDaySortOrder(b);
        if (orderA !== orderB) {
            return orderA - orderB;
        }
        // Secondary sort: alphabetically if primary order is the same
        return String(a).toLowerCase().localeCompare(String(b).toLowerCase());
    });

    if (uniqueOperatingProfilesUL) {
        uniqueOperatingProfilesUL.innerHTML = ''; // Clear previous list items
        if (sortedProfiles.length > 0) {
            sortedProfiles.forEach(profile => {
                const li = document.createElement('li');
                li.textContent = profile;
                uniqueOperatingProfilesUL.appendChild(li);
            });
            if (operatingProfilesStatusMessage) operatingProfilesStatusMessage.textContent = `Found ${sortedProfiles.length} unique operating profile string(s).`;
        } else {
            uniqueOperatingProfilesUL.innerHTML = '<li>No operating profiles found in the current schedule.</li>';
            if (operatingProfilesStatusMessage) operatingProfilesStatusMessage.textContent = "No operating profiles found.";
        }
    }
}

function displayReferenceOperatingProfiles() {
    const referenceProfilesUL = document.getElementById('referenceOperatingProfilesUL');
    if (!referenceProfilesUL) {
        console.warn("Reference Operating Profiles UL element not found.");
        return;
    }

    // This is the comprehensive sample list you provided
    const sampleReferenceScheduleData = [
        { "OperatingProfile": "Mo" }, { "OperatingProfile": "Mo, Tu" }, { "OperatingProfile": "Mo, Tu, We" },
        { "OperatingProfile": "Mo, Tu, We, Th" }, { "OperatingProfile": "Mo, Tu, We, Th, Sa" },
        { "OperatingProfile": "Mo, Tu, We, Th, Sa, Su" }, { "OperatingProfile": "Mo, Tu, We, Th, Su" },
        { "OperatingProfile": "Mo, Tu, We, Fr" }, { "OperatingProfile": "Mo, Tu, We, Fr, Sa" },
        { "OperatingProfile": "Mo, Tu, We, Fr, Sa, Su" }, { "OperatingProfile": "Mo, Tu, We, Fr, Su" },
        { "OperatingProfile": "Mo, Tu, We, Sa" }, { "OperatingProfile": "Mo, Tu, We, Sa, Su" },
        { "OperatingProfile": "Mo, Tu, We, Su" }, { "OperatingProfile": "Mo, Tu, Th" },
        { "OperatingProfile": "Mo, Tu, Th, Sa" }, { "OperatingProfile": "Mo, Tu, Th, Sa, Su" },
        { "OperatingProfile": "Mo, Tu, Th, Su" }, { "OperatingProfile": "Mo, Tu, Fr" },
        { "OperatingProfile": "Mo, Tu, Fr, Sa" }, { "OperatingProfile": "Mo, Tu, Fr, Sa, Su" },
        { "OperatingProfile": "Mo, Tu, Fr, Su" }, { "OperatingProfile": "Mo, Tu, Sa" },
        { "OperatingProfile": "Mo, Tu, Sa, Su" }, { "OperatingProfile": "Mo, Tu, Su" },
        { "OperatingProfile": "Mo, We" }, { "OperatingProfile": "Mo, We, Th" },
        { "OperatingProfile": "Mo, We, Th, Fr" }, { "OperatingProfile": "Mo, We, Th, Fr, Sa" },
        { "OperatingProfile": "Mo, We, Th, Fr, Sa, Su" }, { "OperatingProfile": "Mo, We, Th, Fr, Su" },
        { "OperatingProfile": "Mo, We, Th, Sa" }, { "OperatingProfile": "Mo, We, Th, Sa, Su" },
        { "OperatingProfile": "Mo, We, Th, Su" }, { "OperatingProfile": "Mo, We, Fr" },
        { "OperatingProfile": "Mo, We, Fr, Sa" }, { "OperatingProfile": "Mo, We, Fr, Sa, Su" },
        { "OperatingProfile": "Mo, We, Fr, Su" }, { "OperatingProfile": "Mo, We, Sa" },
        { "OperatingProfile": "Mo, We, Sa, Su" }, { "OperatingProfile": "Mo, We, Su" },
        { "OperatingProfile": "Mo, Th" }, { "OperatingProfile": "Mo, Th, Fr" },
        { "OperatingProfile": "Mo, Th, Fr, Sa" }, { "OperatingProfile": "Mo, Th, Fr, Sa, Su" },
        { "OperatingProfile": "Mo, Th, Fr, Su" }, { "OperatingProfile": "Mo, Th, Sa" },
        { "OperatingProfile": "Mo, Th, Sa, Su" }, { "OperatingProfile": "Mo, Th, Su" },
        { "OperatingProfile": "Mo, Fr" }, { "OperatingProfile": "Mo, Fr, Sa" },
        { "OperatingProfile": "Mo, Fr, Sa, Su" }, { "OperatingProfile": "Mo, Fr, Su" },
        { "OperatingProfile": "Mo, Sa" }, { "OperatingProfile": "Mo, Sa, Su" }, { "OperatingProfile": "Mo, Su" },
        { "OperatingProfile": "MoSch" }, { "OperatingProfile": "MoSch, TuSch" },
        { "OperatingProfile": "MoSch, TuSch, WeSch" }, { "OperatingProfile": "MoSch, TuSch, WeSch, ThSch" },
        { "OperatingProfile": "MoSch, TuSch, WeSch, FrSch" }, { "OperatingProfile": "MoSch, TuSch, ThSch" },
        { "OperatingProfile": "MoSch, TuSch, ThSch, FrSch" }, { "OperatingProfile": "MoSch, TuSch, FrSch" },
        { "OperatingProfile": "MoSch, WeSch" }, { "OperatingProfile": "MoSch, WeSch, ThSch" },
        { "OperatingProfile": "MoSch, WeSch, ThSch, FrSch" }, { "OperatingProfile": "MoSch, WeSch, FrSch" },
        { "OperatingProfile": "MoSch, ThSch" }, { "OperatingProfile": "MoSch, ThSch, FrSch" },
        { "OperatingProfile": "MoSch, FrSch" },
        { "OperatingProfile": "MoNSD" }, { "OperatingProfile": "MoNSD, TuNSD" },
        { "OperatingProfile": "MoNSD, TuNSD, WeNSD" }, { "OperatingProfile": "MoNSD, TuNSD, WeNSD, ThNSD" },
        { "OperatingProfile": "MoNSD, TuNSD, WeNSD, FrNSD" }, { "OperatingProfile": "MoNSD, TuNSD, ThNSD" },
        { "OperatingProfile": "MoNSD, TuNSD, ThNSD, FrNSD" }, { "OperatingProfile": "MoNSD, TuNSD, FrNSD" },
        { "OperatingProfile": "MoNSD, WeNSD" }, { "OperatingProfile": "MoNSD, WeNSD, ThNSD" },
        { "OperatingProfile": "MoNSD, WeNSD, ThNSD, FrNSD" }, { "OperatingProfile": "MoNSD, WeNSD, FrNSD" },
        { "OperatingProfile": "MoNSD, ThNSD" }, { "OperatingProfile": "MoNSD, ThNSD, FrNSD" },
        { "OperatingProfile": "MoNSD, FrNSD" },
        { "OperatingProfile": "Tu" }, { "OperatingProfile": "Tu, We" }, { "OperatingProfile": "Tu, We, Th" },
        { "OperatingProfile": "Tu, We, Th, Fr" }, { "OperatingProfile": "Tu, We, Th, Fr, Sa" },
        { "OperatingProfile": "Tu, We, Th, Fr, Sa, Su" }, { "OperatingProfile": "Tu, We, Th, Fr, Su" },
        { "OperatingProfile": "Tu, We, Th, Sa" }, { "OperatingProfile": "Tu, We, Th, Sa, Su" },
        { "OperatingProfile": "Tu, We, Th, Su" }, { "OperatingProfile": "Tu, We, Fr" },
        { "OperatingProfile": "Tu, We, Fr, Sa" }, { "OperatingProfile": "Tu, We, Fr, Sa, Su" },
        { "OperatingProfile": "Tu, We, Fr, Su" }, { "OperatingProfile": "Tu, We, Sa" },
        { "OperatingProfile": "Tu, We, Sa, Su" }, { "OperatingProfile": "Tu, We, Su" },
        { "OperatingProfile": "Tu, Th" }, { "OperatingProfile": "Tu, Th, Fr" },
        { "OperatingProfile": "Tu, Th, Fr, Sa" }, { "OperatingProfile": "Tu, Th, Fr, Sa, Su" },
        { "OperatingProfile": "Tu, Th, Fr, Su" }, { "OperatingProfile": "Tu, Th, Sa" },
        { "OperatingProfile": "Tu, Th, Sa, Su" }, { "OperatingProfile": "Tu, Th, Su" },
        { "OperatingProfile": "Tu, Fr" }, { "OperatingProfile": "Tu, Fr, Sa" },
        { "OperatingProfile": "Tu, Fr, Sa, Su" }, { "OperatingProfile": "Tu, Fr, Su" },
        { "OperatingProfile": "Tu, Sa" }, { "OperatingProfile": "Tu, Sa, Su" }, { "OperatingProfile": "Tu, Su" },
        { "OperatingProfile": "TuSch" }, { "OperatingProfile": "TuSch, WeSch" },
        { "OperatingProfile": "TuSch, WeSch, ThSch" }, { "OperatingProfile": "TuSch, WeSch, FrSch" },
        { "OperatingProfile": "TuSch, ThSch" }, { "OperatingProfile": "TuSch, ThSch, FrSch" },
        { "OperatingProfile": "TuSch, FrSch" },
        { "OperatingProfile": "TuNSD" }, { "OperatingProfile": "TuNSD, WeNSD" },
        { "OperatingProfile": "TuNSD, WeNSD, ThNSD" }, { "OperatingProfile": "TuNSD, WeNSD, ThNSD, FrNSD" },
        { "OperatingProfile": "TuNSD, WeNSD, FrNSD" }, { "OperatingProfile": "TuNSD, ThNSD" },
        { "OperatingProfile": "TuNSD, ThNSD, FrNSD" }, { "OperatingProfile": "TuNSD, FrNSD" },
        { "OperatingProfile": "We" }, { "OperatingProfile": "We, Th" }, { "OperatingProfile": "We, Th, Fr" },
        { "OperatingProfile": "We, Th, Fr, Sa" }, { "OperatingProfile": "We, Th, Fr, Sa, Su" },
        { "OperatingProfile": "We, Th, Fr, Su" }, { "OperatingProfile": "We, Th, Sa" },
        { "OperatingProfile": "We, Th, Sa, Su" }, { "OperatingProfile": "We, Th, Su" },
        { "OperatingProfile": "We, Fr" }, { "OperatingProfile": "We, Fr, Sa" },
        { "OperatingProfile": "We, Fr, Sa, Su" }, { "OperatingProfile": "We, Fr, Su" },
        { "OperatingProfile": "We, Sa" }, { "OperatingProfile": "We, Sa, Su" }, { "OperatingProfile": "We, Su" },
        { "OperatingProfile": "WeSch" }, { "OperatingProfile": "WeSch, ThSch" },
        { "OperatingProfile": "WeSch, ThSch, FrSch" }, { "OperatingProfile": "WeSch, FrSch" },
        { "OperatingProfile": "WeNSD" }, { "OperatingProfile": "WeNSD, ThNSD" },
        { "OperatingProfile": "WeNSD, ThNSD, FrNSD" }, { "OperatingProfile": "WeNSD, FrNSD" },
        { "OperatingProfile": "Th" }, { "OperatingProfile": "Th, Fr" }, { "OperatingProfile": "Th, Fr, Sa" },
        { "OperatingProfile": "Th, Fr, Sa, Su" }, { "OperatingProfile": "Th, Fr, Su" },
        { "OperatingProfile": "Th, Sa" }, { "OperatingProfile": "Th, Sa, Su" }, { "OperatingProfile": "Th, Su" },
        { "OperatingProfile": "ThSch" }, { "OperatingProfile": "ThSch, FrSch" },
        { "OperatingProfile": "ThNSD" }, { "OperatingProfile": "ThNSD, FrNSD" },
        { "OperatingProfile": "Fr" }, { "OperatingProfile": "Fr, Sa" }, { "OperatingProfile": "Fr, Sa, Su" },
        { "OperatingProfile": "Fr, Su" }, { "OperatingProfile": "FrSch" }, { "OperatingProfile": "FrNSD" },
        { "OperatingProfile": "MF" }, { "OperatingProfile": "MF, Sa" }, { "OperatingProfile": "MF, Sa, Su" },
        { "OperatingProfile": "MF, Su" }, { "OperatingProfile": "MFSch" }, { "OperatingProfile": "MFNSD" },
        { "OperatingProfile": "Sa" }, { "OperatingProfile": "Sa, Su" }, { "OperatingProfile": "Su" },
        { "OperatingProfile": "Christmas Day" }, { "OperatingProfile": "Boxing Day" }, { "OperatingProfile": "New Years Day" }
    ];

    const profileStrings = new Set();
    sampleReferenceScheduleData.forEach(entry => {
        if (entry.OperatingProfile && typeof entry.OperatingProfile === 'string' && entry.OperatingProfile.trim() !== '') {
            profileStrings.add(entry.OperatingProfile.trim());
        }
    });

    const sortedProfiles = Array.from(profileStrings).sort((a, b) => {
        const orderA = getDaySortOrder(a); // Primary sort key
        const orderB = getDaySortOrder(b); // Primary sort key

        if (orderA !== orderB) {
            return orderA - orderB;
        }

        // --- NEW Secondary sort logic for when primary scores are equal ---
        const partsA = a.split(',').map(p => p.trim());
        const partsB = b.split(',').map(p => p.trim());
        const lenA = partsA.length;
        const lenB = partsB.length;
        const minLen = Math.min(lenA, lenB);

        for (let i = 0; i < minLen; i++) {
            // If the parts themselves are identical (e.g. "MoSch" vs "MoSch" in "MoSch, TuSch" vs "MoSch, FrSch"), continue to next part
            if (partsA[i] === partsB[i]) {
                continue;
            }
            // If parts differ, sort by their individual getDaySortOrder, then alphabetically as a tie-breaker
            const partOrderA = getDaySortOrder(partsA[i]);
            const partOrderB = getDaySortOrder(partsB[i]);
            if (partOrderA !== partOrderB) {
                return partOrderA - partOrderB;
            }
            // If individual part orders are the same (e.g., "MF" vs "Mo" if getDaySortOrder grouped them), sort alphabetically
            return String(partsA[i]).toLowerCase().localeCompare(String(partsB[i]).toLowerCase());
        }

        // If one string is a prefix of the other (e.g., "MoSch" vs "MoSch, TuSch"), the shorter one comes first.
        if (lenA !== lenB) {
            return lenA - lenB;
        }

        // Fallback for any other case (though unlikely with the above logic)
        return String(a).toLowerCase().localeCompare(String(b).toLowerCase());
    });

    referenceProfilesUL.innerHTML = ''; // Clear previous list items
    if (sortedProfiles.length > 0) {
        sortedProfiles.forEach(profile => {
            const li = document.createElement('li');
            li.textContent = profile;
            referenceProfilesUL.appendChild(li);
        });
    } else {
        referenceProfilesUL.innerHTML = '<li>No reference profiles defined in the sample list.</li>';
    }
}

function gen_populateRouteSelect() {
    const routeSelectEl = document.getElementById('gen_routeSelect');
    if (!routeSelectEl) return;

    const previouslySelectedRouteInDropdown = routeSelectEl.value;
    routeSelectEl.innerHTML = '<option value="">-- Select Existing Route --</option>';

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        routeSelectEl.innerHTML = '<option value="">-- No Routes in Schedule --</option>';
        const lineNameInputEl = document.getElementById('gen_lineName');
        if (lineNameInputEl) lineNameInputEl.dispatchEvent(new Event('input'));
        return;
    }

    const uniqueRoutes = [...new Set(currentWorkingSchedule.map(e => e.lineName))]
        .filter(Boolean)
        .sort(compareLineNames);

    uniqueRoutes.forEach(lineName => {
        const opt = document.createElement('option');
        opt.value = lineName;
        opt.textContent = lineName;
        routeSelectEl.appendChild(opt);
    });

    const lineNameInputEl = document.getElementById('gen_lineName');
    if (lineNameInputEl && lineNameInputEl.value && uniqueRoutes.includes(lineNameInputEl.value)) {
        routeSelectEl.value = lineNameInputEl.value;
    } else if (previouslySelectedRouteInDropdown && uniqueRoutes.includes(previouslySelectedRouteInDropdown)) {
        routeSelectEl.value = previouslySelectedRouteInDropdown;
        if (lineNameInputEl) lineNameInputEl.value = routeSelectEl.value;
    } else {
        if (lineNameInputEl) lineNameInputEl.value = routeSelectEl.value; // Will be "" if no match
    }

    if(lineNameInputEl) lineNameInputEl.dispatchEvent(new Event('input', { bubbles:true, cancelable:true }));
}


function gen_populateDestinationSelect() {
    const lineNameInputEl = document.getElementById('gen_lineName');
    const destSelectEl = document.getElementById('gen_destinationSelect');
    if (!lineNameInputEl || !destSelectEl) return;

    const selectedRoute = lineNameInputEl.value;
    const previouslySelectedDestInDropdown = destSelectEl.value;

    destSelectEl.innerHTML = ''; // Clear previous options

    if (!selectedRoute) {
        destSelectEl.innerHTML = '<option value="">-- Enter / Select Route First --</option>';
        return;
    }

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        destSelectEl.innerHTML = '<option value="">-- No Schedule Data --</option>';
        return;
    }

    const relevantEntries = currentWorkingSchedule.filter(e =>
        e.lineName === selectedRoute && e.destinationName
    );

    const uniqueDestinations = [...new Set(relevantEntries.map(e => e.destinationName))]
        .sort((a, b) => String(a || "").toLowerCase().localeCompare(String(b || "").toLowerCase()));

    if (uniqueDestinations.length === 0) {
        destSelectEl.innerHTML = `<option value="">-- No Known Destinations for Route ${selectedRoute} --</option>`;
    } else {
        destSelectEl.innerHTML = '<option value="">-- Select Existing Destination --</option>'; // Default prompt
        uniqueDestinations.forEach(destName => {
            const opt = document.createElement('option');
            opt.value = destName;
            opt.textContent = destName;
            destSelectEl.appendChild(opt);
        });
    }

    const destNameInputEl = document.getElementById('gen_destinationName');
    if (destNameInputEl && destNameInputEl.value && uniqueDestinations.includes(destNameInputEl.value)) {
        destSelectEl.value = destNameInputEl.value;
    } else if (previouslySelectedDestInDropdown && uniqueDestinations.includes(previouslySelectedDestInDropdown)) {
        destSelectEl.value = previouslySelectedDestInDropdown;
        if (destNameInputEl) destNameInputEl.value = destSelectEl.value;
    } else {
         if (destNameInputEl) destNameInputEl.value = destSelectEl.value; // Will be "" if no match
    }
}


function gen_attachEventListenersForGeneratorSelects() {
    const stopNameSelect = document.getElementById('gen_stopNameSelect');
    const routeSelect = document.getElementById('gen_routeSelect');
    const destinationSelect = document.getElementById('gen_destinationSelect');
    const lineNameInputEl = document.getElementById('gen_lineName');
    const destNameInputEl = document.getElementById('gen_destinationName');

    if (stopNameSelect) {
        stopNameSelect.removeEventListener('change', gen_handleStopNameSelectChange);
        stopNameSelect.addEventListener('change', gen_handleStopNameSelectChange);
    }
    if (routeSelect) {
        routeSelect.removeEventListener('change', gen_handleRouteSelectChange);
        routeSelect.addEventListener('change', gen_handleRouteSelectChange);
    }
    if (destinationSelect) {
        destinationSelect.removeEventListener('change', gen_handleDestinationSelectChange);
        destinationSelect.addEventListener('change', gen_handleDestinationSelectChange);
    }

    if (lineNameInputEl) {
        lineNameInputEl.removeEventListener('input', gen_handleLineNameInputChange);
        lineNameInputEl.addEventListener('input', gen_handleLineNameInputChange);
        lineNameInputEl.removeEventListener('change', gen_saveDataToLocalStorage); // Ensure change also saves if focus lost
        lineNameInputEl.addEventListener('change', gen_saveDataToLocalStorage);
    }
    if (destNameInputEl) {
        // Input event should be enough for typing, change for losing focus if typed.
        destNameInputEl.removeEventListener('input', gen_saveDataToLocalStorage);
        destNameInputEl.addEventListener('input', gen_saveDataToLocalStorage);
        destNameInputEl.removeEventListener('change', gen_saveDataToLocalStorage);
        destNameInputEl.addEventListener('change', gen_saveDataToLocalStorage);
    }
}

function gen_handleLineNameInputChange() {
    gen_populateDestinationSelect(); // Update destinations based on new line name
    const lineNameInputEl = document.getElementById('gen_lineName');
    const routeSelectEl = document.getElementById('gen_routeSelect');
    // Sync route select dropdown if typed line name matches an option
    if (lineNameInputEl && routeSelectEl) {
        const currentLineName = lineNameInputEl.value;
        let optionExists = Array.from(routeSelectEl.options).some(opt => opt.value === currentLineName);
        if(optionExists) {
            routeSelectEl.value = currentLineName;
        } else {
            routeSelectEl.selectedIndex = 0; // Default to "-- Select Existing Route --"
        }
    }
    gen_saveDataToLocalStorage(); // Save after input change
}


function gen_handleStopNameSelectChange() {
    const stopNameSelect = document.getElementById('gen_stopNameSelect');
    const selectedOption = stopNameSelect.options[stopNameSelect.selectedIndex];
    const stopIdInput = document.getElementById('gen_stopId');
    const stopNameInput = document.getElementById('gen_stopName');
    const directionInput = document.getElementById('gen_direction');

    if (selectedOption && selectedOption.value) {
        if (stopIdInput) stopIdInput.value = selectedOption.value;
        if (stopNameInput) stopNameInput.value = selectedOption.dataset.stopname || '';
        if (directionInput) directionInput.value = selectedOption.dataset.direction || '';
    } else {
        if (stopIdInput) stopIdInput.value = '';
        if (stopNameInput) stopNameInput.value = '';
        if (directionInput) directionInput.value = '';
    }
    gen_saveDataToLocalStorage();
}

function gen_handleRouteSelectChange() {
    const routeSelect = document.getElementById('gen_routeSelect');
    const lineNameInput = document.getElementById('gen_lineName');
    if (lineNameInput) {
        lineNameInput.value = routeSelect.value;
        // Dispatch input event so dependent functions (like gen_populateDestinationSelect) are called
        lineNameInput.dispatchEvent(new Event('input', { bubbles:true, cancelable:true }));
    }
    // gen_saveDataToLocalStorage(); // Already called by lineNameInput's input/change event
}

function gen_handleDestinationSelectChange() {
    const destinationSelect = document.getElementById('gen_destinationSelect');
    const destNameInput = document.getElementById('gen_destinationName');
    if (destNameInput) {
        destNameInput.value = destinationSelect.value;
         // Dispatch input event to ensure consistency if other listeners depend on it
         destNameInput.dispatchEvent(new Event('input', { bubbles:true, cancelable:true }));
    }
    // gen_saveDataToLocalStorage(); // Already called by destNameInput's input/change event
}
// --- END: Schedule Generator Population & Interaction ---

// --- START: Route Timetable Overwrite Functions ---

function populate_rto_SelectRoute() {
    if (!rto_selectRoute) return;
    const currentVal = rto_selectRoute.value;
    rto_selectRoute.innerHTML = '<option value="">-- Select Route --</option>';

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        if (rto_selectProfile) rto_selectProfile.innerHTML = '<option value="">-- Select Route First --</option>';
        if (rto_selectDestination) rto_selectDestination.innerHTML = '<option value="">-- Select Route & Profile First --</option>';
        return;
    }
    const uniqueRoutes = [...new Set(currentWorkingSchedule.map(e => e.lineName))].filter(Boolean).sort(compareLineNames);
    uniqueRoutes.forEach(route => {
        const opt = document.createElement('option');
        opt.value = route;
        opt.textContent = route;
        rto_selectRoute.appendChild(opt);
    });
    if (uniqueRoutes.includes(currentVal)) {
        rto_selectRoute.value = currentVal;
    }
    populate_rto_SelectProfile(rto_selectRoute.value); // This will in turn call populate_rto_SelectDestination
}

function populate_rto_SelectProfile(selectedRoute) {
    if (!rto_selectProfile) return;
    const currentVal = rto_selectProfile.value;
    rto_selectProfile.innerHTML = '<option value="">-- Select Profile --</option>'; // Default for this dropdown

    if (!selectedRoute || !currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        rto_selectProfile.innerHTML = '<option value="">-- Select Route First --</option>';
        if (rto_selectDestination) rto_selectDestination.innerHTML = '<option value="">-- Select Route & Profile First --</option>';
        return;
    }

    const profilesForRoute = [...new Set(
        currentWorkingSchedule
            .filter(e => e.lineName === selectedRoute && e.OperatingProfile)
            .map(e => e.OperatingProfile)
    )].sort((a, b) => { // MODIFIED SORTING LOGIC
        const orderA = getDaySortOrder(a);
        const orderB = getDaySortOrder(b);
        if (orderA !== orderB) {
            return orderA - orderB;
        }
        // Secondary sort: alphabetically if primary order is the same
        return String(a).toLowerCase().localeCompare(String(b).toLowerCase());
    });

    if (profilesForRoute.length === 0) {
        rto_selectProfile.innerHTML = '<option value="">-- No Profiles for Route --</option>';
        if (rto_selectDestination) rto_selectDestination.innerHTML = '<option value="">-- Select Route & Profile First --</option>';
        return;
    }

    profilesForRoute.forEach(profile => {
        const opt = document.createElement('option');
        opt.value = profile;
        opt.textContent = profile;
        rto_selectProfile.appendChild(opt);
    });

    // Reselect previous value if still valid
    if (profilesForRoute.includes(currentVal)) {
        rto_selectProfile.value = currentVal;
    } else if (profilesForRoute.length > 0) {
        // Optionally, select the first item if the previous value is no longer valid and list is not empty
        // rto_selectProfile.value = profilesForRoute[0];
    }

    populate_rto_SelectDestination(selectedRoute, rto_selectProfile.value);
}

function populate_rto_SelectDestination(selectedRoute, selectedProfile) {
    if (!rto_selectDestination) return;
    const currentVal = rto_selectDestination.value;
    // Default option allows for overwriting all destinations for the route/profile
    rto_selectDestination.innerHTML = '<option value="">-- All Destinations for Route/Profile --</option>';

    if (!selectedRoute || !selectedProfile || !currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        // If route or profile not selected, or no data, reset to a more generic prompt
        rto_selectDestination.innerHTML = '<option value="">-- Select Route & Profile First --</option>';
        return;
    }
    const destinations = [...new Set(
        currentWorkingSchedule
            .filter(e => e.lineName === selectedRoute && e.OperatingProfile === selectedProfile && e.destinationName)
            .map(e => e.destinationName)
    )].sort();

    if (destinations.length === 0) {
        // No specific destinations found, so the default "All Destinations..." is appropriate.
        // No need to change the innerHTML here as it's already set.
    } else {
        destinations.forEach(dest => {
            const opt = document.createElement('option');
            opt.value = dest;
            opt.textContent = dest;
            rto_selectDestination.appendChild(opt);
        });
        // If a previous value was set and is still valid, re-select it.
        if (destinations.includes(currentVal)) {
            rto_selectDestination.value = currentVal;
        }
    }
}

function handle_rto_FileUpload(event) {
    const file = event.target.files[0];
    if (!rto_fileStatus || !rto_fileInput) return;

    if (!file) {
        rto_fileStatus.textContent = "No file selected.";
        rto_uploadedScheduleData = [];
        return;
    }
    rto_fileStatus.textContent = `Processing ${file.name}...`;
    rto_uploadedScheduleData = []; // Clear previous uploads

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const fileContent = e.target.result;
            const lines = fileContent.split(/\r?\n/);
            if (lines.length < 2) { // Must have header + at least one data row
                alert("Uploaded file is empty or has no data rows.");
                rto_fileStatus.textContent = "File empty or no data.";
                rto_fileInput.value = ""; // Reset file input
                return;
            }
            const headers = lines[0].split('\t').map(h => h.trim());
            // Define essential headers for a valid overwrite operation
            const requiredHeaders = ['StopID', 'LineName', 'ScheduledTime', 'OperatingProfile'];
            const missingHeaders = requiredHeaders.filter(rh => !headers.includes(rh));
            if (missingHeaders.length > 0) {
                alert(`Uploaded file is missing required headers for overwrite: ${missingHeaders.join(', ')}. \nExpected at least: StopID, LineName, ScheduledTime, OperatingProfile. \nAlso recommended: StopName, Direction, DestinationName, DayOffset.`);
                rto_fileStatus.textContent = "Invalid file headers.";
                rto_fileInput.value = ""; // Reset file input
                return;
            }

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === "") continue; // Skip empty lines
                const values = line.split('\t').map(v => v.trim());
                let entry = {};
                headers.forEach((header, index) => {
                    entry[header] = values[index] !== undefined ? values[index] : "";
                });

                // Basic validation for core fields before adding to potential upload data
                if (entry.StopID && entry.LineName && entry.ScheduledTime && entry.OperatingProfile) {
                     // Standardize time format to HH:MM
                     let scheduledTime = String(entry.ScheduledTime || "").trim();
                     if (scheduledTime.match(/^\d{4}$/)) { // HHMM format
                         scheduledTime = `${scheduledTime.substring(0,2)}:${scheduledTime.substring(2,4)}`;
                     } else if (scheduledTime.match(/^\d{1,2}:\d{2}$/)) { // H:MM or HH:MM format
                         const parts = scheduledTime.split(':');
                         scheduledTime = `${String(parts[0]).padStart(2, '0')}:${String(parts[1]).padStart(2, '0')}`;
                     }
                     entry.ScheduledTime = scheduledTime; // Store standardized time

                     // Standardize other common fields
                     entry.DayOffset = String(entry.DayOffset || "0").trim();
                     entry.StopID = entry.StopID.toUpperCase();
                     entry.LineName = entry.LineName.toUpperCase();
                     // DestinationName and OperatingProfile often need to be case-sensitive or as-is from file.
                     // No specific case change here unless requirements state otherwise.

                     rto_uploadedScheduleData.push(entry);
                }
            }
            rto_fileStatus.textContent = `${file.name} processed. ${rto_uploadedScheduleData.length} potentially valid entries found. Ready to overwrite.`;
            if (rto_statusMessage) rto_statusMessage.textContent = ""; // Clear previous status
        } catch (error) {
            console.error("Error processing timetable overwrite file:", error);
            alert(`Error processing file: ${error.message}`);
            rto_fileStatus.textContent = "Error processing file.";
            if (rto_fileInput) rto_fileInput.value = ""; // Reset file input on error
        }
    };
    reader.onerror = () => {
        alert("Could not read file.");
        rto_fileStatus.textContent = "Error reading file.";
        if (rto_fileInput) rto_fileInput.value = ""; // Reset file input
    };
    reader.readAsText(file);
}

function handle_rto_OverwriteTimetable() {
    if (!currentUser) { alert("Please log in."); return; }
     if (!rto_selectRoute || !rto_selectProfile || !rto_selectDestination || !rto_overwriteButton || !rto_statusMessage) {
         console.error("RTO Tool: One or more UI elements are missing for overwrite operation."); return;
     }

    const targetRoute = rto_selectRoute.value;
    const targetProfile = rto_selectProfile.value;
    const targetDestination = rto_selectDestination.value; // Can be "" for "All Destinations"

    if (!targetRoute) {
        rto_statusMessage.textContent = "Please select a Route to overwrite.";
        rto_statusMessage.style.color = "#e74c3c"; return;
    }
    if (!targetProfile) {
        rto_statusMessage.textContent = "Please select an Operating Profile to overwrite.";
        rto_statusMessage.style.color = "#e74c3c"; return;
    }
    if (rto_uploadedScheduleData.length === 0) {
        rto_statusMessage.textContent = "No new timetable data uploaded. Please upload a file first.";
        rto_statusMessage.style.color = "#e74c3c"; return;
    }

    const confirmationMessage = `Are you sure you want to overwrite all times for:\nRoute: ${targetRoute}\nProfile: ${targetProfile}\n${targetDestination ? `Destination: ${targetDestination}` : '(All Destinations for this Route/Profile)'}\n\nThis will REPLACE existing entries matching these criteria in the current working schedule with data from the uploaded file. This action cannot be easily undone.`;
    if (!confirm(confirmationMessage)) {
        rto_statusMessage.textContent = "Overwrite cancelled by user.";
        rto_statusMessage.style.color = "#f1c40f"; return;
    }

    // Filter uploaded data to only include entries that match the selected criteria
    const newEntriesForTarget = rto_uploadedScheduleData.filter(entry =>
        entry.LineName === targetRoute && // Assumes LineName in file is already uppercase from upload processing
        entry.OperatingProfile === targetProfile && // Match OperatingProfile exactly
        (targetDestination === "" || entry.DestinationName === targetDestination) // Match destination if specified
    ).map((row, index) => {
         // Create a new object structured for currentWorkingSchedule
         // Ensure all required fields for currentWorkingSchedule are present
         return {
             internalId: `${String(row.StopID||'s').trim().toUpperCase()}_${String(row.LineName||'l').trim().toUpperCase()}_${(row.ScheduledTime||"0000").replace(':','')}_${index}_rto_${Date.now()}`,
             stopID: String(row.StopID || "").trim().toUpperCase(),
             stopName: String(row.StopName || "Unknown Stop").trim(), // Default if missing
             direction: String(row.Direction || "Unknown Direction").trim(), // Default if missing
             lineName: String(row.LineName || targetRoute).trim().toUpperCase(), // Ensure it's the target route
             destinationName: String(row.DestinationName || (targetDestination === "" ? "Unknown Destination" : targetDestination)).trim(), // Use specified or default
             scheduledTime: row.ScheduledTime, // Already standardized HH:MM
             OperatingProfile: String(row.OperatingProfile || targetProfile).trim(), // Ensure it's the target profile
             DayOffset: String(row.DayOffset || "0").trim() // Default to 0 if missing
         };
    });

    if (newEntriesForTarget.length === 0) {
        rto_statusMessage.textContent = "No matching entries found in the uploaded file for the selected criteria. No changes made to the working schedule.";
        rto_statusMessage.style.color = "#f1c40f"; return;
    }

    let entriesKept = 0;
    let entriesRemoved = 0;

    // Filter out the old entries from the working schedule
    const updatedWorkingSchedule = currentWorkingSchedule.filter(entry => {
        const matchesCriteriaForRemoval = entry.lineName === targetRoute &&
                              entry.OperatingProfile === targetProfile &&
                              (targetDestination === "" || entry.destinationName === targetDestination);
        if (matchesCriteriaForRemoval) {
            entriesRemoved++;
            return false; // Exclude this entry
        }
        entriesKept++;
        return true; // Keep this entry
    });

    // Add the new entries from the uploaded file
    updatedWorkingSchedule.push(...newEntriesForTarget);
    currentWorkingSchedule = updatedWorkingSchedule; // Update the global working schedule

    rto_statusMessage.textContent = `Timetable overwritten successfully. ${entriesRemoved} old entries removed, ${newEntriesForTarget.length} new entries added. Working schedule now has ${currentWorkingSchedule.length} total entries.`;
    rto_statusMessage.style.color = "#2ecc71";

    // Reset file input and status
    if (rto_fileInput) rto_fileInput.value = "";
    if (rto_fileStatus) rto_fileStatus.textContent = "No file selected.";
    rto_uploadedScheduleData = []; // Clear uploaded data

    // Refresh UI elements that depend on currentWorkingSchedule
    renderUIDependentElements();
    updateStagingStatusDisplay(); // Update Firebase staging status display

    // If the schedule generator is active, re-initialize its controls
    const activeSectionId = localStorage.getItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
    if (activeSectionId === 'schedule-generator-section') {
        gen_initializeScheduleGeneratorControls();
    }
    // If stop management is active, refresh its list
    if (activeSectionId === 'stop-management-tool-section') {
         populateMasterStopList_SM();
    }
    // Refresh the RTO tool's own selectors
    populate_rto_SelectRoute();
}
// --- END: Route Timetable Overwrite Functions ---


// --- START: Timetable Generator Functions ---
function populate_tg_selectRoute() {
    if (!tg_selectRoute) return;
    const currentVal = tg_selectRoute.value;
    tg_selectRoute.innerHTML = '<option value="">-- Select Route --</option>';
    // Also reset dependent elements
    if (tg_selectDirection) tg_selectDirection.innerHTML = '<option value="">-- Select Route First --</option>';
    if (tg_timetableTableBody) tg_timetableTableBody.innerHTML = '';
    if (tg_timetablePlaceholder) {
        tg_timetablePlaceholder.textContent = 'Select a route and direction to view timetable.';
        tg_timetablePlaceholder.style.display = 'block';
    }
    if (tg_statusMessage) tg_statusMessage.textContent = '';


    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        tg_selectRoute.innerHTML = '<option value="">-- No Routes Loaded --</option>';
        return;
    }

    const uniqueRoutes = [...new Set(currentWorkingSchedule.map(e => e.lineName))]
        .filter(Boolean) // Remove any undefined or empty lineNames
        .sort(compareLineNames); // Assuming compareLineNames is your existing sort function

    uniqueRoutes.forEach(route => {
        const opt = document.createElement('option');
        opt.value = route;
        opt.textContent = route;
        tg_selectRoute.appendChild(opt);
    });

    if (uniqueRoutes.includes(currentVal)) {
        tg_selectRoute.value = currentVal;
    }
    // Trigger change to populate directions if a route was re-selected or is still valid
    tg_selectRoute.dispatchEvent(new Event('change'));
}

function populate_tg_selectDirection() {
    if (!tg_selectRoute || !tg_selectDirection) {
        console.error("populate_tg_selectDirection: Crucial select elements missing.");
        return;
    }
    const selectedRoute = tg_selectRoute.value;
    const previouslySelectedDirection = tg_selectDirection.value;

    tg_selectDirection.innerHTML = ''; 

    const defaultPromptOption = document.createElement('option');
    defaultPromptOption.value = "";

    if (!selectedRoute) {
        defaultPromptOption.textContent = "-- Select Route First --";
        tg_selectDirection.appendChild(defaultPromptOption);
        tg_selectDirection.dispatchEvent(new Event('change'));
        return;
    }

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        defaultPromptOption.textContent = "-- No Schedule Data --";
        tg_selectDirection.appendChild(defaultPromptOption);
        tg_selectDirection.dispatchEvent(new Event('change'));
        return;
    }

    const routeEntries = currentWorkingSchedule.filter(e =>
        e.lineName === selectedRoute && e.destinationName
    );
    const uniqueDestinationNames = [...new Set(routeEntries.map(e => e.destinationName))].filter(Boolean);

    if (uniqueDestinationNames.length === 0) {
        defaultPromptOption.textContent = `-- No Destinations for Route ${selectedRoute} --`;
        tg_selectDirection.appendChild(defaultPromptOption);
        tg_selectDirection.dispatchEvent(new Event('change'));
        return;
    }

    let endToEndDestinationsForDropdown = [];

    if (uniqueDestinationNames.length > 0) {
        const destSignificance = uniqueDestinationNames.map(destName => {
            const entriesForThisDest = routeEntries.filter(e => e.destinationName === destName);
            const uniqueStopsForThisDest = new Set(entriesForThisDest.map(e => e.stopID));
            return { name: destName, stopCount: uniqueStopsForThisDest.size };
        }).sort((a, b) => { 
            if (b.stopCount !== a.stopCount) return b.stopCount - a.stopCount;
            return String(a.name).toLowerCase().localeCompare(String(b.name).toLowerCase());
        });

        if (destSignificance.length > 0) {
            endToEndDestinationsForDropdown.push(destSignificance[0].name);
        }
        if (destSignificance.length > 1) {
            if (!endToEndDestinationsForDropdown.includes(destSignificance[1].name)) {
                endToEndDestinationsForDropdown.push(destSignificance[1].name);
            }
        }
        endToEndDestinationsForDropdown.sort((a,b) => String(a).toLowerCase().localeCompare(String(b).toLowerCase()));
    }
    
    console.log(`TG_DEBUG (populate_tg_selectDirection): Identified end-to-end for dropdown for route '${selectedRoute}':`, JSON.stringify(endToEndDestinationsForDropdown));

    if (endToEndDestinationsForDropdown.length === 0) {
        defaultPromptOption.textContent = `-- No End-to-End Destinations Identified --`;
        tg_selectDirection.appendChild(defaultPromptOption);
    } else {
        if (endToEndDestinationsForDropdown.length > 1 || 
            (endToEndDestinationsForDropdown.length === 1 && endToEndDestinationsForDropdown[0] !== previouslySelectedDirection && previouslySelectedDirection === "")) {
            defaultPromptOption.textContent = "-- Select End-to-End Direction --";
            tg_selectDirection.appendChild(defaultPromptOption);
        }
        endToEndDestinationsForDropdown.forEach(destName => {
            const opt = document.createElement('option');
            opt.value = destName;
            opt.textContent = destName;
            tg_selectDirection.appendChild(opt);
        });
    }

    if (endToEndDestinationsForDropdown.includes(previouslySelectedDirection)) {
        tg_selectDirection.value = previouslySelectedDirection;
    } else if (endToEndDestinationsForDropdown.length > 0 && tg_selectDirection.options.length > endToEndDestinationsForDropdown.length) {
         tg_selectDirection.value = ""; 
    } else if (endToEndDestinationsForDropdown.length === 1 && !tg_selectDirection.value) {
        tg_selectDirection.value = endToEndDestinationsForDropdown[0];
    }
    
    tg_selectDirection.dispatchEvent(new Event('change'));
}

function renderSingleTimetableDisplay(title, entries, tableBodyId, tableHeadId, placeholderId, mainFocusDestinationForAnnotation) {
    const tableBody = document.getElementById(tableBodyId);
    const tableHead = document.getElementById(tableHeadId);
    const placeholder = document.getElementById(placeholderId);
    const parentTable = tableBody ? tableBody.closest('table') : null; // Get the <table> element

    // Clear previous content
    if (tableHead) tableHead.innerHTML = '';
    if (tableBody) tableBody.innerHTML = '';

    const titleElement = document.querySelector(`[data-table-for="${tableBodyId}"]`); // Find title using a data attribute
    if (titleElement) titleElement.textContent = title;


    if (!entries || entries.length === 0) {
        if (placeholder) {
            placeholder.textContent = `No services found for this category.`;
            placeholder.style.display = 'block';
        }
        if (parentTable) parentTable.style.display = 'none'; // Hide the table itself
        return;
    }

    if (placeholder) placeholder.style.display = 'none';
    if (parentTable) parentTable.style.display = 'table'; // Show table if there are entries

    const uniqueProfiles = [...new Set(entries.map(e => e.OperatingProfile || "N/A"))]
        .sort((a, b) => {
            const orderA = getDaySortOrder(a);
            const orderB = getDaySortOrder(b);
            if (orderA !== orderB) return orderA - orderB;
            return String(a).toLowerCase().localeCompare(String(b).toLowerCase());
        });

    if (tableHead) {
        const hr = tableHead.insertRow();
        const thStop = document.createElement('th');
        thStop.textContent = 'Stop Name (ID)';
        thStop.style.minWidth = '180px';
        hr.appendChild(thStop);
        uniqueProfiles.forEach(profile => {
            const thProfile = document.createElement('th');
            thProfile.textContent = profile;
            hr.appendChild(thProfile);
        });
    }

    const stopOrderDeterminationEntries = [...entries].sort((a, b) => {
        const dayOffsetA = parseInt(a.DayOffset || "0", 10);
        const dayOffsetB = parseInt(b.DayOffset || "0", 10);
        if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
        const timeA = (a.scheduledTime || "99:99").replace(':', '');
        const timeB = (b.scheduledTime || "99:99").replace(':', '');
        if (timeA !== timeB) return timeA.localeCompare(timeB);
        return (a.internalId || "").localeCompare(b.internalId || "");
    });

    const orderedStopDetails = [];
    const visitedStopIDs = new Set();
    for (const entry of stopOrderDeterminationEntries) {
        if (entry.stopID && !visitedStopIDs.has(entry.stopID)) {
            orderedStopDetails.push({ stopID: entry.stopID, stopName: entry.stopName || entry.stopID });
            visitedStopIDs.add(entry.stopID);
        }
    }

    const timetableData = new Map();
    entries.forEach(entry => {
        if (!entry.stopID) return;
        const stopID = entry.stopID;
        const profileKey = entry.OperatingProfile || "N/A";
        if (!timetableData.has(stopID)) timetableData.set(stopID, new Map());
        const stopProfilesMap = timetableData.get(stopID);
        if (!stopProfilesMap.has(profileKey)) stopProfilesMap.set(profileKey, []);
        stopProfilesMap.get(profileKey).push({
            time: entry.scheduledTime,
            offset: entry.DayOffset || "0",
            destination: entry.destinationName || ""
        });
    });

    if (tableBody) {
        orderedStopDetails.forEach(stopDetail => {
            const stopID = stopDetail.stopID;
            const stopRow = tableBody.insertRow();
            const cellStopName = stopRow.insertCell();
            cellStopName.textContent = `${stopDetail.stopName} (${stopDetail.stopID})`;
            cellStopName.style.fontWeight = "bold";
            cellStopName.style.verticalAlign = "top";

            uniqueProfiles.forEach(profileKey => {
                const cellTimes = stopRow.insertCell();
                cellTimes.style.verticalAlign = "top";
                cellTimes.style.whiteSpace = "pre-wrap";
                cellTimes.style.fontSize = "0.85em";
                cellTimes.style.minWidth = "90px";

                const stopTimesForProfileMap = timetableData.get(stopID);
                const timeObjects = stopTimesForProfileMap ? stopTimesForProfileMap.get(profileKey) : null;

                if (timeObjects && timeObjects.length > 0) {
                    timeObjects.sort((a,b) => { /* Same sorting as before */
                        const oA = parseInt(a.offset,10), oB = parseInt(b.offset,10); if(oA !== oB) return oA - oB;
                        const tA = (a.time||"9999").replace(':',''), tB = (b.time||"9999").replace(':',''); if(tA !== tB) return tA.localeCompare(tB);
                        return (a.destination||"").localeCompare(b.destination||"");
                    });
                    cellTimes.innerHTML = timeObjects.map(t => { // Use innerHTML for potential styling
                        let timeDisplay = t.time || "--:--";
                        if (t.offset && t.offset !== "0") timeDisplay += `&nbsp;<span style="color:#yellow; font-size:0.9em;">(+${t.offset}d)</span>`;
                        // Annotate if the service's destination is different from the mainFocusDestinationForAnnotation
                        if (mainFocusDestinationForAnnotation && t.destination && t.destination !== mainFocusDestinationForAnnotation) {
                            timeDisplay += ` <span style="color:#aaa; font-style:italic; font-size:0.9em;">(to ${t.destination})</span>`;
                        }
                        return timeDisplay;
                    }).join("<br>"); // Use <br> for new lines in HTML
                } else {
                    cellTimes.textContent = "-";
                    cellTimes.style.textAlign = "center";
                }
            });
        });
    }
}


// --- Modified display_tg_Timetable Function ---
function display_tg_Timetable() {
    console.log("--- display_tg_Timetable START (V11 - Refined Categorization Priority) ---");

    if (!tg_selectRoute || !tg_selectDirection || !tg_statusMessage ||
        !document.getElementById('tg_fullJourneyTableBody_tools') ||
        !document.getElementById('tg_shortJourneyTableBody_tools') ||
        !document.getElementById('tg_diversionJourneyTableBody_tools')) {
        console.error("Timetable Generator UI elements (including new table bodies) missing. Exiting.");
        if (tg_statusMessage) {
            tg_statusMessage.textContent = "Error: Timetable display elements are missing in the HTML.";
            tg_statusMessage.style.color = "red";
        }
        return;
    }

    const selectedRoute = tg_selectRoute.value;
    const mainFocusDestination = tg_selectDirection.value;

    console.log(`TG_DEBUG_V11: User Selected Route: '${selectedRoute}', Main Focus Destination: '${mainFocusDestination}'`);

    const tableConfigs = [
        { bodyId: 'tg_fullJourneyTableBody_tools', headId: 'tg_fullJourneyTableHead_tools', placeholderId: 'tg_fullJourneyPlaceholder_tools', titleDataAttr: 'tg_fullJourneyTableBody_tools', defaultTitle: "Full Journeys" },
        { bodyId: 'tg_shortJourneyTableBody_tools', headId: 'tg_shortJourneyTableHead_tools', placeholderId: 'tg_shortJourneyPlaceholder_tools', titleDataAttr: 'tg_shortJourneyTableBody_tools', defaultTitle: "Short Journeys" },
        { bodyId: 'tg_diversionJourneyTableBody_tools', headId: 'tg_diversionJourneyTableHead_tools', placeholderId: 'tg_diversionJourneyPlaceholder_tools', titleDataAttr: 'tg_diversionJourneyTableBody_tools', defaultTitle: "Diversions / School Journeys" }
    ];

    tableConfigs.forEach(config => { /* Reset table displays as before */
        const tableBody = document.getElementById(config.bodyId);
        const tableHead = document.getElementById(config.headId);
        const placeholder = document.getElementById(config.placeholderId);
        const parentTable = tableBody ? tableBody.closest('table') : null;
        const titleElement = document.querySelector(`h4[data-table-for="${config.titleDataAttr}"]`);

        if (tableHead) tableHead.innerHTML = '';
        if (tableBody) tableBody.innerHTML = '';
        if (placeholder) {
            placeholder.textContent = 'Select a route and a destination to view services.';
            placeholder.style.display = 'block';
        }
        if (parentTable) parentTable.style.display = 'none';
        if (titleElement) titleElement.textContent = config.defaultTitle + (mainFocusDestination ? ` towards ${mainFocusDestination}` : "");
    });

    if (!selectedRoute || !mainFocusDestination) {
        if (tg_statusMessage) tg_statusMessage.textContent = "Please select both a route and a primary destination.";
        console.log("--- display_tg_Timetable END (no route or main destination chosen) ---"); return;
    }

    const allRouteEntries = currentWorkingSchedule.filter(entry =>
        entry.lineName === selectedRoute && entry.destinationName
    );
    console.log(`TG_DEBUG_V11: Fetched ${allRouteEntries.length} total entries for route '${selectedRoute}'.`);

    if (allRouteEntries.length === 0) { /* Handle no entries as before */
        if (tg_statusMessage) tg_statusMessage.textContent = `No schedule data found for route ${selectedRoute}.`;
        tableConfigs.forEach(config => {
            const placeholder = document.getElementById(config.placeholderId);
            if(placeholder) placeholder.textContent = `No schedule data for route ${selectedRoute}.`;
        });
        console.log("--- display_tg_Timetable END (no entries initially for route) ---");
        return;
    }

    let representativeDirectionText = "";
    const mainFocusEntriesForDirText = allRouteEntries.filter(e => e.destinationName === mainFocusDestination);
    if (mainFocusEntriesForDirText.length > 0) {
        const directionCounts = mainFocusEntriesForDirText.reduce((acc, e) => {
            if (e.direction && e.direction.trim()) acc[e.direction.trim()] = (acc[e.direction.trim()] || 0) + 1;
            return acc;
        }, {});
        let mostCommonDir = ""; let maxCount = 0;
        for (const dir in directionCounts) if (directionCounts[dir] > maxCount) { mostCommonDir = dir; maxCount = directionCounts[dir]; }
        representativeDirectionText = mostCommonDir;
    }
    console.log(`TG_DEBUG_V11: Representative 'Direction' (Towards) Text for '${mainFocusDestination}' is: '${representativeDirectionText}'`);

    let actualEndToEndDestinationsOnRoute = [];
    const uniqueDestsForRoute = [...new Set(allRouteEntries.map(e => e.destinationName))].filter(Boolean);
    if (uniqueDestsForRoute.length > 0) {
        const destSignificance = uniqueDestsForRoute.map(dn => ({ name: dn, stopCount: new Set(allRouteEntries.filter(e => e.destinationName === dn).map(e => e.stopID)).size }))
            .sort((a, b) => b.stopCount - a.stopCount || String(a.name).localeCompare(String(b.name)));
        if (destSignificance.length > 0 && destSignificance[0].name !== mainFocusDestination) actualEndToEndDestinationsOnRoute.push(destSignificance[0].name);
        if (destSignificance.length > 1 && destSignificance[1].name !== mainFocusDestination && !actualEndToEndDestinationsOnRoute.includes(destSignificance[1].name)) actualEndToEndDestinationsOnRoute.push(destSignificance[1].name);
    }
    console.log(`TG_DEBUG_V11: Other Identified Main End-Points for Route '${selectedRoute}':`, JSON.stringify(actualEndToEndDestinationsOnRoute));

    let fullJourneyEntries = [];
    let shortJourneyEntries = [];
    let diversionEntries = [];

    allRouteEntries.forEach(entry => {
        const entryDest = entry.destinationName;
        const entryDirectionField = (entry.direction || "").trim();
        const entryProfileUpper = (entry.OperatingProfile || "").toUpperCase();
        const entryKeyForLog = `StopID: ${entry.stopID}, Time: ${entry.scheduledTime}, Dest: '${entryDest}', Towards: '${entryDirectionField}', Profile: '${entry.OperatingProfile}'`;
        let categorized = false;

        // 1. Exclude services for completely opposite main directions
        if (actualEndToEndDestinationsOnRoute.includes(entryDest)) { // Removed && entryDest !== mainFocusDestination as it's implicit now
            // console.log(`TG_DEBUG_V11: Entry EXCLUDED (Opposite Main Direction): ${entryKeyForLog}`);
            return; 
        }

        // 2. Prioritize Diversion/School Journey categorization
        if (entryProfileUpper.includes("SCH")) {
            // A school journey is a diversion if it's heading in the representative direction OR
            // if there's no clear representative direction, we'll assume SCH profiles to non-main destinations are diversions.
            // (This could be refined if SCH journeys can also be "standard short" or "standard full")
            if (representativeDirectionText && entryDirectionField === representativeDirectionText) {
                diversionEntries.push(entry);
                categorized = true;
                // console.log(`TG_DEBUG_V11: Entry CATEGORIZED as Diversion (SCH Profile, Matching Rep. Dir): ${entryKeyForLog}`);
            } else if (!representativeDirectionText && entryDest !== mainFocusDestination) {
                // If no clear representative direction, but it's SCH and not to main destination, tentatively class as diversion
                diversionEntries.push(entry);
                categorized = true;
                // console.log(`TG_DEBUG_V11: Entry CATEGORIZED as Diversion (SCH Profile, No Rep. Dir, Not Main Dest): ${entryKeyForLog}`);
            } else if (representativeDirectionText && entryDirectionField !== representativeDirectionText){
                 // console.log(`TG_DEBUG_V11: SCH Entry NOT a Diversion (Direction Mismatch with Rep. Dir): ${entryKeyForLog}`);
            }
            // If an SCH profile journey goes to mainFocusDestination AND its direction matches representativeDirectionText,
            // it will be caught here as a diversion. This is the change in priority.
        }

        // 3. If NOT categorized as a diversion, check for Full Journey
        if (!categorized && entryDest === mainFocusDestination) {
            fullJourneyEntries.push(entry);
            categorized = true;
            // console.log(`TG_DEBUG_V11: Entry CATEGORIZED as Full Journey (Not SCH diversion): ${entryKeyForLog}`);
        }

        // 4. If NOT a diversion or full journey, check for Short Journey
        if (!categorized && representativeDirectionText && entryDirectionField === representativeDirectionText) {
            shortJourneyEntries.push(entry);
            categorized = true;
            // console.log(`TG_DEBUG_V11: Entry CATEGORIZED as Short Journey (Not SCH diversion or Full): ${entryKeyForLog}`);
        }

        // if (!categorized) {
        //     console.log(`TG_DEBUG_V11: Entry NOT CATEGORIZED for any view (Route: ${selectedRoute}, MainDest: ${mainFocusDestination}): ${entryKeyForLog}`);
        // }
    });

    console.log(`TG_DEBUG_V11: Categorization complete. Full: ${fullJourneyEntries.length}, Short: ${shortJourneyEntries.length}, Diversion: ${diversionEntries.length}`);

    renderSingleTimetableDisplay(`Full Journeys to ${mainFocusDestination}`, fullJourneyEntries, 'tg_fullJourneyTableBody_tools', 'tg_fullJourneyTableHead_tools', 'tg_fullJourneyPlaceholder_tools', mainFocusDestination);
    renderSingleTimetableDisplay(`Short Journeys towards ${mainFocusDestination}`, shortJourneyEntries, 'tg_shortJourneyTableBody_tools', 'tg_shortJourneyTableHead_tools', 'tg_shortJourneyPlaceholder_tools', mainFocusDestination);
    renderSingleTimetableDisplay(`Diversions / School Journeys towards ${mainFocusDestination}`, diversionEntries, 'tg_diversionJourneyTableBody_tools', 'tg_diversionJourneyTableHead_tools', 'tg_diversionJourneyPlaceholder_tools', mainFocusDestination);

    if (tg_statusMessage) {
        tg_statusMessage.textContent = `Timetables displayed for route ${selectedRoute}, primarily towards ${mainFocusDestination}.`;
        tg_statusMessage.style.color = '#2ecc71';
    }
    console.log("--- display_tg_Timetable END (V11 - Refined Categorization Priority) ---");
}
// --- END: Timetable Generator Functions ---


// --- Replace your existing gen_addIntervalRule function with this one ---
function gen_addIntervalRule(ruleData = null) {
    gen_ruleCounter++;
    const container = document.getElementById('gen_intervalRulesContainer');
    if (!container) {
        console.error("Could not find gen_intervalRulesContainer");
        return;
    }

    const ruleDiv = document.createElement('div');
    ruleDiv.className = 'gen_interval-rule';
    ruleDiv.id = `gen_rule-${gen_ruleCounter}`; // ID is set using the incremented counter

    const ruleTitle = document.createElement('h4');
    ruleTitle.textContent = `Rule ${gen_ruleCounter}`;
    ruleDiv.appendChild(ruleTitle);

    const inputGroupDiv = document.createElement('div');
    inputGroupDiv.className = 'gen_input-group';

    // Start Time Input
    const startTimeDiv = document.createElement('div');
    const startTimeLabel = document.createElement('label');
    startTimeLabel.setAttribute('for', `gen_startTime-${gen_ruleCounter}`);
    startTimeLabel.textContent = 'Start Time (HHMM):';
    const startTimeInput = document.createElement('input');
    startTimeInput.type = 'text';
    startTimeInput.id = `gen_startTime-${gen_ruleCounter}`;
    startTimeInput.className = 'schedule-generator-input';
    startTimeInput.placeholder = 'e.g., 0900';
    startTimeDiv.appendChild(startTimeLabel);
    startTimeDiv.appendChild(startTimeInput);
    inputGroupDiv.appendChild(startTimeDiv);
    
    // End Time Input
    const endTimeDiv = document.createElement('div');
    const endTimeLabel = document.createElement('label');
    endTimeLabel.setAttribute('for', `gen_endTime-${gen_ruleCounter}`);
    endTimeLabel.textContent = 'End Time (HHMM):';
    const endTimeInput = document.createElement('input');
    endTimeInput.type = 'text';
    endTimeInput.id = `gen_endTime-${gen_ruleCounter}`;
    endTimeInput.className = 'schedule-generator-input';
    endTimeInput.placeholder = 'e.g., 1900';
    endTimeDiv.appendChild(endTimeLabel);
    endTimeDiv.appendChild(endTimeInput);
    inputGroupDiv.appendChild(endTimeDiv);

    // Interval Input
    const intervalDiv = document.createElement('div');
    const intervalLabel = document.createElement('label');
    intervalLabel.setAttribute('for', `gen_interval-${gen_ruleCounter}`);
    intervalLabel.textContent = 'Interval (minutes):';
    const intervalInput = document.createElement('input');
    intervalInput.type = 'number';
    intervalInput.id = `gen_interval-${gen_ruleCounter}`;
    intervalInput.className = 'schedule-generator-input';
    intervalInput.min = '1';
    intervalInput.placeholder = '15';
    intervalDiv.appendChild(intervalLabel);
    intervalDiv.appendChild(intervalInput);
    inputGroupDiv.appendChild(intervalDiv);

    ruleDiv.appendChild(inputGroupDiv);

    // --- MODIFIED Remove Button Logic START ---
    const removeButton = document.createElement('button');
    removeButton.className = 'button small-action tertiary';
    removeButton.textContent = 'Remove Rule';
    removeButton.style.marginLeft = '0'; 
    removeButton.style.marginTop = '5px'; 

    // Capture the specific ID this button is responsible for.
    // gen_ruleCounter at this moment is the correct counter for the rule being added.
    const idForThisButtonToRemove = `gen_rule-${gen_ruleCounter}`;

    // Define the event handler function separately for clarity and so it can be removed.
    const removeHandler = () => {
        // Optional: console.log(`[DEBUG] "Remove Rule" button (for ${idForThisButtonToRemove}) event handler triggered.`);
        
        gen_removeIntervalRule(idForThisButtonToRemove); // Call the actual removal function

        // Disable the button immediately to prevent further clicks on this specific button instance.
        removeButton.disabled = true; 
        // Remove this specific event listener instance from this button.
        removeButton.removeEventListener('click', removeHandler);
    };

    removeButton.addEventListener('click', removeHandler); // Attach the defined handler
    ruleDiv.appendChild(removeButton);
    // --- MODIFIED Remove Button Logic END ---

    container.appendChild(ruleDiv);

    // If ruleData is provided (e.g., from localStorage when loading), populate the fields
    if (ruleData) {
        if(startTimeInput) startTimeInput.value = ruleData.startTime || '';
        if(endTimeInput) endTimeInput.value = ruleData.endTime || '';
        if(intervalInput) intervalInput.value = ruleData.interval || '';
    }
}
// --- End of the gen_addIntervalRule function ---


function gen_removeIntervalRule(ruleId) {
    console.log(`Attempting to remove rule with ID: ${ruleId}`); // 1. Is this function called? What's the ID?
    const ruleElement = document.getElementById(ruleId);
    if (ruleElement) {
        console.log(`Found rule element to remove:`, ruleElement); // 2. Was the element found?
        try {
            ruleElement.remove();
            console.log(`Rule element ${ruleId} removed from DOM.`); // 3. Did remove() execute?
            gen_saveDataToLocalStorage(); // 4. Does saving cause an error? Or is it saving correct state?
        } catch (e) {
            console.error(`Error during rule removal or saving for ${ruleId}:`, e);
        }
    } else {
        console.warn(`Could not find rule element with ID: ${ruleId} to remove.`);
    }
}

// Helper to convert HHMM string to minutes from midnight
function gen_hhmmToMinutes(hhmmStr) {
    if (!hhmmStr || hhmmStr.length !== 4 || !/^\d{4}$/.test(hhmmStr)) return 0; // Basic validation
    const hours = parseInt(hhmmStr.substring(0, 2), 10);
    const minutes = parseInt(hhmmStr.substring(2, 4), 10);
    if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) return 0; // More validation
    return hours * 60 + minutes;
}

// Helper to convert minutes from midnight back to HHMM string
function gen_minutesToHHMM(totalMinutes) {
    const hours = Math.floor(totalMinutes / 60) % 24; // Use % 24 to handle times crossing midnight
    const minutes = totalMinutes % 60;
    return String(hours).padStart(2, '0') + String(minutes).padStart(2, '0');
}

// Helper to format HHMM to HH:MM for display
function gen_formatTimeToHHMMColon(hhmmStr) {
    const timeStr = String(hhmmStr || "").padStart(4, '0'); // Ensure 4 digits
    if (timeStr.length === 4 && !isNaN(parseInt(timeStr,10))) { // Check if it's a 4-digit number
         return timeStr.substring(0, 2) + ":" + timeStr.substring(2, 4);
    }
    return hhmmStr; // Return original if not in expected format
}

// Get base data from the generator form
function gen_getBaseDataFromForm() {
    return {
        stopId: document.getElementById('gen_stopId')?.value.trim(),
        stopName: document.getElementById('gen_stopName')?.value.trim(),
        direction: document.getElementById('gen_direction')?.value.trim(),
        lineName: document.getElementById('gen_lineName')?.value.trim().toUpperCase(), // Standardize to uppercase
        destinationName: document.getElementById('gen_destinationName')?.value.trim(),
        operatingProfile: document.getElementById('gen_operatingProfile')?.value.trim(),
        initialScheduledTime: document.getElementById('gen_initialScheduledTime')?.value.trim(),
        initialDayOffset: document.getElementById('gen_initialDayOffset')?.value.trim() || '0' // Default to '0'
    };
}

// Get interval rules from the dynamically added rule forms
function gen_getIntervalRulesFromForm() {
    const intervalRulesData = [];
    document.querySelectorAll('#gen_intervalRulesContainer .gen_interval-rule').forEach(ruleElement => {
        const idNum = ruleElement.id.split('-')[1]; // Extract number from rule ID
        const startTime = document.getElementById(`gen_startTime-${idNum}`)?.value.trim();
        const endTime = document.getElementById(`gen_endTime-${idNum}`)?.value.trim();
        const intervalValue = document.getElementById(`gen_interval-${idNum}`)?.value.trim();

        // Only add rule if all parts are present and interval is valid
        if (startTime && endTime && intervalValue && parseInt(intervalValue, 10) > 0) {
             intervalRulesData.push({
                startTime: startTime,
                endTime: endTime,
                interval: parseInt(intervalValue, 10)
            });
        } else if (startTime || endTime || intervalValue) { // Log if rule is incomplete but partially filled
            console.warn(`Generator: Incomplete or invalid interval rule ${idNum} skipped (Start: ${startTime}, End: ${endTime}, Interval: ${intervalValue})`);
        }
    });
    return intervalRulesData;
}

// Save all generator data (base, rules, current table) to localStorage
function gen_saveDataToLocalStorage() {
    // Only save if the generator section is visible or has been initialized
    if (document.getElementById('schedule-generator-section')?.style.display !== 'block' && !gen_isInitialized) {
        return; // Avoid saving if section not active and never initialized
    }
    try {
        const appData = {
            baseData: gen_getBaseDataFromForm(),
            intervalRules: gen_getIntervalRulesFromForm(),
            generatedSchedule: gen_currentScheduleEntries // Save the current state of the table
        };
        localStorage.setItem(GEN_APP_DATA_KEY, JSON.stringify(appData));
    } catch (e) {
        console.error("Error saving generator data to localStorage:", e);
    }
}

// Load data from localStorage on page load or section display
function gen_loadDataFromLocalStorage() {
    const savedDataString = localStorage.getItem(GEN_APP_DATA_KEY);
    if (savedDataString) {
        try {
            const appData = JSON.parse(savedDataString);

            // Populate base data fields
            if (appData.baseData) {
                const fieldsToSet = {
                    'gen_stopId': appData.baseData.stopId,
                    'gen_stopName': appData.baseData.stopName,
                    'gen_direction': appData.baseData.direction,
                    'gen_lineName': appData.baseData.lineName,
                    'gen_destinationName': appData.baseData.destinationName,
                    'gen_operatingProfile': appData.baseData.operatingProfile,
                    'gen_initialScheduledTime': appData.baseData.initialScheduledTime,
                    'gen_initialDayOffset': appData.baseData.initialDayOffset || '0',
                };
                for (const id in fieldsToSet) {
                    const el = document.getElementById(id);
                    if (el) el.value = fieldsToSet[id] || '';
                }

                // Attempt to re-select in dropdowns if values were saved
                const gen_stopNameSelectEl = document.getElementById('gen_stopNameSelect');
                if (gen_stopNameSelectEl && appData.baseData.stopId) {
                    // Check if option exists before setting
                    let optionExists = Array.from(gen_stopNameSelectEl.options).some(opt => opt.value === appData.baseData.stopId);
                    if (optionExists) {
                        gen_stopNameSelectEl.value = appData.baseData.stopId;
                    } else {
                         gen_stopNameSelectEl.selectedIndex = 0; // Default to first option if not found
                    }
                }
                gen_stopNameSelectEl?.dispatchEvent(new Event('change')); // Trigger change to update related fields

                // For route and destination, which depend on other selects/inputs being populated first
                // Use setTimeout to allow dependent dropdowns to populate from `currentWorkingSchedule`
                setTimeout(() => {
                    const lineNameInputEl = document.getElementById('gen_lineName');
                    const routeSelectEl = document.getElementById('gen_routeSelect');
                    if (routeSelectEl && lineNameInputEl && lineNameInputEl.value) {
                        let optionExists = Array.from(routeSelectEl.options).some(opt => opt.value === lineNameInputEl.value);
                        if (optionExists) routeSelectEl.value = lineNameInputEl.value;
                        else routeSelectEl.selectedIndex = 0;
                    }
                    // Trigger input event to ensure gen_populateDestinationSelect is called
                    lineNameInputEl?.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));

                    // Nested setTimeout for destination, as it depends on route select
                    setTimeout(() => {
                        const destNameInputEl = document.getElementById('gen_destinationName');
                        const destSelectEl = document.getElementById('gen_destinationSelect');
                        if (destSelectEl && destNameInputEl && destNameInputEl.value) {
                           let optionExists = Array.from(destSelectEl.options).some(opt => opt.value === destNameInputEl.value);
                           if(optionExists) destSelectEl.value = destNameInputEl.value;
                           else destSelectEl.selectedIndex = 0;
                        }
                    }, 150); // Small delay for destination select population
                }, 100); // Small delay for route select population
            }

            // Re-create interval rules
            const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
            if(intervalRulesContainer) intervalRulesContainer.innerHTML = ''; // Clear existing before adding
            gen_ruleCounter = 0; // Reset counter
            (appData.intervalRules || []).forEach(ruleData => gen_addIntervalRule(ruleData));

            // Load generated schedule table
            gen_currentScheduleEntries = appData.generatedSchedule || [];
            gen_renderScheduleTable();

        } catch (e) {
            console.error("Error loading/parsing generator data from localStorage:", e);
            localStorage.removeItem(GEN_APP_DATA_KEY); // Remove corrupted data
             // Add a default rule if parsing failed and rules are empty
             gen_addIntervalRule();
        }
    } else {
        // No saved data, ensure at least one interval rule exists if container is empty
        const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
        if (intervalRulesContainer && intervalRulesContainer.childElementCount === 0) {
            gen_addIntervalRule();
        }
        // Trigger change on stop name select to ensure related fields are cleared/defaulted
        document.getElementById('gen_stopNameSelect')?.dispatchEvent(new Event('change'));
    }
}


// Clear all generator data (form fields, rules, table)
function gen_clearAllData() {
    if (confirm("Are you sure you want to clear all data for the Schedule Generator? This includes base data, interval rules and the current generated schedule table. This cannot be undone.")) {
        const fieldsToClear = [
            'gen_stopId', 'gen_stopName', 'gen_direction',
            'gen_lineName', 'gen_destinationName',
            'gen_operatingProfile', 'gen_initialScheduledTime', 'gen_initialDayOffset'
        ];
        fieldsToClear.forEach(id => {
            const el = document.getElementById(id);
            if(el) el.value = '';
        });

        // Reset selects to their first option (usually a prompt)
        ['gen_stopNameSelect', 'gen_routeSelect', 'gen_destinationSelect'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.selectedIndex = 0;
        });
        const initialDayOffsetEl = document.getElementById('gen_initialDayOffset');
        if(initialDayOffsetEl) initialDayOffsetEl.value = '0'; // Default day offset

        // Clear interval rules and add one default empty rule
        const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
        if(intervalRulesContainer) intervalRulesContainer.innerHTML = '';
        gen_ruleCounter = 0; // Reset rule counter
        gen_addIntervalRule(); // Add a fresh rule

        // Clear and re-render the schedule table
        gen_currentScheduleEntries = [];
        gen_renderScheduleTable();

        localStorage.removeItem(GEN_APP_DATA_KEY); // Remove from localStorage
        alert("All generator data has been cleared.");

        // Trigger change on stop name select to ensure related fields are updated/cleared
        document.getElementById('gen_stopNameSelect')?.dispatchEvent(new Event('change'));
    }
}


function gen_generateSchedule() {
    gen_currentScheduleEntries = []; // Start with an empty array for new generation
    const addedEntryKeys = new Set(); // To prevent duplicate entries from different rules generating same time

    // Get base data for all entries
    const baseFormValues = gen_getBaseDataFromForm();
    const baseDataForGeneration = {
        stopId: baseFormValues.stopId,
        stopName: baseFormValues.stopName,
        direction: baseFormValues.direction,
        lineName: baseFormValues.lineName,
        destinationName: baseFormValues.destinationName,
        operatingProfile: baseFormValues.operatingProfile,
        // Note: DayOffset from base form is only for the *initial* entry if provided
    };

    // Add the initial entry if provided
    if (baseFormValues.initialScheduledTime && baseFormValues.initialScheduledTime.match(/^\d{3,4}$/)) {
        const initialEntry = {
            ...baseDataForGeneration,
            scheduledTime: baseFormValues.initialScheduledTime.padStart(4,'0'), // Ensure HHMM format
            dayOffset: baseFormValues.initialDayOffset || '0'
        };
        // Create a unique key for this entry to avoid duplicates if rules overlap
        const initialKey = `${initialEntry.stopId}-${initialEntry.lineName}-${initialEntry.scheduledTime}-${initialEntry.operatingProfile}`;
        gen_currentScheduleEntries.push(initialEntry);
        addedEntryKeys.add(initialKey);
    }

    // Process interval rules
    const intervalRules = gen_getIntervalRulesFromForm();
    intervalRules.forEach(rule => {
        const startTimeStr = rule.startTime;
        const endTimeStr = rule.endTime;
        const intervalMins = parseInt(rule.interval, 10);

        // Validate rule components
        if (!startTimeStr || !startTimeStr.match(/^\d{3,4}$/) ||
            !endTimeStr || !endTimeStr.match(/^\d{3,4}$/) ||
            isNaN(intervalMins) || intervalMins <= 0) {
            console.warn(`Generator: Skipping invalid rule: Start-${startTimeStr}, End-${endTimeStr}, Interval-${rule.interval}`);
            return; // Skip this rule
        }

        let currentTotalMinutes = gen_hhmmToMinutes(startTimeStr.padStart(4,'0'));
        const endTotalMinutesInput = gen_hhmmToMinutes(endTimeStr.padStart(4,'0'));
        let effectiveEndTotalMinutes = endTotalMinutesInput;

        // Handle rules that span midnight (e.g., 22:00 to 02:00)
        // If start time is numerically greater than end time (e.g., 2200 > 0200), end time is on the next day.
        if (currentTotalMinutes > endTotalMinutesInput && startTimeStr > endTimeStr) { // Heuristic for overnight
             effectiveEndTotalMinutes += 24 * 60; // Add a day's worth of minutes to end time
        }

        const ruleStartHourForContext = parseInt(startTimeStr.padStart(4,'0').substring(0, 2), 10);
        // Rule is considered "new day service" if it *starts* between 00:00-03:59.
        // This impacts the DayOffset logic for times generated by *this specific rule*.
        const isRuleConsideredNewDayService = (ruleStartHourForContext >= 0 && ruleStartHourForContext <= 3);

        while (currentTotalMinutes <= effectiveEndTotalMinutes) {
            const scheduledTimeHHMM = gen_minutesToHHMM(currentTotalMinutes); // currentTotalMinutes can be > 1440
            const entryKey = `${baseDataForGeneration.stopId}-${baseDataForGeneration.lineName}-${scheduledTimeHHMM}-${baseDataForGeneration.operatingProfile}`;

            if (!addedEntryKeys.has(entryKey)) {
                let generatedDayOffset = 0; // Default DayOffset for this generated time
                const currentGeneratedHour = parseInt(scheduledTimeHHMM.substring(0,2), 10); // Hour of the generated time (0-23)

                // DayOffset logic based on rule's start context and generated time
                if (isRuleConsideredNewDayService) {
                    // If the rule itself starts in the 00:00-03:59 window, all its generated times
                    // are considered part of that service day, so DayOffset remains 0 relative to the rule's start.
                    generatedDayOffset = 0;
                } else {
                    // If the rule starts *before* midnight (e.g., 22:00):
                    // Only if the *generated time* crosses into the 00:00-03:59 window *and*
                    // currentTotalMinutes reflects it's past the first midnight (>= 1440 minutes from 00:00 of rule start day)
                    // then DayOffset becomes 1.
                    if (currentTotalMinutes >= 1440 && (currentGeneratedHour >=0 && currentGeneratedHour <=3)) {
                         generatedDayOffset = 1;
                    } else {
                        generatedDayOffset = 0;
                    }
                }

                gen_currentScheduleEntries.push({
                    ...baseDataForGeneration,
                    scheduledTime: scheduledTimeHHMM,
                    dayOffset: String(generatedDayOffset)
                });
                addedEntryKeys.add(entryKey);
            }

            if (intervalMins === 0) break; // Safety break for zero interval
            currentTotalMinutes += intervalMins;
        }
    });

    // Sort the final list for display
    gen_currentScheduleEntries.sort((a, b) => {
        const timeA = (a.dayOffset || '0') + (a.scheduledTime || '9999');
        const timeB = (b.dayOffset || '0') + (b.scheduledTime || '9999');
        return timeA.localeCompare(timeB);
    });

    gen_renderScheduleTable(); // Update the UI
    gen_saveDataToLocalStorage(); // Persist changes
}

function gen_deleteScheduleEntry(index) {
    if (index < 0 || index >= gen_currentScheduleEntries.length) {
        console.error("Invalid index for deletion from generator table:", index);
        return;
    }

    const entryToDelete = gen_currentScheduleEntries[index];
    let timeToDisplay = entryToDelete.scheduledTime || "";
    // Format time for confirmation dialog
    if (timeToDisplay.length === 4 && !isNaN(timeToDisplay)) {
        timeToDisplay = `${timeToDisplay.substring(0,2)}:${timeToDisplay.substring(2,4)}`;
    } else if (timeToDisplay.length === 3 && !isNaN(timeToDisplay)) { // e.g. 745 -> 07:45
            timeToDisplay = `0${timeToDisplay.substring(0,1)}:${timeToDisplay.substring(1,3)}`;
    }


    if (confirm(`Are you sure you want to delete this entry from the generator's table?\nStop: ${entryToDelete.stopId} - ${entryToDelete.stopName}\nLine: ${entryToDelete.lineName}\nTime: ${timeToDisplay}\nDest: ${entryToDelete.destinationName}`)) {
        gen_currentScheduleEntries.splice(index, 1); // Remove the entry
        gen_renderScheduleTable(); // Re-render the table
        gen_saveDataToLocalStorage(); // Save the updated list
        console.log("Entry deleted from generator list and local storage updated.");
    }
}


// Render the current schedule entries into the HTML table
// In omsi_tools.html, inside the main <script> block:

// REPLACE the existing gen_renderScheduleTable function with this:
function gen_renderScheduleTable() {
    const resultsTable = document.getElementById('gen_resultsTable');
    if (!resultsTable) return;
    const resultsBody = resultsTable.getElementsByTagName('tbody')[0];
    const resultsHead = resultsTable.getElementsByTagName('thead')[0];
    if (!resultsBody || !resultsHead) return;

    resultsBody.innerHTML = ''; // Clear existing rows

    // Ensure table headers are correct (Actions column should be last)
    if (resultsHead.rows.length > 0) {
        let headerRow = resultsHead.rows[0];
        if (headerRow.cells.length === 0 || headerRow.cells[headerRow.cells.length - 1].textContent !== "Actions") {
            headerRow.innerHTML = `<th>StopID</th><th>StopName</th><th>Direction</th><th>LineName</th><th>DestinationName</th><th>ScheduledTime (HH:MM)</th><th>OperatingProfile</th><th>DayOffset</th><th>Actions</th>`;
        }
    } else {
        let header = resultsTable.createTHead();
        let row = header.insertRow(0);
        row.innerHTML = `<th>StopID</th><th>StopName</th><th>Direction</th><th>LineName</th><th>DestinationName</th><th>ScheduledTime (HH:MM)</th><th>OperatingProfile</th><th>DayOffset</th><th>Actions</th>`;
    }

    if (!gen_currentScheduleEntries || gen_currentScheduleEntries.length === 0) {
        // Optionally display a message like "No data in generator table."
        return;
    }

    const groupedDisplayEntries = new Map();

    // Group entries by all fields except time, collecting original indices
    gen_currentScheduleEntries.forEach((entry, originalIndex) => {
        const key = [
            (entry.stopId || "").trim().toUpperCase(),
            (entry.stopName || "").trim(),
            (entry.direction || "").trim(),
            (entry.lineName || "").trim().toUpperCase(),
            (entry.destinationName || "").trim(),
            (entry.operatingProfile || "").trim(),
            String(entry.dayOffset || "0").trim()
        ].join("⁂"); // Unique delimiter

        let timeForThisEntry = entry.scheduledTime || ""; // Expected HHMM string

        if (!groupedDisplayEntries.has(key)) {
            groupedDisplayEntries.set(key, {
                stopId: (entry.stopId || "").trim().toUpperCase(),
                stopName: (entry.stopName || "").trim(),
                direction: (entry.direction || "").trim(),
                lineName: (entry.lineName || "").trim().toUpperCase(),
                destinationName: (entry.destinationName || "").trim(),
                operatingProfile: (entry.operatingProfile || "").trim(),
                dayOffset: String(entry.dayOffset || "0").trim(),
                // Store objects with time (HHMM) and originalIndex
                timeEntries: [] 
            });
        }
        
        // Add the HHMM time and its original index to the group's timeEntries array
        if (timeForThisEntry.match(/^\d{3,4}$/)) { // e.g. "0745", "1230"
             groupedDisplayEntries.get(key).timeEntries.push({ time: timeForThisEntry.padStart(4, '0'), originalIndex: originalIndex });
        } else if (timeForThisEntry.match(/^\d{2}:\d{2}$/)) { // If it was already HH:MM
             groupedDisplayEntries.get(key).timeEntries.push({ time: timeForThisEntry.replace(':', '').padStart(4,'0'), originalIndex: originalIndex });
        } else {
            console.warn("RenderTable: Skipping invalid time format during grouping:", timeForThisEntry, "for entry at index:", originalIndex);
        }
    });

    // Iterate through the grouped entries to build the table rows
    groupedDisplayEntries.forEach((group, groupKey) => {
        let newRow = resultsBody.insertRow();
        newRow.insertCell().textContent = group.stopId;
        newRow.insertCell().textContent = group.stopName;
        newRow.insertCell().textContent = group.direction;
        newRow.insertCell().textContent = group.lineName;
        newRow.insertCell().textContent = group.destinationName;

        // Sort timeEntries by HHMM time string
        group.timeEntries.sort((a, b) => a.time.localeCompare(b.time));

        // Format HHMM times to HH:MM for display
        const displayTimesArray = group.timeEntries.map(te => {
            const hhmm = te.time;
            if (hhmm.length === 4) return `${hhmm.substring(0, 2)}:${hhmm.substring(2, 4)}`;
            // Fallback for safety, though times should be 4-digit HHMM
            return hhmm; 
        });
        newRow.insertCell().textContent = displayTimesArray.join(', ');

        newRow.insertCell().textContent = group.operatingProfile;
        newRow.insertCell().textContent = group.dayOffset;

        // Add action cell with delete button for the group
        let actionCell = newRow.insertCell();
        let deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete'; // "Delete Group" might be too long for small button
        deleteButton.classList.add('button', 'small-action', 'secondary');
        
        const originalIndicesForThisGroup = group.timeEntries.map(te => te.originalIndex);
        deleteButton.addEventListener('click', () => gen_deleteScheduleEntriesByGroup(originalIndicesForThisGroup, group)); // Pass group for confirmation msg
        actionCell.appendChild(deleteButton);
    });
}

// REPLACE the existing gen_deleteScheduleEntry function with gen_deleteScheduleEntriesByGroup
// (or remove gen_deleteScheduleEntry if it's no longer called from anywhere else)
function gen_deleteScheduleEntriesByGroup(originalIndicesToDelete, groupDetails) {
    if (!originalIndicesToDelete || originalIndicesToDelete.length === 0) {
        console.error("No indices provided for deletion.");
        return;
    }

    let confirmationMessage = `Are you sure you want to delete this group of ${originalIndicesToDelete.length} time entries from the generator's table?`;
    if (groupDetails) {
        const timesToDisplay = groupDetails.timeEntries.map(te => {
            const hhmm = te.time;
            if (hhmm.length === 4) return `${hhmm.substring(0, 2)}:${hhmm.substring(2, 4)}`;
            return hhmm;
        }).slice(0, 5).join(', '); // Show up to 5 times
        
        confirmationMessage = `Are you sure you want to delete all times for:\nStop: ${groupDetails.stopName} (${groupDetails.stopId})\nLine: ${groupDetails.lineName}\nDest: ${groupDetails.destinationName}\nProfile: ${groupDetails.operatingProfile}\nTimes: ${timesToDisplay}${groupDetails.timeEntries.length > 5 ? '...' : ''}\n\nThis will remove ${originalIndicesToDelete.length} underlying schedule entries.`;
    }


    if (confirm(confirmationMessage)) {
        // Remove entries from gen_currentScheduleEntries by original indices.
        // Must remove in reverse order of index to avoid issues with shifting array indices.
        originalIndicesToDelete.sort((a, b) => b - a); // Sort indices descending
        
        originalIndicesToDelete.forEach(index => {
            if (index >= 0 && index < gen_currentScheduleEntries.length) {
                gen_currentScheduleEntries.splice(index, 1);
            } else {
                console.warn("gen_deleteScheduleEntriesByGroup: Invalid index attempted for deletion:", index);
            }
        });
        
        gen_renderScheduleTable(); // Re-render the table (which will re-group)
        gen_saveDataToLocalStorage(); // Save the updated gen_currentScheduleEntries
        console.log("Group of entries deleted from generator list and local storage updated.");
    }
}


// In omsi_tools.html, inside the main <script> block,
// replace the existing gen_exportToCountFile function with this:

function gen_exportToCountFile() {
    if (!gen_currentScheduleEntries || gen_currentScheduleEntries.length === 0) {
        alert("No schedule data to export from generator. Please generate or load a schedule first.");
        return;
    }

    const groupedEntries = new Map();

    // Group entries by all fields except time
    gen_currentScheduleEntries.forEach(entry => {
        // Create a consistent key for grouping.
        // Note: entry.scheduledTime is expected to be an HHMM string (e.g., "0845")
        // from the generator's internal storage.
        const key = [
            (entry.stopId || "").trim().toUpperCase(),
            (entry.stopName || "").trim(),
            (entry.direction || "").trim(),
            (entry.lineName || "").trim().toUpperCase(),
            (entry.destinationName || "").trim(),
            (entry.operatingProfile || "").trim(), // OperatingProfile is case-sensitive
            String(entry.dayOffset || "0").trim()
        ].join("⁂"); // Using a less common delimiter for the key

        let timeForThisEntry = entry.scheduledTime || ""; // Expected HHMM string e.g., "0745", "1230"

        if (!groupedEntries.has(key)) {
            groupedEntries.set(key, {
                // Store common data from the first entry encountered for this group
                stopId: (entry.stopId || "").trim().toUpperCase(),
                stopName: (entry.stopName || "").trim(),
                direction: (entry.direction || "").trim(),
                lineName: (entry.lineName || "").trim().toUpperCase(),
                destinationName: (entry.destinationName || "").trim(),
                operatingProfile: (entry.operatingProfile || "").trim(),
                dayOffset: String(entry.dayOffset || "0").trim(),
                times: [] // Store times as HHMM strings initially for sorting
            });
        }

        // Add the HHMM time to the group's times array if it's a valid 3 or 4 digit string
        // The generator should already store them padded, but good to be safe.
        if (timeForThisEntry.match(/^\d{3,4}$/)) {
             groupedEntries.get(key).times.push(timeForThisEntry.padStart(4, '0'));
        } else if (timeForThisEntry.match(/^\d{2}:\d{2}$/)) { // If somehow it's already HH:MM
             groupedEntries.get(key).times.push(timeForThisEntry.replace(':', '').padStart(4, '0'));
        } else {
            console.warn("Export: Skipping invalid time format during grouping:", timeForThisEntry, "for entry:", entry);
        }
    });

    const headers = [
        "StopID", "StopName", "Direction", "LineName",
        "DestinationName", "ScheduledTime", "OperatingProfile", "DayOffset"
    ];
    let tabText = headers.join("\t") + "\n"; // Header row

    // Iterate through the grouped entries to build the export string
    groupedEntries.forEach(group => {
        // Sort times (which are HHMM strings like "0745", "1230")
        group.times.sort((a, b) => a.localeCompare(b)); // Standard string sort works for HHMM

        // Format HHMM times to HH:MM for the comma-separated string
        const formattedTimesArray = group.times.map(hhmm => {
            if (hhmm.length === 4) {
                return `${hhmm.substring(0, 2)}:${hhmm.substring(2, 4)}`;
            }
            // This case should ideally not be hit if times are stored as padded HHMM
            if (hhmm.length === 3) { 
                return `0${hhmm.substring(0, 1)}:${hhmm.substring(1, 3)}`;
            }
            return hhmm; // Fallback, though input should be HHMM
        });

        // Join with comma and a space for readability, matching your example format
        // Your import logic uses .trim() so it handles the space fine.
        const commaSeparatedTimes = formattedTimesArray.join(', '); 

        const rowValues = [
            group.stopId, group.stopName, group.direction, group.lineName,
            group.destinationName, commaSeparatedTimes, group.operatingProfile, group.dayOffset
        ];
        
        // Replace any tabs or newlines within fields to prevent breaking TSV format
        tabText += rowValues.map(val => String(val === undefined || val === null ? '' : val).replace(/\t|\n|\r/g, " ")).join("\t") + "\n";
    });

    const blob = new Blob([tabText], { type: 'text/plain;charset=utf-8;' });
    const link = document.createElement("a");

    if (link.download !== undefined) { // Check for browser support
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "schedule_generated.count"); // Filename
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url); // Clean up
    } else {
        alert("Your browser does not support automatic file downloading.");
    }
}


function gen_handleAddGeneratedToWorkingSchedule() {
    if (!currentUser) {
        alert("Please log in to modify the working schedule.");
        return;
    }
    if (!gen_currentScheduleEntries || gen_currentScheduleEntries.length === 0) {
        alert("No schedule entries generated/loaded in the generator's table to add.");
        return;
    }

    const actionChoice = prompt("Choose action for adding entries from the generator's table to the main working schedule:\n1. OVERWRITE entire working schedule.\n2. APPEND to existing working schedule.\n\nEnter 1 or 2 (or Cancel):");

    if (actionChoice !== "1" && actionChoice !== "2") {
        if (actionChoice !== null) alert("Invalid choice. Operation cancelled."); // Handle if user enters something other than 1, 2, or cancels
        return;
    }

    const isOverwrite = actionChoice === "1";

    if (isOverwrite) {
        if (!confirm(`ARE YOU SURE you want to OVERWRITE the ENTIRE main working schedule with these ${gen_currentScheduleEntries.length} entries from the generator's table? THIS CANNOT BE UNDONE EASILY.`)) {
            return;
        }
        currentWorkingSchedule = []; // Clear the main working schedule
    } else { // Append
        if (!confirm(`Are you sure you want to APPEND these ${gen_currentScheduleEntries.length} entries to the main working schedule?`)) {
            return;
        }
    }

    let addedCount = 0;
    const newEntriesForWorkingSchedule = gen_currentScheduleEntries.map((genEntry, index) => {
        // Standardize scheduledTime to HH:MM for the working schedule
        let scheduledTimeForWorking = genEntry.scheduledTime || "";
        if (scheduledTimeForWorking && scheduledTimeForWorking.length === 4 && !scheduledTimeForWorking.includes(':')) {
            scheduledTimeForWorking = `${scheduledTimeForWorking.substring(0,2)}:${scheduledTimeForWorking.substring(2,4)}`;
        } else if (scheduledTimeForWorking && scheduledTimeForWorking.length === 3 && !scheduledTimeForWorking.includes(':')) {
            scheduledTimeForWorking = `0${scheduledTimeForWorking.substring(0,1)}:${scheduledTimeForWorking.substring(1,3)}`;
        }

        // Generate a unique internalId for each new entry
        const uniqueSuffix = Date.now() + "_" + index + (isOverwrite ? "_ow_gen" : "_app_gen");
        const internalId = `${(genEntry.stopId||'s').toUpperCase()}_${(genEntry.lineName||'l').toUpperCase()}_${(genEntry.scheduledTime||"").replace(':','')}_${uniqueSuffix}`;

        addedCount++;
        return {
            internalId: internalId,
            stopID: (genEntry.stopId || "").toUpperCase(),
            stopName: genEntry.stopName || "",
            direction: genEntry.direction || "",
            lineName: (genEntry.lineName || "").toUpperCase(),
            destinationName: genEntry.destinationName || "",
            scheduledTime: scheduledTimeForWorking,
            OperatingProfile: genEntry.operatingProfile || "",
            DayOffset: String(genEntry.dayOffset || "0")
        };
    });

    currentWorkingSchedule.push(...newEntriesForWorkingSchedule);
    alert(`${addedCount} entries from the generator's table have been ${isOverwrite ? 'set as (overwritten)' : 'appended to'} the main working schedule.`);

    // Refresh UI and Firebase staging status
    renderUIDependentElements();
    updateStagingStatusDisplay();
}


function gen_handleGetWorkingSchedule() {
    if (!currentUser) { alert("Please log in."); return; }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        alert("The main working schedule is currently empty."); return;
    }
    if (!confirm(`Replace current generator table with all ${currentWorkingSchedule.length} entries from main working schedule? Any unsaved generator data will be lost.`)) {
        return;
    }

    // Map working schedule to generator's internal format (time as HHMM string)
    let tempSchedule = currentWorkingSchedule.map(entry => {
        let internalGenScheduledTime = entry.scheduledTime || "";
        if (internalGenScheduledTime.includes(':')) { // Convert HH:MM to HHMM
            internalGenScheduledTime = internalGenScheduledTime.replace(':', '');
        }
        internalGenScheduledTime = internalGenScheduledTime.padStart(4, '0'); // Ensure HHMM

        return {
            stopId: entry.stopID || "",
            stopName: entry.stopName || "",
            direction: entry.direction || "",
            lineName: entry.lineName || "",
            destinationName: entry.destinationName || "",
            scheduledTime: internalGenScheduledTime, // Store as HHMM
            operatingProfile: entry.OperatingProfile || "",
            dayOffset: String(entry.DayOffset || "0")
        };
    });

    // Sort for consistent display in generator table
    tempSchedule.sort((a, b) => {
        const lineCompare = compareLineNames(a.lineName, b.lineName); if (lineCompare !== 0) return lineCompare;
        const stopNameA = (a.stopName || "").toLowerCase(); const stopNameB = (b.stopName || "").toLowerCase();
        if (stopNameA < stopNameB) return -1; if (stopNameA > stopNameB) return 1;
        const timeA = a.scheduledTime || "9999"; const timeB = b.scheduledTime || "9999"; // HHMM strings
        if (timeA < timeB) return -1; if (timeA > timeB) return 1;
        const dayOffsetA = parseInt(a.dayOffset, 10); const dayOffsetB = parseInt(b.dayOffset, 10);
        if (dayOffsetA < dayOffsetB) return -1; if (dayOffsetA > dayOffsetB) return 1;
        return 0;
    });

    gen_currentScheduleEntries = tempSchedule;
    gen_renderScheduleTable();
    gen_saveDataToLocalStorage(); // Save this loaded state to local storage
    alert(`Loaded ${gen_currentScheduleEntries.length} entries into generator table.`);
}


function gen_handleLoadStopSchedule() {
    if (!currentUser) { alert("Please log in."); return; }
    const stopSelectEl = document.getElementById('gen_stopNameSelect');
    const selectedStopId = stopSelectEl ? stopSelectEl.value : null;

    if (!selectedStopId) { alert("Please select a stop from the 'Base Data' section first."); return; }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) { alert("Main working schedule is empty."); return; }
    if (!confirm(`Replace current generator table with the schedule for stop "${selectedStopId}"? Any unsaved generator data will be lost.`)) { return; }

    const entriesForSelectedStop = currentWorkingSchedule.filter(entry => entry.stopID === selectedStopId);

    if (entriesForSelectedStop.length === 0) {
        alert(`No schedule entries found for stop "${selectedStopId}". Generator table will be cleared.`);
        gen_currentScheduleEntries = []; // Clear table if no entries
    } else {
        let tempSchedule = entriesForSelectedStop.map(entry => {
            let internalGenScheduledTime = entry.scheduledTime || "";
            if (internalGenScheduledTime.includes(':')) internalGenScheduledTime = internalGenScheduledTime.replace(':', '');
            internalGenScheduledTime = internalGenScheduledTime.padStart(4, '0'); // Ensure HHMM
            return {
                stopId: entry.stopID || "", stopName: entry.stopName || "", direction: entry.direction || "",
                lineName: entry.lineName || "", destinationName: entry.destinationName || "",
                scheduledTime: internalGenScheduledTime, // Store as HHMM
                operatingProfile: entry.OperatingProfile || "",
                dayOffset: String(entry.DayOffset || "0")
            };
        });

        // Sort for consistent display
        tempSchedule.sort((a, b) => {
            const lineCompare = compareLineNames(a.lineName, b.lineName); if (lineCompare !== 0) return lineCompare;
            const timeA = a.scheduledTime || "9999"; const timeB = b.scheduledTime || "9999";
            if (timeA < timeB) return -1; if (timeA > timeB) return 1;
            const dayOffsetA = parseInt(a.dayOffset, 10); const dayOffsetB = parseInt(b.dayOffset, 10);
            if (dayOffsetA < dayOffsetB) return -1; if (dayOffsetA > dayOffsetB) return 1;
            return 0;
        });
        gen_currentScheduleEntries = tempSchedule;
    }

    gen_renderScheduleTable();
    gen_saveDataToLocalStorage(); // Save this loaded state
    if (entriesForSelectedStop.length > 0) alert(`Loaded ${gen_currentScheduleEntries.length} entries for stop "${selectedStopId}" into the generator table.`);
}


function gen_initializeScheduleGeneratorControls() {
    // Populate dropdowns first as other actions might depend on their state
    gen_populateStopNameSelect();
    gen_populateRouteSelect(); // This will also trigger destination population via its change handler
    
    // Attach event listeners for the select elements
    gen_attachEventListenersForGeneratorSelects();

    // Load any saved data from local storage (this will also populate fields and rules)
    gen_loadDataFromLocalStorage();

    // Attach listeners to base data input fields that trigger saving to localStorage
    const gen_baseDataInputsIds = [
        'gen_operatingProfile', 'gen_initialScheduledTime', 'gen_initialDayOffset'
        // stopId, stopName, direction, lineName, destinationName are handled by select/input change events
    ];
    gen_baseDataInputsIds.forEach(id => {
        const element = document.getElementById(id);
        if (element && (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'select')) {
            const eventType = element.tagName.toLowerCase() === 'select' ? 'change' : 'input';
            element.removeEventListener(eventType, gen_saveDataToLocalStorage); // Avoid duplicate listeners
            element.addEventListener(eventType, gen_saveDataToLocalStorage);
        }
    });

    // Attach listener to the interval rules container for dynamic input saving
    const gen_intervalContainer = document.getElementById('gen_intervalRulesContainer');
    if (gen_intervalContainer) {
        // Define the handler separately to ensure it can be removed if needed
        function gen_handleIntervalContainerInput(event) {
            const target = event.target;
            // Check if the event target is an input within a rule
            if (target.tagName.toLowerCase() === 'input' && target.closest('.gen_interval-rule')) {
                 gen_saveDataToLocalStorage();
            }
        }
        gen_intervalContainer.removeEventListener('input', gen_handleIntervalContainerInput); // Remove before adding
        gen_intervalContainer.addEventListener('input', gen_handleIntervalContainerInput);
    }

    // Ensure at least one rule exists if none were loaded from localStorage
    const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
    if (intervalRulesContainer && intervalRulesContainer.childElementCount === 0) {
        gen_addIntervalRule();
    }

    // Attach listeners to action buttons
    const btnGenerate = document.getElementById('gen_generateScheduleButton');
    if (btnGenerate) { btnGenerate.removeEventListener('click', gen_generateSchedule); btnGenerate.addEventListener('click', gen_generateSchedule); }

    const btnExport = document.getElementById('gen_exportToCountButton');
    if (btnExport) { btnExport.removeEventListener('click', gen_exportToCountFile); btnExport.addEventListener('click', gen_exportToCountFile); }

    const btnAddToWorking = document.getElementById('gen_addToWorkingScheduleButton');
    if (btnAddToWorking) { btnAddToWorking.removeEventListener('click', gen_handleAddGeneratedToWorkingSchedule); btnAddToWorking.addEventListener('click', gen_handleAddGeneratedToWorkingSchedule); }

    const btnGetWorkingSchedule = document.getElementById('gen_getWorkingScheduleButton');
    if (btnGetWorkingSchedule) { btnGetWorkingSchedule.removeEventListener('click', gen_handleGetWorkingSchedule); btnGetWorkingSchedule.addEventListener('click', gen_handleGetWorkingSchedule); }

    const btnLoadStopSchedule = document.getElementById('gen_loadStopScheduleButton');
    if (btnLoadStopSchedule) { btnLoadStopSchedule.removeEventListener('click', gen_handleLoadStopSchedule); btnLoadStopSchedule.addEventListener('click', gen_handleLoadStopSchedule); }

    const btnClear = document.getElementById('gen_clearAllDataButton');
    if (btnClear) { btnClear.removeEventListener('click', gen_clearAllData); btnClear.addEventListener('click', gen_clearAllData); }

    const btnAddRule = document.getElementById('gen_addIntervalRuleButton');
if (btnAddRule) {
    // MODIFIED: Use the stable gen_addIntervalRule_clickHandler function reference
    btnAddRule.removeEventListener('click', gen_addIntervalRule_clickHandler);
    btnAddRule.addEventListener('click', gen_addIntervalRule_clickHandler);
}


    if (!gen_isInitialized) {
      gen_isInitialized = true;
      console.log("Schedule Generator Controls Initialized (First Time).");
    } else {
      console.log("Schedule Generator Controls Re-initialized/Refreshed.");
    }
}
// --- END: Schedule Generator ---

// --- START: Schedule Copier (within Schedule Generator) Tool Specific Functions ---
function gen_addIntervalRule_clickHandler() {
    gen_addIntervalRule(null); // Add a fresh, empty rule
}

function populateCopierStopSelectors() {
    const uniqueStops = getUniqueStopsFromSchedule(); // Assumes this helper exists and works

    if (sgCopierSourceStopSelect) {
        const currentSourceVal = sgCopierSourceStopSelect.value;
        sgCopierSourceStopSelect.innerHTML = '<option value="">-- Select Source Stop --</option>';
        uniqueStops.forEach(stop => {
            const opt = document.createElement('option');
            opt.value = stop.stopID;
            opt.textContent = `${stop.stopName} (${stop.stopID})`;
            sgCopierSourceStopSelect.appendChild(opt);
        });
        // Reselect if still valid
        if (uniqueStops.find(s => s.stopID === currentSourceVal)) {
            sgCopierSourceStopSelect.value = currentSourceVal;
        }
        sgCopierSourceStopSelect.dispatchEvent(new Event('change')); // Trigger route display update
    }

    if (sgCopierTargetStopSelect) {
        const currentTargetVal = sgCopierTargetStopSelect.value;
        sgCopierTargetStopSelect.innerHTML = '<option value="">-- Select Target Stop --</option>';
        uniqueStops.forEach(stop => {
            const opt = document.createElement('option');
            opt.value = stop.stopID;
            opt.textContent = `${stop.stopName} (${stop.stopID})`;
            sgCopierTargetStopSelect.appendChild(opt);
        });
        // Reselect if still valid
        if (uniqueStops.find(s => s.stopID === currentTargetVal)) {
            sgCopierTargetStopSelect.value = currentTargetVal;
        }
    }
}

function displayRoutesForCopierSourceStop() {
    if (!sgCopierSourceStopSelect || !sgCopierSourceRoutesContainer || !sgCopierSourceRoutesPlaceholder) return;
    const selectedStopID = sgCopierSourceStopSelect.value;
    sgCopierSourceRoutesContainer.innerHTML = ''; // Clear previous tiles

    if (!selectedStopID) {
        sgCopierSourceRoutesPlaceholder.textContent = 'Select a source stop to see routes.';
        sgCopierSourceRoutesPlaceholder.style.display = 'block';
        return;
    }

    const servingRoutes = new Set();
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID === selectedStopID && entry.lineName) {
            servingRoutes.add(entry.lineName);
        }
    });

    const sortedRoutes = Array.from(servingRoutes).sort(compareLineNames); // Use existing sorter

    if (sortedRoutes.length === 0) {
        sgCopierSourceRoutesPlaceholder.textContent = `No routes found serving stop ${selectedStopID}.`;
        sgCopierSourceRoutesPlaceholder.style.display = 'block';
    } else {
        sgCopierSourceRoutesPlaceholder.style.display = 'none';
        sortedRoutes.forEach(lineName => {
            const tile = document.createElement('span');
            tile.classList.add('route-tile-tools-list', 'copier-route-tile');
            tile.textContent = lineName;
            tile.dataset.lineName = lineName; // Store lineName for later retrieval
            const bgColor = getRouteTileColourForTools(lineName, selectedStopID); // Use existing color logic
            tile.style.backgroundColor = bgColor;
            tile.style.color = getTextColourForBackgroundTools(bgColor); // Use existing text color logic
            tile.style.cursor = 'pointer'; // Indicate clickable
            tile.setAttribute('role', 'checkbox'); // Accessibility
            tile.setAttribute('aria-checked', 'false');
            tile.setAttribute('tabindex', '0'); // Make focusable

            tile.addEventListener('click', () => {
                const isSelected = tile.classList.toggle('selected-tile'); // Toggle selection class
                tile.setAttribute('aria-checked', isSelected.toString());
            });
            tile.addEventListener('keydown', (event) => { // Keyboard accessibility
                if (event.key === ' ' || event.key === 'Enter') {
                    event.preventDefault();
                    tile.click(); // Trigger click on space/enter
                }
            });
            sgCopierSourceRoutesContainer.appendChild(tile);
        });
    }
}

function handleCopySchedules() {
    if (!sgCopierSourceStopSelect || !sgCopierStatusMessage) return;
    const sourceStopID = sgCopierSourceStopSelect.value;
    if (!sourceStopID) {
        sgCopierStatusMessage.textContent = 'Please select a source stop first.';
        sgCopierStatusMessage.style.color = '#f1c40f';
        return;
    }

    const selectedRouteTiles = document.querySelectorAll('#sgCopierSourceRoutesContainer .copier-route-tile.selected-tile');
    if (selectedRouteTiles.length === 0) {
        sgCopierStatusMessage.textContent = 'Please select at least one route to copy.';
        sgCopierStatusMessage.style.color = '#f1c40f';
        return;
    }

    const selectedRoutes = Array.from(selectedRouteTiles).map(tile => tile.dataset.lineName);
    copiedScheduleEntries = []; // Clear previously copied entries

    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID === sourceStopID && selectedRoutes.includes(entry.lineName)) {
            copiedScheduleEntries.push(JSON.parse(JSON.stringify(entry))); // Deep copy the entry
        }
    });

    if (copiedScheduleEntries.length > 0) {
        sgCopierStatusMessage.textContent = `${copiedScheduleEntries.length} schedule entries for routes [${selectedRoutes.join(', ')}] from stop ${sourceStopID} copied. Ready to paste.`;
        sgCopierStatusMessage.style.color = '#2ecc71';
    } else {
        sgCopierStatusMessage.textContent = `No schedule entries found for the selected routes at stop ${sourceStopID}.`;
        sgCopierStatusMessage.style.color = '#f1c40f';
    }
}

// Adjusts HH:MM time string by a given number of minutes
function adjustScheduledTime(timeStr, adjustmentMinutes) {
    if (!timeStr || !timeStr.match(/^\d{2}:\d{2}$/)) {
        console.warn(`Invalid time format for adjustment: ${timeStr}. Returning as is.`);
        return { newTime: timeStr, dayOffsetChange: 0 }; // Return original if format is wrong
    }

    const [hours, minutes] = timeStr.split(':').map(Number);
    let totalMinutes = (hours * 60) + minutes + adjustmentMinutes;

    const oneDayInMinutes = 24 * 60;
    let dayOffsetChange = 0;

    if (totalMinutes < 0) {
        dayOffsetChange = Math.floor(totalMinutes / oneDayInMinutes); // Will be negative
        totalMinutes = totalMinutes % oneDayInMinutes;
        if (totalMinutes < 0) totalMinutes += oneDayInMinutes; // Ensure positive remainder
    } else if (totalMinutes >= oneDayInMinutes) {
        dayOffsetChange = Math.floor(totalMinutes / oneDayInMinutes); // Will be positive
        totalMinutes = totalMinutes % oneDayInMinutes;
    }

    const newHours = Math.floor(totalMinutes / 60);
    const newMinutes = totalMinutes % 60;

    return {
        newTime: `${String(newHours).padStart(2, '0')}:${String(newMinutes).padStart(2, '0')}`,
        dayOffsetChange: dayOffsetChange
    };
}

function handlePasteSchedules() {
    if (!currentUser) {
        sgCopierStatusMessage.textContent = 'Please log in.'; sgCopierStatusMessage.style.color = '#e74c3c'; return;
    }
    if (copiedScheduleEntries.length === 0) {
        sgCopierStatusMessage.textContent = 'No schedules copied. Use "Copy Selected Schedules" first.'; sgCopierStatusMessage.style.color = '#f1c40f'; return;
    }
    const targetStopID = sgCopierTargetStopSelect.value;
    if (!targetStopID) {
        sgCopierStatusMessage.textContent = 'Please select a target stop.'; sgCopierStatusMessage.style.color = '#f1c40f'; return;
    }

    const timeAdjustmentStr = sgCopierTimeAdjustmentInput.value.trim();
    const timeAdjustmentMinutes = parseInt(timeAdjustmentStr, 10);
    if (isNaN(timeAdjustmentMinutes)) {
        sgCopierStatusMessage.textContent = 'Invalid time adjustment. Enter a number (e.g., +5, -10, 0).'; sgCopierStatusMessage.style.color = '#e74c3c'; return;
    }

    const targetStopDetails = getUniqueStopsFromSchedule().find(s => s.stopID === targetStopID);
    if (!targetStopDetails) {
        sgCopierStatusMessage.textContent = `Details for target stop ID: ${targetStopID} not found. Cannot paste.`; sgCopierStatusMessage.style.color = '#e74c3c'; return;
    }

    const newEntriesForWorkingSchedule = [];
    copiedScheduleEntries.forEach((copiedEntry, index) => {
        const newEntry = JSON.parse(JSON.stringify(copiedEntry)); // Deep copy

        // Update stop details to target stop
        newEntry.stopID = targetStopDetails.stopID;
        newEntry.stopName = targetStopDetails.stopName;
        newEntry.direction = targetStopDetails.direction;

        // Adjust time and day offset
        const { newTime, dayOffsetChange } = adjustScheduledTime(newEntry.scheduledTime, timeAdjustmentMinutes);
        newEntry.scheduledTime = newTime;
        let originalDayOffset = parseInt(newEntry.DayOffset || "0", 10);
        newEntry.DayOffset = String(originalDayOffset + dayOffsetChange);

        // Prevent negative DayOffset if adjustment results in it
        if (parseInt(newEntry.DayOffset, 10) < 0) {
            console.warn(`Adjusted DayOffset for ${newEntry.lineName} at ${newEntry.scheduledTime} became negative. Clamping to 0.`);
            newEntry.DayOffset = "0";
        }

        // Create a new unique internalId
        const uniqueSuffix = `_copied_sg_${Date.now()}_${index}`;
        newEntry.internalId = `${targetStopDetails.stopID.toUpperCase()}_${newEntry.lineName.toUpperCase()}_${newEntry.scheduledTime.replace(':', '')}${uniqueSuffix}`;

        newEntriesForWorkingSchedule.push(newEntry);
    });

    if (newEntriesForWorkingSchedule.length > 0) {
        if (confirm(`This will add ${newEntriesForWorkingSchedule.length} new schedule entries to Stop "${targetStopDetails.stopName} (${targetStopDetails.stopID})" with a ${timeAdjustmentMinutes} minute time adjustment to the MAIN WORKING SCHEDULE. Proceed?`)) {
            currentWorkingSchedule.push(...newEntriesForWorkingSchedule); // Add to the main schedule
            sgCopierStatusMessage.textContent = `${newEntriesForWorkingSchedule.length} entries pasted to stop ${targetStopDetails.stopID}. Added to main working schedule.`;
            sgCopierStatusMessage.style.color = '#2ecc71';
            copiedScheduleEntries = []; // Clear clipboard after pasting
            renderUIDependentElements(); // Refresh UI lists
            updateStagingStatusDisplay(); // Update Firebase staging status
        } else {
            sgCopierStatusMessage.textContent = 'Paste operation cancelled by user.'; sgCopierStatusMessage.style.color = '#f1c40f';
        }
    } else {
        sgCopierStatusMessage.textContent = 'No valid entries were processed for pasting.'; sgCopierStatusMessage.style.color = '#e74c3c';
    }
}


function initializeScheduleGeneratorCopierControls() {
    if (!sgCopierSourceStopSelect || !sgCopierCopySchedulesButton || !sgCopierPasteSchedulesButton) {
        console.warn("Schedule Copier (SG) DOM elements not found. Cannot initialize."); return;
    }
    populateCopierStopSelectors(); // Populate stop selectors on init

    sgCopierSourceStopSelect.removeEventListener('change', displayRoutesForCopierSourceStop); // Avoid duplicates
    sgCopierSourceStopSelect.addEventListener('change', displayRoutesForCopierSourceStop);

    sgCopierCopySchedulesButton.removeEventListener('click', handleCopySchedules);
    sgCopierCopySchedulesButton.addEventListener('click', handleCopySchedules);

    sgCopierPasteSchedulesButton.removeEventListener('click', handlePasteSchedules);
    sgCopierPasteSchedulesButton.addEventListener('click', handlePasteSchedules);

    console.log("Schedule Generator's Copier Controls Initialized/Refreshed.");
}
// --- END: Schedule Copier (within Schedule Generator) Tool Specific Functions ---


// --- UI Navigation & State ---
function showSection(sectionId) {
    allToolContentSections.forEach(section => {
        section.style.display = 'none';
    });
    const sectionToShow = document.getElementById(sectionId);
    if (sectionToShow) {
        sectionToShow.style.display = 'block';
        const isMainButtonSection = Array.from(mainMenuButtons).some(btn => btn.getAttribute('data-section') === sectionId);
        if (isMainButtonSection) localStorage.setItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY, sectionId);

        // Call specific population/initialization functions based on the section shown
        if (sectionId === 'bulk-edit-tools-section') {
            populateRouteSelectorForColours(); renderGlobalCustomRouteColours();
            populateStopSelectorForSpecificColours(); renderStopSpecificRouteColours();
            if (selectStopForSpecificRouteColour?.value) displayRoutesForSpecificColouring();
        } else if (sectionId === 'view-departures-section') {
            populateStopSelectorForDeparturesView();
            if(selectStopForDeparturesView?.value) displayDeparturesForSelectedStop();
        } else if (sectionId === 'schedule-generator-section') {
            gen_initializeScheduleGeneratorControls(); // For main generator part
            initializeScheduleGeneratorCopierControls(); // For copier sub-tool
        } else if (sectionId === 'analytics-validation-section') {
            populateConsolidateStopSelect();
        } else if (sectionId === 'route-timetable-overwrite-section') {
            populate_rto_SelectRoute();
        } else if (sectionId === 'operating-profiles-section') {
            displayUniqueOperatingProfiles();
        } else if (sectionId === 'route-stops-explorer-section') {
            populate_rse_SelectRoute();
            if(rse_selectRoute?.value) {
                displayRouteStopsExplorer();
            } else { // Reset placeholders if no route selected
                if(rse_direction1_title) rse_direction1_title.textContent = "Direction 1: (Select Route)";
                if(rse_direction1_stopsList) rse_direction1_stopsList.innerHTML = "";
                if(rse_direction1_placeholder) rse_direction1_placeholder.style.display = 'block';
                if(rse_direction2_title) rse_direction2_title.textContent = "Direction 2: (Select Route)";
                if(rse_direction2_stopsList) rse_direction2_stopsList.innerHTML = "";
                if(rse_direction2_placeholder) rse_direction2_placeholder.style.display = 'block';
                if(rse_statusMessage) rse_statusMessage.textContent = "";
            }
        }
        // ADDED/MODIFIED: Timetable Generator section handling
        else if (sectionId === 'timetable-generator-section') {
            populate_tg_selectRoute(); // Populate routes when section is shown
            // If a route is already selected (e.g. from previous state or re-render), populate directions
            if (tg_selectRoute?.value) {
                populate_tg_selectDirection(); // This will also trigger timetable display if direction is set
            }
            // If both route and direction are selected, ensure timetable is displayed
            if (tg_selectRoute?.value && tg_selectDirection?.value) {
                display_tg_Timetable();
            }
        }

    } else console.warn(`Attempted to show non-existent section: ${sectionId}`);
}


function hideAllToolSections() { allToolContentSections.forEach(s => s.style.display = 'none'); }

function updateAuthUI(user) {
    currentUser = user;
    hideAllToolSections(); // Hide all tools before deciding which to show
    if (user) {
        if (adminLoginSection) adminLoginSection.style.display = 'none';
        if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'block';
        if (topMenuBar) topMenuBar.style.display = 'block';
        if (logoutContainer) logoutContainer.style.display = 'block';
        if (loginFormContainer) loginFormContainer.style.display = 'none';
        if (authStatus) authStatus.textContent = '';
        if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = user.email;

        loadInitialData(); // Load data needed for tools
        initializeAutoApplyScheduler(); // Start auto-apply checker

        // Restore last active section or default to first
        const lastActiveSection = localStorage.getItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        let sectionShown = false;
        if (lastActiveSection) {
            const sectionEl = document.getElementById(lastActiveSection);
            // Ensure it's a known main menu section before showing
            const isKnownMenu = Array.from(mainMenuButtons).some(b=>b.dataset.section === lastActiveSection);
            if (sectionEl && isKnownMenu) {
                showSection(lastActiveSection); // This will also trigger its specific initializers
                sectionShown = true;
            } else {
                localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY); // Clean up invalid stored key
            }
        }
        // If no section was restored (or none was stored/valid), show the first one by default
        if (!sectionShown && mainMenuButtons.length > 0 && mainMenuButtons[0].dataset.section) {
            showSection(mainMenuButtons[0].dataset.section);
        }

    } else { // User is logged out
        if (adminLoginSection) adminLoginSection.style.display = 'block';
        if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'none';
        if (topMenuBar) topMenuBar.style.display = 'none';
        if (logoutContainer) logoutContainer.style.display = 'none';
        if (loginFormContainer) loginFormContainer.style.display = 'block';
        if (authStatus) authStatus.textContent = 'Please log in to use the tools.';
        if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = '';

        localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY); // Clear active section on logout
        stopAutoApplyScheduler(); // Stop auto-apply

        // Clear data that should not persist when logged out
        currentWorkingSchedule = []; closedStopIDs = []; globalCustomRouteColours = {}; stopSpecificRouteColours = {};
        renderUIDependentElements(); // Re-render UI which will show empty states for lists/selects
    }
}


// --- Analytics Functions ---
function detectDuplicateEntries() {
    if (!currentUser || currentWorkingSchedule.length === 0) {
        if (duplicateEntriesResults) duplicateEntriesResults.innerHTML = '<p>No schedule data or not logged in.</p>'; return;
    }
    const signatures = new Map(); const duplicates = [];
    currentWorkingSchedule.forEach((entry, index) => {
        // Normalize profile string for consistent signature
        const profileString = (entry.OperatingProfile || "").toLowerCase().split(',').map(s => s.trim()).sort().join(',');
        const signature = [
            (entry.stopID || "").toUpperCase(),
            (entry.lineName || "").toUpperCase(),
            entry.scheduledTime || "00:00", // Standardize missing time?
            profileString,
            entry.DayOffset || "0",
            (entry.destinationName || "").trim() // Trim destination
        ].join('|');

        if (signatures.has(signature)) {
            signatures.get(signature).push(index); // Add original index
        } else {
            signatures.set(signature, [index]); // Store as array with original index
        }
    });

    signatures.forEach((indices, sig) => {
        if (indices.length > 1) { // If more than one entry has this signature
            duplicates.push(indices.map(originalIndex => ({...currentWorkingSchedule[originalIndex], originalIndex})));
        }
    });

    if (duplicateEntriesResults) {
        if (duplicates.length === 0) {
            duplicateEntriesResults.innerHTML = '<p>No duplicate entries found.</p>';
        } else {
            let html = `<p>Found ${duplicates.length} set(s) of duplicates:</p><ul>`;
            duplicates.forEach((set, i) => {
                html += `<li class="duplicate-set"><strong>Set ${i + 1}:</strong> (Appears ${set.length} times)`;
                set.forEach(e => {
                    html += `<span class="entry-detail"> - Stop: ${e.stopID}, Line: ${e.lineName}, Time: ${e.scheduledTime}, Profile: ${e.OperatingProfile}, Dest: ${e.destinationName} (Original Index: ${e.originalIndex})</span>`;
                });
                html += `</li>`;
            });
            duplicateEntriesResults.innerHTML = html + `</ul>`;
        }
    }
}

function handleRemoveDuplicateEntries() {
    if (!currentUser) { alert("Please log in."); if(removeDuplicatesStatusMessage) removeDuplicatesStatusMessage.textContent = "Not logged in."; return; }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) { alert("Working schedule empty."); if(removeDuplicatesStatusMessage) removeDuplicatesStatusMessage.textContent = "Working schedule empty."; return; }

    const initialCount = currentWorkingSchedule.length;
    const signaturesEncountered = new Set();
    const deduplicatedSchedule = [];

    currentWorkingSchedule.forEach(entry => {
        const profileString = (entry.OperatingProfile || "").toLowerCase().split(',').map(s=>s.trim()).sort().join(',');
        const signature = [(entry.stopID||"").toUpperCase(), (entry.lineName||"").toUpperCase(), entry.scheduledTime||"00:00", profileString, entry.DayOffset||"0", (entry.destinationName||"").trim()].join('|');
        if (!signaturesEncountered.has(signature)) {
            signaturesEncountered.add(signature);
            deduplicatedSchedule.push(entry); // Keep first occurrence
        }
    });

    const removedCount = initialCount - deduplicatedSchedule.length;
    if (removedCount === 0) {
        alert("No duplicates found based on StopID, LineName, Time, Profile, DayOffset, and Destination.");
        if(removeDuplicatesStatusMessage){ removeDuplicatesStatusMessage.textContent = "No duplicates found."; removeDuplicatesStatusMessage.style.color = ""; }
        return;
    }

    if (confirm(`Found ${removedCount} duplicate schedule entries. Are you sure you want to remove them (keeping the first occurrence of each)?`)) {
        currentWorkingSchedule = deduplicatedSchedule;
        if(removeDuplicatesStatusMessage){ removeDuplicatesStatusMessage.textContent = `${removedCount} duplicates removed.`; removeDuplicatesStatusMessage.style.color = '#2ecc71'; }
        alert(`${removedCount} duplicates removed.`);
        renderUIDependentElements(); // Refresh UI elements
        detectDuplicateEntries(); // Re-run detection to confirm
        updateStagingStatusDisplay(); // Update Firebase staging status
    } else {
        if(removeDuplicatesStatusMessage){ removeDuplicatesStatusMessage.textContent = "Duplicate removal cancelled by user."; removeDuplicatesStatusMessage.style.color = '#f1c40f'; }
    }
}


// --- START: Consolidate Operating Days Functions ---
function populateConsolidateStopSelect() {
    if (!consolidateStopSelect) return;
    const currentVal = consolidateStopSelect.value;
    consolidateStopSelect.innerHTML = '<option value="">-- Select Stop --</option>';
    const uniqueStops = getUniqueStopsFromSchedule(); // Assumes this helper is defined
    if (uniqueStops.length === 0) {
        consolidateStopSelect.innerHTML = '<option value="">-- No Stops in Schedule --</option>';
        populateConsolidateRouteSelect(); // This will show "Select Stop First"
        return;
    }
    uniqueStops.forEach(stop => {
        const opt=document.createElement('option');
        opt.value=stop.stopID;
        opt.textContent=`${stop.stopName} (${stop.stopID})`;
        consolidateStopSelect.appendChild(opt);
    });
    if (uniqueStops.find(s => s.stopID === currentVal)) {
        consolidateStopSelect.value = currentVal;
    }
    populateConsolidateRouteSelect(); // Populate routes based on current/new stop selection
}

function populateConsolidateRouteSelect() {
    if (!consolidateRouteSelect || !consolidateStopSelect) return;
    const selectedStopId = consolidateStopSelect.value;
    const currentRouteVal = consolidateRouteSelect.value;
    consolidateRouteSelect.innerHTML = '<option value="">-- Select Route --</option>';

    if (!selectedStopId) {
        consolidateRouteSelect.innerHTML = '<option value="">-- Select Stop First --</option>';
        return;
    }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) return; // No schedule to get routes from

    const routesForStop = [...new Set(
        currentWorkingSchedule
            .filter(e => e.stopID === selectedStopId && e.lineName)
            .map(e => e.lineName)
    )].sort(compareLineNames); // Assuming compareLineNames exists

    if (routesForStop.length === 0) {
        consolidateRouteSelect.innerHTML = `<option value="">-- No Routes for Stop ${selectedStopId} --</option>`;
    } else {
        routesForStop.forEach(ln => {
            const opt=document.createElement('option');
            opt.value=ln; opt.textContent=ln;
            consolidateRouteSelect.appendChild(opt);
        });
        if (routesForStop.includes(currentRouteVal)) {
            consolidateRouteSelect.value = currentRouteVal;
        }
    }
}

function handleConsolidateOperatingDays() {
    if (!currentUser) { alert("Please log in."); consolidateOpDaysStatusMessage.textContent = "Not logged in."; return; }
    const stopId = consolidateStopSelect.value;
    const lineName = consolidateRouteSelect.value;
    const newProfile = consolidateNewProfileInput.value.trim();

    if (!stopId) { consolidateOpDaysStatusMessage.textContent = "Please select a Stop ID."; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return; }
    if (!lineName) { consolidateOpDaysStatusMessage.textContent = "Please select a Route."; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return; }
    if (!newProfile) { consolidateOpDaysStatusMessage.textContent = "Please enter the new combined Operating Profile."; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return; }

    const relevantEntriesForStopRoute = currentWorkingSchedule.filter(e => e.stopID === stopId && e.lineName === lineName);
    if (relevantEntriesForStopRoute.length === 0) {
        consolidateOpDaysStatusMessage.textContent = `No entries found for Stop ${stopId}, Line ${lineName}.`; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return;
    }

    const groups = new Map(); // Group entries by time, destination, dayOffset
    relevantEntriesForStopRoute.forEach(e => {
        const key = `${e.scheduledTime}|${e.destinationName||""}|${e.DayOffset||"0"}`;
        if(!groups.has(key)) groups.set(key, []);
        groups.get(key).push(e);
    });

    let consolidatedGroupCount = 0;
    let entriesToRemoveInternalIds = new Set();
    let modifiedEntriesForThisContext = []; // Holds the (potentially modified) first entry of each group

    groups.forEach((group, key) => {
        if (group.length > 1) { // Only process groups that have multiple entries (i.e., candidates for consolidation)
            consolidatedGroupCount++;
            const firstEntry = {...group[0]}; // Take a copy of the first entry
            firstEntry.OperatingProfile = newProfile; // Update its profile
            modifiedEntriesForThisContext.push(firstEntry); // This is the one we keep/update

            // Mark the rest for removal
            for (let i = 1; i < group.length; i++) {
                if (group[i].internalId) { // Ensure internalId exists before adding
                    entriesToRemoveInternalIds.add(group[i].internalId);
                } else {
                    console.warn("Entry missing internalId, cannot mark for removal:", group[i]);
                }
            }
        } else {
            // If group has only one entry, it's not consolidated but should still be part of the result for this stop/route
            modifiedEntriesForThisContext.push(group[0]);
        }
    });

    const otherEntries = currentWorkingSchedule.filter(e => e.stopID !== stopId || e.lineName !== lineName); // Entries not part of this stop/route combination

    if (consolidatedGroupCount === 0) {
        consolidateOpDaysStatusMessage.textContent = "No entries found that could be consolidated for the selected criteria (i.e., no multiple entries with same time/dest/dayOffset).";
        consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return;
    }

    const actualRemovedCount = entriesToRemoveInternalIds.size;
    if (!confirm(`Found ${consolidatedGroupCount} group(s) of entries for Stop ${stopId}, Route ${lineName} that can be consolidated.\nThis will update one entry per group to Operating Profile "${newProfile}" and remove ${actualRemovedCount} other redundant entries.\nProceed?`)) {
        consolidateOpDaysStatusMessage.textContent = "Consolidation cancelled by user."; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return;
    }

    // Rebuild currentWorkingSchedule:
    // Start with entries not involved in this operation.
    // Then add the modified/kept entries from the consolidation context.
    // The filter on modifiedEntriesForThisContext isn't strictly needed if logic is correct, but good for safety.
    currentWorkingSchedule = [
        ...otherEntries,
        ...modifiedEntriesForThisContext.filter(mEntry => !entriesToRemoveInternalIds.has(mEntry.internalId))
    ];


    consolidateOpDaysStatusMessage.textContent = `Consolidated ${consolidatedGroupCount} group(s) for Stop ${stopId}, Route ${lineName}. ${actualRemovedCount} entries removed. Operating Profile set to "${newProfile}".`;
    consolidateOpDaysStatusMessage.style.color = '#2ecc71';
    alert(`Operating days consolidated. ${actualRemovedCount} entries removed.`);

    renderUIDependentElements();
    detectDuplicateEntries(); // Check for new duplicates if any
    updateStagingStatusDisplay();
}
// --- END: Consolidate Operating Days Functions ---

// --- Utility Functions (Date, Sorting, Parsing etc.) ---
function parseLineName(lineNameStr) { const name = String(lineNameStr || "").toUpperCase().trim(); const numericPrefixRegex = new RegExp(/^(\d+)([A-Z]*)$/); const alphaNumericRegex = new RegExp(/^([A-Z]+)(\d+)?([A-Z]*)$/); const numericPrefixMatch = name.match(numericPrefixRegex); if (numericPrefixMatch) return { type: 'numeric', number: parseInt(numericPrefixMatch[1], 10), suffix: numericPrefixMatch[2] || '', original: name }; const alphaNumericMatch = name.match(alphaNumericRegex); if (alphaNumericMatch) return { type: 'alpha', prefix: alphaNumericMatch[1], number: alphaNumericMatch[2] ? parseInt(alphaNumericMatch[2], 10) : null, suffix: alphaNumericMatch[3] || '', original: name }; return { type: 'other', original: name }; }
function compareLineNames(lineAStr, lineBStr) { const parsedA = parseLineName(lineAStr); const parsedB = parseLineName(lineBStr); if (parsedA.type === 'numeric' && parsedB.type === 'alpha') return -1; if (parsedA.type === 'alpha' && parsedB.type === 'numeric') return 1; if (parsedA.type === 'numeric' && parsedB.type === 'numeric') { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type === 'alpha' && parsedB.type === 'alpha') { const prefixCompare = parsedA.prefix.localeCompare(parsedB.prefix); if (prefixCompare !== 0) return prefixCompare; if (parsedA.number === null && parsedB.number !== null) return -1; if (parsedA.number !== null && parsedB.number === null) return 1; if (parsedA.number !== null && parsedB.number !== null) { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; } return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type !== 'other' && parsedB.type === 'other') return -1; if (parsedA.type === 'other' && parsedB.type !== 'other') return 1; return (parsedA.original || "").localeCompare(parsedB.original || ""); }

function generateUniqueStopId(format) {
    const existingStopIDs = new Set(currentWorkingSchedule.map(entry => entry.stopID.toUpperCase()));
    let nextId = ""; let currentNum = 0; let attempts = 0; const maxAttempts = 100000; // Prevent infinite loop
    if (format === "NUM") { // Purely numeric, starting from 101 or max existing + 1
        let maxNumeric = 100; // Smallest allowed is 101 effectively
        existingStopIDs.forEach(id => {
            if (/^\d+$/.test(id)) { // Check if it's a number
                const num = parseInt(id, 10);
                if (num >= 101 && num > maxNumeric) maxNumeric = num;
            }
        });
        currentNum = maxNumeric + 1;
        while (attempts < maxAttempts) {
            nextId = String(currentNum);
            if (!existingStopIDs.has(nextId)) return nextId;
            currentNum++; attempts++;
            if (currentNum > 99999) break; // Safety break if we exceed a reasonable number
        }
    } else if (["BP", "LE", "RO"].includes(format)) { // Prefixed IDs
        const prefix = format;
        let maxPrefixNum = 0;
        existingStopIDs.forEach(id => {
            if (id.startsWith(prefix)) {
                const numPart = id.substring(prefix.length);
                if (/^\d+$/.test(numPart)) { // Ensure the part after prefix is numeric
                    const num = parseInt(numPart, 10);
                    if (num > maxPrefixNum) maxPrefixNum = num;
                }
            }
        });
        currentNum = maxPrefixNum + 1;
        while (attempts < maxAttempts) {
            nextId = prefix + currentNum;
            if (!existingStopIDs.has(nextId.toUpperCase())) return nextId; // Check against uppercase
            currentNum++; attempts++;
            if (currentNum > 99999) break; // Safety break
        }
    }
    // Fallback if no unique ID found after many attempts or invalid format
    console.warn("Could not generate unique Stop ID for format:", format, "- falling back to timestamped ID.");
    return (format || "ID") + String(Date.now()).slice(-5) + String(Math.floor(Math.random()*90)+10);
}


// In omsi_tools.html

function getOperatingCodesForToday_Tools() {
    const n = new Date(); 
    const dOW = n.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat
    const todayDateString = `${n.getFullYear()}-${String(n.getMonth() + 1).padStart(2, '0')}-${String(n.getDate()).padStart(2, '0')}`;

    let potentialDateCodes = new Set(); // Changed variable name for clarity
    let isBankHolidayToday = false;

    // Check for Bank Holiday first
    // Ensure ukBankHolidaysData is populated in omsi_tools.html (likely via fetchBankHolidaysForSetup)
    if (typeof ukBankHolidaysData !== 'undefined' && ukBankHolidaysData.dates && ukBankHolidaysData.dates.includes(todayDateString)) {
        const holidayTitle = ukBankHolidaysData.titles[todayDateString] || "";
        isBankHolidayToday = true;
        if (holidayTitle.toLowerCase().includes("good friday")) {
            potentialDateCodes.add("Sa");
        } else {
            potentialDateCodes.add("Su");
        }
    }

    // If not a Bank Holiday, determine normal day codes
    if (!isBankHolidayToday) {
        // Ensure isSchoolHolidayPeriodForSetup and schoolHolidayDateRanges are defined in omsi_tools.html
        const isSchHol = (typeof isSchoolHolidayPeriodForSetup === 'function' && typeof schoolHolidayDateRanges !== 'undefined') ? isSchoolHolidayPeriodForSetup(n) : false;
        const schoolSuffix = isSchHol ? "NSD" : "Sch";
        let dayCode = "";
        switch (dOW) {
            case 0: dayCode = "Su"; break;
            case 1: dayCode = "Mo"; break;
            case 2: dayCode = "Tu"; break;
            case 3: dayCode = "We"; break;
            case 4: dayCode = "Th"; break;
            case 5: dayCode = "Fr"; break;
            case 6: dayCode = "Sa"; break;
        }
        potentialDateCodes.add(dayCode);

        if (dOW >= 1 && dOW <= 5) { // Monday to Friday
            potentialDateCodes.add(dayCode + schoolSuffix);
            potentialDateCodes.add("MF" + schoolSuffix);
            potentialDateCodes.add("MF");
        }
        // Removed explicit additions of "SchoolHoliday", "SaNSD", "SuNSD" as per your preference
    } else { // It IS a Bank Holiday
        // const isSchHolOnBH = isSchoolHolidayPeriodForSetup(n);
        // if (isSchHolOnBH) {
        //     // potentialDateCodes.add("SchoolHoliday"); // Removed
        //     // if(potentialDateCodes.has("Sa")) potentialDateCodes.add("SaNSD"); // Removed
        //     // if(potentialDateCodes.has("Su") && !potentialDateCodes.has("Sa")) potentialDateCodes.add("SuNSD"); // Removed
        // }
    }

        const finalFilteredCodes = Array.from(potentialDateCodes).filter(code => 
        typeof VALID_OPERATING_PROFILE_CODES_FOR_TOOLS !== 'undefined' && VALID_OPERATING_PROFILE_CODES_FOR_TOOLS.includes(code)
    );
    
    return finalFilteredCodes;
}

async function fetchBankHolidaysForSetup() {
    try {
        const response = await fetch('https://www.gov.uk/bank-holidays.json');
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        // Process for 'england-and-wales'
        if (data['england-and-wales'] && data['england-and-wales'].events) {
            const events = data['england-and-wales'].events;
            ukBankHolidaysData = {
                dates: events.map(event => event.date), // Array of YYYY-MM-DD strings
                titles: events.reduce((acc, event) => { acc[event.date] = event.title; return acc; }, {}) // Map of date string to holiday title
            };
        } else {
            console.warn("Setup: Bank holiday data format issue or 'england-and-wales' not found.");
            ukBankHolidaysData = { dates: [], titles: {} }; // Default to empty if structure is not as expected
        }
    } catch (error) {
        console.error("Setup: Failed to fetch UK bank holidays:", error);
        ukBankHolidaysData = { dates: [], titles: {} }; // Default to empty on error
        if(currentProfileDisplayElement) currentProfileDisplayElement.textContent = "Today's Operating Profile: (Bank Hol. check failed)";
    }
    updateCurrentProfileDisplayOnSetup(); // Update display after fetching (or failing)
}

function isSchoolHolidayPeriodForSetup(dateObject) {
    if (!schoolHolidayDateRanges || schoolHolidayDateRanges.length === 0) return false;
    const checkTime = dateObject.getTime(); // Time of the date to check
    for (const range of schoolHolidayDateRanges) {
        try {
            const startTime = new Date(range.start + "T00:00:00").getTime(); // Start of the holiday day
            const endTime = new Date(range.end + "T23:59:59").getTime();   // End of the holiday day
            if (checkTime >= startTime && checkTime <= endTime) {
                return true; // Date is within a holiday range
            }
        } catch (e) {
            console.error("Invalid date in schoolHolidayDateRanges (setup):", range, e);
            // Skip this range if dates are invalid
        }
    }
    return false; // Not in any holiday range
}

// Inside omsi_tools.html

function updateCurrentProfileDisplayOnSetup() {
    const now = new Date();
    const dayOfWeek = now.getDay(); 
    const todayDateString = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

    let profileDisplayText = "";
    let isBankHol = false;
    let serviceTypeDisplay = ""; 
    // globalOperationalOverrides needs to be defined and populated in omsi_tools.html if used
    let isOverridden = false;
    let finalDisplayLabel = "Today's Operating Profile:";


    if (typeof globalOperationalOverrides !== 'undefined' && globalOperationalOverrides && globalOperationalOverrides[todayDateString] && currentUser) {
        const overrideProfileValue = globalOperationalOverrides[todayDateString];
        profileDisplayText = `${overrideProfileValue} (Manual Override)`;
        isOverridden = true;
        finalDisplayLabel = "Today's Profile:";
    }


    if (!isOverridden) {
        if (ukBankHolidaysData.dates && ukBankHolidaysData.dates.includes(todayDateString)) {
            let holidayTitle = ukBankHolidaysData.titles[todayDateString] || "Bank Holiday";
            // --- MODIFICATION HERE ---
            holidayTitle = toTitleCase_display(holidayTitle); // Apply title case
            // --- END MODIFICATION ---
            isBankHol = true;
            if (holidayTitle.toLowerCase().includes("good friday")) { // Keep toLowerCase for logic
                profileDisplayText = holidayTitle;
                serviceTypeDisplay = "(Saturday Service)";
            } else {
                profileDisplayText = holidayTitle;
                serviceTypeDisplay = "(Sunday Service)";
            }
        }

        let dayName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][dayOfWeek];

        if (!isBankHol) { 
            profileDisplayText = dayName;
            // Ensure isSchoolHolidayPeriodForSetup and schoolHolidayDateRanges are defined in omsi_tools.html
            if (typeof isSchoolHolidayPeriodForSetup === 'function' && isSchoolHolidayPeriodForSetup(now)) { 
                profileDisplayText += " (School Holiday)";
            }
        } else { 
            profileDisplayText += ` ${serviceTypeDisplay} - Observed on a ${dayName}`;
            if (typeof isSchoolHolidayPeriodForSetup === 'function' && isSchoolHolidayPeriodForSetup(now)) {
                profileDisplayText += " (School Holiday Period)";
            }
        }
    }
    
    const operatingCodes = (typeof getOperatingCodesForToday_Tools === 'function' && !isOverridden) ? getOperatingCodesForToday_Tools() : (isOverridden ? [profileDisplayText.split(' (')[0]] : []);
    
    if (currentProfileDisplayElement) { // Assuming currentProfileDisplayElement is the ID for this file
        const codesString = operatingCodes.length > 0 ? ` [Codes: ${operatingCodes.join(', ')}]` : "";
        currentProfileDisplayElement.textContent = `${finalDisplayLabel} ${profileDisplayText}${codesString}`;
    }
}


// --- Form & Data Handling Functions ---
function isValidScheduleDataFromText(jsonData) {
    if (!jsonData || jsonData.length === 0) return false;
    // Define the core required columns for a schedule file
    const requiredColumns = ['StopID', 'StopName', 'Direction', 'LineName', 'DestinationName', 'ScheduledTime', 'OperatingProfile'];
    const firstEntry = jsonData[0]; // Check headers based on the first entry's keys
    const allColumnsPresent = requiredColumns.every(col => col in firstEntry);

    if (!allColumnsPresent) {
        const missingCols = requiredColumns.filter(col => !(col in firstEntry));
        alert(`Uploaded .COUNT file is missing essential headers: ${missingCols.join(', ')}.\nExpected headers are: StopID, StopName, Direction, LineName, DestinationName, ScheduledTime, OperatingProfile. The 'DayOffset' header is optional.`);
        return false;
    }
    return true;
}

// In omsi_tools.html, replace the existing handleCountFileUpload function with this:

function handleCountFileUpload(event) {
    const file = event.target.files[0];
    if (file) {
        if (fileStatusElement) fileStatusElement.textContent = `Processing ${file.name}...`;
        
        setTimeout(() => {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fileContent = e.target.result;
                    const lines = fileContent.split(/\r?\n/); 

                    if (lines.length < 1) {
                        alert("File is empty.");
                        if(fileStatusElement) fileStatusElement.textContent="File processing failed: File is empty.";
                        if(countFileInput) countFileInput.value=""; 
                        return;
                    }

                    const headerLine = lines[0].trim();
                    const headersFromFile = headerLine.split('\t').map(h => h.trim());

                    if (!isValidHeaderStructure(headersFromFile)) { 
                        if(fileStatusElement) fileStatusElement.textContent = "File processing failed: Invalid header structure.";
                        if(countFileInput) countFileInput.value = "";
                        return; 
                    }
                    
                    if (lines.length < 2 && lines[0].trim() !== "") { 
                         alert("File contains headers but no data rows.");
                        if(fileStatusElement) fileStatusElement.textContent="File processing failed: No data rows.";
                        if(countFileInput) countFileInput.value="";
                        return;
                    }

                    const canonicalHeaders = { 
                        STOPID: "StopID", STOPNAME: "StopName", DIRECTION: "Direction",
                        LINENAME: "LineName", DESTINATIONNAME: "DestinationName",
                        SCHEDULEDTIME: "ScheduledTime", OPERATINGPROFILE: "OperatingProfile",
                        DAYOFFSET: "DayOffset"
                    };
                    const headerMap = {};
                    headersFromFile.forEach(hFromFile => {
                        const upperHFromFile = hFromFile.toUpperCase();
                        for (const canonUpper in canonicalHeaders) {
                            if (upperHFromFile === canonUpper) {
                                headerMap[hFromFile] = canonicalHeaders[canonUpper];
                                break;
                            }
                        }
                    });

                    const newScheduleEntries = []; 
                    const definedStopIDsInThisUpload = new Set(); // To avoid duplicate minimal definitions

                    for (let i = 1; i < lines.length; i++) { 
                        const line = lines[i].trim();
                        if (line === "") continue; 

                        const values = line.split('\t').map(v => v.trim());
                        
                        let rowObjectCanonical = {}; 
                        headersFromFile.forEach((headerInFile, idx) => {
                            const canonicalKey = headerMap[headerInFile]; 
                            if (canonicalKey) { 
                                rowObjectCanonical[canonicalKey] = values[idx] !== undefined ? values[idx] : "";
                            }
                        });

                        const stopIDFromFile = String(rowObjectCanonical.StopID || "").trim().toUpperCase();
                        const stopNameFromFile = String(rowObjectCanonical.StopName || "").trim();
                        const directionFromFile = String(rowObjectCanonical.Direction || "").trim();
                        const lineNameFromFile = String(rowObjectCanonical.LineName || "").trim().toUpperCase();
                        const destinationNameFromFile = String(rowObjectCanonical.DestinationName || "").trim();
                        const operatingProfileFromFile = String(rowObjectCanonical.OperatingProfile || "").trim();
                        const dayOffsetFromFile = String(rowObjectCanonical.DayOffset || "0").trim();
                        let rawScheduledTimes = String(rowObjectCanonical.ScheduledTime || "").trim();
                        
                        if (!stopIDFromFile) {
                            console.warn(`Skipping row ${i+1} due to missing StopID.`);
                            continue;
                        }

                        // Determine if this row is primarily for stop definition
                        const isLikelyStopDefinition = stopIDFromFile && 
                                                     (stopNameFromFile || directionFromFile) && // Must have at least name or direction for a useful definition
                                                     !lineNameFromFile && 
                                                     !rawScheduledTimes && 
                                                     !operatingProfileFromFile;

                        if (isLikelyStopDefinition) {
                            if (!definedStopIDsInThisUpload.has(stopIDFromFile)) {
                                newScheduleEntries.push({
                                    internalId: `${stopIDFromFile}_definition_row${i}_${Date.now()}`,
                                    stopID: stopIDFromFile,
                                    stopName: stopNameFromFile || "Unnamed Stop (via upload)",
                                    direction: directionFromFile || ""
                                    // NO LineName, DestinationName, ScheduledTime, OperatingProfile, DayOffset
                                });
                                definedStopIDsInThisUpload.add(stopIDFromFile);
                                console.log(`Row ${i+1}: Processed as Stop Definition for ${stopIDFromFile}`);
                            } else {
                                 console.log(`Row ${i+1}: Duplicate minimal Stop Definition for ${stopIDFromFile} in this file upload, skipped.`);
                            }
                        } else if (stopIDFromFile && lineNameFromFile && rawScheduledTimes && operatingProfileFromFile) {
                            // Process as a full schedule entry
                            const timeStrings = rawScheduledTimes.split(',')
                                                      .map(t => t.trim())
                                                      .filter(t => t !== ""); 

                            if (timeStrings.length === 0 && rawScheduledTimes !== "") {
                                 console.warn(`Row ${i+1}: ScheduledTime column '${rawScheduledTimes}' (for Line: ${lineNameFromFile}) parsed to zero valid times. Skipping times for this row configuration.`);
                            }
                            
                            timeStrings.forEach((singleTimeStr, timeIdx) => {
                                let schTime = singleTimeStr;
                                if (schTime.match(/^\d{1,2}:\d{2}(:\d{2})?$/)) { 
                                    const p = schTime.split(':');
                                    schTime = `${String(p[0]).padStart(2, '0')}:${String(p[1]).padStart(2, '0')}`;
                                } else if (schTime.length === 4 && !schTime.includes(':')) { 
                                    schTime = `${schTime.substring(0, 2)}:${schTime.substring(2, 4)}`;
                                } else if (schTime.length === 3 && !schTime.includes(':')) { 
                                    schTime = `0${schTime.substring(0, 1)}:${schTime.substring(1, 3)}`;
                                } else {
                                    console.warn(`Row ${i+1}, Time #${timeIdx+1}: Unrecognized time format '${singleTimeStr}'. Skipping this specific time.`);
                                    return; 
                                }

                                const timeParts = schTime.split(':');
                                const h = parseInt(timeParts[0], 10);
                                const m = parseInt(timeParts[1], 10);
                                if (isNaN(h) || isNaN(m) || h < 0 || h > 23 || m < 0 || m > 59) {
                                    console.warn(`Row ${i+1}, Time #${timeIdx+1}: Invalid time value '${schTime}' after standardization. Skipping this specific time.`);
                                    return; 
                                }

                                newScheduleEntries.push({
                                    internalId: `${stopIDFromFile}_${lineNameFromFile}_${schTime.replace(':', '')}_row${i}_t${timeIdx}_countfile`,
                                    stopID: stopIDFromFile,
                                    stopName: stopNameFromFile,
                                    direction: directionFromFile,
                                    lineName: lineNameFromFile,
                                    destinationName: destinationNameFromFile,
                                    scheduledTime: schTime,
                                    OperatingProfile: operatingProfileFromFile,
                                    DayOffset: dayOffsetFromFile
                                });
                            });
                        } else {
                             console.warn(`Skipping row ${i+1} as it's incomplete for a schedule entry and not a clear stop definition. StopID: '${stopIDFromFile}', LineName: '${lineNameFromFile}', Times: '${rawScheduledTimes}', Profile: '${operatingProfileFromFile}'.`);
                        }
                    }

                    // (The rest of the function: checks for empty results, confirmation, assignment to currentWorkingSchedule, etc.)
                    // ... remains the same ...
                    if (newScheduleEntries.length === 0 && lines.length > 1 && lines[0].trim() !== "") { 
                        alert("No valid schedule entries or stop definitions could be processed from the file. Please check the format and data.");
                        if(fileStatusElement) fileStatusElement.textContent="File processing failed: No valid entries found.";
                        if(countFileInput) countFileInput.value="";
                        return;
                    }
                    if (newScheduleEntries.length === 0 && (lines.length <=1 || lines[0].trim() === "")) { 
                        alert("File appears to be empty or contains only headers without data.");
                        return;
                    }

                    if (currentWorkingSchedule.length > 0 && !confirm("This will REPLACE the current working schedule with the contents of this file. Are you sure?")) {
                        if(fileStatusElement) fileStatusElement.textContent="Upload cancelled by user.";
                        if(countFileInput) countFileInput.value="";
                        return;
                    }
                    
                    currentWorkingSchedule = newScheduleEntries;
                    renderUIDependentElements(); 
                    updateStagingStatusDisplay(); 
                    if(fileStatusElement) fileStatusElement.textContent = `${file.name} processed. ${currentWorkingSchedule.length} total entries (schedule entries + stop definitions) loaded.`;


                } catch (error) {
                    console.error("Error processing .COUNT file:", error);
                    alert(`An error occurred while processing the file: ${error.message}. Please check file format and content.`);
                    if(fileStatusElement) fileStatusElement.textContent = "Error loading file.";
                }
                if(countFileInput) countFileInput.value=""; 
            };
            reader.onerror = () => {
                alert("Could not read the selected file. Please ensure it's a valid text file.");
                if(fileStatusElement) fileStatusElement.textContent = "Error reading file.";
                if(countFileInput) countFileInput.value = "";
            };
            reader.readAsText(file); 
        }, 50); 
    }
}

// Add this new helper function or integrate its logic if you have a similar one
function isValidHeaderStructure(parsedHeaders) {
    // Convert all parsed headers to uppercase for case-insensitive comparison
    const upperParsedHeaders = parsedHeaders.map(h => h.toUpperCase());
    const requiredHeaders = ['STOPID', 'STOPNAME', 'DIRECTION', 'LINENAME', 'DESTINATIONNAME', 'SCHEDULEDTIME', 'OPERATINGPROFILE']; // DayOffset is optional but good to have
    
    const missingHeaders = requiredHeaders.filter(rh => !upperParsedHeaders.includes(rh));

    if (missingHeaders.length > 0) {
        alert(`Uploaded .COUNT file is missing essential headers: ${missingHeaders.join(', ')}.\nExpected headers (case-insensitive) are at least: ${requiredHeaders.join(', ')}. The 'DayOffset' header is also recommended.`);
        return false;
    }
    return true;
}

function handleBulkUpdateRouteDestination() {
    if (!currentUser) { alert("Please log in to perform bulk updates."); return; }
    const targetLineName = bulkEditTargetLineNameInput.value.trim().toUpperCase();
    const oldDestination = bulkEditOldDestinationInput.value.trim(); // Keep case for comparison if needed, or use .toLowerCase() for case-insensitive
    const newDestination = bulkEditNewDestinationInput.value.trim();

    if (!targetLineName) { alert("Target Line Name is required."); bulkEditTargetLineNameInput.focus(); return; }
    if (!newDestination) { alert("New Destination Name is required."); bulkEditNewDestinationInput.focus(); return; }

    let updatedCount = 0;
    currentWorkingSchedule.forEach(entry => {
        if (entry.lineName && entry.lineName.toUpperCase() === targetLineName) {
            // If oldDestination is provided, only update if it matches (case-insensitive for flexibility)
            if (oldDestination) {
                if (entry.destinationName && entry.destinationName.toLowerCase() === oldDestination.toLowerCase()) {
                    entry.destinationName = newDestination;
                    updatedCount++;
                }
            } else { // If oldDestination is blank, update all entries for the targetLineName
                entry.destinationName = newDestination;
                updatedCount++;
            }
        }
    });

    if (updatedCount > 0) {
        renderUIDependentElements(); // Refresh UI
        updateStagingStatusDisplay(); // Update Firebase status
        alert(`${updatedCount} entries for Line "${targetLineName}" had their destination updated to "${newDestination}".`);
    } else {
        alert(`No entries found for Line "${targetLineName}"` + (oldDestination ? ` with Old Destination "${oldDestination}"` : "") + " to update.");
    }
}


// --- Firebase Data Interaction ---
// REPLACE your existing handleStageSchedule function in omsi_tools.html with this:

async function handleStageSchedule() { // <--- Added async here
    if (!currentUser) {
        alert("Please log in to stage the schedule.");
        return;
    }
    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        alert("Firebase is not available. Cannot stage schedule.");
        return;
    }

    const { database, dbSet, dbUpdate, dbRef } = window.firebaseOMSI;

    if (currentWorkingSchedule.length === 0) {
        if (!confirm("The working schedule is currently empty. Are you sure you want to stage an empty schedule? This will clear any previously staged data and the live data if applied.")) {
            if (stagingStatusMessage) {
                stagingStatusMessage.textContent = "Staging of empty schedule cancelled.";
                stagingStatusMessage.style.color = "#e74c3c";
            }
            return;
        }
    }

    if (stagingStatusMessage) {
        stagingStatusMessage.textContent = "Preparing to stage schedule... This may take a moment for large schedules.";
        stagingStatusMessage.style.color = "#f1c40f"; // Yellow for in-progress
    }

    try {
        // 1. Clear the existing pending schedules base path first.
        console.log(`Staging: Clearing existing data at ${FB_PATH_PENDING_SCHEDULE_DATA}...`);
        await dbSet(dbRef(database, FB_PATH_PENDING_SCHEDULE_DATA), null);
        console.log("Staging: Pending schedule path cleared.");

        // 2. Group currentWorkingSchedule entries by Route/Profile/Destination
        const groupedByRPD = {};
        currentWorkingSchedule.forEach((entry, index) => {
            if (!entry.lineName || !entry.OperatingProfile || !entry.destinationName) {
                console.warn("Staging: Skipping entry with missing route/profile/destination for structure:", entry);
                return;
            }
            // Ensure sanitizeFirebaseKey is available in this scope
            const saneRoute = sanitizeFirebaseKey(entry.lineName);
            const saneProfile = sanitizeFirebaseKey(entry.OperatingProfile);
            const saneDest = sanitizeFirebaseKey(entry.destinationName);
            const pathKey = `${saneRoute}/${saneProfile}/${saneDest}`;

            if (!groupedByRPD[pathKey]) {
                groupedByRPD[pathKey] = [];
            }
            
            const entryForStaging = { ...entry };
            if (!entryForStaging.internalId || entryForStaging.internalId.includes("_fbload_flat") || entryForStaging.internalId.includes("_countfile")) {
                 entryForStaging.internalId = `${(entry.stopID||'s').toUpperCase()}_${(entry.lineName||'l').toUpperCase()}_${(entry.scheduledTime||"").replace(':','')}_staged_${Date.now()}_${index}`;
            }
            groupedByRPD[pathKey].push(entryForStaging);
        });

        // 3. Write each group (R/P/D's entries) to Firebase separately
        console.log(`Staging: Preparing to write ${Object.keys(groupedByRPD).length} individual R/P/D groups to Firebase.`);
        const writePromises = [];
        for (const rpdKey in groupedByRPD) {
            const entriesForThisRPD = groupedByRPD[rpdKey];
            entriesForThisRPD.sort((a, b) => { // Sort for consistency
                const timeA = (a.scheduledTime || "99:99").replace(':', '');
                const timeB = (b.scheduledTime || "99:99").replace(':', '');
                const timeCompare = timeA.localeCompare(timeB);
                if (timeCompare !== 0) return timeCompare;
                return (a.stopID || "").localeCompare(b.stopID || "");
            });

            const specificFirebasePath = `${FB_PATH_PENDING_SCHEDULE_DATA}/${rpdKey}/entries`;
            writePromises.push(dbSet(dbRef(database, specificFirebasePath), entriesForThisRPD));
        }

        await Promise.all(writePromises);
        console.log("Staging: All individual R/P/D schedule parts written to Firebase pending path.");

        // 4. Generate and save ancillary data (unique stops, timestamp, status)
        const stopsMap = new Map();
        currentWorkingSchedule.forEach(row => {
            if (row.stopID && !stopsMap.has(row.stopID.toUpperCase())) {
                stopsMap.set(row.stopID.toUpperCase(), {
                    stopID: row.stopID, stopName: row.stopName, direction: row.direction
                });
            }
        });
        const finalUniqueStops = Array.from(stopsMap.values()).sort((a,b)=>{
            const nameCompare = (a.stopName||"").localeCompare(b.stopName||"");
            return nameCompare !== 0 ? nameCompare : (a.direction||"").localeCompare(b.direction||"");
        });

        const ancillaryUpdates = {};
        ancillaryUpdates[FB_PATH_PENDING_UNIQUE_STOPS] = finalUniqueStops;
        ancillaryUpdates[FB_PATH_PENDING_TIMESTAMP] = new Date().toISOString();
        ancillaryUpdates[FB_PATH_APPSTATE_STATUS] = 'update_staged';

        await dbUpdate(dbRef(database), ancillaryUpdates);

        alert("Schedule STAGED successfully to Firebase using granular writes. It can now be applied live.");
        updateStagingStatusDisplay();

    } catch (error) {
        console.error("Firebase Staging Error (granular writes): ", error);
        alert("Error staging schedule to Firebase: " + error.message + ". Check console for details.");
        if(stagingStatusMessage) {
            stagingStatusMessage.textContent = "Firebase Staging Error. Data might be partially staged. It's advisable to try staging again.";
            stagingStatusMessage.style.color = "#e74c3c";
        }
    }
}

// REPLACE your existing handleApplyNow function in omsi_tools.html with this:

async function handleApplyNow() { // Added async here
    if (!currentUser) {
        alert("Please log in to apply the staged schedule.");
        return;
    }
    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        alert("Firebase is not available. Cannot apply schedule.");
        return;
    }

    const { database, dbGet, dbSet, dbUpdate, dbRef, dbChild } = window.firebaseOMSI;

    if (stagingStatusMessage) {
        stagingStatusMessage.textContent = "Fetching staged data to apply live...";
        stagingStatusMessage.style.color = "#f1c40f";
    }

    try {
        // 1. Get the entire pending schedule node
        const pendingSnapshot = await dbGet(dbChild(dbRef(database), '/pendingSchedule'));

        if (!pendingSnapshot.exists()) {
            alert("No Firebase staged schedule found to apply.");
            if (stagingStatusMessage) {
                stagingStatusMessage.textContent = "No Firebase staged schedule available.";
                stagingStatusMessage.style.color = "#e74c3c";
            }
            return;
        }

        const pendingDataContainer = pendingSnapshot.val();
        // Extract the actual nested schedule data and unique stops
        // The keys here should match how they are stored in FB_PATH_PENDING_SCHEDULE_DATA and FB_PATH_PENDING_UNIQUE_STOPS
        const pendingSchedulesByRoute = pendingDataContainer[FB_PATH_PENDING_SCHEDULE_DATA.split('/').pop()]; // e.g., "schedulesByRoute"
        const pendingUniqueBusStops = pendingDataContainer[FB_PATH_PENDING_UNIQUE_STOPS.split('/').pop()]; // e.g., "uniqueBusStops"

        if (!pendingSchedulesByRoute) {
            alert("Staged schedule data (schedulesByRoute object) is missing or in an unexpected format within the pending data. Cannot apply.");
            console.error("Pending data dump (missing schedulesByRoute):", pendingDataContainer);
            if (stagingStatusMessage) stagingStatusMessage.textContent = "Error: Staged schedule data missing.";
            return;
        }
        if (!pendingUniqueBusStops) {
            alert("Staged unique bus stops data is missing. Cannot apply.");
            console.error("Pending data dump (missing uniqueBusStops):", pendingDataContainer);
            if (stagingStatusMessage) stagingStatusMessage.textContent = "Error: Staged unique stops missing.";
            return;
        }

        if (!confirm("Are you sure you want to apply the STAGED schedule LIVE NOW? This will overwrite the current live data.")) {
            if (stagingStatusMessage) {
                stagingStatusMessage.textContent = "Apply operation cancelled by user.";
                stagingStatusMessage.style.color = "#f1c40f";
            }
            return;
        }

        if (stagingStatusMessage) {
            stagingStatusMessage.textContent = "Applying staged schedule live... This may take a moment.";
            stagingStatusMessage.style.color = "#f1c40f";
        }

        // 2. Clear the existing live schedules base path.
        console.log(`ApplyNow: Clearing existing data at ${FB_PATH_LIVE_SCHEDULE_DATA}...`);
        await dbSet(dbRef(database, FB_PATH_LIVE_SCHEDULE_DATA), null);
        console.log("ApplyNow: Live schedule path cleared.");

        // 3. Write each R/P/D's entries from pendingSchedulesByRoute to the live path
        console.log(`ApplyNow: Preparing to write ${Object.keys(pendingSchedulesByRoute).length} individual R/P/D groups to live path.`);
        const liveWritePromises = [];
        for (const saneRoute in pendingSchedulesByRoute) {
            for (const saneProfile in pendingSchedulesByRoute[saneRoute]) {
                for (const saneDest in pendingSchedulesByRoute[saneRoute][saneProfile]) {
                    const entriesForThisRPD = pendingSchedulesByRoute[saneRoute][saneProfile][saneDest].entries;
                    if (entriesForThisRPD && Array.isArray(entriesForThisRPD)) {
                        const specificLivePath = `${FB_PATH_LIVE_SCHEDULE_DATA}/${saneRoute}/${saneProfile}/${saneDest}/entries`;
                        liveWritePromises.push(dbSet(dbRef(database, specificLivePath), entriesForThisRPD));
                    } else {
                        console.warn(`ApplyNow: Missing or invalid 'entries' array for ${saneRoute}/${saneProfile}/${saneDest} in pending data.`);
                    }
                }
            }
        }

        await Promise.all(liveWritePromises);
        console.log("ApplyNow: All individual R/P/D schedule parts written to Firebase live path.");

        // 4. Update ancillary live data and clear pending area
        const appUpdates = {};
        appUpdates[FB_PATH_LIVE_UNIQUE_STOPS] = pendingUniqueBusStops; // Write the staged unique stops
        appUpdates[FB_PATH_APPSTATE_LAST_UPDATED] = new Date().toISOString();
        appUpdates[FB_PATH_APPSTATE_STATUS] = 'idle';
        appUpdates['/pendingSchedule'] = null;      // Clear the entire pendingSchedule node

        await dbUpdate(dbRef(database), appUpdates);

        alert("Staged schedule APPLIED LIVE successfully (using granular writes)!");
        
        // IMPORTANT: Reload data into currentWorkingSchedule from the new live structured data
        // This ensures the local in-memory state matches the newly applied live state.
        await loadInitialData(); // Make sure loadInitialData is also async if it wasn't already
        // updateStagingStatusDisplay() will be called by loadInitialData via renderUIDependentElements -> updateStagingStatusDisplay

    } catch (error) {
        console.error("Firebase Apply Error (granular writes): ", error);
        alert("Error applying schedule live: " + error.message + ". Check console for details.");
        if (stagingStatusMessage) {
            stagingStatusMessage.textContent = "Firebase Apply Error. Live data might be incomplete or old data might not be fully cleared. Please review carefully or try staging and applying again.";
            stagingStatusMessage.style.color = "#e74c3c";
        }
    }
}

// In omsi_tools.html, within the main <script> block

async function loadInitialData() {
    console.log("Tools: Loading initial data from Firebase (enhanced for all stops)...");
    let msg = "Loading data from Firebase...";
    if (fileStatusElement) fileStatusElement.textContent = msg;

    currentWorkingSchedule = []; // Reset before loading
    closedStopIDs = [];
    globalCustomRouteColours = {}; // Assuming this is defined elsewhere or loaded if needed
    stopSpecificRouteColours = {}; // Assuming this is defined elsewhere or loaded if needed

    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        msg = "Firebase not connected. Cannot load data.";
        console.error(msg);
        if (fileStatusElement) fileStatusElement.textContent = msg;
        renderUIDependentElements(); // Render with empty data
        return;
    }

    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
    try {
        // 1. Fetch structured schedule data (stops that have active routes)
        const scheduleSnap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_SCHEDULE_DATA)); // FB_PATH_LIVE_SCHEDULE_DATA = '/liveSchedule/schedulesByRoute'
        const flatScheduleFromDB = [];
        if (scheduleSnap.exists()) {
            const schedulesByRoute = scheduleSnap.val();
            for (const routeKey in schedulesByRoute) {
                const routeData = schedulesByRoute[routeKey];
                for (const profileKey in routeData) {
                    const profileData = routeData[profileKey];
                    for (const destKey in profileData) {
                        const destData = profileData[destKey];
                        if (destData && Array.isArray(destData.entries)) {
                            destData.entries.forEach(entry => {
                                flatScheduleFromDB.push({ ...entry });
                            });
                        }
                    }
                }
            }
        }
        currentWorkingSchedule = flatScheduleFromDB.map((e,i)=>({...e, internalId: e.internalId || `${(e.stopID||'s')}_${(e.lineName||'l')}_${(e.scheduledTime||"").replace(':','')}_${i}_fbload_flat`}));
        console.log(`Loaded ${currentWorkingSchedule.length} entries from structured schedule data (schedulesByRoute).`);

        // 2. Fetch all unique stop definitions from Firebase
        const uniqueStopsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_UNIQUE_STOPS)); // FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops'
        const firebaseUniqueStops = uniqueStopsSnap.exists() && Array.isArray(uniqueStopsSnap.val()) ? uniqueStopsSnap.val() : [];
        console.log(`Workspaceed ${firebaseUniqueStops.length} stops from uniqueBusStops list.`);

        const stopIDsAlreadyInScheduleFromRoutes = new Set(currentWorkingSchedule.map(e => e.stopID.toUpperCase()));

        firebaseUniqueStops.forEach(fbStop => {
            if (fbStop && fbStop.stopID && !stopIDsAlreadyInScheduleFromRoutes.has(fbStop.stopID.toUpperCase())) {
                // This stop is defined in uniqueBusStops but was not found in any active schedule entries.
                // Add it as a definition-only entry to currentWorkingSchedule.
                currentWorkingSchedule.push({
                    internalId: `${fbStop.stopID}_definition_fbload_${Date.now()}`, // Ensure unique internalId
                    stopID: fbStop.stopID,
                    stopName: fbStop.stopName || "Unknown Stop Name", // Provide default if missing
                    direction: fbStop.direction || "" // Default to empty string if no direction (no "towards")
                    // No LineName, ScheduledTime etc. as it's a definition for a stop without current routes
                });
                console.log(`Added definition for stop ${fbStop.stopID} (from uniqueBusStops) to local working schedule.`);
            }
        });

        // 3. Fetch other necessary data (closed stops, colours)
        const closedSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_CLOSED_STOPS));
        if (closedSnap.exists()) {
            const fbClosed = closedSnap.val();
            for(const id_key in fbClosed) { // Renamed 'id' to 'id_key' to avoid conflict if 'id' is a global var
                if(fbClosed[id_key]===true) closedStopIDs.push(id_key.toUpperCase());
            }
        }

        const globalColoursSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS));
        if (globalColoursSnap.exists()) globalCustomRouteColours = globalColoursSnap.val() || {};

        const stopSpecificColoursSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS));
        if (stopSpecificColoursSnap.exists()) stopSpecificRouteColours = stopSpecificColoursSnap.val() || {};

        msg = `Data loaded. Working schedule now contains ${currentWorkingSchedule.length} total items (schedule entries + stop definitions). ${closedStopIDs.length} closed stops identified.`;
    } catch (error) {
        console.error("Firebase Load Initial Data Error (omsi_tools.html with merge logic):", error);
        msg = "Error loading data from Firebase: " + error.message;
        currentWorkingSchedule = []; // Ensure it's empty on error
    }
    if (fileStatusElement) fileStatusElement.textContent = msg;

    // These functions were in your original omsi_tools.html loadInitialData, ensure they are defined or remove if not needed.
    if (typeof compileEffectiveRouteColoursForTools === 'function') compileEffectiveRouteColoursForTools();
    renderUIDependentElements();
    updateStagingStatusDisplay();
    if (typeof fetchBankHolidaysForSetup === 'function') fetchBankHolidaysForSetup();
}

async function updateStagingStatusDisplay() {
    let pTime = null; // Pending timestamp
    let lTime = null; // Last live update timestamp
    let fbStatus = "Checking Firebase status...";
    let currentFbSt = 'unknown'; // Firebase app state status

    if (applyNowButton) applyNowButton.disabled = true; // Disable by default

    if (window.firebaseOMSI && window.firebaseOMSI.database) {
        const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
        try {
            const pSnap = await dbGet(dbChild(dbRef(database), FB_PATH_PENDING_TIMESTAMP));
            if (pSnap.exists()) pTime = pSnap.val();

            const lSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_LAST_UPDATED));
            if (lSnap.exists()) lTime = lSnap.val();

            const sSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_STATUS));
            currentFbSt = sSnap.exists() ? sSnap.val() : 'unknown';
            fbStatus = `Firebase status: ${currentFbSt}.`;

            if (applyNowButton) applyNowButton.disabled = !(currentFbSt === 'update_staged' && pTime); // Enable only if staged and timestamp exists

        } catch (error) {
            fbStatus = "Error checking Firebase Status.";
            console.error(fbStatus, error);
            if (applyNowButton) applyNowButton.disabled = true;
        }
    } else {
        fbStatus = "Firebase not available.";
        if (applyNowButton) applyNowButton.disabled = true;
    }

    let msg = "";
    if (currentFbSt === 'update_staged' && pTime) {
        msg = `A schedule was STAGED on: ${new Date(pTime).toLocaleString()}.<br>It is ready to 'Apply Staged Live NOW'.`;
        if(stagingStatusMessage) stagingStatusMessage.style.color = "#2ecc71"; // Green for ready
    } else {
        msg = "No schedule is currently staged. Any changes made can be staged for future application.";
        if(stagingStatusMessage) stagingStatusMessage.style.color = "#f1c40f"; // Yellow for can stage
    }
    msg += lTime ? `<br>The LIVE schedule was last updated: ${new Date(lTime).toLocaleString()}` : "<br>The LIVE schedule has not been set yet.";
    msg += `<br><small>(${fbStatus})</small>`;

    if(stagingStatusMessage) stagingStatusMessage.innerHTML = msg;
}

function saveClosedStopsToFirebase() {
    if (!currentUser) return; // Only if logged in
    if (window.firebaseOMSI && window.firebaseOMSI.database) {
        const { database, dbRef, dbUpdate } = window.firebaseOMSI;
        const fbClosedObject = {}; // Firebase prefers objects for this kind of map
        closedStopIDs.forEach(id => fbClosedObject[id.toUpperCase()] = true); // Ensure uppercase keys

        const updates = {};
        updates[FB_PATH_APPSTATE_CLOSED_STOPS] = fbClosedObject;
        dbUpdate(dbRef(database), updates)
            .then(() => {
                console.log("Closed stops saved to Firebase.");
                // Update status message in Stop Management tool if it's active
                if (masterStopListStatus_SM && document.getElementById('stop-management-tool-section')?.style.display === 'block') {
                    masterStopListStatus_SM.textContent = "Stop status updated in Firebase.";
                    setTimeout(() => { // Revert to normal count message after a delay
                        if(masterStopListStatus_SM && masterStopListUL_SM) masterStopListStatus_SM.textContent = `Showing ${masterStopListUL_SM.children.length} of ${uniqueStopsMasterList_SM.length} unique stops.`;
                    }, 2000);
                }
                // Refresh master stop list as it displays status
                populateMasterStopList_SM();
            })
            .catch(error => {
                console.error("Firebase Save Closed Stops Error: ", error);
                if (masterStopListStatus_SM) masterStopListStatus_SM.textContent = "Error saving stop status to Firebase.";
            });
    }
}

function saveGlobalCustomRouteColours() {
    if (!currentUser) return;
    if (window.firebaseOMSI && window.firebaseOMSI.database) {
        const { database, dbSet, dbRef } = window.firebaseOMSI;
        dbSet(dbRef(database, FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS), globalCustomRouteColours)
            .then(() => console.log("Global custom route colours saved to Firebase."))
            .catch(e => console.error("Firebase Save Global Custom Colours Error: ", e));
    }
    if (routeColourStatusMessage) {
        routeColourStatusMessage.textContent = 'Global custom colours saved.';
        setTimeout(() => { if(routeColourStatusMessage) routeColourStatusMessage.textContent = ''; }, 3000);
    }
    compileEffectiveRouteColoursForTools(); // Recompile if this function exists
    renderGlobalCustomRouteColours(); // Re-render the list of global colours

    // Refresh other UI elements that might use these colours
    if(selectStopForDeparturesView?.value) displayDeparturesForSelectedStop();
    if (selectStopForSpecificRouteColour?.value) displayRoutesForSpecificColouring();
    if (document.getElementById('stop-management-tool-section')?.style.display === 'block') populateMasterStopList_SM();
}

function saveStopSpecificRouteColoursToFirebase() {
    if (!currentUser) {
        if(stopSpecificRouteColourStatusMessage) {stopSpecificRouteColourStatusMessage.textContent="Not logged in. Cannot save."; stopSpecificRouteColourStatusMessage.style.color='#e74c3c';}
        return;
    }
    if (window.firebaseOMSI && window.firebaseOMSI.database) {
        const { database, dbSet, dbRef } = window.firebaseOMSI;
        dbSet(dbRef(database, FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS), stopSpecificRouteColours)
            .then(() => {
                console.log("Stop-specific route colours saved to Firebase.");
                if(stopSpecificRouteColourStatusMessage){
                    stopSpecificRouteColourStatusMessage.textContent='Stop-specific colours saved successfully.';
                    stopSpecificRouteColourStatusMessage.style.color='#2ecc71';
                    setTimeout(()=>{if(stopSpecificRouteColourStatusMessage)stopSpecificRouteColourStatusMessage.textContent='';},3000);
                }
                compileEffectiveRouteColoursForTools(); // Recompile if needed
                renderStopSpecificRouteColours(); // Re-render the list of stop-specific colours

                // Refresh other UI that might use these specific colours
                if (selectStopForSpecificRouteColour?.value) displayRoutesForSpecificColouring(); // Refresh tiles in current view
                if (document.getElementById('stop-management-tool-section')?.style.display==='block') populateMasterStopList_SM();
                if (selectStopForDeparturesView?.value) displayDeparturesForSelectedStop();
            })
            .catch(error => {
                console.error("Firebase Save Stop-Specific Colours Error:", error);
                if(stopSpecificRouteColourStatusMessage){
                    stopSpecificRouteColourStatusMessage.textContent='Error saving stop-specific colours: ' + error.message;
                    stopSpecificRouteColourStatusMessage.style.color='#e74c3c';
                }
            });
    } else {
        if(stopSpecificRouteColourStatusMessage){
            stopSpecificRouteColourStatusMessage.textContent='Firebase not available. Cannot save.';
            stopSpecificRouteColourStatusMessage.style.color='#e74c3c';
        }
    }
}


// --- UI Population & Rendering ---
function setGlobalRouteColour(colour) { if (inputRouteColour) inputRouteColour.value = colour; }
function setStopSpecificRouteColour(colour) { if (inputStopSpecificRouteColour) inputStopSpecificRouteColour.value = colour; }

function renderUIDependentElements() {
    if(currentUser) { // Only populate if user is logged in and data might be present
        populateRouteSelectorForColours();
        populateStopSelectorForSpecificColours();
        populateStopSelectorForDeparturesView();
        renderGlobalCustomRouteColours();
        renderStopSpecificRouteColours();
        populateConsolidateStopSelect(); // This will chain to populate its route select
        populateCopierStopSelectors(); // For Schedule Generator's copier tool
        populate_rse_SelectRoute(); // For Route Stops Explorer
        // ADDED: Populate Timetable Generator route select
        if (document.getElementById('timetable-generator-section')?.style.display === 'block') {
             populate_tg_selectRoute();
        }

        // If Schedule Generator is active, re-initialize its controls
        // This ensures its internal dropdowns (stop, route, dest) are also up-to-date
        const scheduleGeneratorSection = document.getElementById('schedule-generator-section');
        if (scheduleGeneratorSection && scheduleGeneratorSection.style.display === 'block') {
            console.log("renderUIDependentElements: Refreshing Schedule Generator controls due to data change.");
            gen_initializeScheduleGeneratorControls();
            initializeScheduleGeneratorCopierControls();
        }

        // Refresh content of the currently active section if it depends on schedule data
        const activeSectionId = localStorage.getItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        if (activeSectionId) {
            const sectionElement = document.getElementById(activeSectionId);
            if (sectionElement && sectionElement.style.display === 'block') {
                console.log(`renderUIDependentElements: Re-evaluating content for active section: ${activeSectionId}`);
                if (activeSectionId === 'bulk-edit-tools-section') {
                    // Already handled by individual calls above, but ensure tiles update if needed
                    if (selectStopForSpecificRouteColour?.value) displayRoutesForSpecificColouring();
                } else if (activeSectionId === 'view-departures-section') {
                    if(selectStopForDeparturesView?.value) displayDeparturesForSelectedStop();
                } else if (activeSectionId === 'stop-management-tool-section') {
                    populateMasterStopList_SM();
                }
                // Global route deletion selector is already populated
                else if (activeSectionId === 'route-timetable-overwrite-section') {
                    populate_rto_SelectRoute(); // Re-populate RTO selectors
                }
                // Analytics consolidation selectors are already populated
                // Add/Remove stop selector is already populated
                else if (activeSectionId === 'operating-profiles-section') {
                    displayUniqueOperatingProfiles();
                    displayReferenceOperatingProfiles();
                } else if (activeSectionId === 'route-stops-explorer-section') {
                    if (rse_selectRoute?.value) displayRouteStopsExplorer();
                }
                // ADDED: Refresh Timetable Generator if active
                else if (activeSectionId === 'timetable-generator-section') {
                    if (tg_selectRoute?.value) { // If a route is selected
                        populate_tg_selectDirection(); // This will re-populate directions and trigger timetable display
                    }
                     if (tg_selectRoute?.value && tg_selectDirection?.value) {
                        display_tg_Timetable();
                    }
                }
            }
        }
    } else { // User logged out or data cleared
        // Clear all select dropdowns to a default state
        const allSelects = document.querySelectorAll('select');
        allSelects.forEach(sel => {
            const firstOptionText = sel.options[0] ? sel.options[0].textContent : "-- Select --";
            const firstOptionValue = sel.options[0] ? sel.options[0].value : "";
            sel.innerHTML = `<option value="${firstOptionValue}">${firstOptionText}</option>`;
        });

        // Clear lists and show placeholders/default messages
        if(currentRouteColoursList) currentRouteColoursList.innerHTML = "";
        if(noCustomColoursMessage) noCustomColoursMessage.style.display = 'block';
        if(currentStopSpecificColoursList) currentStopSpecificColoursList.innerHTML = "";
        if(noStopSpecificColoursMessageEl) noStopSpecificColoursMessageEl.style.display = 'block';
        if(stopDeparturesList) stopDeparturesList.innerHTML = "";
        if(noDeparturesForStopMessage) noDeparturesForStopMessage.style.display = 'block';
        if(masterStopListUL_SM) masterStopListUL_SM.innerHTML = "";
        if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = 'Please log in to view stops.';
        if(duplicateEntriesResults) duplicateEntriesResults.innerHTML = '<p>Please log in to detect duplicates.</p>';
        if(gen_currentScheduleEntries) gen_currentScheduleEntries = []; gen_renderScheduleTable(); // Clear generator table

        // Clear Route Stops Explorer
        if(rse_direction1_stopsList) rse_direction1_stopsList.innerHTML = "";
        if(rse_direction2_stopsList) rse_direction2_stopsList.innerHTML = "";
        if(rse_direction1_placeholder) rse_direction1_placeholder.style.display = 'block';
        if(rse_direction2_placeholder) rse_direction2_placeholder.style.display = 'block';
        if(rse_direction1_title) rse_direction1_title.textContent = "Direction 1: (Select Route)";
        if(rse_direction2_title) rse_direction2_title.textContent = "Direction 2: (Select Route)";

        // Clear Timetable Generator
        if (tg_timetableTableBody) tg_timetableTableBody.innerHTML = '';
        if (tg_timetablePlaceholder) {
            tg_timetablePlaceholder.textContent = 'Please log in and load schedule data.';
            tg_timetablePlaceholder.style.display = 'block';
        }
        if (tg_statusMessage) tg_statusMessage.textContent = '';
    }
}


function compileEffectiveRouteColoursForTools() { /* console.log("Effective route colours re-evaluation triggered."); */ } // Placeholder if used
function renderGlobalCustomRouteColours() {
    if (!currentRouteColoursList || !noCustomColoursMessage) return; currentRouteColoursList.innerHTML = '';
    const routes = Object.keys(globalCustomRouteColours).sort(compareLineNames); let hasTrueCustoms = routes.length > 0;
    if (!hasTrueCustoms && Object.keys(initialRouteColourMapForTools).every(key => !globalCustomRouteColours[key.toUpperCase()])) { noCustomColoursMessage.textContent = 'No global custom colours. Using initial defaults or system default.'; noCustomColoursMessage.style.display = 'block'; }
    else noCustomColoursMessage.style.display = 'none';
    const allDisplayableGlobalRoutes = [...new Set([...Object.keys(initialRouteColourMapForTools).map(k=>k.toUpperCase()), ...Object.keys(globalCustomRouteColours).map(k=>k.toUpperCase())])].sort(compareLineNames);
    allDisplayableGlobalRoutes.forEach(rName => {
        const isCustom = globalCustomRouteColours.hasOwnProperty(rName); const color = globalCustomRouteColours[rName] || initialRouteColourMapForTools[rName] || DEFAULT_ROUTE_COLOUR_TOOLS;
        const li = document.createElement('li'); li.style.display='flex'; li.style.alignItems='center'; li.style.justifyContent='space-between';
        const box = document.createElement('span'); box.className='colour-preview-box'; box.style.backgroundColor=color;
        const info = document.createElement('span'); info.className='route-info';
        let statusText = isCustom ? "" : ` <small style="opacity:0.7;">(Initial Default)</small>`; if (!isCustom && !initialRouteColourMapForTools[rName]) statusText = ` <small style="opacity:0.7;">(System Default)</small>`;
        info.innerHTML = `Route: ${rName} - Colour: ${color.toUpperCase()}${statusText}`;
        const actions = document.createElement('div');
        if (isCustom) { const btn=document.createElement('button'); btn.textContent='Remove Global'; btn.classList.add('button','small-action','secondary'); btn.addEventListener('click',()=>handleRemoveGlobalRouteColour(rName)); actions.appendChild(btn); }
        li.appendChild(box); li.appendChild(info); li.appendChild(actions); currentRouteColoursList.appendChild(li);
    });
}
function populateRouteSelectorForColours() {
    if (!selectRouteNameColour) return;
    const currentVal = selectRouteNameColour.value;
    selectRouteNameColour.innerHTML = '<option value="">-- Select Route --</option>';
    const lines = [...new Set(currentWorkingSchedule.map(e => e.lineName))]
                  .filter(Boolean) // Ensure no null/empty routes
                  .sort(compareLineNames);
    lines.forEach(ln => {
        const opt = document.createElement('option');
        opt.value = ln; opt.textContent = ln;
        selectRouteNameColour.appendChild(opt);
    });
    if (lines.includes(currentVal)) {
        selectRouteNameColour.value = currentVal;
    }
    selectRouteNameColour.dispatchEvent(new Event('change')); // Trigger color update for input
}

function handleSaveGlobalRouteColour() {
    if (!currentUser) return; if (!selectRouteNameColour || !inputRouteColour || !routeColourStatusMessage) return;
    const rName = selectRouteNameColour.value; const color = inputRouteColour.value;
    if (!rName) { routeColourStatusMessage.textContent = 'Select route.'; routeColourStatusMessage.style.color = '#e74c3c'; return; }
    if (!color.match(/^#[0-9a-fA-F]{6}$/)) { routeColourStatusMessage.textContent = 'Invalid hex (e.g., #RRGGBB).'; routeColourStatusMessage.style.color = '#e74c3c'; return; }
    globalCustomRouteColours[rName.toUpperCase()] = color.toUpperCase(); saveGlobalCustomRouteColours();
}
function handleRemoveGlobalRouteColour(key) {
    if (!currentUser) return; if (globalCustomRouteColours.hasOwnProperty(key) && confirm(`Remove GLOBAL custom colour for ${key}?`)) {
        delete globalCustomRouteColours[key]; saveGlobalCustomRouteColours();
        // If the removed route was selected, reset its color input to default
        if (selectRouteNameColour.value.toUpperCase() === key) {
            inputRouteColour.value = initialRouteColourMapForTools[key] || DEFAULT_ROUTE_COLOUR_TOOLS;
        }
    }
}

// --- START: Stop-Specific Route Colour Functions ---
function populateStopSelectorForSpecificColours() {
    if (!selectStopForSpecificRouteColour) return; const currentVal = selectStopForSpecificRouteColour.value;
    selectStopForSpecificRouteColour.innerHTML = '<option value="">-- Select Stop --</option>';
    const uniqueStops = getUniqueStopsFromSchedule(); // Assumes this helper is defined
    if (uniqueStops.length === 0) {
        selectStopForSpecificRouteColour.innerHTML = '<option value="">-- No Stops in Schedule --</option>';
        displayRoutesForSpecificColouring(); // This will show placeholder for routes
        return;
    }
    uniqueStops.forEach(stop => {
        const opt=document.createElement('option');
        opt.value=stop.stopID; opt.textContent=`${stop.stopName} (${stop.stopID})`;
        selectStopForSpecificRouteColour.appendChild(opt);
    });
    if (uniqueStops.find(s => s.stopID === currentVal)) {
        selectStopForSpecificRouteColour.value = currentVal;
    }
    displayRoutesForSpecificColouring(); // Display routes for current/new selection
}

function displayRoutesForSpecificColouring() {
    if (!specificRouteColourTilesContainer || !specificRouteColourTilesPlaceholder) return;
    if (deleteRouteFromStopButton) deleteRouteFromStopButton.style.display = 'none'; // Hide delete button by default
    if (deleteRouteFromStopStatusMessage) deleteRouteFromStopStatusMessage.textContent = ''; // Clear status

    const selectedStopID = selectStopForSpecificRouteColour.value;
    specificRouteColourTilesContainer.innerHTML = ''; // Clear previous tiles

    if (!selectedStopID) {
        specificRouteColourTilesPlaceholder.textContent = 'Select a stop to see its routes.';
        specificRouteColourTilesPlaceholder.style.display = 'block';
        return;
    }

    const servingRoutes = new Set();
    currentWorkingSchedule.forEach(e => {
        if (e.stopID === selectedStopID && e.lineName) servingRoutes.add(e.lineName);
    });
    const sortedRoutes = Array.from(servingRoutes).sort(compareLineNames);

    if (sortedRoutes.length === 0) {
        specificRouteColourTilesPlaceholder.textContent = `No routes found serving stop ${selectedStopID}.`;
        specificRouteColourTilesPlaceholder.style.display = 'block';
    } else {
        specificRouteColourTilesPlaceholder.style.display = 'none';
        sortedRoutes.forEach(lineName => {
            const tile = document.createElement('span');
            tile.classList.add('route-tile-tools-list', 'specific-colour-route-tile');
            tile.textContent=lineName; tile.dataset.lineName=lineName;
            const bgColor = getRouteTileColourForTools(lineName, selectedStopID); // Uses effective color
            tile.style.backgroundColor=bgColor;
            tile.style.color=getTextColourForBackgroundTools(bgColor);
            tile.setAttribute('role','checkbox'); tile.setAttribute('aria-checked','false'); tile.setAttribute('tabindex','0');

            tile.addEventListener('click', () => {
                const isSelected = tile.classList.toggle('selected-for-color-edit');
                tile.setAttribute('aria-checked',isSelected.toString());
                // Show/hide delete button based on selection count
                const selTiles = specificRouteColourTilesContainer.querySelectorAll('.specific-colour-route-tile.selected-for-color-edit');
                if (deleteRouteFromStopButton) {
                    if(selTiles.length===1){ // Only show if exactly one tile is selected
                        deleteRouteFromStopButton.style.display='inline-block';
                        deleteRouteFromStopButton.dataset.selectedRouteName=selTiles[0].dataset.lineName;
                    } else {
                        deleteRouteFromStopButton.style.display='none';
                        delete deleteRouteFromStopButton.dataset.selectedRouteName;
                    }
                }
                if (deleteRouteFromStopStatusMessage) deleteRouteFromStopStatusMessage.textContent = ''; // Clear status on selection change
            });
            tile.addEventListener('keydown', (event) => { if (event.key===' '||event.key==='Enter'){event.preventDefault(); tile.click();}});
            specificRouteColourTilesContainer.appendChild(tile);
        });
    }
}

function handleDeleteRouteFromSpecificStop() {
    if (!currentUser) { alert("Log in."); if(deleteRouteFromStopStatusMessage) deleteRouteFromStopStatusMessage.textContent="Not logged in."; return; }
    const selectedStopID = selectStopForSpecificRouteColour.value;
    const lineNameToDelete = deleteRouteFromStopButton.dataset.selectedRouteName; // Get from button's data attribute

    if (!selectedStopID || !lineNameToDelete) {
        if(deleteRouteFromStopStatusMessage){
            deleteRouteFromStopStatusMessage.textContent="No stop/route selected (ensure exactly one route tile is selected for deletion).";
            deleteRouteFromStopStatusMessage.style.color='#f1c40f';
        }
        return;
    }

    if (!confirm(`Are you sure you want to delete ALL schedule entries for route "${lineNameToDelete}" ONLY from stop "${selectedStopID}"?\nThis will also remove any specific colour override for this route at this stop.\nThis action CANNOT BE UNDONE easily.`)) {
        if(deleteRouteFromStopStatusMessage){ deleteRouteFromStopStatusMessage.textContent="Deletion cancelled."; deleteRouteFromStopStatusMessage.style.color='#7f8c8d'; }
        return;
    }

    let originalScheduleLength = currentWorkingSchedule.length;
    // Filter out entries matching the stop and route
    currentWorkingSchedule = currentWorkingSchedule.filter(e => !(e.stopID === selectedStopID && e.lineName && e.lineName.toUpperCase() === lineNameToDelete.toUpperCase()));
    let scheduleEntriesRemovedCount = originalScheduleLength - currentWorkingSchedule.length;
    let colourOverrideRemoved = false;

    // Remove specific color override if it exists
    if (stopSpecificRouteColours[selectedStopID] && stopSpecificRouteColours[selectedStopID][lineNameToDelete.toUpperCase()]) {
        delete stopSpecificRouteColours[selectedStopID][lineNameToDelete.toUpperCase()];
        colourOverrideRemoved = true;
        // If this stop no longer has any specific overrides, remove the stop key itself
        if (Object.keys(stopSpecificRouteColours[selectedStopID]).length === 0) {
            delete stopSpecificRouteColours[selectedStopID];
        }
        saveStopSpecificRouteColoursToFirebase(); // Save changes to Firebase
    }

    if (deleteRouteFromStopStatusMessage) {
        deleteRouteFromStopStatusMessage.textContent = `Route "${lineNameToDelete}" deleted from stop "${selectedStopID}". ${scheduleEntriesRemovedCount} schedule entries removed. ${colourOverrideRemoved?'Specific colour override also removed.':''}`;
        deleteRouteFromStopStatusMessage.style.color = '#2ecc71';
    }

    // Reset delete button state and refresh UI
    if(deleteRouteFromStopButton) {
        deleteRouteFromStopButton.style.display = 'none';
        delete deleteRouteFromStopButton.dataset.selectedRouteName;
    }
    displayRoutesForSpecificColouring(); // Refresh route tiles for the current stop
    renderUIDependentElements();         // General UI refresh
    updateStagingStatusDisplay();        // Update Firebase staging status
}

function handleSaveStopSpecificRouteColour() {
    if (!currentUser) { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent="Not logged in.";stopSpecificRouteColourStatusMessage.style.color='#e74c3c';} return; }
    const selectedStopID = selectStopForSpecificRouteColour.value;
    if (!selectedStopID) { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent="Select stop.";stopSpecificRouteColourStatusMessage.style.color='#f1c40f';} return; }

    const selectedTiles = specificRouteColourTilesContainer.querySelectorAll('.specific-colour-route-tile.selected-for-color-edit');
    if (selectedTiles.length === 0) { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent="Select route tile(s) to apply colour.";stopSpecificRouteColourStatusMessage.style.color='#f1c40f';} return; }

    const newColour = inputStopSpecificRouteColour.value;
    if (!newColour.match(/^#[0-9a-fA-F]{6}$/)) { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent='Invalid hex colour (e.g., #RRGGBB).';stopSpecificRouteColourStatusMessage.style.color='#e74c3c';} return; }

    if (!stopSpecificRouteColours[selectedStopID]) stopSpecificRouteColours[selectedStopID] = {}; // Initialize if stop not present

    let routesUpdated = [];
    selectedTiles.forEach(tile => {
        const lineName = tile.dataset.lineName;
        if(lineName){
            stopSpecificRouteColours[selectedStopID][lineName.toUpperCase()]=newColour.toUpperCase(); // Save with uppercase keys
            routesUpdated.push(lineName);
        }
    });

    if (routesUpdated.length > 0) {
        saveStopSpecificRouteColoursToFirebase(); // Save to Firebase
        // Deselect tiles after applying color
        selectedTiles.forEach(tile => tile.classList.remove('selected-for-color-edit'));

        // Reset delete button state as selection changed
        const stillSelTiles = specificRouteColourTilesContainer.querySelectorAll('.specific-colour-route-tile.selected-for-color-edit'); // Should be 0
        if(deleteRouteFromStopButton){
            if(stillSelTiles.length===1){
                deleteRouteFromStopButton.style.display='inline-block';
                deleteRouteFromStopButton.dataset.selectedRouteName=stillSelTiles[0].dataset.lineName;
            } else {
                deleteRouteFromStopButton.style.display='none';
                delete deleteRouteFromStopButton.dataset.selectedRouteName;
            }
        }
         if(stopSpecificRouteColourStatusMessage) {
            stopSpecificRouteColourStatusMessage.textContent = `Colour ${newColour} applied to ${routesUpdated.join(', ')} at stop ${selectedStopID}.`;
            stopSpecificRouteColourStatusMessage.style.color = '#2ecc71';
        }
    } else {
        if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent="No routes were selected or updated.";stopSpecificRouteColourStatusMessage.style.color='#e74c3c';}
    }
}

function renderStopSpecificRouteColours() {
    if (!currentStopSpecificColoursList || !noStopSpecificColoursMessageEl) return; currentStopSpecificColoursList.innerHTML = '';
    const stopIDsWithOverrides = Object.keys(stopSpecificRouteColours).filter(stopID => stopSpecificRouteColours[stopID] && Object.keys(stopSpecificRouteColours[stopID]).length > 0)
        .sort((a,b)=>{ // Sort by stop name for display
            const stopA=getUniqueStopsFromSchedule().find(s=>s.stopID===a);
            const stopB=getUniqueStopsFromSchedule().find(s=>s.stopID===b);
            const nameA=stopA?stopA.stopName.toLowerCase():a.toLowerCase();
            const nameB=stopB?stopB.stopName.toLowerCase():b.toLowerCase();
            if(nameA<nameB)return -1; if(nameA>nameB)return 1; return 0;
        });

    if (stopIDsWithOverrides.length === 0) {
        noStopSpecificColoursMessageEl.textContent = 'No stop-specific colour overrides are currently set.';
        noStopSpecificColoursMessageEl.style.display = 'block'; return;
    }
    noStopSpecificColoursMessageEl.style.display = 'none';

    stopIDsWithOverrides.forEach(stopID => {
        const stopDetails = getUniqueStopsFromSchedule().find(s => s.stopID === stopID);
        const stopDisplayName = stopDetails ? `${stopDetails.stopName} (${stopID})` : stopID;

        const stopGroupTitle = document.createElement('h4');
        stopGroupTitle.className='stop-group-title'; stopGroupTitle.textContent=`Stop: ${stopDisplayName}`;
        currentStopSpecificColoursList.appendChild(stopGroupTitle);

        const routesListUl = document.createElement('ul');
        const routesForThisStop = stopSpecificRouteColours[stopID];
        Object.keys(routesForThisStop).sort(compareLineNames).forEach(lineName => {
            const color = routesForThisStop[lineName];
            const li = document.createElement('li');
            li.style.display='flex'; li.style.alignItems='center'; li.style.justifyContent='space-between';

            const box = document.createElement('span'); box.className='colour-preview-box'; box.style.backgroundColor=color;
            const info = document.createElement('span'); info.className='route-info';
            info.textContent=`Route: ${lineName} - Colour: ${color.toUpperCase()}`;

            const actions = document.createElement('div');
            const removeBtn = document.createElement('button');
            removeBtn.textContent='Remove Override'; removeBtn.classList.add('button','small-action','secondary');
            removeBtn.addEventListener('click', () => handleRemoveStopSpecificRouteColour(stopID, lineName));
            actions.appendChild(removeBtn);

            li.appendChild(box); li.appendChild(info); li.appendChild(actions);
            routesListUl.appendChild(li);
        });
        currentStopSpecificColoursList.appendChild(routesListUl);
    });
}

function handleRemoveStopSpecificRouteColour(stopID, lineName) {
    if (!currentUser) return;
    if (stopSpecificRouteColours[stopID] && stopSpecificRouteColours[stopID][lineName]) {
        if (confirm(`Remove specific colour override for route ${lineName} at stop ${stopID}?`)) {
            delete stopSpecificRouteColours[stopID][lineName];
            // If the stop no longer has any overrides, remove the stop key
            if (Object.keys(stopSpecificRouteColours[stopID]).length === 0) {
                delete stopSpecificRouteColours[stopID];
            }
            saveStopSpecificRouteColoursToFirebase(); // This will also re-render the list
        }
    }
}
// --- END: Stop-Specific Route Colour Functions ---

// --- START: Global Route Deletion Functions ---
function populateGlobalRouteToDeleteSelector() {
    if (!selectGlobalRouteToDelete) return; const currentVal = selectGlobalRouteToDelete.value;
    selectGlobalRouteToDelete.innerHTML = '<option value="">-- Select Route --</option>';
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        selectGlobalRouteToDelete.innerHTML = '<option value="">-- No Routes in Schedule --</option>'; return;
    }
    const uniqueRoutes = [...new Set(currentWorkingSchedule.map(e => e.lineName).filter(Boolean))].sort(compareLineNames);
    if (uniqueRoutes.length === 0) {
        selectGlobalRouteToDelete.innerHTML = '<option value="">-- No Valid Routes Found --</option>';
    } else {
        uniqueRoutes.forEach(ln => {
            const opt=document.createElement('option'); opt.value=ln; opt.textContent=ln;
            selectGlobalRouteToDelete.appendChild(opt);
        });
        if (uniqueRoutes.includes(currentVal)) selectGlobalRouteToDelete.value = currentVal;
    }
}

function handleDeleteEntireRouteGlobally() {
    if (!currentUser) { alert("Log in."); if(deleteEntireRouteStatusMessage) deleteEntireRouteStatusMessage.textContent="Not logged in."; return; }
    const lineNameToDelete = selectGlobalRouteToDelete.value;
    if (!lineNameToDelete) {
        if(deleteEntireRouteStatusMessage){ deleteEntireRouteStatusMessage.textContent="Select a route to delete."; deleteEntireRouteStatusMessage.style.color='#f1c40f';}
        return;
    }
    if (!confirm(`EXTREME CAUTION!\n\nAre you absolutely sure you want to delete ALL schedule entries for route "${lineNameToDelete}" from ALL stops?\nThis will also remove its global custom colour setting and ANY stop-specific colour overrides for this route across ALL stops.\n\nTHIS ACTION IS HIGHLY DESTRUCTIVE AND CANNOT BE EASILY UNDONE.\n\nProceed with global deletion of route "${lineNameToDelete}"?`)) {
        if(deleteEntireRouteStatusMessage){ deleteEntireRouteStatusMessage.textContent="Global deletion cancelled by user."; deleteEntireRouteStatusMessage.style.color='#7f8c8d';}
        return;
    }

    let originalScheduleLength = currentWorkingSchedule.length;
    // Remove all schedule entries for this route
    currentWorkingSchedule = currentWorkingSchedule.filter(e => !(e.lineName && e.lineName.toUpperCase() === lineNameToDelete.toUpperCase()));
    let scheduleEntriesRemovedCount = originalScheduleLength - currentWorkingSchedule.length;

    // Remove global custom colour for this route
    let globalColourRemoved = false;
    if (globalCustomRouteColours[lineNameToDelete.toUpperCase()]) {
        delete globalCustomRouteColours[lineNameToDelete.toUpperCase()];
        globalColourRemoved=true;
        saveGlobalCustomRouteColours(); // Save change
    }

    // Remove stop-specific colour overrides for this route from all stops
    let specificColoursRemovedCount = 0;
    let specificColoursNeedSave = false;
    Object.keys(stopSpecificRouteColours).forEach(stopID => {
        if (stopSpecificRouteColours[stopID] && stopSpecificRouteColours[stopID][lineNameToDelete.toUpperCase()]) {
            delete stopSpecificRouteColours[stopID][lineNameToDelete.toUpperCase()];
            specificColoursRemovedCount++;
            if(Object.keys(stopSpecificRouteColours[stopID]).length===0) delete stopSpecificRouteColours[stopID]; // Clean up empty stop objects
            specificColoursNeedSave=true;
        }
    });
    if (specificColoursNeedSave) saveStopSpecificRouteColoursToFirebase(); // Save changes if any were made

    if (deleteEntireRouteStatusMessage) {
        deleteEntireRouteStatusMessage.textContent = `Route "${lineNameToDelete}" and all its data deleted globally. ${scheduleEntriesRemovedCount} schedule entries removed. ${globalColourRemoved?'Global colour setting removed. ':''}${specificColoursRemovedCount>0?specificColoursRemovedCount+' stop-specific colour override(s) removed.':''}`;
        deleteEntireRouteStatusMessage.style.color = '#2ecc71';
    }
    selectGlobalRouteToDelete.value = ""; // Reset selector
    renderUIDependentElements(); // Refresh all UI
    updateStagingStatusDisplay(); // Update Firebase status
}
// --- END: Global Route Deletion Functions ---


function getRouteTileColourForTools(lineName, stopID = null) {
    const upName = String(lineName || "").toUpperCase();
    // Check for stop-specific override first
    if (stopID && stopSpecificRouteColours[stopID.toUpperCase()] && stopSpecificRouteColours[stopID.toUpperCase()][upName]) {
        return stopSpecificRouteColours[stopID.toUpperCase()][upName];
    }
    // Then check for global custom colour
    if (globalCustomRouteColours[upName]) {
        return globalCustomRouteColours[upName];
    }
    // Then check for initial hardcoded map (if any)
    if (initialRouteColourMapForTools[upName]) {
        return initialRouteColourMapForTools[upName];
    }
    // Fallback logic (e.g., for night buses or superloop)
    if (upName.startsWith("N")) return globalCustomRouteColours["NIGHT_DEFAULT"] || initialRouteColourMapForTools["NIGHT_DEFAULT"] || NIGHT_BUS_BLUE_COLOR; // Default night bus
    if (upName.startsWith("SL")) return globalCustomRouteColours["SL_DEFAULT"] || initialRouteColourMapForTools["SL_DEFAULT"] || "#D32F2F"; // Example for Superloop
    // Absolute default
    return DEFAULT_ROUTE_COLOUR_TOOLS;
}

function getTextColourForBackgroundTools(hex) {
    if(!hex || hex.length < 7) return '#FFFFFF'; // Default to white for invalid hex
    const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
    // Standard luminance calculation
    return ((0.299*r + 0.587*g + 0.114*b)/255) > 0.5 ? '#000000' : '#FFFFFF'; // Black text for light bg, White for dark
}

// Helper to get a sort order for OperatingProfile strings (e.g., Mon before Tue)
// --- Helper to get a sort order for OperatingProfile strings (e.g., Mon before Tue) ---
function getDaySortOrder(profile) {
    if (!profile) return 9999; // Fallback for undefined profiles

    const p = profile.toUpperCase().replace(/\s+/g, ''); // Normalize: uppercase, remove all spaces
    const has = (keywords) => keywords.some(kw => p.includes(kw));
    
    let baseScore = 9000; // Default for unclassified

    // Specific day matching
    if (has(["MONDAY", "MO"])) baseScore = 100; // Monday profiles first
    else if (has(["TUESDAY", "TU"])) baseScore = 200;
    else if (has(["WEDNESDAY", "WE"])) baseScore = 300;
    else if (has(["THURSDAY", "TH"])) baseScore = 400;
    else if (has(["FRIDAY", "FR"]) && !has(["GOODFRIDAY"])) baseScore = 500; 
    // General Weekday terms (MF, Weekday) now come after specific Friday variants
    else if (has(["MON-FRI", "MONTOFRI", "WEEKDAY", "MF"])) baseScore = 600; 
    // Weekend
    else if (has(["SATURDAY", "SA"])) baseScore = 700;
    else if (has(["SUNDAY", "SU"])) baseScore = 800;

    // Holidays and Special (higher scores)
    // Note: The sample data for the reference list no longer includes "Good Friday" or "Bank Holiday",
    // but the sorting logic for them is kept in case your actual live data has them.
    if (has(["GOODFRIDAY"])) return 850; 
    if (has(["BANKHOLIDAY", "BANKHOL"])) return 910; 
    if (has(["CHRISTMAS"])) return 920;
    if (has(["BOXINGDAY"])) return 930;
    if (has(["NEWYEAR"])) return 940;
    
    // Add sub-scores for Sch/NSD variants
    if (baseScore < 9000) { // Only apply Sch/NSD to classified days/weekday groups
        if (has(["SCH"])) return baseScore + 1;    // e.g., MoSch = 101, MFSch = 601
        if (has(["NSD"])) return baseScore + 2;    // e.g., MoNSD = 102, MFNSD = 602
        // Check for SchoolHoliday if it's part of a combined term like "Weekday,SchoolHoliday"
        // Exclude Sunday here because "Sunday,SchoolHoliday" should primarily sort as Sunday.
        if (has(["SCHOOLHOLIDAY"]) && !has(["SUNDAY","SU"])) return baseScore + 3; 
        return baseScore; // Base day/group if no Sch/NSD/SchoolHoliday variant
    }
    
    // If it's a general "SchoolHoliday" not tied to a specific day type yet
    if (has(["SCHOOLHOLIDAY"])) return 950;

    // For comma-separated terms like "Sa,Su" - take the earliest day's score
    if (profile.includes(',')) {
        const parts = profile.split(',');
        let minScoreForParts = 9999;
        for (const part of parts) {
            minScoreForParts = Math.min(minScoreForParts, getDaySortOrder(part.trim())); // Recursive call for parts
        }
        return minScoreForParts; // Use the lowest score found among parts
    }

    return baseScore; // Return the determined score or fallback
}

function populateStopSelectorForDeparturesView() {
    if (!selectStopForDeparturesView) return;
    const currentVal = selectStopForDeparturesView.value;
    selectStopForDeparturesView.innerHTML = '<option value="">-- Select Stop --</option>';

    if (currentWorkingSchedule.length === 0) {
        selectStopForDeparturesView.innerHTML = '<option value="">-- No Stops Loaded --</option>';
        displayDeparturesForSelectedStop(); // This will show a message
        return;
    }

    const stopsMap = new Map();
    currentWorkingSchedule.forEach(e => {
        if (e.stopID && !stopsMap.has(e.stopID.toUpperCase())) {
            stopsMap.set(e.stopID.toUpperCase(), { stopID: e.stopID, stopName: e.stopName || e.stopID });
        }
    });
    const sorted = Array.from(stopsMap.values()).sort((a,b)=>(a.stopName.toLowerCase()).localeCompare(b.stopName.toLowerCase()));

    sorted.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s.stopID; opt.textContent = `${s.stopName} (${s.stopID})`;
        selectStopForDeparturesView.appendChild(opt);
    });

    if (stopsMap.has(currentVal.toUpperCase())) {
        selectStopForDeparturesView.value = currentVal;
    }
    displayDeparturesForSelectedStop(); // Refresh departures for the selected/default stop
}

function displayDeparturesForSelectedStop() {
    if (!selectStopForDeparturesView || !stopDeparturesList || !noDeparturesForStopMessage) return;
    const selStopID = selectStopForDeparturesView.value;
    stopDeparturesList.innerHTML = ''; // Clear previous departures

    if (!selStopID) {
        noDeparturesForStopMessage.textContent = 'Select a stop to view its scheduled departures.';
        noDeparturesForStopMessage.style.display = 'block';
        return;
    }

    const deps = currentWorkingSchedule.filter(e => e.stopID === selStopID).sort((a,b) => {
        const offsetA=parseInt(a.DayOffset||"0",10); const offsetB=parseInt(b.DayOffset||"0",10);
        if(offsetA!==offsetB)return offsetA-offsetB; // Sort by DayOffset first

        const dayA=getDaySortOrder(a.OperatingProfile); const dayB=getDaySortOrder(b.OperatingProfile);
        if(dayA!==dayB)return dayA-dayB; // Then by operating profile day order

        const timeA=(a.scheduledTime||"99:99").replace(':',''); // HHMM format for sort
        const timeB=(b.scheduledTime||"99:99").replace(':','');
        if(timeA!==timeB)return timeA.localeCompare(timeB); // Then by time

        const lineComp=compareLineNames(a.lineName,b.lineName); // Then by Line Name
        if(lineComp!==0)return lineComp;

        return (a.OperatingProfile||"").localeCompare(b.OperatingProfile||""); // Finally by full profile string
    });

    if (deps.length === 0) {
        noDeparturesForStopMessage.textContent = 'No scheduled departures found for this stop in the current working schedule.';
        noDeparturesForStopMessage.style.display = 'block';
    } else {
        noDeparturesForStopMessage.style.display = 'none';
        deps.forEach(d => {
            const li=document.createElement('li');
            const tile=document.createElement('span');
            tile.className='route-tile-tools-list'; // Use existing class for route tiles
            tile.textContent=d.lineName||'N/A';
            const bg=getRouteTileColourForTools(d.lineName,selStopID); // Use effective color
            tile.style.backgroundColor=bg; tile.style.color=getTextColourForBackgroundTools(bg);

            const span=document.createElement('span');
            span.innerHTML=` to ${d.destinationName||'Unknown Destination'} <strong style="margin-left:0.5em;">at ${d.scheduledTime||'N/A'}</strong> <small style="opacity:0.7;margin-left:0.75em;">(Profile: ${d.OperatingProfile||'N/A'})</small>${d.DayOffset&&d.DayOffset!=="0"?`<small style="opacity:0.7;margin-left:0.3em;color:#FFD700;">(+${d.DayOffset}d)</small>`:''}`;

            li.appendChild(tile); li.appendChild(span);
            stopDeparturesList.appendChild(li);
        });
    }
}


// --- Stop Management Tool Functions ---
function getUniqueStopsFromSchedule() { // Helper used by many functions
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) return [];
    const stopsMap = new Map();
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && !stopsMap.has(entry.stopID.toUpperCase())) { // Use uppercase for map key consistency
            stopsMap.set(entry.stopID.toUpperCase(), {
                stopID: entry.stopID,
                stopName: entry.stopName || "Unknown Name", // Default if name is missing
                direction: entry.direction || "No Direction"  // Default if direction is missing
            });
        }
    });
    // Sort by stop name for consistent dropdown population elsewhere
    return Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase()));
}


function populateMasterStopList_SM() {
    if (!masterStopListUL_SM || !masterStopListStatus_SM) return;
    uniqueStopsMasterList_SM = getUniqueStopsFromSchedule(); // Get fresh list
    const filterText = masterStopListFilterInput_SM.value.toLowerCase().trim();
    masterStopListUL_SM.innerHTML = ''; // Clear previous list
    let displayedCount = 0;

    // Define Night Bus color once for efficiency inside the loop if it's a constant lookup
    const NIGHT_BUS_BLUE_COLOR_CONST = (globalCustomRouteColours["NIGHT_DEFAULT"] || initialRouteColourMapForTools["NIGHT_DEFAULT"] || NIGHT_BUS_BLUE_COLOR || "#4CDBE6").toUpperCase();

    if (uniqueStopsMasterList_SM.length === 0) {
        masterStopListStatus_SM.textContent = 'No unique stops found in the current working schedule.';
        return;
    }

    uniqueStopsMasterList_SM.forEach(stop => {
        if (!stop || !stop.stopID) return; // Skip if stop or stopID is invalid

        const stopIdLower=stop.stopID.toLowerCase();
        const stopNameLower=(stop.stopName||"").toLowerCase();
        const stopDirectionLower=(stop.direction||"").toLowerCase();

        // Gather details for this stop
        const servingRoutesData=new Map(); // Use a map for route details if needed later
        let earliestTimeOverall=null;
        let latestTimeOverall=null;
        let hasNightBusService=false;
        let hasDayBusService=false;

        currentWorkingSchedule.forEach(entry => {
            if (entry.stopID===stop.stopID) {
                if (entry.lineName) {
                    if(!servingRoutesData.has(entry.lineName)) servingRoutesData.set(entry.lineName,{}); // Store route if not already
                    const tileColor = getRouteTileColourForTools(entry.lineName,stop.stopID).toUpperCase();
                    if(tileColor===NIGHT_BUS_BLUE_COLOR_CONST) hasNightBusService=true;
                    if(tileColor!==NIGHT_BUS_BLUE_COLOR_CONST) hasDayBusService=true; // Any non-night bus color means day service
                }
                // Determine earliest/latest times including day offset
                if (entry.scheduledTime) {
                    const entryTimeNumeric=parseInt((entry.scheduledTime||"99:99").replace(":",""),10);
                    const entryDayOffset=parseInt(entry.DayOffset||"0",10);
                    const comparableTime=(entryDayOffset*2400)+entryTimeNumeric; // For easy comparison
                    if(earliestTimeOverall===null||comparableTime<earliestTimeOverall.comparable){
                        earliestTimeOverall={time:entry.scheduledTime,dayOffset:entryDayOffset,comparable:comparableTime};
                    }
                    if(latestTimeOverall===null||comparableTime>latestTimeOverall.comparable){
                        latestTimeOverall={time:entry.scheduledTime,dayOffset:entryDayOffset,comparable:comparableTime};
                    }
                }
            }
        });
        const sortedServingRouteNames = Array.from(servingRoutesData.keys()).sort(compareLineNames);
        const isClosed = closedStopIDs.includes(stop.stopID.toUpperCase());
        const closureStatus = isClosed ? "Closed" : "Open";
        const is24HourStop = hasNightBusService && hasDayBusService; // True if both types of services are present

        // Filter logic
        const matchesFilter = !filterText || // No filter means show all
                              stopIdLower.includes(filterText) ||
                              stopNameLower.includes(filterText) ||
                              stopDirectionLower.includes(filterText) ||
                              sortedServingRouteNames.some(rn=>rn.toLowerCase().includes(filterText)) ||
                              closureStatus.toLowerCase().includes(filterText) ||
                              (is24HourStop && ("24 hours".includes(filterText) || "24hr".includes(filterText)));


        if (matchesFilter) {
            displayedCount++;
            const li = document.createElement('li');
            li.dataset.stopid = stop.stopID; // Store stopID for actions

            // Main stop info
            let content = `<span class="stop-name-master">${stop.stopName}</span><br>
                           <span class="stop-direction-master">Towards: ${stop.direction}</span><br>
                           <span class="stop-id-master">Stop ID: ${stop.stopID}</span><br>`;

            // Serving routes
            if (sortedServingRouteNames.length > 0) {
                content += `<div class="serving-routes-container">`;
                sortedServingRouteNames.forEach(lineName => {
                    const bgColor=getRouteTileColourForTools(lineName,stop.stopID);
                    const textColor=getTextColourForBackgroundTools(bgColor);
                    content += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor};">${lineName}</span>`;
                });
                content += `</div>`;
            } else {
                content += `<div class="serving-routes-container"><span style="font-size:0.8em;opacity:0.7;">No routes currently scheduled for this stop.</span></div>`;
            }

            // Details grid (Status, Service Type, Times)
            content += `<div class="stop-details-grid">`;
            content += `<span class="detail-label">Status:</span> <span class="detail-value status-${closureStatus.toLowerCase()}">${closureStatus}</span>`;

            if (is24HourStop) {
                content += `<span class="detail-label">Service:</span> <span class="detail-value" style="color:${NIGHT_BUS_BLUE_COLOR_CONST};font-weight:bold;">24 Hours</span>`;
                content += `<span class="detail-label">First Bus:</span> <span class="detail-value">-</span>`; // Not typically shown for 24hr
                content += `<span class="detail-label">Last Bus:</span> <span class="detail-value">-</span>`;
            } else {
                let firstBusText = earliestTimeOverall?earliestTimeOverall.time+(earliestTimeOverall.dayOffset>0?` (+${earliestTimeOverall.dayOffset}d)`:''):"N/A";
                let lastBusText = latestTimeOverall?latestTimeOverall.time+(latestTimeOverall.dayOffset>0?` (+${latestTimeOverall.dayOffset}d)`:''):"N/A";
                content += `<span class="detail-label">First Bus (approx):</span> <span class="detail-value">${firstBusText}</span>`;
                content += `<span class="detail-label">Last Bus (approx):</span> <span class="detail-value">${lastBusText}</span>`;
            }
            content += `</div>`; // End of stop-details-grid
            li.innerHTML = content;

            // Action buttons
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'stop-actions';

            const editBtn = document.createElement('button');
            editBtn.className = 'button small-action'; editBtn.textContent = 'Edit Details'; // More descriptive
            editBtn.addEventListener('click', () => handleEditStop_SM(stop.stopID, stop.stopName, stop.direction));
            actionsDiv.appendChild(editBtn);

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'button small-action secondary'; deleteBtn.textContent = 'Delete Stop'; // More descriptive
            deleteBtn.addEventListener('click', () => handleDeleteStop_SM(stop.stopID));
            actionsDiv.appendChild(deleteBtn);

            const toggleBtn = document.createElement('button');
            toggleBtn.className = `button small-action ${isClosed ? "tertiary" : "secondary"}`; // Use tertiary for "Reopen"
            toggleBtn.textContent = isClosed ? "Reopen Stop" : "Close Stop";
            toggleBtn.addEventListener('click', () => handleToggleStopStatus_SM(stop.stopID));
            actionsDiv.appendChild(toggleBtn);

            li.appendChild(actionsDiv);
            masterStopListUL_SM.appendChild(li);
        }
    });

    // Update status message
    if (displayedCount === 0 && uniqueStopsMasterList_SM.length > 0 && filterText) {
        masterStopListStatus_SM.textContent = 'No stops match the current filter.';
    } else if (uniqueStopsMasterList_SM.length > 0) {
        masterStopListStatus_SM.textContent = `Showing ${displayedCount} of ${uniqueStopsMasterList_SM.length} unique stops. Filter: "${filterText||'none'}"`;
    } else {
        masterStopListStatus_SM.textContent = 'No unique stops in the current working schedule.';
    }
}


function handleEditStop_SM(stopID, currentName, currentDirection) {
    if (!currentUser) { alert("Please log in to edit stops."); return; }

    const newStopName = prompt(`Editing Stop: ${stopID}\nEnter new Stop Name (current: "${currentName}"):`, currentName);
    if (newStopName === null) { // User cancelled first prompt
        if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Edit cancelled for ${stopID}.`;
        return;
    }

    const newDirection = prompt(`Editing Stop: ${stopID}\nEnter new "Towards" text (current: "${currentDirection}"):`, currentDirection);
    if (newDirection === null) { // User cancelled second prompt
        if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Edit cancelled for ${stopID}.`;
        return;
    }

    // Check if actual changes were made
    const nameChanged = newStopName.trim() !== currentName.trim();
    const directionChanged = newDirection.trim() !== currentDirection.trim();

    if (!nameChanged && !directionChanged) {
        if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `No changes made to Stop ID "${stopID}".`;
        return;
    }

    let updatedCount = 0;
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && entry.stopID.toUpperCase() === stopID.toUpperCase()) {
            let entryChangedInLoop = false;
            if (nameChanged && newStopName.trim()) { // Update if changed and new name is not blank
                entry.stopName = newStopName.trim();
                entryChangedInLoop = true;
            }
            if (directionChanged && newDirection.trim()) { // Update if changed and new direction is not blank
                entry.direction = newDirection.trim();
                entryChangedInLoop = true;
            }
            // Handle cases where user might want to clear a name or direction (though UI usually prevents blank StopName)
            if (nameChanged && !newStopName.trim() && entry.stopName !== "") { // If new name is blank, clear existing
                entry.stopName = ""; // Or a placeholder like "Unknown Name" if preferred
                entryChangedInLoop = true;
            }
            if (directionChanged && !newDirection.trim() && entry.direction !== "") { // If new direction is blank, clear existing
                entry.direction = ""; // Or "No Direction"
                entryChangedInLoop = true;
            }
            if (entryChangedInLoop) updatedCount++;
        }
    });

    if (updatedCount > 0) {
        renderUIDependentElements(); // Refresh UI including master list
        updateStagingStatusDisplay(); // Update Firebase staging status
        if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `${updatedCount} schedule entries for Stop ID "${stopID}" updated.`;
        // No need to call populateMasterStopList_SM explicitly if renderUIDependentElements handles it or its sub-calls do.
        // However, if direct refresh is needed: setTimeout(() => populateMasterStopList_SM(), 100);
    } else {
        if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `No schedule entries found for Stop ID "${stopID}" to update, or no effective changes specified.`;
    }
}

function handleDeleteStop_SM(stopIdToRemove) {
    if (!currentUser) { alert("Please log in to delete stops."); return; }
    if (!stopIdToRemove) {
        if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = "Stop ID not provided for deletion."; return;
    }

    const stopDetails = uniqueStopsMasterList_SM.find(s => s.stopID === stopIdToRemove);
    const stopNameToConfirm = stopDetails ? `${stopDetails.stopName} (${stopIdToRemove})` : stopIdToRemove;

    if (!confirm(`ARE YOU SURE you want to remove stop "${stopNameToConfirm}" and ALL its associated schedule entries from the working schedule?\nThis action CANNOT BE UNDONE easily.`)) {
        if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Deletion of stop ${stopNameToConfirm} cancelled.`;
        return;
    }

    const initialLength = currentWorkingSchedule.length;
    // Filter out all entries for this stopID
    currentWorkingSchedule = currentWorkingSchedule.filter(entry => entry.stopID.toUpperCase() !== stopIdToRemove.toUpperCase());
    const removedCount = initialLength - currentWorkingSchedule.length;

    // Also remove from closedStopIDs if present
    const closedIndex = closedStopIDs.indexOf(stopIdToRemove.toUpperCase());
    if (closedIndex > -1) closedStopIDs.splice(closedIndex, 1);

    // Remove any stop-specific colour overrides for this stop
    if (stopSpecificRouteColours[stopIdToRemove.toUpperCase()]) {
        delete stopSpecificRouteColours[stopIdToRemove.toUpperCase()];
    }

    if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Stop "${stopNameToConfirm}" and ${removedCount} schedule entries removed.`;

    // Persist changes to closed status and specific colours
    saveClosedStopsToFirebase();
    saveStopSpecificRouteColoursToFirebase();

    renderUIDependentElements(); // Full UI refresh
    updateStagingStatusDisplay(); // Update staging status
}

function handleToggleStopStatus_SM(stopID) {
    if (!currentUser) { alert("Please log in to change stop status."); return; }
    if (!stopID) {
        if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = "Stop ID not provided for status change."; return;
    }

    const stopIdUpper = stopID.toUpperCase();
    const stopDetails = uniqueStopsMasterList_SM.find(s => s.stopID === stopID); // Find details for message
    const stopName = stopDetails ? stopDetails.stopName : stopID;

    const idx = closedStopIDs.indexOf(stopIdUpper);
    if (idx === -1) { // Stop is currently open, so close it
        closedStopIDs.push(stopIdUpper);
        if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Stop '${stopName}' (${stopID}) marked as closed.`;
    } else { // Stop is currently closed, so reopen it
        closedStopIDs.splice(idx, 1);
        if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Stop '${stopName}' (${stopID}) marked as reopened.`;
    }
    saveClosedStopsToFirebase(); // This will also call populateMasterStopList_SM
}

function handleFindReplaceStopIdInSchedule_SM() {
    if (!currentUser) { alert("Please log in to use this feature."); return; }
    const findStopID = findStopIdScheduleInput_SM.value.trim().toUpperCase();
    const replaceStopID = replaceStopIdScheduleInput_SM.value.trim().toUpperCase();

    if (!findStopID || !replaceStopID) {
        findReplaceStatusMessage_SM.textContent = "Both 'Stop ID to Find' and 'Replace with New Stop ID' are required.";
        findReplaceStatusMessage_SM.style.color = '#e74c3c'; return;
    }
    if (findStopID === replaceStopID) {
        findReplaceStatusMessage_SM.textContent = "Find and Replace Stop IDs cannot be the same.";
        findReplaceStatusMessage_SM.style.color = '#f1c40f'; return;
    }

    let newNameForReplaced = ""; let newDirectionForReplaced = "";
    let foundNewStopDetails = false;

    // Try to find an existing entry with the 'replaceStopID' to get its name/direction
    const existingNewStopEntry = currentWorkingSchedule.find(e => e.stopID.toUpperCase() === replaceStopID);
    if (existingNewStopEntry) {
        newNameForReplaced = existingNewStopEntry.stopName;
        newDirectionForReplaced = existingNewStopEntry.direction;
        foundNewStopDetails = true;
    } else {
        // If 'replaceStopID' doesn't exist, use details from the first 'findStopID' entry
        const oldStopDetails = currentWorkingSchedule.find(e => e.stopID.toUpperCase() === findStopID);
        if (oldStopDetails) {
            newNameForReplaced = oldStopDetails.stopName; // Use old name
            newDirectionForReplaced = oldStopDetails.direction; // Use old direction
            console.warn(`Details for the new Stop ID "${replaceStopID}" were not found in the schedule. Using details from the old Stop ID "${findStopID}" for replaced entries.`);
        } else {
            console.warn(`Details for both the new Stop ID "${replaceStopID}" and the old Stop ID "${findStopID}" were not found. Name/Direction for replaced entries might be blank or incorrect.`);
            // Fallback to blank if neither found, or consider prompting user
            newNameForReplaced = "Unknown Name"; // Or leave blank as per requirements
            newDirectionForReplaced = "No Direction";
        }
    }

    if (!confirm(`Are you sure you want to replace ALL occurrences of Stop ID "${findStopID}" with "${replaceStopID}" in the working schedule?\n${foundNewStopDetails ? `The Stop Name and Direction for these entries will be updated to match existing entries for "${replaceStopID}".` : (newNameForReplaced !== "Unknown Name" ? `The Stop Name and Direction will be based on "${findStopID}"'s details.` : `Stop Name and Direction may need to be reviewed manually after replacement.`)}\nThis action CANNOT BE UNDONE easily.`)) {
        findReplaceStatusMessage_SM.textContent = "Find and Replace operation cancelled by user.";
        findReplaceStatusMessage_SM.style.color = '#7f8c8d'; return;
    }

    let replacedCount = 0;
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && entry.stopID.toUpperCase() === findStopID) {
            entry.stopID = replaceStopID; // Replace the ID
            // Update name and direction based on what was determined
            entry.stopName = newNameForReplaced;
            entry.direction = newDirectionForReplaced;
            replacedCount++;
        }
    });

    if (replacedCount > 0) {
        renderUIDependentElements(); // Full UI refresh
        updateStagingStatusDisplay(); // Update Firebase status
        findReplaceStatusMessage_SM.textContent = `Replaced ${replacedCount} occurrences of "${findStopID}" with "${replaceStopID}".`;
        if (foundNewStopDetails || newNameForReplaced !== "Unknown Name") { // Give feedback on name/dir source
            findReplaceStatusMessage_SM.textContent += ` Name/Direction for these entries updated to: "${newNameForReplaced}" / "${newDirectionForReplaced}".`;
        }
        findReplaceStatusMessage_SM.style.color = '#2ecc71';
        // Clear input fields after successful operation
        findStopIdScheduleInput_SM.value='';
        replaceStopIdScheduleInput_SM.value='';
    } else {
        findReplaceStatusMessage_SM.textContent = `No occurrences of Stop ID "${findStopID}" found in the schedule.`;
        findReplaceStatusMessage_SM.style.color = '#f1c40f';
    }
}


// --- START: Functions for "Add/Remove Stop Details" section ---
function handleSuggestStopId_ARS() {
    if (!currentUser || !selectNewStopIdFormat_ARS || !inputNewStopId_ARS) return;
    const selectedFormat = selectNewStopIdFormat_ARS.value;
    const suggestedId = generateUniqueStopId(selectedFormat); // Uses the improved generator
    inputNewStopId_ARS.value = suggestedId;
    // Trigger input event to re-validate availability if there's a listener
    inputNewStopId_ARS.dispatchEvent(new Event('input', {bubbles:true, cancelable:true}));

    if (addNewStopStatus_ARS) {
        if (suggestedId && !suggestedId.includes(String(Date.now()).slice(-5))) { // Check if it's not a fallback ID
            addNewStopStatus_ARS.textContent = `Suggested unique ID: ${suggestedId}.`;
            addNewStopStatus_ARS.style.color = '#bdc3c7'; // Neutral/info color
        } else if (suggestedId) { // It's likely a fallback ID
            addNewStopStatus_ARS.textContent = `Suggested fallback ID: ${suggestedId}. Please review and ensure uniqueness.`;
            addNewStopStatus_ARS.style.color = '#f1c40f'; // Warning color
        } else { // Should not happen if generateUniqueStopId always returns something
            addNewStopStatus_ARS.textContent = 'Could not suggest a unique ID. Please enter manually.';
            addNewStopStatus_ARS.style.color = '#e74c3c'; // Error color
        }
    }
}

function handleAddStopDetails_ARS() {
    if (!currentUser) { alert("Log in to add new stop details."); return; }
    const newStopID = inputNewStopId_ARS.value.trim().toUpperCase();
    const newStopName = inputNewStopName_ARS.value.trim();
    const newStopDirection = inputNewStopDirection_ARS.value.trim();

    if (!newStopID) { addNewStopStatus_ARS.textContent = "New Stop ID is required."; addNewStopStatus_ARS.style.color = '#e74c3c'; inputNewStopId_ARS.focus(); return; }
    if (!/^[A-Z0-9]+$/.test(newStopID)) { // Basic validation for typical Stop IDs (alphanumeric uppercase)
        addNewStopStatus_ARS.textContent = "Stop ID should only contain uppercase letters and numbers."; addNewStopStatus_ARS.style.color = '#e74c3c'; inputNewStopId_ARS.focus(); return;
    }
    if (!newStopName) { addNewStopStatus_ARS.textContent = "New Stop Name is required."; addNewStopStatus_ARS.style.color = '#e74c3c'; inputNewStopName_ARS.focus(); return; }
    // Direction is optional, so no validation for blank here.

    const existingStopIDs = new Set(currentWorkingSchedule.map(e => e.stopID.toUpperCase()));
    if (existingStopIDs.has(newStopID)) {
        addNewStopStatus_ARS.textContent = `Stop ID "${newStopID}" already exists in the working schedule. Please use a unique ID.`;
        if(newStopIdAvailability_ARS){ // Update the specific availability message too
            newStopIdAvailability_ARS.textContent = 'This Stop ID already exists.';
            newStopIdAvailability_ARS.style.color = '#e74c3c';
        }
        inputNewStopId_ARS.focus(); return;
    }

    // Add a placeholder schedule entry to make the stop appear in selectors
    const placeholderEntry = {
        internalId: `${newStopID}_placeholder_${Date.now()}`, // Unique internal ID
        stopID: newStopID,
        stopName: newStopName,
        direction: newStopDirection,
        lineName: "INFO_ONLY", // Special lineName to indicate it's a definition
        destinationName: "Stop Definition Placeholder",
        scheduledTime: "00:00", // Placeholder time
        OperatingProfile: "AllDays", // Placeholder profile
        DayOffset: "0"
    };
    currentWorkingSchedule.push(placeholderEntry);
    addNewStopStatus_ARS.textContent = `Stop "${newStopID} - ${newStopName}" added with a placeholder entry. It is now available in stop selectors.`;
    addNewStopStatus_ARS.style.color = '#2ecc71';

    // Clear form fields for next entry
    inputNewStopId_ARS.value = '';
    inputNewStopName_ARS.value = '';
    inputNewStopDirection_ARS.value = '';
    if(newStopIdAvailability_ARS) newStopIdAvailability_ARS.textContent = ''; // Clear availability message
    if(selectNewStopIdFormat_ARS) selectNewStopIdFormat_ARS.selectedIndex = 0; // Reset format selector

    renderUIDependentElements(); // Refresh UI (especially stop selectors)
    updateStagingStatusDisplay(); // Update Firebase status
}

function populateStopToRemoveSelector_ARS() {
    if (!selectStopToRemove_ARS) return;
    const currentVal = selectStopToRemove_ARS.value;
    selectStopToRemove_ARS.innerHTML = '<option value="">-- Select Stop to Remove --</option>';
    const uniqueStops = getUniqueStopsFromSchedule(); // Uses the helper for sorted, unique stops
    if (uniqueStops.length === 0) {
        selectStopToRemove_ARS.innerHTML = '<option value="">-- No Stops in Schedule --</option>'; return;
    }
    uniqueStops.forEach(stop => {
        const opt=document.createElement('option');
        opt.value=stop.stopID; opt.textContent=`${stop.stopName} (${stop.stopID})`;
        selectStopToRemove_ARS.appendChild(opt);
    });
    if (uniqueStops.find(s => s.stopID === currentVal)) { // Reselect if still valid
        selectStopToRemove_ARS.value = currentVal;
    }
}

function handleRemoveStop_ARS() {
    if (!currentUser) { alert("Log in to remove stops."); return; }
    const stopIdToRemove = selectStopToRemove_ARS.value;
    if (!stopIdToRemove) {
        removeStopStatus_ARS.textContent = "Please select a stop to remove.";
        removeStopStatus_ARS.style.color = '#f1c40f'; return;
    }

    const stopDetails = getUniqueStopsFromSchedule().find(s => s.stopID === stopIdToRemove);
    const stopNameToConfirm = stopDetails ? `${stopDetails.stopName} (${stopIdToRemove})` : stopIdToRemove;

    if (!confirm(`ARE YOU SURE you want to remove stop "${stopNameToConfirm}" and ALL its associated schedule entries from the working schedule?\nThis action CANNOT BE UNDONE easily.`)) {
        removeStopStatus_ARS.textContent = "Remove operation cancelled by user.";
        removeStopStatus_ARS.style.color = '#7f8c8d'; return;
    }

    const initialLength = currentWorkingSchedule.length;
    // Filter out all entries for this stopID (case-insensitive)
    currentWorkingSchedule = currentWorkingSchedule.filter(e => e.stopID.toUpperCase() !== stopIdToRemove.toUpperCase());
    const removedCount = initialLength - currentWorkingSchedule.length;
    const stopIdUpper = stopIdToRemove.toUpperCase();

    // Also remove from closedStopIDs if present
    const closedIndex = closedStopIDs.indexOf(stopIdUpper);
    if (closedIndex > -1) closedStopIDs.splice(closedIndex, 1);

    // Remove any stop-specific colour overrides for this stop
    if (stopSpecificRouteColours[stopIdUpper]) {
        delete stopSpecificRouteColours[stopIdUpper];
    }

    removeStopStatus_ARS.textContent = `Stop "${stopNameToConfirm}" and ${removedCount} schedule entries removed. Closed status and specific colours for this stop (if any) have also been cleared.`;
    removeStopStatus_ARS.style.color = '#2ecc71';

    // Persist changes to closed status and specific colours to Firebase
    saveClosedStopsToFirebase();
    saveStopSpecificRouteColoursToFirebase();

    renderUIDependentElements(); // Full UI refresh
    updateStagingStatusDisplay(); // Update staging status
    selectStopToRemove_ARS.value = ""; // Reset the selector
}
// --- END: Functions for "Add/Remove Stop Details" section ---

// --- START: Route Stops Explorer Functions ---
function populate_rse_SelectRoute() {
    if (!rse_selectRoute) return; const currentVal = rse_selectRoute.value;
    rse_selectRoute.innerHTML = '<option value="">-- Select Route --</option>';
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        rse_selectRoute.innerHTML = '<option value="">-- No Routes in Schedule --</option>';
        displayRouteStopsExplorer(); // This will show placeholders
        return;
    }
    const uniqueRoutes = [...new Set(currentWorkingSchedule.map(e => e.lineName))].filter(Boolean).sort(compareLineNames);
    uniqueRoutes.forEach(route => {
        const opt=document.createElement('option'); opt.value=route; opt.textContent=route;
        rse_selectRoute.appendChild(opt);
    });
    if (uniqueRoutes.includes(currentVal)) rse_selectRoute.value = currentVal;
    // Do not automatically call displayRouteStopsExplorer here; let the change event on the select do it.
}


function displayRouteStopsExplorer() {
    if (!rse_selectRoute || !rse_direction1_title || !rse_direction1_stopsList || !rse_direction1_placeholder || !rse_direction2_title || !rse_direction2_stopsList || !rse_direction2_placeholder || !rse_statusMessage) {
        console.error("Route Stops Explorer UI elements missing. Cannot display.");
        return;
    }
    const selectedRoute = rse_selectRoute.value;

    // Reset display
    rse_direction1_title.textContent = "Direction 1: (Select Route)";
    rse_direction1_stopsList.innerHTML = "";
    rse_direction1_placeholder.style.display = 'block';
    rse_direction1_placeholder.textContent = "Select a route to view stops.";
    rse_direction2_title.textContent = "Direction 2: (Select Route)";
    rse_direction2_stopsList.innerHTML = "";
    rse_direction2_placeholder.style.display = 'block';
    rse_direction2_placeholder.textContent = "Select a route to view stops.";
    if (rse_statusMessage) rse_statusMessage.textContent = "";
    if (rse_direction1_container) rse_direction1_container.style.display = 'none'; // Hide column by default
    if (rse_direction2_container) rse_direction2_container.style.display = 'none'; // Hide column by default


    if (!selectedRoute) return; // No route selected

    const routeEntries = currentWorkingSchedule.filter(e => e.lineName === selectedRoute);
    if (routeEntries.length === 0) {
        if (rse_statusMessage) rse_statusMessage.textContent = `No schedule data found for route ${selectedRoute}.`;
        rse_direction1_placeholder.textContent = `No data for route ${selectedRoute}.`;
        rse_direction2_placeholder.textContent = `No data for route ${selectedRoute}.`;
        if (rse_direction1_container) rse_direction1_container.style.display = 'block'; // Show placeholder area
        if (rse_direction2_container) rse_direction2_container.style.display = 'block'; // Show placeholder area

        return;
    }

    // Improved logic to find up to two primary destinations based on significance (number of unique stops served)
    let direction1Name = null;
    let direction2Name = null;
    const uniqueDestinationNamesForRoute = [...new Set(routeEntries.map(e => e.destinationName).filter(Boolean))];

    if (uniqueDestinationNamesForRoute.length > 0) {
        const destSignificance = uniqueDestinationNamesForRoute.map(destName => {
            const entriesForThisDest = routeEntries.filter(e => e.destinationName === destName);
            const uniqueStopsForThisDest = new Set(entriesForThisDest.map(e => e.stopID));
            return { name: destName, stopCount: uniqueStopsForThisDest.size, firstEntryTime: Math.min(...entriesForThisDest.map(e => parseInt((e.scheduledTime||"99:99").replace(':',''),10))) };
        }).sort((a, b) => {
            if (b.stopCount !== a.stopCount) return b.stopCount - a.stopCount; // Primary sort: more stops = more significant
            if (a.firstEntryTime !== b.firstEntryTime) return a.firstEntryTime - b.firstEntryTime; // Secondary: earlier start time
            return String(a.name).toLowerCase().localeCompare(String(b.name).toLowerCase()); // Tertiary: alphabetical
        });

        if (destSignificance.length > 0) {
            direction1Name = destSignificance[0].name;
        }
        if (destSignificance.length > 1) {
            direction2Name = destSignificance[1].name;
            // Ensure direction2Name is somewhat distinct if possible, primitive check
            if (direction1Name && direction2Name && destSignificance[0].stopCount === destSignificance[1].stopCount && direction1Name.startsWith(direction2Name) || direction2Name.startsWith(direction1Name)) {
                if (destSignificance.length > 2) direction2Name = destSignificance[2].name; // Try third if first two are too similar
            }
        }
    }
    
    console.log(`RSE_DEBUG: For route '${selectedRoute}', identified Dir1: '${direction1Name}', Dir2: '${direction2Name}'`);


    if (!direction1Name && !direction2Name) {
        if (rse_statusMessage) rse_statusMessage.textContent = `Route ${selectedRoute} has no clearly defined destinations in the schedule to determine directions.`;
        rse_direction1_placeholder.textContent = `No primary destinations identifiable for ${selectedRoute}.`;
        if (rse_direction1_container) rse_direction1_container.style.display = 'block';
        return;
    }
    
    // Helper to get and sort stops for a given destination (this should represent the full journey to that destination)
    function getStopsForDirection(destinationName) {
        if (!destinationName) return [];
        // Filter for entries explicitly going to this destinationName
        const directionEntries = routeEntries.filter(e => e.destinationName === destinationName);
        if (directionEntries.length === 0) return [];

        const stopTimes = new Map(); 
        directionEntries.forEach(entry => {
            const stopID = entry.stopID;
            const stopName = entry.stopName || stopID;
            const timeParts = (entry.scheduledTime || "00:00").split(':');
            const hours = parseInt(timeParts[0], 10);
            const minutes = parseInt(timeParts[1], 10);
            const dayOffset = parseInt(entry.DayOffset || "0", 10);
            const comparableTime = (dayOffset * 1440) + (hours * 60) + minutes;

            if (!stopTimes.has(stopID) || comparableTime < stopTimes.get(stopID).earliestTime) {
                stopTimes.set(stopID, { stopName: stopName, stopID: stopID, earliestTime: comparableTime });
            }
        });
        return Array.from(stopTimes.values()).sort((a, b) => a.earliestTime - b.earliestTime);
    }

    // Populate Direction 1
    if (direction1Name) {
        if (rse_direction1_container) rse_direction1_container.style.display = 'block';
        rse_direction1_title.textContent = `Direction: Towards ${direction1Name}`;
        const stops1 = getStopsForDirection(direction1Name);
        if (stops1.length > 0) {
            rse_direction1_placeholder.style.display = 'none';
            stops1.forEach((s, index) => { // Added index for numbering
                const li = document.createElement('li');
                // Added numbering
                li.innerHTML = `<span class="stop-number">${index + 1}. </span><span class="stop-name">${s.stopName}</span> <span class="stop-id">(${s.stopID})</span>`;
                rse_direction1_stopsList.appendChild(li);
            });
        } else {
            rse_direction1_placeholder.textContent = `No stops found for direction: ${direction1Name}.`;
            rse_direction1_placeholder.style.display = 'block';
        }
    }

    // Populate Direction 2
    if (direction2Name) {
        if (rse_direction2_container) rse_direction2_container.style.display = 'block';
        rse_direction2_title.textContent = `Direction: Towards ${direction2Name}`;
        const stops2 = getStopsForDirection(direction2Name);
        if (stops2.length > 0) {
            rse_direction2_placeholder.style.display = 'none';
            stops2.forEach((s, index) => { // Added index for numbering
                const li = document.createElement('li');
                // Added numbering
                li.innerHTML = `<span class="stop-number">${index + 1}. </span><span class="stop-name">${s.stopName}</span> <span class="stop-id">(${s.stopID})</span>`;
                rse_direction2_stopsList.appendChild(li);
            });
        } else {
            rse_direction2_placeholder.textContent = `No stops found for direction: ${direction2Name}.`;
            rse_direction2_placeholder.style.display = 'block';
        }
    } else if (direction1Name && rse_statusMessage) { // Only one clear direction found
        rse_statusMessage.textContent = `Route ${selectedRoute} appears to have one primary direction defined towards ${direction1Name}, or other directions are less distinct.`;
        if (rse_direction2_container) rse_direction2_container.style.display = 'none'; // Hide the second column
    }
}
// --- END: Route Stops Explorer Functions ---

// --- START: Auto Apply Scheduler ---
function initializeAutoApplyScheduler() {
    if(autoApplyIntervalId) clearInterval(autoApplyIntervalId); // Clear existing interval if any
    // Check every minute (60 * 1000 milliseconds)
    autoApplyIntervalId = setInterval(checkForAutoApply, 60 * 1000);
    console.log("Auto-apply scheduler initialized (checks every minute for Firebase staged updates).");
}

function stopAutoApplyScheduler() {
    if(autoApplyIntervalId){
        clearInterval(autoApplyIntervalId);
        autoApplyIntervalId=null;
        console.log("Auto-apply scheduler stopped.");
    }
}

async function checkForAutoApply() {
    if (!currentUser) return; // Only run if logged in (though this is a background task, context matters)

    const now=new Date();
    const day=now.getDay(); // Sunday = 0, Monday = 1, ..., Wednesday = 3
    const hour=now.getHours(); // 0-23
    const currentISODate=now.toISOString().split('T')[0]; // YYYY-MM-DD

    // Define your auto-apply schedule here
    const AUTO_APPLY_DAY = 6; // 0=Sun, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat
    const AUTO_APPLY_HOUR = 3; // Represents 3 AM (03:00 - 03:59)

    if (day===AUTO_APPLY_DAY && hour===AUTO_APPLY_HOUR) {
        const flagKey = `autoApplied_${AUTO_APPLY_DAY}_${AUTO_APPLY_HOUR}_${currentISODate}`;
        // Check sessionStorage to prevent multiple applications within the same hour on the same day
        if (sessionStorage.getItem(flagKey)==='true') {
            // console.log(`Auto-apply: Already run for ${currentISODate} at ${AUTO_APPLY_HOUR}:00.`);
            return;
        }

        console.log(`Auto-apply: Target time reached (Day ${AUTO_APPLY_DAY}, Hour ${AUTO_APPLY_HOUR} on ${currentISODate}). Checking for staged updates...`);

        if (window.firebaseOMSI && window.firebaseOMSI.database) {
            const {database,dbGet,dbRef,dbChild}=window.firebaseOMSI;
            try {
                const statusSnapshot=await dbGet(dbChild(dbRef(database),FB_PATH_APPSTATE_STATUS));
                const pendingTimestampSnapshot=await dbGet(dbChild(dbRef(database),FB_PATH_PENDING_TIMESTAMP));

                const currentFbStatus = statusSnapshot.exists()?statusSnapshot.val():'unknown';
                const pendingTimestamp = pendingTimestampSnapshot.exists()?pendingTimestampSnapshot.val():null;

                if(currentFbStatus==='update_staged' && pendingTimestamp){
                    console.log("Auto-apply: Staged update found. Attempting to apply live...");
                    // Temporarily override window.confirm for non-interactive application
                    const originalConfirm=window.confirm;
                    window.confirm=(message)=>{
                        console.log(`Auto-apply: Bypassed confirm dialog with message: "${message}"`);
                        return true; // Automatically confirm
                    };
                    handleApplyNow(); // Call the existing apply function
                    window.confirm=originalConfirm; // Restore original confirm

                    sessionStorage.setItem(flagKey,'true'); // Set flag to prevent re-application
                    console.log(`Auto-apply: Staged schedule automatically applied for ${currentISODate} at ${AUTO_APPLY_HOUR}:00.`);
                } else {
                    console.log(`Auto-apply: No staged update eligible for auto-application. Firebase Status: ${currentFbStatus}, Pending Timestamp: ${pendingTimestamp}`);
                    // Set flag even if no update, to prevent re-checking this hour
                    sessionStorage.setItem(flagKey,'true');
                }
            } catch(error){
                console.error("Auto-apply: Error during Firebase check or application:",error);
            }
        } else {
            console.log("Auto-apply: Firebase not available. Cannot check for staged updates.");
        }
    } else { // Not the auto-apply time, clear old flags
        const T24_HOURS_AGO=new Date(now.getTime()-(24*60*60*1000)); // Roughly 24 hours ago
        const yesterdayISODate=T24_HOURS_AGO.toISOString().split('T')[0];
        const oldFlagKey=`autoApplied_${AUTO_APPLY_DAY}_${AUTO_APPLY_HOUR}_${yesterdayISODate}`;
        if(sessionStorage.getItem(oldFlagKey)){
            sessionStorage.removeItem(oldFlagKey);
            console.log(`Auto-apply: Cleared old session flag: ${oldFlagKey}`);
        }
    }
}
// --- END: Auto Apply Scheduler ---


// --- Event Listeners & Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    // Initial UI state before login
    if (adminLoginSection) adminLoginSection.style.display = 'block';
    if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'none';
    if (topMenuBar) topMenuBar.style.display = 'none';
    hideAllToolSections(); // Hide all tool sections initially

    // Listener for Operating Profiles refresh button
    if (refreshOperatingProfilesButton) {
    refreshOperatingProfilesButton.addEventListener('click', () => {
        displayUniqueOperatingProfiles(); // For profiles from currentWorkingSchedule
        displayReferenceOperatingProfiles(); // For the static reference list
    });
}

    // Main menu button listeners
    const allMainMenuButtons = document.querySelectorAll('#main-menu-buttons .menu-button');
    allMainMenuButtons.forEach(button => {
        button.addEventListener('click', () => {
            const sectionId = button.getAttribute('data-section');
            if (currentUser && sectionId) { // Only show section if logged in
                showSection(sectionId);
            } else if (!currentUser) {
                alert("Please log in to access this section.");
            }
        });
    });

    // Analytics & Validation listeners
    if(detectDuplicatesButton) detectDuplicatesButton.addEventListener('click', detectDuplicateEntries);
    if(removeDuplicateEntriesButton) removeDuplicateEntriesButton.addEventListener('click', handleRemoveDuplicateEntries);
    if(consolidateOperatingDaysButton) consolidateOperatingDaysButton.addEventListener('click', handleConsolidateOperatingDays);
    if(consolidateStopSelect) consolidateStopSelect.addEventListener('change', populateConsolidateRouteSelect); // Populate routes when stop changes

    // Add/Remove Stop validation listener
    const inputNewStopId_ARS_El = document.getElementById('inputNewStopId_ARS');
    const newStopIdAvailability_ARS_El = document.getElementById('newStopIdAvailability_ARS');
    if (inputNewStopId_ARS_El && newStopIdAvailability_ARS_El) {
        inputNewStopId_ARS_El.addEventListener('input', () => {
            const newStopId = inputNewStopId_ARS_El.value.trim().toUpperCase();
            if (!newStopId) { newStopIdAvailability_ARS_El.textContent=''; newStopIdAvailability_ARS_El.style.color=''; return; }
            if (!/^[A-Z0-9]+$/.test(newStopId)) { newStopIdAvailability_ARS_El.textContent='ID must be alphanumeric uppercase.'; newStopIdAvailability_ARS_El.style.color='#e74c3c'; return; }
            const existingStopIDs = new Set(currentWorkingSchedule.map(e=>e.stopID.toUpperCase()));
            if (existingStopIDs.has(newStopId)) {
                newStopIdAvailability_ARS_El.textContent='This Stop ID already exists.'; newStopIdAvailability_ARS_El.style.color='#e74c3c';
            } else {
                newStopIdAvailability_ARS_El.textContent='This Stop ID is available.'; newStopIdAvailability_ARS_El.style.color='#2ecc71';
            }
        });
    }

    // Route Timetable Overwrite listeners
    if (rto_selectRoute) rto_selectRoute.addEventListener('change', () => populate_rto_SelectProfile(rto_selectRoute.value));
    if (rto_selectProfile) rto_selectProfile.addEventListener('change', () => populate_rto_SelectDestination(rto_selectRoute.value, rto_selectProfile.value));
    if (rto_fileInput) rto_fileInput.addEventListener('change', handle_rto_FileUpload);
    if (rto_overwriteButton) rto_overwriteButton.addEventListener('click', handle_rto_OverwriteTimetable);

    // Route Stops Explorer listener
    if (rse_selectRoute) rse_selectRoute.addEventListener('change', displayRouteStopsExplorer);

    // Remove inline onclicks and attach listeners for color preset buttons
    const globalColorPresetButtons = document.querySelectorAll('.route-colour-management-subsection .button[onclick^="setGlobalRouteColour"]');
    globalColorPresetButtons.forEach(button => {
        const colorMatch = button.getAttribute('onclick')?.match(/setGlobalRouteColour\('#([0-9a-fA-F]{6})'\)/);
        if (colorMatch && colorMatch[1]) {
            const color = '#' + colorMatch[1];
            button.removeAttribute('onclick'); // Good practice: remove inline handler
            button.addEventListener('click', () => setGlobalRouteColour(color));
        }
    });

    const stopSpecificColorPresetButtons = document.querySelectorAll('.stop-specific-route-colour-subsection .button[onclick^="setStopSpecificRouteColour"]');
    stopSpecificColorPresetButtons.forEach(button => {
        const colorMatch = button.getAttribute('onclick')?.match(/setStopSpecificRouteColour\('#([0-9a-fA-F]{6})'\)/);
        if (colorMatch && colorMatch[1]) {
            const color = '#' + colorMatch[1];
            button.removeAttribute('onclick');
            button.addEventListener('click', () => setStopSpecificRouteColour(color));
        }
    });


// Firebase initialization logic
function initializeMainAppLogic() {
    console.log("Firebase ready, initializing main app logic for OMSI Tools.");
    const { auth, authOnAuthStateChanged, authSignInWithEmailAndPassword, authSignOut } = window.firebaseOMSI;
    authOnAuthStateChanged(auth, (user) => updateAuthUI(user)); // Centralized UI update on auth state change

    if (loginButton && inputEmail && inputPassword && authStatus) {
        const adminLoginForm = document.getElementById('adminLoginForm');
        if (adminLoginForm) adminLoginForm.addEventListener('submit', (event) => {
            event.preventDefault(); // Prevent form submission
            const email=inputEmail.value; const password=inputPassword.value;
            if(authStatus)authStatus.textContent='Logging in...';
            authSignInWithEmailAndPassword(auth, email, password)
                .catch((error) => { // Handle login errors
                    console.error("Login Error:", error);
                    if(authStatus) authStatus.textContent = `Login Error: ${error.message}`;
                });
        });
    }
    if (logoutButton) logoutButton.addEventListener('click', () => {
        localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY); // Clear active section on logout
        authSignOut(auth).catch((e) => console.error("Sign-out Error:", e));
    });
}

// Check if Firebase is already initialized (e.g. script order or async loading)
if (window.firebaseOMSI && window.firebaseOMSI.auth) {
    console.log("Firebase already ready on DOMContentLoaded for OMSI Tools.");
    initializeMainAppLogic();
} else { // Wait for custom 'firebaseReady' event dispatched by the module script
    console.log("Firebase not yet ready on DOMContentLoaded, waiting for 'firebaseReady' event.");
    document.addEventListener('firebaseReady', () => {
        console.log("'firebaseReady' event received by OMSI Tools main script.");
        if (window.firebaseOMSI && window.firebaseOMSI.auth) {
            initializeMainAppLogic();
        } else {
            console.error("'firebaseReady' event fired, but window.firebaseOMSI.auth is still not available! Cannot initialize app logic.");
            updateAuthUI(null); // Ensure UI reflects a non-logged-in state
            if (authStatus) authStatus.textContent = 'Critical Firebase Authentication initialization error.';
        }
    }, { once: true }); // Listen only once
}

    // Deployment and File Upload listeners
    if (stageScheduleButton) stageScheduleButton.addEventListener('click', handleStageSchedule);
    if (applyNowButton) applyNowButton.addEventListener('click', handleApplyNow);
    if (viewArrivalsButton) viewArrivalsButton.addEventListener('click', () => { window.location.href = "omsi_arrivals.html"; }); // Assuming this is the target
    if (countFileInput) countFileInput.addEventListener('change', handleCountFileUpload);

    // Bulk Edit listeners
    if(bulkEditTargetLineNameInput) bulkEditTargetLineNameInput.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); });
    if(bulkUpdateRouteDestinationButton) bulkUpdateRouteDestinationButton.addEventListener('click', handleBulkUpdateRouteDestination);

    // Route Colour Management listeners
    if (saveRouteColourButton) saveRouteColourButton.addEventListener('click', handleSaveGlobalRouteColour);
    if (selectRouteNameColour) selectRouteNameColour.addEventListener('change', () => {
        const selectedRoute = selectRouteNameColour.value;
        const upperSelectedRoute = selectedRoute.toUpperCase();
        if (selectedRoute && globalCustomRouteColours[upperSelectedRoute]) {
            inputRouteColour.value = globalCustomRouteColours[upperSelectedRoute];
        } else if (initialRouteColourMapForTools[upperSelectedRoute]) { // Fallback to initial map if any
            inputRouteColour.value = initialRouteColourMapForTools[upperSelectedRoute];
        } else { // Absolute default
            inputRouteColour.value = DEFAULT_ROUTE_COLOUR_TOOLS;
        }
    });

    // Stop-Specific Route Colour listeners
    if (selectStopForSpecificRouteColour) selectStopForSpecificRouteColour.addEventListener('change', displayRoutesForSpecificColouring);
    if (saveStopSpecificRouteColourButton) saveStopSpecificRouteColourButton.addEventListener('click', handleSaveStopSpecificRouteColour);
    if (deleteRouteFromStopButton) deleteRouteFromStopButton.addEventListener('click', handleDeleteRouteFromSpecificStop);

    // View Departures listener
    if (selectStopForDeparturesView) selectStopForDeparturesView.addEventListener('change', displayDeparturesForSelectedStop);

    // ADDED: Event listeners for Timetable Generator
    if (tg_selectRoute) {
        tg_selectRoute.addEventListener('change', populate_tg_selectDirection);
    }
    if (tg_selectDirection) {
        tg_selectDirection.addEventListener('change', display_tg_Timetable);
    }

    // Service Worker registration
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/live-tracker/sw-omsi.js') // Ensure this path is correct from your web root
            .then(registration => console.log('Service Worker (sw-omsi.js) registered with scope:', registration.scope))
            .catch(error => console.error('Service Worker (sw-omsi.js) registration failed:', error));
        });
    }
});
</script>
</body>
</html>
