<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMSI Tools - Extra Modules</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
   <link rel="manifest" href="/live-tracker/manifest-omsitoolsextra.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OMSI Extra Tools">
    <meta name="theme-color" content="#2c3e50">
    
    <style>
        /* --- Styles for Responsive SRU Batch Actions --- */
        .sru-batch-actions {
            display: flex;
            flex-wrap: wrap; /* Allows buttons to wrap to the next line on small screens */
            gap: 0.5rem;     /* Creates consistent spacing between buttons */
            margin-top: 1em; /* Adds some space above the button group */
        }

        .sru-batch-actions .button {
            flex: 1 1 220px; /* Buttons can grow and shrink, with a preferred base width of 220px */
            margin: 0;       /* Reset individual margins, gap property will handle spacing */
            text-align: center;
        }

        @font-face {
            font-family: 'NJFont Medium Web';
            src: url('fonts/NJFont-Medium.ttf') format('truetype');
            font-weight: normal;font-style: normal;font-display: swap;
        }
        body {
            font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            margin:0;
            box-sizing: border-box;
        }
        .page-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            box-sizing: border-box;
        }
        #top-menu-bar_extra {
            background-color: rgba(0,0,0,0.25); padding: 0.75rem; border-radius: 0.5rem;
            margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center; display: block;
        }
        .menu-button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin: 0.25rem;
        }
        .menu-button:hover { background-color: #2980b9; }
        .tool-content-section {
            display: block; 
            background-color: rgba(0,0,0,0.15); padding: 1.5rem;
            border-radius: 0.5rem; margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            box-sizing: border-box;
        }
        #auth-section {
             margin-bottom: 1.5rem; background-color: rgba(0,0,0,0.15); padding: 1.5rem;
             border-radius: 0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #current-profile-display-container {
            text-align: center; margin-bottom: 1.5rem; padding: 0.75rem;
            background-color: rgba(255,255,255,0.05); border-radius: 0.25rem; display: block;
        }
        #auth-section.auth-section-compact {
            padding: 0.75rem;
            background-color: rgba(255,255,255,0.05);
            border-radius: 0.25rem;
            text-align: center;
        }

        #logout-container_extra {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .logged-in-username {
            font-size: 0.9rem;
            color: #FFFFFF;
        }

#op-points-list-extra li {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 0.5rem;
    border-bottom: 1px solid #4A5568;
}
#op-points-list-extra li:last-child {
    border-bottom: none;
}
#op-points-list-extra .op-point-item-actions {
    display: flex;
    gap: 0.5rem;
    align-items: center;
}

        #stopDeparturesList_extra li {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.1rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #stopDeparturesList_extra li:last-child {
            border-bottom: none;
        }

        #current-profile-display { font-size: 0.9rem; opacity: 1; font-style: normal; color: #FFFFFF;}
        h1 { font-size: 2rem; margin-bottom: 1.5rem; font-weight: normal; text-align: center; color: #ffffff; }
        h2 { font-size: 1.5rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: normal; border-bottom: 1px solid #7f8c8d; padding-bottom: 0.25rem;}
        h3.subsection-title { font-size: 1.25rem; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: normal; color: #e0e0e0; border-bottom: 1px solid rgba(127,140,141,0.5); padding-bottom: 0.2rem;}
        .subsection {
            background-color: rgba(0,0,0,0.1); padding: 1rem; border-radius: 0.375rem;
            margin-top: 1rem; margin-bottom: 1rem; border: 1px solid rgba(127,140,141,0.2);
            box-sizing: border-box;
        }
        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;}
        .form-field-group { margin-bottom: 1rem; }
        label { display: block; margin-bottom: 0.25rem; font-size: 0.85rem; color: #bdc3c7; }
        input[type="text"], input[type="email"], input[type="password"], input[type="time"],
        input[type="color"], input[type="number"], input[type="date"], input[type="datetime-local"],
        select, textarea {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e; color: #ecf0f1; font-size:0.9rem; box-sizing: border-box;
        }
        input[type="date"]::-webkit-calendar-picker-indicator,
        input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            filter: invert(0.8); cursor:pointer;
        }
        select option { background-color: #34495e; color: #ecf0f1; }
        .button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.5rem 0.8rem;
            border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin-right: 0.5rem; margin-top:0.5rem;
            display: inline-block;
            text-align: center;
            vertical-align: middle;
            box-sizing: border-box;
        }
        .button:hover { background-color: #2980b9; }
        .button.secondary { background-color: #e74c3c; }
        .button.secondary:hover { background-color: #c0392b; }
        .button.save { background-color: #27ae60; }
        .button.save:hover { background-color: #229954; }
        .button.tertiary { background-color: #f39c12; }
        .button.tertiary:hover { background-color: #e67e22; }
        .button.neutral { background-color: #7f8c8d; }
        .button.neutral:hover { background-color: #95a5a6; color: #2c3e50; }
        .button.small-action { padding: 0.2rem 0.4rem; font-size: 0.8rem; margin: 0 0.15rem; line-height: 1; min-width: 20px; text-align:center; font-weight: bold;}

        .button:disabled,
        .button[disabled] {
            background-color: #5D6D7E !important;
            color: #a0a0a0 !important;
            cursor: not-allowed;
            opacity: 0.65;
            box-shadow: none;
        }

        .schedule-generator-input {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e; color: #ecf0f1; font-size: 0.9rem;
        }
        #masterStopListUL_extra li.master-stop-list-item { display: grid; grid-template-columns: 2.5fr 1.5fr 1fr; gap: 1rem; padding: 0.75rem 0.5rem; border-bottom: 1px solid #34495e; transition: background-color 0.15s ease-in-out; align-items: start; } #masterStopListUL_extra li.master-stop-list-item:last-child { border-bottom: none; } .master-stop-original-info .stop-name-master { font-weight: bold; color: #ecf0f1; font-size: 1.05em; } .master-stop-original-info .stop-direction-master { font-size: 0.85em; color: #95a5a6; margin-bottom: 0.3rem; }
        .master-stop-original-info .stop-id-master { font-weight: normal; color: #bdc3c7; font-size: 0.95em; } .master-stop-original-info .stop-details-grid { display: grid; grid-template-columns: auto 1fr; gap: 0.2rem 0.8rem; font-size: 0.85em; margin-top: 0.4rem; } .master-stop-original-info .detail-label { font-weight: normal; color: #bdc3c7; opacity: 0.8; } .master-stop-original-info .detail-value { color: #ecf0f1; } .master-stop-original-info .detail-value.status-closed { color: #e74c3c; font-weight: bold; } .master-stop-original-info .status-open { color: #2ecc71; } .master-stop-original-info .serving-routes-container { margin-top: 0.4rem; margin-bottom: 0.2rem; display: flex; flex-wrap: wrap; gap: 0.3em; padding: 0.25rem 0;} .master-stop-new-id-section label { font-size: 0.8em; display: block; margin-bottom: 0.2em; color: #bdc3c7; } .master-list-new-id-input { margin-bottom: 0.25rem; } .master-list-row-warning { font-size: 0.8em; color: #f39c12; min-height: 1.2em; margin-top: 0.25rem; } .master-stop-actions { margin-top: 0rem; padding-top: 0rem; border-top: none; display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-start; } .master-stop-actions .button { width: 100%; margin: 0; } .route-tile-tools-list { display: inline-block; padding: 0.2em 0.55em; margin-right: 0.3em; margin-bottom: 0.3em; border-radius: 0.25rem; font-size: 0.8em; font-weight: bold; color: white; text-align: center; line-height: 1.3; min-width: 28px; box-shadow: 0 1px 2px rgba(0,0,0,0.25); vertical-align: middle; } #newStopIdAvailability_extra { font-size: 0.8em; min-height: 1.1em; margin-top: 0.25rem; }
        .selectable-route-tile-container { display: flex; flex-wrap: wrap; gap: 0.6rem; padding: 0.25rem 0; } .selectable-route-tile { display: inline-block; padding: 0.4em 0.8em; border-radius: 0.25rem; font-size: 0.9em; font-weight: bold; text-align: center; line-height: 1.4; min-width: 40px; box-shadow: 0 1px 3px rgba(0,0,0,0.3); cursor: pointer; border: 2px solid transparent; transition: border-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out; } .selectable-route-tile:hover { transform: translateY(-1px); } .selectable-route-tile.selected { border-color: #f1c40f !important; box-shadow: 0 0 8px 1px #f1c40f !important; }
        #duplicateStopsByNameDirResults_extra ul { list-style: none; padding-left: 0; } #duplicateStopsByNameDirResults_extra li { margin-bottom: 0rem; } .duplicate-set-to-merge { border: 1px solid #4a5568; padding: 0.75rem; margin-bottom: 0.75rem; border-radius: 0.25rem; background-color: rgba(0,0,0,0.05); } .duplicate-set-to-merge p { margin-bottom: 0.35rem; } .duplicate-set-to-merge .stop-id-options label { display: block; margin-bottom: 0.25rem; font-size: 0.9em; cursor: pointer; } .duplicate-set-to-merge .stop-id-options input[type="radio"] { margin-right: 0.35em; vertical-align: middle; }
        #rsg-stop-sequence-list-extra li { display: flex; flex-direction: column; padding: 0.6rem 0.5rem; border-bottom: 1px solid #4A5568; background-color: rgba(255,255,255,0.03); cursor: grab; } #rsg-stop-sequence-list-extra li:active { cursor: grabbing; background-color: rgba(255,255,255,0.07); } #rsg-stop-sequence-list-extra li.rsg-dragging-placeholder { opacity: 0.5; background-color: #567a9a; border: 1px dashed #ecf0f1; } #rsg-stop-sequence-list-extra li:last-child { border-bottom: none; } .rsg-li-main-content { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 0.5rem; }
        #rsg-stop-sequence-list-extra .rsg-stop-info { flex-grow: 1; margin-right: 1rem; } #rsg-stop-sequence-list-extra .rsg-stop-name { font-weight: bold; } #rsg-stop-sequence-list-extra .rsg-stop-id { font-size: 0.85em; color: #bdc3c7; margin-left: 0.5em; } #rsg-stop-sequence-list-extra .rsg-stop-actions { display: flex; align-items: center; gap: 0.5rem; } #rsg-stop-sequence-list-extra .rsg-stop-actions button { padding: 0.15rem 0.35rem; font-size: 0.75rem; line-height: 1; } #rsg-stop-sequence-list-extra .rsg-time-adjustment-input { width: 70px; padding: 0.25rem; font-size: 0.85em; text-align: center; }
        .rsg-copy-adjustment-buttons-container { display: flex; flex-wrap: wrap; gap: 0.4rem; margin-top: 0.5rem; align-items: center; width: 100%; padding-top: 0.3rem; border-top: 1px solid rgba(127,140,141,0.15); } .rsg-copy-adjustment-buttons-container .button.copy-adj-button { font-size: 0.7em; padding: 0.2em 0.5em; line-height: 1.3; white-space: nowrap; margin: 0; background-color: #546E7A; color: white; } .rsg-copy-adjustment-buttons-container .button.copy-adj-button:hover { background-color: #607D8B; }
        #dpo-selectable-profiles-container-extra > div, #rsg-selectable-profiles-container-extra > div {
            display: inline-flex;
            align-items: center;
            background-color: #4A5568;
            color: #ecf0f1;
            padding: 0.4em 0.8em;
            border-radius: 0.25rem;
            border: 1px solid transparent;
            cursor: pointer;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }

        #dpo-selectable-profiles-container-extra > div > label, #rsg-selectable-profiles-container-extra > div > label {
            font-size: 14px !important;
            font-weight: 700 !important;
            font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif !important;
            text-shadow: 0 0 1px rgba(255,255,255,0.5);
            cursor: pointer;
            line-height: 1.4;
            margin-left: 4px;
            color: #ecf0f1;
        }

        #dpo-selectable-profiles-container-extra > div > input[type="checkbox"], #rsg-selectable-profiles-container-extra > div > input[type="checkbox"] {
            margin-right: 8px;
            vertical-align: middle;
            height: 1em;
            width: 1em;
        }

        #dpo-selectable-profiles-container-extra > div:has(input[type="checkbox"]:checked), #rsg-selectable-profiles-container-extra > div:has(input[type="checkbox"]:checked) {
            border-color: #f1c40f !important;
            box-shadow: 0 0 6px 1px #f1c40f !important;
        }

        #dpo-selectable-profiles-container-extra > div:hover, #rsg-selectable-profiles-container-extra > div:hover {
            background-color: #5D6D7E;
        }
        #rsg-stop-search-results-extra { max-height: 200px; overflow-y: auto; border: 1px solid #4A5568; border-radius: 0.25rem; background-color: #34495e; margin-top: 0.25rem; } #rsg-stop-search-results-extra .rsg-search-result-item { padding: 0.5rem 0.6rem; cursor: pointer; border-bottom: 1px solid #2c3e50; } #rsg-stop-search-results-extra .rsg-search-result-item:last-child { border-bottom: none; } #rsg-stop-search-results-extra .rsg-search-result-item:hover { background-color: #4a6a80; } #rsg-stop-search-results-extra .rsg-search-stop-name { font-weight: bold; display: block; } #rsg-stop-search-results-extra .rsg-search-stop-details { font-size: 0.8em; color: #bdc3c7; display: block; margin-top:0.1em; } #rsg-stop-search-results-extra .rsg-search-serving-routes { margin-top: 0.3em; }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }
        .rpd-profile-tile { border: 2px solid transparent; transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; } .rpd-profile-tile.selected { border-color: #f1c40f !important; box-shadow: 0 0 8px 1px #f1c40f !important; }

        /* --- THIS IS THE CORRECTED MODAL STYLE --- */
        .rsg-modal { 
            position: fixed; 
            left: 0; 
            top: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(0, 0, 0, 0.6); 
            z-index: 1050; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
        } 

        .rsg-modal-content { 
            background: linear-gradient(145deg, #3a506b, #2c3e50); 
            color: #ecf0f1; 
            padding: 20px 25px; 
            border-radius: 8px; 
            width: 90%;
	    max-height: 90vh;
	    overflow-y: auto; 
            max-width: 500px; 
            box-shadow: 0 8px 25px rgba(0,0,0,0.3); 
            border: 1px solid #4a6a80; 
        }

        .rsg-modal-content h4 { margin-top: 0; margin-bottom: 1rem; font-size: 1.3em; color: #ffffff; border-bottom: 1px solid #567a9a; padding-bottom: 0.5rem; } .rsg-modal-content .form-field-group { margin-bottom: 1rem; } .rsg-modal-content label { font-size: 0.9em; } .rsg-modal-content input.schedule-generator-input { background-color: #2c3e50; border-color: #567a9a; } .rsg-modal-actions { margin-top: 1.5rem; text-align: right; display: flex; justify-content: flex-end; gap: 0.5rem; } .rsg-modal-actions .button { margin-top: 0; }
        
        #sru-cancel-modal-checkboxes-container-extra .sru-cancel-time-item label { color: #ecf0f1; font-size: 0.9em; cursor: pointer; } #sru-cancel-modal-checkboxes-container-extra .sru-cancel-time-item input[type="checkbox"] { margin-right: 8px; vertical-align: middle; } #sru-cancel-modal-checkboxes-container-extra .sru-cancel-time-item { display: block; margin-bottom: 0.4rem; padding: 0.2rem 0.1rem; }

        /* --- RESPONSIVE BUTTON AND FORM FIXES --- */
        #main-menu-buttons_extra { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.25rem; }
        #main-menu-buttons_extra .menu-button { flex-grow: 1; min-width: 160px; margin: 0.25rem;  }
        @media (max-width: 480px) { #logout-container_extra { flex-direction: column; align-items: flex-start; gap: 0.5rem; } #logoutButton_extra {  margin-top: 0.25rem; align-self: flex-start; } }
        
        #timetable-exporter-section_extra .form-grid[style*="grid-template-columns: 3fr 1fr"] { grid-template-columns: 1fr !important;  }
        @media (min-width: 768px) { #timetable-exporter-section_extra .form-grid[style*="grid-template-columns: 3fr 1fr"] { grid-template-columns: 3fr 1fr !important;  } }
        
        #scheduled-route-deletion-section_extra .form-grid[style*="grid-template-columns: 2fr 1.5fr 1fr"] { grid-template-columns: 1fr !important;  }
        @media (min-width: 768px) { #scheduled-route-deletion-section_extra .form-grid[style*="grid-template-columns: 2fr 1.5fr 1fr"] { grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)) !important;  } }
        @media (min-width: 1024px) { #scheduled-route-deletion-section_extra .form-grid[style*="grid-template-columns: 2fr 1.5fr 1fr"] { grid-template-columns: 2fr 1.5fr 1fr !important;  } }
        
        #route-schedule-generator-section_extra .subsection > .form-field-group[style*="display: flex"] { flex-wrap: wrap !important; gap: 0.5rem;  }
        #route-schedule-generator-section_extra .subsection > .form-field-group[style*="display: flex"] .button { flex-grow: 1; flex-basis: calc(50% - 0.5rem);  min-width: 200px;  margin-left: 0 !important;  margin-right: 0 !important; }
        @media (max-width: 600px) {  #route-schedule-generator-section_extra .subsection > .form-field-group[style*="display: flex"] .button { flex-basis: 100%;  } }
        
        .rsg-modal-actions { flex-wrap: wrap; justify-content: flex-start;  gap: 0.5rem;  }
        .rsg-modal-actions .button { flex-grow: 1; min-width: 120px; margin: 0;  }
        
        #stop-manager-tool-section_extra .subsection > div[style*="justify-content:space-between"][style*="align-items:center"] { flex-wrap: wrap !important;  gap: 0.5rem; }
        #stop-manager-tool-section_extra .subsection > div[style*="justify-content:space-between"][style*="align-items:center"] > .button { flex-grow: 1; min-width: 160px;  }
        
        #config-data-section_extra .subsection .form-grid[style*="grid-template-columns: 1fr 1fr 2fr auto"] {
            grid-template-columns: 1fr !important; 
            gap: 0.5rem !important;
        }
        @media (min-width: 768px) {
            #config-data-section_extra .subsection .form-grid[style*="grid-template-columns: 1fr 1fr 2fr auto"] {
                grid-template-columns: 1fr 1fr 2fr auto !important;
                gap: 1rem !important;
            }
        }
        #config-data-section_extra .subsection div[style*="border: 1px dashed #f39c12"] {
            white-space: normal;
            word-wrap: break-word;
        }
        #config-data-section_extra .subsection div[style*="border: 1px dashed #f39c12"] ul {
            white-space: normal;
            word-wrap: break-word;
        }

        .calendar-tool-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .calendar-grid-container-extra {
            width: 100%;
            margin-bottom: 1rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            box-sizing: border-box;
        }
        #events-calendar-grid_extra {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-auto-rows: minmax(100px, auto);
        }

        #events-calendar-grid_extra .cv-current-day {
            background-color: rgba(255, 255, 0, 0.25) !important;
            border: 2px solid #F1C40F !important;
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.7);
        }
        #events-calendar-grid_extra .cv-current-day .cv-day-number-span {
            font-weight: bold;
            color: #F1C40F !important;
        }

        #events-calendar-grid_extra > div {
            height: auto;
            padding: 4px;
            font-size: 0.70em;
            box-sizing: border-box;
            overflow-wrap: break-word;
            word-wrap: break-word;
            white-space: normal;
            border-right: 1px solid #3e4e5e;
            border-bottom: 1px solid #3e4e5e;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            min-width: 0;
        }
        #events-calendar-grid_extra > div:nth-child(7n) { border-right: none; }
        #events-calendar-grid_extra > div:last-child { border-bottom: none; }
        #events-calendar-grid_extra > div[style*="font-weight: bold"] {
            font-size: 0.6em !important;
            padding: 3px 2px !important;
            text-align: center !important;
            height: auto;
            background-color: rgba(0,0,0,0.25) !important;
            justify-content: center;
            border-bottom: 1px solid #4A5568 !important;
        }
        #events-calendar-grid_extra .cv-day-number-span {
            font-size: 0.9em;
            display: block;
            text-align: right;
            margin-bottom: 2px;
            font-weight: bold;
            color: #ecf0f1;
        }
        .cv-profile-text {
            font-size: 0.85em;
            font-weight: bold;
            color: #bdc3c7;
            margin-bottom: 0.3em;
            text-align: left;
            white-space: normal;
            overflow-wrap: break-word;
            word-wrap: break-word;
            line-height: 1.3;
        }
        #events-calendar-grid_extra .cv-event-item {
            display: block;
            padding: 2px 3px;
            margin-top: 1px;
            border-radius: 3px;
            font-size: 0.9em;
            line-height: 1.2;
            color: white; 
            white-space: normal;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        @media (max-width: 600px) {
            #events-calendar-grid_extra { grid-auto-rows: minmax(80px, auto); }
            #events-calendar-grid_extra > div { font-size: 0.65em; padding: 3px; }
            #events-calendar-grid_extra > div[style*="font-weight: bold"] { font-size: 0.6em !important; }
            #events-calendar-grid_extra .cv-day-number-span { font-size: 0.85em; }
            .cv-profile-text { font-size: 0.8em; }
            #events-calendar-grid_extra .cv-event-item { font-size: 0.85em; line-height: 1.15; padding: 1px 2px;}
        }
        @media (max-width: 480px) {
            .calendar-tool-header { justify-content: center; }
            #cv-month-year-display_extra { order: -1; width: 100%; text-align: center; margin-bottom: 0.5rem; font-size: 1.2em; }
            #cv-prev-month-btn_extra, #cv-next-month-btn_extra { flex-basis: calc(50% - 0.25rem); justify-content: center; font-size: 0.8em; padding: 0.5rem 0.6rem; }
            #events-calendar-grid_extra { grid-auto-rows: minmax(70px, auto); }
            #events-calendar-grid_extra > div { font-size: 0.6em; padding: 2px; }
            #events-calendar-grid_extra > div[style*="font-weight: bold"] { font-size: 0.55em !important; }
            #events-calendar-grid_extra .cv-day-number-span { font-size: 0.9em; }
            .cv-profile-text { font-size: 0.75em; line-height: 1.2; }
            #events-calendar-grid_extra .cv-event-item { font-size: 0.8em; line-height: 1.1; padding: 1px 2px;}
        }

        .sru-task-title-heading {
            white-space: normal !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            text-overflow: clip !important;
            display: block;
        }
        
        #rsg-route-selection-container-extra,
        #rsg-selectable-profiles-container-extra,
        #rsg-saved-configs-list-extra,
        #rsg-schedule-preview-container-extra > div,
        #op-copy-eligible-points-container-extra {
            max-height: none !important;
            overflow-y: visible !important;
        }

    </style>
</head>
<body>
    <div class="page-container">
        <h1>OMSI Tools - Extra Modules</h1>
        <div id="global-notification-banner" style="display: none; padding: 12px 15px; background-color: #27ae60; color: white; text-align: center; position: sticky; top: 0; left: 0; width: 100%; z-index: 1060; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
        </div>

        <div id="auth-section" class="section">
            <h2>Admin Login</h2>
            <div id="login-form-container_extra">
                <form id="adminLoginForm_extra">
                    <div class="form-grid" style="grid-template-columns: 1fr;">
                        <div><label for="inputEmail_extra">Email</label><input type="email" id="inputEmail_extra" autocomplete="email"></div>
                        <div><label for="inputPassword_extra">Password</label><input type="password" id="inputPassword_extra" autocomplete="current-password"></div>
                    </div>
                    <button id="loginButton_extra" type="submit" class="button">Login</button>
                </form>
                <p id="auth-status_extra" style="margin-top: 0.5em; color: #f1c40f;"></p>
            </div>
            <div id="logout-container_extra" style="display:none;"> <span id="loggedInUserEmail_extra" class="logged-in-username"></span>
                <button id="logoutButton_extra" class="button secondary small-action">Logout</button>
            </div>
        </div>

        <div id="current-profile-display-container" style="display:none;"> <p id="current-profile-display">Today's Operating Profile: (loading...)</p>
            <button id="enableDesktopNotificationsBtn_extra" class="button neutral">Enable Desktop Alerts</button>
            <button id="iphoneTestNotificationBtn" class="button neutral" style="background-color: lightblue; color: #2c3e50;">Test iPhone Notification</button>
        </div>

        <div id="top-menu-bar_extra" style="display:none;"> 
            <div id="main-menu-buttons_extra">
                <button class="menu-button" data-section="day-profile-override-section_extra">Day Profile Override</button>
                <button class="menu-button" data-section="stop-manager-tool-section_extra">Master Stop Viewer</button>
                <button class="menu-button" data-section="global-route-deletion-section_extra">Global Route Deletion</button>
                <button class="menu-button" data-section="route-schedule-generator-section_extra">Route Schedule Generator</button>
                <button class="menu-button" data-section="route-profile-deletion-section_extra">Route Profile Deletion</button>
                <button class="menu-button" data-section="view-departures-section_extra">View Departures</button>
                <button class="menu-button" data-section="timetable-exporter-section_extra">Timetable Exporter</button>
                <button class="menu-button" data-section="scheduled-route-updates-section_extra">Scheduled Tasks</button>
                <button class="menu-button" data-section="scheduled-route-deletion-section_extra">Schedule Route Deletion</button>
                <button class="menu-button" data-section="config-data-section_extra">View/Edit Config Data</button>
                <button class="menu-button" data-section="key-departures-section_extra">Key Departures</button> 
                <button class="menu-button" data-section="calendar-view-section_extra">Events Calendar</button>
                <button class="menu-button" data-section="curtailment-config-section_extra">Operational Points</button>
                <button class="menu-button" data-section="trip-curtailment-section_extra">Live Trip Intervention</button>
                <button class="menu-button" data-section="route-curtailment-section_extra">Service Leg Curtailment</button>
            </div>
        </div>

        <div id="tool-sections-wrapper_extra">

            <div id="route-curtailment-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Service Leg Curtailment</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Set a temporary terminus for all trips on a specific service leg (route and direction).
                </p>
            
                <div class="subsection">
                    <h3 class="subsection-title">1. Define Service Curtailment</h3>
                    <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); align-items: end;">
                        <div>
                            <label for="slc-route-select-extra">Route to Curtail:</label>
                            <select id="slc-route-select-extra" class="schedule-generator-input"></select>
                        </div>
                        <div>
                            <label for="slc-destination-select-extra">Direction/Destination to Curtail:</label>
                            <select id="slc-destination-select-extra" class="schedule-generator-input" disabled></select>
                        </div>
                        <div>
                            <label for="slc-return-dest-select-extra">And Suppress Return Journey to:</label>
                            <select id="slc-return-dest-select-extra" class="schedule-generator-input" disabled multiple size="3"></select>
                        </div>
                        <div>
                            <label for="slc-curtailment-point-select-extra">New Temporary Terminus:</label>
                            <select id="slc-curtailment-point-select-extra" class="schedule-generator-input" disabled></select>
                        </div>
                    </div>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr; align-items: end; margin-top: 1rem;">
                         <div>
                            <label for="slc-start-time-input-extra">Curtailment Start From:</label>
                            <input type="datetime-local" id="slc-start-time-input-extra" class="schedule-generator-input">
                        </div>
                        <div>
                            <label for="slc-end-time-input-extra">Curtailment End At:</label>
                            <input type="datetime-local" id="slc-end-time-input-extra" class="schedule-generator-input">
                        </div>
                    </div>
                </div>
            
                <div class="subsection" style="margin-top: 1.5rem;">
                    <h3 class="subsection-title">2. Activate Curtailment</h3>
                    <button id="slc-activate-button-extra" class="button secondary">Activate Service Curtailment</button>
                    <p id="slc-status-message-extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>
            
                <div class="subsection" style="margin-top: 2rem;">
                    <h3 class="subsection-title">Active & Upcoming Service Curtailments</h3>
                    <div id="slc-active-list-extra">
                        <p>Loading...</p>
                    </div>
                </div>
            </div>
            <div id="key-departures-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Key First & Last Departures (Today)</h2>
                <p style="font-size:0.9em; margin-bottom:1em; opacity: 0.8;">
                    This tool shows the upcoming first and last trips of the day for all services, based on saved RSG configurations. It is intended for operational awareness. Data automatically refreshes.
                </p>
                <button id="kd-refresh-btn_extra" class="button neutral small-action" style="margin-bottom: 1em;">Refresh Now</button>
                <p id="kd-status-message_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                <div class="form-grid" style="grid-template-columns: 1fr 1fr; gap: 2rem;">
                    <div>
                        <h3 class="subsection-title">Upcoming First Departures</h3>
                        <div id="kd-first-departures-list_extra"></div>
                    </div>
                    <div>
                        <h3 class="subsection-title">Upcoming Last Departures</h3>
                        <div id="kd-last-departures-list_extra"></div>
                    </div>
                </div>
            </div>

            <div id="day-profile-override-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Day Profile Override</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Force a specific operating profile for one or more routes on a chosen date, overriding the automatic day-of-week, school day, or bank holiday logic.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">1. Select Date & Profiles</h3>
                    <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); align-items: end;">
                        <div>
                            <label for="overrideDate_extra">Date to Override:</label>
                            <input type="date" id="overrideDate_extra" class="schedule-generator-input">
                        </div>
                        <div>
                            <label>Selected Date:</label>
                            <p id="selectedDateDisplay_extra" style="padding: 0.5rem; background-color: #2c3e50; border-radius: 0.25rem;">(select a date)</p>
                        </div>
                        <div>
                            <label>Current Route Overrides for this Date:</label>
                            <div id="dpo-current-overrides-list-extra" style="font-size:0.9em; min-height: 40px;"></div>
                        </div>
                    </div>
                     <div class="form-field-group" style="margin-top: 1rem;">
                        <label>Select Operating Profile(s) to Apply:</label>
                         <div id="dpo-selectable-profiles-container-extra" class="selectable-route-tile-container">
                            <p id="dpo-profiles-placeholder-extra" style="opacity:0.7;">Loading profiles...</p>
                        </div>
                        <p style="font-size:0.8em; opacity:0.8; margin-top:0.4rem;">Currently Selected: <strong id="dpo-selected-profiles-display-extra">(None selected)</strong></p>
                        <button id="dpo-clear-profile-checkboxes-button-extra" class="button small-action neutral" style="margin-top:0.5rem;">Clear Profile Selection</button>
                    </div>
                </div>
                 <div class="subsection" style="margin-top:1.5rem;">
                    <h3 class="subsection-title">2. Select Routes to Apply Override To</h3>
                    <div id="dpo-route-selection-container-extra" class="selectable-route-tile-container">
                         <p id="dpo-routes-placeholder-extra" style="opacity:0.7;">Loading routes...</p>
                    </div>
                    <p style="font-size:0.8em; opacity:0.8; margin-top:0.4rem;">Currently Selected (<span id="dpo-selected-route-count-extra">0</span>): <strong id="dpo-selected-routes-display-extra">(None selected)</strong></p>
                     <div style="margin-top:0.5rem;">
                        <button id="dpo-select-all-routes-button-extra" class="button small-action neutral">Select All Routes</button>
                        <button id="dpo-clear-route-selection-button-extra" class="button small-action neutral">Clear Route Selection</button>
                    </div>
                </div>
                <div class="subsection" style="margin-top:1.5rem;">
                    <h3 class="subsection-title">3. Apply or Clear Overrides</h3>
                     <button id="dpo-apply-override-to-routes-button-extra" class="button save">Apply Profile(s) to Selected Routes</button>
                     <button id="dpo-clear-override-for-routes-button-extra" class="button secondary">Clear Override from Selected Routes</button>
                     <p id="dpo-status-message-extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>
                <div class="subsection" style="margin-top: 2rem;">
                    <h3 id="dpo-active-overrides-title" class="subsection-title">All Active Overrides (Next 365 Days)</h3>
                    <div id="activeOverridesList_extra"></div>
                </div>
            </div>

            <div id="stop-manager-tool-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Master Stop Viewer</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    This tool provides a consolidated list of all unique stops defined across all of your saved RSG configurations. To add, remove, or edit stops, please do so within the "Route Schedule Generator" tool.
                </p>
                 <div class="subsection">
                    <h3 class="subsection-title">Master Stop List (Derived from RSG Configs)</h3>
                     <div style="display: flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:1rem; margin-bottom:1rem;">
                        <input type="text" id="masterStopListFilterInput_extra" placeholder="Filter by name, ID, direction, status, or route..." style="flex-grow:1; min-width:250px;">
                        <div>
                             <button id="findDuplicateStopsByNameDirButton_extra" class="button tertiary">Find Duplicates (Name/Dir)</button>
                             <button id="refreshMasterStopListButton_extra" class="button neutral">Refresh List</button>
                        </div>
                    </div>
                    <p id="masterStopListStatus_extra" style="min-height:1.2em;"></p>
                     <div id="duplicateStopsByNameDirResults_extra"></div>
                     <ul id="masterStopListUL_extra" style="list-style-type: none; padding: 0; max-height: 800px; overflow-y: auto;"></ul>
                </div>
            </div>

            <div id="global-route-deletion-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Global Route Deletion</h2>
                <p style="font-size:0.9em; margin-bottom:1em; opacity: 0.8;">Permanently delete all schedule entries and settings associated with one or more routes.</p>
                <div class="subsection">
                    <h3 class="subsection-title">Select Route(s) to Delete</h3>
                    <div id="globalRouteDeletionListContainer_extra" class="selectable-route-tile-container"></div>
                    <button id="deleteEntireRouteButton_extra" class="button secondary" style="margin-top: 1rem;">Delete Selected Route(s) Globally</button>
                    <p id="deleteEntireRouteStatusMessage_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>
            </div>

            <div id="route-schedule-generator-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Route Schedule Generator</h2>
                <p style="font-size:0.9em; margin-bottom:1em; opacity: 0.8;">Create, modify, and manage timetables for specific route, destination, and operating profile combinations.</p>
                <div class="subsection">
                    <h3 class="subsection-title">1. Define/Load Configuration</h3>
                    <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
                        <div>
                            <label>Route Name:</label>
                            <input type="text" id="rsg-routeName-input-extra" style="display:none;">
                            <div id="rsg-route-selection-container-extra" class="selectable-route-tile-container">
                                <p id="rsg-routes-placeholder-extra" style="opacity:0.7;">Loading routes...</p>
                            </div>
                            <p style="font-size:0.8em; opacity:0.8; margin-top:0.4rem;">Selected: <strong id="rsg-selected-route-display-extra">(None selected)</strong> <button id="rsg-clear-route-selection-button-extra" class="button small-action neutral" style="margin-left:5px;">Clear</button></p>
                        </div>
                        <div>
                            <label for="rsg-destinationName-select-extra">Destination Name:</label>
                            <select id="rsg-destinationName-select-extra" class="schedule-generator-input"></select>
                            <input type="text" id="rsg-destinationName-input-extra" class="schedule-generator-input" style="margin-top:0.5rem;" placeholder="Or type a new destination...">
                        </div>
                        <div>
                            <label>Operating Profile(s):</label>
                            <div id="rsg-selectable-profiles-container-extra">
                                <p id="rsg-profiles-placeholder-extra" style="opacity:0.7;">Loading profiles...</p>
                            </div>
                             <p style="font-size:0.8em; opacity:0.8; margin-top:0.4rem;">Selected: <strong id="rsg-selected-profiles-display-extra">(None selected)</strong> <button id="rsg-clear-profile-checkboxes-button-extra" class="button small-action neutral" style="margin-left:5px;">Clear</button></p>
                        </div>
                    </div>
                     <div class="form-field-group" style="margin-top:1rem;">
                        <button id="rsg-open-copy-modal-button-extra" class="button neutral">Copy Sequence/Times From...</button>
                        <button id="rsg-open-paste-adj-modal-button-extra" class="button neutral">Paste Adjustments...</button>
                     </div>
                </div>
                <div class="subsection">
                    <h3 class="subsection-title">2. Build Stop Sequence</h3>
                    <input type="text" id="rsg-stop-search-input-extra" class="schedule-generator-input" placeholder="Search for stop by name or ID...">
                    <div id="rsg-stop-search-results-extra"></div>
                    <ul id="rsg-stop-sequence-list-extra" style="margin-top:1rem; list-style:none; padding:0;"></ul>
                    <p id="rsg-stop-sequence-placeholder-extra" style="text-align:center; opacity:0.7; padding:1rem;">Search and add stops to build the sequence.</p>
                </div>
                <div class="subsection" id="rsg-first-stop-times-container-extra" style="display:none;">
                    <h3 class="subsection-title">3. Set First Stop Departure Times</h3>
                    <label for="rsg-first-stop-times-input-extra">Enter times (HH:MM), separated by Tab, comma, or semicolon:</label>
                    <textarea id="rsg-first-stop-times-input-extra" class="schedule-generator-input" rows="3"></textarea>
                    <button id="rsg-pull-first-stop-times-button-extra" class="button neutral" style="margin-top:0.5rem;">Pull Existing Times for First Stop</button>
                </div>
                <div class="subsection">
                     <h3 class="subsection-title">4. Generate & Apply</h3>
                     <div class="form-field-group" style="display: flex; justify-content: space-between; align-items: center;">
                         <button id="rsg-generate-schedule-button-extra" class="button">Generate Preview</button>
                         <button id="rsg-add-to-working-schedule-button-extra" class="button save neutral" disabled>Add Preview to Live Schedule</button>
                         <button id="rsg-save-configuration-button-extra" class="button tertiary" disabled>Save This Configuration</button>
                         <button id="rsg-schedule-this-config-button-extra" class="button" style="background-color: #8e44ad;">Schedule This for Later...</button>
                    </div>
                    <p id="rsg-status-message-extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                    <div id="rsg-schedule-preview-container-extra" style="display:none; margin-top:1rem;">
                        <h4>Preview</h4>
                        <div>
                            <table id="rsg-preview-table-extra" style="width:100%; font-size:0.85em; border-collapse:collapse;">
                                <thead><tr style="background-color:rgba(0,0,0,0.3);"><th style="padding:0.4em;">Stop ID</th><th>Stop Name</th><th>Time</th><th>Route</th><th>Destination</th><th>Profile</th><th>Day Offset</th></tr></thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                </div>
                <div class="subsection">
                    <div style="display:flex; justify-content: space-between; align-items: center; flex-wrap:wrap;">
                        <h3 class="subsection-title" style="margin-bottom:0; border-bottom:none;">Saved Configurations</h3>
                        <div style="display:flex; align-items: center; gap: 0.5rem;">
                            <input type="checkbox" id="rsg-select-all-configs-checkbox-extra" style="margin-right:4px; vertical-align:middle;">
                            <label for="rsg-select-all-configs-checkbox-extra" style="font-size:0.9em;">Select All</label>
                            <button id="rsg-schedule-selected-configs-button-extra" class="button" style="background-color: #16a085;">Schedule Selected...</button>
                        </div>
                    </div>
                    <p id="rsg-load-status-message-extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                    <div id="rsg-saved-configs-list-extra"></div>
                </div>
            </div>
            
            <div id="route-profile-deletion-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Route Profile Deletion</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">Delete all schedule data associated with a specific operating profile for a given route and destination.</p>
                <div class="subsection">
                    <h3 class="subsection-title">1. Select Target</h3>
                    <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
                        <div>
                            <label for="rpd-route-name-select-extra">Route:</label>
                            <select id="rpd-route-name-select-extra" class="schedule-generator-input"></select>
                            <input type="text" id="rpd-route-name-input-extra" class="schedule-generator-input" style="margin-top:0.5rem;" placeholder="Or type route name...">
                        </div>
                        <div>
                            <label for="rpd-destination-name-select-extra">Destination:</label>
                             <div style="display:flex; align-items:center;">
                                <select id="rpd-destination-name-select-extra" class="schedule-generator-input" style="flex-grow:1;"></select>
                                <button id="rpd-clear-destination-button-extra" class="button small-action neutral" style="margin-left:5px; display:none;"></button>
                            </div>
                            <input type="text" id="rpd-destination-name-input-extra" class="schedule-generator-input" style="margin-top:0.5rem;" placeholder="Or type destination...">
                        </div>
                    </div>
                </div>
                <div class="subsection" style="margin-top:1.5rem;">
                    <h3 class="subsection-title">2. Select Profile(s) to Delete</h3>
                    <div id="rpd-profile-list-container-extra"></div>
                    <button id="rpd-delete-profiles-button-extra" class="button secondary" style="margin-top:1rem;">Delete Selected Profile(s)</button>
                    <p id="rpd-status-message-extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>
            </div>
        
            <div id="view-departures-section_extra" class="tool-content-section section" style="display:none;">
                <h2>View Departures by Stop (Today)</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">Select a stop to see all scheduled departures for today's operating profile.</p>
                <div class="subsection">
                    <label for="selectStopForDeparturesView_extra">Select Stop:</label>
                    <select id="selectStopForDeparturesView_extra" class="schedule-generator-input"></select>
                </div>
                <div class="subsection" style="margin-top:1.5rem;">
                    <h3 class="subsection-title">Departures</h3>
                    <ul id="stopDeparturesList_extra" style="list-style: none; padding: 0;"></ul>
                    <p id="noDeparturesForStopMessage_extra" style="display:none;"></p>
                </div>
            </div>
        
            <div id="timetable-exporter-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Timetable Exporter</h2>
                 <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">Export a summarized timetable for a specific route to a PDF document.</p>
                <div class="subsection">
                    <div class="form-grid" style="grid-template-columns: 3fr 1fr; align-items:end;">
                        <div>
                            <label for="tte-routeName-select-extra">Route Name:</label>
                            <select id="tte-routeName-select-extra" class="schedule-generator-input"></select>
                            <input type="text" id="tte-routeName-input-extra" class="schedule-generator-input" style="margin-top:0.5rem;" placeholder="Or type route name...">
                        </div>
                        <button id="tte-downloadTimetable-button-extra" class="button">Download Summarized PDF</button>
                    </div>
                    <p id="tte-status-message-extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>
            </div>
            
            <div id="scheduled-route-updates-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Scheduled Tasks</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">Review, manage, and execute pending or errored timetable updates and route deletions.</p>
                <div class="subsection">
                    <h3 class="subsection-title">Master Controls</h3>
                    <button id="sru-refresh-list-button-extra" class="button neutral">Refresh Task List</button>
                    <button id="sru-cancel-all-pending-updates-globally-button-extra" class="button secondary" style="background-color: #9A1111;">Cancel ALL Pending Timetable Updates (Global)</button>
                     <p id="sru-cancel-all-global-status-message-extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>
                <div class="subsection">
                    <h3 class="subsection-title" style="color:#2ECC71;">Batch Apply All Tasks for a Specific Go-Live Time</h3>
                    <div id="sru-batch-golive-radios-container-extra" style="margin-bottom:1rem;"></div>
                    <button id="sru-apply-all-for-time-button-extra" class="button save" disabled>Apply All for Selected Go-Live Time</button>
                    <p id="sru-apply-all-status-message-extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>
                <div id="sru-updates-list-container-extra" style="margin-top:1.5rem;"></div>
            </div>
            
            <div id="scheduled-route-deletion-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Schedule Route Deletion</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">Schedule a future date and time for an entire route and all its associated data to be deleted.</p>
                <div class="subsection">
                    <div class="form-grid" style="grid-template-columns: 2fr 1.5fr 1fr; align-items:end;">
                         <div>
                            <label for="srd-routeName-select-extra">Route Name:</label>
                            <select id="srd-routeName-select-extra" class="schedule-generator-input"></select>
                            <input type="text" id="srd-routeName-input-extra" class="schedule-generator-input" style="margin-top:0.5rem;" placeholder="Or type route name...">
                        </div>
                        <div>
                            <label for="srd-go-live-datetime-input-extra">Deletion Date & Time:</label>
                            <input type="datetime-local" id="srd-go-live-datetime-input-extra" class="schedule-generator-input">
                        </div>
                        <button id="srd-schedule-deletion-button-extra" class="button secondary">Schedule Deletion</button>
                    </div>
                    <p id="srd-status-message-extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>
            </div>
        
            <div id="config-data-section_extra" class="tool-content-section section" style="display:none;">
                <h2>View/Edit Config Data</h2>
                <div class="subsection">
                    <h3 class="subsection-title">School Holiday Periods</h3>
                    <div id="school-holidays-display-extra"></div>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr 2fr auto; align-items: end; margin-top: 1rem; border-top: 1px solid rgba(127,140,141,0.2); padding-top: 1rem;">
                        <input type="hidden" id="sh-editing-id-extra">
                        <div>
                            <label for="sh-start-date-input-extra">Start Date</label>
                            <input type="date" id="sh-start-date-input-extra" class="schedule-generator-input">
                        </div>
                        <div>
                            <label for="sh-end-date-input-extra">End Date</label>
                            <input type="date" id="sh-end-date-input-extra" class="schedule-generator-input">
                        </div>
                        <div>
                            <label for="sh-description-input-extra">Description</label>
                            <input type="text" id="sh-description-input-extra" placeholder="e.g., Summer Holidays 2025" class="schedule-generator-input">
                        </div>
                        <div style="display:flex; gap: 0.5rem;">
                            <button id="sh-save-button-extra" class="button save">Save/Add Period</button>
                            <button id="sh-clear-form-button-extra" class="button neutral" style="display:none;">Clear</button>
                        </div>
                    </div>
                     <p id="sh-status-message-extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>
                <div class="subsection">
                    <h3 class="subsection-title">Operating Profiles List</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1em;">Manage the master list of operating profiles available throughout the tools.</p>
                    <div id="op-profiles-list-extra" style="max-height: 250px; overflow-y: auto; margin-bottom:1rem;"></div>
                     <div class="form-grid" style="grid-template-columns: 2fr auto; align-items: end; border-top: 1px solid rgba(127,140,141,0.2); padding-top: 1rem;">
                         <div>
                            <label for="op-profile-input-extra">New Profile Name:</label>
                            <input type="text" id="op-profile-input-extra" class="schedule-generator-input" placeholder="e.g., Sunday Bank Holiday">
                        </div>
                        <button id="op-profile-add-button-extra" class="button save">Add Profile</button>
                    </div>
                    <p id="op-profiles-status-extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>
            </div>
        
            <div id="calendar-view-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Events Calendar</h2>
                <div class="calendar-tool-header">
                    <button id="cv-prev-month-btn_extra" class="button neutral"> Previous Month</button>
                    <h3 id="cv-month-year-display_extra" class="subsection-title" style="margin:0; border:none;">Month Year</h3>
                    <button id="cv-next-month-btn_extra" class="button neutral">Next Month </button>
                </div>
                <div class="calendar-grid-container-extra">
                    <div id="events-calendar-grid_extra"></div>
                </div>
                <div class="subsection" id="calendar-day-details_extra">
                     <p>Click on a day to see details.</p>
                </div>
            </div>
        
            <div id="curtailment-config-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Operational Points Management</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Define the official, pre-approved points where a service can be curtailed (short-turned). These points will then be available in the Live Trip Intervention tool.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">Define Curtailment Points</h3>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                        <div>
                            <label for="op-points-route-select-extra">Route:</label>
                            <select id="op-points-route-select-extra" class="schedule-generator-input"></select>
                        </div>
                        <div>
                            <label for="op-points-dest-select-extra">Destination:</label>
                            <select id="op-points-dest-select-extra" class="schedule-generator-input"></select>
                        </div>
                    </div>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr 1fr auto; align-items: end; margin-top: 1rem;">
                        <div>
                            <label for="op-points-last-stop-select-extra">Select Last Stop (Curtailment Point):</label>
                            <select id="op-points-last-stop-select-extra" class="schedule-generator-input"></select>
                        </div>
                        <div>
                            <label for="op-points-return-origin-select-extra">Return Journey Origin Stop:</label>
                            <select id="op-points-return-origin-select-extra" class="schedule-generator-input"></select>
                        </div>
                        <div>
                            <label for="op-points-dest-name-input-extra">New Destination Name Display:</label>
                            <input type="text" id="op-points-dest-name-input-extra" class="schedule-generator-input" placeholder="e.g., Oswald Road">
                        </div>
                        <div style="display:flex; gap: 0.5rem;">
                            <button id="op-points-add-btn-extra" class="button save">Add Point</button>
                            <button id="op-points-copy-from-route-btn-extra" class="button tertiary">Copy From...</button>
                        </div>
                    </div>
                    <p id="op-points-status-message-extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>
                <div class="subsection" style="margin-top: 1.5rem;">
                    <h3 class="subsection-title">Currently Defined Curtailment Points</h3>
                    <div id="op-points-list-extra">
                        <p>Select a route and destination to view its defined curtailment points.</p>
                    </div>
                </div>
            </div>
            
            <div id="trip-curtailment-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Live Trip Intervention Tool</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Select a service to view all of today's trips. You can then manually curtail a specific trip at an officially-defined point.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">1. Select Service</h3>
                    <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); align-items: end;">
                        <div>
                            <label for="curtail-route-select-extra">Route:</label>
                            <select id="curtail-route-select-extra" class="schedule-generator-input"></select>
                        </div>
                        <div>
                            <label for="curtail-dest-select-extra">Destination:</label>
                            <select id="curtail-dest-select-extra" class="schedule-generator-input"></select>
                        </div>
                        <div>
                            <label for="curtail-profile-display-extra">Today's Operating Profile:</label>
                            <input type="text" id="curtail-profile-display-extra" class="schedule-generator-input" readonly>
                        </div>
                        <div>
                            <button id="curtail-fetch-trips-btn-extra" class="button" style="width:100%;">Fetch Trips</button>
                        </div>
                    </div>
                </div>
                <div class="subsection" style="margin-top: 2rem;">
                    <h3 class="subsection-title">2. Upcoming & In-Service Trips Today</h3>
                    <p id="curtail-status-message-extra" style="min-height:1.2em; margin-bottom:0.5rem;"></p>
                    <div id="curtail-trip-list-container-extra" style="max-height: 600px; overflow-y: auto;">
                        <p>Please select a service above and fetch trips.</p>
                    </div>
                </div>
            </div>

        </div> 
        
        <div id="rsg-paste-adjustments-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content">
                <h4>Paste Time Adjustments</h4>
                <div class="form-field-group">
                    <label for="rsg-paste-adj-textarea-extra">Paste a list of numbers (e.g., +1, 2, 5), one per line. They will be applied sequentially to the stop sequence.</label>
                    <textarea id="rsg-paste-adj-textarea-extra" class="schedule-generator-input" rows="10" style="margin-top: 0.5rem;"></textarea>
                </div>
                <p id="rsg-paste-adj-modal-status-extra" style="min-height:1.2em;"></p>
                <div class="rsg-modal-actions">
                    <button id="rsg-paste-adj-cancel-button-extra" class="button neutral">Cancel</button>
                    <button id="rsg-paste-adj-apply-button-extra" class="button save">Apply</button>
                </div>
            </div>
        </div>
        
        <div id="rsg-save-config-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content">
                <h4>Save Configuration</h4>
                <div class="form-field-group">
                    <label for="rsg-config-name-input-extra">Configuration Name:</label>
                    <input type="text" id="rsg-config-name-input-extra" class="schedule-generator-input">
                </div>
                <p id="rsg-save-config-modal-status-extra" style="min-height:1.2em;"></p>
                <div class="rsg-modal-actions">
                    <button id="rsg-save-config-cancel-button-extra" class="button neutral">Cancel</button>
                    <button id="rsg-save-config-confirm-button-extra" class="button save">Save</button>
                </div>
            </div>
        </div>
        <div id="rsg-copy-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content">
                <h4>Copy From Existing Schedule</h4>
                <div class="form-field-group">
                    <label for="rsg-copy-source-routeName-select-extra">Source Route:</label>
                    <select id="rsg-copy-source-routeName-select-extra" class="schedule-generator-input"></select>
                </div>
                 <div class="form-field-group">
                    <label for="rsg-copy-source-destinationName-select-extra">Source Destination:</label>
                    <select id="rsg-copy-source-destinationName-select-extra" class="schedule-generator-input"></select>
                </div>
                <div class="form-field-group">
                    <label for="rsg-copy-source-operatingProfile-select-extra">Source Operating Profile:</label>
                    <select id="rsg-copy-source-operatingProfile-select-extra" class="schedule-generator-input"></select>
                </div>
                <p id="rsg-copy-modal-status-extra" style="min-height:1.2em;"></p>
                 <div class="rsg-modal-actions">
                    <button id="rsg-copy-modal-cancel-button-extra" class="button neutral">Cancel</button>
                    <button id="rsg-copy-modal-action-button-extra" class="button save">Copy Data</button>
                </div>
            </div>
        </div>
        <div id="rsg-schedule-datetime-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content">
                <h4>Schedule Go-Live Time</h4>
                <div class="form-field-group">
                    <label for="rsg-go-live-datetime-input-extra">Select Date and Time for this schedule to go live:</label>
                    <input type="datetime-local" id="rsg-go-live-datetime-input-extra" class="schedule-generator-input">
                </div>
                 <p id="rsg-schedule-datetime-modal-status-extra" style="min-height:1.2em;"></p>
                 <div class="rsg-modal-actions">
                    <button id="rsg-schedule-datetime-cancel-button-extra" class="button neutral">Cancel</button>
                    <button id="rsg-schedule-datetime-confirm-button-extra" class="button save">Confirm & Schedule</button>
                </div>
            </div>
        </div>
        <div id="sru-cancel-route-time-select-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content">
                <h4 id="sru-cancel-modal-title-extra">Cancel Updates</h4>
                <p id="sru-cancel-modal-route-info-extra" style="margin-bottom:1rem;"></p>
                <div class="form-field-group">
                    <label>Select Go-Live Time(s) to Cancel:</label>
                     <div style="margin: 0.5rem 0;">
                        <input type="checkbox" id="sru-cancel-modal-select-all-times-extra" style="margin-right:8px;">
                        <label for="sru-cancel-modal-select-all-times-extra">Select All</label>
                    </div>
                    <div id="sru-cancel-modal-checkboxes-container-extra" style="max-height: 200px; overflow-y: auto; padding: 0.5rem; border: 1px solid #567a9a; border-radius: 4px;">
                        </div>
                </div>
                <p id="sru-cancel-modal-status-extra" style="min-height:1.2em;"></p>
                 <div class="rsg-modal-actions">
                    <button id="sru-cancel-modal-cancel-button-extra" class="button neutral">Close</button>
                    <button id="sru-cancel-modal-confirm-button-extra" class="button secondary">Cancel Selected Update(s)</button>
                </div>
            </div>
        </div>
        <div id="rsg-replace-stop-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content">
                <h4 id="rsg-replace-stop-modal-title-extra">Replace Stop</h4>
                <p id="rsg-replace-stop-modal-info-extra" style="margin-bottom: 1rem;"></p>
                <div class="form-field-group">
                    <label for="rsg-replace-stop-search-input-extra">Search for new stop:</label>
                    <input type="text" id="rsg-replace-stop-search-input-extra" class="schedule-generator-input" placeholder="Search by name or ID...">
                    <div id="rsg-replace-stop-search-results-extra"></div>
                </div>
                 <p id="rsg-replace-stop-modal-status-extra" style="min-height:1.2em;"></p>
                 <div class="rsg-modal-actions">
                    <button id="rsg-replace-stop-modal-cancel-button-extra" class="button neutral">Cancel</button>
                </div>
            </div>
        </div>

        <div id="curtail-intervention-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content">
                <h4 id="curtail-modal-title-extra">Select Curtailment Point</h4>
                <div id="curtail-modal-options-container-extra" class="form-field-group">
                    </div>
                <div class="rsg-modal-actions">
                    <button id="curtail-modal-cancel-button-extra" class="button neutral">Cancel</button>
                </div>
            </div>
        </div>

        <div id="op-copy-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content">
                <h4 id="op-copy-modal-title-extra">Copy Curtailment Points</h4>
                <div class="form-field-group">
                    <label for="op-copy-source-route-select-extra">From Route:</label>
                    <select id="op-copy-source-route-select-extra" class="schedule-generator-input"></select>
                </div>
                 <div class="form-field-group">
                    <label for="op-copy-source-dest-select-extra">From Destination:</label>
                    <select id="op-copy-source-dest-select-extra" class="schedule-generator-input"></select>
                </div>
                <div class="form-field-group">
                    <p>Eligible points to copy:</p>
                    <div id="op-copy-eligible-points-container-extra" style="padding: 0.5rem; border: 1px solid #567a9a; border-radius: 4px;">
                    </div>
                </div>
                <p id="op-copy-modal-status-extra" style="min-height:1.2em;"></p>
                <div class="rsg-modal-actions">
                    <button id="op-copy-modal-cancel-button-extra" class="button neutral">Cancel</button>
                    <button id="op-copy-modal-confirm-button-extra" class="button save">Copy Selected Points</button>
                </div>
            </div>
        </div>

    </div>
<script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";
      import { getMessaging, getToken, onMessage } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-messaging.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s", // Replace with your actual Firebase API Key
        authDomain: "omsi-c5505.firebaseapp.com", // Replace with your actual Firebase Auth Domain
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app", // Replace with your actual Firebase Database URL
        projectId: "omsi-c5505", // Replace with your actual Firebase Project ID
        storageBucket: "omsi-c5505.appspot.com", // Replace with your actual Firebase Storage Bucket
        messagingSenderId: "503595375440", // Replace with your actual Firebase Messaging Sender ID
        appId: "1:503595375440:web:356be6684b77ff5909ea55", // Replace with your actual Firebase App ID
        measurementId: "G-VN7X65V3F9" // Replace with your actual Firebase Measurement ID
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);
      const messaging = getMessaging(app);

      window.firebaseOMSI = {
          database: database, auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut,
          messaging: messaging, // Expose the initialized messaging object
          fcmGetToken: getToken, // Expose the getToken function
          fcmOnMessage: onMessage // Expose the onMessage function
      };
      document.dispatchEvent(new CustomEvent('firebaseReady', { detail: window.firebaseOMSI }));
    </script>
<script>
// --- Global State Variables ---
        let rsg_configKeyToRename_extra = null;
        let currentUser_extra = null;
        let pageSpecificSettings = {};
        let rsg_currentlyEditingConfigKey_extra = null;
        let rsg_currentlyEditingConfigDisplayName_extra = null;
        let rsg_isDirty = false;
	let serviceTerminusMappings_extra = {};
	let cv_currentDisplayDate_extra = new Date();
        let rsg_batchScheduleItems = [];
	let massCurtailments_data = {};
        let allDefinedStops_data = {};
	let dpo_selectedRoutes_extra = []; // New: Stores routes selected for DPO override
        let dpo_currentOverridesForSelectedDate = {}; // New: Stores the route-specific overrides for the currently selected date.
        let rsg_indexOfStopToReplace_extra = -1;
        let sruCancelModalContext = { routeName: null };
        let scheduledRouteDeletions_extra = {};
	let cachedScheduledTasksHTML_extra = null;
	let cachedBatchRadiosHTML_extra = null;
	let isScheduledTasksCacheValid_extra = false;
	let operationalOverrides_data = {};
        let stopToServingRoutesMap_extra = new Map();
        let ukBankHolidaysData_extra = { dates: [], titles: {} };
        let schoolHolidayDateRanges_extra = [];

        let currentWorkingSchedule_extra = []; // This will be populated by flattening the new structure on load
        let closedStopIDs_extra = [];
        let globalCustomRouteColours_extra = {};
        let stopSpecificRouteColours_extra = {};
        let uniqueStopsMasterList_extra = [];
        let processedExcelStopsData_extra = [];
        let rsg_selectedStops_extra = [];
        let rsg_generatedPreviewEntries_extra = [];
        let rsg_loadedConfigs_extra = {};
	let todayKeyTripEvents_extra = []; // Stores { lineName, destinationName, originStopName, departureTime, departureTimeObj, type: 'first'|'last' }
	let shownTripAlerts_extra = {};    // Tracks shown alerts: key = "Route|Dest|Type|Time", value = true
	let lastAlertDataPreparedDate_extra = null; // To know when to refresh todayKeyTripEvents_extra
	let tripAlertIntervalId_extra = null; // To store the setInterval ID
        let rsg_lastLoadedRouteName_extra = null;
        let rsg_lastLoadedDestName_extra = null;
        let rsg_lastLoadedOpProfile_extra = null;
        let rsg_draggedItemIndex_extra = null;
	let rsg_selectedRoute_extra = null; // Stores the currently selected route for RSG
        let scheduledRouteUpdates_extra = {};
	let RSG_OPERATING_PROFILES_LIST = [ // This will now be populated from Firebase or seeded with these defaults
    "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su",
    "MF",
    "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MFSch",
    "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MFNSD",
    "Christmas Eve", "Christmas Day", "Boxing Day", "New Years Eve", "New Years Day", "Special", "SpMo", "SpTu", "SpWe",
    "SpTh", "SpFr", "SpSa", "SpSu"
];



        // --- Firebase Path Constants ---
        const FB_PATH_PAGE_EXTRA_SETTINGS = '/settings/extraModulesPageSettings';
        const FB_PATH_OPERATIONAL_OVERRIDES = '/operationalOverrides';
	const FB_PATH_MASS_CURTAILMENTS = '/liveServiceInterventions/massCurtailments';
        const FB_PATH_SCHEDULED_DELETIONS = '/scheduledRouteDeletions';
        const FB_PATH_SCHEDULES_BY_ROUTE = '/liveSchedule/schedulesByRoute'; // New path for structured schedule data
	const FB_PATH_CURTAILMENT_POINTS = '/operationalSettings/curtailmentPoints';
	const FB_PATH_LIVE_INTERVENTIONS = '/liveServiceInterventions/curtailments';
	const FB_PATH_SERVICE_TERMINUS_MAPPINGS = '/settings/serviceTerminusMappings';
        const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
        const FB_PATH_APPSTATE_LAST_UPDATED = '/appState/scheduleLastUpdated';
        const FB_PATH_APPSTATE_CLOSED_STOPS = '/appState/closedStopIDs';
        const FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS = '/settings/customRouteColours';
        const FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS = '/settings/stopSpecificRouteColours';
        const FB_PATH_RSG_CONFIGS = '/rsgConfigs';
        const FB_PATH_ALL_DEFINED_STOPS = '/allDefinedStops';
        const FB_PATH_SCHEDULED_UPDATES = '/scheduledUpdates';
	const ALERT_LEAD_TIME_MINUTES = 15; // Notify 15 minutes before departure
	const ALERT_CHECK_INTERVAL_MS = 30 * 1000; // Check every 30 seconds (adjust as needed)
        const FB_PATH_SCHEDULED_ROUTE_UPDATES = '/scheduledRouteUpdates';
        const BANK_HOLIDAY_CACHE_DURATION_MS = 24 * 60 * 60 * 1000;
	const FB_PATH_EDITABLE_OP_PROFILES = '/settings/operatingProfilesList';
	const FB_PATH_SCHOOL_HOLIDAYS = '/settings/schoolHolidayRanges';
	const DEFAULT_SCHOOL_HOLIDAY_RANGES = [
    { id: 'sh-20250524', start: '2025-05-24', end: '2025-06-01', description: "Summer half term 2025" },
    { id: 'sh-20250719', start: '2025-07-19', end: '2025-09-02', description: "Summer holidays 2025" },
    { id: 'sh-20251025', start: '2025-10-25', end: '2025-11-02', description: "Autumn half term 2025" },
    { id: 'sh-20251220', start: '2025-12-20', end: '2026-01-04', description: "Christmas 2025/26" },
    { id: 'sh-20260214', start: '2026-02-14', end: '2026-02-22', description: "Spring half term 2026" },
    { id: 'sh-20260403', start: '2026-04-03', end: '2026-04-20', description: "Easter 2026" },
    { id: 'sh-20260523', start: '2026-05-23', end: '2026-05-31', description: "Summer half term 2026" },
    { id: 'sh-20260718', start: '2026-07-18', end: '2026-09-02', description: "Summer holidays 2026" },
    { id: 'sh-20261024', start: '2026-10-24', end: '2026-11-01', description: "Autumn half term 2026" },
    { id: 'sh-20261219', start: '2026-12-19', end: '2027-01-04', description: "Christmas 2026/27" },
    { id: 'sh-20270213', start: '2027-02-13', end: '2027-02-21', description: "Spring half term 2027" },
    { id: 'sh-20270326', start: '2027-03-26', end: '2027-04-13', description: "Easter 2027" },
    { id: 'sh-20270529', start: '2027-05-29', end: '2027-06-06', description: "Summer half term 2027" },
    { id: 'sh-20270722', start: '2027-07-22', end: '2027-08-31', description: "Summer holidays 2027" }
];


        // --- DOM Elements ---
        const tteRouteNameSelect_el_extra = document.getElementById('tte-routeName-select-extra');
        const tteRouteNameInput_el_extra = document.getElementById('tte-routeName-input-extra');
	const dpoSelectAllRoutesButton_el_extra = document.getElementById('dpo-select-all-routes-button-extra');
        const tteDownloadTimetableButton_el_extra = document.getElementById('tte-downloadTimetable-button-extra');
        const tteStatusMessage_el_extra = document.getElementById('tte-status-message-extra');
	const selectStopForDeparturesView_extra = document.getElementById('selectStopForDeparturesView_extra');
        const rsgSelectAllConfigsCheckbox_el_extra = document.getElementById('rsg-select-all-configs-checkbox-extra');
	const rsgOpenPasteAdjModalButton_el_extra = document.getElementById('rsg-open-paste-adj-modal-button-extra');
const rsgPasteAdjModal_el_extra = document.getElementById('rsg-paste-adjustments-modal-extra');
const rsgPasteAdjTextarea_el_extra = document.getElementById('rsg-paste-adj-textarea-extra');
const rsgPasteAdjApplyButton_el_extra = document.getElementById('rsg-paste-adj-apply-button-extra');
const rsgPasteAdjCancelButton_el_extra = document.getElementById('rsg-paste-adj-cancel-button-extra');
const rsgPasteAdjModalStatus_el_extra = document.getElementById('rsg-paste-adj-modal-status-extra');
	const opPointsRouteSelect_el_extra = document.getElementById('op-points-route-select-extra');
const opPointsDestSelect_el_extra = document.getElementById('op-points-dest-select-extra');
const opPointsLastStopSelect_el_extra = document.getElementById('op-points-last-stop-select-extra');
const opPointsDestNameInput_el_extra = document.getElementById('op-points-dest-name-input-extra');
const opPointsAddBtn_el_extra = document.getElementById('op-points-add-btn-extra');
const opPointsList_el_extra = document.getElementById('op-points-list-extra');
const opPointsStatusMsg_el_extra = document.getElementById('op-points-status-message-extra');
const curtailRouteSelect_el_extra = document.getElementById('curtail-route-select-extra');
const curtailDestSelect_el_extra = document.getElementById('curtail-dest-select-extra');
const curtailProfileDisplay_el_extra = document.getElementById('curtail-profile-display-extra');
const curtailFetchTripsBtn_el_extra = document.getElementById('curtail-fetch-trips-btn-extra');
const curtailTripListContainer_el_extra = document.getElementById('curtail-trip-list-container-extra');
const curtailStatusMsg_el_extra = document.getElementById('curtail-status-message-extra');
const curtailInterventionModal_el_extra = document.getElementById('curtail-intervention-modal-extra');
const curtailModalCancelBtn_el_extra = document.getElementById('curtail-modal-cancel-button-extra');
	
	const KEY_DEPARTURES_REFRESH_INTERVAL_MS = 60 * 1000;
        const rsgCopySourceOpProfileSelect_el_extra = document.getElementById('rsg-copy-source-operatingProfile-select-extra');
        const rsgReplaceStopModal_el_extra = document.getElementById('rsg-replace-stop-modal-extra');
const rsgReplaceStopModalTitle_el_extra = document.getElementById('rsg-replace-stop-modal-title-extra');
const rsgReplaceStopModalInfo_el_extra = document.getElementById('rsg-replace-stop-modal-info-extra');
const rsgReplaceStopSearchInput_el_extra = document.getElementById('rsg-replace-stop-search-input-extra');
const rsgReplaceStopSearchResults_el_extra = document.getElementById('rsg-replace-stop-search-results-extra');
const rsgReplaceStopModalCancelButton_el_extra = document.getElementById('rsg-replace-stop-modal-cancel-button-extra');
        const serviceAnalyzerStopSelect_el_extra = document.getElementById('service-analyzer-stop-select-extra');
        const serviceAnalyzerStopInput_el_extra = document.getElementById('service-analyzer-stop-input-extra');
        const serviceAnalyzerStopSummary_el_extra = document.getElementById('service-analyzer-stop-summary-extra');

        const scdStopSelect_el_extra = document.getElementById('scd-stop-select-extra');
        const scdStopSearchInput_el_extra = document.getElementById('scd-stop-search-input-extra');
        const scdStopSearchResults_el_extra = document.getElementById('scd-stop-search-results-extra');
        const scdEventList_el_extra = document.getElementById('scd-event-list-extra');
        const scdNoEventsMessage_el_extra = document.getElementById('scd-no-events-message-extra');
        const scdStatusMessage_el_extra = document.getElementById('scd-status-message-extra');
	const authSection_el_extra = document.getElementById('auth-section');
        const loginFormContainer_el_extra = document.getElementById('login-form-container_extra');
        const adminLoginForm_el_extra = document.getElementById('adminLoginForm_extra');
        const inputEmail_el_extra = document.getElementById('inputEmail_extra');
        const inputPassword_el_extra = document.getElementById('inputPassword_extra');
        const authStatus_el_extra = document.getElementById('auth-status_extra');
        const logoutContainer_el_extra = document.getElementById('logout-container_extra');
        const loggedInUserEmailDisplay_el_extra = document.getElementById('loggedInUserEmail_extra');
        const topMenuBar_el_extra = document.getElementById('top-menu-bar_extra');
        const toolSectionsWrapper_el_extra = document.getElementById('tool-sections-wrapper_extra');
        const currentProfileDisplayContainer_el = document.getElementById('current-profile-display-container');
        const currentProfileDisplayElement_el = document.getElementById('current-profile-display');
        // Day Profile Override
        const overrideDateInput_el_extra = document.getElementById('overrideDate_extra');
        // REMOVED: const overrideProfileInput_el_extra = document.getElementById('overrideProfile_extra');
        const dpoStatusMessage_el_extra = document.getElementById('dpo-status-message-extra'); // Renamed from overrideStatusMessage_el_extra
        const selectedDateDisplay_el_extra = document.getElementById('selectedDateDisplay_extra');
        // REMOVED: const autoProfileForSelectedDate_el_extra = document.getElementById('autoProfileForSelectedDate_extra');
        // REMOVED: const currentOverrideForSelectedDate_el_extra = document.getElementById('currentOverrideForSelectedDate_extra');
        const activeOverridesList_el_extra = document.getElementById('activeOverridesList_extra');

        // NEW DPO ELEMENTS
        const dpoApplyOverrideToRoutesButton_el_extra = document.getElementById('dpo-apply-override-to-routes-button-extra');
        const dpoClearOverrideForRoutesButton_el_extra = document.getElementById('dpo-clear-override-for-routes-button-extra');
        const dpoRouteSelectionContainer_el_extra = document.getElementById('dpo-route-selection-container-extra');
        const dpoSelectedRoutesDisplay_el_extra = document.getElementById('dpo-selected-routes-display-extra');
        const dpoClearRouteSelectionButton_el_extra = document.getElementById('dpo-clear-route-selection-button-extra');
        const dpoCurrentOverridesList_el_extra = document.getElementById('dpo-current-overrides-list-extra');
        
        // Stop Management & Creation
        const selectNewStopIdFormat_el_extra = document.getElementById('selectNewStopIdFormat_extra');
        const inputNewStopId_el_extra = document.getElementById('inputNewStopId_extra');
        const newStopIdAvailability_el_extra = document.getElementById('newStopIdAvailability_extra');
        const inputNewStopName_el_extra = document.getElementById('inputNewStopName_extra');
        const inputNewStopDirection_el_extra = document.getElementById('inputNewStopDirection_extra');
        const buttonAddNewStop_el_extra = document.getElementById('buttonAddNewStop_extra');
        const addNewStopStatus_el_extra = document.getElementById('addNewStopStatus_extra');
        const fileInputBulkAddStops_el_extra = document.getElementById('fileInputBulkAddStops_extra');
        const fileNameBulkAddStops_el_extra = document.getElementById('fileNameBulkAddStops_extra');
        const buttonBulkAddNewStops_el_extra = document.getElementById('buttonBulkAddNewStops_extra');
        const bulkAddNewStopsStatus_el_extra = document.getElementById('bulkAddNewStopsStatus_extra');
        const masterStopListFilterInput_el_extra = document.getElementById('masterStopListFilterInput_extra');
        const refreshMasterStopListButton_el_extra = document.getElementById('refreshMasterStopListButton_extra');
        const masterStopListUL_el_extra = document.getElementById('masterStopListUL_extra');
        const masterStopListStatus_el_extra = document.getElementById('masterStopListStatus_extra');
        const applyMasterListStopIdChangesButton_el_extra = document.getElementById('applyMasterListStopIdChangesButton_extra');
        const masterListApplyChangesStatus_el_extra = document.getElementById('masterListApplyChangesStatus_extra');
        const exportUniqueStopsButton_el_extra = document.getElementById('exportUniqueStopsButton_extra');
        const findDuplicateStopsByNameDirButton_el_extra = document.getElementById('findDuplicateStopsByNameDirButton_extra');
        const duplicateStopsByNameDirResults_el_extra = document.getElementById('duplicateStopsByNameDirResults_extra');
        // Global Route Deletion
        // Corrected line
const globalRouteDeletionListContainer_el_extra = document.getElementById('globalRouteDeletionListContainer_extra');
        const deleteEntireRouteButton_el_extra = document.getElementById('deleteEntireRouteButton_el_extra');
        const deleteEntireRouteStatusMessage_el_extra = document.getElementById('deleteEntireRouteStatusMessage_el_extra');
        
	// Route Schedule Generator (RSG)
        // Removed: const rsgRouteNameSelect_el_extra = document.getElementById('rsg-routeName-select-extra'); // REMOVED as it's no longer a <select>
        const rsgRouteNameInput_el_extra = document.getElementById('rsg-routeName-input-extra'); // This now refers to the hidden input
        const rsgRouteSelectionContainer_el_extra = document.getElementById('rsg-route-selection-container-extra'); // NEW: Container for route tiles
        const rsgSelectedRouteDisplay_el_extra = document.getElementById('rsg-selected-route-display-extra'); // NEW: Element to display selected route name
        const rsgRoutesPlaceholder_el_extra = document.getElementById('rsg-routes-placeholder-extra'); // NEW: Placeholder for routes
        const rsgClearRouteSelectionButton_el_extra = document.getElementById('rsg-clear-route-selection-button-extra'); // NEW: Clear button for route selection
        //const rsgOperatingProfileInput_el_extra = document.getElementById('rsg-operatingProfile-input-extra'); // Keep this line if it's currently commented out in your file
        const rsgDestinationNameSelect_el_extra = document.getElementById('rsg-destinationName-select-extra');
        const rsgDestinationNameInput_el_extra = document.getElementById('rsg-destinationName-input-extra');
        const rsgStopSearchInput_el_extra = document.getElementById('rsg-stop-search-input-extra');
        const rsgStopSearchResults_el_extra = document.getElementById('rsg-stop-search-results-extra');
        const rsgStopSequenceList_el_extra = document.getElementById('rsg-stop-sequence-list-extra');
        const rsgStopSequencePlaceholder_el_extra = document.getElementById('rsg-stop-sequence-placeholder-extra');
        const rsgFirstStopTimesContainer_el_extra = document.getElementById('rsg-first-stop-times-container-extra');
        const rsgFirstStopTimesInput_el_extra = document.getElementById('rsg-first-stop-times-input-extra');
        const rsgGenerateScheduleButton_el_extra = document.getElementById('rsg-generate-schedule-button-extra');
        const rsgSaveConfigurationButton_el_extra = document.getElementById('rsg-save-configuration-button-extra');
        const rsgAddToWorkingScheduleButton_el_extra = document.getElementById('rsg-add-to-working-schedule-button-extra');
        const rsgStatusMessage_el_extra = document.getElementById('rsg-status-message-extra');
        const rsgSchedulePreviewContainer_el_extra = document.getElementById('rsg-schedule-preview-container-extra');
        const rsgPreviewTableBody_el_extra = document.getElementById('rsg-preview-table-extra')?.getElementsByTagName('tbody')[0];
        const rsgOpenCopyModalButton_el_extra = document.getElementById('rsg-open-copy-modal-button-extra');
        const rsgCopyModal_el_extra = document.getElementById('rsg-copy-modal-extra');
        const rsgCopySourceRouteNameSelect_el_extra = document.getElementById('rsg-copy-source-routeName-select-extra');
        // Removed: const rsgCopySourceRouteNameInput_el_extra = document.getElementById('rsg-copy-source-routeName-input-extra'); // This was removed in your current code, ensure it's not present if not used.
        const rsgCopySourceOpProfileInput_el_extra = document.getElementById('rsg-copy-source-operatingProfile-input-extra');
        const rsgCopySourceDestNameSelect_el_extra = document.getElementById('rsg-copy-source-destinationName-select-extra');
        // Removed: const rsgCopySourceDestNameInput_el_extra = document.getElementById('rsg-copy-source-destinationName-input-extra'); // This was removed in your current code, ensure it's not present if not used.
        const rsgCopyModalStatus_el_extra = document.getElementById('rsg-copy-modal-status-extra');
        const rsgCopyModalCancelButton_el_extra = document.getElementById('rsg-copy-modal-cancel-button-extra');
        const rsgCopyModalActionButton_el_extra = document.getElementById('rsg-copy-modal-action-button-extra');
       
	// Route Profile Deletion (RPD) - NEW
        const rpdRouteSelect_el_extra = document.getElementById('rpd-route-name-select-extra');
        const rpdRouteInput_el_extra = document.getElementById('rpd-route-name-input-extra');
        const rpdDestinationSelect_el_extra = document.getElementById('rpd-destination-name-select-extra');
        const rpdDestinationInput_el_extra = document.getElementById('rpd-destination-name-input-extra');
        const rpdClearDestinationButton_el_extra = document.getElementById('rpd-clear-destination-button-extra');
        const rpdProfileListContainer_el_extra = document.getElementById('rpd-profile-list-container-extra');
        const rpdDeleteProfilesButton_el_extra = document.getElementById('rpd-delete-profiles-button-extra');
        const rpdStatusMessage_el_extra = document.getElementById('rpd-status-message-extra');
        const srdRouteNameSelect_el_extra = document.getElementById('srd-routeName-select-extra');
const srdRouteNameInput_el_extra = document.getElementById('srd-routeName-input-extra');
const srdGoLiveDateTimeInput_el_extra = document.getElementById('srd-go-live-datetime-input-extra');
const srdScheduleDeletionButton_el_extra = document.getElementById('srd-schedule-deletion-button-extra');
const srdStatusMessage_el_extra = document.getElementById('srd-status-message-extra');
const rsgScheduleSelectedConfigsButton_el_extra = document.getElementById('rsg-schedule-selected-configs-button-extra');
const rsgScheduleThisConfigButton_el_extra = document.getElementById('rsg-schedule-this-config-button-extra');
const rsgScheduleDateTimeConfirmBtn = document.getElementById('rsg-schedule-datetime-confirm-button-extra');
const rsgScheduleDateTimeCancelBtn = document.getElementById('rsg-schedule-datetime-cancel-button-extra');
const rsgScheduleDateTimeModal = document.getElementById('rsg-schedule-datetime-modal-extra');
const sruBatchGoLiveRadiosContainer_el_extra = document.getElementById('sru-batch-golive-radios-container-extra');
const sruApplyAllForTimeButton_el_extra = document.getElementById('sru-apply-all-for-time-button-extra');
const sruApplyAllStatusMessage_el_extra = document.getElementById('sru-apply-all-status-message-extra');
// For the "Cancel Route Updates by Specific Time(s)" Modal
const sruCancelRouteTimeSelectModal_el_extra = document.getElementById('sru-cancel-route-time-select-modal-extra');
const sruCancelModalTitle_el_extra = document.getElementById('sru-cancel-modal-title-extra');
const sruCancelModalRouteInfo_el_extra = document.getElementById('sru-cancel-modal-route-info-extra');
const sruCancelModalCheckboxesContainer_el_extra = document.getElementById('sru-cancel-modal-checkboxes-container-extra');
const sruCancelModalSelectAllCheckbox_el_extra = document.getElementById('sru-cancel-modal-select-all-times-extra');
const sruCancelModalConfirmButton_el_extra = document.getElementById('sru-cancel-modal-confirm-button-extra');
const sruCancelModalCancelButton_el_extra = document.getElementById('sru-cancel-modal-cancel-button-extra');
const sruCancelModalStatus_el_extra = document.getElementById('sru-cancel-modal-status-extra');
let keyDeparturesIntervalId_extra = null;

// For the Global "Cancel ALL Pending Updates" Button
const sruCancelAllPendingUpdatesGloballyButton_el_extra = document.getElementById('sru-cancel-all-pending-updates-globally-button-extra');
const sruCancelAllGlobalStatusMessage_el_extra = document.getElementById('sru-cancel-all-global-status-message-extra');


        // --- Helper Functions ---
        function sanitizeFirebaseKey(text) {
            if (typeof text !== 'string') return '';
            // Replace forbidden characters with an underscore
            // Firebase forbids '.', '#', '$', '[', ']'
            return text.replace(/[.#$[\]]/g, '_');
        }

// Your VAPID Public Key - this is the key you provided earlier
const VAPID_PUBLIC_KEY = "BLrah0KLMfCtXL-rBj-epnPyXPDHszMFMyywyGky0nOpPpsbQNV03mNuuxeiw6Fcj44u20cphHBUW8WGGTVi7QI"; 

// Ensure VAPID_PUBLIC_KEY is defined globally at the top of your script block
// const VAPID_PUBLIC_KEY = "BLrah0KLMfCtXL-rBj-epnPyXPDHszMFMyywyGky0nOpPpsbQNV03mNuuxeiw6Fcj44u20cphHBUW8WGGTVi7QI"; 

function op_points_populateReturnOriginSelect() {
    const selectEl = document.getElementById('op-points-return-origin-select-extra');
    if (!selectEl) return;

    selectEl.innerHTML = '<option value="">-- Select Return Start Stop --</option>';
    if (!allDefinedStops_data || Object.keys(allDefinedStops_data).length === 0) {
        selectEl.innerHTML = '<option value="">No Stops Defined</option>';
        return;
    }

    const sortedStops = Object.values(allDefinedStops_data).sort((a,b) => (a.stopName || "").localeCompare(b.stopName));

    sortedStops.forEach(stop => {
        selectEl.add(new Option(`${stop.stopName} (${stop.stopID})`, stop.stopID));
    });
}

// In omsi_tools_extra.html

function setupFirebaseListeners_ExtraPage() {
    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        console.error("Firebase not ready, cannot set up listeners on Extra Tools page.");
        return;
    }
    const { database, dbOnValue, dbRef } = window.firebaseOMSI;

    // Listener for Mass Service Leg Curtailments
    const massCurtailmentsRef = dbRef(database, FB_PATH_MASS_CURTAILMENTS);
    dbOnValue(massCurtailmentsRef, (snapshot) => {
        console.log("[SLC Listener] Mass curtailment data updated from Firebase.");
        massCurtailments_data = snapshot.exists() ? snapshot.val() || {} : {};
        
        // Whenever the data changes, re-render the list of active curtailments
        if (typeof slc_renderActiveCurtailments === 'function') {
            slc_renderActiveCurtailments();
        }
    });

    console.log("Real-time Firebase listeners set up for Extra Tools page.");
}

// --- Functions for the Paste Adjustments Modal ---

/**
 * @description Opens the modal for pasting time adjustments. Validates that there's a sequence to apply to.
 */
function rsg_openPasteAdjModal_ExtraPage() {
    if (!rsg_selectedStops_extra || rsg_selectedStops_extra.length < 2) {
        if(rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Please build a sequence of at least two stops before pasting adjustments.";
            rsgStatusMessage_el_extra.style.color = '#f1c40f';
        }
        return;
    }
    if (rsgPasteAdjModal_el_extra) {
        if (rsgPasteAdjTextarea_el_extra) rsgPasteAdjTextarea_el_extra.value = '';
        if (rsgPasteAdjModalStatus_el_extra) rsgPasteAdjModalStatus_el_extra.textContent = '';
        rsgPasteAdjModal_el_extra.style.display = 'flex';
        if (rsgPasteAdjTextarea_el_extra) rsgPasteAdjTextarea_el_extra.focus();
    }
}

/**
 * @description Closes the modal for pasting time adjustments.
 */
function rsg_closePasteAdjModal_ExtraPage() {
    if (rsgPasteAdjModal_el_extra) {
        rsgPasteAdjModal_el_extra.style.display = 'none';
    }
}

/**
 * @description Parses the text from the modal's textarea and applies the numbers to the sequence.
 */
function rsg_applyPastedAdjustments_ExtraPage() {
    if (!rsgPasteAdjTextarea_el_extra || !rsgStopSequenceList_el_extra || !rsg_selectedStops_extra) {
        if(rsgPasteAdjModalStatus_el_extra) rsgPasteAdjModalStatus_el_extra.textContent = "Error: System components not ready.";
        return;
    }
    
    const pastedText = rsgPasteAdjTextarea_el_extra.value;
    const lines = pastedText.split(/\r?\n/).filter(line => line.trim() !== '');
    const numbersToApply = lines.map(line => parseInt(line.replace('+', ''), 10));

    const adjustmentInputs = rsgStopSequenceList_el_extra.querySelectorAll('.rsg-time-adjustment-input');

    if (adjustmentInputs.length === 0) {
        if(rsgPasteAdjModalStatus_el_extra) rsgPasteAdjModalStatus_el_extra.textContent = "No stops in the sequence to apply adjustments to.";
        return;
    }

    let appliedCount = 0;
    const loopLimit = Math.min(numbersToApply.length, adjustmentInputs.length);

    for (let i = 0; i < loopLimit; i++) {
        const number = numbersToApply[i];
        if (!isNaN(number) && number >= 0) {
            const inputElement = adjustmentInputs[i];
            const liElement = inputElement.closest('li');
            if(liElement) {
                const stopIndexInArray = parseInt(liElement.dataset.index, 10);
                if(rsg_selectedStops_extra[stopIndexInArray]) {
                    // Update the UI
                    inputElement.value = number;
                    // Update the data model
                    rsg_selectedStops_extra[stopIndexInArray].timeAdjustment = number;
                    appliedCount++;
                }
            }
        }
    }

    if (rsgPasteAdjModalStatus_el_extra) {
        rsgPasteAdjModalStatus_el_extra.textContent = `Applied ${appliedCount} of ${lines.length} adjustments.`;
        rsgPasteAdjModalStatus_el_extra.style.color = '#2ecc71';
    }

    rsg_isDirty = true;
    rsg_resetPreviewState("Time adjustments updated from paste. Please regenerate preview.", "info");
    rsg_updateRsgActionButtonsState();
    
    setTimeout(() => {
        rsg_closePasteAdjModal_ExtraPage();
    }, 1500);
}

async function getFCMTokenAndStore(serviceWorkerRegistration) {
    console.log("FCM DEBUG: Entering getFCMTokenAndStore. Attempting subscription with provided SW registration.");

    // This block is for robustness in case serviceWorkerRegistration is somehow invalid initially.
    // It's already good practice to ensure it's a valid object.
    if (!serviceWorkerRegistration || !(serviceWorkerRegistration instanceof ServiceWorkerRegistration)) {
        console.warn("FCM DEBUG: Invalid Service Worker Registration provided initially. Attempting recovery with navigator.serviceWorker.ready.");
        try {
            serviceWorkerRegistration = await navigator.serviceWorker.ready;
            if (!serviceWorkerRegistration) {
                console.error("FCM DEBUG: Recovery failed. navigator.serviceWorker.ready did not return a registration. Cannot proceed with token acquisition.");
                return;
            }
            console.log("FCM DEBUG: Recovered Service Worker Registration successfully via navigator.serviceWorker.ready.");
        } catch (err) {
            console.error("FCM DEBUG: Recovery attempt for Service Worker Registration failed:", err);
            return;
        }
    }

    // Now, ensure that the page itself is controlled by a service worker.
    // This is often the missing link causing the "no active service worker" error.
    if (!navigator.serviceWorker.controller) {
        console.warn("FCM DEBUG: Page not yet controlled by a Service Worker. Forcing reload to establish control.");
        // Reloading the page forces it to be controlled by the newly active SW.
        // This is disruptive, but often necessary for Push API to work immediately after activation.
        location.reload(); // This will cause the page to reload. The next load will have a controller.
        return; // Exit, as the page will reload and retry token acquisition on next load.
    }


    try {
        const messaging = window.firebaseOMSI.messaging;
        const fcmGetToken = window.firebaseOMSI.fcmGetToken;

        console.log("FCM DEBUG: Attempting fcmGetToken call.");

        // Introduce a small delay before attempting getToken().
        // This gives the browser's internal PushManager a moment to truly settle.
        // The AbortError often happens when the environment isn't *fully* ready, even if promises resolve.
        await new Promise(resolve => setTimeout(resolve, 500)); // Wait for 500ms

        const currentToken = await fcmGetToken(messaging, {
            serviceWorkerRegistration: serviceWorkerRegistration,
            vapidKey: VAPID_PUBLIC_KEY
        });

        if (currentToken) {
            console.log('FCM Registration Token:', currentToken);
            const { database, dbSet, dbRef } = window.firebaseOMSI;
            await dbSet(dbRef(database, `fcmTokens/${currentUser_extra.uid}/${currentToken}`), true);
            console.log('FCM token stored in Firebase for user:', currentUser_extra.uid);

            if (window.firebaseOMSI.fcmOnMessage) {
                window.firebaseOMSI.fcmOnMessage(messaging, (payload) => {
                    console.log('FCM DEBUG: *** FOREGROUND MESSAGE RECEIVED BY onMessage LISTENER *** ', payload);
                    const notificationTitle = payload.notification.title;
                    const notificationBody = payload.notification.body;
                    const notificationIcon = payload.notification.icon || '/live-tracker/assets/icons/icon-192x192.png';
                    if (typeof showTripAlertPopup_ExtraPage === 'function') {
                        showTripAlertPopup_ExtraPage(`${notificationTitle}: ${notificationBody}`, 'info');
                    } else {
                        console.warn("FCM DEBUG: showTripAlertPopup_ExtraPage function not found for foreground handling.");
                    }
                    if (typeof showNativeNotification === 'function') {
                        showNativeNotification(notificationTitle, notificationBody, notificationIcon);
                    } else {
                        console.warn("FCM DEBUG: showNativeNotification function not found for foreground handling.");
                    }
                });
            } else {
                console.warn("FCM DEBUG: window.firebaseOMSI.fcmOnMessage is not defined.");
            }

        } else {
            console.warn('FCM DEBUG: getToken returned null or undefined. No FCM registration token available. This can happen if permission is denied, VAPID key is wrong, or Firebase setup incomplete.');
        }
    } catch (err) {
        console.error('FCM DEBUG: An error occurred during FCM token acquisition process:', err);
        if (Notification.permission === 'granted') {
             alert('Error setting up push notifications: ' + err.message + '. Please ensure your browser supports them and try again.');
        } else if (Notification.permission === 'default') {
             alert('To receive alerts even when offline, please enable notifications when prompted by the browser.');
        }
    }
    console.log("FCM DEBUG: Exiting getFCMTokenAndStore.");
}

let definedCurtailmentPoints = {};
let activeTripsForCurtailment = [];

function op_points_populateRouteSelect() {
    const select = document.getElementById('op-points-route-select-extra');
    if (!select) return;
    const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))].filter(Boolean).sort(compareLineNames_ExtraPage);
    select.innerHTML = '<option value="">-- Select Route --</option>';
    uniqueRoutes.forEach(r => select.add(new Option(r, r)));
}

function op_points_updateCopyButtonState() {
    const targetRoute = document.getElementById('op-points-route-select-extra').value;
    const targetDest = document.getElementById('op-points-dest-select-extra').value;
    const copyButton = document.getElementById('op-points-copy-from-route-btn-extra');

    if (copyButton) {
        // The button is enabled only if both a route and a destination are selected.
        copyButton.disabled = !targetRoute || !targetDest;
    }
}

function op_points_populateDestSelect() {
    const routeSelect = document.getElementById('op-points-route-select-extra');
    const destSelect = document.getElementById('op-points-dest-select-extra');
    if (!routeSelect || !destSelect) return;

    const selectedRoute = routeSelect.value;
    // Reset the destination dropdown and clear the stop list that depends on it
    destSelect.innerHTML = '<option value="">--- Select Journey Variant ---</option>';
    op_points_populateLastStopSelect();

    if (!selectedRoute) return;

    // This is a regular expression to find "(from DDMMYY)" in the name
    const futureDatePattern = /\(from\s*\d{6}\)/;
    const matchingConfigs = [];

    // 1. Find all configs for the selected route
    for (const key in rsg_loadedConfigs_extra) {
        const config = rsg_loadedConfigs_extra[key];
        if (config.routeName === selectedRoute) {
            // 2. Filter out any configs that match the future-date pattern in their name
            if (config.userDisplayName && !futureDatePattern.test(config.userDisplayName)) {
                matchingConfigs.push({ key, ...config });
            }
        }
    }

    // Sort the valid, current configs alphabetically by their display name
    matchingConfigs.sort((a, b) => (a.userDisplayName || a.key).localeCompare(b.userDisplayName || b.key));

    // 3. Populate the dropdown using your custom names
    if (matchingConfigs.length > 0) {
        matchingConfigs.forEach(config => {
            const option = document.createElement('option');
            // The VALUE is the unique key to identify the exact schedule
            option.value = config.key;
            // The TEXT is your existing, descriptive name
            option.textContent = config.userDisplayName || config.key;
            destSelect.appendChild(option);
        });
    }

    // Automatically trigger the logic to populate the "Last Stop" select
    destSelect.dispatchEvent(new Event('change'));
}
function op_points_populateLastStopSelect() {
    const destSelect = document.getElementById('op-points-dest-select-extra');
    const lastStopSelect = document.getElementById('op-points-last-stop-select-extra');
    if (!destSelect || !lastStopSelect) return;

    // The value from the destination select is now the unique key of the RSG config
    const selectedConfigKey = destSelect.value;
    lastStopSelect.innerHTML = '<option value="">--- Select Last Stop ---</option>'; // Reset dropdown

    if (!selectedConfigKey) {
        return; // Exit if no specific journey is selected
    }

    // Directly look up the configuration using its unique key
    const matchingConfig = rsg_loadedConfigs_extra[selectedConfigKey];

    // If we found the config, populate the dropdown with its stop sequence
    if (matchingConfig && matchingConfig.stopSequence) {
        // Exclude the very last stop, as a curtailment cannot end at the final destination
        const stopsToShow = matchingConfig.stopSequence.slice(0, -1);

        stopsToShow.forEach(stop => {
            const option = document.createElement('option');
            option.value = stop.stopID;
            option.textContent = `${stop.stopName} (${stop.stopID})`;
            lastStopSelect.appendChild(option);
        });
    }
}

// --- START: Mass Route Curtailment Functions ---

function mrc_setupToolForRoute() {
    const selectedRoute = document.getElementById('curtail-route-select-extra').value;
    const mrcSection = document.getElementById('mass-route-curtailment-subsection-extra');
    
    if (!selectedRoute) {
        mrcSection.style.display = 'none';
        return;
    }
    
    mrcSection.style.display = 'block';

    // Reset form fields
    document.getElementById('mrc-term-stop-search-input-extra').value = '';
    document.getElementById('mrc-selected-term-stop-display-extra').textContent = 'Selected: (None)';
    document.getElementById('mrc-selected-term-stop-id-extra').value = '';
    document.getElementById('mrc-new-dest-display-name-extra').value = '';
    document.getElementById('mrc-start-time-input-extra').value = '';
    document.getElementById('mrc-end-time-input-extra').value = '';
    document.getElementById('mrc-status-message-extra').textContent = '';

    mrc_renderActiveCurtailments();
}

function mrc_renderActiveCurtailments() {
    const displayDiv = document.getElementById('mrc-active-display-extra');
    const formDiv = document.getElementById('mrc-form-extra');
    const selectedRoute = document.getElementById('curtail-route-select-extra').value;
    
    let activeCurtailment = null;
    let activeCurtailmentId = null;
    const now = new Date();

    for (const key in massCurtailments_data) {
        const mc = massCurtailments_data[key];
        if (mc.routeName === selectedRoute) {
            const endTime = new Date(mc.endTime);
            if (endTime > now) {
                activeCurtailment = mc;
                activeCurtailmentId = key;
                break;
            }
        }
    }

    if (activeCurtailment) {
        displayDiv.style.display = 'block';
        formDiv.style.display = 'none';
        const endTime = new Date(activeCurtailment.endTime);
        displayDiv.innerHTML = `
            <p style="margin-top:0; font-weight:bold; color: #f39c12;">This route is currently curtailed!</p>
            <p style="font-size:0.9em; margin-bottom:0.5em;">All services are terminating at <strong>${activeCurtailment.newTerminusDisplayName} (${activeCurtailment.newTerminusStopId})</strong>.</p>
            <p style="font-size:0.9em; margin-bottom:1rem;">This is active until: <strong>${endTime.toLocaleString()}</strong>.</p>
            <button class="button save" onclick="mrc_handleCancelCurtailment('${activeCurtailmentId}')">Lift Curtailment Now</button>
        `;
    } else {
        displayDiv.style.display = 'none';
        formDiv.style.display = 'block';
    }
}

function mrc_handleStopSearch() {
    const searchInput = document.getElementById('mrc-term-stop-search-input-extra');
    const resultsDiv = document.getElementById('mrc-term-stop-search-results-extra');
    const searchTerm = searchInput.value.toLowerCase().trim();
    resultsDiv.innerHTML = '';
    resultsDiv.style.display = searchTerm.length >= 2 ? 'block' : 'none';

    if (searchTerm.length < 2) return;

    const filteredStops = Object.values(allDefinedStops_data).filter(stop => 
        (stop.stopName || "").toLowerCase().includes(searchTerm) || 
        (stop.stopID || "").toLowerCase().includes(searchTerm)
    ).slice(0, 5);

    if (filteredStops.length > 0) {
        const list = document.createElement('ul');
        list.style.listStyle = 'none';
        list.style.padding = '0';
        list.style.margin = '0';
        list.style.border = '1px solid #7f8c8d';
        list.style.borderRadius = '0.25rem';
        list.style.backgroundColor = '#2c3e50';
        list.style.position = 'absolute';
        list.style.width = '100%';

        filteredStops.forEach(stop => {
            const li = document.createElement('li');
            li.textContent = `${stop.stopName} (${stop.stopID})`;
            li.style.padding = '0.5rem';
            li.style.cursor = 'pointer';
            li.addEventListener('mouseenter', () => li.style.backgroundColor = '#34495e');
            li.addEventListener('mouseleave', () => li.style.backgroundColor = '#2c3e50');
            li.addEventListener('click', () => {
                document.getElementById('mrc-selected-term-stop-id-extra').value = stop.stopID;
                document.getElementById('mrc-selected-term-stop-display-extra').textContent = `Selected: ${stop.stopName} (${stop.stopID})`;
                document.getElementById('mrc-new-dest-display-name-extra').value = stop.stopName;
                searchInput.value = `${stop.stopName} (${stop.stopID})`;
                resultsDiv.style.display = 'none';
            });
            list.appendChild(li);
        });
        resultsDiv.appendChild(list);
    } else {
        resultsDiv.innerHTML = `<div style="padding:0.5rem; background-color: #2c3e50; border: 1px solid #7f8c8d; border-radius: 0.25rem;">No stops found.</div>`;
    }
}

// --- START: Service Leg Curtailment (SLC) Functions ---

function slc_populateRouteSelect() {
    const selectEl = document.getElementById('slc-route-select-extra');
    if (!selectEl) return;
    const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))].filter(Boolean).sort(compareLineNames_ExtraPage);
    selectEl.innerHTML = '<option value="">-- Select Route --</option>';
    uniqueRoutes.forEach(route => selectEl.add(new Option(route, route)));
    slc_populateDestinationSelect(); // Trigger chain reaction
}

function slc_populateDestinationSelect() {
    const routeSelect = document.getElementById('slc-route-select-extra');
    const destSelect = document.getElementById('slc-destination-select-extra');
    if (!routeSelect || !destSelect) return;

    const selectedRoute = routeSelect.value;
    destSelect.innerHTML = '<option value="">-- Select Journey Variant --</option>';
    destSelect.disabled = true;
    
    // This will clear the terminus points dropdown when the route changes.
    slc_populateCurtailmentPointsSelect(); 

    if (!selectedRoute) return;

    // This logic finds all saved RSG configurations for the selected route.
    const matchingConfigs = [];
    const futureDatePattern = /\(from\s*\d{6}\)/;
    for (const key in rsg_loadedConfigs_extra) {
        const config = rsg_loadedConfigs_extra[key];
        if (config.routeName === selectedRoute && !futureDatePattern.test(config.userDisplayName || key)) {
            matchingConfigs.push({ key, ...config });
        }
    }

    // Sort the configurations alphabetically by their display name
    matchingConfigs.sort((a, b) => (a.userDisplayName || a.key).localeCompare(b.userDisplayName || b.key));

    // Populate the dropdown with the descriptive name and unique key
    if (matchingConfigs.length > 0) {
        matchingConfigs.forEach(config => {
            const option = document.createElement('option');
            // The VALUE is now the unique key of the saved config
            option.value = config.key; 
            // The TEXT is the user-friendly display name
            option.textContent = config.userDisplayName || config.key; 
            destSelect.appendChild(option);
        });
        destSelect.disabled = false;
    }
    
    // Trigger the next function in the chain
    destSelect.dispatchEvent(new Event('change'));
}

// REPLACE your existing slc_populateCurtailmentPointsSelect function with this one.
async function slc_populateCurtailmentPointsSelect() {
    const routeSelect = document.getElementById('slc-route-select-extra');
    const destSelect = document.getElementById('slc-destination-select-extra');
    const pointSelect = document.getElementById('slc-curtailment-point-select-extra');

    if (!routeSelect || !destSelect || !pointSelect) return;

    const selectedConfigKey = destSelect.value;
    const route = routeSelect.value;

    pointSelect.innerHTML = '<option value="">-- Select Point --</option>';
    pointSelect.disabled = true;

    if (!route || !selectedConfigKey) {
        return;
    }

    const configData = rsg_loadedConfigs_extra[selectedConfigKey];
    if (!configData || !configData.destinationName) return;

    const correctDestinationName = configData.destinationName;
    const path = `${FB_PATH_CURTAILMENT_POINTS}/${sanitizeFirebaseKey(route)}/${sanitizeFirebaseKey(correctDestinationName)}`;
    
    const { database, dbGet, dbRef } = window.firebaseOMSI;
    const snapshot = await dbGet(dbRef(database, path));

    if (snapshot.exists()) {
        const definedPoints = snapshot.val();
        if (Array.isArray(definedPoints) && definedPoints.length > 0) {
            const stopOrderInSequence = configData.stopSequence ? configData.stopSequence.map(s => s.stopID) : [];
            
            definedPoints.sort((a, b) => {
                const indexA = stopOrderInSequence.indexOf(a.lastStopID);
                const indexB = stopOrderInSequence.indexOf(b.lastStopID);
                return (indexA === -1 ? Infinity : indexA) - (indexB === -1 ? Infinity : indexB);
            });

            definedPoints.forEach(point => {
                // *** MODIFIED: Include the returnOriginStopID in the option's value ***
                const optionValue = JSON.stringify({
                    stopId: point.lastStopID,
                    displayName: point.newDestinationName,
                    returnOriginStopID: point.returnOriginStopID // Ensure this is included
                });
                const optionText = `${point.newDestinationName} (${point.lastStopID})`;
                pointSelect.add(new Option(optionText, optionValue));
            });
            pointSelect.disabled = false;
        } else {
            pointSelect.innerHTML = '<option value="">No defined points found</option>';
        }
    } else {
        pointSelect.innerHTML = '<option value="">No defined points found</option>';
    }
}

// In omsi_tools_extra.html
async function slc_handleActivateCurtailment() {
    const statusEl = document.getElementById('slc-status-message-extra');
    const DYNAMIC_TRIP_LAYOVER_MINUTES = 5;

    const route = document.getElementById('slc-route-select-extra').value;
    const outboundConfigKey = document.getElementById('slc-destination-select-extra').value;
    const pointJSON = document.getElementById('slc-curtailment-point-select-extra').value;
    const startTime = document.getElementById('slc-start-time-input-extra').value;
    const endTime = document.getElementById('slc-end-time-input-extra').value;
    const templateReturnJourneyDestName = document.getElementById('slc-return-dest-select-extra')?.value;

    if (!route || !outboundConfigKey || !pointJSON || !startTime || !endTime || !templateReturnJourneyDestName) {
        statusEl.textContent = "All fields are required.";
        statusEl.style.color = "#e74c3c";
        return;
    }
    const outboundConfig = rsg_loadedConfigs_extra[outboundConfigKey];
    const point = JSON.parse(pointJSON);
    const returnOriginStopID_fromPoint = point.returnOriginStopID;

    const templateReturnConfig = Object.values(rsg_loadedConfigs_extra).find(c => c.routeName === route && c.destinationName === templateReturnJourneyDestName);
    if (!templateReturnConfig) {
        statusEl.textContent = `Error: Cannot find RSG template for return journey to "${templateReturnJourneyDestName}".`; return;
    }

    const allReturnJourneyConfigs = Object.values(rsg_loadedConfigs_extra).filter(c => c.routeName === route && c.destinationName === templateReturnConfig.destinationName);
    const legsToSuppress = allReturnJourneyConfigs.map(c => ({ routeName: route, destinationName: c.destinationName }));

    const allOutboundTrips = segmentScheduleEntriesIntoTrips(currentWorkingSchedule_extra.filter(e => e.lineName === outboundConfig.routeName && e.destinationName === outboundConfig.destinationName));
    
    let allDynamicReturnEntries = [];
    for (const outboundTrip of allOutboundTrips) {
        const arrivalAtTerminusEntry = outboundTrip.find(stop => stop.stopID === point.stopId);
        if (!arrivalAtTerminusEntry) continue;
        
        const profileForThisTrip = outboundTrip[0].OperatingProfile; // Get the specific profile of the trip being curtailed.

        let arrivalTimeAbs = (parseInt(arrivalAtTerminusEntry.DayOffset || 0) * 1440) + (parseInt(arrivalAtTerminusEntry.scheduledTime.split(':')[0]) * 60) + parseInt(arrivalAtTerminusEntry.scheduledTime.split(':')[1]);
        let newDepartureTimeAbs = arrivalTimeAbs + DYNAMIC_TRIP_LAYOVER_MINUTES;

        const fullReturnSequence = templateReturnConfig.stopSequence;
        const returnTripStartIndex = fullReturnSequence.findIndex(s => s.stopID === returnOriginStopID_fromPoint);
        if (returnTripStartIndex === -1) continue;

        const actualReturnSequence = fullReturnSequence.slice(returnTripStartIndex);
        const actualReturnStopIds = actualReturnSequence.map(s => s.stopID);
        let currentTimeAbs = newDepartureTimeAbs;

        actualReturnSequence.forEach((stop, index) => {
            if (index > 0) { currentTimeAbs += (stop.timeAdjustment || 0); }
            let dOff = 0; let eMins = currentTimeAbs;
            while(eMins >= 1440) { eMins -= 1440; dOff++; }
            while(eMins < 0) { eMins += 1440; dOff--; }
            
            allDynamicReturnEntries.push({
                stopID: stop.stopID, stopName: stop.stopName, direction: stop.direction,
                lineName: route, destinationName: templateReturnConfig.destinationName,
                OperatingProfile: profileForThisTrip, // *** THE FIX: Use the inherited profile
                scheduledTime: `${String(Math.floor(eMins / 60)).padStart(2,'0')}:${String(eMins % 60).padStart(2,'0')}`,
                DayOffset: String(dOff), tripStopSequence: actualReturnStopIds,
                isDynamicallyGenerated: true
            });
        });
    }
    
    const record = {
        routeName: route, destinationName: outboundConfig.destinationName,
        newTerminusStopId: point.stopId, newTerminusDisplayName: point.displayName,
        startTime: new Date(startTime).toISOString(), endTime: new Date(endTime).toISOString(),
        user: currentUser_extra.email,
        suppressedServiceLegs: legsToSuppress,
        dynamicallyGeneratedTrip: allDynamicReturnEntries
    };
    
    if (!confirm(`Confirm Curtailment for Route ${route} to ${point.displayName}?\nThis will apply universally. Proceed?`)) {
        statusEl.textContent = "Activation cancelled."; return;
    }
    
    const { database, dbSet, dbRef } = window.firebaseOMSI;
    const newKey = `masscurt-${Date.now()}`;
    try {
        await dbSet(dbRef(database, `${FB_PATH_MASS_CURTAILMENTS}/${newKey}`), record);
        statusEl.textContent = "Universal curtailment rule activated successfully!";
        statusEl.style.color = "#2ecc71";
        slc_renderActiveCurtailments();
    } catch (error) {
        statusEl.textContent = "Error saving curtailment: " + error.message;
        statusEl.style.color = "#e74c3c";
    }
}



function slc_populateReturnDestinationSelect() {
    const routeSelect = document.getElementById('slc-route-select-extra');
    const outboundDestSelect = document.getElementById('slc-destination-select-extra');
    const returnDestSelect = document.getElementById('slc-return-dest-select-extra');

    if (!routeSelect || !outboundDestSelect || !returnDestSelect) return;

    const selectedRoute = routeSelect.value;
    const selectedOutboundConfigKey = outboundDestSelect.value;
    
    // Get the actual destination name of the journey being curtailed
    const outboundConfig = rsg_loadedConfigs_extra[selectedOutboundConfigKey];
    const outboundDestinationName = outboundConfig ? outboundConfig.destinationName : null;

    returnDestSelect.innerHTML = ''; // Clear existing options
    returnDestSelect.disabled = true;

    if (!selectedRoute) return;

    // Find all possible destination names for this route from the RSG configurations
    const allPossibleDests = new Set();
    for (const key in rsg_loadedConfigs_extra) {
        const config = rsg_loadedConfigs_extra[key];
        if (config.routeName === selectedRoute && config.destinationName) {
            allPossibleDests.add(config.destinationName);
        }
    }
    
    const sortedDests = Array.from(allPossibleDests).sort();

    let optionsAdded = 0;
    sortedDests.forEach(destName => {
        // IMPORTANT: Do not show the outbound destination in the list of return journeys
        if (destName !== outboundDestinationName) {
            const option = document.createElement('option');
            option.value = destName;
            option.textContent = destName;
            returnDestSelect.appendChild(option);
            optionsAdded++;
        }
    });

    if (optionsAdded > 0) {
        returnDestSelect.disabled = false;
    } else {
        returnDestSelect.innerHTML = '<option value="">No other destinations found</option>';
    }
}

function slc_renderActiveCurtailments() {
    const listDiv = document.getElementById('slc-active-list-extra');
    listDiv.innerHTML = '';
    const now = new Date();
    
    const activeCurtailments = Object.entries(massCurtailments_data).filter(([key, mc]) => {
        return new Date(mc.endTime) > now;
    });

    if (activeCurtailments.length === 0) {
        listDiv.innerHTML = '<p style="opacity:0.7;">No active or upcoming service curtailments.</p>';
        return;
    }

    let html = '<ul style="list-style-type: none; padding: 0;">';
    activeCurtailments.sort(([, a], [, b]) => new Date(a.startTime) - new Date(b.startTime)).forEach(([key, mc]) => {
        html += `
            <li style="background-color: rgba(255,255,255,0.05); padding: 0.75rem; border-radius: 4px; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong style="color: #f39c12;">${mc.routeName} to ${mc.destinationName}</strong><br>
                    <span style="font-size:0.9em;">Terminating at: <strong>${mc.newTerminusDisplayName}</strong></span><br>
                    <span style="font-size:0.8em; opacity:0.8;">Active until: ${new Date(mc.endTime).toLocaleString()}</span>
                </div>
                <button class="button save small-action" onclick="slc_handleCancelCurtailment('${key}')">Lift Now</button>
            </li>
        `;
    });
    html += '</ul>';
    listDiv.innerHTML = html;
}

async function slc_handleCancelCurtailment(curtailmentId) {
    if (!curtailmentId || !confirm("Lift this service curtailment immediately?")) return;
    const { database, dbRemove, dbRef } = window.firebaseOMSI;
    try {
        await dbRemove(dbRef(database, `${FB_PATH_MASS_CURTAILMENTS}/${curtailmentId}`));
        delete massCurtailments_data[curtailmentId];
        slc_renderActiveCurtailments();
    } catch (error) {
        alert("Error lifting curtailment: " + error.message);
    }
}
// --- END: Service Leg Curtailment (SLC) Functions ---

async function mrc_handleActivateCurtailment() {
    const statusEl = document.getElementById('mrc-status-message-extra');
    const route = document.getElementById('rc-route-select-extra').value;
    const stopId = document.getElementById('mrc-selected-term-stop-id-extra').value;
    const displayName = document.getElementById('mrc-new-dest-display-name-extra').value.trim();
    const startTime = document.getElementById('rc-start-time-input-extra').value;
    const endTime = document.getElementById('rc-end-time-input-extra').value;

    if (!route || !stopId || !displayName || !startTime || !endTime) {
        statusEl.textContent = "All fields are required to activate a curtailment.";
        statusEl.style.color = "#e74c3c";
        return;
    }
    
    const startTimeObj = new Date(startTime);
    const endTimeObj = new Date(endTime);
    if (endTimeObj <= startTimeObj) {
        statusEl.textContent = "End time must be after the start time.";
        statusEl.style.color = "#e74c3c";
        return;
    }

    const record = {
        routeName: route,
        newTerminusStopId: stopId,
        newTerminusDisplayName: displayName,
        startTime: startTimeObj.toISOString(),
        endTime: endTimeObj.toISOString(),
        user: currentUser_extra.email
    };

    if (!confirm(`Are you sure you want to curtail ALL services on Route ${route} to terminate at ${displayName} from ${startTimeObj.toLocaleString()} until ${endTimeObj.toLocaleString()}?`)) {
        statusEl.textContent = "Activation cancelled.";
        return;
    }

    const { database, dbSet, dbRef } = window.firebaseOMSI;
    const newKey = `masscurt-${Date.now()}`;
    try {
        await dbSet(dbRef(database, `${FB_PATH_MASS_CURTAILMENTS}/${newKey}`), record);
        massCurtailments_data[newKey] = record;
        statusEl.textContent = "Mass curtailment activated successfully!";
        statusEl.style.color = "#2ecc71";
        mrc_renderActiveCurtailments(); // Refresh the display
        displayDeparturesForSelectedStop_ExtraPage(); // Refresh the main departures view if it's visible
    } catch (error) {
        statusEl.textContent = "Error activating curtailment: " + error.message;
        statusEl.style.color = "#e74c3c";
    }
}

async function mrc_handleCancelCurtailment(curtailmentId) {
    if (!curtailmentId) return;
    if (!confirm("Are you sure you want to lift this route-wide curtailment?")) return;

    const { database, dbRemove, dbRef } = window.firebaseOMSI;
    try {
        await dbRemove(dbRef(database, `${FB_PATH_MASS_CURTAILMENTS}/${curtailmentId}`));
        delete massCurtailments_data[curtailmentId];
        document.getElementById('mrc-status-message-extra').textContent = "Curtailment lifted.";
        mrc_renderActiveCurtailments();
    } catch (error) {
        document.getElementById('mrc-status-message-extra').textContent = "Error lifting curtailment: " + error.message;
    }
}

// --- END: Mass Route Curtailment Functions ---

// In omsi_tools_extra.html

async function op_points_displayDefinedPoints() {
    const routeSelect = document.getElementById('op-points-route-select-extra');
    const destSelect = document.getElementById('op-points-dest-select-extra');
    const listDiv = document.getElementById('op-points-list-extra');
    if (!routeSelect || !destSelect || !listDiv) return;

    const route = routeSelect.value;
    const destConfigKey = destSelect.value;
    listDiv.innerHTML = '<p>Select a route and destination to view points.</p>';

    if (route && destConfigKey) {
        const configForDestName = rsg_loadedConfigs_extra[destConfigKey];
        if (!configForDestName || !configForDestName.destinationName) {
            listDiv.innerHTML = '<p>Could not find configuration details for the selected destination.</p>';
            return;
        }
        const destinationName = configForDestName.destinationName;

        const { database, dbGet, dbRef } = window.firebaseOMSI;
        const path = `${FB_PATH_CURTAILMENT_POINTS}/${sanitizeFirebaseKey(route)}/${sanitizeFirebaseKey(destinationName)}`;
        const snapshot = await dbGet(dbRef(database, path));
        
        const points = snapshot.exists() ? snapshot.val() : [];
        definedCurtailmentPoints[path] = points; 

        if (points.length === 0) {
            listDiv.innerHTML = '<p>No official curtailment points defined for this service.</p>';
            return;
        }

        let stopOrderFromRsg = [];
        if (configForDestName && configForDestName.stopSequence) {
            stopOrderFromRsg = configForDestName.stopSequence.map(s => (s.stopID || "").trim().toUpperCase());
        }

        const sortedPoints = [...points].sort((a, b) => {
            const indexA = stopOrderFromRsg.indexOf((a.lastStopID || "").trim().toUpperCase());
            const indexB = stopOrderFromRsg.indexOf((b.lastStopID || "").trim().toUpperCase());
            return (indexA === -1 ? Infinity : indexA) - (indexB === -1 ? Infinity : indexB);
        });

        let html = '<ul style="list-style-type: none; padding-left: 0;">';
        sortedPoints.forEach((point, idx) => {
            const stopInfo = allDefinedStops_data[(point.lastStopID || "").toUpperCase()] || { stopName: 'Unknown Stop' };
            const returnOriginInfo = allDefinedStops_data[point.returnOriginStopID?.toUpperCase()] || { stopName: 'Unknown' };
            
            html += `<li style="display:flex; justify-content:space-between; align-items:center; padding: 0.5em; border-bottom: 1px solid #4A5568;">
                        <div>
                           <span><strong>Last Stop:</strong> ${stopInfo.stopName} (${point.lastStopID})</span><br>
                           <span style="font-size:0.9em;"><strong>Displays As:</strong> "${point.newDestinationName}"</span><br>
                           <span style="font-size:0.9em; opacity: 0.8; color: #3498db;"><strong>Return From: ${returnOriginInfo.stopName} (${point.returnOriginStopID})</strong></span>
                        </div>
                        <div class="op-point-item-actions">
                           <button class="button small-action neutral" onclick="op_points_handleEditPoint(${idx})">Edit</button>
                           <button class="button small-action secondary" onclick="op_points_handleDeletePoint(${idx})">Delete</button>
                        </div>
                     </li>`;
        });
        html += '</ul>';
        listDiv.innerHTML = html;
    }
}

// Add this new function anywhere alongside your other op_points_ functions.
async function op_points_handleEditPoint(index) {
    const statusMsg = document.getElementById('op-points-status-message-extra');
    const route = document.getElementById('op-points-route-select-extra').value;
    const destConfigKey = document.getElementById('op-points-dest-select-extra').value;

    if (!route || !destConfigKey) {
        alert("Cannot edit: Route or Destination context is missing.");
        return;
    }

    const configData = rsg_loadedConfigs_extra[destConfigKey];
    if (!configData || !configData.destinationName) {
        alert("Error: Could not find configuration details for the selected destination to perform edit.");
        return;
    }
    const destinationName = configData.destinationName;
    const path = `${FB_PATH_CURTAILMENT_POINTS}/${sanitizeFirebaseKey(route)}/${sanitizeFirebaseKey(destinationName)}`;

    let currentPoints = definedCurtailmentPoints[path] || [];
    if (index < 0 || index >= currentPoints.length) {
        alert("Error: Invalid index for edit. The list may have changed.");
        return;
    }
    
    const pointToEdit = currentPoints[index];

    // Populate the form fields
    document.getElementById('op-points-last-stop-select-extra').value = pointToEdit.lastStopID;
    document.getElementById('op-points-dest-name-input-extra').value = pointToEdit.newDestinationName;
    document.getElementById('op-points-return-origin-select-extra').value = pointToEdit.returnOriginStopID;

    // Scroll to the top of the section and focus the first form field
    const formSection = document.getElementById('curtailment-config-section_extra');
    if (formSection) formSection.scrollIntoView({ behavior: 'smooth' });
    document.getElementById('op-points-last-stop-select-extra').focus();

    // Now, remove the old entry by calling the delete handler internally
    // We pass 'true' to suppress the confirmation prompt for a smoother UX
    await op_points_handleDeletePoint(index, true);

    if (statusMsg) {
        statusMsg.textContent = `Editing point "${pointToEdit.newDestinationName}". Make your changes above and click 'Add Point' to save.`;
        statusMsg.style.color = "#3498db";
    }
}

async function op_points_handleAddPoint() {
    const statusMsg = document.getElementById('op-points-status-message-extra');
    const route = document.getElementById('op-points-route-select-extra').value;
    const destConfigKey = document.getElementById('op-points-dest-select-extra').value;
    const lastStopID = document.getElementById('op-points-last-stop-select-extra').value;
    const newDestName = document.getElementById('op-points-dest-name-input-extra').value.trim();
    // *** NEW: Get the return journey's origin stop ***
    const returnOriginStopID = document.getElementById('op-points-return-origin-select-extra').value;

    // *** MODIFIED: Add returnOriginStopID to validation ***
    if (!route || !destConfigKey || !lastStopID || !newDestName || !returnOriginStopID) {
        statusMsg.textContent = 'All fields (Route, Destination, Last Stop, Return Origin, Display Name) are required.';
        statusMsg.style.color = '#f1c40f';
        return;
    }

    const configData = rsg_loadedConfigs_extra[destConfigKey];
    if (!configData || !configData.destinationName) {
        statusMsg.textContent = 'Error: Could not find configuration details for the selected destination.';
        statusMsg.style.color = '#e74c3c';
        return;
    }
    const destinationName = configData.destinationName;

    // *** MODIFIED: Add the new property to the point's data structure ***
    const newPoint = { 
        lastStopID, 
        newDestinationName: newDestName,
        returnOriginStopID: returnOriginStopID
    };
    
    const path = `${FB_PATH_CURTAILMENT_POINTS}/${sanitizeFirebaseKey(route)}/${sanitizeFirebaseKey(destinationName)}`;
    
    let currentPoints = definedCurtailmentPoints[path] || [];
    if (currentPoints.some(p => p.lastStopID === newPoint.lastStopID)) {
         statusMsg.textContent = 'This stop is already defined as a curtailment point.';
         statusMsg.style.color = '#f1c40f';
         return;
    }
    currentPoints.push(newPoint);
    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        await dbSet(dbRef(database, path), currentPoints);
        statusMsg.textContent = 'Curtailment point added successfully.';
        statusMsg.style.color = '#2ecc71';
        op_points_displayDefinedPoints(); 
    } catch (error) {
        statusMsg.textContent = 'Error saving point: ' + error.message;
        statusMsg.style.color = '#e74c3c';
    }
}

// REPLACE your existing op_points_handleDeletePoint function with this one.
async function op_points_handleDeletePoint(index, suppressConfirmation = false) {
    const statusMsg = document.getElementById('op-points-status-message-extra');
    if (!statusMsg) return;

    const route = document.getElementById('op-points-route-select-extra').value;
    const destConfigKey = document.getElementById('op-points-dest-select-extra').value;

    if (!route || !destConfigKey) {
        statusMsg.textContent = 'Cannot delete: Route or Destination context is missing.';
        statusMsg.style.color = '#e74c3c';
        return;
    }

    const configData = rsg_loadedConfigs_extra[destConfigKey];
    if (!configData || !configData.destinationName) {
        statusMsg.textContent = 'Error: Could not find configuration details for deletion.';
        statusMsg.style.color = '#e74c3c';
        return;
    }

    const destinationName = configData.destinationName;
    const path = `${FB_PATH_CURTAILMENT_POINTS}/${sanitizeFirebaseKey(route)}/${sanitizeFirebaseKey(destinationName)}`;
    
    let currentPoints = definedCurtailmentPoints[path] || [];
    
    if (index < 0 || index >= currentPoints.length) {
        statusMsg.textContent = 'Error: Invalid index for deletion. The list may have changed.';
        statusMsg.style.color = '#e74c3c';
        return;
    }
    
    // Check the suppressConfirmation flag before showing the prompt
    if (!suppressConfirmation) {
        if (!confirm(`Are you sure you want to delete this curtailment point: "${currentPoints[index].newDestinationName}"?`)) {
            statusMsg.textContent = 'Deletion cancelled.';
            statusMsg.style.color = '';
            return;
        }
    }

    currentPoints.splice(index, 1);
    
    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        await dbSet(dbRef(database, path), currentPoints);
        if (!suppressConfirmation) { // Only show this message on a manual delete
            statusMsg.textContent = 'Point deleted successfully.';
            statusMsg.style.color = "#2ecc71";
        }
        op_points_displayDefinedPoints(); 
    } catch (error) {
        statusMsg.textContent = 'Error deleting point: ' + error.message;
        statusMsg.style.color = '#e74c3c';
        op_points_displayDefinedPoints();
    }
}

function curtail_populateSelectors() {
            const routeSelect = document.getElementById('curtail-route-select-extra');
            if (!routeSelect) return;
            const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))].filter(Boolean).sort(compareLineNames_ExtraPage);
            routeSelect.innerHTML = '<option value="">-- Select Route --</option>';
            uniqueRoutes.forEach(r => routeSelect.add(new Option(r, r)));
            // The addEventListener line was removed from here
            curtail_populateDestSelect();
        }

function curtail_populateDestSelect() {
    const routeSelect = document.getElementById('curtail-route-select-extra');
    const destSelect = document.getElementById('curtail-dest-select-extra');
    if (!routeSelect || !destSelect) return;
    const selectedRoute = routeSelect.value;
    destSelect.innerHTML = '<option value="">-- Select Destination --</option>';
    if (selectedRoute) {
        const uniqueDests = [...new Set(currentWorkingSchedule_extra.filter(e => e.lineName === selectedRoute).map(e => e.destinationName))].filter(Boolean).sort();
        uniqueDests.forEach(d => destSelect.add(new Option(d, d)));
    }
    const profileDisplay = document.getElementById('curtail-profile-display-extra');
    if (profileDisplay) {
        profileDisplay.value = getOperatingCodesForDate_ExtraPage(new Date()).join(', ');
    }
}

function curtail_fetchTodaysTrips() {
    const route = document.getElementById('curtail-route-select-extra').value;
    const dest = document.getElementById('curtail-dest-select-extra').value;
    const statusMsg = document.getElementById('curtail-status-message-extra');
    const container = document.getElementById('curtail-trip-list-container-extra');
    const now = new Date(); // Get the current time for filtering

    if (!route || !dest) {
        statusMsg.textContent = 'Please select a route and destination.';
        statusMsg.style.color = '#f1c40f';
        if(container) container.innerHTML = '<p>Please select a service above and fetch trips.</p>';
        activeTripsForCurtailment = [];
        return;
    }

    statusMsg.textContent = 'Finding active configurations and generating today\'s trips...';
    statusMsg.style.color = '#3498db';

    const todaysActiveProfiles = getOperatingCodesForDate_ExtraPage(new Date());
    let allTripsForTheDay = []; // Temporary holder for all trips

    if (!rsg_loadedConfigs_extra || Object.keys(rsg_loadedConfigs_extra).length === 0) {
        statusMsg.textContent = 'Error: Route Schedule Generator configurations are not loaded.';
        statusMsg.style.color = '#e74c3c';
        return;
    }

    for (const configKey in rsg_loadedConfigs_extra) {
        const config = rsg_loadedConfigs_extra[configKey];

        if (config.routeName !== route || config.destinationName !== dest) {
            continue;
        }

        const configProfiles = (config.operatingProfile || "").split(',').map(p => p.trim());
        const isActiveToday = configProfiles.some(profile => todaysActiveProfiles.includes(profile));

        if (isActiveToday) {
            const tripsFromThisConfig = generateScheduleTripsFromConfig(config);
            
            // --- NEW: Calculate duration and create trip objects ---
            const tripDurationMinutes = (config.stopSequence || []).reduce((acc, stop, index) => {
                return index > 0 ? acc + (stop.timeAdjustment || 0) : acc;
            }, 0);

            tripsFromThisConfig.forEach(tripStops => {
                if (tripStops.length > 0) {
                    const startTimeObj = createEventTimeObjForAlert(tripStops[0].scheduledTime, new Date());
                    const endTimeObj = new Date(startTimeObj.getTime() + tripDurationMinutes * 60000);

                    allTripsForTheDay.push({
                        startTime: tripStops[0].scheduledTime,
                        endTimeObj: endTimeObj,
                        stops: tripStops,
                        isCurtailed: tripStops[0].curtailment && tripStops[0].curtailment.newDestinationName
                    });
                }
            });
            // --- END NEW ---
        }
    }

    // --- NEW: Filter for trips that have not finished yet ---
    activeTripsForCurtailment = allTripsForTheDay.filter(trip => trip.endTimeObj >= now);

    // Sort the filtered trips by their start time
    activeTripsForCurtailment.sort((a, b) => {
        return a.startTime.localeCompare(b.startTime);
    });

    curtail_renderTripCards();
    statusMsg.textContent = `Found ${activeTripsForCurtailment.length} upcoming or in-service trips.`;
    statusMsg.style.color = '#2ecc71';
}

function curtail_renderTripCards() {
    const container = document.getElementById('curtail-trip-list-container-extra');
    container.innerHTML = '';
    if (activeTripsForCurtailment.length === 0) {
        container.innerHTML = '<p>No upcoming or in-service trips found for the selected service today.</p>';
        return;
    }

    activeTripsForCurtailment.forEach((tripObject, tripIndex) => {
        const tripStops = tripObject.stops; // Get the stops from the object
        if (tripStops.length === 0) return;

        const card = document.createElement('div');
        card.className = 'subsection';
        card.style.marginBottom = '1rem';
        
        const firstStop = tripStops[0];
        const isCurtailed = tripObject.isCurtailed;

        const cardHeader = document.createElement('h4');
        cardHeader.style.marginTop = 0;
        
        let headerHTML = `Trip: ${firstStop.scheduledTime} from ${firstStop.stopName} `;
        if (isCurtailed) {
            headerHTML += `<span style="color: #f39c12; font-weight: bold;">(CURTAILED at ${firstStop.curtailment.newDestinationName})</span>
                         <button class="button small-action" style="float: right;" data-trip-index="${tripIndex}">Revert</button>`;
        } else {
            headerHTML += `<button class="button small-action tertiary" style="float: right;" data-trip-index="${tripIndex}">Intervene...</button>`;
        }
        
        cardHeader.innerHTML = headerHTML;
        card.appendChild(cardHeader);

        const stopList = document.createElement('ul');
        stopList.style.listStyle = 'none';
        stopList.style.paddingLeft = '1rem';
        stopList.style.fontSize = '0.9em';
        
        const curtailStopIndex = isCurtailed ? tripStops.findIndex(s => s.stopID === firstStop.curtailment.curtailAtStopID) : -1;

        tripStops.forEach((stop, stopIndex) => {
            const li = document.createElement('li');
            li.textContent = `${stop.scheduledTime} - ${stop.stopName}`;
            if (isCurtailed && curtailStopIndex !== -1 && stopIndex > curtailStopIndex) {
                li.style.textDecoration = 'line-through';
                li.style.opacity = '0.5';
            }
            stopList.appendChild(li);
        });
        card.appendChild(stopList);
        container.appendChild(card);
    });

    container.querySelectorAll('button[data-trip-index]').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const tripIndex = e.target.dataset.tripIndex;
            if (e.target.textContent === 'Revert') {
                curtail_revertCurtailment(tripIndex);
            } else {
                curtail_handleInterveneClick(tripIndex);
            }
        });
    });
}

async function curtail_handleInterveneClick(tripIndex) {
    const tripObject = activeTripsForCurtailment[tripIndex]; // Get the trip object
    if (!tripObject || !tripObject.stops || tripObject.stops.length === 0) return;

    const tripStops = tripObject.stops;
    const route = tripStops[0].lineName;
    const dest = tripStops[0].destinationName;
    const modal = document.getElementById('curtail-intervention-modal-extra');
    const title = document.getElementById('curtail-modal-title-extra');
    const optionsContainer = document.getElementById('curtail-modal-options-container-extra');

    title.textContent = `Intervene on ${tripStops[0].scheduledTime} trip to ${dest}`;
    optionsContainer.innerHTML = '<p>Loading valid curtailment points...</p>';
    modal.style.display = 'flex';

    const { database, dbGet, dbRef } = window.firebaseOMSI;
    const path = `${FB_PATH_CURTAILMENT_POINTS}/${sanitizeFirebaseKey(route)}/${sanitizeFirebaseKey(dest)}`;
    const snapshot = await dbGet(dbRef(database, path));
    const officialPoints = snapshot.exists() ? snapshot.val() : [];

    if (officialPoints.length === 0) {
        optionsContainer.innerHTML = '<p>No official curtailment points are defined for this service.</p>';
        return;
    }

    optionsContainer.innerHTML = '';
    officialPoints.forEach(point => {
        const pointStopInTrip = tripStops.find(s => s.stopID === point.lastStopID);
        if (pointStopInTrip) {
            const btn = document.createElement('button');
            btn.className = 'button';
            btn.style.width = '100%';
            btn.style.marginBottom = '0.5rem';
            btn.textContent = `Curtail at ${pointStopInTrip.stopName} (display as "${point.newDestinationName}")`;
            btn.addEventListener('click', () => curtail_confirmCurtailment(tripIndex, point));
            optionsContainer.appendChild(btn);
        }
    });
}

 async function curtail_confirmCurtailment(tripIndex, curtailmentPoint) {
    const tripObject = activeTripsForCurtailment[tripIndex];
    if (!tripObject || !tripObject.stops || tripObject.stops.length === 0) {
        alert("Error: Could not find trip data for curtailment.");
        return;
    }

    const tripStops = tripObject.stops;
    const statusMsg = document.getElementById('curtail-status-message-extra');
    const modal = document.getElementById('curtail-intervention-modal-extra');

    try {
        if (statusMsg) {
            statusMsg.textContent = "Applying curtailment and updating live schedule...";
            statusMsg.style.color = "#f1c40f";
        }

        const routeName = tripStops[0].lineName;
        const opProfile = tripStops[0].OperatingProfile;
        const destName = tripStops[0].destinationName;

        const curtailmentData = {
            curtailAtStopID: curtailmentPoint.lastStopID,
            newDestinationName: curtailmentPoint.newDestinationName,
            appliedAt: new Date().toISOString()
        };

        let entriesUpdatedCount = 0;
        const tripTimesByStopId = new Map(tripStops.map(entry => [entry.stopID, entry.scheduledTime]));

        currentWorkingSchedule_extra.forEach(entry => {
            if (
                entry.lineName === routeName &&
                entry.destinationName === destName &&
                entry.OperatingProfile === opProfile &&
                tripTimesByStopId.get(entry.stopID) === entry.scheduledTime
            ) {
                entry.curtailment = curtailmentData;
                entriesUpdatedCount++;
            }
        });

        if (entriesUpdatedCount > 0) {
            await saveSpecificRouteDataToFirebase_ExtraPage(routeName);
            
            // Update local state for immediate re-render
            tripObject.isCurtailed = true;
            tripObject.stops.forEach(stop => stop.curtailment = curtailmentData);

            curtail_renderTripCards();

            alert(`Intervention applied! The ${tripStops[0].scheduledTime} trip will now be shown as curtailed.`);
            if (modal) modal.style.display = 'none';
            if (statusMsg) statusMsg.textContent = `Successfully curtailed trip for Route ${routeName}.`;

        } else {
            throw new Error("Could not find matching schedule entries to apply curtailment to.");
        }

    } catch (error) {
        console.error("Error applying intervention:", error);
        alert('Error applying intervention: ' + error.message);
        if (statusMsg) statusMsg.textContent = 'Error applying intervention: ' + error.message;
    }
}

async function curtail_revertCurtailment(tripIndex) {
    const tripObject = activeTripsForCurtailment[tripIndex];
    if (!tripObject || !tripObject.stops || tripObject.stops.length === 0) {
        alert("Error: Could not find trip data to revert.");
        return;
    }

    const tripStops = tripObject.stops;
    const routeName = tripStops[0].lineName;
    const opProfile = tripStops[0].OperatingProfile;
    const destName = tripStops[0].destinationName;
    
    const tripTimesByStopId = new Map(tripStops.map(entry => [entry.stopID, entry.scheduledTime]));
    let entriesUpdatedCount = 0;

    currentWorkingSchedule_extra.forEach(entry => {
        if (
            entry.lineName === routeName &&
            entry.destinationName === destName &&
            entry.OperatingProfile === opProfile &&
            tripTimesByStopId.get(entry.stopID) === entry.scheduledTime &&
            entry.curtailment
        ) {
            delete entry.curtailment;
            entriesUpdatedCount++;
        }
    });

    if (entriesUpdatedCount > 0) {
        try {
            await saveSpecificRouteDataToFirebase_ExtraPage(routeName);
            
            // Update local state for immediate re-render
            tripObject.isCurtailed = false;
            tripObject.stops.forEach(stop => delete stop.curtailment);

            curtail_renderTripCards();

            alert(`Reverted curtailment for the ${tripStops[0].scheduledTime} trip. The arrivals board will now update.`);

        } catch (error) {
            console.error("Error saving reversion to Firebase:", error);
            alert('Error saving reversion: ' + error.message);
        }
    } else {
        alert("Error: Could not find the active curtailment record in the live schedule data. The list may be out of sync.");
    }
}

// --- START: Functions for Copying Curtailment Points ---

function op_points_openCopyModal() {
    const targetRoute = document.getElementById('op-points-route-select-extra').value;
    const targetDest = document.getElementById('op-points-dest-select-extra').value;

    if (!targetRoute || !targetDest) {
        alert("Please select a target Route and Destination before copying.");
        return;
    }

    const modal = document.getElementById('op-copy-modal-extra');
    const title = document.getElementById('op-copy-modal-title-extra');
    const sourceRouteSelect = document.getElementById('op-copy-source-route-select-extra');
    
    title.textContent = `Copy Points to: ${targetRoute} to ${targetDest}`;
    
    // Populate source route dropdown, excluding the current target route
    sourceRouteSelect.innerHTML = '<option value="">-- Select Source Route --</option>';
    const uniqueRoutes = [...new Set(Object.values(rsg_loadedConfigs_extra).map(c => c.routeName))].filter(Boolean).sort(compareLineNames_ExtraPage);
    uniqueRoutes.forEach(route => {
        if (route !== targetRoute) {
            sourceRouteSelect.add(new Option(route, route));
        }
    });

    // Reset the rest of the modal
    document.getElementById('op-copy-source-dest-select-extra').innerHTML = '<option value="">-- Select Source Route First --</option>';
    document.getElementById('op-copy-eligible-points-container-extra').innerHTML = '<p style="opacity:0.7;">Select a source route and destination.</p>';
    document.getElementById('op-copy-modal-status-extra').textContent = '';

    modal.style.display = 'flex';
}

function op_points_closeCopyModal() {
    const modal = document.getElementById('op-copy-modal-extra');
    if (modal) modal.style.display = 'none';
}

function op_points_populateCopyModalDestSelect() {
    const sourceRouteSelect = document.getElementById('op-copy-source-route-select-extra');
    const sourceDestSelect = document.getElementById('op-copy-source-dest-select-extra');
    if (!sourceRouteSelect || !sourceDestSelect) return;

    const selectedSourceRoute = sourceRouteSelect.value;
    sourceDestSelect.innerHTML = '<option value="">--- Select Source Journey ---</option>';

    // This will clear the eligible points list whenever the source route changes.
    op_points_findAndDisplayEligiblePoints();

    if (!selectedSourceRoute) {
        return;
    }

    // This pattern finds names with "(from DDMMYY)" to exclude them
    const futureDatePattern = /\(from\s*\d{6}\)/;
    const matchingConfigs = [];

    // 1. Find all configs for the selected source route
    for (const key in rsg_loadedConfigs_extra) {
        const config = rsg_loadedConfigs_extra[key];
        if (config.routeName === selectedSourceRoute) {
            // 2. Filter out future-dated schedules
            if (config.userDisplayName && !futureDatePattern.test(config.userDisplayName)) {
                matchingConfigs.push({ key, ...config });
            }
        }
    }

    // Sort the valid configs by their descriptive name
    matchingConfigs.sort((a, b) => (a.userDisplayName || a.key).localeCompare(b.userDisplayName || b.key));

    // 3. Populate the dropdown with the descriptive names and unique keys
    if (matchingConfigs.length > 0) {
        matchingConfigs.forEach(config => {
            const option = document.createElement('option');
            // The VALUE is the unique key
            option.value = config.key;
            // The TEXT is your descriptive name
            option.textContent = config.userDisplayName || config.key;
            sourceDestSelect.appendChild(option);
        });
    }

    // Automatically trigger the logic to find eligible points for the first item in the list
    sourceDestSelect.dispatchEvent(new Event('change'));
}

async function op_points_findAndDisplayEligiblePoints() {
    const container = document.getElementById('op-copy-eligible-points-container-extra');
    const sourceRoute = document.getElementById('op-copy-source-route-select-extra').value;
    const sourceDestKey = document.getElementById('op-copy-source-dest-select-extra').value; // This is the source config key
    const targetRoute = document.getElementById('op-points-route-select-extra').value;
    const targetDestKey = document.getElementById('op-points-dest-select-extra').value; // This is the target config key

    container.innerHTML = '<p style="opacity:0.7;">Loading...</p>';

    if (!sourceRoute || !sourceDestKey) {
        container.innerHTML = '<p style="opacity:0.7;">Select a source route and destination.</p>';
        return;
    }

    // --- START: CORRECTED LOGIC ---
    // 1. Get the stop sequence for the TARGET route directly using its config key.
    let targetStopIds = new Set();
    const targetConfig = rsg_loadedConfigs_extra[targetDestKey]; // The 'value' of the dest select is the key

    if (targetConfig && targetConfig.stopSequence) {
        targetConfig.stopSequence.forEach(s => targetStopIds.add(s.stopID));
    }
    // --- END: CORRECTED LOGIC ---

    if (targetStopIds.size === 0) {
        // This is the error message you were seeing. It will now only trigger if the looked-up config truly has no stops.
        container.innerHTML = '<p style="color:#f1c40f;">Target route has no defined stop sequence in RSG. Cannot determine eligibility.</p>';
        return;
    }

    // 2. Get the defined curtailment points for the SOURCE route
    // Note: The source destination dropdown also uses the config key as its value. We need the actual destinationName from the config.
    const sourceConfig = rsg_loadedConfigs_extra[sourceDestKey];
    if (!sourceConfig) {
        container.innerHTML = '<p style="color:#e74c3c;">Could not load source configuration data.</p>';
        return;
    }
    const sourceDestName = sourceConfig.destinationName; // Get the actual destination name for the Firebase path
    
    const { database, dbGet, dbRef } = window.firebaseOMSI;
    const sourcePath = `${FB_PATH_CURTAILMENT_POINTS}/${sanitizeFirebaseKey(sourceRoute)}/${sanitizeFirebaseKey(sourceDestName)}`;
    const snapshot = await dbGet(dbRef(database, sourcePath));
    const sourcePoints = snapshot.exists() ? snapshot.val() : [];
    
    // 3. Find which source points are eligible
    const eligiblePoints = sourcePoints.filter(sourcePoint => targetStopIds.has(sourcePoint.lastStopID));

    if (eligiblePoints.length === 0) {
        container.innerHTML = '<p style="opacity:0.8;">No compatible curtailment points found on the source route that exist on the target route.</p>';
        return;
    }

    // 4. Render checkboxes for eligible points (this part remains the same)
    container.innerHTML = '';
    eligiblePoints.forEach((point, index) => {
        const stopInfo = allDefinedStops_data[point.lastStopID.toUpperCase()] || { stopName: 'Unknown Stop' };
        const checkboxId = `op-copy-cb-${index}`;
        const itemDiv = document.createElement('div');
        itemDiv.style.marginBottom = '0.4rem';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = checkboxId;
        checkbox.value = point.lastStopID;
        checkbox.dataset.newDestName = point.newDestinationName;
        checkbox.style.marginRight = '8px';

        const label = document.createElement('label');
        label.htmlFor = checkboxId;
        label.textContent = `At: ${stopInfo.stopName} (${point.lastStopID}) | Displays: "${point.newDestinationName}"`;
        
        itemDiv.appendChild(checkbox);
        itemDiv.appendChild(label);
        container.appendChild(itemDiv);
    });
}

async function op_points_performCopy() {
    const targetRoute = document.getElementById('op-points-route-select-extra').value;
    // The value of the destination dropdown is the unique key of the RSG config
    const targetDestKey = document.getElementById('op-points-dest-select-extra').value;
    const statusMsg = document.getElementById('op-copy-modal-status-extra');
    const selectedCheckboxes = document.querySelectorAll('#op-copy-eligible-points-container-extra input[type="checkbox"]:checked');

    if (selectedCheckboxes.length === 0) {
        statusMsg.textContent = "No points selected to copy.";
        statusMsg.style.color = "#f1c40f";
        return;
    }

    // First, we must get the actual destination name from the target's config key
    const targetConfig = rsg_loadedConfigs_extra[targetDestKey];
    if (!targetConfig || !targetConfig.destinationName) {
        statusMsg.textContent = "Error: Could not determine target destination name from selection.";
        statusMsg.style.color = "#e74c3c";
        return;
    }
    const targetDestinationName = targetConfig.destinationName;

    statusMsg.textContent = "Copying points...";
    statusMsg.style.color = "#3498db";

    const { database, dbGet, dbSet, dbRef } = window.firebaseOMSI;
    const targetPath = `${FB_PATH_CURTAILMENT_POINTS}/${sanitizeFirebaseKey(targetRoute)}/${sanitizeFirebaseKey(targetDestinationName)}`;
    
    // Get current points for the target to avoid duplicates
    const snapshot = await dbGet(dbRef(database, targetPath));
    let targetPoints = snapshot.exists() ? snapshot.val() : [];

    let pointsAddedCount = 0;
    selectedCheckboxes.forEach(cb => {
        const newPoint = {
            lastStopID: cb.value,
            newDestinationName: cb.dataset.newDestName
        };

        // --- START: CORRECTED DUPLICATE CHECK ---
        // The check now verifies that BOTH the stopID and the newDestinationName do not already exist together.
        if (!targetPoints.some(p => p.lastStopID === newPoint.lastStopID && p.newDestinationName === newPoint.newDestinationName)) {
            targetPoints.push(newPoint);
            pointsAddedCount++;
        }
        // --- END: CORRECTED DUPLICATE CHECK ---
    });

    if (pointsAddedCount === 0) {
        // This message will now only appear if all selected points are true duplicates (same stop AND same display name).
        statusMsg.textContent = "All selected points already exist on the target.";
        statusMsg.style.color = "#7f8c8d";
        return;
    }

    try {
        await dbSet(dbRef(database, targetPath), targetPoints);
        statusMsg.textContent = `Successfully copied ${pointsAddedCount} point(s)!`;
        statusMsg.style.color = "#2ecc71";

        // Refresh the main display and close the modal
        op_points_displayDefinedPoints();
        setTimeout(op_points_closeCopyModal, 1500);

    } catch (error) {
        statusMsg.textContent = "Error saving copied points: " + error.message;
        statusMsg.style.color = "#e74c3c";
    }
}

function populateScdStopSelector_ExtraPage() {
    if (!scdStopSelect_el_extra || !allDefinedStops_data) {
        console.warn("SCD: Stop selector element or allDefinedStops_data not found.");
        return;
    }

    const currentSelectedValue = scdStopSelect_el_extra.value;
    scdStopSelect_el_extra.innerHTML = '<option value="">-- Select Stop --</option>';

    const stopsArray = Object.values(allDefinedStops_data);

    // Sort stops alphabetically by name, then by ID
    stopsArray.sort((a, b) => {
        const nameA = (a.stopName || "").toLowerCase();
        const nameB = (b.stopName || "").toLowerCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        return (a.stopID || "").localeCompare(b.stopID || "");
    });

    let selectedStillExists = false;
    stopsArray.forEach(stop => {
        if (stop && stop.stopID && stop.stopName) {
            const option = document.createElement('option');
            option.value = stop.stopID;
            // CORRECTED LINE: Remove the span and math-inline syntax
            option.textContent = `${stop.stopName} (${stop.stopID})`; 
            scdStopSelect_el_extra.appendChild(option);
            if (stop.stopID === currentSelectedValue) {
                selectedStillExists = true;
            }
        }
    });

    // Restore previous selection if it still exists
    if (selectedStillExists) {
        scdStopSelect_el_extra.value = currentSelectedValue;
    } else {
        scdStopSelect_el_extra.value = ""; // Clear if previous selection is no longer valid
    }
    // Also clear search input and results when repopulating the select
    if (scdStopSearchInput_el_extra) scdStopSearchInput_el_extra.value = '';
    if (scdStopSearchResults_el_extra) scdStopSearchResults_el_extra.innerHTML = '<p style="padding: 0.5rem; opacity:0.7;">Start typing to search for stops.</p>';

    // ADDED EVENT LISTENER:
    scdStopSelect_el_extra.onchange = () => {
        displayScdScheduledEvents(scdStopSelect_el_extra.value);
        if (scdStopSearchInput_el_extra) scdStopSearchInput_el_extra.value = ''; // Clear search when dropdown is used
    };
}

function handleScdStopSearch_ExtraPage() {
    if (!scdStopSearchInput_el_extra || !scdStopSearchResults_el_extra || !allDefinedStops_data) {
        return;
    }

    const searchTerm = scdStopSearchInput_el_extra.value.toLowerCase().trim();
    scdStopSearchResults_el_extra.innerHTML = ''; // Clear previous results

    if (searchTerm.length < 2) {
        scdStopSearchResults_el_extra.innerHTML = '<p style="padding: 0.5rem; opacity:0.7;">Start typing to search for stops.</p>';
        return;
    }

    const definedStopsArray = Object.values(allDefinedStops_data);

    const filteredStops = definedStopsArray.filter(stop => {
        const stopName = stop.stopName || "";
        const stopID = stop.stopID || "";
        return stopName.toLowerCase().includes(searchTerm) || stopID.toLowerCase().includes(searchTerm);
    }).slice(0, 10); // Limit results to top 10

    if (filteredStops.length > 0) {
        filteredStops.forEach(stop => {
            const itemDiv = document.createElement('div');
            itemDiv.classList.add('rsg-search-result-item'); // Reuse RSG styling

            let content = `<span class="rsg-search-stop-name"><span class="math-inline">\{stop\.stopName \|\| 'N/A'\} \(</span>{stop.stopID})</span>`;
            if (stop.direction && stop.direction.trim() !== "" && stop.direction.trim().toUpperCase() !== "NO DIRECTION") {
                content += `<span class="rsg-search-stop-details">Towards: ${stop.direction}</span>`;
            }

            itemDiv.innerHTML = content;
            itemDiv.addEventListener('click', () => {
                scdStopSelect_el_extra.value = stop.stopID; // Set the dropdown value
                scdStopSearchInput_el_extra.value = ''; // Clear search input
                scdStopSearchResults_el_extra.innerHTML = ''; // Clear search results
                displayScdScheduledEvents(stop.stopID); // Trigger display for the selected stop
            });
            scdStopSearchResults_el_extra.appendChild(itemDiv);
        });
    } else {
        scdStopSearchResults_el_extra.innerHTML = '<div class="rsg-search-result-item">No matching stops found.</div>';
    }
}

async function displayScdScheduledEvents(selectedStopID) {
    // --- 1. SETUP & VALIDATION ---
    if (!scdEventList_el_extra || !scdNoEventsMessage_el_extra || !scdStatusMessage_el_extra || !currentUser_extra || !rsg_loadedConfigs_extra) {
        if (scdStatusMessage_el_extra) {
            scdStatusMessage_el_extra.textContent = "Error: System components (RSG configs, etc.) not loaded.";
            scdStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    scdEventList_el_extra.innerHTML = '';
    scdNoEventsMessage_el_extra.style.display = 'block';
    scdNoEventsMessage_el_extra.textContent = 'Analyzing today\'s active RSG configurations...';
    if (scdStatusMessage_el_extra) scdStatusMessage_el_extra.textContent = '';

    if (!selectedStopID) {
        scdNoEventsMessage_el_extra.textContent = 'Select a stop to view its scheduled events.';
        return;
    }

    const selectedStopIDUpper = selectedStopID.toUpperCase();
    const stopDetails = allDefinedStops_data[selectedStopIDUpper] || { stopName: selectedStopID, direction: '' };
    scdStatusMessage_el_extra.textContent = `Analyzing RSG configurations for stop: ${stopDetails.stopName || selectedStopID}...`;
    scdStatusMessage_el_extra.style.color = '#f1c40f';

    // --- 2. DATA GATHERING - DIRECT FROM RSG CONFIGS ---
    const eventsForDisplay = [];
    const todaysActiveProfiles = getOperatingCodesForDate_ExtraPage(new Date());

    // Loop through all saved RSG configurations
    for (const configKey in rsg_loadedConfigs_extra) {
        const config = rsg_loadedConfigs_extra[configKey];
        if (!config || !config.operatingProfile) continue;

        // Check if this configuration is active today
        const configProfiles = config.operatingProfile.split(',').map(p => p.trim());
        const isActiveToday = configProfiles.some(profile => todaysActiveProfiles.includes(profile));

        if (isActiveToday) {
            // Generate all trips for this active configuration
            const trips = generateScheduleTripsFromConfig(config);

            // For each generated trip, check if it serves the selected stand
            trips.forEach(trip => {
                if (trip.length === 0) return;
                const tripId = `${trip[0].lineName}|${trip[0].destinationName}|${trip[0].OperatingProfile}|${trip[0].scheduledTime}|${trip[0].DayOffset || '0'}`;

                for (let i = 0; i < trip.length; i++) {
                    const currentStopEntry = trip[i];
                    if (currentStopEntry.stopID.toUpperCase() === selectedStopIDUpper) {
                        
                        // A. This is a DEPARTURE from our stand. Time is calculated directly from RSG.
                        eventsForDisplay.push({
                            type: 'Departure',
                            lineName: currentStopEntry.lineName,
                            destinationName: currentStopEntry.destinationName,
                            operatingProfile: currentStopEntry.OperatingProfile,
                            scheduledTime: currentStopEntry.scheduledTime,
                            DayOffset: currentStopEntry.DayOffset || '0',
                            timeAbs: getAbsMinutes(currentStopEntry.scheduledTime, parseInt(currentStopEntry.DayOffset || '0')),
                            tripId: tripId,
                        });

                        // B. The ARRIVAL is the departure from the now-correct PREVIOUS stop.
                        if (i > 0) {
                            const previousStopEntry = trip[i - 1];
                            eventsForDisplay.push({
                                type: 'Arrival',
                                lineName: previousStopEntry.lineName,
                                destinationName: previousStopEntry.destinationName,
                                operatingProfile: previousStopEntry.OperatingProfile,
                                scheduledTime: previousStopEntry.scheduledTime,
                                DayOffset: previousStopEntry.DayOffset || '0',
                                timeAbs: getAbsMinutes(previousStopEntry.scheduledTime, parseInt(previousStopEntry.DayOffset || '0')),
                                tripId: tripId,
                                originStopName: previousStopEntry.stopName // Will now be correct
                            });
                        }
                        break; 
                    }
                }
            });
        }
    }

    // --- 3. CONFLICT DETECTION & RENDERING (No changes needed here) ---
    if (eventsForDisplay.length === 0) {
        scdNoEventsMessage_el_extra.textContent = `No events found for stop ${stopDetails.stopName} (${selectedStopID}) from today's active RSG configurations.`;
        scdStatusMessage_el_extra.textContent = 'Analysis complete.';
        scdStatusMessage_el_extra.style.color = '';
        return;
    }
    
    eventsForDisplay.sort((a, b) => {
        if (a.timeAbs !== b.timeAbs) return a.timeAbs - b.timeAbs;
        if (a.type === 'Arrival' && b.type === 'Departure') return -1;
        if (a.type === 'Departure' && b.type === 'Arrival') return 1;
        return 0;
    });

    const CONFLICT_WINDOW_MINUTES = 2;
    const conflictsFoundTripIds = new Set();
    
    for (let i = 0; i < eventsForDisplay.length - 1; i++) {
        const event1 = eventsForDisplay[i];
        const event2 = eventsForDisplay[i + 1];

        if (event1.tripId === event2.tripId) continue;

        const timeDiff = event2.timeAbs - event1.timeAbs;
        if (timeDiff > 0 && timeDiff <= CONFLICT_WINDOW_MINUTES) {
            event1.isConflict = true;
            event2.isConflict = true;
            conflictsFoundTripIds.add(event1.tripId);
            conflictsFoundTripIds.add(event2.tripId);
        }
    }

    scdNoEventsMessage_el_extra.style.display = 'none';
    let html = '';
    eventsForDisplay.forEach(event => {
        const routeColor = getRouteTileColour_ExtraPage(event.lineName, selectedStopID);
        const textColor = getTextColourForBackground_ExtraPage(routeColor);
        const isConflictClass = event.isConflict ? 'background-color: #e74c3c; border-left: 4px solid #c0392b;' : '';
        const conflictTitle = event.isConflict ? 'title="Potential conflict at this stop!"' : '';
        const displayDayOffset = event.DayOffset && parseInt(event.DayOffset) !== 0 ? ` (+${event.DayOffset}d)` : '';

        const eventDetailsText = event.type === 'Arrival' ?
            `Arriving at Stand (from ${event.originStopName || 'previous stop'})` :
            `Departing from Stand`;

        const routeTileDisplay = `<span style="font-weight: bold; color: ${textColor}; padding: 0.2em 0.5em; border-radius: 3px; background-color: ${routeColor};">${event.lineName}</span>`;

        html += `
            <li style="margin-bottom: 0.5em; padding: 0.6em; border-radius: 0.25rem; background-color: rgba(255,255,255,0.05); ${isConflictClass}" ${conflictTitle}>
                <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.9em;">
                    ${routeTileDisplay}
                    <span style="margin-left: 0.5em; flex-grow: 1;">
                        <strong style="color: #ffffff;">${event.scheduledTime}${displayDayOffset}</strong>
                        <span style="opacity: 0.8; margin-left: 0.5em;">${eventDetailsText}</span>
                    </span>
                    <span style="font-size: 0.8em; opacity: 0.6;">(P: ${event.operatingProfile})</span>
                </div>
            </li>
        `;
    });
    scdEventList_el_extra.innerHTML = html;

    scdStatusMessage_el_extra.textContent = `Analysis complete. Displaying ${eventsForDisplay.length} events directly from RSG configurations. Conflicts detected involving ${conflictsFoundTripIds.size} trip(s).`;
    scdStatusMessage_el_extra.style.color = conflictsFoundTripIds.size > 0 ? '#e74c3c' : '#2ecc71';
}

/**
 * Diagnostic tool to inspect the raw data of a saved RSG configuration.
 */
function inspectRsgConfig(routeName, operatingProfile, destinationName) {
    if (typeof rsg_loadedConfigs_extra === 'undefined' || !rsg_loadedConfigs_extra) {
        console.error("The variable 'rsg_loadedConfigs_extra' is not available. Please ensure you are logged in and the page is fully loaded.");
        return;
    }

    console.log(`--- Inspecting RSG Configs for Route: "${routeName}", Profile: "${operatingProfile}", Destination: "${destinationName}" ---`);

    let foundConfig = null;
    let foundKey = null;

    // Search for a configuration that matches all criteria
    for (const key in rsg_loadedConfigs_extra) {
        const config = rsg_loadedConfigs_extra[key];
        const configProfiles = (config.operatingProfile || "").split(',').map(p => p.trim());
        const targetProfiles = (operatingProfile || "").split(',').map(p => p.trim());
        
        // Check if all target profiles are present in the config's profiles
        const profileMatch = targetProfiles.every(tp => configProfiles.includes(tp));

        if (config.routeName === routeName && config.destinationName === destinationName && profileMatch) {
            foundConfig = config;
            foundKey = key;
            break;
        }
    }

    if (!foundConfig) {
        console.log(`%c[NOT FOUND] No saved RSG configuration matched the provided criteria.`, "color: red; font-weight: bold;");
        console.log("Please check that the route name, destination, and operating profile(s) exactly match what is saved in the RSG tool.");
        return;
    }

    console.log(`%c[FOUND] Matched Configuration with Key: ${foundKey}`, "color: green; font-weight: bold;");
    console.log("Display Name:", foundConfig.userDisplayName);
    
    console.log("\n--- First Stop Departure Times ---");
    console.log(`[${foundConfig.firstStopTimes}]`);

    console.log("\n--- Stop Sequence with Time Adjustments ---");
    console.log("This table shows the 'Minutes from previous stop' values that are being used for calculations.");
    
    // Use console.table for a clean, readable output
    const tableData = foundConfig.stopSequence.map((stop, index) => ({
        '#': index + 1,
        'Stop Name': stop.stopName,
        'Stop ID': stop.stopID,
        'Time Adjustment (mins)': stop.timeAdjustment
    }));
    console.table(tableData);
    
    console.log("\n--- End of Inspection ---");
}

function rsg_handleDestinationNameSelectChange_ExtraPage() {
    if (!rsgDestinationNameSelect_el_extra || !rsgDestinationNameInput_el_extra) {
        return;
    }
    rsgDestinationNameInput_el_extra.value = rsgDestinationNameSelect_el_extra.value;
    const event = new Event('input', { bubbles: true, cancelable: true });
    rsgDestinationNameInput_el_extra.dispatchEvent(event);
    const blurEvent = new Event('blur', { bubbles: true, cancelable: true });
    rsgDestinationNameInput_el_extra.dispatchEvent(blurEvent);
}

/**
 * Generates an array of trips based on a single RSG configuration object.
 * Each trip is an array of stop entries with calculated times.
 * @param {object} config - A single configuration object from rsg_loadedConfigs_extra.
 * @returns {Array<Array<object>>} An array of trips.
 */
function generateScheduleTripsFromConfig(config) {
    if (!config || !config.stopSequence || !config.firstStopTimes) {
        return [];
    }
    
    const trips = [];
    const firstStopTimes = (config.firstStopTimes || "").split(/\t|,|;/).map(t => t.trim()).filter(t => t.match(/^\d{2}:\d{2}$/));

    firstStopTimes.forEach(startTimeHHMM => {
        const singleTrip = [];
        const startParts = startTimeHHMM.split(':');
        let currentMinutesFromMidnight = parseInt(startParts[0], 10) * 60 + parseInt(startParts[1], 10);
        let currentDayOffset = 0;

        config.stopSequence.forEach((stop, index) => {
            if (!stop || typeof stop.stopID === 'undefined') return;

            if (index > 0) {
                const adjustment = (typeof stop.timeAdjustment === 'number' && !isNaN(stop.timeAdjustment)) ? stop.timeAdjustment : 0;
                currentMinutesFromMidnight += adjustment;
            }

            // Normalize time to handle passing midnight
            let effectiveMinutes = currentMinutesFromMidnight;
            let effectiveDayOffset = currentDayOffset;
            while (effectiveMinutes >= 1440) {
                effectiveMinutes -= 1440;
                effectiveDayOffset++;
            }
            while (effectiveMinutes < 0) {
                effectiveMinutes += 1440;
                effectiveDayOffset--;
            }

            const hours = Math.floor(effectiveMinutes / 60);
            const minutes = effectiveMinutes % 60;
            const scheduledTimeOutput = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            
            singleTrip.push({
                stopID: stop.stopID,
                stopName: stop.stopName,
                direction: stop.direction,
                lineName: config.routeName,
                destinationName: config.destinationName,
                OperatingProfile: config.operatingProfile,
                scheduledTime: scheduledTimeOutput,
                DayOffset: String(effectiveDayOffset)
            });
        });
        if(singleTrip.length > 0) {
            trips.push(singleTrip);
        }
    });
    return trips;
}

function showTripAlertPopup_ExtraPage(message, type = 'info') { // Added type for styling
    const banner = document.getElementById('global-notification-banner');
    if (!banner) {
        console.error("Global notification banner not found for in-page trip alert.");
        return;
    }

    // Set banner content and style based on type
    let backgroundColor;
    let textColor = 'white'; // Default text color

    switch (type) {
        case 'error':
            backgroundColor = '#e74c3c'; // Red
            break;
        case 'warning':
            backgroundColor = '#f39c12'; // Yellow
            textColor = '#2c3e50'; // Darker text for yellow bg
            break;
        case 'success':
            backgroundColor = '#27ae60'; // Green
            break;
        case 'info': // Default for trip alerts
        default:
            backgroundColor = '#3498db'; // Blue
            break;
    }

    banner.innerHTML = ''; // Clear previous content (e.g., from a scheduled task alert)

    const messageSpan = document.createElement('span');
    messageSpan.textContent = message;
    messageSpan.style.flexGrow = '1'; // Allow message to take available space
    messageSpan.style.textAlign = 'left'; // Align text to the left

    const closeButton = document.createElement('button');
    closeButton.innerHTML = '&times;'; // '' character for a close symbol
    closeButton.style.marginLeft = '15px';
    closeButton.style.padding = '0.2em 0.5em';
    closeButton.style.fontSize = '1.2em';
    closeButton.style.fontWeight = 'bold';
    closeButton.style.lineHeight = '1';
    closeButton.style.border = 'none';
    closeButton.style.background = 'transparent';
    closeButton.style.color = textColor; // Match banner text color
    closeButton.style.cursor = 'pointer';
    closeButton.title = 'Dismiss';
    closeButton.setAttribute('aria-label', 'Dismiss notification');
    closeButton.onclick = (e) => {
        e.stopPropagation(); // Prevent any parent handlers
        banner.style.display = 'none';
    };

    banner.appendChild(messageSpan);
    banner.appendChild(closeButton);

    // Apply styles to the banner
    banner.style.backgroundColor = backgroundColor;
    banner.style.color = textColor;
    banner.style.display = 'flex'; // Use flex for better alignment
    banner.style.justifyContent = 'space-between';
    banner.style.alignItems = 'center';
    banner.style.padding = '12px 15px'; // Re-apply padding if cleared by innerHTML
    banner.style.position = 'sticky'; // Ensure it's sticky
    banner.style.top = '0';
    banner.style.left = '0';
    banner.style.width = '100%';
    banner.style.zIndex = '1060';
    banner.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
}

function segmentScheduleEntriesIntoTrips(
    scheduleEntriesForServiceLeg,
    minStopsPerTripHeuristic = 2 // Sensible default
) {
    const allTrips = [];
    if (!scheduleEntriesForServiceLeg || scheduleEntriesForServiceLeg.length === 0) {
        return allTrips;
    }

    const sortedEntries = [...scheduleEntriesForServiceLeg].sort((a, b) => {
        const absA = getAbsMinutes(a.scheduledTime, parseInt(a.DayOffset || 0));
        const absB = getAbsMinutes(b.scheduledTime, parseInt(b.DayOffset || 0));
        if (absA === absB) return 0;
        if (absA === null) return 1;
        if (absB === null) return -1;
        return absA - absB;
    });

    let currentTrip = [];
    let previousStopTimeAbs = -1;
    let firstStopTimeOfCurrentLogicalTripAbs = -1;

    for (let i = 0; i < sortedEntries.length; i++) {
        const entry = sortedEntries[i];
        if (!entry.stopID || !entry.scheduledTime) continue;

        const currentStopTimeAbs = getAbsMinutes(entry.scheduledTime, parseInt(entry.DayOffset || 0));
        if (currentStopTimeAbs === null) continue;

        if (currentTrip.length === 0) {
            firstStopTimeOfCurrentLogicalTripAbs = currentStopTimeAbs;
        } else {
            let splitTrip = false;
            if (currentStopTimeAbs < previousStopTimeAbs) {
                splitTrip = true;
            } else if (
                entry.stopID === currentTrip[0].stopID &&
                currentTrip.length >= minStopsPerTripHeuristic &&
                currentStopTimeAbs > firstStopTimeOfCurrentLogicalTripAbs
            ) {
                splitTrip = true;
            }

            if (splitTrip) {
                if (currentTrip.length > 0) {
                    allTrips.push([...currentTrip]);
                }
                currentTrip = [];
                firstStopTimeOfCurrentLogicalTripAbs = currentStopTimeAbs;
            }
        }
        currentTrip.push(entry);
        previousStopTimeAbs = currentStopTimeAbs;
    }

    if (currentTrip.length > 0) {
        allTrips.push([...currentTrip]);
    }
    return allTrips;
}

async function fetchBankHolidays_ExtraPage() {
    const cacheKey = 'ukBankHolidaysData_cache';
    const cachedData = localStorage.getItem(cacheKey);
    const now = new Date().getTime();

    if (cachedData) {
        try {
            const parsedCache = JSON.parse(cachedData);
            if (parsedCache.timestamp && (now - parsedCache.timestamp < BANK_HOLIDAY_CACHE_DURATION_MS) && parsedCache.data) {
                ukBankHolidaysData_extra = parsedCache.data;
                console.log("Bank holidays loaded from cache for division:", ukBankHolidaysData_extra.division);
                // Ensure it has the expected structure after loading from cache
                if (!ukBankHolidaysData_extra.dates || !ukBankHolidaysData_extra.titles) {
                    console.warn("Cached bank holiday data is malformed, fetching fresh.");
                    localStorage.removeItem(cacheKey); // Remove bad cache
                } else {
                    return; // Use cached data
                }
            } else {
                localStorage.removeItem(cacheKey); // Cache expired or invalid
            }
        } catch (e) {
            console.error("Error parsing cached bank holiday data, fetching fresh:", e);
            localStorage.removeItem(cacheKey);
        }
    }

    console.log("Fetching fresh bank holiday data from API...");
    try {
        const response = await fetch('https://www.gov.uk/bank-holidays.json');
        if (!response.ok) {
            throw new Error(`HTTP error when fetching bank holidays! status: ${response.status}`);
        }
        const allDivisionsData = await response.json();

        // Assuming you want 'england-and-wales' - adjust if needed
        const divisionData = allDivisionsData['england-and-wales'];

        if (divisionData && divisionData.events && Array.isArray(divisionData.events)) {
            const datesArray = [];
            const titlesObject = {};
            divisionData.events.forEach(event => {
                if (event.date && event.title) { // Expects "YYYY-MM-DD"
                    datesArray.push(event.date);
                    titlesObject[event.date] = event.title;
                }
            });

            ukBankHolidaysData_extra = {
                division: divisionData.division || 'england-and-wales',
                dates: datesArray,
                titles: titlesObject
            };

            localStorage.setItem(cacheKey, JSON.stringify({ timestamp: now, data: ukBankHolidaysData_extra }));
            console.log("Bank holidays fetched and cached for division:", ukBankHolidaysData_extra.division);
        } else {
            console.error("Bank holiday data for 'england-and-wales' division not found or in unexpected format.", allDivisionsData);
            ukBankHolidaysData_extra = { division: 'england-and-wales', dates: [], titles: {} }; // Set to empty on error
        }
    } catch (error) {
        console.error("Failed to fetch or process bank holidays:", error);
        // Ensure ukBankHolidaysData_extra is in a consistent empty state on error if not using cache
        if (!cachedData) { // Only reset if there was no valid cache to fall back to
             ukBankHolidaysData_extra = { division: '', dates: [], titles: {} };
        }
    }
}

async function prepareKeyTripTimesForAlerts_ExtraPage() {
    const functionStartTime = new Date();
    const allPotentialEvents = [];
    const todayForAlerts = new Date();
    lastAlertDataPreparedDate_extra = todayForAlerts.toDateString();
    
    const operationalDatesToConsider = [
        { date: todayForAlerts, label: "current" },
    ];
    const yesterdayForAlerts = new Date(todayForAlerts);
    yesterdayForAlerts.setDate(todayForAlerts.getDate() - 1);
    operationalDatesToConsider.push({ date: yesterdayForAlerts, label: "previous" });

    if (!rsg_loadedConfigs_extra || Object.keys(rsg_loadedConfigs_extra).length === 0) {
        todayKeyTripEvents_extra = [];
        return;
    }

    for (const opDay of operationalDatesToConsider) {
        const currentOperationalDate = opDay.date;
        const opDayLabel = opDay.label;
        const dateStringYYYYMMDD = getYYYYMMDD_ExtraPage(currentOperationalDate);

        for (const configKey in rsg_loadedConfigs_extra) {
            if (!Object.hasOwnProperty.call(rsg_loadedConfigs_extra, configKey)) continue;
            
            const rsgConfig = rsg_loadedConfigs_extra[configKey];
            const configUserDisplayName = rsgConfig.userDisplayName || configKey;
            const routeName = rsgConfig.routeName;

            if (!routeName) {
                continue;
            }

            const isNRoute = routeName.toUpperCase().startsWith('N');
            const futureDatePattern = /\(from\s*\d{6}\)/;
            if (futureDatePattern.test(configUserDisplayName)) {
                continue;
            }

            const configOperatingProfiles = (rsgConfig.operatingProfile || "").split(',').map(p => p.trim());
            const effectiveProfilesForThisRouteOnThisDate = getOperatingCodesForDate_ExtraPage(currentOperationalDate, routeName);
            const isActiveForThisOpDate = configOperatingProfiles.some(cop => effectiveProfilesForThisRouteOnThisDate.includes(cop));
            
            if (!isActiveForThisOpDate) {
                continue;
            }
            
            if (!isNRoute) {
                const routeColor = getRouteTileColour_ExtraPage(routeName, null).toUpperCase();
                const nightBusColor = (globalCustomRouteColours_extra["NIGHT_DEFAULT"] || NIGHT_BUS_BLUE_COLOR_extra).toUpperCase();
                
                if (routeColor === nightBusColor) {
                    let allowThisService = false;
                    const configIsForChristmasEve = (rsgConfig.operatingProfile || "").includes("Christmas Eve");
                    const opDayIsEffectivelyChristmasEve = effectiveProfilesForThisRouteOnThisDate.includes("Christmas Eve");
                    if (configIsForChristmasEve && opDayIsEffectivelyChristmasEve) {
                        allowThisService = true;
                    }
                    const configIsForBoxingDay = (rsgConfig.operatingProfile || "").includes("Boxing Day");
                    const opDayIsEffectivelyBoxingDay = effectiveProfilesForThisRouteOnThisDate.includes("Boxing Day");
                    if (!allowThisService && configIsForBoxingDay && opDayIsEffectivelyBoxingDay) {
                        allowThisService = true;
                    }

                    if (!allowThisService) {
                        continue; 
                    }
                }
            }

            if (!rsgConfig.firstStopTimes || rsgConfig.firstStopTimes.trim() === "" ||
                !rsgConfig.stopSequence || rsgConfig.stopSequence.length === 0) {
                continue;
            }

            const rawDepartureTimes = (rsgConfig.firstStopTimes || "").split(/\s*[\t;,]\s*/)
                                         .map(t => t.trim()).filter(t => t.match(/^\d{2}:\d{2}$/));
            
            if (rawDepartureTimes.length === 0) {
                continue;
            }

            let hasLateNightTimesInList = rawDepartureTimes.some(t => parseInt(t.substring(0,2)) >= 20);
            let hasEarlyMorningTimesInList = rawDepartureTimes.some(t => parseInt(t.substring(0,2)) < 6);

            const departureTimeObjectsSorted = rawDepartureTimes.map(timeStr => {
                let [h, m] = timeStr.split(':').map(Number);
                let sortableMinutes = h * 60 + m;
                if ( (isNRoute && h < 6) ||
                     (h < 4 && hasLateNightTimesInList && hasEarlyMorningTimesInList) ) {
                    sortableMinutes += 1440;
                }
                return { timeStr, sortableMinutes };
            }).sort((a, b) => a.sortableMinutes - b.sortableMinutes);

            if (departureTimeObjectsSorted.length === 0) continue;

            const firstDepartureTimeStr = departureTimeObjectsSorted[0].timeStr;
            const lastDepartureTimeStr = departureTimeObjectsSorted[departureTimeObjectsSorted.length - 1].timeStr;
            const firstStopOfSequence = rsgConfig.stopSequence[0];
            const lastStopOfSequence = rsgConfig.stopSequence[rsgConfig.stopSequence.length - 1];
            const headsignDestinationName = rsgConfig.destinationName;

            const eventBaseData = {
                lineName: routeName, headsignDestinationName: headsignDestinationName,
                originStopName: firstStopOfSequence.stopName || firstStopOfSequence.stopID,
                actualTerminusName: lastStopOfSequence.stopName || lastStopOfSequence.stopID,
                operatingProfile: rsgConfig.operatingProfile,
                rsgConfigUserDisplayName: configUserDisplayName || configKey
            };

            const firstDepartureTimeObj = createEventTimeObjForAlert(firstDepartureTimeStr, currentOperationalDate, hasLateNightTimesInList, hasEarlyMorningTimesInList, isNRoute);
            const lastDepartureTimeObj = createEventTimeObjForAlert(lastDepartureTimeStr, currentOperationalDate, hasLateNightTimesInList, hasEarlyMorningTimesInList, isNRoute);
            
            const firstTripType = isNRoute ? 'n-bus-first-trip' : 'rsg-first-trip';
            const lastTripType = isNRoute ? 'n-bus-last-trip' : 'rsg-last-trip';

            allPotentialEvents.push({
                ...eventBaseData, type: firstTripType, configKey: configKey,
                departureTime: firstDepartureTimeStr,
                departureTimeObj: firstDepartureTimeObj,
            });

            if (lastDepartureTimeStr !== firstDepartureTimeStr || departureTimeObjectsSorted.length > 1) {
                allPotentialEvents.push({
                    ...eventBaseData, type: lastTripType, configKey: configKey,
                    departureTime: lastDepartureTimeStr,
                    departureTimeObj: lastDepartureTimeObj,
                });
            }
        }
    }

    const tomorrowForAlerts = new Date(todayForAlerts);
    tomorrowForAlerts.setDate(todayForAlerts.getDate() + 1);
    const todayDateStrForFilter = todayForAlerts.toDateString();
    const tomorrowDateStrForFilter = tomorrowForAlerts.toDateString();
    
    let filteredEventsForDisplay = allPotentialEvents.filter(event => {
        if (!event.departureTimeObj) {
            return false;
        }
        const eventCalendarDateStr = event.departureTimeObj.toDateString();
        return eventCalendarDateStr === todayDateStrForFilter || eventCalendarDateStr === tomorrowDateStrForFilter;
    });

    filteredEventsForDisplay.sort((a,b) => {
        if (!a.departureTimeObj && !b.departureTimeObj) return 0;
        if (!a.departureTimeObj) return 1;
        if (!b.departureTimeObj) return -1;
        const timeDiff = a.departureTimeObj.getTime() - b.departureTimeObj.getTime();
        if (timeDiff !== 0) return timeDiff;
        return a.type.localeCompare(b.type);
    });

    // --- START: NUANCED DE-DUPLICATION LOGIC ---
    const uniqueEvents = [];
    const seenEventSignaturesForAlert = new Set();
    for (const event of filteredEventsForDisplay) {
        
        let signatureBase;
        const isFirstTrip = event.type === 'n-bus-first-trip' || event.type === 'rsg-first-trip';

        if (isFirstTrip) {
            // For FIRST trips, use a SPECIFIC signature that includes the date, allowing one for each operational night.
            signatureBase = `${event.type}|${event.lineName}|${event.headsignDestinationName}|${event.departureTime}|${event.departureTimeObj.toDateString()}`;
        } else {
            // For LAST trips, use a GENERAL signature, so only one true "last bus" is ever shown.
            signatureBase = `${event.type}|${event.lineName}|${event.headsignDestinationName}|${event.departureTime}`;
        }

        if (!seenEventSignaturesForAlert.has(signatureBase)) {
            uniqueEvents.push(event);
            seenEventSignaturesForAlert.add(signatureBase);
        }
    }
    todayKeyTripEvents_extra = uniqueEvents;
    // --- END: NUANCED DE-DUPLICATION LOGIC ---
}

function checkAndShowTripAlerts_ExtraPage() {
    const checkStartTime = new Date();
    // console.log(`[DEBUG CHECK&SHOW ${checkStartTime.toLocaleTimeString()}] Function Entry: checkAndShowTripAlerts_ExtraPage`);
    const now = new Date();

    if (now.toDateString() !== lastAlertDataPreparedDate_extra) {
        console.log(`[DEBUG CHECK&SHOW ${checkStartTime.toLocaleTimeString()}] Date changed from ${lastAlertDataPreparedDate_extra} to ${now.toDateString()}. Refreshing alert data.`);
        if (typeof prepareKeyTripTimesForAlerts_ExtraPage === 'function') {
            // This is async, but for alerts, it's okay if it runs in background.
            // The *next* call to checkAndShowTripAlerts_ExtraPage will use the refreshed data.
            prepareKeyTripTimesForAlerts_ExtraPage();
        }
        shownTripAlerts_extra = {}; // Reset shown alerts for the new day
    }

    if (!todayKeyTripEvents_extra || todayKeyTripEvents_extra.length === 0) {
        // console.log(`[DEBUG CHECK&SHOW ${checkStartTime.toLocaleTimeString()}] No key trip events to check for alerts.`);
        return;
    }

    // console.log(`[DEBUG CHECK&SHOW ${checkStartTime.toLocaleTimeString()}] Checking ${todayKeyTripEvents_extra.length} events against current time ${now.toISOString()}`);
    todayKeyTripEvents_extra.forEach(event => {
        let alertShownId;
        // Ensure configKey is part of the ID
        alertShownId = `${event.type}|${event.configKey || 'no-key'}|${event.lineName}|${event.headsignDestinationName}|${event.departureTime}|${event.originStopName}`;

        if (shownTripAlerts_extra[alertShownId]) {
            // if (event.lineName.toUpperCase().startsWith('N')) console.log(`[DEBUG CHECK&SHOW N-ROUTE] Alert for ${alertShownId} already shown. Skipping.`);
            return;
        }
        if (!event.departureTimeObj || !(event.departureTimeObj instanceof Date)) {
            // if (event.lineName.toUpperCase().startsWith('N')) console.log(`[DEBUG CHECK&SHOW N-ROUTE] Event ${event.lineName} ${event.type} at ${event.departureTime} missing or invalid departureTimeObj. Skipping.`);
            return;
        }

        const timeDiffMs = event.departureTimeObj.getTime() - now.getTime();
        const timeDiffMinutes = timeDiffMs / (1000 * 60);

        // if (event.lineName.toUpperCase().startsWith('N')) { // Uncomment for very verbose N-route alert checking
        //      console.log(`[DEBUG CHECK&SHOW N-ROUTE] Event: ${event.lineName} ${event.type} ${event.departureTime}. Target Time: ${event.departureTimeObj.toISOString()}. Diff Mins: ${timeDiffMinutes.toFixed(2)}.`);
        // }

        if (timeDiffMinutes > 0 && timeDiffMinutes <= ALERT_LEAD_TIME_MINUTES) {
            let message = "";
            const serviceHeadsignDisplay = `${event.lineName} to ${event.headsignDestinationName}`;
            let tripTypeDescription = "";

            if (event.type === 'rsg-first-trip' || event.type === 'n-bus-first-trip') {
                tripTypeDescription = "first";
            } else if (event.type === 'rsg-last-trip' || event.type === 'n-bus-last-trip') {
                tripTypeDescription = "last";
            }


            if (tripTypeDescription) {
                message = `${serviceHeadsignDisplay} is about to depart its ${tripTypeDescription} trip for today from ${event.originStopName} at ${event.departureTime}.`;
                // if (event.lineName.toUpperCase().startsWith('N')) { // Uncomment for N-route specific alert triggering log
                //     console.log(`[DEBUG CHECK&SHOW N-ROUTE ALERT] SHOWING ALERT for ${event.lineName} ${event.type} at ${event.departureTime}. Message: "${message}"`);
                // }

                const desktopPref = localStorage.getItem('desktopNotificationPreference_omsiExtra');
                let currentNativePermission = "denied";
                if (typeof checkNotificationPermission === 'function') {
                    currentNativePermission = checkNotificationPermission();
                }

                if (desktopPref === 'granted' && currentNativePermission === 'granted') {
                    let notificationTitle = "OMSI Trip Alert";
                    if (event.lineName && event.headsignDestinationName) {
                        notificationTitle = `${event.lineName} to ${event.headsignDestinationName}`;
                    }
                    if (typeof showNativeNotification === 'function') {
                        showNativeNotification(notificationTitle, message, '/live-tracker/assets/icons/icon-192x192.png');
                    } else {
                        if (typeof showTripAlertPopup_ExtraPage === 'function') {
                            showTripAlertPopup_ExtraPage(message);
                        }
                    }
                } else {
                    if (typeof showTripAlertPopup_ExtraPage === 'function') {
                        showTripAlertPopup_ExtraPage(message);
                    }
                }
                shownTripAlerts_extra[alertShownId] = true;
            } else {
                // if (event.lineName.toUpperCase().startsWith('N')) { // Uncomment for N-route specific no-alert log
                //      console.log(`[DEBUG CHECK&SHOW N-ROUTE] Event type ${event.type} for ${event.lineName} did not result in a tripTypeDescription. No alert generated.`);
                // }
            }
        }
    });
    // console.log(`[DEBUG CHECK&SHOW ${new Date().toLocaleTimeString()}] Function Exit: checkAndShowTripAlerts_ExtraPage (Duration: ${(new Date() - checkStartTime)/1000}s)`);
}

function createEventTimeObjForAlert(timeStr, baseDate, hasLateNightTimesInList, hasEarlyMorningTimesInList, isNRoute = false) {
    const [hours, minutes] = timeStr.split(':').map(Number);

    // Create the date object using local time components.
    let eventDate = new Date(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate(), hours, minutes, 0, 0);

    // Handle overnight services by advancing the calendar day if necessary.
    let advanceDate = false;
    if (isNRoute && hours < 6) {
        advanceDate = true;
    } else if (hours < 4 && hasLateNightTimesInList && hasEarlyMorningTimesInList) {
        advanceDate = true;
    }

    if (advanceDate) {
        eventDate.setDate(eventDate.getDate() + 1);
    }

    // --- DIAGNOSTIC LINE ---
    // This will print the exact Date object being created for each key departure time.
    console.log(`[Key Departure Time Check] For schedule time "${timeStr}", created Date object:`, eventDate.toString());

    return eventDate;
}

function checkNotificationPermission() {
    if (!("Notification" in window)) {
        return "unsupported";
    }
    return Notification.permission;
}

async function requestNotificationPermission() {
    // Check if the Notification API is supported by the user's browser.
    if (!("Notification" in window)) {
        alert("This browser does not support desktop notifications.");
        return "unsupported";
    }

    const currentPermission = Notification.permission; // Get the current notification permission status.

    // If permission is already granted.
    if (currentPermission === "granted") {
        localStorage.setItem('desktopNotificationPreference_omsiExtra', 'granted'); // Store the user's preference in local storage.
        console.log("Notification permission was already granted.");

        // Attempt to get the active Service Worker registration.
        // navigator.serviceWorker.ready returns a promise that resolves with the ServiceWorkerRegistration object
        // when the service worker is active.
        let activeRegistration = null;
        try {
            activeRegistration = await navigator.serviceWorker.ready;
        } catch (err) {
            console.error("Failed to get active Service Worker registration during permission check:", err);
        }

        // If an active Service Worker registration is found, proceed to get the FCM token.
        if (activeRegistration) {
            await getFCMTokenAndStore(activeRegistration); // Pass the active registration to getFCMTokenAndStore.
        } else {
            console.warn("FCM: Notification permission granted, but no active Service Worker registration found. Token acquisition will defer to SW activation.");
            // This case means the SW might be installing or activating, but not yet 'ready'.
            // The getFCMTokenAndStore call from DOMContentLoaded's .then(registration => ...) will handle it.
        }

        // Show a native notification to confirm that desktop alerts are active.
        if (typeof showNativeNotification === 'function') {
             showNativeNotification("OMSI Tools Notifications", "Desktop alerts are active!", '/live-tracker/assets/icons/icon-192x192.png');
        }
        return "granted"; // Return 'granted' as the final permission status.
    }

    // If permission was previously denied by the user.
    if (currentPermission === "denied") {
        alert("Notification permission was previously denied. To enable, please go to your browser's site settings and allow notifications for this page.");
        localStorage.setItem('desktopNotificationPreference_omsiExtra', 'denied'); // Store the denied preference.
        return "denied"; // Return 'denied'.
    }

    // If permission is in the "default" state (meaning the user has not yet made a choice).
    // This will trigger the browser's native permission prompt.
    const permissionResult = await Notification.requestPermission();

    // If the user grants permission through the prompt.
    if (permissionResult === "granted") {
        localStorage.setItem('desktopNotificationPreference_omsiExtra', 'granted'); // Store the granted preference.
        console.log("Notification permission granted by user.");
        alert("Desktop notifications have been enabled!"); // Inform the user.

        // Wait for the Service Worker to be ready and active before attempting to get the FCM token.
        // This is crucial as getToken requires an active service worker registration.
        const newRegistration = await navigator.serviceWorker.ready;
        if (newRegistration) {
            await getFCMTokenAndStore(newRegistration); // Pass the new active registration to getFCMTokenAndStore.
        } else {
            console.error("FCM: Permission granted, but Service Worker registration was not ready. Token acquisition failed.");
        }

        // Show a test native notification immediately after permission is granted.
        if (typeof showNativeNotification === 'function') {
            showNativeNotification(
                "OMSI Tools Notifications", // Title of the notification.
                "Test successful! You will now receive desktop alerts.", // Body of the notification.
                '' // Icon path (empty string for default or no icon).
            );
        }
        return "granted"; // Return 'granted'.
    } else if (permissionResult === "denied") { // If the user denies permission through the prompt.
        localStorage.setItem('desktopNotificationPreference_omsiExtra', 'denied'); // Store the denied preference.
        alert("Desktop notifications were denied. You can change this in your browser's site settings.");
        return "denied"; // Return 'denied'.
    } else { // If the user dismisses the prompt without making a choice.
        localStorage.removeItem('desktopNotificationPreference_omsiExtra'); // Remove any stored preference.
        alert("Notification permission request dismissed or not acted upon.");
        return "default"; // Return 'default'.
    }
}

function rsg_populateRouteTiles_ExtraPage() {
    console.log("[DEBUG RSG_ROUTES] rsg_populateRouteTiles_ExtraPage: Function started."); // New log
    if (!rsgRouteSelectionContainer_el_extra || !rsgRoutesPlaceholder_el_extra || !rsgSelectedRouteDisplay_el_extra) {
        console.error("RSG Route Tiles: Essential container/display elements missing.");
        return;
    }
    rsgRouteSelectionContainer_el_extra.innerHTML = '';
    rsgRoutesPlaceholder_el_extra.textContent = "Loading routes..."; // Ensure placeholder is visible initially
    rsgRoutesPlaceholder_el_extra.style.display = 'block';

    const initialScheduleLength = currentWorkingSchedule_extra.length; // New log
    console.log(`[DEBUG RSG_ROUTES] currentWorkingSchedule_extra has ${initialScheduleLength} entries.`); // New log

    const uniqueRoutes = [...new Set(
        currentWorkingSchedule_extra
            .filter(e => {
                const isValid = e.lineName && e.lineName.trim() !== '';
                // console.log(`[DEBUG RSG_ROUTES_FILTER] Entry lineName: '${e.lineName}', isValid: ${isValid}`); // Uncomment for very verbose filter debug
                return isValid;
            })
            .map(e => e.lineName)
    )].sort(compareLineNames_ExtraPage);

    console.log("DEBUG: rsg_populateRouteTiles_ExtraPage - uniqueRoutes (after robust filter):", uniqueRoutes); // Existing log, now with context

    if (uniqueRoutes.length === 0) {
        console.log("[DEBUG RSG_ROUTES] uniqueRoutes is empty. Displaying 'No routes found' message."); // New log
        rsgRoutesPlaceholder_el_extra.textContent = "No valid routes found in schedule after filtering.";
        rsgRouteSelectionContainer_el_extra.appendChild(rsgRoutesPlaceholder_el_extra);
        rsgRoutesPlaceholder_el_extra.style.display = 'block'; // Ensure placeholder is visible
        rsg_selectedRoute_extra = null;
        rsgRouteNameInput_el_extra.value = '';
        rsgSelectedRouteDisplay_el_extra.textContent = '(None selected)';
        rsg_updateRsgActionButtonsState();
        return;
    }

    console.log(`[DEBUG RSG_ROUTES] Found ${uniqueRoutes.length} unique routes. Proceeding to render tiles.`); // New log

    // If we reach here, it means uniqueRoutes is NOT empty, so hide the placeholder
    rsgRoutesPlaceholder_el_extra.style.display = 'none';

    let selectedRouteExistsInList = false;
    let currentSelectedValue = rsg_selectedRoute_extra;

    uniqueRoutes.forEach(routeName => {
        const tile = document.createElement('span');
        tile.classList.add('selectable-route-tile');
        tile.textContent = routeName;
        tile.dataset.routeName = routeName;

        const bgColor = getRouteTileColour_ExtraPage(routeName);
        tile.style.backgroundColor = bgColor;
        tile.style.color = getTextColourForBackground_ExtraPage(bgColor);

        if (currentSelectedValue && routeName.toUpperCase() === currentSelectedValue.toUpperCase()) {
            tile.classList.add('selected');
            selectedRouteExistsInList = true;
        }

        tile.addEventListener('click', () => {
            rsgRouteSelectionContainer_el_extra.querySelectorAll('.selectable-route-tile.selected').forEach(selectedTile => {
                selectedTile.classList.remove('selected');
            });

            tile.classList.add('selected');
            rsg_selectedRoute_extra = routeName;
            rsgRouteNameInput_el_extra.value = routeName;
            rsgSelectedRouteDisplay_el_extra.textContent = routeName;

            rsg_populateDestinationSelect_ExtraPage();
            rsg_loadOrPullConfiguration_ExtraPage();
            rsg_updateRsgActionButtonsState();
        });
        rsgRouteSelectionContainer_el_extra.appendChild(tile);
        // console.log(`[DEBUG RSG_ROUTES] Appended tile for route: ${routeName}`); // Uncomment for very verbose append debug
    });

    if (!selectedRouteExistsInList) {
        console.log("[DEBUG RSG_ROUTES] No previously selected route found in the new list."); // New log
        rsg_selectedRoute_extra = null;
        rsgRouteNameInput_el_extra.value = '';
        rsgSelectedRouteDisplay_el_extra.textContent = '(None selected)';
    } else {
        console.log(`[DEBUG RSG_ROUTES] Retaining previously selected route: ${rsg_selectedRoute_extra}`); // New log
        rsgRouteNameInput_el_extra.value = rsg_selectedRoute_extra || '';
        rsgSelectedRouteDisplay_el_extra.textContent = rsg_selectedRoute_extra || '(None selected)';
    }
    rsg_updateRsgActionButtonsState();
    console.log("[DEBUG RSG_ROUTES] rsg_populateRouteTiles_ExtraPage: Function finished."); // New log
}

        function rsg_populateDestinationSelect_ExtraPage() {
            if (!rsgDestinationNameSelect_el_extra || !rsgRouteNameInput_el_extra) {
                console.warn("RSG: Destination select or route name input missing for populating destinations.");
                return;
            }

            const selectedRoute = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
            const currentInputValue = rsgDestinationNameInput_el_extra.value.trim();

            rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- Select Destination --</option>';

            if (!selectedRoute) {
                rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- Select Route First --</option>';
                rsgDestinationNameInput_el_extra.value = "";
                return;
            }

            // Filter for entries that have a non-empty lineName (matching selectedRoute) and non-empty destinationName.
            const uniqueDestinations = [...new Set(
                currentWorkingSchedule_extra
                    .filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName && e.destinationName.trim() !== '')
                    .map(e => e.destinationName)
            )].sort();

            if (uniqueDestinations.length > 0) {
                uniqueDestinations.forEach(dest => {
                    const opt = document.createElement('option');
                    opt.value = dest;
                    opt.textContent = dest;
                    rsgDestinationNameSelect_el_extra.appendChild(opt);
                });

                const matchedDest = uniqueDestinations.find(d => d === currentInputValue);
                if (matchedDest) {
                    rsgDestinationNameSelect_el_extra.value = matchedDest;
                    rsgDestinationNameInput_el_extra.value = matchedDest;
                } else {
                    rsgDestinationNameSelect_el_extra.value = "";
                }
            } else {
                rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- No Destinations for this Route --</option>';
                rsgDestinationNameInput_el_extra.value = "";
            }
        }

        function rsg_clearRouteSelection_ExtraPage() {
            rsgRouteSelectionContainer_el_extra.querySelectorAll('.selectable-route-tile.selected').forEach(selectedTile => {
                selectedTile.classList.remove('selected');
            });
            rsg_selectedRoute_extra = null;
            rsgRouteNameInput_el_extra.value = '';
            rsgSelectedRouteDisplay_el_extra.textContent = '(None selected)';
            rsg_populateDestinationSelect_ExtraPage(); // Clear destinations too
            rsg_loadOrPullConfiguration_ExtraPage(); // Reset config loading context
            rsg_updateRsgActionButtonsState();
        }

async function displayKeyDepartures_ExtraPage() {
    const now = new Date();
    const functionDisplayStartTime = new Date();
    
    const firstDepListDiv = document.getElementById('kd-first-departures-list_extra');
    const lastDepListDiv = document.getElementById('kd-last-departures-list_extra');
    const statusMsgEl = document.getElementById('kd-status-message_extra');

    if (!firstDepListDiv || !lastDepListDiv || !statusMsgEl) {
        return;
    }

    firstDepListDiv.innerHTML = '<p>Updating first departures...</p>';
    lastDepListDiv.innerHTML = '<p>Updating last departures...</p>';

    const todayStr = now.toDateString();

    if (lastAlertDataPreparedDate_extra !== todayStr || !todayKeyTripEvents_extra || todayKeyTripEvents_extra.length === 0) {
        if (statusMsgEl) statusMsgEl.textContent = 'Data stale or empty. Preparing/Refreshing key departure data...';
        if (typeof prepareKeyTripTimesForAlerts_ExtraPage === 'function') {
            await prepareKeyTripTimesForAlerts_ExtraPage();
        } else {
            if (statusMsgEl) statusMsgEl.textContent = 'Error: Key departure preparation function missing.';
            return;
        }
    }

    if (!todayKeyTripEvents_extra || todayKeyTripEvents_extra.length === 0) {
        const msg = "No key trip events identified for display based on current configurations and time.";
        if (statusMsgEl) statusMsgEl.textContent = msg;
        firstDepListDiv.innerHTML = `<p style="opacity:0.7;">${msg}</p>`;
        lastDepListDiv.innerHTML = `<p style="opacity:0.7;">${msg}</p>`;
        return;
    }
    
    // Filter for events that haven't happened yet
    const upcomingEvents = todayKeyTripEvents_extra.filter(event => {
        if (!event.departureTimeObj || !(event.departureTimeObj instanceof Date)) {
            return false;
        }
        return event.departureTimeObj >= now;
    });

    const firstTripTypes = ['rsg-first-trip', 'n-bus-first-trip'];
    const lastTripTypes = ['rsg-last-trip', 'n-bus-last-trip'];
    
    const firstDeparturesToDisplay = upcomingEvents.filter(e => firstTripTypes.includes(e.type));
    const lastDeparturesToDisplay = upcomingEvents.filter(e => lastTripTypes.includes(e.type));

    const sortEvents = (a, b) => {
        if (!a.departureTimeObj || !b.departureTimeObj) return 0;
        return a.departureTimeObj.getTime() - b.departureTimeObj.getTime();
    };

    firstDeparturesToDisplay.sort(sortEvents);
    lastDeparturesToDisplay.sort(sortEvents);

    const renderEventList = (eventArray, listDivElement, listTypeForEmptyMessage) => {
        if (eventArray.length > 0) {
            let html = '<ul style="list-style-type:none; padding-left:0;">';
            eventArray.forEach(event => {
                const routeColor = getRouteTileColour_ExtraPage(event.lineName, null);
                const destinationDisplay = `<strong>${toTitleCase_rsg(event.headsignDestinationName || 'N/A')}</strong>`;
                const opProfileDisplay = event.operatingProfile ? event.operatingProfile.split(',').map(p => p.trim()).join(', ') : 'N/A';

                html += `<li style="margin-bottom:0.5em; padding: 0.4em 0.5em; background-color: rgba(255,255,255,0.03); border-radius: 4px; border-left: 3px solid ${routeColor};">
                    <strong style="font-size:1.05em;">${event.departureTime}</strong> -
                    <span style="color: ${routeColor}; font-weight: bold;">${event.lineName}</span>
                    to ${destinationDisplay}
                    from ${toTitleCase_rsg(event.originStopName || 'N/A')}
                    <span style="font-size:0.8em; color:#bdc3c7; display:block; margin-top:2px;">(Op Profile: ${opProfileDisplay})</span>
                </li>`;
            });
            html += '</ul>';
            listDivElement.innerHTML = html;
        } else {
            listDivElement.innerHTML = `<p style="opacity:0.7;">No upcoming ${listTypeForEmptyMessage.toLowerCase()} departures found.</p>`;
        }
    };

    renderEventList(firstDeparturesToDisplay, firstDepListDiv, "First");
    renderEventList(lastDeparturesToDisplay, lastDepListDiv, "Last");

    const tomorrowForDisplayMsg = new Date(now);
    tomorrowForDisplayMsg.setDate(now.getDate() + 1);
    if (statusMsgEl) statusMsgEl.textContent = `Displaying upcoming departures for ${todayStr} & ${tomorrowForDisplayMsg.toLocaleDateString()}. Updated: ${now.toLocaleTimeString()}.`;
}

async function renderCalendarView_ExtraPage() {
    const calendarGrid = document.getElementById('events-calendar-grid_extra');
    const monthYearDisplay = document.getElementById('cv-month-year-display_extra');
    const dayDetailsDisplay = document.getElementById('calendar-day-details_extra');

    if (!calendarGrid || !monthYearDisplay || !dayDetailsDisplay) {
        console.error("Calendar UI elements not found for renderCalendarView_ExtraPage.");
        return;
    }

    calendarGrid.innerHTML = '';
    dayDetailsDisplay.innerHTML = '<p>Click on a day to see details.</p>';

    const actualToday = new Date();
    const actualCurrentYear = actualToday.getFullYear();
    const actualCurrentMonth = actualToday.getMonth();
    const actualCurrentDate = actualToday.getDate();

    const year = cv_currentDisplayDate_extra.getFullYear();
    const month = cv_currentDisplayDate_extra.getMonth();

    if (monthYearDisplay) {
        monthYearDisplay.textContent = `${cv_currentDisplayDate_extra.toLocaleString('default', { month: 'long' })} ${year}`;
    }

    const dayNames = ["Sat", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri"];
    dayNames.forEach(dayName => {
        const headerCell = document.createElement('div');
        headerCell.style.textAlign = 'center';
        headerCell.style.fontWeight = 'bold';
        headerCell.style.padding = '0.5em 0.2em';
        headerCell.style.backgroundColor = 'rgba(0,0,0,0.2)';
        headerCell.style.borderBottom = '1px solid #4A5568';
        headerCell.style.fontSize = '0.8em';
        headerCell.textContent = dayName;
        calendarGrid.appendChild(headerCell);
    });

    const firstDayOfMonth = new Date(year, month, 1);
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const startingDayOfWeek = (firstDayOfMonth.getDay() + 1) % 7;

    const dpoMap = new Map();
    if (typeof operationalOverrides_data === 'object' && operationalOverrides_data !== null) {
        Object.entries(operationalOverrides_data).forEach(([dateStr, profilesOrObject]) => {
            // Ensure that what we put into the map is either the profile string or an empty string if malformed.
            if (typeof profilesOrObject === 'string') {
                dpoMap.set(dateStr, profilesOrObject);
            } else if (typeof profilesOrObject === 'object' && profilesOrObject !== null && !Array.isArray(profilesOrObject)) {
                // If it's an object, it means it's a date with route-specific overrides.
                // For a calendar summary, we might want to indicate this as "Route-Specific Overrides"
                // or concatenate the profiles for a summary, or leave it blank if no *overall* profile.
                // For simplicity here, we'll mark it as an object to distinguish it from the `split` issue.
                // The later `getOperatingCodesForDate_ExtraPage` will handle the full object.
                dpoMap.set(dateStr, profilesOrObject); // Store the object, but handle the split later
            } else {
                console.warn(`Calendar View: Malformed override data for date ${dateStr}:`, profilesOrObject);
                // Optionally set to an empty string or specific error string
                dpoMap.set(dateStr, "");
            }
        });
    }

    for (let i = 0; i < startingDayOfWeek; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.style.borderRight = '1px solid #4A5568';
        emptyCell.style.borderBottom = '1px solid #4A5568';
        if (i === 0) emptyCell.style.borderLeft = '1px solid #4A5568';
        emptyCell.style.minHeight = '100px';
        calendarGrid.appendChild(emptyCell);
    }

    for (let day = 1; day <= daysInMonth; day++) {
        const dayCell = document.createElement('div');
        dayCell.style.minHeight = '100px';
        dayCell.style.padding = '0.3em';
        dayCell.style.cursor = 'pointer';
        dayCell.classList.add('calendar-day-cell');
        dayCell.setAttribute('role', 'button');
        dayCell.setAttribute('tabindex', '0');

        if (year === actualCurrentYear && month === actualCurrentMonth && day === actualCurrentDate) {
            dayCell.classList.add('cv-current-day');
        }

        const dayNumberSpan = document.createElement('strong');
        dayNumberSpan.className = 'cv-day-number-span';
        dayNumberSpan.textContent = day;
        dayCell.appendChild(dayNumberSpan);

        const dateForThisCell = new Date(year, month, day);
        const dateStringYYYYMMDD = getYYYYMMDD_ExtraPage(dateForThisCell);

        let effectiveProfiles = [];
        // Check if the override for this date is a string (legacy direct override) or an object (route-specific)
        const directOverrideValue = dpoMap.has(dateStringYYYYMMDD) ? dpoMap.get(dateStringYYYYMMDD) : undefined;

        if (typeof directOverrideValue === 'string' && directOverrideValue.trim() !== "") {
            effectiveProfiles = directOverrideValue.split(',').map(p => p.trim());
        } else if (typeof directOverrideValue === 'object' && directOverrideValue !== null) {
            // This date has route-specific overrides.
            // We need to summarize them for the calendar cell display.
            // A simple approach is to list unique profiles, or just state "Multiple Overrides".
            const profilesInThisDateOverride = new Set();
            for (const routeName in directOverrideValue) {
                if (Object.hasOwnProperty.call(directOverrideValue, routeName)) {
                    const profileString = directOverrideValue[routeName];
                    if (typeof profileString === 'string' && profileString.trim() !== '') {
                        profileString.split(',').forEach(p => profilesInThisDateOverride.add(p.trim()));
                    }
                }
            }
            if (profilesInThisDateOverride.size > 0) {
                effectiveProfiles = Array.from(profilesInThisDateOverride).sort();
            } else {
                effectiveProfiles = ['(Route-Specific Overrides)']; // Or simply empty if you want no text
            }
        } else {
            // No direct override string or valid object found for this date,
            // so use the automatically determined profiles.
            effectiveProfiles = getOperatingCodesForDate_ExtraPage(dateForThisCell);
        }

        if (effectiveProfiles.length > 0) {
            const profilesDiv = document.createElement('div');
            profilesDiv.classList.add('cv-profile-text');
            profilesDiv.textContent = effectiveProfiles.join(', ');
            profilesDiv.title = `Active Profile(s): ${effectiveProfiles.join(', ')}`;
            dayCell.appendChild(profilesDiv);
        }

        let eventsOnThisDay = [];
        if (ukBankHolidaysData_extra && ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(dateStringYYYYMMDD)) {
            const title = ukBankHolidaysData_extra.titles[dateStringYYYYMMDD] || "Bank Holiday";
            eventsOnThisDay.push({ type: 'Bank Holiday', text: title, color: '#E67E22' });
        }
        if (isSchoolHolidayPeriod_ExtraPage(dateForThisCell)) {
            eventsOnThisDay.push({ type: 'School Holiday', text: 'School Holiday', color: '#3498DB' });
        }
        
        // This check is specifically for where the DPO tool shows "Override Active".
        // It relies on `dpoMap.has(dateStringYYYYMMDD)` to indicate an override exists.
        // It's the `effectiveProfiles` which reflects the *result* of that override.
        // If `directOverrideValue` is an object, it's an override, even if `effectiveProfiles` summarizes.
        if (directOverrideValue !== undefined) { // Any form of override (string or object) is active
            eventsOnThisDay.push({ type: 'DPO Info', text: 'Override Active - See DPO for more information', color: '#F1C40F'});
        }


        Object.values(scheduledRouteUpdates_extra || {}).forEach(task => {
            if (task.goLiveDateTime && getYYYYMMDD_ExtraPage(new Date(task.goLiveDateTime)) === dateStringYYYYMMDD && task.status === 'pending') {
                let updateDetails = `Route ${task.routeName || 'N/A'}`;
                if (task.operatingProfile) {
                    updateDetails += ` (P: ${task.operatingProfile}`;
                    if (task.destinationName) { updateDetails += `, D: ${task.destinationName}`; }
                    updateDetails += `)`;
                } else if (task.destinationName) { updateDetails += ` (D: ${task.destinationName})`; }
                eventsOnThisDay.push({ type: 'Task', text: `Update: ${updateDetails}`, color: '#2ECC71' });
            }
        });
        Object.values(scheduledRouteDeletions_extra || {}).forEach(task => {
            if (task.goLiveDateTime && getYYYYMMDD_ExtraPage(new Date(task.goLiveDateTime)) === dateStringYYYYMMDD && task.status === 'pending') {
                eventsOnThisDay.push({ type: 'Task', text: `Delete Rte: ${task.routeName || 'N/A'}`, color: '#E74C3C' });
            }
        });

        if (eventsOnThisDay.length > 0) {
            if (dayCell.style.backgroundColor === '') {
                 dayCell.style.backgroundColor = 'rgba(255,255,255,0.05)';
            }
            eventsOnThisDay.sort((a, b) => {
                const typeOrder = { 'DPO Info': 0.5, 'Bank Holiday': 1, 'School Holiday': 2, 'Task': 3 };
                const orderA = typeOrder[a.type] || 99;
                const orderB = typeOrder[b.type] || 99;
                if (orderA !== orderB) return orderA - orderB;
                return (a.text || "").localeCompare(b.text || "");
            });

            for (const event of eventsOnThisDay) {
                const eventDiv = document.createElement('div');
                eventDiv.classList.add('cv-event-item');

                let displayText = event.text;
                if (event.type === 'Task') {
                    displayText = event.text.length > 30 ? event.text.substring(0, 27) + "..." : event.text;
                }
                eventDiv.textContent = displayText;
                eventDiv.title = `${event.type}: ${event.text}`;
                eventDiv.style.backgroundColor = event.color;
                eventDiv.style.color = getTextColourForBackground_ExtraPage(event.color);
                eventDiv.style.margin = '1px 0';
                eventDiv.style.padding = '2px 3px';
                eventDiv.style.borderRadius = '3px';
                dayCell.appendChild(eventDiv);
            }
        }

        dayCell.addEventListener('click', () => displayCalendarDayDetails_ExtraPage(dateStringYYYYMMDD, eventsOnThisDay));
        dayCell.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                displayCalendarDayDetails_ExtraPage(dateStringYYYYMMDD, eventsOnThisDay);
            }
        });
        calendarGrid.appendChild(dayCell);
    }

    const totalCells = startingDayOfWeek + daysInMonth;
    const remainingCells = (7 - (totalCells % 7)) % 7;
    for (let i = 0; i < remainingCells; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.style.borderBottom = '1px solid #4A5568';
        if ((totalCells + i) % 7 !== 6) {
             emptyCell.style.borderRight = '1px solid #4A5568';
        }
        if ((totalCells + i) % 7 === 0) {
             emptyCell.style.borderLeft = '1px solid #4A5568';
        }
        emptyCell.style.minHeight = '100px';
        calendarGrid.appendChild(emptyCell);
    }
}

        function dpo_populateRouteSelection_ExtraPage() {
            if (!dpoRouteSelectionContainer_el_extra) return;
            const routePlaceholder = document.getElementById('dpo-routes-placeholder-extra');
            if (!routePlaceholder) return;

            dpoRouteSelectionContainer_el_extra.innerHTML = '';
            
            const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))]
                .filter(Boolean)
                .sort(compareLineNames_ExtraPage);

            if (uniqueRoutes.length === 0) {
                routePlaceholder.textContent = "No routes found in schedule.";
                dpoRouteSelectionContainer_el_extra.appendChild(routePlaceholder);
                return;
            }
            routePlaceholder.style.display = 'none';

            uniqueRoutes.forEach(routeName => {
                const tile = document.createElement('span');
                tile.classList.add('selectable-route-tile');
                tile.textContent = routeName;
                tile.dataset.routeName = routeName;

                const bgColor = getRouteTileColour_ExtraPage(routeName);
                tile.style.backgroundColor = bgColor;
                tile.style.color = getTextColourForBackground_ExtraPage(bgColor);

                tile.addEventListener('click', () => {
                    const isSelected = tile.classList.toggle('selected');
                    if (isSelected) {
                        if (!dpo_selectedRoutes_extra.includes(routeName)) {
                            dpo_selectedRoutes_extra.push(routeName);
                        }
                    } else {
                        dpo_selectedRoutes_extra = dpo_selectedRoutes_extra.filter(r => r !== routeName);
                    }
                    dpo_selectedRoutes_extra.sort(compareLineNames_ExtraPage);
                    dpo_updateSelectedRoutesDisplay();
                    dpo_updateActionButtonsState();
                });
                dpoRouteSelectionContainer_el_extra.appendChild(tile);
            });
            dpo_updateSelectedRoutesDisplay();
        }

        function dpo_updateSelectedRoutesDisplay() {
            if (dpoSelectedRoutesDisplay_el_extra) {
                dpoSelectedRoutesDisplay_el_extra.textContent = dpo_selectedRoutes_extra.length > 0
                    ? dpo_selectedRoutes_extra.join(', ')
                    : '(None selected)';
            }
        }

        function dpo_clearRouteSelections_ExtraPage() {
            dpo_selectedRoutes_extra = [];
            const allTiles = dpoRouteSelectionContainer_el_extra.querySelectorAll('.selectable-route-tile');
            allTiles.forEach(tile => tile.classList.remove('selected'));
            dpo_updateSelectedRoutesDisplay();
            dpo_updateActionButtonsState();
        }

// In omsi_tools_extra.html, after dpo_clearRouteSelections_ExtraPage function
function dpo_selectAllRoutes_ExtraPage() {
    dpo_selectedRoutes_extra = []; // Clear current selections first
    const allTiles = dpoRouteSelectionContainer_el_extra.querySelectorAll('.selectable-route-tile');
    let selectedCount = 0;

    allTiles.forEach(tile => {
        const routeName = tile.dataset.routeName;
        if (routeName && !dpo_selectedRoutes_extra.includes(routeName)) {
            dpo_selectedRoutes_extra.push(routeName);
            tile.classList.add('selected'); // Add the 'selected' class
            selectedCount++;
        }
    });

    dpo_selectedRoutes_extra.sort(compareLineNames_ExtraPage); // Keep sorted
    dpo_updateSelectedRoutesDisplay();
    dpo_updateActionButtonsState();

    const dpoStatusMessageEl = document.getElementById('dpo-status-message-extra');
    if (dpoStatusMessageEl) {
        dpoStatusMessageEl.textContent = `${selectedCount} routes selected.`;
        dpoStatusMessageEl.style.color = '#2ecc71';
    }
}

const departuresSelect = document.getElementById('selectStopForDeparturesView_extra');
    if (departuresSelect) {
        departuresSelect.addEventListener('change', displayDeparturesForSelectedStop_ExtraPage);
    }

        function dpo_updateActionButtonsState() {
            const dateSelected = overrideDateInput_el_extra.value !== "";
            const profilesSelected = dpo_getSelectedOpProfilesString_ExtraPage() !== "";
            const routesSelected = dpo_selectedRoutes_extra.length > 0;

            if (dpoApplyOverrideToRoutesButton_el_extra) {
                dpoApplyOverrideToRoutesButton_el_extra.disabled = !(dateSelected && profilesSelected && routesSelected);
            }
            if (dpoClearOverrideForRoutesButton_el_extra) {
                dpoClearOverrideForRoutesButton_el_extra.disabled = !(dateSelected && routesSelected);
            }
        }

function displayCalendarDayDetails_ExtraPage(dateString, events) {
    const dayDetailsDisplay = document.getElementById('calendar-day-details_extra');
    if (!dayDetailsDisplay) {
        console.error("Day details display element not found.");
        return;
    }

    const sortedEvents = [...events].sort((a, b) => {
        const typeOrder = { 'DPO Info': 0.5, 'DPO': 1, 'Bank Holiday': 2, 'School Holiday': 3, 'Task': 4 };
        const orderA = typeOrder[a.type] || 99;
        const orderB = typeOrder[b.type] || 99;
        if (orderA !== orderB) return orderA - orderB;
        return (a.text || "").localeCompare(b.text || "");
    });

    let html = `<h4 style="margin-top:0; margin-bottom:0.75em;">Details for ${formatDateToDDMonthYYYY_ExtraPage(dateString)}:</h4>`;
    if (sortedEvents.length > 0) {
        html += '<ul style="list-style-type:none; padding-left:0; margin:0;">';
        sortedEvents.forEach(event => {
            html += `<li style="margin-bottom:0.5em; padding:0.4em 0.6em; background-color:${event.color}; color:${getTextColourForBackground_ExtraPage(event.color)}; border-radius:4px; font-size:0.9em;">
                        <strong style="font-weight:bold;">${event.type}:</strong> ${event.text}
                     </li>`;
        });
        html += '</ul>';
    } else {
        html += '<p style="font-size:0.9em; opacity:0.8;">No special events or tasks scheduled for this day.</p>';
    }
    dayDetailsDisplay.innerHTML = html;
}

function triggerStopAnalysisDynamically(stopID) {
    console.log('[Trigger] Analyzing stopID:', stopID); // For debugging
    analyzeStop_ExtraPage(stopID);
}

function displaySchoolHolidays_ExtraPage() {
    const displayDiv = document.getElementById('school-holidays-display-extra');
    if (!displayDiv) return;

    if (!schoolHolidayDateRanges_extra || schoolHolidayDateRanges_extra.length === 0) {
        displayDiv.innerHTML = '<p>No school holiday periods are currently defined in the script.</p>';
        return;
    }

    let html = '<ul style="list-style-type: disc; padding-left: 20px; margin-top:0.5em;">';
    schoolHolidayDateRanges_extra.forEach(range => {
        // Assuming you have formatDateToDDMonthYYYY_ExtraPage or similar
        const startDateFormatted = range.start ? formatDateToDDMonthYYYY_ExtraPage(range.start) : 'N/A';
        const endDateFormatted = range.end ? formatDateToDDMonthYYYY_ExtraPage(range.end) : 'N/A';
        html += `<li style="margin-bottom:0.3em;">${startDateFormatted} - ${endDateFormatted}</li>`;
    });
    html += '</ul>';
    displayDiv.innerHTML = html;
}

async function saveSchoolHolidaysToFirebase_ExtraPage() {
    if (!currentUser_extra || !window.firebaseOMSI) {
        console.error("Cannot save School Holidays: Not logged in or Firebase not available.");
        // Optionally update sh-status-message-extra here
        return false;
    }

    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        // Ensure all holidays have an ID. Those from DEFAULT_SCHOOL_HOLIDAY_RANGES might not initially.
        const holidaysToSave = schoolHolidayDateRanges_extra.map((holiday, index) => ({
            id: holiday.id || `sh-${Date.now()}-${index}`, // Assign ID if missing
            start: holiday.start,
            end: holiday.end,
            description: holiday.description || ""
        }));
        schoolHolidayDateRanges_extra = holidaysToSave; // Update global array with IDs

        await dbSet(dbRef(database, FB_PATH_SCHOOL_HOLIDAYS), schoolHolidayDateRanges_extra);
        console.log("School holiday date ranges saved to Firebase.");
        return true;
    } catch (error) {
        console.error("Error saving school holidays to Firebase:", error);
        const shStatusEl = document.getElementById('sh-status-message-extra');
        if (shStatusEl) {
            shStatusEl.textContent = "Error saving school holidays: " + error.message;
            shStatusEl.style.color = "#e74c3c";
        }
        return false;
    }
}

function displaySchoolHolidays_ExtraPage() {
    const displayDiv = document.getElementById('school-holidays-display-extra');
    const shStatusEl = document.getElementById('sh-status-message-extra');
    if (!displayDiv) return;

    displayDiv.innerHTML = ''; // Clear previous content

    if (!schoolHolidayDateRanges_extra || schoolHolidayDateRanges_extra.length === 0) {
        displayDiv.innerHTML = '<p style="padding:0.5em; opacity:0.7;">No school holiday periods defined. Add one below.</p>';
        return;
    }

    // Sort by start date for display
    const sortedHolidays = [...schoolHolidayDateRanges_extra].sort((a,b) => new Date(a.start) - new Date(b.start));

    const ul = document.createElement('ul');
    ul.style.listStyleType = 'none';
    ul.style.paddingLeft = '0';

    sortedHolidays.forEach(holiday => {
        const li = document.createElement('li');
        li.style.display = 'flex';
        li.style.justifyContent = 'space-between';
        li.style.alignItems = 'center';
        li.style.padding = '0.5em';
        li.style.marginBottom = '0.3em';
        li.style.backgroundColor = 'rgba(255,255,255,0.03)';
        li.style.borderRadius = '0.25rem';

        const textSpan = document.createElement('span');
        const startDateFormatted = holiday.start ? formatDateToDDMonthYYYY_ExtraPage(holiday.start) : 'N/A';
        const endDateFormatted = holiday.end ? formatDateToDDMonthYYYY_ExtraPage(holiday.end) : 'N/A';
        textSpan.innerHTML = `<strong>${startDateFormatted} - ${endDateFormatted}</strong>` +
                           (holiday.description ? ` <span style="font-size:0.9em; color:#bdc3c7;">(${holiday.description})</span>` : '');
        li.appendChild(textSpan);

        const buttonsDiv = document.createElement('div');

        const editButton = document.createElement('button');
        editButton.textContent = 'Edit';
        editButton.classList.add('button', 'small-action', 'neutral');
        editButton.style.marginRight = '0.5em';
        editButton.addEventListener('click', () => populateSchoolHolidayFormForEdit_ExtraPage(holiday.id));
        buttonsDiv.appendChild(editButton);

        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.classList.add('button', 'small-action', 'secondary');
        deleteButton.addEventListener('click', () => handleDeleteSchoolHoliday_ExtraPage(holiday.id));
        buttonsDiv.appendChild(deleteButton);

        li.appendChild(buttonsDiv);
        ul.appendChild(li);
    });
    displayDiv.appendChild(ul);
    if(shStatusEl) shStatusEl.textContent = ''; // Clear status on successful display
}

function clearSchoolHolidayForm_ExtraPage() {
    document.getElementById('sh-editing-id-extra').value = '';
    document.getElementById('sh-start-date-input-extra').value = '';
    document.getElementById('sh-end-date-input-extra').value = '';
    document.getElementById('sh-description-input-extra').value = '';
    const clearBtn = document.getElementById('sh-clear-form-button-extra');
    if (clearBtn) clearBtn.style.display = 'none';
    const saveBtn = document.getElementById('sh-save-button-extra');
    if (saveBtn) saveBtn.textContent = 'Save/Add Period';
}

function populateSchoolHolidayFormForEdit_ExtraPage(holidayId) {
    const holiday = schoolHolidayDateRanges_extra.find(h => h.id === holidayId);
    if (holiday) {
        document.getElementById('sh-editing-id-extra').value = holiday.id;
        document.getElementById('sh-start-date-input-extra').value = holiday.start;
        document.getElementById('sh-end-date-input-extra').value = holiday.end;
        document.getElementById('sh-description-input-extra').value = holiday.description || '';
        const clearBtn = document.getElementById('sh-clear-form-button-extra');
        if (clearBtn) clearBtn.style.display = 'inline-block';
        const saveBtn = document.getElementById('sh-save-button-extra');
        if (saveBtn) saveBtn.textContent = 'Update Period';
        document.getElementById('sh-start-date-input-extra').focus();
    }
}

async function handleSaveSchoolHoliday_ExtraPage() {
    const statusEl = document.getElementById('sh-status-message-extra');
    if (!statusEl) return;

    const editingId = document.getElementById('sh-editing-id-extra').value;
    const startDate = document.getElementById('sh-start-date-input-extra').value;
    const endDate = document.getElementById('sh-end-date-input-extra').value;
    const description = document.getElementById('sh-description-input-extra').value.trim();

    if (!startDate || !endDate) {
        statusEl.textContent = "Start Date and End Date are required.";
        statusEl.style.color = "#f1c40f";
        return;
    }
    if (new Date(endDate) < new Date(startDate)) {
        statusEl.textContent = "End Date cannot be before Start Date.";
        statusEl.style.color = "#f1c40f";
        return;
    }

    if (editingId) { // Editing existing
        const index = schoolHolidayDateRanges_extra.findIndex(h => h.id === editingId);
        if (index > -1) {
            schoolHolidayDateRanges_extra[index].start = startDate;
            schoolHolidayDateRanges_extra[index].end = endDate;
            schoolHolidayDateRanges_extra[index].description = description;
        }
    } else { // Adding new
        schoolHolidayDateRanges_extra.push({
            id: `sh-${Date.now()}`, // Simple unique ID
            start: startDate,
            end: endDate,
            description: description
        });
    }

    if (await saveSchoolHolidaysToFirebase_ExtraPage()) {
        statusEl.textContent = `School holiday period ${editingId ? 'updated' : 'added'} successfully.`;
        statusEl.style.color = "#2ecc71";
        clearSchoolHolidayForm_ExtraPage();
        displaySchoolHolidays_ExtraPage();
        // If other parts of your app depend on school holidays, you might need to trigger a refresh for them.
        // For example, if the current day profile display is affected:
        if (typeof updateCurrentProfileDisplay_ExtraPage === 'function') {
            updateCurrentProfileDisplay_ExtraPage();
        }
    } else {
        // saveSchoolHolidaysToFirebase_ExtraPage will set its own error message
    }
}

async function handleDeleteSchoolHoliday_ExtraPage(holidayId) {
    const statusEl = document.getElementById('sh-status-message-extra');
    if (!confirm("Are you sure you want to delete this school holiday period?")) {
        if(statusEl) statusEl.textContent = "Deletion cancelled.";
        return;
    }
    schoolHolidayDateRanges_extra = schoolHolidayDateRanges_extra.filter(h => h.id !== holidayId);
    if (await saveSchoolHolidaysToFirebase_ExtraPage()) {
        if(statusEl) {
            statusEl.textContent = "School holiday period deleted.";
            statusEl.style.color = "#2ecc71";
        }
        displaySchoolHolidays_ExtraPage();
        if (typeof updateCurrentProfileDisplay_ExtraPage === 'function') {
            updateCurrentProfileDisplay_ExtraPage();
        }
    }
}

async function saveOpProfilesToFirebase_ExtraPage() {
    if (!currentUser_extra || !window.firebaseOMSI) {
        console.error("Cannot save Op Profiles: Not logged in or Firebase not available.");
        if(opProfilesStatus_el_extra) {
            opProfilesStatus_el_extra.textContent = "Error: Not logged in. Cannot save.";
            opProfilesStatus_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        // RSG_OPERATING_PROFILES_LIST is now the source of truth, updated from Firebase or by edits
        await dbSet(dbRef(database, FB_PATH_EDITABLE_OP_PROFILES), RSG_OPERATING_PROFILES_LIST);
        console.log("Operating profiles saved to Firebase.");
        if(opProfilesStatus_el_extra) {
            opProfilesStatus_el_extra.textContent = "Operating profiles list saved to Firebase!";
            opProfilesStatus_el_extra.style.color = "#2ecc71";
             setTimeout(() => { if(opProfilesStatus_el_extra && opProfilesStatus_el_extra.textContent.includes("saved to Firebase")) opProfilesStatus_el_extra.textContent = ""; }, 3000);
        }
        return true;
    } catch (error) {
        console.error("Error saving operating profiles to Firebase:", error);
        if(opProfilesStatus_el_extra) {
            opProfilesStatus_el_extra.textContent = "Error saving operating profiles: " + error.message;
            opProfilesStatus_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
}

function renderEditableOpProfiles_ExtraPage() {
    const listDiv = document.getElementById('op-profiles-list-extra');
    const statusEl = document.getElementById('op-profiles-status-extra');
    if (!listDiv) return;

    listDiv.innerHTML = ''; // Clear current list

    if (!RSG_OPERATING_PROFILES_LIST || RSG_OPERATING_PROFILES_LIST.length === 0) {
        listDiv.innerHTML = '<p>No operating profiles defined. Add one above.</p>';
        return;
    }

    // Sort a copy for display, keeping the original RSG_OPERATING_PROFILES_LIST potentially unsorted if order matters elsewhere (though it's usually sorted for display in checkboxes)
    const profilesToDisplay = [...RSG_OPERATING_PROFILES_LIST].sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a); // Uses your existing sorter
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) return orderA - orderB;
        return String(a).localeCompare(String(b));
    });


    profilesToDisplay.forEach(profileName => {
        const itemDiv = document.createElement('div');
        itemDiv.style.display = 'flex';
        itemDiv.style.justifyContent = 'space-between';
        itemDiv.style.alignItems = 'center';
        itemDiv.style.padding = '0.4em 0.2em';
        itemDiv.style.borderBottom = '1px solid rgba(127,140,141,0.2)';

        const nameSpan = document.createElement('span');
        nameSpan.textContent = profileName;
        itemDiv.appendChild(nameSpan);

        const buttonsDiv = document.createElement('div');

        const editButton = document.createElement('button');
        editButton.textContent = 'Edit';
        editButton.classList.add('button', 'small-action', 'neutral');
        editButton.style.marginRight = '0.5em';
        editButton.addEventListener('click', () => handleEditOpProfile_ExtraPage(profileName));
        buttonsDiv.appendChild(editButton);

        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.classList.add('button', 'small-action', 'secondary');
        deleteButton.addEventListener('click', () => handleDeleteOpProfile_ExtraPage(profileName));
        buttonsDiv.appendChild(deleteButton);

        itemDiv.appendChild(buttonsDiv);
        listDiv.appendChild(itemDiv);
    });
}

async function handleAddOpProfile_ExtraPage() {
    const inputEl = document.getElementById('op-profile-input-extra');
    const statusEl = document.getElementById('op-profiles-status-extra');
    if (!inputEl || !statusEl) return;

    const newProfileName = inputEl.value.trim();
    if (!newProfileName) {
        statusEl.textContent = "Profile name cannot be empty.";
        statusEl.style.color = "#f1c40f";
        return;
    }
    if (RSG_OPERATING_PROFILES_LIST.some(p => p.toLowerCase() === newProfileName.toLowerCase())) {
        statusEl.textContent = `Profile "${newProfileName}" already exists.`;
        statusEl.style.color = "#f1c40f";
        return;
    }

    RSG_OPERATING_PROFILES_LIST.push(newProfileName);
    if (await saveOpProfilesToFirebase_ExtraPage()) {
        statusEl.textContent = `Profile "${newProfileName}" added.`;
        statusEl.style.color = "#2ecc71";
        inputEl.value = '';
        renderEditableOpProfiles_ExtraPage();
        // Refresh dependent UIs
        if (typeof rsg_populateProfileCheckboxes_ExtraPage === 'function') rsg_populateProfileCheckboxes_ExtraPage();
        if (typeof dpo_populateProfileCheckboxes_ExtraPage === 'function') dpo_populateProfileCheckboxes_ExtraPage();
    }
}

function checkProfileUsage_ExtraPage(profileName) {
    let usageMessages = [];
    const profileLower = profileName.toLowerCase();

    // Check live schedule
    if (currentWorkingSchedule_extra.some(entry => entry.OperatingProfile && entry.OperatingProfile.toLowerCase() === profileLower)) {
        usageMessages.push("Live schedule entries");
    }
    // Check RSG saved configs
    if (Object.values(rsg_loadedConfigs_extra).some(config => config.operatingProfile && config.operatingProfile.toLowerCase().split(',').map(p=>p.trim()).includes(profileLower))) {
        usageMessages.push("Saved Route Schedule Generator configurations");
    }
    // Check Day Profile Overrides (assuming overrides are loaded into a variable, e.g., `dayProfileOverrides_data`)
    // For this example, let's assume `activeOverridesList_el_extra` innerHTML can be checked, or better, a data structure.
    // This is a placeholder for actual data checking:
    // if (dayProfileOverrides_data && Object.values(dayProfileOverrides_data).some(override => override.toLowerCase() === profileLower)) {
    //     usageMessages.push("Day Profile Overrides");
    // }

    // Check hardcoded JS constants (simplified check)
    const criticalHardcodedProfiles = ["mo", "tu", "we", "th", "fr", "sa", "su", "mf", "mfsch", "mfnsd"]; // examples
    if (criticalHardcodedProfiles.includes(profileLower) ||
        RSG_PROFILE_GROUPS_TO_MANAGE.some(group => group.groupProfile.toLowerCase() === profileLower || group.individuals.some(ind => ind.toLowerCase() === profileLower)) ||
        MASTER_VALID_PROFILE_COMBINATIONS_LIST_EXTRA.some(combo => combo.toLowerCase().split(',').map(p=>p.trim()).includes(profileLower)) ) {
        usageMessages.push("Hardcoded JavaScript logic (Profile Groups, Valid Combinations). Modifying this may break checkbox selection logic unless JS code is also updated by a developer.");
    }
    return usageMessages;
}

async function handleEditOpProfile_ExtraPage(oldProfileName) {
    const statusEl = document.getElementById('op-profiles-status-extra');
    const newProfileName = prompt(`Enter new name for operating profile "${oldProfileName}":`, oldProfileName);

    if (!newProfileName || newProfileName.trim() === "" || newProfileName.trim() === oldProfileName) {
        statusEl.textContent = "Edit cancelled or name unchanged.";
        statusEl.style.color = "";
        return;
    }
    const trimmedNewName = newProfileName.trim();
    if (RSG_OPERATING_PROFILES_LIST.some(p => p.toLowerCase() === trimmedNewName.toLowerCase() && p.toLowerCase() !== oldProfileName.toLowerCase())) {
        statusEl.textContent = `Profile name "${trimmedNewName}" already exists.`;
        statusEl.style.color = "#f1c40f";
        return;
    }

    const usage = checkProfileUsage_ExtraPage(oldProfileName);
    let confirmMessage = `Are you sure you want to rename "<span class="math-inline">\{oldProfileName\}" to "</span>{trimmedNewName}"?`;
    if (usage.length > 0) {
        confirmMessage += "\n\nWARNING: This profile is currently used in or referenced by:\n- " + usage.join("\n- ");
        confirmMessage += "\n\nRenaming it here will update the list, but will NOT automatically update it in existing schedules, saved RSG configs, or hardcoded JavaScript logic. This might lead to inconsistencies or broken behavior in related tools unless those are also updated (some manually).";
    }

    if (!confirm(confirmMessage)) {
        statusEl.textContent = "Edit cancelled by user.";
        return;
    }

    const index = RSG_OPERATING_PROFILES_LIST.findIndex(p => p === oldProfileName);
    if (index > -1) {
        RSG_OPERATING_PROFILES_LIST[index] = trimmedNewName;
        if (await saveOpProfilesToFirebase_ExtraPage()) {
            statusEl.textContent = `Profile "<span class="math-inline">\{oldProfileName\}" renamed to "</span>{trimmedNewName}".`;
            renderEditableOpProfiles_ExtraPage();
            // Refresh dependent UIs
            if (typeof rsg_populateProfileCheckboxes_ExtraPage === 'function') rsg_populateProfileCheckboxes_ExtraPage();
            if (typeof dpo_populateProfileCheckboxes_ExtraPage === 'function') dpo_populateProfileCheckboxes_ExtraPage();
        }
    } else {
        statusEl.textContent = `Error: Profile "${oldProfileName}" not found to edit.`;
        statusEl.style.color = "#e74c3c";
    }
}

async function handleDeleteOpProfile_ExtraPage(profileNameToDelete) {
    const statusEl = document.getElementById('op-profiles-status-extra');

    const usage = checkProfileUsage_ExtraPage(profileNameToDelete);
    let confirmMessage = `Are you sure you want to delete the operating profile "${profileNameToDelete}"? This action cannot be undone.`;
    if (usage.length > 0) {
        confirmMessage += "\n\nWARNING: This profile is currently used in or referenced by:\n- " + usage.join("\n- ");
        confirmMessage += "\n\nDeleting it will remove it from this list, but will NOT automatically remove it from existing schedules, saved RSG configs, or hardcoded JavaScript logic. This might lead to orphaned data or broken behavior in related tools.";
    }
     if (RSG_OPERATING_PROFILES_LIST.length <= 1) {
        alert("You cannot delete the last operating profile.");
        return;
    }


    if (!confirm(confirmMessage)) {
        statusEl.textContent = "Deletion cancelled by user.";
        return;
    }

    RSG_OPERATING_PROFILES_LIST = RSG_OPERATING_PROFILES_LIST.filter(p => p !== profileNameToDelete);
    if (await saveOpProfilesToFirebase_ExtraPage()) {
        statusEl.textContent = `Profile "${profileNameToDelete}" deleted.`;
        renderEditableOpProfiles_ExtraPage();
        // Refresh dependent UIs
        if (typeof rsg_populateProfileCheckboxes_ExtraPage === 'function') rsg_populateProfileCheckboxes_ExtraPage();
        if (typeof dpo_populateProfileCheckboxes_ExtraPage === 'function') dpo_populateProfileCheckboxes_ExtraPage();
    }
}

function populateServiceAnalyzerDropdowns_ExtraPage() {
    if (!serviceAnalyzerStopSelect_el_extra || !allDefinedStops_data) {
        if (serviceAnalyzerStopSelect_el_extra) {
            serviceAnalyzerStopSelect_el_extra.innerHTML = '<option value="">Error loading stops</option>';
        }
        return;
    }

    const currentSelectedValue = serviceAnalyzerStopSelect_el_extra.value;
    serviceAnalyzerStopSelect_el_extra.innerHTML = '<option value="">-- Select Stop --</option>';

    const stopsArray = Object.values(allDefinedStops_data);

    stopsArray.sort((a, b) => {
        const nameA = (a.stopName || "").toLowerCase();
        const nameB = (b.stopName || "").toLowerCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        return (a.stopID || "").localeCompare(b.stopID || "");
    });

    let selectedStillExists = false;
    stopsArray.forEach(stop => {
        if (stop && stop.stopID && stop.stopName) {
            const option = document.createElement('option');
            option.value = stop.stopID;
            option.textContent = `${stop.stopName} (${stop.stopID})`;
            serviceAnalyzerStopSelect_el_extra.appendChild(option);
            if (stop.stopID === currentSelectedValue) {
                selectedStillExists = true;
            }
        }
    });

    if (selectedStillExists) {
        serviceAnalyzerStopSelect_el_extra.value = currentSelectedValue;
    } else {
        if (serviceAnalyzerStopInput_el_extra && serviceAnalyzerStopInput_el_extra.value) {
            const typedValueLower = serviceAnalyzerStopInput_el_extra.value.toLowerCase().trim();
            const matchedOption = Array.from(serviceAnalyzerStopSelect_el_extra.options).find(opt =>
                opt.text.toLowerCase().includes(typedValueLower) ||
                (opt.value && opt.value.toLowerCase() === typedValueLower)
            );
            if (matchedOption) {
                serviceAnalyzerStopSelect_el_extra.value = matchedOption.value;
            }
        }
    }
}

        function rsg_populateCopySourceOpProfileSelect_ExtraPage() {
    if (!rsgCopySourceOpProfileSelect_el_extra || !rsgCopySourceRouteNameSelect_el_extra || !rsgCopySourceDestNameSelect_el_extra || !currentWorkingSchedule_extra) {
        if (rsgCopySourceOpProfileSelect_el_extra) {
            rsgCopySourceOpProfileSelect_el_extra.innerHTML = '<option value="">-- Error: Deps missing --</option>';
        }
        console.warn("RSG Copy Modal: Missing elements or schedule data for populating profiles.");
        return;
    }

    // Store the previously selected profile value
    const previouslySelectedProfile = rsgCopySourceOpProfileSelect_el_extra.value;

    const sourceRouteName = rsgCopySourceRouteNameSelect_el_extra.value.trim().toUpperCase();
    const sourceDestName = rsgCopySourceDestNameSelect_el_extra.value.trim(); // Read from select

    rsgCopySourceOpProfileSelect_el_extra.innerHTML = '<option value="">-- Select Profile --</option>'; // Default option

    if (!sourceRouteName) {
        rsgCopySourceOpProfileSelect_el_extra.innerHTML = '<option value="">-- Select Route First --</option>';
        return;
    }

    const relevantEntries = currentWorkingSchedule_extra.filter(entry => {
        let matches = entry.lineName && entry.lineName.toUpperCase() === sourceRouteName;
        if (sourceDestName) { // If a destination is specified, filter by it
            matches = matches && entry.destinationName === sourceDestName;
        }
        return matches;
    });

    if (relevantEntries.length === 0) {
        rsgCopySourceOpProfileSelect_el_extra.innerHTML = '<option value="">-- No schedules for selected Route/Dest --</option>';
        return;
    }

    const uniqueProfiles = [...new Set(relevantEntries.map(e => e.OperatingProfile).filter(Boolean))];
    
    uniqueProfiles.sort((a, b) => {
        const orderA = (typeof getDaySortOrder_ExtraPage === 'function') ? getDaySortOrder_ExtraPage(a) : 0;
        const orderB = (typeof getDaySortOrder_ExtraPage === 'function') ? getDaySortOrder_ExtraPage(b) : 0;
        if (orderA !== orderB) return orderA - orderB;
        return String(a).localeCompare(String(b)); 
    });

    if (uniqueProfiles.length === 0) {
        rsgCopySourceOpProfileSelect_el_extra.innerHTML = '<option value="">-- No Profiles Found --</option>';
        return;
    }

    let isPreviouslySelectedProfileStillValid = false;
    uniqueProfiles.forEach(profile => {
        const opt = document.createElement('option');
        opt.value = profile;
        opt.textContent = profile;
        rsgCopySourceOpProfileSelect_el_extra.appendChild(opt);
        if (profile === previouslySelectedProfile) {
            isPreviouslySelectedProfileStillValid = true;
        }
    });

    // If the previously selected profile is still in the new list of options, re-select it.
    if (isPreviouslySelectedProfileStillValid && previouslySelectedProfile !== "") {
        rsgCopySourceOpProfileSelect_el_extra.value = previouslySelectedProfile;
    }
}

async function handleToggleStopStatusFromMasterList_ExtraPage(stopIDToToggle) {
    if (!currentUser_extra || !window.firebaseOMSI) {
        alert("Please log in to change stop status.");
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "Not logged in.";
        return;
    }
    if (!stopIDToToggle) {
        console.error("handleToggleStopStatusFromMasterList_ExtraPage: No stopID provided.");
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "Error: StopID missing for status toggle.";
        return;
    }

    const stopIDUpper = stopIDToToggle.toUpperCase();
    const isCurrentlyClosed = closedStopIDs_extra.includes(stopIDUpper);
    const action = isCurrentlyClosed ? "reopen" : "close";
    const stopNameForConfirm = allDefinedStops_data[stopIDUpper]?.stopName || stopIDToToggle;

    if (!confirm(`Are you sure you want to ${action} the stop: "${stopNameForConfirm}" (${stopIDToToggle})?`)) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `Stop status change for ${stopIDToToggle} cancelled.`;
        return;
    }

    if (isCurrentlyClosed) {
        // Reopen: Remove from closedStopIDs_extra
        const index = closedStopIDs_extra.indexOf(stopIDUpper);
        if (index > -1) {
            closedStopIDs_extra.splice(index, 1);
        }
    } else {
        // Close: Add to closedStopIDs_extra if not already there
        if (!closedStopIDs_extra.includes(stopIDUpper)) {
            closedStopIDs_extra.push(stopIDUpper);
        }
    }

    if (masterStopListStatus_el_extra) {
        masterStopListStatus_el_extra.textContent = `Updating status for stop ${stopIDToToggle}...`;
        masterStopListStatus_el_extra.style.color = "#f1c40f";
    }

    try {
        // Save the updated closedStopIDs_extra array to Firebase
        // Assuming you have a function like saveClosedStopsToFirebase_ExtraPage
        if (typeof saveClosedStopsToFirebase_ExtraPage === 'function') {
            await saveClosedStopsToFirebase_ExtraPage(); // This function should save the 'closedStopIDs_extra' array
        } else {
            console.error("saveClosedStopsToFirebase_ExtraPage function is not defined! Cannot save stop status changes to Firebase.");
            throw new Error("Critical function missing for saving closed stops.");
        }
        
        if (masterStopListStatus_el_extra) {
            masterStopListStatus_el_extra.textContent = `Stop "${stopNameForConfirm}" has been ${action}d.`;
            masterStopListStatus_el_extra.style.color = "#2ecc71";
        }
        // Refresh the master stop list UI to reflect the change
        populateMasterStopList_ExtraPage();
        // Also, if the arrivals page might be open, it will eventually pick up this change from Firebase.
        // If this stop was currently selected in the Service Analyzer or other tools, their display might need refresh.
        renderUIDependentElements_ExtraPage();


    } catch (error) {
        console.error(`Error ${action}ing stop ${stopIDToToggle}:`, error);
        if (masterStopListStatus_el_extra) {
            masterStopListStatus_el_extra.textContent = `Error ${action}ing stop: ${error.message}`;
            masterStopListStatus_el_extra.style.color = "#e74c3c";
        }
        // Revert local change on error
        if (isCurrentlyClosed) { // Was trying to reopen, but failed, so add it back
            if (!closedStopIDs_extra.includes(stopIDUpper)) closedStopIDs_extra.push(stopIDUpper);
        } else { // Was trying to close, but failed, so remove it
            const index = closedStopIDs_extra.indexOf(stopIDUpper);
            if (index > -1) closedStopIDs_extra.splice(index, 1);
        }
        populateMasterStopList_ExtraPage(); // Refresh to show reverted state
    }
}

// Place this function in your <script> tag in omsi_tools_extra.html
// where other helper functions are defined.

function getTextColourForBackground_ExtraPage(hexColour) {
    if (!hexColour || typeof hexColour !== 'string' || !hexColour.startsWith('#')) {
        // console.warn("getTextColourForBackground_ExtraPage: Invalid hexColour provided:", hexColour, "Defaulting to white text.");
        return '#FFFFFF'; // Default to white text on error or if invalid
    }

    let r, g, b;
    if (hexColour.length === 4) { // Expand short hex e.g. #RGB to #RRGGBB
        r = parseInt(hexColour[1] + hexColour[1], 16);
        g = parseInt(hexColour[2] + hexColour[2], 16);
        b = parseInt(hexColour[3] + hexColour[3], 16);
    } else if (hexColour.length === 7) {
        r = parseInt(hexColour.slice(1, 3), 16);
        g = parseInt(hexColour.slice(3, 5), 16);
        b = parseInt(hexColour.slice(5, 7), 16);
    } else {
        // console.warn("getTextColourForBackground_ExtraPage: Hex length invalid:", hexColour, "Defaulting to white text.");
        return '#FFFFFF'; // Invalid length
    }

    if (isNaN(r) || isNaN(g) || isNaN(b)) {
        // console.warn("getTextColourForBackground_ExtraPage: Failed to parse hex:", hexColour, "Defaulting to white text.");
        return '#FFFFFF';
    }
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return luminance > 0.5 ? '#000000' : '#FFFFFF';
}

function rsg_openReplaceStopModal_ExtraPage(indexToReplace) {
    // MODIFICATION: Get the modal element directly inside the function
    const modalElement = document.getElementById('rsg-replace-stop-modal-extra');

    // Log 1: Function entry
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 1: Function called with indexToReplace:", indexToReplace, "Type:", typeof indexToReplace);
    console.log("[rsg_openReplaceStopModal_ExtraPage] Fresh modalElement lookup result:", modalElement); // NEW LOG to see if it's found

    // NEW DIRECT CHECK for the main modal container
    if (!modalElement) {
        alert("Critical Error: The modal container 'rsg-replace-stop-modal-extra' was NOT found in the DOM when trying to open it. Please ensure its HTML is correct and not commented out or removed by another script.");
        console.error("[rsg_openReplaceStopModal_ExtraPage] The element with ID 'rsg-replace-stop-modal-extra' is null at the time of function call.");
        return; // Stop if the main modal div isn't there
    }

    // Original Check 1: Validate rsg_selectedStops_extra (data for the sequence)
    if (rsg_selectedStops_extra === null || typeof rsg_selectedStops_extra === 'undefined') {
        console.error("[rsg_openReplaceStopModal_ExtraPage] ERROR CHECK 1: rsg_selectedStops_extra is null or undefined! Cannot proceed.");
        alert("Critical Error: The stop sequence data is not available for replacement operation.");
        return;
    }
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 2 (original check 1): rsg_selectedStops_extra type:", typeof rsg_selectedStops_extra, "Is Array:", Array.isArray(rsg_selectedStops_extra), "Length:", rsg_selectedStops_extra?.length);

    // Original Check 2: Validate indexToReplace (index within the sequence data)
    if (typeof indexToReplace !== 'number' || isNaN(indexToReplace) || indexToReplace < 0 || indexToReplace >= rsg_selectedStops_extra.length) {
        console.error("[rsg_openReplaceStopModal_ExtraPage] ERROR CHECK 2: Invalid indexToReplace.",
                      "Index:", indexToReplace, "Sequence length:", rsg_selectedStops_extra.length);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Error: Invalid stop position for replacement operation. Index out of bounds.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        } else {
            alert("Error: Invalid stop position for replacement operation.");
        }
        return;
    }
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 3 (original check 2): indexToReplace is valid.");

    rsg_indexOfStopToReplace_extra = indexToReplace;
    const originalStop = rsg_selectedStops_extra[indexToReplace];

    // Original Check 3: Validate originalStop (data for the specific stop being replaced)
    if (!originalStop || typeof originalStop !== 'object') {
        console.error("[rsg_openReplaceStopModal_ExtraPage] ERROR CHECK 3: Could not find valid original stop data at index", indexToReplace, "Data found:", originalStop);
        alert("Error: Could not retrieve data for the stop to be replaced.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Error: Original stop data missing.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 4 (original check 3): Original stop to replace:", JSON.parse(JSON.stringify(originalStop)));

    // Check 4: DOM Elements for the modal *CONTENTS*. The main container (`modalElement`) is already confirmed to exist.
    let allModalInternalElementsPresent = true;
    const modalTitle_el = document.getElementById('rsg-replace-stop-modal-title-extra');
    const modalInfo_el = document.getElementById('rsg-replace-stop-modal-info-extra');
    const modalSearchInput_el = document.getElementById('rsg-replace-stop-search-input-extra');
    const modalSearchResults_el = document.getElementById('rsg-replace-stop-search-results-extra');
    const modalStatus_el = document.getElementById('rsg-replace-stop-modal-status-extra'); // Status paragraph inside the modal

    if (!modalTitle_el) { console.error("[rsg_openReplaceStopModal_ExtraPage] Modal internal part 'rsg-replace-stop-modal-title-extra' is null."); allModalInternalElementsPresent = false; }
    if (!modalInfo_el) { console.error("[rsg_openReplaceStopModal_ExtraPage] Modal internal part 'rsg-replace-stop-modal-info-extra' is null."); allModalInternalElementsPresent = false; }
    if (!modalSearchInput_el) { console.error("[rsg_openReplaceStopModal_ExtraPage] Modal internal part 'rsg-replace-stop-search-input-extra' is null."); allModalInternalElementsPresent = false; }
    if (!modalSearchResults_el) { console.error("[rsg_openReplaceStopModal_ExtraPage] Modal internal part 'rsg-replace-stop-search-results-extra' is null."); allModalInternalElementsPresent = false; }

    if (!allModalInternalElementsPresent) {
        alert("Critical Error: Some internal parts of the 'Replace Stop' dialog are missing from the page, even if the main container was found. Modal may not function correctly. Check console for details.");
        // Optionally, you could still try to show the modal if the main container exists but internals are missing,
        // or return here to prevent showing a broken modal. For now, let's allow it to proceed to show the (potentially empty) modal.
    }
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 5 equivalent: Check for internal modal parts complete. allModalInternalElementsPresent:", allModalInternalElementsPresent);

    // Populate modal content (these will only run if elements were found)
    if (modalTitle_el) {
        modalTitle_el.textContent = `Replace: ${originalStop.stopName || 'N/A'} (${originalStop.stopID || 'N/A'})`;
    }
    if (modalInfo_el) {
        let timeAdjInfo = "";
        if (indexToReplace > 0) {
            timeAdjInfo = `The existing time adjustment of +${originalStop.timeAdjustment || 0} min (from previous stop) will be kept.`;
        } else {
            timeAdjInfo = "This is the first stop in the sequence; its time adjustment is effectively 0.";
        }
        modalInfo_el.textContent = `You are replacing the stop at position ${indexToReplace + 1}. ${timeAdjInfo}`;
    }
    if (modalSearchInput_el) {
        modalSearchInput_el.value = '';
    }
    if (modalSearchResults_el) {
        modalSearchResults_el.innerHTML = '<p style="padding:5px; opacity:0.7;">Type to search for a replacement stop.</p>';
    }
    if (modalStatus_el) {
        modalStatus_el.textContent = '';
    }

    // Display the modal using the locally fetched 'modalElement'
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 6 equivalent: Attempting to display the modal element.");
    modalElement.style.display = 'flex'; // Use the locally fetched modalElement
    if (modalSearchInput_el) {
        modalSearchInput_el.focus();
    }
    console.log("[rsg_openReplaceStopModal_ExtraPage] LOG 7 equivalent: Modal display style set to 'flex'. Focus set to input (if available).");
}

function rsg_closeReplaceStopModal_ExtraPage() {
    if (rsgReplaceStopModal_el_extra) {
        rsgReplaceStopModal_el_extra.style.display = 'none';
    }
    rsg_indexOfStopToReplace_extra = -1; // Reset index
}

function rsg_handleReplaceStopSearch_ExtraPage() {
    if (!rsgReplaceStopSearchInput_el_extra || !rsgReplaceStopSearchResults_el_extra || !allDefinedStops_data) {
        // Ensure necessary elements and data are available
        if (rsgReplaceStopSearchResults_el_extra) {
             rsgReplaceStopSearchResults_el_extra.innerHTML = '<p style="padding:5px; opacity:0.7; color: #e74c3c;">Error: Search components not ready.</p>';
        }
        return;
    }

    const searchTerm = rsgReplaceStopSearchInput_el_extra.value.toLowerCase().trim();
    rsgReplaceStopSearchResults_el_extra.innerHTML = ''; // Clear previous results

    if (searchTerm.length === 0) {
        rsgReplaceStopSearchResults_el_extra.innerHTML = '<p style="padding:5px; opacity:0.7;">Type to search for a replacement stop.</p>';
        return;
    }
    if (searchTerm.length < 2) { // Optional: you might want to allow 1-char searches or adjust this
        rsgReplaceStopSearchResults_el_extra.innerHTML = '<p style="padding:5px; opacity:0.7;">Please type at least 2 characters to search.</p>';
        return;
    }

    // Ensure allDefinedStops_data is an object before trying to get its values
    const definedStopsArray = (typeof allDefinedStops_data === 'object' && allDefinedStops_data !== null)
                             ? Object.values(allDefinedStops_data)
                             : [];

    if (definedStopsArray.length === 0) {
        rsgReplaceStopSearchResults_el_extra.innerHTML = '<p style="padding:5px; opacity:0.7; color: #f1c40f;">No defined stops available to search.</p>';
        return;
    }
    
    const currentStopBeingReplacedID = (rsg_indexOfStopToReplace_extra !== -1 && 
                                        rsg_selectedStops_extra && // Ensure rsg_selectedStops_extra exists
                                        rsg_selectedStops_extra[rsg_indexOfStopToReplace_extra])
                                    ? rsg_selectedStops_extra[rsg_indexOfStopToReplace_extra].stopID.toUpperCase()
                                    : null;

    const filteredStops = definedStopsArray.filter(stop => {
        // Ensure stop object and its properties are valid before accessing
        const stopName = stop && typeof stop.stopName === 'string' ? stop.stopName : "";
        const stopID = stop && typeof stop.stopID === 'string' ? stop.stopID : "";

        if (!stopID) return false; // Skip if stopID is invalid or missing

        // Exclude the exact stop that is currently at the position being replaced
        if (currentStopBeingReplacedID && stopID.toUpperCase() === currentStopBeingReplacedID) {
            return false;
        }
        return stopName.toLowerCase().includes(searchTerm) || stopID.toLowerCase().includes(searchTerm);
    }).slice(0, 10); // Limit results to the top 10

    if (filteredStops.length > 0) {
        filteredStops.forEach(newStop => { // newStop is an object like { stopID: "X", stopName: "Y", direction: "Z" }
            const itemDiv = document.createElement('div');
            itemDiv.classList.add('rsg-search-result-item');

            // --- CORRECTED CONTENT GENERATION ---
            const stopNameDisplay = newStop.stopName || 'N/A';
            const stopIDDisplay = newStop.stopID || 'N/A'; 

            // Main stop name and ID line
            let content = `<span class="rsg-search-stop-name">${stopNameDisplay} (${stopIDDisplay})</span>`;

            // Add direction if available
            let directionText = "";
            if (newStop.direction && newStop.direction.trim() !== "" && newStop.direction.trim().toUpperCase() !== "NO DIRECTION") {
                directionText = `Towards: ${newStop.direction}`;
            }
            if (directionText) {
                content += `<span class="rsg-search-stop-details">${directionText}</span>`;
            }
            // --- END OF CORRECTION ---
            
            itemDiv.innerHTML = content;

            itemDiv.addEventListener('click', () => {
                // Ensure rsg_confirmStopReplacement_ExtraPage is defined before calling
                if (typeof rsg_confirmStopReplacement_ExtraPage === 'function') {
                    rsg_confirmStopReplacement_ExtraPage(newStop);
                } else {
                    console.error("Error: rsg_confirmStopReplacement_ExtraPage function is not defined.");
                    alert("Error: Cannot confirm stop replacement, function missing.");
                }
            });
            rsgReplaceStopSearchResults_el_extra.appendChild(itemDiv);
        });
    } else {
        rsgReplaceStopSearchResults_el_extra.innerHTML = '<div class="rsg-search-result-item">No other matching stops found.</div>';
    }
}

function rsg_confirmStopReplacement_ExtraPage(newStopData) {
    if (rsg_indexOfStopToReplace_extra < 0 || rsg_indexOfStopToReplace_extra >= rsg_selectedStops_extra.length) {
        console.error("Cannot replace stop, invalid index stored:", rsg_indexOfStopToReplace_extra);
        const modalStatusEl = document.getElementById('rsg-replace-stop-modal-status-extra');
        if (modalStatusEl) {
            modalStatusEl.textContent = "Error: Invalid stop position. Please close and retry.";
            modalStatusEl.style.color = "#e74c3c";
        }
        return;
    }

    const originalStopData = rsg_selectedStops_extra[rsg_indexOfStopToReplace_extra];
    // Preserve time adjustment. For the first stop (index 0), it's always 0.
    const preservedTimeAdjustment = (rsg_indexOfStopToReplace_extra === 0) ? 0 : (originalStopData.timeAdjustment || 0);

    const replacementStop = {
        stopID: newStopData.stopID,
        stopName: newStopData.stopName,
        direction: newStopData.direction || "",
        timeAdjustment: preservedTimeAdjustment
    };

    rsg_selectedStops_extra.splice(rsg_indexOfStopToReplace_extra, 1, replacementStop);

    rsg_isDirty = true;
    rsg_closeReplaceStopModal_ExtraPage();
    rsg_renderStopSequence_ExtraPage();
    rsg_resetPreviewState(`Stop '<span class="math-inline">\{originalStopData\.stopName\}' replaced with '</span>{newStopData.stopName}'. Regenerate preview.`, "info");
    rsg_updateRsgActionButtonsState();

    if (rsgStatusMessage_el_extra) {
        rsgStatusMessage_el_extra.textContent = `Stop at position ${rsg_indexOfStopToReplace_extra + 1} changed to ${newStopData.stopName}.`;
        rsgStatusMessage_el_extra.style.color = "#2ecc71";
    }
}

// In omsi_tools_extra.html

// This function should be called to save the master list of all defined stops
async function saveAllDefinedStopsToFirebase_ExtraPage() {
    if (!currentUser_extra || !window.firebaseOMSI) {
        console.error("saveAllDefinedStopsToFirebase_ExtraPage: Not logged in or Firebase not available.");
        throw new Error("Authentication or Firebase connection issue for saving defined stops.");
    }
    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        // This line saves the entire 'allDefinedStops_data' object to the '/allDefinedStops' path
        await dbSet(dbRef(database, FB_PATH_ALL_DEFINED_STOPS), allDefinedStops_data);
        console.log("All defined stop definitions saved to Firebase path:", FB_PATH_ALL_DEFINED_STOPS);
    } catch (error) {
        console.error("Error saving all defined stop definitions to Firebase:", error);
        throw error; // Propagate error to be handled by the caller
    }
}

// This function is called when you click "Add Stop Definition"
async function handleAddStopDetails_ExtraPage() {
    if (!currentUser_extra || !addNewStopStatus_el_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !inputNewStopDirection_el_extra) {
        if (addNewStopStatus_el_extra) {
            addNewStopStatus_el_extra.textContent = "Error: UI components missing for adding stop.";
            addNewStopStatus_el_extra.style.color = '#e74c3c';
        }
        return;
    }
    const newStopID = inputNewStopId_el_extra.value.trim().toUpperCase(); // Ensure newStopID is uppercase
    const newStopName = inputNewStopName_el_extra.value.trim();
    const newStopDirection = inputNewStopDirection_el_extra.value.trim();

    if (!newStopID) { 
        addNewStopStatus_el_extra.textContent = "New Stop ID is required."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopId_el_extra.focus(); 
        return; 
    }
    if (!/^[A-Z0-9]+$/.test(newStopID)) { 
        addNewStopStatus_el_extra.textContent = "Stop ID: A-Z, 0-9 only (uppercase)."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopId_el_extra.focus(); 
        return; 
    }
    if (!newStopName) { 
        addNewStopStatus_el_extra.textContent = "New Stop Name is required."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopName_el_extra.focus(); 
        return; 
    }

    // Check against the local cache 'allDefinedStops_data'
    // Ensure 'allDefinedStops_data' keys are consistently uppercase
    if (allDefinedStops_data && allDefinedStops_data[newStopID]) { 
        addNewStopStatus_el_extra.textContent = `Stop ID "${newStopID}" already exists as a definition.`; 
        if(newStopIdAvailability_el_extra){ 
            newStopIdAvailability_el_extra.textContent = 'ID already exists!'; 
            newStopIdAvailability_el_extra.style.color = '#e74c3c'; 
        } 
        inputNewStopId_el_extra.focus(); 
        return; 
    }

    const newStopDefinition = {
        stopID: newStopID, // Storing the uppercase version
        stopName: newStopName,
        direction: newStopDirection
    };
    
    // Add to local cache 'allDefinedStops_data' using uppercase key
    if (!allDefinedStops_data) allDefinedStops_data = {};
    allDefinedStops_data[newStopID] = newStopDefinition;

    addNewStopStatus_el_extra.textContent = `Adding stop definition "${newStopID}" to Firebase...`;
    addNewStopStatus_el_extra.style.color = '#f1c40f';

    try {
        // This is the crucial call to save the updated master list to Firebase
        await saveAllDefinedStopsToFirebase_ExtraPage(); 
        
        addNewStopStatus_el_extra.textContent = `Stop definition "${newStopID} - ${newStopName}" added to Firebase.`;
        addNewStopStatus_el_extra.style.color = '#2ecc71';

        // Clear inputs and refresh UI
        inputNewStopId_el_extra.value = ''; 
        inputNewStopName_el_extra.value = ''; 
        inputNewStopDirection_el_extra.value = '';
        if(newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = '';
        if(selectNewStopIdFormat_el_extra) selectNewStopIdFormat_el_extra.selectedIndex = 0;
        
        if (typeof autoGenerateAndSetNewStopId_ExtraPage === 'function' && inputNewStopName_el_extra && inputNewStopId_el_extra) {
            autoGenerateAndSetNewStopId_ExtraPage(); // Suggest ID for the *next* stop
        }
        
        renderUIDependentElements_ExtraPage(); // Refresh UI lists (like master stop list)

    } catch (error) {
        console.error("Error adding new stop definition:", error);
        addNewStopStatus_el_extra.textContent = "Error saving stop definition: " + error.message;
        addNewStopStatus_el_extra.style.color = '#e74c3c';
        
        // Revert local addition if Firebase update failed
        if (allDefinedStops_data && allDefinedStops_data[newStopID]) {
            delete allDefinedStops_data[newStopID];
        }
        renderUIDependentElements_ExtraPage(); // Refresh UI to show the reverted state
    }
}

// Function to populate the route dropdown for Scheduled Route Deletion (SRD)
function srd_populateRouteSelect_ExtraPage() {
    if (!srdRouteNameSelect_el_extra || !currentWorkingSchedule_extra) {
        console.warn("SRD: Route select element or schedule data not available.");
        return;
    }
    // Get unique routes that actually have schedule entries (not just definitions)
    const uniqueRoutesWithSchedules = [...new Set(
        currentWorkingSchedule_extra
            .filter(e => e.lineName && e.scheduledTime) // Ensure it's a route with actual schedule entries
            .map(e => e.lineName)
    )].sort(compareLineNames_ExtraPage);

    const currentInputValue = srdRouteNameInput_el_extra ? srdRouteNameInput_el_extra.value.trim() : "";

    srdRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Route to Delete --</option>';
    uniqueRoutesWithSchedules.forEach(route => {
        const opt = document.createElement('option');
        opt.value = route;
        opt.textContent = route;
        srdRouteNameSelect_el_extra.appendChild(opt);
    });

    if (currentInputValue) {
        const matchedOption = uniqueRoutesWithSchedules.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
        srdRouteNameSelect_el_extra.value = matchedOption ? matchedOption : "";
    } else {
        srdRouteNameSelect_el_extra.value = "";
    }
    if(srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = '';
}

function rsg_pullCurrentFirstStopTimes_ExtraPage() {
    if (!currentUser_extra) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Please log in to pull times.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    if (!rsgRouteNameInput_el_extra || !rsgDestinationNameInput_el_extra || !rsgFirstStopTimesInput_el_extra || !rsgStatusMessage_el_extra) {
        console.error("RSG Pull Times: Essential DOM elements missing.");
        alert("Error: RSG form components for pulling times are missing.");
        return;
    }

    const routeName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
    const opProfilesString = rsg_getSelectedOpProfilesString_ExtraPage(); // Returns comma-separated string like "MF, Sa"
    const destName = rsgDestinationNameInput_el_extra.value.trim();

    if (!routeName) {
        rsgStatusMessage_el_extra.textContent = "Please select/enter a Route Name first.";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }
    if (!opProfilesString) {
        rsgStatusMessage_el_extra.textContent = "Please select Operating Profile(s) first.";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }
    if (!destName) {
        rsgStatusMessage_el_extra.textContent = "Please select/enter a Destination Name first.";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    if (!rsg_selectedStops_extra || rsg_selectedStops_extra.length === 0) {
        rsgStatusMessage_el_extra.textContent = "No stops in the sequence. Add the first stop to pull its times.";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    const firstStopID = rsg_selectedStops_extra[0].stopID;
    const selectedOpProfilesArray = opProfilesString.split(',').map(p => p.trim()).filter(Boolean);
    const uniqueTimesSet = new Set();

    currentWorkingSchedule_extra.forEach(entry => {
        if (entry.lineName && entry.lineName.toUpperCase() === routeName &&
            entry.destinationName === destName &&
            entry.stopID === firstStopID &&
            entry.OperatingProfile && selectedOpProfilesArray.includes(entry.OperatingProfile) &&
            (entry.DayOffset === "0" || !entry.DayOffset) && // Primarily pull times for DayOffset 0
            entry.scheduledTime && entry.scheduledTime.match(/^\d{2}:\d{2}$/)) {
            uniqueTimesSet.add(entry.scheduledTime);
        }
    });

    if (uniqueTimesSet.size > 0) {
        const sortedTimes = Array.from(uniqueTimesSet).sort((a, b) => {
            const timeAVal = parseInt(a.replace(':', ''), 10);
            const timeBVal = parseInt(b.replace(':', ''), 10);
            return timeAVal - timeBVal;
        });
        rsgFirstStopTimesInput_el_extra.value = sortedTimes.join('\t');
        rsgStatusMessage_el_extra.textContent = `Pulled ${sortedTimes.length} unique first stop time(s) for the selected parameters.`;
        rsgStatusMessage_el_extra.style.color = "#2ecc71";
        rsg_isDirty = true; // Mark configuration as dirty
        console.log(`RSG User Edit: First stop times pulled. rsg_isDirty is true. Times: "${rsgFirstStopTimesInput_el_extra.value}"`);
        // Trigger input event for the textarea if other logic depends on it
        rsgFirstStopTimesInput_el_extra.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
    } else {
        rsgFirstStopTimesInput_el_extra.value = ''; // Clear if no times found
        rsgStatusMessage_el_extra.textContent = "No existing first stop times found in the main schedule for the current RSG Route, Profile(s), Destination, and First Stop (with DayOffset 0).";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
    }
}

function sru_openCancelRouteTimeSelectModal_ExtraPage(routeName) {
    if (!sruCancelRouteTimeSelectModal_el_extra || !sruCancelModalTitle_el_extra || 
        !sruCancelModalRouteInfo_el_extra || !sruCancelModalCheckboxesContainer_el_extra || 
        !sruCancelModalStatus_el_extra || !sruCancelModalSelectAllCheckbox_el_extra ||
        !sruCancelModalConfirmButton_el_extra) {
        console.error("SRU Cancel Modal: Essential modal elements are missing from the DOM.");
        alert("Error: Cancellation modal components are not fully available.");
        return;
    }

    sruCancelModalStatus_el_extra.textContent = '';
    sruCancelModalRouteInfo_el_extra.textContent = `Route: ${routeName}`;
    sruCancelModalTitle_el_extra.textContent = `Cancel Updates for Route: ${routeName}`;
    sruCancelModalCheckboxesContainer_el_extra.innerHTML = '<p style="opacity:0.7;">Loading available go-live times...</p>';
    sruCancelModalSelectAllCheckbox_el_extra.checked = false; // Reset select all

    const pendingApplyTasksForRoute = [];
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.values(scheduledRouteUpdates_extra).forEach(task => {
            if (task && task.routeName === routeName &&
                (task.taskType === 'applySchedule' || task.taskTypeDisplay === 'applySchedule') &&
                task.status === 'pending' && task.goLiveDateTime) {
                pendingApplyTasksForRoute.push(task);
            }
        });
    }

    sruCancelModalContext.routeName = routeName; // Store routeName in context

    const uniqueGoLiveTimes = [...new Set(pendingApplyTasksForRoute.map(task => task.goLiveDateTime))]
        .sort((a, b) => new Date(a).getTime() - new Date(b).getTime());

    if (uniqueGoLiveTimes.length === 0) {
        sruCancelModalCheckboxesContainer_el_extra.innerHTML = '<p style="opacity:0.7;">No pending updates with specific go-live times found for this route to cancel.</p>';
        sruCancelModalConfirmButton_el_extra.disabled = true;
        sruCancelModalSelectAllCheckbox_el_extra.disabled = true;
    } else {
        sruCancelModalCheckboxesContainer_el_extra.innerHTML = ''; // Clear "Loading..."
        uniqueGoLiveTimes.forEach((isoTime, index) => {
            const tasksAtThisTimeCount = pendingApplyTasksForRoute.filter(t => t.goLiveDateTime === isoTime).length;
            const checkboxId = `sru-cancel-cb-time-${index}`;
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'sru-cancel-time-item'; // For potential specific styling

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = 'sruCancelSelectedGoLiveTimeCheckbox_extra';
            checkbox.id = checkboxId;
            checkbox.value = isoTime;
            checkbox.dataset.taskCount = tasksAtThisTimeCount; // Store task count for info
            checkbox.addEventListener('change', () => { // Handle individual checkbox changes
                const allTimeCheckboxes = sruCancelModalCheckboxesContainer_el_extra.querySelectorAll('input[type="checkbox"]');
                const allChecked = Array.from(allTimeCheckboxes).every(cb => cb.checked);
                sruCancelModalSelectAllCheckbox_el_extra.checked = allChecked;
            });

            const label = document.createElement('label');
            label.htmlFor = checkboxId;
            label.textContent = `${new Date(isoTime).toLocaleString()} (${tasksAtThisTimeCount} task(s))`;
            
            itemDiv.appendChild(checkbox);
            itemDiv.appendChild(label);
            sruCancelModalCheckboxesContainer_el_extra.appendChild(itemDiv);
        });
        sruCancelModalConfirmButton_el_extra.disabled = false;
        sruCancelModalSelectAllCheckbox_el_extra.disabled = false;
    }
    sruCancelRouteTimeSelectModal_el_extra.style.display = 'flex';
}

function sru_closeCancelRouteTimeSelectModal_ExtraPage() {
    if (sruCancelRouteTimeSelectModal_el_extra) {
        sruCancelRouteTimeSelectModal_el_extra.style.display = 'none';
    }
    sruCancelModalContext.routeName = null; // Clear context
    if (sruCancelModalCheckboxesContainer_el_extra) sruCancelModalCheckboxesContainer_el_extra.innerHTML = ''; // Clear checkboxes
    if (sruCancelModalSelectAllCheckbox_el_extra) sruCancelModalSelectAllCheckbox_el_extra.checked = false;
}

async function sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage() {
    if (!sruCancelModalContext.routeName) {
        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = "Error: Route context is missing. Please close and retry.";
            sruCancelModalStatus_el_extra.style.color = "#e74c3c";
        }
        return;
    }
    const routeName = sruCancelModalContext.routeName;

    const selectedTimeCheckboxes = sruCancelModalCheckboxesContainer_el_extra.querySelectorAll('input[type="checkbox"]:checked');
    const selectedGoLiveTimesISO = Array.from(selectedTimeCheckboxes).map(cb => cb.value);

    if (selectedGoLiveTimesISO.length === 0) {
        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = "No go-live time(s) selected for cancellation.";
            sruCancelModalStatus_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    const tasksToCancelKeys = [];
    let totalTasksAffectedCount = 0;
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.entries(scheduledRouteUpdates_extra).forEach(([key, task]) => {
            if (task && task.routeName === routeName &&
                selectedGoLiveTimesISO.includes(task.goLiveDateTime) &&
                (task.taskType === 'applySchedule' || task.taskTypeDisplay === 'applySchedule') &&
                task.status === 'pending') {
                tasksToCancelKeys.push(key);
                totalTasksAffectedCount++;
            }
        });
    }

    if (tasksToCancelKeys.length === 0) { // Should ideally not happen if checkboxes were based on pending tasks
        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = "No matching pending updates found for the selected criteria. The list might have changed.";
            sruCancelModalStatus_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    
    const selectedTimesReadable = selectedGoLiveTimesISO.map(iso => new Date(iso).toLocaleString()).join(', ');
    const confirmMsg = `Are you sure you want to cancel all ${totalTasksAffectedCount} pending timetable update(s) for Route "${routeName}" scheduled for the following time(s):\n- ${selectedTimesReadable}\nThis action cannot be undone.`;
    
    if (!confirm(confirmMsg)) {
        if(sruCancelModalStatus_el_extra) sruCancelModalStatus_el_extra.textContent = "Cancellation aborted by user.";
        return;
    }

    if(sruCancelModalStatus_el_extra) {
        sruCancelModalStatus_el_extra.textContent = `Cancelling ${totalTasksAffectedCount} task(s) for Route "${routeName}"...`;
        sruCancelModalStatus_el_extra.style.color = "#f1c40f";
    }

    const { database, dbUpdate, dbRef } = window.firebaseOMSI;
    const updatesToRemove = {};
    tasksToCancelKeys.forEach(taskKey => {
        updatesToRemove[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`] = null;
    });

    try {
        await dbUpdate(dbRef(database), updatesToRemove);
        
        tasksToCancelKeys.forEach(taskKey => { // Update local cache
            if (scheduledRouteUpdates_extra && scheduledRouteUpdates_extra[taskKey]) {
                delete scheduledRouteUpdates_extra[taskKey];
            }
        });

        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = `Successfully cancelled ${totalTasksAffectedCount} update(s) for Route "${routeName}".`;
            sruCancelModalStatus_el_extra.style.color = "#2ecc71";
        }
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh the main list
        setTimeout(sru_closeCancelRouteTimeSelectModal_ExtraPage, 1800);

    } catch (error) {
        console.error(`Error cancelling updates for route ${routeName}:`, error);
        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = `Error cancelling updates: ${error.message}`;
            sruCancelModalStatus_el_extra.style.color = "#e74c3c";
        }
    }
}

async function handleCancelAllUpdatesForRoute_Master(routeName) {
    if (!routeName) {
        console.error("handleCancelAllUpdatesForRoute_Master called without routeName");
        return;
    }

    const pendingApplyTasksForRoute = [];
     if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.values(scheduledRouteUpdates_extra).forEach(task => {
            if (task && task.routeName === routeName &&
                (task.taskType === 'applySchedule' || task.taskTypeDisplay === 'applySchedule') &&
                task.status === 'pending' && task.goLiveDateTime) {
                pendingApplyTasksForRoute.push(task);
            }
        });
    }

    if (pendingApplyTasksForRoute.length === 0) {
        alert(`No pending timetable updates found for Route "${routeName}" to cancel.`);
        return;
    }

    const uniqueGoLiveTimesForRoute = [...new Set(pendingApplyTasksForRoute.map(task => task.goLiveDateTime))];

    if (uniqueGoLiveTimesForRoute.length === 1) {
        // Only one go-live time, directly use the execution logic for that single time.
        // We need to pass routeName and the single goLiveDateTimeISO to a function that can handle it.
        // For simplicity, we'll construct what sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage expects.
        sruCancelModalContext.routeName = routeName; // Set context for the execution function
        
        // Simulate selection of this single time to pass to the execution function
        // This is a bit of a workaround; ideally, sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage
        // would take routeName and an array of ISO times.
        // For now, we can directly call a firebase removal.

        const tasksToCancelKeys = pendingApplyTasksForRoute.map(task => {
             // Find the key for this task in scheduledRouteUpdates_extra
            for (const key in scheduledRouteUpdates_extra) {
                if (scheduledRouteUpdates_extra[key] === task) return key;
            }
            return null;
        }).filter(Boolean);


        if (tasksToCancelKeys.length > 0) {
            const confirmMsg = `Are you sure you want to cancel all ${tasksToCancelKeys.length} pending timetable update(s) for Route "${routeName}" scheduled for ${new Date(uniqueGoLiveTimesForRoute[0]).toLocaleString()}?`;
            if (!confirm(confirmMsg)) return;

            if (rsgStatusMessage_el_extra) { // Use a general status message
                 rsgStatusMessage_el_extra.textContent = `Cancelling updates for Route ${routeName}...`;
                 rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }

            const { database, dbUpdate, dbRef } = window.firebaseOMSI;
            const updatesToRemove = {};
            tasksToCancelKeys.forEach(taskKey => {
                updatesToRemove[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`] = null;
            });

            try {
                await dbUpdate(dbRef(database), updatesToRemove);
                tasksToCancelKeys.forEach(taskKey => {
                    if (scheduledRouteUpdates_extra && scheduledRouteUpdates_extra[taskKey]) {
                        delete scheduledRouteUpdates_extra[taskKey];
                    }
                });
                if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = `Successfully cancelled updates for Route "${routeName}".`;
                    rsgStatusMessage_el_extra.style.color = "#2ecc71";
                }
                loadAndDisplayScheduledUpdates_ExtraPage();
            } catch (error) {
                 if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = `Error cancelling updates for ${routeName}: ${error.message}`;
                    rsgStatusMessage_el_extra.style.color = "#e74c3c";
                }
            }
        }

    } else if (uniqueGoLiveTimesForRoute.length > 1) {
        sru_openCancelRouteTimeSelectModal_ExtraPage(routeName); // Open modal for selection
    } else {
        alert(`No specific go-live times found for pending updates on Route "${routeName}". This shouldn't happen if tasks were found.`);
    }
}

async function handleCancelAllUpdatesAllRoutes_Global() {
    console.log("// DEBUG: 1. handleCancelAllUpdatesAllRoutes_Global function CALLED."); // DEBUG: New Log

    if (!currentUser_extra) {
        console.log("// DEBUG: 2. Exiting because currentUser_extra is falsy."); // DEBUG: New Log
        if(sruCancelAllGlobalStatusMessage_el_extra) { sruCancelAllGlobalStatusMessage_el_extra.textContent = "Please log in."; sruCancelAllGlobalStatusMessage_el_extra.style.color = "#e74c3c"; }
        return;
    }
    console.log("// DEBUG: 2a. User is logged in:", currentUser_extra.email); // DEBUG: New Log

    const pendingApplyScheduleTaskKeys = [];
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        console.log("// DEBUG: 3. scheduledRouteUpdates_extra IS an object. Number of keys:", Object.keys(scheduledRouteUpdates_extra).length); // DEBUG: New Log
        // DEBUG: Log a small sample of the tasks to check their structure
        let taskSampleCount = 0;
        for (const key_debug in scheduledRouteUpdates_extra) {
            if (taskSampleCount < 2) { // Log first 2 tasks found
                 console.log(`// DEBUG: Task sample [${key_debug}]:`, JSON.parse(JSON.stringify(scheduledRouteUpdates_extra[key_debug])));
                 taskSampleCount++;
            } else {
                break;
            }
        }

        Object.entries(scheduledRouteUpdates_extra).forEach(([key, task]) => {
            // DEBUG: Log each task being checked and if it matches criteria
            const isApplyScheduleType = task && (task.taskType === 'applySchedule' || task.taskTypeDisplay === 'applySchedule');
            const isPendingStatus = task && task.status === 'pending';
            // console.log(`// DEBUG: Checking task [${key}]: taskType='${task ? task.taskType : 'N/A'}', taskTypeDisplay='${task ? task.taskTypeDisplay : 'N/A'}', status='${task ? task.status : 'N/A'}'. Match: ${isApplyScheduleType && isPendingStatus}`);

            if (isApplyScheduleType && isPendingStatus) {
                pendingApplyScheduleTaskKeys.push(key);
            }
        });
    } else {
        console.log("// DEBUG: 3. scheduledRouteUpdates_extra is NOT an object or is null."); // DEBUG: New Log
    }

    console.log("// DEBUG: 4. Number of pendingApplyScheduleTaskKeys found:", pendingApplyScheduleTaskKeys.length); // DEBUG: New Log
    if (pendingApplyScheduleTaskKeys.length > 0) {
        console.log("// DEBUG: Keys found:", pendingApplyScheduleTaskKeys.join(', ')); // DEBUG: New Log
    }


    if (pendingApplyScheduleTaskKeys.length === 0) {
        console.log("// DEBUG: 5. Exiting because no pending applySchedule tasks found."); // DEBUG: New Log
        if(sruCancelAllGlobalStatusMessage_el_extra) {
            sruCancelAllGlobalStatusMessage_el_extra.textContent = "No pending timetable updates found across all routes to cancel.";
            sruCancelAllGlobalStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    console.log("// DEBUG: 6. About to show confirmation prompt."); // DEBUG: New Log
    const userConfirmation = prompt(`EXTREME CAUTION!\nYou are about to cancel ALL ${pendingApplyScheduleTaskKeys.length} pending timetable updates for ALL routes and ALL go-live times.\nThis action CANNOT BE UNDONE.\n\nTo confirm, please type "CANCEL ALL UPDATES" in the box below:`);
    console.log("// DEBUG: 7. User confirmation input:", userConfirmation); // DEBUG: New Log


    if (userConfirmation !== "CANCEL ALL UPDATES") {
        console.log("// DEBUG: 8. Exiting because user confirmation was not 'CANCEL ALL UPDATES'."); // DEBUG: New Log
        if(sruCancelAllGlobalStatusMessage_el_extra) {
            sruCancelAllGlobalStatusMessage_el_extra.textContent = "Global cancellation aborted by user or incorrect confirmation.";
            sruCancelAllGlobalStatusMessage_el_extra.style.color = "";
        }
        return;
    }

    console.log("// DEBUG: 9. Proceeding with cancellation logic."); // DEBUG: New Log
    if(sruCancelAllGlobalStatusMessage_el_extra) {
        sruCancelAllGlobalStatusMessage_el_extra.textContent = `Processing global cancellation of ${pendingApplyScheduleTaskKeys.length} task(s)...`;
        sruCancelAllGlobalStatusMessage_el_extra.style.color = "#f1c40f";
    }
    if(sruCancelAllPendingUpdatesGloballyButton_el_extra) sruCancelAllPendingUpdatesGloballyButton_el_extra.disabled = true;

    const { database, dbUpdate, dbRef } = window.firebaseOMSI;
    const updatesToNullify = {};
    pendingApplyScheduleTaskKeys.forEach(key => {
        updatesToNullify[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${key}`] = null;
    });
    console.log("// DEBUG: 10. Firebase updatesToNullify object prepared:", updatesToNullify); // DEBUG: New Log


    try {
        await dbUpdate(dbRef(database), updatesToNullify);
        console.log("// DEBUG: 11. Firebase dbUpdate successful."); // DEBUG: New Log

        pendingApplyScheduleTaskKeys.forEach(key => {
            if (scheduledRouteUpdates_extra && scheduledRouteUpdates_extra[key]) {
                delete scheduledRouteUpdates_extra[key];
            }
        });
        
        if(sruCancelAllGlobalStatusMessage_el_extra) {
            sruCancelAllGlobalStatusMessage_el_extra.textContent = `Successfully cancelled all ${pendingApplyScheduleTaskKeys.length} pending timetable updates globally.`;
            sruCancelAllGlobalStatusMessage_el_extra.style.color = "#2ecc71";
        }
        loadAndDisplayScheduledUpdates_ExtraPage();
    } catch (error) {
        console.error("Error performing global cancellation of scheduled updates:", error);
        console.log("// DEBUG: 12. Firebase dbUpdate FAILED. Error:", error); // DEBUG: New Log
         if(sruCancelAllGlobalStatusMessage_el_extra) {
            sruCancelAllGlobalStatusMessage_el_extra.textContent = `Error during global cancellation: ${error.message}`;
            sruCancelAllGlobalStatusMessage_el_extra.style.color = "#e74c3c";
        }
    } finally {
        console.log("// DEBUG: 13. In finally block, re-enabling button."); // DEBUG: New Log
        if(sruCancelAllPendingUpdatesGloballyButton_el_extra) sruCancelAllPendingUpdatesGloballyButton_el_extra.disabled = false;
    }
}

function dpo_getCanonicalProfileString_ExtraPage(profileArray) {
    if (!Array.isArray(profileArray)) return "";
    return profileArray.map(p => String(p).trim()).sort((a,b) => a.localeCompare(b)).join(',');
}

function dpo_simulateAutoGroup_ExtraPage(selectedProfilesArray) {
    let simulatedSelections = [...selectedProfilesArray]; 
    // Assuming RSG_PROFILE_GROUPS_TO_MANAGE is suitable here
    RSG_PROFILE_GROUPS_TO_MANAGE.forEach(group => {
        const allIndividualsPresent = group.individuals.every(ind => simulatedSelections.includes(ind));
        if (allIndividualsPresent) {
            simulatedSelections = simulatedSelections.filter(p => !group.individuals.includes(p)); 
            if (!simulatedSelections.includes(group.groupProfile)) {
                simulatedSelections.push(group.groupProfile); 
            }
        }
    });
    return simulatedSelections;
}

function dpo_populateProfileCheckboxes_ExtraPage() {
    const container = document.getElementById('dpo-selectable-profiles-container-extra');
    const placeholder = document.getElementById('dpo-profiles-placeholder-extra');
    if (!container) {
        console.error("DPO Profile checkbox container not found!");
        return;
    }
    container.innerHTML = ''; // Clear previous content

    if (RSG_OPERATING_PROFILES_LIST.length === 0 && placeholder) {
        placeholder.textContent = "No profiles defined for selection.";
        container.appendChild(placeholder);
        return;
    }
    if (placeholder) placeholder.style.display = 'none';

    RSG_OPERATING_PROFILES_LIST.forEach(profileValue => {
        const wrapper = document.createElement('div');
        // Apply styles to make it look like a tile (these are from your CSS for #dpo-selectable-profiles-container-extra > div)
        wrapper.style.display = 'inline-flex';
        wrapper.style.alignItems = 'center';
        wrapper.style.backgroundColor = '#4A5568';
        wrapper.style.color = '#ecf0f1';
        wrapper.style.padding = '0.4em 0.8em';
        wrapper.style.borderRadius = '0.25rem';
        wrapper.style.border = '1px solid transparent';
        wrapper.style.cursor = 'pointer';
        wrapper.style.transition = 'border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.2s ease-in-out'; // Added background-color transition
        wrapper.style.marginRight = '0.5rem';
        wrapper.style.marginBottom = '0.5rem';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        const safeProfileId = profileValue.replace(/[^a-zA-Z0-9_-]/g, '');
        checkbox.id = `dpo-profile-cb-${safeProfileId}-extra`;
        checkbox.value = profileValue;
        checkbox.name = 'dpoOperatingProfileCheckbox_extra';
        checkbox.classList.add('dpo-profile-checkbox');
        // Apply styles from your CSS for #dpo-selectable-profiles-container-extra > div > input[type="checkbox"]
        checkbox.style.marginRight = '8px';
        checkbox.style.verticalAlign = 'middle';
        checkbox.style.height = '1em';
        checkbox.style.width = '1em';

        const label = document.createElement('label');
        label.htmlFor = checkbox.id; // Important for accessibility and default label click behavior
        label.textContent = profileValue;
        // Apply styles from your CSS for #dpo-selectable-profiles-container-extra > div > label
        label.style.fontSize = '14px';
        label.style.fontWeight = '700';
        label.style.fontFamily = "'NJFont Medium Web', -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif";
        label.style.textShadow = '0 0 1px rgba(255,255,255,0.5)';
        label.style.cursor = 'pointer'; // Label itself is also clickable
        label.style.lineHeight = '1.4';
        label.style.marginLeft = '4px'; // As per your CSS
        label.style.color = '#ecf0f1';

        // Event listener for the checkbox itself (handles logic and visual updates)
        checkbox.addEventListener('change', () => {
            const isChecked = checkbox.checked;
            wrapper.classList.toggle('selected', isChecked); // Use class for selected state if defined in CSS
            if (isChecked) {
                wrapper.style.borderColor = '#f1c40f';
                wrapper.style.boxShadow = '0 0 6px 1px #f1c40f';
                wrapper.style.backgroundColor = '#5D6D7E'; // Keep "hover" style when selected
            } else {
                wrapper.style.borderColor = 'transparent';
                wrapper.style.boxShadow = 'none';
                wrapper.style.backgroundColor = '#4A5568'; // Back to default
            }
            dpo_handleProfileSelectionChange_ExtraPage(); // Your existing logic handler
        });

        // *** NEW: Make the entire wrapper (tile) clickable ***
        wrapper.addEventListener('click', (e) => {
            // If the click was on the checkbox or the label, their native behavior
            // or the checkbox's change listener will handle it.
            // We only act if the click was on the wrapper's padding area.
            if (e.target === wrapper) { // Only toggle if the wrapper div itself was clicked
                checkbox.checked = !checkbox.checked;
                // Manually dispatch the 'change' event on the checkbox
                // to trigger its listener and update styles/logic.
                const changeEvent = new Event('change', { bubbles: true });
                checkbox.dispatchEvent(changeEvent);
            }
        });
        
        // Add hover effect to wrapper (tile)
        wrapper.addEventListener('mouseenter', () => {
            if (!checkbox.checked) { // Only change background if not selected
                 wrapper.style.backgroundColor = '#5D6D7E';
            }
        });
        wrapper.addEventListener('mouseleave', () => {
            if (!checkbox.checked) { // Revert if not selected
                wrapper.style.backgroundColor = '#4A5568';
            }
        });

        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        container.appendChild(wrapper);
    });
    dpo_updateDisabledProfileCheckboxes_ExtraPage(); // Call your existing function to update checkbox states
}

function dpo_updateDisabledProfileCheckboxes_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox'));
    const currentSelectedValues = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

    allCheckboxes.forEach(cb => {
        if (cb.checked) { // Always enable if checked
            cb.disabled = false;
            if (cb.parentElement) {
                cb.parentElement.style.opacity = 1;
                const labelForCb = cb.parentElement.querySelector('label');
                if (labelForCb) labelForCb.style.cursor = 'pointer';
            }
            return;
        }

        const potentialNextRawSelection = [...currentSelectedValues, cb.value];
        // Use DPO specific simulate and canonical functions
        const finalEffectiveSelectionAfterAutoGroup = dpo_simulateAutoGroup_ExtraPage(potentialNextRawSelection); 
        const finalEffectiveSortedString = dpo_getCanonicalProfileString_ExtraPage(finalEffectiveSelectionAfterAutoGroup);

        let canBeEnabled = false;
        // Uses DPO specific set
        if (DPO_VALID_PROFILE_COMBINATIONS_SET.has(finalEffectiveSortedString)) { 
            canBeEnabled = true;
        }

        if (!canBeEnabled) { // Check if it's a valid prefix for DPO combinations
            const prefixToTest = finalEffectiveSortedString + ","; // Important: check if adding another profile would make it valid
            for (const validCombo of DPO_VALID_PROFILE_COMBINATIONS_SET) { 
                if (validCombo.startsWith(prefixToTest)) {
                    canBeEnabled = true;
                    break;
                }
            }
        }

        // Special case: if nothing is currently selected, is this single profile (after its own potential auto-grouping) valid or a prefix?
        if (currentSelectedValues.length === 0) {
             const singleProfileItselfAfterPotentialGroup = dpo_simulateAutoGroup_ExtraPage([cb.value]);
             const singleCanonical = dpo_getCanonicalProfileString_ExtraPage(singleProfileItselfAfterPotentialGroup);
             if (DPO_VALID_PROFILE_COMBINATIONS_SET.has(singleCanonical)) {
                 canBeEnabled = true;
             } else {
                 const prefixToTestForSingle = singleCanonical + ",";
                 for (const validCombo of DPO_VALID_PROFILE_COMBINATIONS_SET) {
                     if (validCombo.startsWith(prefixToTestForSingle)) {
                         canBeEnabled = true;
                         break;
                     }
                 }
             }
        }

        cb.disabled = !canBeEnabled;
        if (cb.parentElement) {
            cb.parentElement.style.opacity = !canBeEnabled ? 0.5 : 1;
            const labelForCb = cb.parentElement.querySelector('label');
            if (labelForCb) {
                labelForCb.style.cursor = !canBeEnabled ? 'not-allowed' : 'pointer';
            }
        }
    });
}

function dpo_handleProfileSelectionChange_ExtraPage(event) {
    let currentSelectionsArray = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox:checked')).map(cb => cb.value);
    const allCheckboxes = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox'));

    // Handle auto-grouping (e.g., Mo-Fr implies individual days)
    // Assuming RSG_PROFILE_GROUPS_TO_MANAGE is suitable
    RSG_PROFILE_GROUPS_TO_MANAGE.forEach(group => {
        const groupCheckbox = allCheckboxes.find(cb => cb.value === group.groupProfile);
        if (!groupCheckbox) return; 
        currentSelectionsArray = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value); // Re-evaluate current selections
        const allIndividualsInGroupSelected = group.individuals.every(day => currentSelectionsArray.includes(day));

        if (allIndividualsInGroupSelected) {
            if (!groupCheckbox.checked) { // If individuals are all selected, but group isn't
                group.individuals.forEach(day => {
                    const cb = allCheckboxes.find(c => c.value === day);
                    if (cb && cb.checked) { cb.checked = false; }
                });
                groupCheckbox.checked = true;
            }
        } else if (groupCheckbox.checked) { // If group is selected, but not all individuals are
            // If the event target was one of the individuals and it's being unchecked, uncheck the group
            if (event && event.target && group.individuals.includes(event.target.value) && !event.target.checked) {
                 groupCheckbox.checked = false;
            }
            // Ensure individuals are unchecked if group is checked
             group.individuals.forEach(day => {
                const cb = allCheckboxes.find(c => c.value === day);
                if(cb && cb.checked) cb.checked = false;
            });
        }
    });

    // Re-get the selections after auto-grouping
    currentSelectionsArray = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox:checked')).map(cb => cb.value);
    
    // Sort for consistent display and storage
    currentSelectionsArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a); // Make sure this helper exists or adapt from RSG
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) return orderA - orderB;
        return a.localeCompare(b);
    });

    const finalSelectedProfilesString = currentSelectionsArray.join(', ');
    const displayElement = document.getElementById('dpo-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }

    dpo_updateDisabledProfileCheckboxes_ExtraPage();
}

function dpo_getSelectedOpProfilesString_ExtraPage() {
    const selectedProfiles = [];
    document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox:checked').forEach(checkbox => {
        selectedProfiles.push(checkbox.value);
    });
    // Sorts alphabetically for consistent storage, e.g., ["Fr", "MF", "Sa"] -> "Fr,MF,Sa"
    selectedProfiles.sort((a,b) => a.localeCompare(b)); 
    
    return selectedProfiles.join(', '); // MODIFIED: Joins with comma AND space
}

function dpo_setCheckedProfiles_ExtraPage(profileString) {
    const profilesToSelect = profileString ? profileString.split(',').map(p => p.trim()).filter(Boolean) : [];
    const allCheckboxes = document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox');
    allCheckboxes.forEach(checkbox => {
        checkbox.checked = profilesToSelect.includes(checkbox.value);
    });
    // After setting, trigger the logic that handles display and disabled states
    dpo_handleProfileSelectionChange_ExtraPage(null); // Pass null as no specific event triggered this
}

function dpo_clearProfileSelections_ExtraPage() {
    const allCheckboxes = document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox');
    allCheckboxes.forEach(cb => cb.checked = false);
    dpo_handleProfileSelectionChange_ExtraPage(null); // Update display and disabled states
}

async function dpo_applyOverrideToRoutes_ExtraPage() {
            if (!currentUser_extra || !overrideDateInput_el_extra || !dpoStatusMessage_el_extra || !window.firebaseOMSI) { 
                if (dpoStatusMessage_el_extra) {
                    dpoStatusMessage_el_extra.textContent = "Error: System not ready or not logged in."; 
                    dpoStatusMessage_el_extra.style.color="#e74c3c";
                }
                return; 
            }

            const selectedDate = overrideDateInput_el_extra.value;
            const profilesToApply = dpo_getSelectedOpProfilesString_ExtraPage();
            const routesToApplyTo = dpo_selectedRoutes_extra;

            if (!selectedDate) { 
                dpoStatusMessage_el_extra.textContent = "Please select a date."; 
                dpoStatusMessage_el_extra.style.color="#e74c3c"; 
                return; 
            }
            if (!profilesToApply) { 
                dpoStatusMessage_el_extra.textContent = "Please select an operating profile(s) using the checkboxes."; 
                dpoStatusMessage_el_extra.style.color="#e74c3c"; 
                return; 
            }
            if (routesToApplyTo.length === 0) {
                dpoStatusMessage_el_extra.textContent = "Please select at least one route to apply the profile to.";
                dpoStatusMessage_el_extra.style.color="#f1c40f";
                return;
            }
            
            const dateObj = new Date(selectedDate + "T00:00:00");
            if (isNaN(dateObj.getTime())) {
                dpoStatusMessage_el_extra.textContent = "Invalid date selected.";
                dpoStatusMessage_el_extra.style.color="#e74c3c";
                return;
            }

            let dateOverrides = operationalOverrides_data[selectedDate] || {};
            let changesMade = false;

            routesToApplyTo.forEach(routeName => {
                if (dateOverrides[routeName] !== profilesToApply) {
                    dateOverrides[routeName] = profilesToApply;
                    changesMade = true;
                }
            });

            if (!changesMade) {
                dpoStatusMessage_el_extra.textContent = "No changes needed for selected routes and profile. Override not applied.";
                dpoStatusMessage_el_extra.style.color="#7f8c8d";
                return;
            }

            if (!confirm(`Are you sure you want to apply "${profilesToApply}" profile(s) to Route(s): ${routesToApplyTo.join(', ')} for ${formatDateToDDMonthYYYY_ExtraPage(selectedDate)}?`)) {
                dpoStatusMessage_el_extra.textContent = "Override application cancelled by user.";
                dpoStatusMessage_el_extra.style.color="";
                return;
            }

            dpoStatusMessage_el_extra.textContent = `Applying override to selected routes...`;
            dpoStatusMessage_el_extra.style.color="#f1c40f";

            const { database, dbSet, dbRef } = window.firebaseOMSI; 
            try {
                await dbSet(dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${selectedDate}`), dateOverrides);
                
                operationalOverrides_data[selectedDate] = dateOverrides;

                dpoStatusMessage_el_extra.textContent = `Successfully applied profile(s) to ${routesToApplyTo.length} route(s) for ${formatDateToDDMonthYYYY_ExtraPage(selectedDate)}.`;
                dpoStatusMessage_el_extra.style.color="#2ecc71";
                
                updateSelectedDateInfo_ExtraPage();
                loadAndDisplayOverrides_ExtraPage();
                dpo_clearRouteSelections_ExtraPage();
                dpo_clearProfileSelections_ExtraPage();
                updateCurrentProfileDisplay_ExtraPage();

            } catch (error) {
                console.error("DPO Apply: Error applying override:", error); 
                dpoStatusMessage_el_extra.textContent = "Error applying override: " + error.message; 
                dpoStatusMessage_el_extra.style.color="#e74c3c";
            } 
        }

// --- END: Day Profile Override (DPO) Checkbox Logic ---

async function handleEditStopFromMasterList_ExtraPage(stopID, currentName, currentDirection) {
    if (!currentUser_extra) {
        alert("Please log in to edit stop details.");
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "Not logged in.";
        return;
    }

    const newStopNamePrompt = prompt(`Editing Stop: ${stopID}\nEnter new Stop Name (current: "${currentName || ''}"):`, currentName || '');
    if (newStopNamePrompt === null) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `Edit cancelled for stop ${stopID}.`;
        return;
    }

    const newDirectionPrompt = prompt(`Editing Stop: ${stopID}\nEnter new "Towards" text (current: "${currentDirection || ''}"):`, currentDirection || '');
    if (newDirectionPrompt === null) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `Edit cancelled for stop ${stopID}.`;
        return;
    }

    const trimmedNewStopName = newStopNamePrompt.trim();
    const trimmedNewDirection = newDirectionPrompt.trim();
    let definitionChanged = false;
    const stopIDUpper = stopID.toUpperCase();

    // 1. Update the master definition in allDefinedStops_data (local cache)
    if (allDefinedStops_data && typeof allDefinedStops_data === 'object' && allDefinedStops_data[stopIDUpper]) {
        if (allDefinedStops_data[stopIDUpper].stopName !== trimmedNewStopName) {
            allDefinedStops_data[stopIDUpper].stopName = trimmedNewStopName;
            definitionChanged = true;
        }
        if (allDefinedStops_data[stopIDUpper].direction !== trimmedNewDirection) {
            allDefinedStops_data[stopIDUpper].direction = trimmedNewDirection;
            definitionChanged = true;
        }
    } else {
        console.error(`Stop definition for ${stopID} not found in allDefinedStops_data during edit. This should not happen if list is correctly populated.`);
        if (masterStopListStatus_el_extra) {
            masterStopListStatus_el_extra.textContent = `Error: Master definition for stop ${stopID} not found. Edit failed.`;
            masterStopListStatus_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    // 2. Update occurrences in currentWorkingSchedule_extra (local cache for live schedules)
    let updatedScheduleEntryCount = 0;
    let scheduleEntriesModified = false;
    if (Array.isArray(currentWorkingSchedule_extra)) {
        currentWorkingSchedule_extra.forEach(entry => {
            if (entry.stopID && entry.stopID.toUpperCase() === stopIDUpper) {
                let entryModifiedThisIteration = false;
                if (entry.stopName !== trimmedNewStopName) {
                    entry.stopName = trimmedNewStopName;
                    entryModifiedThisIteration = true;
                }
                if (entry.direction !== trimmedNewDirection) {
                    entry.direction = trimmedNewDirection;
                    entryModifiedThisIteration = true;
                }
                if (entryModifiedThisIteration) {
                    updatedScheduleEntryCount++;
                    scheduleEntriesModified = true;
                }
            }
        });
    }

    if (!definitionChanged && !scheduleEntriesModified) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `No changes made to Stop ID "${stopID}".`;
        return;
    }

    if (masterStopListStatus_el_extra) {
        masterStopListStatus_el_extra.textContent = `Updating entries for stop ${stopID}...`;
        masterStopListStatus_el_extra.style.color = "#f1c40f";
    }

    try {
        // Save the updated master definition list to Firebase
        if (definitionChanged && typeof saveAllDefinedStopsToFirebase_ExtraPage === 'function') {
            await saveAllDefinedStopsToFirebase_ExtraPage();
        }

        // Rebuild and save the live schedule if its entries or related definitions changed
        if (scheduleEntriesModified || definitionChanged) {
            if (typeof rebuildAndSaveEntireScheduleToFirebase_ExtraPage === 'function') {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
            } else {
                console.error("rebuildAndSaveEntireScheduleToFirebase_ExtraPage is not defined!");
                throw new Error("Cannot save schedule, critical function missing.");
            }
        }
        
        if (masterStopListStatus_el_extra) {
            let message = `Stop ID "${stopID}" updated.`;
            if (definitionChanged) message += ` Master definition changed.`;
            if (scheduleEntriesModified) message += ` ${updatedScheduleEntryCount} live schedule entries affected.`;
            masterStopListStatus_el_extra.textContent = message;
            masterStopListStatus_el_extra.style.color = "#2ecc71";
        }
        
        if (typeof renderUIDependentElements_ExtraPage === 'function') {
            renderUIDependentElements_ExtraPage(); // Refresh UI
        }

    } catch (error) {
        console.error(`Error saving Stop ID ${stopID} changes to Firebase:`, error);
        if (masterStopListStatus_el_extra) {
            masterStopListStatus_el_extra.textContent = `Error saving changes for stop ${stopID}: ${error.message}`;
            masterStopListStatus_el_extra.style.color = "#e74c3c";
        }
        // Consider reloading data on critical error to resync
        if (typeof loadInitialData_ExtraPage === 'function') {
             alert("A critical error occurred while saving stop edits. Attempting to reload all data. Please verify changes.");
             await loadInitialData_ExtraPage();
        }
    }
}

async function handleApplyScheduledRouteBatch_ExtraPage(tasksInBatch) {
    if (!currentUser_extra) {
        alert("Please log in to apply batch updates.");
        return;
    }
    if (!tasksInBatch || tasksInBatch.length === 0) {
        alert("No tasks provided for batch application.");
        return;
    }

    const representativeTask = tasksInBatch[0]; // Assuming all tasks in batch are for the same route & time
    const targetRouteName = representativeTask.routeName.toUpperCase();
    const goLiveDateTimeForDisplay = new Date(representativeTask.goLiveDateTime).toLocaleString();

    let allNewEntriesForRoute = [];
    let involvedProfiles = new Set();
    let involvedDestinations = new Set();
    let taskKeysInBatch = []; // To update status of all processed tasks

    tasksInBatch.forEach(task => {
        // Ensure we only aggregate 'applySchedule' tasks for the correct route
        if ((task.taskTypeDisplay === 'applySchedule' || task.taskType === 'applySchedule') && task.routeName.toUpperCase() === targetRouteName) {
            if (task.scheduledEntries && task.scheduledEntries.length > 0) {
                // Deep copy entries to avoid issues if the same task object is somehow reused
                allNewEntriesForRoute.push(...JSON.parse(JSON.stringify(task.scheduledEntries)));
                involvedProfiles.add(task.operatingProfile);
                involvedDestinations.add(task.destinationName);
            }
            taskKeysInBatch.push(task.key);
        }
    });

    if (allNewEntriesForRoute.length === 0) {
        alert(`No actual schedule entries found within the selected batch for Route "${targetRouteName}". Cannot apply.`);
        return;
    }

    const profileList = Array.from(involvedProfiles).join(', ') || "N/A";
    const destList = Array.from(involvedDestinations).join(', ') || "N/A";

    const confirmMessage = `Apply BATCH update for Route: ${targetRouteName}\n` +
                         `Go-Live: ${goLiveDateTimeForDisplay}\n\n` +
                         `This batch includes ${tasksInBatch.length} update(s) which will define the following for this route:\n` +
                         `Operating Profile(s): ${profileList}\n` +
                         `Destination(s): ${destList}\n\n` +
                         `WARNING: This will DELETE ALL existing schedules for the ENTIRE Route "${targetRouteName}" (across all its current profiles and destinations).\n` +
                         `Then, ${allNewEntriesForRoute.length} new entries from this batch will be added, forming the new complete schedule for this route.\n\n` +
                         `Proceed with wiping the whole route and applying this batch?`;

    if (!confirm(confirmMessage)) {
        alert("Batch application cancelled by user.");
        return;
    }

    if (rsgStatusMessage_el_extra) { // Use a general status message element if available
        rsgStatusMessage_el_extra.textContent = `Processing batch for Route ${targetRouteName}... This may take a moment.`;
        rsgStatusMessage_el_extra.style.color = "#3498db";
    }

    const { database, dbUpdate, dbRef } = window.firebaseOMSI;
    let removedCount = 0;

    // 1. Filter out ALL existing entries for this targetRouteName from the local working schedule
    currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
        const matchesRouteOnly = entry.lineName && entry.lineName.toUpperCase() === targetRouteName;
        if (matchesRouteOnly) {
            removedCount++;
            return false;
        }
        return true;
    });
    console.log(`Batch Apply: Removed <span class="math-inline">\{removedCount\} existing entries for Route "</span>{targetRouteName}".`);

    // 2. Add all new entries from the batch, ensuring unique internalIds
    const entriesToAddWithUniqueIds = allNewEntriesForRoute.map((e, idx) => ({
        ...e,
        internalId: e.internalId || `<span class="math-inline">\{e\.stopID\}\_</span>{e.lineName}_${(e.scheduledTime||"0000").replace(':','')}_batchApply_${Date.now()}_${idx}`
    }));
    currentWorkingSchedule_extra.push(...entriesToAddWithUniqueIds);
    console.log(`Batch Apply: Added <span class="math-inline">\{entriesToAddWithUniqueIds\.length\} new entries for Route "</span>{targetRouteName}".`);

    try {
        // 3. Rebuild and save the entire schedule to Firebase.
        await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
        console.log(`Batch Apply: Main schedule rebuilt and saved to Firebase for Route "${targetRouteName}".`);

        // 4. Update the status of all processed scheduled items in Firebase
        const updatesToFirebaseStatus = {};
        const appliedAtTimestamp = new Date().toISOString();
        const appliedByEmail = currentUser_extra ? currentUser_extra.email : "system (batch)";

        taskKeysInBatch.forEach(taskKey => {
            // This assumes all tasks in the batch were 'applySchedule' tasks from FB_PATH_SCHEDULED_ROUTE_UPDATES
            updatesToFirebaseStatus[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/status`] = 'applied (batch)';
            updatesToFirebaseStatus[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/appliedAt`] = appliedAtTimestamp;
            updatesToFirebaseStatus[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/appliedBy`] = appliedByEmail;
        });

        await dbUpdate(dbRef(database), updatesToFirebaseStatus);
        console.log("DEBUG: Task keys being processed:", JSON.stringify(taskKeysInBatch));
console.log("DEBUG: Data being sent to Firebase for status update:", JSON.stringify(updatesToFirebaseStatus));

        // Refresh UI
        loadAndDisplayScheduledUpdates_ExtraPage(); 
        renderUIDependentElements_ExtraPage(); 

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Batch update for Route ${targetRouteName} applied successfully. Live schedule updated.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
            setTimeout(() => { if (rsgStatusMessage_el_extra.textContent && rsgStatusMessage_el_extra.textContent.includes(`Batch update for Route ${targetRouteName}`)) rsgStatusMessage_el_extra.textContent = ''; }, 7000);
        } else {
            alert(`Batch update for Route ${targetRouteName} applied successfully. Live schedule updated.`);
        }

    } catch (error) {
        console.error("Error applying scheduled batch update:", error);
        alert(`Error applying batch update for Route "${targetRouteName}": ${error.message}. The live schedule may be in an inconsistent state. Review carefully.`);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error applying batch for Route ${targetRouteName}: ${error.message}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // Attempt to mark tasks as 'error' in Firebase
        const errorUpdates = {};
        taskKeysInBatch.forEach(taskKey => {
            errorUpdates[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/status`] = 'error';
            errorUpdates[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/lastError`] = `Batch Apply Error: ${error.message}`;
        });
        await dbUpdate(dbRef(database), errorUpdates).catch(err => console.error("Failed to mark batch tasks as error:", err));
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh to show error state
    }
}

function checkAndDisplayDueUpdatesNotification_ExtraPage() {
    const banner = document.getElementById('global-notification-banner');
    if (!banner || !currentUser_extra) { // Only show if logged in and banner element exists
        if (banner) banner.style.display = 'none'; // Ensure banner is hidden if no user
        return;
    }

    let dueTasksDetails = []; // To store info about due tasks for the banner message
    const now = new Date().getTime();

    console.log("Banner Check: Function called at", new Date().toLocaleString());
    console.log("Banner Check: Current epoch time (now):", now);

    // Check 'applySchedule' tasks (typically from RSG - timetable updates)
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.values(scheduledRouteUpdates_extra).forEach(task => {
            if (task && task.status === 'pending' && task.goLiveDateTime) {
                const goLiveTimeEpoch = new Date(task.goLiveDateTime).getTime();
                // console.log(`Banner Check (Update Task ${task.key || 'N/A'}): Status: ${task.status}, GoLiveISO: ${task.goLiveDateTime}, GoLiveEpoch: ${goLiveTimeEpoch}, Due: ${goLiveTimeEpoch <= now}`);
                if (goLiveTimeEpoch <= now) {
                    dueTasksDetails.push({
                        type: 'Timetable Update',
                        name: `Route ${task.routeName || 'N/A'} (for P: ${task.operatingProfile || 'N/A'} to D: ${task.destinationName || 'N/A'})`,
                        key: task.key,
                        goLive: new Date(task.goLiveDateTime).toLocaleString()
                    });
                }
            }
        });
    }

    // Check 'deleteEntireRoute' tasks
    if (typeof scheduledRouteDeletions_extra === 'object' && scheduledRouteDeletions_extra !== null) {
        Object.values(scheduledRouteDeletions_extra).forEach(task => {
            if (task && task.status === 'pending' && task.goLiveDateTime) {
                const goLiveTimeEpoch = new Date(task.goLiveDateTime).getTime();
                // console.log(`Banner Check (Delete Task ${task.key || 'N/A'}): Status: ${task.status}, GoLiveISO: ${task.goLiveDateTime}, GoLiveEpoch: ${goLiveTimeEpoch}, Due: ${goLiveTimeEpoch <= now}`);
                if (goLiveTimeEpoch <= now) {
                    dueTasksDetails.push({
                        type: 'Route Deletion',
                        name: `Route ${task.routeName || 'N/A'}`,
                        key: task.key,
                        goLive: new Date(task.goLiveDateTime).toLocaleString()
                    });
                }
            }
        });
    }

    console.log("Banner Check: Total dueTasksDetails found:", dueTasksDetails.length, JSON.parse(JSON.stringify(dueTasksDetails)));

    if (dueTasksDetails.length > 0) {
        // Sort by go-live time, earliest first, for display consistency if you show details
        dueTasksDetails.sort((a,b) => new Date(a.goLive).getTime() - new Date(b.goLive).getTime());
        
        let message = `${dueTasksDetails.length} scheduled task(s) are now due or overdue.`;
        // Example: Show details of the first due task in the console for easier debugging
        if (dueTasksDetails[0]) {
           console.log("Banner Check: First due task details:", dueTasksDetails[0]);
        }
        
        banner.innerHTML = `${message} 
            <button id="view-due-tasks-button" class="button small-action neutral" style="margin-left:15px; background-color: #ecf0f1; color: #2c3e50; padding: 0.3em 0.6em; font-size: 0.85em;">
                View & Manage Tasks
            </button>`;
        banner.style.backgroundColor = '#27ae60'; // Green for due tasks
        banner.style.display = 'block';

        const viewButton = document.getElementById('view-due-tasks-button');
        if (viewButton) {
            // Ensure only one listener is attached, or handle re-attachment carefully if innerHTML is used often
            if (!viewButton.dataset.listenerAttached) {
                viewButton.addEventListener('click', () => {
                    showExtraPageSection('scheduled-route-updates-section_extra'); // Navigate to the tasks page
                    // You might choose to hide the banner after click or let it persist
                    // banner.style.display = 'none'; 
                });
                viewButton.dataset.listenerAttached = 'true';
            }
        }
    } else {
        banner.style.display = 'none';
    }
}

// Function to handle confirming and saving the scheduled deletion
async function srd_confirmAndScheduleDeletion_ExtraPage() {
    if (!currentUser_extra || !window.firebaseOMSI || !window.firebaseOMSI.database || !window.firebaseOMSI.auth) { // Added auth check here
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Not logged in or Firebase (database/auth) not available.";
            srdStatusMessage_el_extra.style.color = "#e74c3c";
        }
        console.error("SRD Save: currentUser_extra, window.firebaseOMSI, or its database/auth components are missing.");
        return;
    }

    const routeName = srdRouteNameInput_el_extra.value.trim() || srdRouteNameSelect_el_extra.value;
    const goLiveDateTimeValue = srdGoLiveDateTimeInput_el_extra.value;

    if (!routeName) {
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Please select or enter a route name to schedule for deletion.";
            srdStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    if (!goLiveDateTimeValue) {
        // ... (error handling for goLiveDateTimeValue) ...
        return;
    }

    const goLiveDateObj = new Date(goLiveDateTimeValue);
    if (isNaN(goLiveDateObj.getTime())) {
        // ... (error handling for invalid date) ...
        return;
    }

    if (goLiveDateObj <= new Date()) {
        // ... (error handling for past date) ...
        return;
    }

    // Destructure auth here to ensure it's in scope for this function
    const { database, dbSet, dbRef, auth } = window.firebaseOMSI;

    // Crucial check for UID
    console.log("SRD Save: Current User from auth object:", auth.currentUser ? auth.currentUser.uid : "No user from auth object");
    console.log("SRD Save: Current User from currentUser_extra variable:", currentUser_extra ? currentUser_extra.uid : "No user from currentUser_extra");
    console.log("SRD Save: Expected Admin UID:", 'PBVTn1GvcAfIZWNLzuP1brUtJDu1');

    // Use the UID from the auth object directly for the most reliable check
    if (!auth.currentUser || auth.currentUser.uid !== 'PBVTn1GvcAfIZWNLzuP1brUtJDu1') {
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Permission Denied: You are not authorized to perform this action.";
            srdStatusMessage_el_extra.style.color = "#e74c3c";
        }
        console.error("SRD Save: Permission Denied. UID mismatch or no authenticated user. Actual UID:", auth.currentUser ? auth.currentUser.uid : "null");
        return; // Stop if not the admin user
    }


    if (!confirm(`Are you sure you want to schedule the DELETION of all data for route "${routeName}" to occur on ${goLiveDateObj.toLocaleString()}? This action, once processed, cannot be easily undone.`)) {
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Scheduled deletion cancelled by user.";
            srdStatusMessage_el_extra.style.color = "";
        }
        return;
    }

    const deletionTask = {
        taskType: "deleteEntireRoute",
        routeName: routeName,
        goLiveDateTime: goLiveDateObj.toISOString(),
        scheduledAt: new Date().toISOString(),
        status: "pending",
        userEmail: currentUser_extra.email // currentUser_extra should be the admin user here
    };

    if (srdStatusMessage_el_extra) {
        srdStatusMessage_el_extra.textContent = `Scheduling deletion for route "${routeName}"...`;
        srdStatusMessage_el_extra.style.color = "#3498db";
    }

    try {
        const deletionTaskKey = `delSched_${Date.now()}_${sanitizeFirebaseKey(routeName)}`;
        await dbSet(dbRef(database, `${FB_PATH_SCHEDULED_DELETIONS}/${deletionTaskKey}`), deletionTask);

        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = `Deletion for route "${routeName}" successfully scheduled for ${goLiveDateObj.toLocaleString()}. It will appear in the 'Scheduled Tasks' list.`;
            srdStatusMessage_el_extra.style.color = "#2ecc71";
        }
        if(srdRouteNameInput_el_extra) srdRouteNameInput_el_extra.value = '';
        if(srdRouteNameSelect_el_extra) srdRouteNameSelect_el_extra.value = '';
        if(srdGoLiveDateTimeInput_el_extra) srdGoLiveDateTimeInput_el_extra.value = '';

    } catch (error) {
        console.error("Error scheduling route deletion to Firebase:", error); // This will show the permission denied
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Error scheduling deletion: " + error.message;
            srdStatusMessage_el_extra.style.color = "#e74c3c";
        }
    }
}

function isStandStop_ExtraPage(stopID) {
    if (!stopID || typeof stopID !== 'string') {
        return false;
    }
    const upperCaseID = stopID.toUpperCase();
    // You can customize these prefixes based on your actual stand ID patterns
    return upperCaseID.startsWith('BP') || upperCaseID.startsWith('STAND') || upperCaseID.includes('STN'); // Added 'STN' as an example
}

        function getYYYYMMDD_ExtraPage(dateSource) { const d = dateSource ? new Date(dateSource) : new Date(); const year = d.getFullYear(); const month = String(d.getMonth() + 1).padStart(2, '0'); const day = String(d.getDate()).padStart(2, '0'); return `${year}-${month}-${day}`; }
        function formatDateToDDMonthYYYY_ExtraPage(dateStringYYYYMMDD) { if (!dateStringYYYYMMDD || !/^\d{4}-\d{2}-\d{2}$/.test(dateStringYYYYMMDD)) return "Invalid Date"; const [year, month, day] = dateStringYYYYMMDD.split('-'); const dateObj = new Date(year, month - 1, day); const options = { day: '2-digit', month: 'long', year: 'numeric' }; return dateObj.toLocaleDateString('en-GB', options); }
        function getUniqueStopsFromSchedule_ExtraPage() { if (!currentWorkingSchedule_extra || currentWorkingSchedule_extra.length === 0) return []; const stopsMap = new Map(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID && !stopsMap.has(entry.stopID.toUpperCase())) { stopsMap.set(entry.stopID.toUpperCase(), { stopID: entry.stopID, stopName: entry.stopName || "Unknown Name", direction: entry.direction || "No Direction" }); } }); return Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase())); }
        function parseLineName_ExtraPage(lineNameStr) { const name = String(lineNameStr || "").toUpperCase().trim(); const numericPrefixRegex = new RegExp(/^(\d+)([A-Z]*)$/); const alphaNumericRegex = new RegExp(/^([A-Z]+)(\d+)?([A-Z]*)$/); const numericPrefixMatch = name.match(numericPrefixRegex); if (numericPrefixMatch) return { type: 'numeric', number: parseInt(numericPrefixMatch[1], 10), suffix: numericPrefixMatch[2] || '', original: name }; const alphaNumericMatch = name.match(alphaNumericRegex); if (alphaNumericMatch) return { type: 'alpha', prefix: alphaNumericMatch[1], number: alphaNumericMatch[2] ? parseInt(alphaNumericMatch[2], 10) : null, suffix: alphaNumericMatch[3] || '', original: name }; return { type: 'other', original: name }; }
        
	function compareLineNames_ExtraPage(lineAStr, lineBStr) { const parsedA = parseLineName_ExtraPage(lineAStr); const parsedB = parseLineName_ExtraPage(lineBStr); if (parsedA.type === 'numeric' && parsedB.type === 'alpha') return -1; if (parsedA.type === 'alpha' && parsedB.type === 'numeric') return 1; if (parsedA.type === 'numeric' && parsedB.type === 'numeric') { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type === 'alpha' && parsedB.type === 'alpha') { const prefixCompare = parsedA.prefix.localeCompare(parsedB.prefix); if (prefixCompare !== 0) return prefixCompare; if (parsedA.number === null && parsedB.number !== null) return -1; if (parsedA.number !== null && parsedB.number === null) return 1; if (parsedA.number !== null && parsedB.number !== null) { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; } return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type !== 'other' && parsedB.type === 'other') return -1; if (parsedA.type === 'other' && parsedB.type !== 'other') return 1; return (parsedA.original || "").localeCompare(parsedB.original || ""); }
        const DEFAULT_ROUTE_COLOUR_TOOLS_extra = "#73809C"; // Default fallback color for routes
        const NIGHT_BUS_BLUE_COLOR_extra = "#4CDBE6"; // Explicit color for N-Routes and 24hr services if no custom override
        const initialRouteColourMapForTools_extra = {}; // This can remain empty if all custom colors are Firebase-driven

        function getRouteTileColour_ExtraPage(lineName, stopID = null) {
    const upName = String(lineName || "").toUpperCase();
    let color;

    // Check stop-specific colors
    if (stopID && stopSpecificRouteColours_extra[stopID.toUpperCase()] &&
        typeof stopSpecificRouteColours_extra[stopID.toUpperCase()][upName] === 'string' &&
        stopSpecificRouteColours_extra[stopID.toUpperCase()][upName].startsWith('#')) {
        color = stopSpecificRouteColours_extra[stopID.toUpperCase()][upName];
    }
    // Check global custom colors if not found above
    else if (globalCustomRouteColours_extra[upName] &&
               typeof globalCustomRouteColours_extra[upName] === 'string' &&
               globalCustomRouteColours_extra[upName].startsWith('#')) {
        color = globalCustomRouteColours_extra[upName];
    }
    // Check initial (hardcoded) map - though yours is empty
    else if (initialRouteColourMapForTools_extra[upName] &&
               typeof initialRouteColourMapForTools_extra[upName] === 'string' &&
               initialRouteColourMapForTools_extra[upName].startsWith('#')) {
        color = initialRouteColourMapForTools_extra[upName];
    }
    // Check specific prefixes like 'N' or 'SL'
    else if (upName.startsWith("N")) {
        color = (globalCustomRouteColours_extra["NIGHT_DEFAULT"] && typeof globalCustomRouteColours_extra["NIGHT_DEFAULT"] === 'string' && globalCustomRouteColours_extra["NIGHT_DEFAULT"].startsWith('#'))
                ? globalCustomRouteColours_extra["NIGHT_DEFAULT"]
                : NIGHT_BUS_BLUE_COLOR_extra; // NIGHT_BUS_BLUE_COLOR_extra should be a valid hex
    } else if (upName.startsWith("SL")) {
        color = (globalCustomRouteColours_extra["SL_DEFAULT"] && typeof globalCustomRouteColours_extra["SL_DEFAULT"] === 'string' && globalCustomRouteColours_extra["SL_DEFAULT"].startsWith('#'))
                ? globalCustomRouteColours_extra["SL_DEFAULT"]
                : "#D32F2F"; // Ensure this default is valid
    }

    // Validate the determined color and provide a final fallback
    if (typeof color === 'string' && color.startsWith('#') && (color.length === 7 || color.length === 4)) {
        return color.toUpperCase();
    }

    // Fallback if no valid color string found from any source
    // console.warn(`getRouteTileColour_ExtraPage: No valid color found for lineName "<span class="math-inline">\{lineName\}", stopID "</span>{stopID || 'N/A'}". Defaulting to ${DEFAULT_ROUTE_COLOUR_TOOLS_extra}.`);
    return DEFAULT_ROUTE_COLOUR_TOOLS_extra.toUpperCase(); // Ensure DEFAULT_ROUTE_COLOUR_TOOLS_extra is valid
}

        function isSchoolHolidayPeriod_ExtraPage(dateObjectForCell) { // dateObjectForCell is local time, e.g., new Date(year, month, day)
    if (!schoolHolidayDateRanges_extra || schoolHolidayDateRanges_extra.length === 0) {
        return false;
    }

    // Normalize the calendar cell's date to midnight local time to represent the whole day
    const cellDateNormalized = new Date(dateObjectForCell.getFullYear(), dateObjectForCell.getMonth(), dateObjectForCell.getDate());
    const cellTime = cellDateNormalized.getTime();

    for (const range of schoolHolidayDateRanges_extra) {
        try {
            // Parse start date string as local midnight
            const startDateParts = range.start.split('-'); // "YYYY-MM-DD"
            const rangeStartDate = new Date(
                parseInt(startDateParts[0]),
                parseInt(startDateParts[1]) - 1, // JS months are 0-11
                parseInt(startDateParts[2])
            );
            const rangeStartTime = rangeStartDate.getTime();

            // Parse end date string as local midnight
            const endDateParts = range.end.split('-'); // "YYYY-MM-DD"
            const rangeEndDate = new Date(
                parseInt(endDateParts[0]),
                parseInt(endDateParts[1]) - 1, // JS months are 0-11
                parseInt(endDateParts[2])
            );
            const rangeEndTime = rangeEndDate.getTime();

            // Check if the cell's date is within the inclusive start and end dates
            if (cellTime >= rangeStartTime && cellTime <= rangeEndTime) {
                return true;
            }
        } catch (e) {
            console.error("Invalid date encountered in schoolHolidayDateRanges_extra during check:", range, e);
        }
    }
    return false;
}
      
  function getOperatingCodesForDate_ExtraPage(dateObject, routeName = null) {
        const n = dateObject;
        const dOW = n.getDay();
        const todayDateString = `${n.getFullYear()}-${String(n.getMonth() + 1).padStart(2, '0')}-${String(n.getDate()).padStart(2, '0')}`;
        let potentialDateCodes = new Set();
        let isBankHolidayToday = false;

        if (routeName && operationalOverrides_data && operationalOverrides_data[todayDateString] && operationalOverrides_data[todayDateString][routeName]) {
            const routeOverrideProfile = operationalOverrides_data[todayDateString][routeName];
            return routeOverrideProfile.split(',').map(p => p.trim()).filter(Boolean);
        }

        if (ukBankHolidaysData_extra && ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(todayDateString)) {
            const holidayTitle = ukBankHolidaysData_extra.titles[todayDateString] || "";
            isBankHolidayToday = true;
            if (holidayTitle.toLowerCase().includes("good friday")) {
                potentialDateCodes.add("Sa");
            } else {
                potentialDateCodes.add("Su");
            }
        }

        if (!isBankHolidayToday) {
            const isSchHol = isSchoolHolidayPeriod_ExtraPage(n);
            const schoolSuffix = isSchHol ? "NSD" : "Sch";
            let dayCode = "";
            switch (dOW) {
                case 0: dayCode = "Su"; break;
                case 1: dayCode = "Mo"; break;
                case 2: dayCode = "Tu"; break;
                case 3: dayCode = "We"; break;
                case 4: dayCode = "Th"; break;
                case 5: dayCode = "Fr"; break;
                case 6: dayCode = "Sa"; break;
            }
            potentialDateCodes.add(dayCode);
            if (dOW >= 1 && dOW <= 5) {
                potentialDateCodes.add(dayCode + schoolSuffix);
                potentialDateCodes.add("MF" + schoolSuffix);
                potentialDateCodes.add("MF");
            }
        }
        
        const finalFilteredCodes = Array.from(potentialDateCodes).filter(code => 
            typeof RSG_OPERATING_PROFILES_LIST !== 'undefined' && RSG_OPERATING_PROFILES_LIST.includes(code)
        );
        
        return finalFilteredCodes;
    }

async function updateCurrentProfileDisplay_ExtraPage() {
            const now = new Date();
            const todayDateString = getYYYYMMDD_ExtraPage(now);
            let displayHtml = "";
            let displayLabel = "Today's Operating Profile:";

            // Get the general auto-determined profiles for today (without considering specific routes yet)
            const autoDeterminedGeneralProfiles = getOperatingCodesForDate_ExtraPage(now);
            const autoDeterminedGeneralProfileString = autoDeterminedGeneralProfiles.length > 0 ? autoDeterminedGeneralProfiles.join(', ') : 'N/A';

            // Check for bank holiday title for display label
            let isBankHolidayToday = false;
            if (ukBankHolidaysData_extra && ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(todayDateString)) {
                isBankHolidayToday = true;
            }

            if (isBankHolidayToday) {
                const holidayTitle = ukBankHolidaysData_extra.titles[todayDateString] || "Bank Holiday";
                displayLabel = `${toTitleCase_display(holidayTitle)}:`;
            } else {
                displayLabel = `Today's Operating Profile:`;
            }

            // Map to store {profileString: Set of routeNames} for all routes that are NOT following the general default
            const customProfileRoutes = new Map();
            let allRoutesWithSchedules = new Set(); // All routes that have schedule entries

            // Populate allRoutesWithSchedules from currentWorkingSchedule_extra
            currentWorkingSchedule_extra.forEach(entry => {
                if (entry.lineName) {
                    allRoutesWithSchedules.add(entry.lineName);
                }
            });

            // Iterate through each unique route to get its specific effective profile for today
            allRoutesWithSchedules.forEach(routeName => {
                // Get the effective profiles for this specific route on this specific date
                const effectiveProfilesForRoute = getOperatingCodesForDate_ExtraPage(now, routeName);
                const effectiveProfileString = effectiveProfilesForRoute.join(', ');

                // If this route's effective profile is different from the general default
                const routeSpecificOverrideInFirebase = operationalOverrides_data[todayDateString] && operationalOverrides_data[todayDateString][routeName] ? true : false;
                
                if (routeSpecificOverrideInFirebase || (effectiveProfileString !== autoDeterminedGeneralProfileString && effectiveProfileString !== 'N/A')) {
                    customProfileRoutes.set(effectiveProfileString, (customProfileRoutes.get(effectiveProfileString) || new Set()).add(routeName));
                }
            });

            // Determine display content
            if (customProfileRoutes.size > 0) {
                displayHtml = `${displayLabel}<br>`;
                let customRouteLines = [];

                // Sort custom profiles for consistent display order
                const sortedCustomProfileStrings = Array.from(customProfileRoutes.keys()).sort();

                sortedCustomProfileStrings.forEach(profileString => {
                    const routesForThisProfile = Array.from(customProfileRoutes.get(profileString)).sort(); // Sort routes alphabetically
                    customRouteLines.push(`${routesForThisProfile.join(', ')}: <strong style="color:#f1c40f;">${profileString}</strong>`);
                });

                // Removed `font-size:0.85em;` from this span
                displayHtml += `<span style="margin-left:1em;">${customRouteLines.join('<br><span style="margin-left:1em;">')}</span>`;

                // Add a final disclaimer about routes not explicitly listed if needed
                let totalCustomRoutesCount = 0;
                customProfileRoutes.forEach(routesSet => totalCustomRoutesCount += routesSet.size);

                if (allRoutesWithSchedules.size > totalCustomRoutesCount) {
                    // Removed `font-size:0.85em;` and `display:block; margin-top:0.7em;`
                    displayHtml += `<br><span style="margin-left:1em; opacity:0.8;">All Other Routes: ${autoDeterminedGeneralProfileString}</span>`;
                }
            } else {
                // Simple display if no custom profiles or all routes follow the general profile
                displayHtml = `${displayLabel} ${autoDeterminedGeneralProfileString}`;
            }

            if (currentProfileDisplayElement_el) {
                currentProfileDisplayElement_el.innerHTML = displayHtml;
            }
        }

        // In omsi_tools_extra.html, inside loadAndDisplayOverrides_ExtraPage
async function loadAndDisplayOverrides_ExtraPage() {
    const activeOverridesListElement = document.getElementById('activeOverridesList_extra');
    const overridesHeadingElement = document.getElementById('dpo-active-overrides-title'); 

    if (!activeOverridesListElement || !window.firebaseOMSI) {
        if(activeOverridesListElement) activeOverridesListElement.innerHTML = '<p>Error: System dependencies missing.</p>';
        return;
    }
    activeOverridesListElement.innerHTML = '<p>Loading all active overrides...</p>';
    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;

    try {
        const snapshot = await dbGet(dbChild(dbRef(database), FB_PATH_OPERATIONAL_OVERRIDES));
        let html = "";
        const today = new Date(); // Current date is Wednesday, June 4, 2025
        today.setHours(0, 0, 0, 0); 

        const currentYear = today.getFullYear(); // 2025
        
        // --- MODIFIED SECTION ---
        const fixedDaysAhead = 365; // Always show 365 days
        const targetYearForDisplay = currentYear + 1; // It will span into the next year if 365 days is used.
        // --- END MODIFIED SECTION ---

        if (overridesHeadingElement) {
            // Updated text: "All Active Overrides Within The Next 365 Days"
            overridesHeadingElement.textContent = `All Active Overrides Within The Next 365 Days`;
        }

        const allOverrides = snapshot.exists() ? snapshot.val() : {};
        const relevantOverrides = [];
        
        // Calculate the actual future cutoff date for filtering overrides based on 365 days from today
        const actualFutureCutoffDate = new Date(today);
        actualFutureCutoffDate.setDate(today.getDate() + fixedDaysAhead);


        for (const dateKey in allOverrides) {
            if (Object.hasOwnProperty.call(allOverrides, dateKey) && /^\d{4}-\d{2}-\d{2}$/.test(dateKey)) {
                const overrideDate = new Date(dateKey + "T00:00:00"); 
                
                // Filter overrides to only show those within the next fixedDaysAhead days from today
                if (overrideDate >= today && overrideDate <= actualFutureCutoffDate) { 
                    const routeOverridesForDate = allOverrides[dateKey];
                    if (routeOverridesForDate && typeof routeOverridesForDate === 'object' && Object.keys(routeOverridesForDate).length > 0) {
                        for (const routeName in routeOverridesForDate) {
                            if (Object.hasOwnProperty.call(routeOverridesForDate, routeName)) {
                                relevantOverrides.push({
                                    date: dateKey,
                                    routeName: routeName,
                                    profile: routeOverridesForDate[routeName]
                                });
                            }
                        }
                    }
                }
            }
        }
        
        relevantOverrides.sort((a,b) => {
            const dateCompare = a.date.localeCompare(b.date);
            if (dateCompare !== 0) return dateCompare;
            return compareLineNames_ExtraPage(a.routeName, b.routeName);
        });

        if (relevantOverrides.length > 0) {
            let groupedHtml = "<ul style='list-style-type: none; padding-left: 0;'>";
            let currentDate = null;
            relevantOverrides.forEach(ov => {
                if (ov.date !== currentDate) {
                    if (currentDate !== null) {
                        groupedHtml += "</div></li>";
                    }
                    currentDate = ov.date;
                    groupedHtml += `<li style="margin-top:0.75em; margin-bottom:0.25em;"><strong>${formatDateToDDMonthYYYY_ExtraPage(ov.date)}:</strong>
                                    <div style="margin-top:0.5em; display:flex; flex-wrap:wrap; gap:0.4em; padding-left:15px;">`;
                }
                
                const displayProfile = String(ov.profile || "").replace(/,/g, ', '); 
                const bgColor = getRouteTileColour_ExtraPage(ov.routeName);
                const textColor = getTextColourForBackground_ExtraPage(bgColor);

                groupedHtml += `
                    <span class="route-tile-tools-list" 
                          style="background-color:${bgColor}; color:${textColor}; padding:0.3em 0.6em; font-size:0.85em; cursor:help;"
                          title="${ov.routeName}: ${displayProfile}">
                        ${ov.routeName}
                        <span style="font-size:0.75em; opacity:0.8; display:block; line-height:1.2;">${displayProfile}</span>
                    </span>`;
            });
            groupedHtml += "</div></li></ul>";
            html = groupedHtml;
        } else {
            html = `<p>No route-specific overrides set for the next ${fixedDaysAhead} day(s).</p>`; 
        }
        activeOverridesListElement.innerHTML = html;
    } catch (error) {
        console.error("Error loading all overrides:", error);
        activeOverridesListElement.innerHTML = "<p>Error loading all overrides.</p>";
        if (overridesHeadingElement) {
            overridesHeadingElement.textContent = "All Active Overrides (Error)";
        }
    }
}
        
async function updateSelectedDateInfo_ExtraPage() {
            if (!overrideDateInput_el_extra || !selectedDateDisplay_el_extra || !dpoCurrentOverridesList_el_extra) return;
            const selectedDateStr = overrideDateInput_el_extra.value;
            dpo_clearRouteSelections_ExtraPage();
            dpoStatusMessage_el_extra.textContent = '';

            selectedDateDisplay_el_extra.textContent = selectedDateStr ? formatDateToDDMonthYYYY_ExtraPage(selectedDateStr) : "(select a date)";
            dpoCurrentOverridesList_el_extra.innerHTML = '<p>Select a date above to see its current overrides.</p>';

            if (!selectedDateStr) {
                return;
            }
            
            if (operationalOverrides_data && operationalOverrides_data[selectedDateStr]) {
                dpo_currentOverridesForSelectedDate = operationalOverrides_data[selectedDateStr];
                const routeOverridesForDate = Object.entries(dpo_currentOverridesForSelectedDate)
                                                .sort((a, b) => compareLineNames_ExtraPage(a[0], b[0]));
                if (routeOverridesForDate.length > 0) {
                    let html = `<ul style="list-style-type: disc; padding-left: 20px; margin: 0;">`;
                    routeOverridesForDate.forEach(([routeName, profile]) => {
                        html += `<li>${routeName}: ${profile}</li>`;
                    });
                    html += `</ul>`;
                    dpoCurrentOverridesList_el_extra.innerHTML = html;
                } else {
                    dpoCurrentOverridesList_el_extra.innerHTML = `<p>No specific route overrides set for ${formatDateToDDMonthYYYY_ExtraPage(selectedDateStr)}.</p>`;
                }
            } else {
                dpo_currentOverridesForSelectedDate = {};
                dpoCurrentOverridesList_el_extra.innerHTML = `<p>No specific route overrides set for ${formatDateToDDMonthYYYY_ExtraPage(selectedDateStr)}.</p>`;
            }
            dpo_updateActionButtonsState();
        }

async function dpo_clearOverrideForRoutes_ExtraPage() {
            if (!currentUser_extra || !overrideDateInput_el_extra || !dpoStatusMessage_el_extra || !window.firebaseOMSI) {
                if (dpoStatusMessage_el_extra) {
                    dpoStatusMessage_el_extra.textContent = "Error: System not ready or not logged in for clear.";
                    dpoStatusMessage_el_extra.style.color="#e74c3c";
                }
                return;
            }
            const selectedDate = overrideDateInput_el_extra.value;
            const routesToClearFor = dpo_selectedRoutes_extra;

            if (!selectedDate) {
                dpoStatusMessage_el_extra.textContent = "Please select a date to clear overrides from.";
                dpoStatusMessage_el_extra.style.color="#e74c3c";
                return;
            }
            if (routesToClearFor.length === 0) {
                dpoStatusMessage_el_extra.textContent = "Please select at least one route to clear its override.";
                dpoStatusMessage_el_extra.style.color="#f1c40f";
                return;
            }

            const { database, dbRemove, dbSet, dbRef } = window.firebaseOMSI;
            let dateOverrides = operationalOverrides_data[selectedDate];

            if (!dateOverrides || Object.keys(dateOverrides).length === 0) {
                dpoStatusMessage_el_extra.textContent = `No overrides found for ${formatDateToDDMonthYYYY_ExtraPage(selectedDate)} to clear.`;
                dpoStatusMessage_el_extra.style.color="#f1c40f";
                dpo_clearRouteSelections_ExtraPage();
                return;
            }
            
            let overridesActuallyCleared = false;
            routesToClearFor.forEach(routeName => {
                if (dateOverrides[routeName]) {
                    delete dateOverrides[routeName];
                    overridesActuallyCleared = true;
                }
            });

            if (!overridesActuallyCleared) {
                dpoStatusMessage_el_extra.textContent = "No existing overrides for the selected routes on this date to clear.";
                dpoStatusMessage_el_extra.style.color="#7f8c8d";
                return;
            }

            if (!confirm(`Are you sure you want to clear the override for Route(s): ${routesToClearFor.join(', ')} on ${formatDateToDDMonthYYYY_ExtraPage(selectedDate)}?`)) {
                dpoStatusMessage_el_extra.textContent = "Clear override cancelled.";
                dpoStatusMessage_el_extra.style.color="#7f8c8d";
                return;
            }
            
            dpoStatusMessage_el_extra.textContent = `Clearing override for selected routes...`;
            dpoStatusMessage_el_extra.style.color="#f1c40f";

            try {
                if (Object.keys(dateOverrides).length === 0) {
                    await dbRemove(dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${selectedDate}`));
                    delete operationalOverrides_data[selectedDate];
                } else {
                    await dbSet(dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${selectedDate}`), dateOverrides);
                    operationalOverrides_data[selectedDate] = dateOverrides;
                }
                
                dpoStatusMessage_el_extra.textContent = `Successfully cleared override for ${routesToClearFor.length} route(s) on ${formatDateToDDMonthYYYY_ExtraPage(selectedDate)}.`;
                dpoStatusMessage_el_extra.style.color="#2ecc71";
                
                updateSelectedDateInfo_ExtraPage();
                loadAndDisplayOverrides_ExtraPage();
                dpo_clearRouteSelections_ExtraPage();
                updateCurrentProfileDisplay_ExtraPage();
            } catch (error) {
                console.error("DPO Clear: Error clearing override:", error);
                dpoStatusMessage_el_extra.textContent = "Error clearing override: " + error.message; 
                dpoStatusMessage_el_extra.style.color="#e74c3c";
            }
        }

        async function updateAncillaryScheduleData_ExtraPage() {
            if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available for ancillary data update.");
            const { database, dbSet, dbUpdate, dbRef } = window.firebaseOMSI;

            // 1. Regenerate uniqueBusStops from the current in-memory flat schedule
            const stopsMap = new Map();
            currentWorkingSchedule_extra.forEach(row => {
                if (row.stopID && !stopsMap.has(row.stopID.toUpperCase())) {
                    stopsMap.set(row.stopID.toUpperCase(), { stopID: row.stopID, stopName: row.stopName, direction: row.direction });
                }
            });
            const finalUniqueStops = Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase()));

            try {
                console.log("Attempting to save unique bus stops (ancillary)...");
                await dbSet(dbRef(database, FB_PATH_LIVE_UNIQUE_STOPS), finalUniqueStops);
                console.log("Unique bus stops saved. Attempting to save last updated timestamp (ancillary)...");
                await dbUpdate(dbRef(database), { [FB_PATH_APPSTATE_LAST_UPDATED]: new Date().toISOString() });
                console.log("Ancillary schedule data (unique stops, timestamp) updated.");
            } catch (error) {
                console.error("Error saving ancillary schedule data:", error);
                // Decide if this error should be propagated or just logged
                throw error; // Propagate for now
            }
        }

        // --- REBUILDS ENTIRE SCHEDULE in new structured format ---
        // In omsi_tools_extra.html

async function rebuildAndSaveEntireScheduleToFirebase_ExtraPage(flatScheduleDataToSave) {
    if (!currentUser_extra || !window.firebaseOMSI) {
        throw new Error("Not logged in or Firebase not available.");
    }
    const { database, dbUpdate, dbRef } = window.firebaseOMSI;

    console.log("Rebuilding entire schedule into BOTH 'schedulesByRoute' and 'schedulesByStop' structures...");

    // 1. Initialize objects for both data structures
    const newSchedulesByRoute = {};
    const newSchedulesByStop = {};

    // 2. Loop through the flat data ONCE to populate both objects
    flatScheduleDataToSave.forEach(entry => {
        // A. Logic for the 'schedulesByRoute' structure (for your tools)
        if (entry.lineName && entry.OperatingProfile && entry.destinationName) {
            const saneRoute = sanitizeFirebaseKey(entry.lineName);
            const saneProfile = sanitizeFirebaseKey(entry.OperatingProfile);
            const saneDest = sanitizeFirebaseKey(entry.destinationName);

            if (!newSchedulesByRoute[saneRoute]) newSchedulesByRoute[saneRoute] = {};
            if (!newSchedulesByRoute[saneRoute][saneProfile]) newSchedulesByRoute[saneRoute][saneProfile] = {};
            if (!newSchedulesByRoute[saneRoute][saneProfile][saneDest]) {
                newSchedulesByRoute[saneRoute][saneProfile][saneDest] = { entries: [] };
            }
            
            const entryForStorage = { ...entry };
            entryForStorage.lineName = entry.lineName;
            entryForStorage.OperatingProfile = entry.OperatingProfile;
            entryForStorage.destinationName = entry.destinationName;
            newSchedulesByRoute[saneRoute][saneProfile][saneDest].entries.push(entryForStorage);
        }

        // B. Logic for the new 'schedulesByStop' structure (for the arrivals board)
        if (entry.stopID && entry.lineName && entry.scheduledTime) {
            if (!newSchedulesByStop[entry.stopID]) {
                newSchedulesByStop[entry.stopID] = [];
            }
            newSchedulesByStop[entry.stopID].push(entry);
        }
    });

    // Sort the nested 'entries' arrays for consistency (optional but good practice)
    for (const routeKey in newSchedulesByRoute) {
        for (const profileKey in newSchedulesByRoute[routeKey]) {
            for (const destKey in newSchedulesByRoute[routeKey][profileKey]) {
                newSchedulesByRoute[routeKey][profileKey][destKey].entries.sort((a, b) => {
                    const timeA = (a.scheduledTime || "9999").replace(':', '');
                    const timeB = (b.scheduledTime || "9999").replace(':', '');
                    if (timeA !== timeB) return timeA.localeCompare(timeB);
                    return (a.stopName || "").localeCompare(b.stopName || "");
                });
            }
        }
    }
    
    try {
        // 3. Prepare ONE object that contains all the updates for an atomic write
        const updatesForFirebase = {};
        
        // By setting the parent path to the new data, we replace everything under it.
        // This is safer than deleting and then writing in multiple steps.
        updatesForFirebase['/liveSchedule/schedulesByRoute'] = newSchedulesByRoute;
        updatesForFirebase['/liveSchedule/schedulesByStop'] = newSchedulesByStop; // Add the new structure to the update

        console.log(`Attempting to save both schedule structures to Firebase...`);

        // 4. Execute the single, atomic update operation
        await dbUpdate(dbRef(database), updatesForFirebase);
        
        console.log("Both schedule structures saved successfully and in sync to Firebase.");

        // 5. After a full rebuild, also update ancillary data like unique stops and timestamp
        await updateAncillaryScheduleData_ExtraPage();

    } catch (error) {
        console.error("Error performing the atomic rebuild and save operation:", error);
        // Propagate the error so the calling function can notify the user
        throw error;
    }
}


        // --- Stop Management Functions ---
        function getBaseStopName_ExtraPage(fullStopName) { if (!fullStopName) return ""; let baseName = String(fullStopName).trim(); baseName = baseName.replace(/\s*\(Stand [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\(Bay [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\(Stop [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\([A-Z0-9]\)\s*$/i, ''); baseName = baseName.replace(/\s*-\s*Bay\s*[A-Z0-9]+\s*$/i,''); baseName = baseName.replace(/\s*Stop\s*[A-Z0-9]+\s*$/i,''); return baseName.trim(); }
        function getRandomIdFormat_ExtraPage() { const formats = ["NUM", "BP", "LE", "RO"]; return formats[Math.floor(Math.random() * formats.length)]; }
        function generateUniqueStopId_ExtraPage(format, stopName = "", allExistingStopIDsSet) { const targetBaseName = getBaseStopName_ExtraPage(stopName).toUpperCase(); let prefix = ""; let numericRegex; let baseStartNumber = 1; const MAX_NUMERIC_PART = 99999; switch (format) { case "NUM": prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; case "BP": prefix = "BP"; numericRegex = /^BP(\d+)$/; baseStartNumber = 1; break; case "LE": prefix = "LE"; numericRegex = /^LE(\d+)$/; baseStartNumber = 1; break; case "RO": prefix = "RO"; numericRegex = /^RO(\d+)$/; baseStartNumber = 1; break; default: console.warn(`generateUniqueStopId_ExtraPage: Unknown format "${format}", defaulting to NUM.`); format="NUM"; prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; if (/^[A-Z]+$/.test(format)) {prefix = format.toUpperCase(); numericRegex = new RegExp(`^${prefix}(\\d+)$`); baseStartNumber = 1;} break; } let highestNumInNameSequence = 0; let nameSpecificSequenceFound = false; if (targetBaseName && currentWorkingSchedule_extra) { currentWorkingSchedule_extra.forEach(entry => { if (entry.stopName && entry.stopID) { const existingEntryBaseName = getBaseStopName_ExtraPage(entry.stopName).toUpperCase(); if (existingEntryBaseName === targetBaseName) { const match = entry.stopID.toUpperCase().match(numericRegex); if (match && match[1]) { const numPart = parseInt(match[1], 10); if (!isNaN(numPart) && numPart <= MAX_NUMERIC_PART && numPart > highestNumInNameSequence) { highestNumInNameSequence = numPart; } nameSpecificSequenceFound = true; } } } }); } let nextNumInSequence = nameSpecificSequenceFound ? highestNumInNameSequence + 1 : baseStartNumber; if (format === "NUM" && nextNumInSequence < 101) nextNumInSequence = 101; if (baseStartNumber > MAX_NUMERIC_PART) { console.warn(`Suggest ID (single): Base start ${baseStartNumber} for ${format} exceeds MAX. Fallback.`); return prefix + "MAX_S_ERR" + Math.floor(Math.random()*1000); } let attempts = 0; const maxAttempts = MAX_NUMERIC_PART + 2000; let candidateId = ""; while (attempts < maxAttempts) { if (nextNumInSequence > MAX_NUMERIC_PART) { console.warn(`Suggest ID (single): All numbers up to ${MAX_NUMERIC_PART} exhausted for ${prefix}, base ${targetBaseName}. Fallback.`); let fA = 0, fId; do { fId = prefix + "RND" + String(Date.now()).slice(-3) + (Math.floor(Math.random()*900)+100); fA++; if (fA > 50) return prefix + "FB_FAIL" + Math.floor(Math.random()*1000); } while (allExistingStopIDsSet.has(fId.toUpperCase())); return fId; } candidateId = prefix + nextNumInSequence; if (!allExistingStopIDsSet.has(candidateId.toUpperCase())) return candidateId; nextNumInSequence++; attempts++; } console.warn(`CRITICAL: Could not generate unique Stop ID for ${format}, name: "${stopName}". Final fallback.`); let fA2 = 0, fId2; do { fId2 = prefix + "ULTRA_FB" + String(Date.now()).slice(-5) + (Math.floor(Math.random()*90)+10); fA2++; if (fA2 > 50) return prefix + "ULTRA_CRIT_FAIL" + Math.floor(Math.random()*100); } while (allExistingStopIDsSet.has(fId2.toUpperCase())); return fId2; }
        function autoGenerateAndSetNewStopId_ExtraPage() { if (!currentUser_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !selectNewStopIdFormat_el_extra) return; const currentStopName = inputNewStopName_el_extra.value.trim(); if (!currentStopName) { inputNewStopId_el_extra.value = ""; selectNewStopIdFormat_el_extra.selectedIndex = 0; if(addNewStopStatus_el_extra) {addNewStopStatus_el_extra.textContent = "Enter stop name for ID suggestion."; addNewStopStatus_el_extra.style.color = "";} if (newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = ''; return; } const actualBaseName = getBaseStopName_ExtraPage(currentStopName).toUpperCase(); let formatToUse = null; if (actualBaseName && currentWorkingSchedule_extra && currentWorkingSchedule_extra.length > 0) { for (const existingEntry of currentWorkingSchedule_extra) { if (existingEntry.stopID && existingEntry.stopName) { const existingEntryBaseName = getBaseStopName_ExtraPage(existingEntry.stopName).toUpperCase(); if (existingEntryBaseName === actualBaseName) { const existingId = existingEntry.stopID.toUpperCase(); if (existingId.startsWith("BP") && /BP\d+/.test(existingId)) formatToUse = "BP"; else if (existingId.startsWith("LE") && /LE\d+/.test(existingId)) formatToUse = "LE"; else if (existingId.startsWith("RO") && /RO\d+/.test(existingId)) formatToUse = "RO"; else if (/^\d+$/.test(existingId) && parseInt(existingId, 10) >= 100) formatToUse = "NUM"; if (formatToUse) break; } } } } if (!formatToUse) formatToUse = getRandomIdFormat_ExtraPage(); selectNewStopIdFormat_el_extra.value = formatToUse; const allCurrentScheduleIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase())); const suggestedId = generateUniqueStopId_ExtraPage(formatToUse, currentStopName, allCurrentScheduleIDs); inputNewStopId_el_extra.value = suggestedId; inputNewStopId_el_extra.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })); if (addNewStopStatus_el_extra) { addNewStopStatus_el_extra.textContent = `Auto-suggested ID: ${suggestedId} (Format: "${formatToUse}").`; addNewStopStatus_el_extra.style.color = '#bdc3c7'; } }
        async function handleAddStopDetails_ExtraPage() {
    if (!currentUser_extra || !addNewStopStatus_el_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !inputNewStopDirection_el_extra) {
        if (addNewStopStatus_el_extra) {
            addNewStopStatus_el_extra.textContent = "Error: UI components missing for adding stop.";
            addNewStopStatus_el_extra.style.color = '#e74c3c';
        }
        return;
    }
    const newStopID = inputNewStopId_el_extra.value.trim().toUpperCase();
    const newStopName = inputNewStopName_el_extra.value.trim();
    const newStopDirection = inputNewStopDirection_el_extra.value.trim();

    if (!newStopID) { 
        addNewStopStatus_el_extra.textContent = "New Stop ID is required."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopId_el_extra.focus(); 
        return; 
    }
    if (!/^[A-Z0-9]+$/.test(newStopID)) { 
        addNewStopStatus_el_extra.textContent = "Stop ID: A-Z, 0-9 only."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopId_el_extra.focus(); 
        return; 
    }
    if (!newStopName) { 
        addNewStopStatus_el_extra.textContent = "New Stop Name is required."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopName_el_extra.focus(); 
        return; 
    }

    // Check against allDefinedStops_data for uniqueness
    if (allDefinedStops_data && allDefinedStops_data[newStopID]) { 
        addNewStopStatus_el_extra.textContent = `Stop ID "${newStopID}" already exists as a definition.`; 
        if(newStopIdAvailability_el_extra){ 
            newStopIdAvailability_el_extra.textContent = 'ID already exists!'; 
            newStopIdAvailability_el_extra.style.color = '#e74c3c'; 
        } 
        inputNewStopId_el_extra.focus(); 
        return; 
    }

    const newStopDefinition = {
        stopID: newStopID,
        stopName: newStopName,
        direction: newStopDirection
    };
    
    // Add to local cache
    if (!allDefinedStops_data) allDefinedStops_data = {};
    allDefinedStops_data[newStopID] = newStopDefinition;

    addNewStopStatus_el_extra.textContent = `Adding stop definition "${newStopID}" to Firebase...`;
    addNewStopStatus_el_extra.style.color = '#f1c40f';

    try {
        await saveAllDefinedStopsToFirebase_ExtraPage(); 
        
        addNewStopStatus_el_extra.textContent = `Stop definition "${newStopID} - ${newStopName}" added to Firebase.`;
        addNewStopStatus_el_extra.style.color = '#2ecc71';

        inputNewStopId_el_extra.value = ''; 
        inputNewStopName_el_extra.value = ''; 
        inputNewStopDirection_el_extra.value = '';
        if(newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = '';
        if(selectNewStopIdFormat_el_extra) selectNewStopIdFormat_el_extra.selectedIndex = 0;
        
        if (typeof autoGenerateAndSetNewStopId_ExtraPage === 'function' && inputNewStopName_el_extra && inputNewStopId_el_extra) {
            autoGenerateAndSetNewStopId_ExtraPage();
        }
        
        renderUIDependentElements_ExtraPage(); // Refresh UI lists (like master stop list)

    } catch (error) {
        console.error("Error adding new stop definition:", error);
        addNewStopStatus_el_extra.textContent = "Error saving stop definition: " + error.message;
        addNewStopStatus_el_extra.style.color = '#e74c3c';
        
        // Revert local addition if Firebase update failed
        if (allDefinedStops_data && allDefinedStops_data[newStopID]) {
            delete allDefinedStops_data[newStopID];
        }
        renderUIDependentElements_ExtraPage();
    }
}

async function handleDeleteStopFromMasterList_ExtraPage(stopIDToDelete) {
    if (!currentUser_extra) {
        alert("Log in to delete stops.");
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "Not logged in.";
        return;
    }
    if (!stopIDToDelete) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "No StopID provided for deletion.";
        console.error("handleDeleteStopFromMasterList_ExtraPage: No stopIDToDelete provided.");
        return;
    }

    // Ensure allDefinedStops_data is an object
    if (typeof allDefinedStops_data !== 'object' || allDefinedStops_data === null) {
        allDefinedStops_data = {};
        console.warn("handleDeleteStopFromMasterList_ExtraPage: allDefinedStops_data was not an object, initialized.");
    }

    const stopNameToDelete = allDefinedStops_data[stopIDToDelete.toUpperCase()]?.stopName || stopIDToDelete;

    if (!confirm(`ARE YOU SURE you want to permanently delete the stop definition for "${stopNameToDelete} (${stopIDToDelete})" AND all its associated schedule entries from Firebase? This cannot be undone.`)) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `Deletion of stop ${stopIDToDelete} cancelled.`;
        return;
    }

    if (masterStopListStatus_el_extra) {
        masterStopListStatus_el_extra.textContent = `Deleting stop ${stopIDToDelete} and its schedules...`;
        masterStopListStatus_el_extra.style.color = '#f1c40f';
    }

    const stopIDUpper = stopIDToDelete.toUpperCase();
    let definitionWasDeleted = false;

    // 1. Remove from defined stops (local cache)
    if (allDefinedStops_data[stopIDUpper]) {
        delete allDefinedStops_data[stopIDUpper];
        definitionWasDeleted = true;
    }

    // 2. Remove any schedule entries for this stop from currentWorkingSchedule_extra (local cache)
    let entriesRemovedCount = 0;
    if (Array.isArray(currentWorkingSchedule_extra)) {
        currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
            if (entry.stopID && entry.stopID.toUpperCase() === stopIDUpper) {
                entriesRemovedCount++;
                return false; // Exclude this entry
            }
            return true; // Keep other entries
        });
    } else {
        currentWorkingSchedule_extra = []; // Ensure it's an array if it wasn't
    }


    // 3. Update related data (local caches)
    if (Array.isArray(closedStopIDs_extra)) {
        closedStopIDs_extra = closedStopIDs_extra.filter(id => id.toUpperCase() !== stopIDUpper);
    } else {
        closedStopIDs_extra = [];
    }

    if (typeof stopSpecificRouteColours_extra === 'object' && stopSpecificRouteColours_extra !== null && stopSpecificRouteColours_extra[stopIDUpper]) {
        delete stopSpecificRouteColours_extra[stopIDUpper];
    } else if (typeof stopSpecificRouteColours_extra !== 'object' || stopSpecificRouteColours_extra === null) {
        stopSpecificRouteColours_extra = {};
    }

    if (stopToServingRoutesMap_extra instanceof Map && stopToServingRoutesMap_extra.has(stopIDToDelete)) {
        stopToServingRoutesMap_extra.delete(stopIDToDelete);
    }


    // 4. Save all changes to Firebase
    try {
        if (definitionWasDeleted) {
            // Ensure saveAllDefinedStopsToFirebase_ExtraPage is defined and handles allDefinedStops_data correctly
            if (typeof saveAllDefinedStopsToFirebase_ExtraPage === 'function') {
                await saveAllDefinedStopsToFirebase_ExtraPage();
            } else {
                console.error("saveAllDefinedStopsToFirebase_ExtraPage function is not defined!");
                throw new Error("Critical function missing for saving defined stops.");
            }
        }

        // Rebuild and save the schedule which now lacks entries for the deleted stop
        // Ensure rebuildAndSaveEntireScheduleToFirebase_ExtraPage exists and is robust
        if (typeof rebuildAndSaveEntireScheduleToFirebase_ExtraPage === 'function') {
            await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
        } else {
            console.error("rebuildAndSaveEntireScheduleToFirebase_ExtraPage function is not defined!");
            throw new Error("Critical function missing for saving schedule data.");
        }
        
        // Ancillary data like uniqueBusStops (stops with service) will be updated by rebuildAndSave...
        if (typeof saveClosedStopsToFirebase_ExtraPage === 'function') await saveClosedStopsToFirebase_ExtraPage();
        if (typeof saveStopSpecificColoursToFirebase_ExtraPage === 'function') await saveStopSpecificColoursToFirebase_ExtraPage();

        if (masterStopListStatus_el_extra) {
            masterStopListStatus_el_extra.textContent = `Stop "${stopNameToDelete}" definition and ${entriesRemovedCount} schedule entries deleted.`;
            masterStopListStatus_el_extra.style.color = '#2ecc71';
        }
        
        // Refresh UI elements that depend on this data
        if (typeof renderUIDependentElements_ExtraPage === 'function') {
            renderUIDependentElements_ExtraPage();
        }

    } catch (error) {
        console.error(`Error deleting stop ${stopIDToDelete}:`, error);
        if (masterStopListStatus_el_extra) {
            masterStopListStatus_el_extra.textContent = `Error deleting stop ${stopIDToDelete}: ${error.message}`;
            masterStopListStatus_el_extra.style.color = '#e74c3c';
        }
        // Attempt to reload initial data to try and resync with Firebase on critical error
        if (typeof loadInitialData_ExtraPage === 'function') {
            alert("A critical error occurred while saving deletions. Attempting to reload all data to ensure consistency. Please check the stop's status after reload.");
            await loadInitialData_ExtraPage();
        }
    }
}

        function generateUniqueStopId_ExtraPage_BulkAware(format, stopName, newlyGeneratedIDsInBatchSet, baseNameAndFormatToGeneratedNumericPartsMap) { const targetBaseName = getBaseStopName_ExtraPage(stopName).toUpperCase(); let prefix = ""; let numericRegex; let baseStartNumber = 1; const MAX_NUMERIC_PART = 99999; switch (format) { case "NUM": prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; case "BP": prefix = "BP"; numericRegex = /^BP(\d+)$/; baseStartNumber = 1; break; case "LE": prefix = "LE"; numericRegex = /^LE(\d+)$/; baseStartNumber = 1; break; case "RO": prefix = "RO"; numericRegex = /^RO(\d+)$/; baseStartNumber = 1; break; default: console.warn(`generateUniqueStopId_ExtraPage_BulkAware (Replace Mode): Unknown format "${format}" for "${stopName}". Defaulting to NUM.`); format = "NUM"; prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; } const keyForMap = `${targetBaseName}_${format}`; if (!baseNameAndFormatToGeneratedNumericPartsMap.has(keyForMap)) { baseNameAndFormatToGeneratedNumericPartsMap.set(keyForMap, new Set()); } const numericPartsForThisGroup = baseNameAndFormatToGeneratedNumericPartsMap.get(keyForMap); let highestNumInGroup = 0; numericPartsForThisGroup.forEach(numStr => { const num = parseInt(numStr, 10); if (!isNaN(num) && num > highestNumInGroup) highestNumInGroup = num; }); let nextNumInSequence = highestNumInGroup > 0 ? highestNumInGroup + 1 : baseStartNumber; if (format === "NUM" && nextNumInSequence < 101) nextNumInSequence = 101; if (baseStartNumber > MAX_NUMERIC_PART) { console.warn(`BulkAware (Replace): Base start ${baseStartNumber} for ${format} exceeds MAX. Fallback.`); return prefix + "B_MAX_S_ERR" + Math.floor(Math.random()*1000); } let attempts = 0; const maxAttempts = MAX_NUMERIC_PART + 2000; let candidateId = ""; while (attempts < maxAttempts) { if (nextNumInSequence > MAX_NUMERIC_PART) { console.warn(`BulkAware (Replace): All numbers up to ${MAX_NUMERIC_PART} exhausted for ${prefix}, base ${targetBaseName}. Fallback.`); let fA = 0, fId; do { fId = prefix + "BRND" + String(Date.now()).slice(-4) + (Math.floor(Math.random()*900)+100); fA++; if (fA > 50) return prefix + "B_FB_FAIL" + Math.floor(Math.random()*1000); } while (newlyGeneratedIDsInBatchSet.has(fId.toUpperCase())); return fId; } candidateId = prefix + nextNumInSequence; if (!newlyGeneratedIDsInBatchSet.has(candidateId.toUpperCase())) { const match = candidateId.match(numericRegex); if(match && match[1]) numericPartsForThisGroup.add(match[1]); return candidateId; } nextNumInSequence++; attempts++; } console.warn(`CRITICAL_BULK (Replace): Could not generate unique Stop ID for ${format}, name: "${stopName}". Final fallback.`); let fA2 = 0, fId2; do { fId2 = prefix + "B_ULTRA_FB" + String(Date.now()).slice(-5) + (Math.floor(Math.random()*9000)+1000); fA2++; if (fA2 > 50) throw new Error("Bulk Fallback ID gen failed catastrophically."); } while (newlyGeneratedIDsInBatchSet.has(fId2.toUpperCase())); return fId2; }
        async function handleBulkAddStops_ExtraPage() {
            if (!currentUser_extra) { alert("Log in."); if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="Not logged in."; bulkAddNewStopsStatus_el_extra.style.color="#e74c3c";} return; }
            const stopsToProcessFromExcel = processedExcelStopsData_extra;
            if (!stopsToProcessFromExcel || stopsToProcessFromExcel.length === 0) { if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="No Excel data processed."; bulkAddNewStopsStatus_el_extra.style.color="#f1c40f";} return; }
            if (!confirm(`DANGER! This will DELETE ALL existing schedules AND ALL MASTER STOP DEFINITIONS, then add ${stopsToProcessFromExcel.length} stop definition(s) from Excel. This action CANNOT BE UNDONE. Proceed?`)) { // Modified confirm message
                if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="Bulk replace operation cancelled."; bulkAddNewStopsStatus_el_extra.style.color="#7f8c8d";} return;
            }
            if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = `Replacing all stops and definitions with ${stopsToProcessFromExcel.length} definitions from file...`; bulkAddNewStopsStatus_el_extra.style.color = '#f1c40f'; }

            let newFlatScheduleEntries = [];
            const newlyGeneratedOrUsedIDsInThisBatch = new Set();
            const baseNameToFormatMapForThisBatch = new Map();
            const baseNameAndFormatToGeneratedNumericPartsMap = new Map();
            let errorsEncountered = 0;
            let totalPlaceholdersCreated = 0;
            let uniqueStopIDsAddedCount = 0; // This will count unique stop *definitions*
            let statusMessages = [`Starting bulk replacement (Excel rows: ${stopsToProcessFromExcel.length})...\n`];

            // +++ NEW: Object to hold the new master stop definitions from this Excel file +++
            const newMasterDefinedStopsFromExcel = {};

            for (const stopData of stopsToProcessFromExcel) {
                const excelStopName = (stopData.stopName || "").trim();
                const excelDirection = (stopData.direction || "").trim();
                const excelUserProvidedStopID = (stopData.userProvidedStopID || "").trim();
                // const excelBaseName = getBaseStopName_ExtraPage(excelStopName).toUpperCase(); // Already in original
                let excelLineNames = (stopData.lineNameInput && stopData.lineNameInput.trim() !== "") ? stopData.lineNameInput.split(',').map(ln => ln.trim().toUpperCase()).filter(ln => ln !== "") : ["INFO_ONLY"];
                if (excelLineNames.length === 0) excelLineNames = ["INFO_ONLY"];

                if (!excelStopName && !excelUserProvidedStopID) {
                    statusMessages.push(`Row ${stopData.originalLineNumber}: Skipped. StopName or StopID required.`); errorsEncountered++; continue;
                }

                let finalStopID = "";
                // let idSourceMessage = ""; // Already in original
                // let chosenFormatForThisStop = ""; // Already in original
                if (excelUserProvidedStopID) {
                    const providedIDUpper = excelUserProvidedStopID.toUpperCase();
                    if (!/^[A-Z0-9]+$/.test(providedIDUpper)) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Provided StopID "${excelUserProvidedStopID}" invalid chars. Skipped.`); errorsEncountered++; continue; }
                    if (newlyGeneratedOrUsedIDsInThisBatch.has(providedIDUpper)) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Provided StopID "${excelUserProvidedStopID}" is duplicated within this Excel file. Skipped.`); errorsEncountered++; continue; }
                    finalStopID = excelUserProvidedStopID; // Use original casing if provided by user for the actual stopID property in the definition
                    // idSourceMessage = "user-provided"; // Already in original
                    // ... (logic for chosenFormatForThisStop from existing code) ...
                } else {
                    // ... (existing logic for auto-generating ID, ensure generateUniqueStopId_ExtraPage_BulkAware returns the ID in the desired case, typically uppercase for consistency but if it preserves original casing for display that's fine too) ...
                    chosenFormatForThisStop = baseNameToFormatMapForThisBatch.get(getBaseStopName_ExtraPage(excelStopName).toUpperCase()) || getRandomIdFormat_ExtraPage();
                    if (!baseNameToFormatMapForThisBatch.has(getBaseStopName_ExtraPage(excelStopName).toUpperCase())) {
                        baseNameToFormatMapForThisBatch.set(getBaseStopName_ExtraPage(excelStopName).toUpperCase(), chosenFormatForThisStop);
                    }
                    finalStopID = generateUniqueStopId_ExtraPage_BulkAware(chosenFormatForThisStop, excelStopName, newlyGeneratedOrUsedIDsInThisBatch, baseNameAndFormatToGeneratedNumericPartsMap);
                    // idSourceMessage = `auto-gen (${chosenFormatForThisStop})`; // Already in original
                }

                if (!finalStopID) {
                    statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Failed to obtain a final StopID. Skipped.`); errorsEncountered++; continue;
                }

                const finalStopIDKey = finalStopID.toUpperCase(); // Use uppercase for the KEY in the definitions object
                newlyGeneratedOrUsedIDsInThisBatch.add(finalStopIDKey);

                // +++ NEW/MODIFIED: Populate the new master defined stops object +++
                // Add definition only if it's a new unique StopID encountered in this file.
                if (!newMasterDefinedStopsFromExcel[finalStopIDKey]) {
                     newMasterDefinedStopsFromExcel[finalStopIDKey] = {
                        stopID: finalStopIDKey, // Store the stopID property itself as uppercase for consistency
                        stopName: excelStopName,
                        direction: excelDirection
                    };
                    uniqueStopIDsAddedCount++; // Count unique definitions being added
                }
                // --- End NEW/MODIFIED ---

                excelLineNames.forEach(ln => {
                    newFlatScheduleEntries.push({
                        internalId: `${finalStopIDKey}_${ln.replace(/[^A-Z0-9]/ig, '')}_phReplace_${Date.now()}_${newFlatScheduleEntries.length}`,
                        stopID: finalStopIDKey, // Use the consistent uppercase ID for schedule entries
                        stopName: excelStopName,
                        direction: excelDirection,
                        lineName: ln,
                        destinationName: "To Be Defined",
                        OperatingProfile: "AllDays",
                        scheduledTime: "00:00",
                        DayOffset: "0"
                    });
                    totalPlaceholdersCreated++;
                });
                statusMessages.push(`Row ${stopData.originalLineNumber}: Processed "${excelStopName}" -> ID: ${finalStopID} (Key: ${finalStopIDKey}). Routes: ${excelLineNames.join(', ')}.`);
            }

            // ... (existing summary message logic and user confirmation for errors) ...
            if (newFlatScheduleEntries.length === 0 && errorsEncountered > 0) { /* ... */ return; }
            else if (newFlatScheduleEntries.length === 0) { /* ... */ return; }


            // +++ NEW/MODIFIED: Update the global allDefinedStops_data with the new master list +++
            allDefinedStops_data = newMasterDefinedStopsFromExcel; // This REPLACES all existing definitions in the local cache
            // --- End NEW/MODIFIED ---

            currentWorkingSchedule_extra = newFlatScheduleEntries; // This is correct
            closedStopIDs_extra = []; // Correct for a full replace
            stopSpecificRouteColours_extra = {}; // Correct for a full replace

            try {
                // +++ NEW/MODIFIED: Save the new master defined stops to Firebase +++
                if (typeof saveAllDefinedStopsToFirebase_ExtraPage === 'function') {
                    await saveAllDefinedStopsToFirebase_ExtraPage(); // This saves the content of `allDefinedStops_data`
                    statusMessages.push(`\nSuccessfully updated master stop definitions in Firebase (${Object.keys(allDefinedStops_data).length} stops).`);
                } else {
                    statusMessages.push(`\nERROR: Function to save master stop definitions is missing! Definitions not saved to Firebase.`);
                    throw new Error("saveAllDefinedStopsToFirebase_ExtraPage function is undefined.");
                }
                // --- End NEW/MODIFIED ---

                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
                await saveClosedStopsToFirebase_ExtraPage(); // Saves empty `closedStopIDs_extra`
                await saveStopSpecificColoursToFirebase_ExtraPage(); // Saves empty `stopSpecificRouteColours_extra`

                statusMessages.push(`\nSuccessfully REPLACED all schedules. Added ${totalPlaceholdersCreated} placeholder entries for ${uniqueStopIDsAddedCount} unique StopIDs to Firebase in the new structure.`);
                if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#2ecc71'; }
                if (fileInputBulkAddStops_el_extra) fileInputBulkAddStops_el_extra.value = '';
                if (fileNameBulkAddStops_el_extra) fileNameBulkAddStops_el_extra.textContent = 'No file selected.';
                processedExcelStopsData_extra = [];
                renderUIDependentElements_ExtraPage(); // This will re-render lists based on new data
            } catch (error) {
                statusMessages.push("\nDATABASE ERROR: Error saving replaced data to Firebase: " + error.message);
                if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; }
                console.error("Error bulk replacing stops and saving to Firebase:", error);
            }
        }

        function handleExcelFileForBulkAdd_ExtraPage(event) { const file = event.target.files[0]; if (!fileInputBulkAddStops_el_extra || !fileNameBulkAddStops_el_extra || !bulkAddNewStopsStatus_el_extra) return; if (!file) { fileNameBulkAddStops_el_extra.textContent = "No file selected."; processedExcelStopsData_extra = []; return; } fileNameBulkAddStops_el_extra.textContent = `Processing ${file.name}...`; bulkAddNewStopsStatus_el_extra.textContent = ""; processedExcelStopsData_extra = []; const reader = new FileReader(); reader.onload = function(e) { try { const data = new Uint8Array(e.target.result); const workbook = XLSX.read(data, {type: 'array'}); const firstSheetName = workbook.SheetNames[0]; const worksheet = workbook.Sheets[firstSheetName]; const jsonData = XLSX.utils.sheet_to_json(worksheet, {header:1, defval:''}); if (jsonData.length === 0) { bulkAddNewStopsStatus_el_extra.textContent = "Excel file empty or no data."; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileNameBulkAddStops_el_extra.textContent = `Error: ${file.name} is empty.`; fileInputBulkAddStops_el_extra.value = ''; return; } let validEntries = 0; let tempProcessedData = []; jsonData.forEach((row, index) => { if (!Array.isArray(row) || row.every(cell => String(cell).trim() === '')) return; const userProvidedStopID = String(row[0] || "").trim(); const stopName = String(row[1] || "").trim(); const direction = String(row[2] || "").trim(); const lineNameInput = String(row[3] || "").trim(); if (!stopName && !userProvidedStopID) { console.warn(`Skipping Excel row ${index + 1}: StopName and StopID both missing.`); return; } tempProcessedData.push({ originalLineNumber: index + 1, userProvidedStopID: userProvidedStopID, stopName: stopName, direction: direction, lineNameInput: lineNameInput }); validEntries++; }); processedExcelStopsData_extra = tempProcessedData; if (validEntries > 0) { fileNameBulkAddStops_el_extra.textContent = `${file.name} (${validEntries} valid rows ready).`; bulkAddNewStopsStatus_el_extra.textContent = `${validEntries} stop definitions processed. Ready for Bulk Replace operation.`; bulkAddNewStopsStatus_el_extra.style.color = '#2ecc71'; } else { fileNameBulkAddStops_el_extra.textContent = `No valid data in ${file.name}.`; bulkAddNewStopsStatus_el_extra.textContent = "No valid definitions (StopName/StopID required)."; bulkAddNewStopsStatus_el_extra.style.color = '#f1c40f'; fileInputBulkAddStops_el_extra.value = ''; } } catch (error) { console.error("Error processing Excel:", error); fileNameBulkAddStops_el_extra.textContent = `Error processing ${file.name}.`; bulkAddNewStopsStatus_el_extra.textContent = "Error processing Excel: " + error.message; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileInputBulkAddStops_el_extra.value = ''; } }; reader.onerror = () => { fileNameBulkAddStops_el_extra.textContent = "Error reading file."; bulkAddNewStopsStatus_el_extra.textContent = "Could not read file."; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileInputBulkAddStops_el_extra.value = ''; }; reader.readAsArrayBuffer(file); }
        
function populateMasterStopList_ExtraPage() {
    if (!masterStopListUL_el_extra || !masterStopListStatus_el_extra) return;

    // Use allDefinedStops_data as the source, convert to array and sort
    const stopsToDisplay = Object.values(allDefinedStops_data || {}).sort((a, b) => {
        const nameA = (a.stopName || "").toLowerCase();
        const nameB = (b.stopName || "").toLowerCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        return (a.stopID || "").toLowerCase().localeCompare((b.stopID || "").toLowerCase());
    });

    const filterText = masterStopListFilterInput_el_extra.value.toLowerCase().trim();
    masterStopListUL_el_extra.innerHTML = '';
    let displayedCount = 0;

    if (stopsToDisplay.length === 0) {
        masterStopListStatus_el_extra.textContent = 'No stop definitions found.';
        masterStopListUL_el_extra.innerHTML = '<p style="text-align:center; padding:1rem; opacity:0.7;">No stops defined in the system.</p>';
        return;
    }

    stopsToDisplay.forEach(stop => {
        if (!stop || !stop.stopID) return;

        // stopToServingRoutesMap_extra is still derived from currentWorkingSchedule_extra (actual services)
        const servingRouteNamesArray = Array.from(stopToServingRoutesMap_extra.get(stop.stopID) || new Set());
        const stopIdLower = stop.stopID.toLowerCase();
        const stopNameLower = (stop.stopName || "").toLowerCase();
        const isClosed = closedStopIDs_extra.includes(stop.stopID.toUpperCase());
        const closureStatus = isClosed ? "Closed" : "Open";

        if (filterText) {
            const stopDirectionLower = (stop.direction || "").toLowerCase();
            const matchesStopId = stopIdLower.includes(filterText);
            const matchesStopName = stopNameLower.includes(filterText);
            const matchesDirection = stopDirectionLower.includes(filterText) ||
                                     (filterText === "no direction" && (stop.direction || "").trim().toUpperCase() === "NO DIRECTION") ||
                                     (filterText === "blank" && !(stop.direction && stop.direction.trim() !== ""));
            const matchesStatus = closureStatus.toLowerCase().includes(filterText);
            const matchesRoute = servingRouteNamesArray.some(routeName =>
                routeName.toLowerCase().includes(filterText)
            );
            if (!(matchesStopId || matchesStopName || matchesDirection || matchesStatus || matchesRoute)) {
                return;
            }
        }

        displayedCount++;
        const li = document.createElement('li');
        li.classList.add('master-stop-list-item');
        li.dataset.originalStopid = stop.stopID;

        const originalInfoDiv = document.createElement('div');
        originalInfoDiv.classList.add('master-stop-original-info');

        let originalContent = `<span class="stop-name-master">${stop.stopName || 'N/A'}</span><br>`;

        let directionHtmlLine = "";
        if (stop.direction &&
            stop.direction.trim() !== "" &&
            stop.direction.trim().toUpperCase() !== "NO DIRECTION") {
            directionHtmlLine = `<span class="stop-direction-master">Towards: ${stop.direction}</span><br>`;
        }
        originalContent += directionHtmlLine;

        originalContent += `<span class="stop-id-master">Stop ID: ${stop.stopID}</span>`;

        originalContent += `<div class="master-stop-original-info .stop-details-grid" style="margin-top:0.3rem;">
                                <span class="detail-label">Status:</span>
                                <span class="detail-value ${isClosed ? 'status-closed' : 'status-open'}">${closureStatus}</span>
                            </div>`;

        if (servingRouteNamesArray.length > 0) {
            const sortedRouteNamesForDisplay = [...servingRouteNamesArray].sort(compareLineNames_ExtraPage);
            originalContent += `<div class="serving-routes-container" style="margin-top:0.3rem;">`;
            sortedRouteNamesForDisplay.slice(0, 10).forEach(lineName => {
                const bgColor = getRouteTileColour_ExtraPage(lineName, stop.stopID);
                const textColor = getTextColourForBackground_ExtraPage(bgColor);
                originalContent += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor}; font-size:0.7em; padding:0.15em 0.4em;">${lineName}</span>`;
            });
            if (sortedRouteNamesForDisplay.length > 10) {
                originalContent += `<span style="font-size:0.7em; opacity:0.8;">...and ${sortedRouteNamesForDisplay.length - 10} more.</span>`;
            }
            originalContent += `</div>`;
        } else { // New: If no serving routes, indicate this explicitly
            originalContent += `<div class="serving-routes-container" style="margin-top:0.3rem; font-size:0.8em; opacity:0.7;">(No routes currently serving this stop)</div>`;
        }
        originalInfoDiv.innerHTML = originalContent;

        const newIdSectionDiv = document.createElement('div');
        newIdSectionDiv.classList.add('master-stop-new-id-section');
        const newIdLabel = document.createElement('label');
        newIdLabel.textContent = 'Propose New ID (optional):';
        const newIdInput = document.createElement('input');
        newIdInput.type = 'text';
        newIdInput.classList.add('schedule-generator-input', 'master-list-new-id-input');
        newIdInput.dataset.originalId = stop.stopID;
        newIdInput.placeholder = "Enter new ID, then Apply Bulk";
        newIdInput.value = stop.stopID;

        const warningP = document.createElement('p');
        warningP.classList.add('master-list-row-warning');

        newIdInput.addEventListener('input', () => {
            const enteredID = newIdInput.value.trim().toUpperCase();
            warningP.textContent = '';
            warningP.style.color = '#f39c12';

            if (!enteredID) return;
            if (enteredID === stop.stopID.toUpperCase()) return;

            if (!/^[A-Z0-9]+$/.test(enteredID)) {
                warningP.textContent = 'Invalid chars in ID.';
                return;
            }
            const allCurrentAndProposedIDs = new Set(Object.keys(allDefinedStops_data || {}).map(id => id.toUpperCase()));
            document.querySelectorAll('#masterStopListUL_extra .master-list-new-id-input').forEach(inp => {
                if (inp !== newIdInput) {
                    const otherProposed = inp.value.trim().toUpperCase();
                    if (otherProposed && otherProposed !== inp.dataset.originalId.toUpperCase()) {
                        allCurrentAndProposedIDs.add(otherProposed);
                    }
                }
            });

            if (allCurrentAndProposedIDs.has(enteredID)) {
                warningP.textContent = 'ID taken or proposed elsewhere!';
            } else {
                warningP.textContent = 'New ID available.';
                warningP.style.color = '#2ecc71';
            }
        });

        newIdSectionDiv.appendChild(newIdLabel);
        newIdSectionDiv.appendChild(newIdInput);
        newIdSectionDiv.appendChild(warningP);

        const actionsDiv = document.createElement('div');
        actionsDiv.classList.add('master-stop-actions');

        const editBtn = document.createElement('button');
        editBtn.className = 'button small-action';
        editBtn.textContent = 'Edit Name / Direction';
        editBtn.addEventListener('click', () => handleEditStopFromMasterList_ExtraPage(stop.stopID, stop.stopName, stop.direction));

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'button small-action secondary';
        deleteBtn.textContent = 'Delete Stop Definition'; // Text changed for clarity
        deleteBtn.addEventListener('click', () => handleDeleteStopFromMasterList_ExtraPage(stop.stopID));

        const toggleBtn = document.createElement('button');
        toggleBtn.className = `button small-action ${isClosed ? "save" : "secondary"}`;
        toggleBtn.textContent = isClosed ? "Reopen Stop" : "Close Stop";
        toggleBtn.addEventListener('click', () => handleToggleStopStatusFromMasterList_ExtraPage(stop.stopID));

        actionsDiv.appendChild(editBtn);
        actionsDiv.appendChild(deleteBtn);
        actionsDiv.appendChild(toggleBtn);

        li.appendChild(originalInfoDiv);
        li.appendChild(newIdSectionDiv);
        li.appendChild(actionsDiv);
        masterStopListUL_el_extra.appendChild(li);
    });

    if (displayedCount === 0 && stopsToDisplay.length > 0 && filterText) {
        masterStopListUL_el_extra.innerHTML = `<p style="text-align:center; padding:1rem; opacity:0.7;">No stops match your filter "${filterText}".</p>`;
    }

    masterStopListStatus_el_extra.textContent = `Showing ${displayedCount} of ${stopsToDisplay.length} defined stops. ${filterText ? `Filter active: "${filterText}"` : ''}`;
}

        function findDuplicateStopsByNameAndDirection_ExtraPage() { if (!currentUser_extra) { alert("Please log in."); if (duplicateStopsByNameDirResults_el_extra) duplicateStopsByNameDirResults_el_extra.textContent = "Please log in."; return; } if (!duplicateStopsByNameDirResults_el_extra) { console.error("Result display element not found."); return; } duplicateStopsByNameDirResults_el_extra.innerHTML = "<p>Checking for duplicates...</p>"; duplicateStopsByNameDirResults_el_extra.style.color = "#f1c40f"; const stopsToCheck = getUniqueStopsFromSchedule_ExtraPage(); if (!stopsToCheck || stopsToCheck.length === 0) { duplicateStopsByNameDirResults_el_extra.textContent = "No stops loaded."; return; } const signatureMap = new Map(); stopsToCheck.forEach(stop => { if (stop.stopName && stop.stopID) { const name = stop.stopName.trim().toLowerCase(); const direction = (stop.direction || "").trim().toLowerCase(); const signature = `${name}|${direction}`; if (!signatureMap.has(signature)) signatureMap.set(signature, []); signatureMap.get(signature).push({id: stop.stopID, name: stop.stopName, direction: stop.direction}); } }); let duplicateSets = []; signatureMap.forEach((stops, signature) => { if (stops.length > 1) { duplicateSets.push({ signature: signature, name: stops[0].name, direction: stops[0].direction || "", stops: stops.map(s => ({ id: s.id, entryCount: currentWorkingSchedule_extra.filter(entry => entry.stopID === s.id).length })).sort((a,b) => b.entryCount - a.id.localeCompare(b.id)) }); } }); if (duplicateSets.length === 0) { duplicateStopsByNameDirResults_el_extra.textContent = "No duplicate stops found (name & direction)."; duplicateStopsByNameDirResults_el_extra.style.color = "#2ecc71"; } else { let html = `<p>${duplicateSets.length} set(s) of duplicate stops found:</p><ul>`; duplicateSets.forEach((set, index) => { html += `<li class="duplicate-set-to-merge">`; html += `<p><strong>Name:</strong> "${set.name}", <strong>Direction:</strong> "${set.direction || '(None)'}"</p>`; html += `<p>Conflicting StopIDs (select one to keep):</p><div class="stop-id-options">`; set.stops.forEach((stop, radioIndex) => { const radioName = `master_for_set_${index}`; const isChecked = radioIndex === 0 ? "checked" : ""; html += `<label><input type="radio" name="${radioName}" value="${stop.id}" ${isChecked}> ${stop.id} (${stop.entryCount} entries)</label><br>`; }); html += `</div></li>`; }); html += `</ul><button id="mergeDuplicateStopsButton_extra" class="button save" style="margin-top:1rem;">Merge Selected Duplicates</button>`; html += `<p id="mergeDuplicateStopsStatus_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>`; duplicateStopsByNameDirResults_el_extra.innerHTML = html; duplicateStopsByNameDirResults_el_extra.style.color = "#e74c3c"; const mergeButton = document.getElementById('mergeDuplicateStopsButton_extra'); if (mergeButton) mergeButton.addEventListener('click', handleMergeDuplicateStops_ExtraPage); } }
        async function handleMergeDuplicateStops_ExtraPage() {
            if (!currentUser_extra) { alert("Log in."); return; }
            const mergeStatusEl = document.getElementById('mergeDuplicateStopsStatus_extra'); if (!mergeStatusEl) return;
            mergeStatusEl.textContent = "Processing merges..."; mergeStatusEl.style.color = "#f1c40f";
            const duplicateSetElements = duplicateStopsByNameDirResults_el_extra.querySelectorAll('.duplicate-set-to-merge'); if (duplicateSetElements.length === 0) { mergeStatusEl.textContent = "No duplicate sets found."; return; }
            let changesMade = false; let totalEntriesReassigned = 0; let stopIDsMergedAwayOverall = new Set();
            for (let i = 0; i < duplicateSetElements.length; i++) { 
                const radioName = `master_for_set_${i}`; const selectedRadio = duplicateStopsByNameDirResults_el_extra.querySelector(`input[name="${radioName}"]:checked`); if (!selectedRadio) continue; const masterStopID = selectedRadio.value; const masterStopDetails = uniqueStopsMasterList_extra.find(s => s.stopID === masterStopID) || currentWorkingSchedule_extra.find(e => e.stopID === masterStopID); if (!masterStopDetails) continue; const masterStopName = masterStopDetails.stopName; const masterStopDirection = masterStopDetails.direction; const allRadiosInSet = duplicateStopsByNameDirResults_el_extra.querySelectorAll(`input[name="${radioName}"]`); const stopIDsInThisSet = Array.from(allRadiosInSet).map(radio => radio.value); const stopIDsToMergeAway = stopIDsInThisSet.filter(id => id !== masterStopID); if (stopIDsToMergeAway.length > 0) { changesMade = true; stopIDsToMergeAway.forEach(idToMerge => { stopIDsMergedAwayOverall.add(idToMerge.toUpperCase()); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === idToMerge) { entry.stopID = masterStopID; entry.stopName = masterStopName; entry.direction = masterStopDirection; totalEntriesReassigned++; } }); }); }
            }
            if (!changesMade) { mergeStatusEl.textContent = "No merges selected."; mergeStatusEl.style.color = "#7f8c8d"; return; }
            closedStopIDs_extra = closedStopIDs_extra.filter(id => !stopIDsMergedAwayOverall.has(id.toUpperCase())); stopIDsMergedAwayOverall.forEach(idToMergeUpper => { if (stopSpecificRouteColours_extra[idToMergeUpper]) delete stopSpecificRouteColours_extra[idToMergeUpper]; });
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra); 
                await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                mergeStatusEl.textContent = `Merged duplicates. ${totalEntriesReassigned} entries reassigned.`; mergeStatusEl.style.color = "#2ecc71";
                renderUIDependentElements_ExtraPage(); findDuplicateStopsByNameAndDirection_ExtraPage();
            } catch (error) { console.error("Error saving merged stops:", error); mergeStatusEl.textContent = "Error saving merged stops: " + error.message; mergeStatusEl.style.color = "#e74c3c"; alert("CRITICAL: Error saving merged stops. Data inconsistent. Refresh."); }
        }
        async function saveClosedStopsToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; const fbClosedObject = {}; closedStopIDs_extra.forEach(id => { if (typeof id === 'string') fbClosedObject[id.toUpperCase()] = true; }); await dbSet(dbRef(database, FB_PATH_APPSTATE_CLOSED_STOPS), fbClosedObject); console.log("Closed stops saved (Extra)."); }
        async function saveGlobalColoursToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; await dbSet(dbRef(database, FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS), globalCustomRouteColours_extra); console.log("Global route colours saved (Extra)."); }
        async function saveStopSpecificColoursToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; await dbSet(dbRef(database, FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS), stopSpecificRouteColours_extra); console.log("Stop-specific colours saved (Extra)."); }

        // --- Global Route Deletion Functions ---
        function populateGlobalRouteToDeleteList_ExtraPage() { if (!globalRouteDeletionListContainer_el_extra) return; globalRouteDeletionListContainer_el_extra.innerHTML = ''; if (!currentWorkingSchedule_extra || currentWorkingSchedule_extra.length === 0) { globalRouteDeletionListContainer_el_extra.innerHTML = '<p>No routes loaded.</p>'; return; } const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName).filter(Boolean))].sort(compareLineNames_ExtraPage); if (uniqueRoutes.length === 0) { globalRouteDeletionListContainer_el_extra.innerHTML = '<p>No valid routes to list.</p>'; return; } const tileContainer = document.createElement('div'); tileContainer.className = 'selectable-route-tile-container'; uniqueRoutes.forEach(lineName => { const tile = document.createElement('span'); tile.className = 'selectable-route-tile'; tile.textContent = lineName; tile.dataset.lineName = lineName; const bgColor = getRouteTileColour_ExtraPage(lineName); tile.style.backgroundColor = bgColor; tile.style.color = getTextColourForBackground_ExtraPage(bgColor); tile.setAttribute('role', 'checkbox'); tile.setAttribute('aria-checked', 'false'); tile.tabIndex = 0; tile.addEventListener('click', () => { const isSelected = tile.classList.toggle('selected'); tile.setAttribute('aria-checked', isSelected.toString()); }); tile.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); tile.click(); }}); tileContainer.appendChild(tile); }); globalRouteDeletionListContainer_el_extra.appendChild(tileContainer); }
        async function handleDeleteEntireRouteGlobally_ExtraPage() {
            if (!currentUser_extra || !deleteEntireRouteStatusMessage_el_extra || !globalRouteDeletionListContainer_el_extra) return;
            const selectedTiles = globalRouteDeletionListContainer_el_extra.querySelectorAll('.selectable-route-tile.selected');
            if (selectedTiles.length === 0) { deleteEntireRouteStatusMessage_el_extra.textContent = "Select route(s) to delete."; deleteEntireRouteStatusMessage_el_extra.style.color = '#f1c40f'; return; }
            const routesToDelete = Array.from(selectedTiles).map(t => t.dataset.lineName);
            if (!confirm(`EXTREME CAUTION!\nDelete ALL data for route(s): ${routesToDelete.join(', ')} from Firebase? CANNOT BE UNDONE.`)) { deleteEntireRouteStatusMessage_el_extra.textContent = "Global deletion cancelled."; return; }
            deleteEntireRouteStatusMessage_el_extra.textContent = `Deleting route(s): ${routesToDelete.join(', ')}...`; deleteEntireRouteStatusMessage_el_extra.style.color = '#f1c40f';
            const { database, dbRemove, dbRef } = window.firebaseOMSI; let firebaseRemovalPromises = [];
            routesToDelete.forEach(routeNameToDelete => {
                const saneRouteName = sanitizeFirebaseKey(routeNameToDelete);
                const routePath = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRouteName}`;
                firebaseRemovalPromises.push(dbRemove(dbRef(database, routePath)));
            });
            const originalScheduleLength = currentWorkingSchedule_extra.length;
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry =>
                !(entry.lineName && routesToDelete.map(r => r.toUpperCase()).includes(entry.lineName.toUpperCase()))
            );
            const scheduleEntriesRemovedCount = originalScheduleLength - currentWorkingSchedule_extra.length;
            let globalColoursRemoved = false; routesToDelete.forEach(route => { if (globalCustomRouteColours_extra[route.toUpperCase()]) { delete globalCustomRouteColours_extra[route.toUpperCase()]; globalColoursRemoved = true; } });
            let specificColoursNeedSave = false; Object.keys(stopSpecificRouteColours_extra).forEach(stopID => { routesToDelete.forEach(route => { if (stopSpecificRouteColours_extra[stopID] && stopSpecificRouteColours_extra[stopID][route.toUpperCase()]) { delete stopSpecificRouteColours_extra[stopID][route.toUpperCase()]; if (Object.keys(stopSpecificRouteColours_extra[stopID]).length === 0) delete stopSpecificRouteColours_extra[stopID]; specificColoursNeedSave = true; } }); });
            try {
                await Promise.all(firebaseRemovalPromises); 
                if (globalColoursRemoved) await saveGlobalColoursToFirebase_ExtraPage();
                if (specificColoursNeedSave) await saveStopSpecificColoursToFirebase_ExtraPage();
                await updateAncillaryScheduleData_ExtraPage(); 
                deleteEntireRouteStatusMessage_el_extra.textContent = `Route(s) ${routesToDelete.join(', ')} deleted. ${scheduleEntriesRemovedCount} entries removed.`;
                deleteEntireRouteStatusMessage_el_extra.style.color = '#2ecc71';
                renderUIDependentElements_ExtraPage();
            } catch (error) {
                console.error("Error deleting route(s) globally:", error);
                deleteEntireRouteStatusMessage_el_extra.textContent = "Error saving deletions: " + error.message;
                deleteEntireRouteStatusMessage_el_extra.style.color = '#e74c3c';
                alert("Critical error saving global route deletions. Data inconsistent. Refresh.");
            }
        }

        // ++ Route Profile Deletion Functions (NEW SECTION) ++
        /**
         * @description Populates the route select dropdown for the Route Profile Deletion tool.
         */
        function rpd_populateRouteSelect_ExtraPage() {
            if (!rpdRouteSelect_el_extra || !rpdRouteInput_el_extra) return;
            const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))]
                .filter(Boolean)
                .sort(compareLineNames_ExtraPage);

            const currentInputValue = rpdRouteInput_el_extra.value.trim();
            rpdRouteSelect_el_extra.innerHTML = '<option value="">-- Select Route --</option>';
            uniqueRoutes.forEach(route => {
                const opt = document.createElement('option');
                opt.value = route;
                opt.textContent = route;
                rpdRouteSelect_el_extra.appendChild(opt);
            });

            const matchedRoute = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
            if (matchedRoute) {
                rpdRouteSelect_el_extra.value = matchedRoute;
            } else if (currentInputValue) {
                rpdRouteSelect_el_extra.value = ""; 
            }
            // Chain updates
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Handles changes to the route name input field for RPD.
         */
        function rpd_handleRouteNameInputChange_ExtraPage() {
            if (!rpdRouteInput_el_extra || !rpdRouteSelect_el_extra) return;
            const typedRouteUpper = rpdRouteInput_el_extra.value.trim().toUpperCase();
            const matchedOption = Array.from(rpdRouteSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper);

            if (matchedOption) {
                rpdRouteSelect_el_extra.value = matchedOption.value;
                if (rpdRouteInput_el_extra.value !== matchedOption.value) {
                    rpdRouteInput_el_extra.value = matchedOption.value;
                }
            } else {
                rpdRouteSelect_el_extra.value = ""; 
            }
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Handles changes to the route name select dropdown for RPD.
         */
        function rpd_handleRouteNameSelectChange_ExtraPage() {
            if (!rpdRouteSelect_el_extra || !rpdRouteInput_el_extra) return;
            rpdRouteInput_el_extra.value = rpdRouteSelect_el_extra.value;
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Populates the destination select dropdown for RPD based on selected route.
         */
        function rpd_populateDestinationSelect_ExtraPage() {
            if (!rpdDestinationSelect_el_extra || !rpdDestinationInput_el_extra || !rpdRouteInput_el_extra) return;

            const selectedRoute = rpdRouteInput_el_extra.value.trim().toUpperCase();
            const currentDestInputValue = rpdDestinationInput_el_extra.value.trim();

            rpdDestinationSelect_el_extra.innerHTML = '<option value="">-- Optional: All Destinations --</option>'; // Modified default text

            if (!selectedRoute) {
                rpdDestinationInput_el_extra.value = ""; 
                rpdDestinationSelect_el_extra.disabled = true;
                rpdDestinationInput_el_extra.disabled = true;
                if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = 'none';
                rpd_populateProfileList_ExtraPage(); 
                return;
            }

            rpdDestinationSelect_el_extra.disabled = false;
            rpdDestinationInput_el_extra.disabled = false;

            const uniqueDestinations = [...new Set(
                currentWorkingSchedule_extra
                    .filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName)
                    .map(e => e.destinationName)
            )].sort();

            if (uniqueDestinations.length > 0) {
                uniqueDestinations.forEach(dest => {
                    const opt = document.createElement('option');
                    opt.value = dest;
                    opt.textContent = dest;
                    rpdDestinationSelect_el_extra.appendChild(opt);
                });
                const matchedDest = uniqueDestinations.find(d => d === currentDestInputValue);
                if (matchedDest) {
                    rpdDestinationSelect_el_extra.value = matchedDest;
                } else {
                     rpdDestinationSelect_el_extra.value = ""; // Default to "All Destinations" if typed value doesn't match
                }
            } else {
                 rpdDestinationSelect_el_extra.innerHTML = '<option value="">-- No Specific Destinations --</option>';
                 rpdDestinationInput_el_extra.value = ""; // Clear input if no destinations exist
            }
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }
        
        /**
         * @description Handles changes to the destination name input field for RPD.
         */
        function rpd_handleDestinationNameInputChange_ExtraPage() {
            if (!rpdDestinationInput_el_extra || !rpdDestinationSelect_el_extra) return;
            const typedDest = rpdDestinationInput_el_extra.value.trim();
            const matchedOption = Array.from(rpdDestinationSelect_el_extra.options).find(opt => opt.value === typedDest);

            if (matchedOption) {
                rpdDestinationSelect_el_extra.value = matchedOption.value;
                if (rpdDestinationInput_el_extra.value !== matchedOption.value) {
                   rpdDestinationInput_el_extra.value = matchedOption.value;
                }
            } else {
                rpdDestinationSelect_el_extra.value = ""; // If typing something not in list, clear select to imply "All Destinations" or new
            }
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }

        /**
         * @description Handles changes to the destination name select dropdown for RPD.
         */
        function rpd_handleDestinationNameSelectChange_ExtraPage() {
            if (!rpdDestinationSelect_el_extra || !rpdDestinationInput_el_extra) return;
            rpdDestinationInput_el_extra.value = rpdDestinationSelect_el_extra.value; // Sync input with select
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }
        
        /**
         * @description Clears the destination selection for RPD.
         */
        function rpd_handleClearDestination_ExtraPage() {
            if (!rpdDestinationInput_el_extra || !rpdDestinationSelect_el_extra || !rpdClearDestinationButton_el_extra) return;
            rpdDestinationInput_el_extra.value = "";
            rpdDestinationSelect_el_extra.value = ""; // This will select "-- Optional: All Destinations --"
            rpdClearDestinationButton_el_extra.style.display = 'none';
            rpd_populateProfileList_ExtraPage(); 
        }

        /**
         * @description Fetches and displays available profiles for selection based on route and optional destination.
         */
        async function rpd_populateProfileList_ExtraPage() {
            if (!rpdProfileListContainer_el_extra || !rpdRouteInput_el_extra || !rpdDestinationInput_el_extra || !window.firebaseOMSI) {
                if (rpdProfileListContainer_el_extra) rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; opacity:0.7;">Required elements missing for profile listing.</p>';
                return;
            }

            const routeName = rpdRouteInput_el_extra.value.trim();
            const destinationName = rpdDestinationInput_el_extra.value.trim(); // This is the specific destination, if selected

            rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; opacity:0.7;">Select a route to see available profiles.</p>';

            if (!routeName) {
                return; 
            }

            rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; color:#f1c40f;">Loading profiles...</p>';

            // Use currentWorkingSchedule_extra to derive profiles to ensure original casing and relevance
            let profilesOfInterest = currentWorkingSchedule_extra.filter(entry => {
                if (entry.lineName !== routeName) return false;
                if (destinationName && entry.destinationName !== destinationName) return false; // Filter by dest if specified
                return true; // Passes if route matches, and dest matches (if dest was specified)
            });

            let availableOriginalProfileNames = [...new Set(profilesOfInterest.map(e => e.OperatingProfile))].sort();

            if (availableOriginalProfileNames.length === 0) {
                if (destinationName) {
                    rpdProfileListContainer_el_extra.innerHTML = `<p style="font-size:0.85em; color:#f1c40f;">No profiles found for route "${routeName}" with destination "${destinationName}".</p>`;
                } else {
                    rpdProfileListContainer_el_extra.innerHTML = `<p style="font-size:0.85em; color:#f1c40f;">No profiles found for route "${routeName}".</p>`;
                }
                return;
            }

            let html = '<div class="selectable-route-tile-container" style="margin-top:0.5rem;">'; 
            availableOriginalProfileNames.forEach(profileName => {
                html += `
                    <label class="selectable-route-tile rpd-profile-tile" style="background-color: #4A5568; color: white; border-color: transparent;" tabindex="0">
                        <input type="checkbox" class="rpd-profile-checkbox sr-only" value="${profileName}">
                        ${profileName}
                    </label>
                `;
            });
            html += '</div>';
            rpdProfileListContainer_el_extra.innerHTML = html;

            rpdProfileListContainer_el_extra.querySelectorAll('.rpd-profile-tile').forEach(tile => {
                const checkbox = tile.querySelector('.rpd-profile-checkbox');
                const toggleSelection = () => {
                    checkbox.checked = !checkbox.checked;
                    tile.classList.toggle('selected', checkbox.checked); 
                    tile.style.borderColor = checkbox.checked ? '#f1c40f' : 'transparent'; // Visual feedback
                    tile.setAttribute('aria-checked', checkbox.checked.toString());
                };
                tile.addEventListener('click', toggleSelection);
                tile.addEventListener('keydown', (e) => {
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        toggleSelection();
                    }
                });
            });
        }


        /**
         * @description Handles the deletion of selected route profiles.
         */
        async function handleDeleteRouteProfiles_ExtraPage() {
            if (!currentUser_extra || !window.firebaseOMSI) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Not logged in or Firebase not available."; rpdStatusMessage_el_extra.style.color = "#e74c3c";}
                return;
            }

            const routeName = rpdRouteInput_el_extra.value.trim();
            const destinationName = rpdDestinationInput_el_extra.value.trim(); // Optional, if empty means all destinations
            const selectedProfileCheckboxes = rpdProfileListContainer_el_extra.querySelectorAll('.rpd-profile-checkbox:checked');

            if (!routeName) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Please select a route."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}
                return;
            }
            if (selectedProfileCheckboxes.length === 0) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Please select at least one profile to delete."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}
                return;
            }

            const profilesToDeleteOriginalNames = Array.from(selectedProfileCheckboxes).map(cb => cb.value);
            const saneRoute = sanitizeFirebaseKey(routeName);
            const saneDest = destinationName ? sanitizeFirebaseKey(destinationName) : null;

            let confirmMessage = `ARE YOU SURE?\nThis will delete ALL schedule entries for:\nRoute: "${routeName}"`;
            if (saneDest) {
                confirmMessage += `\nDestination: "${destinationName}"`;
            } else {
                confirmMessage += ` (across ALL its destinations)`;
            }
            confirmMessage += `\nFor Operating Profile(s): ${profilesToDeleteOriginalNames.join(', ')}\n\nThis action CANNOT BE UNDONE.`;

            if (!confirm(confirmMessage)) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Profile deletion cancelled."; rpdStatusMessage_el_extra.style.color = "";}
                return;
            }

            if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Deleting profiles from Firebase..."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}

            const { database, dbRemove, dbRef } = window.firebaseOMSI;
            const removalPromises = [];

            profilesToDeleteOriginalNames.forEach(profileName => {
                const saneProfile = sanitizeFirebaseKey(profileName);
                let pathToDelete;
                if (saneDest) { // Delete specific destination under profile
                    pathToDelete = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}/${saneProfile}/${saneDest}`;
                } else { // Delete entire profile node for the route
                    pathToDelete = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}/${saneProfile}`;
                }
                console.log("Firebase path marked for deletion:", pathToDelete);
                removalPromises.push(dbRemove(dbRef(database, pathToDelete)));
            });

            try {
                await Promise.all(removalPromises);
                console.log("Firebase removal operations complete for selected profiles.");

                const originalLength = currentWorkingSchedule_extra.length;
                currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
                    const routeMatch = entry.lineName === routeName;
                    const profileMatch = profilesToDeleteOriginalNames.includes(entry.OperatingProfile);
                    // If saneDest is specified, entry must match it. If saneDest is null, destination doesn't matter for removal of whole profile.
                    const destMatch = saneDest ? (entry.destinationName === destinationName) : true;
                    
                    return !(routeMatch && profileMatch && destMatch);
                });
                const removedCount = originalLength - currentWorkingSchedule_extra.length;
                console.log(`${removedCount} entries removed from local currentWorkingSchedule_extra.`);

                await updateAncillaryScheduleData_ExtraPage();

                if(rpdStatusMessage_el_extra) {
                    rpdStatusMessage_el_extra.textContent = `Successfully deleted ${profilesToDeleteOriginalNames.length} profile(s) (${removedCount} schedule entries affected) for route "${routeName}"${saneDest ? ' and destination "' + destinationName + '"' : ' (all destinations for those profiles)'}. Ancillary data updated.`;
                    rpdStatusMessage_el_extra.style.color = "#2ecc71";
                }
                
                rpd_populateProfileList_ExtraPage(); // Refresh profile list
                renderUIDependentElements_ExtraPage(); 

            } catch (error) {
                console.error("Error deleting route profiles:", error);
                if(rpdStatusMessage_el_extra) {
                    rpdStatusMessage_el_extra.textContent = "Error deleting profiles from Firebase: " + error.message;
                    rpdStatusMessage_el_extra.style.color = "#e74c3c";
                }
                alert("Failed to delete profiles from Firebase. Data might be inconsistent. It's recommended to reload data from Firebase or review carefully.");
            }
        }
        // ++ END Route Profile Deletion Functions ++

        const RSG_PROFILE_GROUPS_TO_MANAGE = [
    { individuals: ["Mo", "Tu", "We", "Th", "Fr"], groupProfile: "MF" },
    { individuals: ["MoSch", "TuSch", "WeSch", "ThSch", "FrSch"], groupProfile: "MFSch" },
    { individuals: ["MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"], groupProfile: "MFNSD" }
];

const RSG_PROFILE_INCOMPATIBILITY_RULES = {
    "Mo": ["MoSch", "MoNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MoSch": ["Mo", "MoNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MoNSD": ["Mo", "MoSch", "MF", "MFSch", "MFNSD", "AllDays"],
    "Tu": ["TuSch", "TuNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "TuSch": ["Tu", "TuNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "We": ["WeSch", "WeNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "Th": ["ThSch", "ThNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "Fr": ["FrSch", "FrNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MF": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MFSch", "MFNSD", "AllDays"],
    "MFSch": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MF", "MFNSD", "AllDays"],
    "MFNSD": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MF", "MFSch", "AllDays"],
    "Sa": ["SaNSD", "AllDays"],
    "SaNSD": ["Sa", "AllDays"],
    "Su": ["SuNSD", "AllDays"],
    "SuNSD": ["Su", "AllDays"],
    "AllDays": RSG_OPERATING_PROFILES_LIST.filter(p => p !== "AllDays"),
    "SchoolHoliday": ["AllDays", "MFSch", "MFNSD", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"],
    "BankHoliday": ["AllDays", "MFSch", "MFNSD", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"]
};

for (const keyProfile_extra in RSG_PROFILE_INCOMPATIBILITY_RULES) {
    RSG_PROFILE_INCOMPATIBILITY_RULES[keyProfile_extra].forEach(disabledProfile_extra => {
        if (!RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra]) {
            RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra] = [];
        }
        if (!RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra].includes(keyProfile_extra)) {
            RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra].push(keyProfile_extra);
        }
    });
}

const MASTER_VALID_PROFILE_COMBINATIONS_LIST_EXTRA = [
    "Mo", "Mo,Tu", "Mo,Tu,We", "Mo,Tu,We,Th", "Mo,Tu,We,Th,Sa", "Mo,Tu,We,Th,Sa,Su",
    "Mo,Tu,We,Th,Su", "Mo,Tu,We,Fr", "Mo,Tu,We,Fr,Sa", "Mo,Tu,We,Fr,Sa,Su",
    "Mo,Tu,We,Fr,Su", "Mo,Tu,We,Sa", "Mo,Tu,We,Sa,Su", "Mo,Tu,We,Su", "Mo,Tu,Th", "Mo,Tu,Th,Fr", "Mo,Tu,Th,Fr,Sa", 
    "Mo,Tu,Th,Fr,Su", "Mo,Tu,Th,Fr,Sa,Su", "Mo,Tu,Th,Sa", "Mo,Tu,Th,Sa,Su", "Mo,Tu,Th,Su", "Mo,Tu,Fr",
    "Mo,Tu,Fr,Sa", "Mo,Tu,Fr,Sa,Su", "Mo,Tu,Fr,Su", "Mo,Tu,Sa", "Mo,Tu,Sa,Su", "Mo,Tu,Su", "Mo,We",
    "Mo,We,Th", "Mo,We,Th,Fr", "Mo,We,Th,Fr,Sa", "Mo,We,Th,Fr,Sa,Su", "Mo,We,Th,Fr,Su",
    "Mo,We,Th,Sa", "Mo,We,Th,Sa,Su", "Mo,We,Th,Su", "Mo,We,Fr", "Mo,We,Fr,Sa",
    "Mo,We,Fr,Sa,Su", "Mo,We,Fr,Su", "Mo,We,Sa", "Mo,We,Sa,Su", "Mo,We,Su", "Mo,Th",
    "Mo,Th,Fr", "Mo,Th,Fr,Sa", "Mo,Th,Fr,Sa,Su", "Mo,Th,Fr,Su", "Mo,Th,Sa",
    "Mo,Th,Sa,Su", "Mo,Th,Su", "Mo,Fr", "Mo,Fr,Sa", "Mo,Fr,Sa,Su", "Mo,Fr,Su", "Mo,Sa",
    "Mo,Sa,Su", "Mo,Su",
    "MoSch", "MoSch,TuSch", "MoSch,TuSch,WeSch", "MoSch,TuSch,WeSch,ThSch", "MoSch,TuSch,WeSch,FrSch",
    "MoSch,TuSch,ThSch", "MoSch,TuSch,ThSch,FrSch", "MoSch,TuSch,FrSch", "MoSch,WeSch",
    "MoSch,WeSch,ThSch", "MoSch,WeSch,ThSch,FrSch", "MoSch,WeSch,FrSch", "MoSch,ThSch",
    "MoSch,ThSch,FrSch", "MoSch,FrSch",
    "MoNSD", "MoNSD,TuNSD", "MoNSD,TuNSD,WeNSD", "MoNSD,TuNSD,WeNSD,ThNSD", "MoNSD,TuNSD,WeNSD,FrNSD",
    "MoNSD,TuNSD,ThNSD", "MoNSD,TuNSD,ThNSD,FrNSD", "MoNSD,TuNSD,FrNSD", "MoNSD,WeNSD",
    "MoNSD,WeNSD,ThNSD", "MoNSD,WeNSD,ThNSD,FrNSD", "MoNSD,WeNSD,FrNSD", "MoNSD,ThNSD",
    "MoNSD,ThNSD,FrNSD", "MoNSD,FrNSD",
    "Tu", "Tu,We", "Tu,We,Th", "Tu,We,Th,Fr", "Tu,We,Th,Fr,Sa", "Tu,We,Th,Fr,Sa,Su",
    "Tu,We,Th,Fr,Su", "Tu,We,Th,Sa", "Tu,We,Th,Sa,Su", "Tu,We,Th,Su", "Tu,We,Fr",
    "Tu,We,Fr,Sa", "Tu,We,Fr,Sa,Su", "Tu,We,Fr,Su", "Tu,We,Sa", "Tu,We,Sa,Su", "Tu,We,Su",
    "Tu,Th", "Tu,Th,Fr", "Tu,Th,Fr,Sa", "Tu,Th,Fr,Sa,Su", "Tu,Th,Fr,Su", "Tu,Th,Sa",
    "Tu,Th,Sa,Su", "Tu,Th,Su", "Tu,Fr", "Tu,Fr,Sa", "Tu,Fr,Sa,Su", "Tu,Fr,Su", "Tu,Sa",
    "Tu,Sa,Su", "Tu,Su",
    "TuSch", "TuSch,WeSch", "TuSch,WeSch,ThSch", "TuSch,WeSch,FrSch", "TuSch,ThSch", "TuSch,ThSch,FrSch",
    "TuSch,FrSch",
    "TuNSD", "TuNSD,WeNSD", "TuNSD,WeNSD,ThNSD", "TuNSD,WeNSD,ThNSD,FrNSD", "TuNSD,WeNSD,FrNSD",
    "TuNSD,ThNSD", "TuNSD,ThNSD,FrNSD", "TuNSD,FrNSD",
    "We", "We,Th", "We,Th,Fr", "We,Th,Fr,Sa", "We,Th,Fr,Sa,Su", "We,Th,Fr,Su", "We,Th,Sa",
    "We,Th,Sa,Su", "We,Th,Su", "We,Fr", "We,Fr,Sa", "We,Fr,Sa,Su", "We,Fr,Su", "We,Sa",
    "We,Sa,Su", "We,Su",
    "WeSch", "WeSch,ThSch", "WeSch,ThSch,FrSch", "WeSch,FrSch",
    "WeNSD", "WeNSD,ThNSD", "WeNSD,ThNSD,FrNSD", "WeNSD,FrNSD",
    "Th", "Th,Fr", "Th,Fr,Sa", "Th,Fr,Sa,Su", "Th,Fr,Su", "Th,Sa", "Th,Sa,Su", "Th,Su",
    "ThSch", "ThSch,FrSch",
    "ThNSD", "ThNSD,FrNSD",
    "Fr", "Fr,Sa", "Fr,Sa,Su", "Fr,Su",
    "FrSch", "FrNSD",
    "MF", "MF,Sa", "MF,Sa,Su", "MF,Su",
    "MFSch", "MFNSD",
    "Sa", "Sa,Su",
    "Su",
    "Christmas Eve",
    "Christmas Day",
    "Boxing Day",
    "New Years Eve",
    "New Years Day",
    "Special",
    "SpMo",
    "SpTu",
    "SpWe",
    "SpTh",
    "SpFr",
    "SpSa",
    "SpSu"
];

// --- DPO Specific Rules ---
const DPO_PROFILE_GROUPS_TO_MANAGE = [
    { individuals: ["Mo", "Tu", "We", "Th", "Fr"], groupProfile: "MF" },
    { individuals: ["MoSch", "TuSch", "WeSch", "ThSch", "FrSch"], groupProfile: "MFSch" },
    { individuals: ["MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"], groupProfile: "MFNSD" }
];

const DPO_MASTER_VALID_PROFILE_COMBINATIONS_LIST = [
    "Mo", "Mo,Tu", "Mo,Tu,We", "Mo,Tu,We,Th", "Mo,Tu,We,Th,Sa", "Mo,Tu,We,Th,Sa,Su",
    "Mo,Tu,We,Th,Su", "Mo,Tu,We,Fr", "Mo,Tu,We,Fr,Sa", "Mo,Tu,We,Fr,Sa,Su",
    "Mo,Tu,We,Fr,Su", "Mo,Tu,We,Sa", "Mo,Tu,We,Sa,Su", "Mo,Tu,We,Su", "Mo,Tu,Th", "Mo,Tu,Th,Fr", "Mo,Tu,Th,Fr,Sa", 
    "Mo,Tu,Th,Fr,Su", "Mo,Tu,Th,Fr,Sa,Su", "Mo,Tu,Th,Sa", "Mo,Tu,Th,Sa,Su", "Mo,Tu,Th,Su", "Mo,Tu,Fr",
    "Mo,Tu,Fr,Sa", "Mo,Tu,Fr,Sa,Su", "Mo,Tu,Fr,Su", "Mo,Tu,Sa", "Mo,Tu,Sa,Su", "Mo,Tu,Su", "Mo,We",
    "Mo,We,Th", "Mo,We,Th,Fr", "Mo,We,Th,Fr,Sa", "Mo,We,Th,Fr,Sa,Su", "Mo,We,Th,Fr,Su",
    "Mo,We,Th,Sa", "Mo,We,Th,Sa,Su", "Mo,We,Th,Su", "Mo,We,Fr", "Mo,We,Fr,Sa",
    "Mo,We,Fr,Sa,Su", "Mo,We,Fr,Su", "Mo,We,Sa", "Mo,We,Sa,Su", "Mo,We,Su", "Mo,Th",
    "Mo,Th,Fr", "Mo,Th,Fr,Sa", "Mo,Th,Fr,Sa,Su", "Mo,Th,Fr,Su", "Mo,Th,Sa",
    "Mo,Th,Sa,Su", "Mo,Th,Su", "Mo,Fr", "Mo,Fr,Sa", "Mo,Fr,Sa,Su", "Mo,Fr,Su", "Mo,Sa",
    "Mo,Sa,Su", "Mo,Su",
    "MoSch", "MoSch,TuSch", "MoSch,TuSch,WeSch", "MoSch,TuSch,WeSch,ThSch", "MoSch,TuSch,WeSch,FrSch",
    "MoSch,TuSch,ThSch", "MoSch,TuSch,ThSch,FrSch", "MoSch,TuSch,FrSch", "MoSch,WeSch",
    "MoSch,WeSch,ThSch", "MoSch,WeSch,ThSch,FrSch", "MoSch,WeSch,FrSch", "MoSch,ThSch",
    "MoSch,ThSch,FrSch", "MoSch,FrSch",
    "MoNSD", "MoNSD,TuNSD", "MoNSD,TuNSD,WeNSD", "MoNSD,TuNSD,WeNSD,ThNSD", "MoNSD,TuNSD,WeNSD,FrNSD",
    "MoNSD,TuNSD,ThNSD", "MoNSD,TuNSD,ThNSD,FrNSD", "MoNSD,TuNSD,FrNSD", "MoNSD,WeNSD",
    "MoNSD,WeNSD,ThNSD", "MoNSD,WeNSD,ThNSD,FrNSD", "MoNSD,WeNSD,FrNSD", "MoNSD,ThNSD",
    "MoNSD,ThNSD,FrNSD", "MoNSD,FrNSD",
    "Tu", "Tu,We", "Tu,We,Th", "Tu,We,Th,Fr", "Tu,We,Th,Fr,Sa", "Tu,We,Th,Fr,Sa,Su",
    "Tu,We,Th,Fr,Su", "Tu,We,Th,Sa", "Tu,We,Th,Sa,Su", "Tu,We,Th,Su", "Tu,We,Fr",
    "Tu,We,Fr,Sa", "Tu,We,Fr,Sa,Su", "Tu,We,Fr,Su", "Tu,We,Sa", "Tu,We,Sa,Su", "Tu,We,Su",
    "Tu,Th", "Tu,Th,Fr", "Tu,Th,Fr,Sa", "Tu,Th,Fr,Sa,Su", "Tu,Th,Fr,Su", "Tu,Th,Sa",
    "Tu,Th,Sa,Su", "Tu,Th,Su", "Tu,Fr", "Tu,Fr,Sa", "Tu,Fr,Sa,Su", "Tu,Fr,Su", "Tu,Sa",
    "Tu,Sa,Su", "Tu,Su",
    "TuSch", "TuSch,WeSch", "TuSch,WeSch,ThSch", "TuSch,WeSch,FrSch", "TuSch,ThSch", "TuSch,ThSch,FrSch",
    "TuSch,FrSch",
    "TuNSD", "TuNSD,WeNSD", "TuNSD,WeNSD,ThNSD", "TuNSD,WeNSD,ThNSD,FrNSD", "TuNSD,WeNSD,FrNSD",
    "TuNSD,ThNSD", "TuNSD,ThNSD,FrNSD", "TuNSD,FrNSD",
    "We", "We,Th", "We,Th,Fr", "We,Th,Fr,Sa", "We,Th,Fr,Sa,Su", "We,Th,Fr,Su", "We,Th,Sa",
    "We,Th,Sa,Su", "We,Th,Su", "We,Fr", "We,Fr,Sa", "We,Fr,Sa,Su", "We,Fr,Su", "We,Sa",
    "We,Sa,Su", "We,Su",
    "WeSch", "WeSch,ThSch", "WeSch,ThSch,FrSch", "WeSch,FrSch",
    "WeNSD", "WeNSD,ThNSD", "WeNSD,ThNSD,FrNSD", "WeNSD,FrNSD",
    "Th", "Th,Fr", "Th,Fr,Sa", "Th,Fr,Sa,Su", "Th,Fr,Su", "Th,Sa", "Th,Sa,Su", "Th,Su",
    "ThSch", "ThSch,FrSch",
    "ThNSD", "ThNSD,FrNSD",
    "Fr", "Fr,Sa", "Fr,Sa,Su", "Fr,Su",
    "FrSch", "FrNSD",
    "MF", "MF,Sa", "MF,Sa,Su", "MF,Su",
    "MFSch", "MFNSD",
    "Sa", "Sa,Su",
    "Su",
    "Christmas Eve", "Christmas Eve,Sa",
    "Christmas Day",
    "Boxing Day", "Boxing Day,Sa,Su",
    "New Years Eve", "New Years Eve,Sa",
    "New Years Day", "New Years Day,Su",
    "Special",
    "SpMo",
    "SpTu",
    "SpWe",
    "SpTh",
    "SpFr",
    "SpSa",
    "SpSu"
];

// Helper function for DPO (can be identical to rsg_getCanonicalProfileString)
function dpo_getCanonicalProfileString_ExtraPage(profileArray) {
    if (!Array.isArray(profileArray)) return "";
    return profileArray.map(p => String(p).trim()).sort((a,b) => a.localeCompare(b)).join(',');
}

// Create the Set for DPO valid combinations
const DPO_VALID_PROFILE_COMBINATIONS_SET = new Set(
    DPO_MASTER_VALID_PROFILE_COMBINATIONS_LIST.map(s => dpo_getCanonicalProfileString_ExtraPage(s.split(',')))
);

function showNativeNotification(title, body, iconUrl = '/live-tracker/assets/icons/icon-192x192.png') {
    if (!("Notification" in window)) {
        console.warn("Desktop notifications not supported by this browser.");
        // Optionally, call your popup here as a fallback if browser doesn't support Notification API
        // if (typeof showTripAlertPopup_ExtraPage === 'function') { showTripAlertPopup_ExtraPage(title + ": " + body); }
        return;
    }
    if (Notification.permission === "granted") {
        try {
            const options = {
                body: body,
                // Ensure the icon path is correct and accessible from your domain.
                // If unsure, test with icon: undefined or icon: '' first.
                icon: iconUrl || undefined 
            };
            const notification = new Notification(title, options);

            // You can add event listeners to the notification if needed
            // notification.onclick = () => { console.log('Notification clicked'); window.focus(); this.close(); };
        } catch (e) {
            console.error("Error creating native notification:", e);
            // Fallback to the popup if native notification fails (e.g., bad icon, browser issue)
            if (typeof showTripAlertPopup_ExtraPage === 'function') {
                showTripAlertPopup_ExtraPage(`Native Notification Error: ${title} - ${body}. Details: ${e.message}`);
            }
        }
    } else {
        // If permission isn't granted, it means the conditions in checkAndShowTripAlerts_ExtraPage
        // should have already routed to the popup. This is an extra check.
        console.warn("Native notification requested, but permission is not 'granted'. Current permission: " + Notification.permission);
        // Optionally, show the popup here too if it's an unexpected state
        // if (typeof showTripAlertPopup_ExtraPage === 'function') { showTripAlertPopup_ExtraPage(title + ": " + body + " (Permission: " + Notification.permission + ")");}
    }
}

function dpo_simulateAutoGroup_ExtraPage(selectedProfilesArray) {
    let simulatedSelections = [...selectedProfilesArray]; 
    // Use DPO_PROFILE_GROUPS_TO_MANAGE defined above
    DPO_PROFILE_GROUPS_TO_MANAGE.forEach(group => { 
        const allIndividualsPresent = group.individuals.every(ind => simulatedSelections.includes(ind));
        if (allIndividualsPresent) {
            // If all individuals in a group are selected, replace them with the group profile
            simulatedSelections = simulatedSelections.filter(p => !group.individuals.includes(p)); 
            if (!simulatedSelections.includes(group.groupProfile)) {
                simulatedSelections.push(group.groupProfile); 
            }
        }
        // If a group profile is selected, ensure individuals are not also in the simulated selection
        // (This part of logic might need refinement based on desired DPO behavior vs RSG)
        // For DPO, typically you select what you want, and grouping might be less about auto-checking
        // and more about what the final "effective" profile string is.
        // If DPO_PROFILE_GROUPS_TO_MANAGE is empty, this loop does nothing.
    });
    return simulatedSelections; // Return the (potentially modified) array of selected profiles
}

// Helper function to create a canonical string (sorted, comma-separated)
function rsg_getCanonicalProfileString(profileArray) {
    if (!Array.isArray(profileArray)) return "";
    return profileArray.map(p => String(p).trim()).sort((a,b) => a.localeCompare(b)).join(',');
}

const VALID_PROFILE_COMBINATIONS_SET = new Set(
    MASTER_VALID_PROFILE_COMBINATIONS_LIST_EXTRA.map(s => rsg_getCanonicalProfileString(s.split(',')))
);

function rsg_showSaveConfigModal_ExtraPage() {
    const routeNameInput = rsgRouteNameInput_el_extra;
    const destinationNameInput = rsgDestinationNameInput_el_extra;
    // rsg_getSelectedOpProfilesString_ExtraPage() will be called to get current profiles
    const configNameInput = document.getElementById('rsg-config-name-input-extra');
    const modal = document.getElementById('rsg-save-config-modal-extra');
    const modalStatus = document.getElementById('rsg-save-config-modal-status-extra');

    if (!routeNameInput || !destinationNameInput || !configNameInput || !modal || !modalStatus) {
        console.error("RSG Save Modal Error: One or more essential DOM elements are missing.");
        if (rsgStatusMessage_el_extra) { 
            rsgStatusMessage_el_extra.textContent = "Error: Save dialog components missing.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const currentRouteName = routeNameInput.value.trim();
    const currentDestName = destinationNameInput.value.trim();
    const currentOpProfiles = rsg_getSelectedOpProfilesString_ExtraPage();

    if (!currentRouteName || !currentDestName || !currentOpProfiles) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route, Destination, and at least one Operating Profile must be selected to suggest a name for saving.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    
    if (!rsg_selectedStops_extra || rsg_selectedStops_extra.length === 0 || !rsgFirstStopTimesInput_el_extra || !rsgFirstStopTimesInput_el_extra.value.trim()) {
       if (rsgStatusMessage_el_extra) {
           rsgStatusMessage_el_extra.textContent = "Stop Sequence and First Stop Times are required to save a configuration.";
           rsgStatusMessage_el_extra.style.color = "#f1c40f";
       }
       return;
   }

    let defaultConfigName;

    if (rsg_currentlyEditingConfigKey_extra && rsg_currentlyEditingConfigDisplayName_extra) {
        defaultConfigName = rsg_currentlyEditingConfigDisplayName_extra;
    } else {
        const defaultNameRoutePart = currentRouteName.replace(/[^a-zA-Z0-9\s,-]/g, '').trim() || "Route";
        const defaultNameDestPart = currentDestName.replace(/[^a-zA-Z0-9\s,-]/g, '').trim() || "Dest";
        const defaultNameProfilePart = currentOpProfiles.replace(/[^a-zA-Z0-9\s,-]/g, '').trim() || "Profile";
        defaultConfigName = `${defaultNameRoutePart} to ${defaultNameDestPart} - ${defaultNameProfilePart}`;
    }

    configNameInput.value = defaultConfigName;
    if (modalStatus) { // Ensure modalStatus element exists before setting its properties
        modalStatus.textContent = ''; 
        modalStatus.style.color = ''; // Reset color
    }
    modal.style.display = 'flex';
}

function rsg_hideSaveConfigModal_ExtraPage() {
    const modal = document.getElementById('rsg-save-config-modal-extra');
    if (modal) modal.style.display = 'none';
}

async function saveSpecificRouteDataToFirebase_ExtraPage(targetRouteName) {
    if (!currentUser_extra || !window.firebaseOMSI || !window.firebaseOMSI.database) {
        console.error("saveSpecificRouteDataToFirebase_ExtraPage: Not logged in or Firebase not available.");
        // Potentially update a status message for the user
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Error: Cannot save route - not logged in or Firebase connection issue.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        throw new Error("Authentication or Firebase connection issue.");
    }

    const { database, dbSet, dbRef, dbRemove } = window.firebaseOMSI; // Ensure dbRemove is destructured
    const saneRouteToUpdate = sanitizeFirebaseKey(targetRouteName); // Assuming sanitizeFirebaseKey is globally available
    const routePathInFirebase = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRouteToUpdate}`;

    console.log(`saveSpecificRouteDataToFirebase_ExtraPage: Preparing to update route "${targetRouteName}" (sanitized: "${saneRouteToUpdate}") in Firebase.`);

    // Filter currentWorkingSchedule_extra to get all entries ONLY for the targetRouteName
    const entriesForThisRoute = currentWorkingSchedule_extra.filter(
        e => e.lineName && e.lineName.toUpperCase() === targetRouteName.toUpperCase()
    );

    if (entriesForThisRoute.length === 0) {
        // If the route now has no entries (e.g., user deleted all its schedules via RSG overwrite with empty)
        // then we should delete this route's node in Firebase.
        console.log(`Route "${targetRouteName}" has no schedule entries in currentWorkingSchedule_extra. Removing its node from Firebase at ${routePathInFirebase}.`);
        try {
            await dbRemove(dbRef(database, routePathInFirebase));
            console.log(`Successfully removed node for route "${targetRouteName}" from Firebase.`);
        } catch (error) {
            console.error(`Error removing node for empty route "${targetRouteName}" from Firebase:`, error);
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Error clearing empty route "${targetRouteName}" in Firebase: ${error.message}`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            // We should still proceed to update ancillary data even if removal fails,
            // as the local schedule (which ancillary data is based on) reflects the route as empty.
        }
    } else {
        // Build the structured data for this specific route
        const routeDataForFirebase = {}; // This will hold { profileKey: { destKey: { entries: [] } } }

        entriesForThisRoute.forEach(entry => {
            // Ensure necessary fields are present for structuring
            if (!entry.OperatingProfile || !entry.destinationName) {
                console.warn("saveSpecificRouteDataToFirebase_ExtraPage: Skipping entry with missing OperatingProfile or destinationName:", entry);
                return;
            }
            const saneProfile = sanitizeFirebaseKey(entry.OperatingProfile);
            const saneDest = sanitizeFirebaseKey(entry.destinationName);

            if (!routeDataForFirebase[saneProfile]) {
                routeDataForFirebase[saneProfile] = {};
            }
            if (!routeDataForFirebase[saneProfile][saneDest]) {
                routeDataForFirebase[saneProfile][saneDest] = { entries: [] };
            }

            const entryForStorage = { ...entry };
            // Ensure these key fields are explicitly part of the stored entry object
            entryForStorage.lineName = entry.lineName;
            entryForStorage.OperatingProfile = entry.OperatingProfile;
            entryForStorage.destinationName = entry.destinationName;

            routeDataForFirebase[saneProfile][saneDest].entries.push(entryForStorage);
        });

        // Sort entries within each R/P/D for consistency
        for (const profileKey in routeDataForFirebase) {
            for (const destKey in routeDataForFirebase[profileKey]) {
                if (routeDataForFirebase[profileKey][destKey].entries) {
                    routeDataForFirebase[profileKey][destKey].entries.sort((a, b) => {
                        const timeA = (a.scheduledTime || "9999").replace(':', '');
                        const timeB = (b.scheduledTime || "9999").replace(':', '');
                        const timeCompare = timeA.localeCompare(timeB);
                        if (timeCompare !== 0) return timeCompare;
                        return (a.stopName || "").localeCompare(b.stopName || ""); // Secondary sort
                    });
                }
            }
        }
        
        console.log(`Attempting to save data for route "${targetRouteName}" to Firebase path: ${routePathInFirebase}`);
        try {
            await dbSet(dbRef(database, routePathInFirebase), routeDataForFirebase);
            console.log(`Successfully saved data for route "${targetRouteName}" to Firebase.`);
        } catch (error) {
             console.error(`Error saving data for route "${targetRouteName}" to Firebase:`, error);
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Error saving route "${targetRouteName}" to Firebase: ${error.message}`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            throw error; // Propagate error to the caller
        }
    }

    // After saving the specific route (or removing it if empty),
    // always update ancillary data based on the full currentWorkingSchedule_extra
    try {
        console.log(`Updating ancillary data after changes to route "${targetRouteName}".`);
        await updateAncillaryScheduleData_ExtraPage(); // This function should be async
        console.log(`Ancillary data updated successfully.`);
    } catch (error) {
        console.error(`Error updating ancillary data after saving route "${targetRouteName}":`, error);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Route data saved, but error updating ancillary data (like unique stops): ${error.message}`;
            // Keep the color as potentially error, or change to warning
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // Decide if this error should also be propagated
    }
}

async function rsg_performSaveConfiguration_ExtraPage() {
            console.log("RSG Save Process: Triggered.");
            const configNameInput = document.getElementById('rsg-config-name-input-extra');
            const modalStatus = document.getElementById('rsg-save-config-modal-status-extra');

            if (!configNameInput || !modalStatus) { /* ... error handling ... */ return; }

            const userDefinedConfigName = configNameInput.value.trim();
            if (!userDefinedConfigName) { /* ... error handling ... */ return; }

            console.log(`RSG Save Process: Modal name: "${userDefinedConfigName}". Currently Editing Key: '${rsg_currentlyEditingConfigKey_extra}', DisplayName: '${rsg_currentlyEditingConfigDisplayName_extra}'`);

            let firebaseKey = null;
            let operationType = ""; 
            // ... (your existing logic for determining firebaseKey and operationType) ...
            if (rsg_currentlyEditingConfigKey_extra && userDefinedConfigName === rsg_currentlyEditingConfigDisplayName_extra) {
                firebaseKey = rsg_currentlyEditingConfigKey_extra;
                operationType = "overwrite_loaded_config";
            } else { /* ... logic to findMatchForKey or create new ... */ 
                let foundMatchForKey = null;
                for (const keyInCache in rsg_loadedConfigs_extra) {
                    if (Object.hasOwnProperty.call(rsg_loadedConfigs_extra, keyInCache)) {
                        const existingConfig = rsg_loadedConfigs_extra[keyInCache];
                        if (existingConfig.userDisplayName === userDefinedConfigName) {
                            foundMatchForKey = keyInCache; break;
                        }
                    }
                }
                if (foundMatchForKey) {
                    firebaseKey = foundMatchForKey; operationType = "overwrite_other_by_display_name";
                } else {
                    firebaseKey = sanitizeFirebaseKey(userDefinedConfigName); operationType = "save_new_config";
                }
            }
            console.log(`RSG Save Process: Operation determined: ${operationType}, Firebase Key: ${firebaseKey}`);
            if (!firebaseKey) { /* ... error handling ... */ return; }
            
            // Synchronization step (ensure this accurately reflects the current UI for time adjustments)
            // The 'input' listeners on timeAdjInput should have already updated rsg_selectedStops_extra items.
            // This block can serve as a final explicit sync if needed, or can be simplified if array is trusted.
            console.log("RSG Save Process: Beginning final sync of time adjustments from UI to rsg_selectedStops_extra array.");
            if (rsgStopSequenceList_el_extra && rsg_selectedStops_extra) {
                const displayedStopItems = rsgStopSequenceList_el_extra.querySelectorAll('li[data-index]');
                displayedStopItems.forEach(li => {
                    const index = parseInt(li.dataset.index);
                    if (rsg_selectedStops_extra[index]) {
                        if (index === 0) { 
                            if(rsg_selectedStops_extra[index].timeAdjustment !== 0) rsg_selectedStops_extra[index].timeAdjustment = 0;
                        } else {
                            const timeAdjInput = li.querySelector('.rsg-time-adjustment-input');
                            if (timeAdjInput) {
                                const uiValue = parseInt(timeAdjInput.value, 10);
                                const currentArrayValue = rsg_selectedStops_extra[index].timeAdjustment;
                                if (!isNaN(uiValue) && uiValue >= 0) {
                                    if (currentArrayValue !== uiValue) {
                                        console.log(`RSG Save Sync: Updating index ${index} from UI value ${uiValue} (was ${currentArrayValue})`);
                                        rsg_selectedStops_extra[index].timeAdjustment = uiValue;
                                    }
                                } else {
                                    if (currentArrayValue !== 0) {
                                        console.log(`RSG Save Sync: Invalid UI value for index ${index} ("${timeAdjInput.value}"), setting to 0 (was ${currentArrayValue})`);
                                        rsg_selectedStops_extra[index].timeAdjustment = 0;
                                    }
                                }
                            } else if (typeof rsg_selectedStops_extra[index].timeAdjustment === 'undefined' || rsg_selectedStops_extra[index].timeAdjustment === null) {
                                 console.log(`RSG Save Sync: No input or undefined adjustment for index ${index}, setting to 0.`);
                                rsg_selectedStops_extra[index].timeAdjustment = 0; 
                            }
                        }
                    }
                });
            }
            console.log("RSG Save Process: Finished final sync of time adjustments.");

            const currentRouteName = rsgRouteNameInput_el_extra.value.trim();
            const currentDestName = rsgDestinationNameInput_el_extra.value.trim();
            const currentOpProfiles = rsg_getSelectedOpProfilesString_ExtraPage();
            const stopSequenceToSave = rsg_selectedStops_extra; // This array should reflect removed stops and time edits
            const firstStopTimesToSave = rsgFirstStopTimesInput_el_extra.value.trim();

            // Detailed logging of what's about to be saved
            console.log("RSG Save Process: Data to be packaged for Firebase:");
            console.log(`  - User Display Name: "${userDefinedConfigName}"`);
            console.log(`  - Route Name: "${currentRouteName}"`);
            console.log(`  - Dest Name: "${currentDestName}"`);
            console.log(`  - Op Profiles: "${currentOpProfiles}"`);
            console.log(`  - First Stop Times: "${firstStopTimesToSave}"`);
            console.log(`  - Stop Sequence Length: ${stopSequenceToSave.length}`);
            console.log("  - Stop Sequence (sample - first 5, with ID, Name, Adjustment):", 
                stopSequenceToSave.slice(0,5).map(s => ({id:s.stopID, name:s.stopName, adj:s.timeAdjustment}))
            );

            if (!currentRouteName || !currentDestName || !currentOpProfiles || stopSequenceToSave.length === 0 || !firstStopTimesToSave) {
                modalStatus.textContent = "Cannot save: All fields (Route, Dest, Profile, Sequence, Times) are required.";
                modalStatus.style.color = "#e74c3c";
                return;
            }

            const configurationToSave = {
                userDisplayName: userDefinedConfigName, 
                routeName: currentRouteName,
                destinationName: currentDestName,
                operatingProfile: currentOpProfiles,
                stopSequence: JSON.parse(JSON.stringify(stopSequenceToSave)), 
                firstStopTimes: firstStopTimesToSave,
                lastSaved: new Date().toISOString()
            };
            
            modalStatus.textContent = `Saving configuration "${userDefinedConfigName}"...`;
            // ... (Firebase save logic as before) ...
            const { database, dbSet, dbRef } = window.firebaseOMSI;
            try {
                const fullSavePath = `${FB_PATH_RSG_CONFIGS}/${firebaseKey}`;
                await dbSet(dbRef(database, fullSavePath), configurationToSave);
                
                rsg_loadedConfigs_extra[firebaseKey] = JSON.parse(JSON.stringify(configurationToSave)); 
                rsg_renderSavedConfigsList_ExtraPage(); 

                modalStatus.textContent = `Configuration "${userDefinedConfigName}" saved successfully!`;
                // ... (status updates and context variable updates as before) ...
                rsg_currentlyEditingConfigKey_extra = firebaseKey;
                rsg_currentlyEditingConfigDisplayName_extra = userDefinedConfigName;
                rsg_lastLoadedRouteName_extra = currentRouteName;
                rsg_lastLoadedDestName_extra = currentDestName;
                rsg_lastLoadedOpProfile_extra = currentOpProfiles;
                
                rsg_isDirty = false; 
                console.log("RSG State: Configuration saved successfully, rsg_isDirty reset to false.");

                setTimeout(rsg_hideSaveConfigModal_ExtraPage, 1500);
            } catch (error) {
                // ... (error handling as before) ...
                console.error("Error saving RSG configuration to Firebase:", error);
                modalStatus.textContent = "Error saving configuration: " + error.message;
            }
        }

async function rsg_performRenameConfiguration_ExtraPage(configKeyToRename, newDisplayName) {
    const statusElement = document.getElementById('rsg-load-status-message-extra'); // Use the status message for the saved configs list

    if (!configKeyToRename) {
        if (statusElement) {
            statusElement.textContent = "Error: No configuration key provided for renaming.";
            statusElement.style.color = "#e74c3c";
        }
        console.error("rsg_performRenameConfiguration_ExtraPage: configKeyToRename is missing.");
        return;
    }

    // newDisplayName is assumed to be non-empty and trimmed by the caller
    // If it could still be empty, an additional check here would be good. For now, we assume caller handles it.

    const configToUpdate = rsg_loadedConfigs_extra[configKeyToRename];
    if (!configToUpdate) {
        if (statusElement) {
            statusElement.textContent = "Error: Original configuration data could not be found. Cannot rename.";
            statusElement.style.color = "#e74c3c";
        }
        console.error(`Failed to find config data for key: ${configKeyToRename} in rsg_loadedConfigs_extra.`);
        return;
    }

    if (statusElement) {
        statusElement.textContent = `Renaming configuration to "${newDisplayName}"...`;
        statusElement.style.color = "#f1c40f";
    }

    const updatedConfigData = {
        ...configToUpdate,
        userDisplayName: newDisplayName, // Already trimmed by caller
        lastSaved: new Date().toISOString()
    };

    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        await dbSet(dbRef(database, `${FB_PATH_RSG_CONFIGS}/${configKeyToRename}`), updatedConfigData);
        rsg_loadedConfigs_extra[configKeyToRename] = updatedConfigData; // Update local cache
        rsg_renderSavedConfigsList_ExtraPage(); // Refresh the displayed list

        if (statusElement) {
            statusElement.textContent = `Configuration successfully renamed to "${newDisplayName}"!`;
            statusElement.style.color = "#2ecc71";
        }
        // No modal to hide anymore for this process
    } catch (error) {
        console.error("Error renaming RSG configuration in Firebase:", error);
        if (statusElement) {
            statusElement.textContent = "Error renaming configuration: " + error.message;
            statusElement.style.color = "#e74c3c";
        }
    }
}

function toTitleCase_rsg(str) {
    if (!str || typeof str !== 'string') return "";
    // This will convert "LAKESIDE" to "Lakeside", "HIGH STREET" to "High Street", etc.
    return str.replace(/\w\S*/g, function(txt){
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
}

function rsg_handleSavedConfigCheckboxChange_ExtraPage() {
    const checkboxes = document.querySelectorAll('.rsg-saved-config-checkbox');
    const tickedCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox:checked');
    const tickedCount = tickedCheckboxes.length;

    if (rsgScheduleSelectedConfigsButton_el_extra) {
        rsgScheduleSelectedConfigsButton_el_extra.disabled = (tickedCount === 0);
    }

    const disableMainActions = tickedCount > 1;

    if (rsgGenerateScheduleButton_el_extra) {
        rsgGenerateScheduleButton_el_extra.disabled = disableMainActions;
    }
    if (rsgSaveConfigurationButton_el_extra) {
        rsgSaveConfigurationButton_el_extra.disabled = disableMainActions;
    }
    if (rsgAddToWorkingScheduleButton_el_extra) {
        if (disableMainActions) {
            rsgAddToWorkingScheduleButton_el_extra.disabled = true;
            rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
            rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
        } else {
            const previewExistsForMainForm = rsg_generatedPreviewEntries_extra && rsg_generatedPreviewEntries_extra.length > 0;
            rsgAddToWorkingScheduleButton_el_extra.disabled = !previewExistsForMainForm;
             if (previewExistsForMainForm) {
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.add('save');
            } else {
                rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
            }
        }
    }
    rsg_updateSelectAllCheckboxesStates();
}

async function rsg_handleScheduleSelectedConfigs_ExtraPage() {
    console.log("Batch Scheduling: Starting for selected saved configs.");
    if (!currentUser_extra) {
        alert("Please log in to schedule configurations.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Please log in.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const tickedCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox:checked');
    if (tickedCheckboxes.length === 0) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "No saved configurations selected to schedule.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    rsg_batchScheduleItems = []; // Clear previous batch items
    let validConfigsForBatchCount = 0;
    let firstInvalidConfigName = null;

    for (const checkbox of tickedCheckboxes) {
        const configKey = checkbox.dataset.configKey;
        const configData = rsg_loadedConfigs_extra[configKey];

        if (configData) {
            // Validate this config by trying to generate its preview entries (isPreCheck = true)
            // rsg_handleGenerateSchedulePreview_ExtraPage will populate rsg_generatedPreviewEntries_extra
            if (rsg_handleGenerateSchedulePreview_ExtraPage(true, configData)) {
                rsg_batchScheduleItems.push({
                    configKey: configKey, // Keep key for reference
                    userDisplayName: configData.userDisplayName || configKey,
                    routeName: configData.routeName,
                    destinationName: configData.destinationName,
                    operatingProfile: configData.operatingProfile,
                    stopSequence: JSON.parse(JSON.stringify(configData.stopSequence)), // Deep copy
                    firstStopTimes: configData.firstStopTimes,
                    scheduledEntries: JSON.parse(JSON.stringify(rsg_generatedPreviewEntries_extra)) // Crucial: copy the generated entries for this config
                });
                validConfigsForBatchCount++;
            } else {
                console.warn(`Batch Scheduling: Config "${configData.userDisplayName || configKey}" is invalid or produced no entries. Skipping.`);
                if (!firstInvalidConfigName) firstInvalidConfigName = configData.userDisplayName || configKey;
            }
        } else {
            console.warn(`Batch Scheduling: Could not find config data for key ${configKey}. Skipping.`);
             if (!firstInvalidConfigName) firstInvalidConfigName = `Key: ${configKey}`;
        }
    }
    
    // Clear the global preview entries after batch processing is done, so it doesn't interfere with main form.
    rsg_generatedPreviewEntries_extra = [];

    if (rsg_batchScheduleItems.length > 0) {
        const scheduleModal = document.getElementById('rsg-schedule-datetime-modal-extra');
        if (scheduleModal) {
            const modalStatus = document.getElementById('rsg-schedule-datetime-modal-status-extra');
            if (modalStatus) {
                 modalStatus.textContent = `Preparing to schedule ${rsg_batchScheduleItems.length} configuration(s). ${firstInvalidConfigName ? `Some (${tickedCheckboxes.length - validConfigsForBatchCount}) were skipped due to issues (e.g., ${firstInvalidConfigName}).` : ''}`;
                 modalStatus.style.color = firstInvalidConfigName ? "#f1c40f" : ""; // Yellow if some skipped
            }
            
            const goLiveInput = document.getElementById('rsg-go-live-datetime-input-extra');
            if (goLiveInput) { // Set default go-live time
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(5, 0, 0, 0); // Default 05:00 AM
                goLiveInput.value = `${tomorrow.getFullYear()}-${String(tomorrow.getMonth() + 1).padStart(2, '0')}-${String(tomorrow.getDate()).padStart(2, '0')}T${String(tomorrow.getHours()).padStart(2, '0')}:${String(tomorrow.getMinutes()).padStart(2, '0')}`;
            }
            scheduleModal.style.display = 'flex';
        } else {
            console.error("Batch Scheduling: Schedule DateTime modal not found!");
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Error: Scheduling modal component is missing.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
        }
    } else {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `No valid configurations to schedule. ${firstInvalidConfigName ? `Problem with "${firstInvalidConfigName}".` : 'Please check selected items.'}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
    }
}

function rsg_renderSavedConfigsList_ExtraPage() {
    const container = document.getElementById('rsg-saved-configs-list-extra');
    if (!container) {
        return;
    }
    container.innerHTML = '';

    const activeRouteNamesFromSchedule = [...new Set(
        currentWorkingSchedule_extra
            .map(entry => entry.lineName)
            .filter(Boolean)
    )];

    const configsByRouteFromSaved = {};
    if (rsg_loadedConfigs_extra && typeof rsg_loadedConfigs_extra === 'object') {
        Object.keys(rsg_loadedConfigs_extra).forEach(key => {
            const configData = rsg_loadedConfigs_extra[key];
            const routeNameFromConfig = configData.routeName || "Unspecified Route";
            if (!configsByRouteFromSaved[routeNameFromConfig]) {
                configsByRouteFromSaved[routeNameFromConfig] = [];
            }
            configsByRouteFromSaved[routeNameFromConfig].push({ key: key, data: configData });
        });
    }

    const allRouteNamesToDisplaySet = new Set([
        ...activeRouteNamesFromSchedule,
        ...Object.keys(configsByRouteFromSaved).filter(rn => rn !== "Unspecified Route")
    ]);
    const sortedAllRouteNamesToDisplay = Array.from(allRouteNamesToDisplaySet).sort(compareLineNames_ExtraPage);

    if (sortedAllRouteNamesToDisplay.length === 0 && !(configsByRouteFromSaved["Unspecified Route"] && configsByRouteFromSaved["Unspecified Route"].length > 0)) {
        const p = document.createElement('p');
        p.id = "rsg-no-saved-configs-message-extra";
        p.style.padding = "0.5em";
        p.style.textAlign = "center";
        p.style.opacity = "0.7";
        p.textContent = "No active routes in schedule and no configurations saved yet.";
        container.appendChild(p);
        rsg_updateSelectAllCheckboxesStates(); // Update even if no items
        return;
    }

    sortedAllRouteNamesToDisplay.forEach(routeName => {
        const routeHeadingContainer = document.createElement('div');
        routeHeadingContainer.style.display = 'flex';
        routeHeadingContainer.style.alignItems = 'center';
        routeHeadingContainer.style.marginTop = "0.8em";
        routeHeadingContainer.style.marginBottom = "0.4em";
        routeHeadingContainer.style.borderBottom = "1px solid rgba(127,140,141,0.3)";
        routeHeadingContainer.style.paddingBottom = "0.2em";
         if (container.children.length > 0 && container.lastChild.tagName !== 'H4' && container.lastChild.firstChild?.tagName !== 'H4') { // check if previous was not a heading
            routeHeadingContainer.style.marginTop = "1.2em";
        }


        const routeSelectAllCheckbox = document.createElement('input');
        routeSelectAllCheckbox.type = 'checkbox';
        routeSelectAllCheckbox.classList.add('rsg-select-route-configs-checkbox-extra');
        routeSelectAllCheckbox.dataset.routeName = routeName;
        routeSelectAllCheckbox.style.marginRight = '8px';
        routeSelectAllCheckbox.style.verticalAlign = 'middle';
        routeSelectAllCheckbox.addEventListener('change', rsg_handleSelectRouteConfigsChange_ExtraPage);
        routeHeadingContainer.appendChild(routeSelectAllCheckbox);

        const routeHeading = document.createElement('h4');
        routeHeading.textContent = `Route ${routeName}:`;
        routeHeading.style.margin = "0"; // Reset margin as it's inside a flex container
        routeHeading.style.fontSize = "1.1em";
        routeHeading.style.color = "#ecf0f1";
        routeHeadingContainer.appendChild(routeHeading);
        container.appendChild(routeHeadingContainer);

        const configsForThisRoute = configsByRouteFromSaved[routeName];

        if (configsForThisRoute && configsForThisRoute.length > 0) {
            configsForThisRoute.sort((a, b) => {
                const nameA = (a.data.userDisplayName || a.key).toLowerCase();
                const nameB = (b.data.userDisplayName || b.key).toLowerCase();
                const nameCompare = nameA.localeCompare(nameB);
                if (nameCompare !== 0) return nameCompare;
                const destA = a.data.destinationName || "";
                const destB = b.data.destinationName || "";
                return destA.localeCompare(destB);
            });

            configsForThisRoute.forEach(configItem => {
                const configKey = configItem.key;
                const configData = configItem.data;
                const originalUserDisplayName = configData.userDisplayName || configKey;
                const routeNameForDesc = configData.routeName || "N/A";
                let destinationNameForDesc = configData.destinationName || "N/A";
                if (destinationNameForDesc !== "N/A") {
                    destinationNameForDesc = toTitleCase_rsg(destinationNameForDesc);
                }
                let operatingProfileForDesc = configData.operatingProfile || "N/A";
                if (operatingProfileForDesc !== "N/A" && typeof operatingProfileForDesc === 'string') {
                    operatingProfileForDesc = operatingProfileForDesc.split(',')
                                                 .map(p => p.trim())
                                                 .join(', ');
                }
                const descriptiveParametersString = `${routeNameForDesc} to ${destinationNameForDesc} - ${operatingProfileForDesc}`;

                const itemDiv = document.createElement('div');
                itemDiv.style.padding = "0.4em 0.6em 0.4em 28px"; // Indent items under route's select all
                itemDiv.style.marginBottom = "0.3em";
                itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)";
                itemDiv.style.borderRadius = "0.25rem";
                itemDiv.style.display = "flex";
                itemDiv.style.justifyContent = "space-between";
                itemDiv.style.alignItems = "center";
                itemDiv.addEventListener('mouseover', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.1)");
                itemDiv.addEventListener('mouseout', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)");
                itemDiv.title = `Load: ${originalUserDisplayName}\n(Parameters: ${descriptiveParametersString})\n(Key: ${configKey})`;

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `rsg-config-checkbox-${configKey}`;
                checkbox.dataset.configKey = configKey;
                checkbox.dataset.parentRouteName = routeName; // Link to parent route for per-route select all
                checkbox.classList.add('rsg-saved-config-checkbox');
                checkbox.style.marginRight = '10px';
                checkbox.style.verticalAlign = 'middle';
                checkbox.addEventListener('change', rsg_handleSavedConfigCheckboxChange_ExtraPage);
                itemDiv.appendChild(checkbox);

                const nameSpan = document.createElement('span');
                nameSpan.textContent = originalUserDisplayName;
                nameSpan.style.flexGrow = "1";
                nameSpan.style.cursor = "pointer";
                nameSpan.addEventListener('click', () => rsg_handleLoadSelectedConfig_ExtraPage(configKey));
                itemDiv.appendChild(nameSpan);

                const actionButtonsDiv = document.createElement('div');
                actionButtonsDiv.style.display = 'flex';
                actionButtonsDiv.style.alignItems = 'center';

                const renameBtn = document.createElement('button');
                renameBtn.textContent = 'Rename';
                renameBtn.classList.add('button', 'small-action', 'neutral');
                renameBtn.style.marginRight = "0.3em";
                renameBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const statusElement = document.getElementById('rsg-load-status-message-extra');
                    if (statusElement) statusElement.textContent = "";
                    const newNameFromPrompt = prompt(`Enter new name for configuration currently named "${originalUserDisplayName}":`, originalUserDisplayName);
                    if (newNameFromPrompt === null) { }
                    else if (newNameFromPrompt.trim() === "") { }
                    else if (newNameFromPrompt.trim() === originalUserDisplayName) { }
                    else { rsg_performRenameConfiguration_ExtraPage(configKey, newNameFromPrompt.trim()); }
                });
                actionButtonsDiv.appendChild(renameBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '';
                deleteBtn.classList.add('button', 'small-action', 'secondary');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    rsg_handleDeleteSavedConfig_ExtraPage(configKey, originalUserDisplayName);
                });
                actionButtonsDiv.appendChild(deleteBtn);

                itemDiv.appendChild(actionButtonsDiv);
                container.appendChild(itemDiv);
            });
        } else {
            const noConfigsForRouteMsg = document.createElement('p');
            noConfigsForRouteMsg.textContent = "(No saved RSG configurations for this route)";
            noConfigsForRouteMsg.style.fontSize = "0.85em";
            noConfigsForRouteMsg.style.fontStyle = "italic";
            noConfigsForRouteMsg.style.opacity = "0.7";
            noConfigsForRouteMsg.style.paddingLeft = "28px"; // Indent message as well
            noConfigsForRouteMsg.style.marginBottom = "0.5em";
            container.appendChild(noConfigsForRouteMsg);
            routeSelectAllCheckbox.disabled = true; // Disable select all if no items for this route
        }
    });

    if (configsByRouteFromSaved["Unspecified Route"] && configsByRouteFromSaved["Unspecified Route"].length > 0) {
        const unspecifiedHeadingContainer = document.createElement('div');
        unspecifiedHeadingContainer.style.display = 'flex';
        unspecifiedHeadingContainer.style.alignItems = 'center';
        unspecifiedHeadingContainer.style.marginTop = "1.2em";
        unspecifiedHeadingContainer.style.marginBottom = "0.4em";
        unspecifiedHeadingContainer.style.borderBottom = "1px solid rgba(127,140,141,0.3)";
        unspecifiedHeadingContainer.style.paddingBottom = "0.2em";

        const unspecifiedSelectAllCheckbox = document.createElement('input');
        unspecifiedSelectAllCheckbox.type = 'checkbox';
        unspecifiedSelectAllCheckbox.classList.add('rsg-select-route-configs-checkbox-extra');
        unspecifiedSelectAllCheckbox.dataset.routeName = "Unspecified Route";
        unspecifiedSelectAllCheckbox.style.marginRight = '8px';
        unspecifiedSelectAllCheckbox.style.verticalAlign = 'middle';
        unspecifiedSelectAllCheckbox.addEventListener('change', rsg_handleSelectRouteConfigsChange_ExtraPage);
        unspecifiedHeadingContainer.appendChild(unspecifiedSelectAllCheckbox);

        const unspecifiedHeading = document.createElement('h4');
        unspecifiedHeading.textContent = "Route: Unspecified Route (from saved configs)";
        unspecifiedHeading.style.margin = "0";
        unspecifiedHeading.style.fontSize = "1.1em";
        unspecifiedHeading.style.color = "#ecf0f1";
        unspecifiedHeadingContainer.appendChild(unspecifiedHeading);
        container.appendChild(unspecifiedHeadingContainer);

        configsByRouteFromSaved["Unspecified Route"].forEach(configItem => {
             const configKey = configItem.key;
            const configData = configItem.data;
            const originalUserDisplayName = configData.userDisplayName || configKey;
            const descriptiveParametersString = `Unspecified Route - Profile: ${configData.operatingProfile || 'N/A'} - Dest: ${toTitleCase_rsg(configData.destinationName || 'N/A')}`;

            const itemDiv = document.createElement('div');
            itemDiv.style.padding = "0.4em 0.6em 0.4em 28px";
            itemDiv.style.marginBottom = "0.3em";
            itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)";
            itemDiv.style.borderRadius = "0.25rem";
            itemDiv.style.display = "flex";
            itemDiv.style.justifyContent = "space-between";
            itemDiv.style.alignItems = "center";
            itemDiv.addEventListener('mouseover', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.1)");
            itemDiv.addEventListener('mouseout', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)");
            itemDiv.title = `Load: ${originalUserDisplayName}\n(Parameters: ${descriptiveParametersString})\n(Key: ${configKey})`;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `rsg-config-checkbox-${configKey}`;
            checkbox.dataset.configKey = configKey;
            checkbox.dataset.parentRouteName = "Unspecified Route";
            checkbox.classList.add('rsg-saved-config-checkbox');
            checkbox.style.marginRight = '10px';
            checkbox.style.verticalAlign = 'middle';
            checkbox.addEventListener('change', rsg_handleSavedConfigCheckboxChange_ExtraPage);
            itemDiv.appendChild(checkbox);

            const nameSpan = document.createElement('span');
            nameSpan.textContent = originalUserDisplayName;
            nameSpan.style.flexGrow = "1";
            nameSpan.style.cursor = "pointer";
            nameSpan.addEventListener('click', () => rsg_handleLoadSelectedConfig_ExtraPage(configKey));
            itemDiv.appendChild(nameSpan);

            const actionButtonsDiv = document.createElement('div');
            actionButtonsDiv.style.display = 'flex';
            actionButtonsDiv.style.alignItems = 'center';

            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Rename';
            renameBtn.classList.add('button', 'small-action', 'neutral');
            renameBtn.style.marginRight = "0.3em";
            renameBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const statusElement = document.getElementById('rsg-load-status-message-extra');
                if (statusElement) statusElement.textContent = "";
                const newNameFromPrompt = prompt(`Enter new name for configuration currently named "${originalUserDisplayName}":`, originalUserDisplayName);
                if (newNameFromPrompt === null) {}
                else if (newNameFromPrompt.trim() === "") {}
                else if (newNameFromPrompt.trim() === originalUserDisplayName) {}
                else { rsg_performRenameConfiguration_ExtraPage(configKey, newNameFromPrompt.trim()); }
            });
            actionButtonsDiv.appendChild(renameBtn);

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = '';
            deleteBtn.classList.add('button', 'small-action', 'secondary');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                rsg_handleDeleteSavedConfig_ExtraPage(configKey, originalUserDisplayName);
            });
            actionButtonsDiv.appendChild(deleteBtn);

            itemDiv.appendChild(actionButtonsDiv);
            container.appendChild(itemDiv);
        });
         if (configsByRouteFromSaved["Unspecified Route"].length === 0) {
            unspecifiedSelectAllCheckbox.disabled = true;
        }
    }
    rsg_handleSavedConfigCheckboxChange_ExtraPage();
    rsg_updateSelectAllCheckboxesStates();
}

function rsg_handleSelectAllConfigsChange_ExtraPage() {
    const isChecked = rsgSelectAllConfigsCheckbox_el_extra.checked;
    const individualCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox');
    const perRouteCheckboxes = document.querySelectorAll('.rsg-select-route-configs-checkbox-extra');

    individualCheckboxes.forEach(cb => cb.checked = isChecked);
    perRouteCheckboxes.forEach(cb => {
        // Only check per-route if it's not disabled (i.e., has items under it)
        if (!cb.disabled) {
            cb.checked = isChecked;
        }
    });

    rsg_handleSavedConfigCheckboxChange_ExtraPage(); // Update main button states
}

function rsg_handleSelectRouteConfigsChange_ExtraPage(event) {
    const sourceCheckbox = event.target;
    const routeName = sourceCheckbox.dataset.routeName;
    const isChecked = sourceCheckbox.checked;

    const individualCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox');
    individualCheckboxes.forEach(cb => {
        if (cb.dataset.parentRouteName === routeName) {
            cb.checked = isChecked;
        }
    });

    rsg_updateSelectAllCheckboxesStates(); // Update global select all based on this change
    rsg_handleSavedConfigCheckboxChange_ExtraPage(); // Update main button states
}

function rsg_updateSelectAllCheckboxesStates() {
    // Update Per-Route "Select All" Checkboxes
    const perRouteCheckboxes = document.querySelectorAll('.rsg-select-route-configs-checkbox-extra');
    perRouteCheckboxes.forEach(perRouteCb => {
        if (perRouteCb.disabled) return; // Skip if it has no items

        const routeName = perRouteCb.dataset.routeName;
        const individualCheckboxesForRoute = document.querySelectorAll(`.rsg-saved-config-checkbox[data-parent-route-name="${routeName}"]`);
        
        if (individualCheckboxesForRoute.length > 0) {
            const allCheckedForRoute = Array.from(individualCheckboxesForRoute).every(cb => cb.checked);
            perRouteCb.checked = allCheckedForRoute;
        } else {
            perRouteCb.checked = false; // No items, so can't be "all checked"
        }
    });

    // Update Global "Select All (Everything)" Checkbox
    if (rsgSelectAllConfigsCheckbox_el_extra) {
        const allIndividualCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox');
        if (allIndividualCheckboxes.length > 0) {
            const allItemsCheckedOverall = Array.from(allIndividualCheckboxes).every(cb => cb.checked);
            rsgSelectAllConfigsCheckbox_el_extra.checked = allItemsCheckedOverall;
        } else {
            rsgSelectAllConfigsCheckbox_el_extra.checked = false; // No items to select
        }
    }
}

async function rsg_handleDeleteSavedConfig_ExtraPage(configKey, displayName) {
    if (!confirm(`Are you sure you want to delete the saved configuration: "${displayName}"? This cannot be undone.`)) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Deletion cancelled.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    if (!window.firebaseOMSI || !window.firebaseOMSI.database || !window.firebaseOMSI.dbGet) { // Added dbGet check
        alert("Firebase components not available. Cannot delete configuration.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Firebase components not available.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    // Make sure dbGet is correctly aliased as get if you use it directly like in the check below
    const { database, dbRemove, dbRef, dbGet: get } = window.firebaseOMSI; // Using alias 'get' for dbGet
    const configPath = `${FB_PATH_RSG_CONFIGS}/${configKey}`;

    if (rsgStatusMessage_el_extra) {
        rsgStatusMessage_el_extra.textContent = `Attempting to delete "${displayName}" (key: ${configKey}) from Firebase path: ${configPath}...`;
        rsgStatusMessage_el_extra.style.color = "#3498db"; // Blue for processing
    }
    console.log(`Attempting to delete from Firebase path: ${configPath}`);

    try {
        await dbRemove(dbRef(database, configPath));
        console.log(`Firebase dbRemove promise resolved for path: ${configPath}. Attempting to verify deletion from server...`);

        // VERIFICATION STEP: Try to fetch the data again immediately after deletion.
        // This helps confirm if the server actually processed the delete.
        const checkSnapshot = await get(dbRef(database, configPath)); // Using the aliased 'get'

        if (checkSnapshot.exists()) {
            // If it still exists, the delete didn't work on the server.
            console.error(`VERIFICATION FAILED: Config "${displayName}" (key: ${configKey}) still exists in Firebase at ${configPath} after dbRemove was called and resolved. This is unexpected.`);
            alert(`Error: Deletion for "${displayName}" appeared to succeed client-side, but the data is still present on the server. Please check Firebase rules for path "${FB_PATH_RSG_CONFIGS}" and its children, and network connectivity. Refreshing the list to reflect the server state.`);
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Deletion of "${displayName}" failed to persist on server. List refreshed.`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            // Force a reload of all RSG configs from Firebase to ensure UI matches the server.
            loadInitialData_ExtraPage(); // Or a more targeted reload for RSG configs if available
            return;
        } else {
            console.log(`VERIFICATION SUCCESS: Config "${displayName}" (key: ${configKey}) confirmed deleted from Firebase server path: ${configPath}.`);
        }

        // If verification passes (or if you skip verification), update local cache and UI.
        delete rsg_loadedConfigs_extra[configKey];
        rsg_renderSavedConfigsList_ExtraPage();

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Configuration "${displayName}" deleted successfully.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
        }

    } catch (error) { // This catch is for errors from dbRemove or the verification 'get'
        console.error(`Error during Firebase operation for configuration "${displayName}" (key: ${configKey}):`, error);
        alert(`Failed to delete configuration "${displayName}". Error: ${error.message}. The list may be out of sync. Please refresh.`);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error deleting configuration "${displayName}": ${error.message}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // On error, it's good practice to reload data to ensure UI consistency.
        loadInitialData_ExtraPage(); // Or a more targeted reload for RSG configs
    }
}

function rsg_getOtherRouteAdjustmentsForStop(targetStopID, currentEditingConfigKey) {
    const adjustmentsMap = new Map(); // Key: adjustmentValue, Value: { count: N, routeNames: Set() }

    if (!rsg_loadedConfigs_extra || typeof rsg_loadedConfigs_extra !== 'object') {
        return { hasDiscrepancies: false, mostCommonValue: null, suggestionTitle: '' };
    }

    for (const configKey in rsg_loadedConfigs_extra) {
        // Skip the configuration currently being edited to avoid comparing with its own (potentially unsaved) state
        if (configKey === currentEditingConfigKey) {
            continue;
        }

        const config = rsg_loadedConfigs_extra[configKey];
        if (config && Array.isArray(config.stopSequence)) {
            for (let i = 0; i < config.stopSequence.length; i++) {
                const stopInOtherConfig = config.stopSequence[i];
                // We only care about adjustments for the same stopID,
                // and only if it's not the first stop in that other sequence (index > 0),
                // and if timeAdjustment is a valid number.
                if (stopInOtherConfig.stopID === targetStopID &&
                    i > 0 && // Not the first stop (as first stop has no preceding adjustment)
                    typeof stopInOtherConfig.timeAdjustment === 'number' &&
                    !isNaN(stopInOtherConfig.timeAdjustment)) {

                    const adjValue = stopInOtherConfig.timeAdjustment;
                    if (!adjustmentsMap.has(adjValue)) {
                        adjustmentsMap.set(adjValue, { count: 0, routeNames: new Set() });
                    }
                    const existingEntry = adjustmentsMap.get(adjValue);
                    existingEntry.count++;
                    existingEntry.routeNames.add(config.routeName || "Unknown Route");
                }
            }
        }
    }

    if (adjustmentsMap.size === 0) {
        return { hasDiscrepancies: false, mostCommonValue: null, suggestionTitle: '' }; // No other routes use this stop with an adjustment
    }

    let mostCommonValue = null;
    let maxCount = 0;
    let allUniqueAdjustmentsFromOthers = [];

    adjustmentsMap.forEach((data, adjValue) => {
        allUniqueAdjustmentsFromOthers.push(adjValue);
        if (data.count > maxCount) {
            maxCount = data.count;
            mostCommonValue = adjValue;
        } else if (data.count === maxCount) {
            // Tie-breaking rule: prefer the smaller adjustment value if counts are equal
            if (mostCommonValue === null || adjValue < mostCommonValue) {
                mostCommonValue = adjValue;
            }
        }
    });
    
    let suggestionTitle = '';
    if (mostCommonValue !== null) {
        const routesUsingMostCommon = Array.from(adjustmentsMap.get(mostCommonValue)?.routeNames || []).slice(0,3).join(', ');
        const andMore = (adjustmentsMap.get(mostCommonValue)?.routeNames.size || 0) > 3 ? ' & more' : '';
        suggestionTitle = `Commonly +${mostCommonValue} min (on routes: ${routesUsingMostCommon}${andMore}). Click to apply.`;
    }


    return {
        // hasDiscrepancies: true if there are other adjustments and the current one differs from the mostCommon
        // This will be checked in the rendering function against the current stop's actual adjustment.
        allUniqueAdjustmentsFromOthers: allUniqueAdjustmentsFromOthers.sort((a,b) => a-b),
        mostCommonValue: mostCommonValue, // The adjustment value to suggest
        suggestionTitle: suggestionTitle  // Tooltip for the warning icon
    };
}

function rsg_handleLoadSelectedConfig_ExtraPage(configKey) {
    const loadStatusMsg = document.getElementById('rsg-load-status-message-extra');
    if (!rsg_loadedConfigs_extra || !rsg_loadedConfigs_extra[configKey]) {
        if (loadStatusMsg) {
            loadStatusMsg.textContent = "Error: Could not find configuration data for " + configKey;
            loadStatusMsg.style.color = "#e74c3c";
        }
        rsg_currentlyEditingConfigKey_extra = null; 
        rsg_currentlyEditingConfigDisplayName_extra = null;
        rsg_isDirty = false; // No valid config loaded to be dirty relative to
        rsg_updateRsgActionButtonsState();
        return;
    }

    const configData = rsg_loadedConfigs_extra[configKey];
    let loadedConfig = JSON.parse(JSON.stringify(configData)); // Deep copy to modify

    rsg_currentlyEditingConfigKey_extra = configKey;
    rsg_currentlyEditingConfigDisplayName_extra = loadedConfig.userDisplayName || configKey;

    rsgRouteNameInput_el_extra.value = loadedConfig.routeName || "";
    rsgDestinationNameInput_el_extra.value = loadedConfig.destinationName || "";
    rsg_setCheckedProfiles_ExtraPage(loadedConfig.operatingProfile || "");

    let namesUpdatedInSequence = false;
    if (loadedConfig.stopSequence && Array.isArray(loadedConfig.stopSequence) && 
        allDefinedStops_data && typeof allDefinedStops_data === 'object') {
        loadedConfig.stopSequence.forEach(stopInSeq => {
            if (stopInSeq.stopID) { // Ensure stopID exists
                const masterStopDef = allDefinedStops_data[stopInSeq.stopID.toUpperCase()];
                if (masterStopDef) {
                    if (stopInSeq.stopName !== masterStopDef.stopName) {
                        stopInSeq.stopName = masterStopDef.stopName;
                        namesUpdatedInSequence = true;
                    }
                    // Ensure direction is compared against a possibly empty master direction
                    const masterDirection = masterStopDef.direction || "";
                    if ((stopInSeq.direction || "") !== masterDirection) {
                        stopInSeq.direction = masterDirection;
                        namesUpdatedInSequence = true;
                    }
                } else {
                    // StopID in sequence not found in master definitions - might be an old/deleted stop
                    // You could mark it visually or log this
                    console.warn(`RSG Load: StopID ${stopInSeq.stopID} from loaded config sequence not found in master definitions. Name/direction may be stale.`);
                }
            }
        });
    }

    rsg_selectedStops_extra = loadedConfig.stopSequence || [];
    if (rsgFirstStopTimesInput_el_extra) {
         rsgFirstStopTimesInput_el_extra.value = loadedConfig.firstStopTimes || "";
    }

    rsg_lastLoadedRouteName_extra = loadedConfig.routeName || "";
    rsg_lastLoadedDestName_extra = loadedConfig.destinationName || "";
    rsg_lastLoadedOpProfile_extra = loadedConfig.operatingProfile || "";

    rsg_renderStopSequence_ExtraPage(); 

    let statusMessageText = `Loaded configuration: "${rsg_currentlyEditingConfigDisplayName_extra}".`;
    if (namesUpdatedInSequence) {
        statusMessageText += " Stop names/directions in the form have been updated to the latest master definitions. Save this RSG configuration to persist these updates within it.";
        rsg_isDirty = true; // Mark as dirty because the in-memory version of the config changed
        if (loadStatusMsg) loadStatusMsg.style.color = "#27ae60"; // Indicate update with different color
    } else {
        rsg_isDirty = false; 
        if (loadStatusMsg) loadStatusMsg.style.color = "#2ecc71"; // Standard success
    }
    
    rsg_resetPreviewState(statusMessageText, "success"); // Use statusMessageText for preview reset too
    if (loadStatusMsg) loadStatusMsg.textContent = statusMessageText;
    
    if (rsgRouteNameInput_el_extra) rsgRouteNameInput_el_extra.dispatchEvent(new Event('blur'));
    if (rsgDestinationNameInput_el_extra) {
        setTimeout(() => {
            rsgDestinationNameInput_el_extra.dispatchEvent(new Event('blur'));
        },50);
    }
    rsg_updateRsgActionButtonsState();
}

function getDaySortOrder_ExtraPage(profile) {
    if (!profile) return 9999;
    const p = String(profile).toUpperCase().replace(/\s+/g, ''); 
    const has = (keywords) => keywords.some(kw => p.includes(kw));
    let baseScore = 9000;

    if (has(["MONDAY", "MO"])) baseScore = 100;
    else if (has(["TUESDAY", "TU"])) baseScore = 200;
    else if (has(["WEDNESDAY", "WE"])) baseScore = 300;
    else if (has(["THURSDAY", "TH"])) baseScore = 400;
    else if (has(["FRIDAY", "FR"]) && !p.includes("GOODFRIDAY")) baseScore = 500;
    else if (has(["MON-FRI", "MONTOFRI", "WEEKDAY", "MF"])) baseScore = 600; 
    else if (has(["SATURDAY", "SA"]) && !p.includes("GOODFRIDAY")) baseScore = 700; 
    else if (has(["SUNDAY", "SU"])) baseScore = 800;

    if (baseScore < 9000) { 
        if (has(["SCH"])) return baseScore + 1;    
        if (has(["NSD"])) return baseScore + 2;    
        return baseScore; 
    }
    // Specific holiday scores (ensure these match what's in RSG_OPERATING_PROFILES_LIST if they are standalone)
    if (has(["CHRISTMASDAY"])) return 9030; // Example scores
    if (has(["BOXINGDAY"])) return 9040;
    if (has(["NEWYEARSDAY"])) return 9050;
    // Removed GoodFriday, SchoolHoliday, BankHoliday, AllDays from here if they are no longer primary types

    if (String(profile).includes(',')) { // For sorting already combined strings if needed elsewhere
        const parts = String(profile).split(',');
        let minScoreForParts = 9999;
        for (const part of parts) {
            minScoreForParts = Math.min(minScoreForParts, getDaySortOrder_ExtraPage(part.trim())); 
        }
        return minScoreForParts;
    }
    return baseScore; 
}

function rsg_populateProfileCheckboxes_ExtraPage() {
    const container = document.getElementById('rsg-selectable-profiles-container-extra');
    const placeholder = document.getElementById('rsg-profiles-placeholder-extra');
    if (!container) {
        console.error("RSG Profile checkbox container not found!");
        return;
    }
    container.innerHTML = ''; // Clear previous content

    if (RSG_OPERATING_PROFILES_LIST.length === 0 && placeholder) {
        placeholder.textContent = "No profiles defined to display.";
        container.appendChild(placeholder);
        return;
    }
    // Ensure placeholder is hidden if there are profiles to display
    if (placeholder) {
        placeholder.style.display = 'none';
    }

    RSG_OPERATING_PROFILES_LIST.forEach(profileValue => {
        const wrapper = document.createElement('div');
        wrapper.classList.add('selectable-route-tile'); // This class controls the visual styling
        // These styles are already in your CSS for .selectable-route-tile,
        // but explicitly setting background here might be good for consistency if default isn't applied otherwise.
        wrapper.style.backgroundColor = '#4A5568'; // Default background for unselected profile tiles
        wrapper.style.color = '#ecf0f1'; // Default text color

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        const safeProfileId = profileValue.replace(/[^a-zA-Z0-9_-]/g, '');
        checkbox.id = `rsg-profile-cb-${safeProfileId}-extra`;
        checkbox.value = profileValue;
        checkbox.name = 'rsgOperatingProfileCheckbox_extra';
        checkbox.classList.add('rsg-profile-checkbox'); // Keep this class for identification

        // The core change: Event listener on the wrapper (the tile itself)
        wrapper.addEventListener('click', (e) => {
            // Prevent toggling if the click was directly on the checkbox itself (optional, but good practice)
            if (e.target === checkbox) {
                // If clicked checkbox directly, let its native change event handle it
            } else {
                // If clicked on wrapper or label, manually toggle checkbox and then dispatch change event
                checkbox.checked = !checkbox.checked;
                const changeEvent = new Event('change', { bubbles: true });
                checkbox.dispatchEvent(changeEvent); // Trigger the change event
            }
        });

        // Add a change listener directly to the checkbox for the core logic
        // This listener will run whether the checkbox was clicked directly OR programmatically toggled by the wrapper click.
        checkbox.addEventListener('change', () => {
            wrapper.classList.toggle('selected', checkbox.checked); // Toggle 'selected' class on parent wrapper
            wrapper.style.borderColor = checkbox.checked ? '#f1c40f' : 'transparent'; // Visual border for selected
            wrapper.style.boxShadow = checkbox.checked ? '0 0 8px 1px #f1c40f' : '0 1px 3px rgba(0,0,0,0.3)'; // Visual shadow for selected
            
            // Now call the main logic function that handles overall selection state and disables
            rsg_handleProfileSelectionChange_ExtraPage(null); // Pass null as no specific event object is needed
        });


        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.textContent = profileValue;
        label.style.marginLeft = "4px"; 
        label.style.cursor = "pointer"; // Cursor for label is handled by wrapper now
        label.style.color = "#ecf0f1"; 

        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        container.appendChild(wrapper);
    });

    // Initial population/setting of states after all checkboxes are created:
    // This is crucial to ensure that if a configuration is loaded (which calls rsg_setCheckedProfiles_ExtraPage),
    // the visual state of the tiles correctly reflects the loaded profile string.
    // rsg_setCheckedProfiles_ExtraPage will then internally call rsg_handleProfileSelectionChange_ExtraPage,
    // which then calls rsg_updateDisabledProfileCheckboxes_ExtraPage.
    // So, we just need to ensure rsg_setCheckedProfiles_ExtraPage is called with the *current* selection state.
    // However, rsg_populateProfileCheckboxes_ExtraPage is called BEFORE rsg_loadOrPullConfiguration_ExtraPage.
    // To ensure initial state is correct for existing configurations, rsg_loadOrPullConfiguration_ExtraPage
    // should be the one responsible for calling rsg_setCheckedProfiles_ExtraPage after setting form values.
    // So, we need to ensure the visual state is updated here after rendering,
    // and let rsg_loadOrPullConfiguration_ExtraPage set the checked states.

    // Let's call rsg_updateDisabledProfileCheckboxes_ExtraPage directly to set initial disabled states.
    // The rsg_setCheckedProfiles_ExtraPage function (called by rsg_loadOrPullConfiguration_ExtraPage)
    // will correctly set the 'checked' state and trigger the 'change' event on relevant checkboxes,
    // which then updates the 'selected' class and calls rsg_handleProfileSelectionChange_ExtraPage.
    if (typeof rsg_updateDisabledProfileCheckboxes_ExtraPage === 'function') {
        rsg_updateDisabledProfileCheckboxes_ExtraPage();
    }
    // We do NOT need to call rsg_handleProfileSelectionChange_ExtraPage(null) here anymore,
    // because rsg_setCheckedProfiles_ExtraPage (which is called by rsg_loadOrPullConfiguration_ExtraPage after this function)
    // will trigger the 'change' event on the checkboxes, which in turn calls rsg_handleProfileSelectionChange_ExtraPage.
}

function populateTimetableExporterRouteSelect_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !currentWorkingSchedule_extra) {
        console.warn("Timetable Exporter: Route select element or schedule data not available.");
        return;
    }
    const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName).filter(Boolean))].sort(compareLineNames_ExtraPage);
    
    const currentInputValue = tteRouteNameInput_el_extra ? tteRouteNameInput_el_extra.value.trim() : "";
    
    tteRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Route --</option>';
    uniqueRoutes.forEach(route => {
        const opt = document.createElement('option');
        opt.value = route;
        opt.textContent = route;
        tteRouteNameSelect_el_extra.appendChild(opt);
    });

    if (currentInputValue) {
        const matchedOption = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
        tteRouteNameSelect_el_extra.value = matchedOption ? matchedOption : "";
    } else {
        tteRouteNameSelect_el_extra.value = "";
    }
}

// --- Helper Functions for PDF Timetable Generation ---

// Helper to convert HH:MM time string to absolute minutes from start of day
function getAbsMinutes(timeStr, dayOffset = 0) {
    // Check if timeStr is valid and in HH:MM format
    if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {
        // console.warn("getAbsMinutes: Invalid timeStr provided:", timeStr);
        return null; 
    }
    const parts = timeStr.split(':');
    if (parts.length !== 2) {
        // console.warn("getAbsMinutes: timeStr not in HH:MM format:", timeStr);
        return null;
    }

    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    
    // Ensure hours and minutes are valid numbers
    if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
        // console.warn("getAbsMinutes: Invalid hours or minutes in timeStr:", timeStr);
        return null;
    }

    // Ensure dayOffset is treated as a number, default to 0 if NaN or invalid
    const numericDayOffset = parseInt(dayOffset, 10);
    const validDayOffset = isNaN(numericDayOffset) ? 0 : numericDayOffset;
    
    return (validDayOffset * 1440) + (hours * 60) + minutes;
}

function toTitleCase_display(str) {
    if (!str || typeof str !== 'string') return "";
    return str.toLowerCase().split(' ').map(function(word) {
        if (word.length > 0) {
            // Handle special cases like "Year's" correctly
            if (word.includes("'")) {
                const parts = word.split("'");
                parts[0] = parts[0].charAt(0).toUpperCase() + parts[0].substring(1);
                return parts.join("'");
            }
            return word.charAt(0).toUpperCase() + word.substring(1);
        }
        return "";
    }).join(' ');
}

async function handleDownloadTimetable_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !tteRouteNameInput_el_extra || !tteStatusMessage_el_extra) {
        console.warn("Timetable Exporter: Essential UI elements are missing for download.");
        if(tteStatusMessage_el_extra) {
             tteStatusMessage_el_extra.textContent = "Initialization error. Try refreshing.";
             tteStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const routeName = tteRouteNameInput_el_extra.value.trim() || tteRouteNameSelect_el_extra.value;

    if (!routeName) {
        tteStatusMessage_el_extra.textContent = "Please select or enter a route name.";
        tteStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    if (!currentUser_extra || typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined' || typeof window.jspdf.jsPDF.API.autoTable === 'undefined') {
        tteStatusMessage_el_extra.textContent = "Error: PDF library not ready or not logged in.";
        tteStatusMessage_el_extra.style.color = "#e74c3c";
        console.error("jsPDF or jsPDF-AutoTable not correctly loaded. window.jspdf:", window.jspdf);
        return;
    }

    tteStatusMessage_el_extra.textContent = `Processing PDF timetable for route: ${routeName}...`;
    tteStatusMessage_el_extra.style.color = "#3498db";

    try {
        const routeEntries = currentWorkingSchedule_extra.filter(e => e.lineName === routeName);
        if (routeEntries.length === 0) {
            tteStatusMessage_el_extra.textContent = `No schedule data found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'landscape',
            unit: 'pt',
            format: 'a4'
        });
        let isFirstTableInPDF = true;

        const uniqueProfileDestPairs = new Map();
        routeEntries.forEach(e => {
            if (e.OperatingProfile && e.destinationName) {
                uniqueProfileDestPairs.set(`${e.OperatingProfile}|${e.destinationName}`, true);
            }
        });

        if (uniqueProfileDestPairs.size === 0) {
            tteStatusMessage_el_extra.textContent = `No operating profile/destination combinations found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }
        
        const sortedPairs = Array.from(uniqueProfileDestPairs.keys()).sort((a,b) => {
            const [profA, destA] = a.split('|');
            const [profB, destB] = b.split('|');
            const profCompare = profA.localeCompare(profB);
            if (profCompare !== 0) return profCompare;
            return destA.localeCompare(destB);
        });

        let tablesAddedToPDF = 0;

        for (const pair of sortedPairs) {
            const [opProfile, destName] = pair.split('|');
            let specificEntries = routeEntries.filter(e =>
                e.OperatingProfile === opProfile && e.destinationName === destName
            );

            if (specificEntries.length === 0) continue;

            specificEntries.sort((a, b) => {
                const dayOffsetA = parseInt(a.DayOffset || 0);
                const dayOffsetB = parseInt(b.DayOffset || 0);
                if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
                const timeA = (a.scheduledTime || "99:99").replace(':', '');
                const timeB = (b.scheduledTime || "99:99").replace(':', '');
                return timeA.localeCompare(timeB);
            });

            const trips = segmentEntriesIntoTrips_forTimetable(specificEntries);
            if (trips.length === 0) continue;

            const stopOrderMap = new Map();
            let globalStopIndexForOrdering = 0;
            trips.forEach(trip => { // Use all trips to define the superset of stops in order
                trip.forEach(entry => {
                    if (!entry.stopID || !entry.scheduledTime) return;
                    const currentStopTimeAbsVal = (parseInt(entry.DayOffset || 0) * 1440) +
                                             parseInt(entry.scheduledTime.split(':')[0]) * 60 +
                                             parseInt(entry.scheduledTime.split(':')[1]);
                    if (!stopOrderMap.has(entry.stopID)) {
                        stopOrderMap.set(entry.stopID, {
                            stopID: entry.stopID, name: entry.stopName, direction: entry.direction,
                            earliestTimeAbs: currentStopTimeAbsVal, 
                            firstSeenIndex: globalStopIndexForOrdering++
                        });
                    }
                });
            });
            const canonicalStopSequence = Array.from(stopOrderMap.values()).sort((a,b) => a.firstSeenIndex - b.firstSeenIndex);

            if (canonicalStopSequence.length === 0) continue;

            const tableHead = [["Stop ID", "Stop Name", "Stop Aim"]];
            trips.forEach((trip, index) => {
                tableHead[0].push(trip[0] ? `${trip[0].scheduledTime}` : `Trip ${index + 1}`);
            });

            const tableBody = [];
            canonicalStopSequence.forEach(stopInfo => {
                const row = [stopInfo.stopID || "", stopInfo.name || "", stopInfo.direction || ""];
                trips.forEach(trip => {
                    const entryForStopInTrip = trip.find(e => e.stopID === stopInfo.stopID);
                    row.push(entryForStopInTrip ? entryForStopInTrip.scheduledTime : "-");
                });
                tableBody.push(row);
            });

            if (tableBody.length > 0) {
                if (!isFirstTableInPDF) {
                    doc.addPage('a4', 'landscape');
                }
                isFirstTableInPDF = false;

                doc.setFontSize(14);
                doc.text(`Route: ${routeName}`, 40, 40);
                doc.setFontSize(11);
                doc.text(`Direction: Towards ${destName}`, 40, 55); // Adjusted Y for spacing
                doc.text(`Operating Profile: ${opProfile}`, 40, 70); // Adjusted Y for spacing

                doc.autoTable({
                    head: tableHead,
                    body: tableBody,
                    startY: 85, // Adjusted startY
                    theme: 'grid',
                    styles: { fontSize: 6, cellPadding: 1.5, overflow: 'visible' }, // 'ellipsize' or 'visible' or 'linebreak'
                    headStyles: { fillColor: [44, 62, 80], textColor: 255, fontSize: 7, fontStyle: 'bold', halign: 'center' },
                    columnStyles: {
                        0: { cellWidth: 50, fontStyle: 'bold' }, 
                        1: { cellWidth: 120 },
                        2: { cellWidth: 100 },
                        // For time columns, you might let them auto-adjust or set a small fixed width if many
                    },
                    margin: { top: 25, right: 30, bottom: 30, left: 40 }, // Adjusted top margin
                    tableWidth: 'auto',
                });
                tablesAddedToPDF++;
            }
        }

        if (tablesAddedToPDF > 0) {
            doc.save(`${sanitizeFirebaseKey(routeName)}_Timetable.pdf`);
            tteStatusMessage_el_extra.textContent = `Timetable PDF for ${routeName} generated successfully!`;
            tteStatusMessage_el_extra.style.color = "#2ecc71";
        } else {
            tteStatusMessage_el_extra.textContent = `No valid trip data found to generate PDF for route ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
        }

    } catch (error) {
        console.error("Error generating PDF timetable:", error);
        tteStatusMessage_el_extra.textContent = "Error generating PDF: " + error.message;
        tteStatusMessage_el_extra.style.color = "#e74c3c";
    }
}

// --- Helper function to segment entries into individual trips for PDF Timetable ---

function segmentEntriesIntoTrips_forTimetable(profileDestEntries, minStopsPerTripHeuristic = 1) { // <-- SET TO 200
    const allTrips = [];
    if (!profileDestEntries || profileDestEntries.length === 0) {
        return allTrips;
    }

    profileDestEntries.sort((a, b) => {
        const dayOffsetA = parseInt(a.DayOffset || 0);
        const dayOffsetB = parseInt(b.DayOffset || 0);
        if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
        const timeA = (a.scheduledTime || "99:99").replace(':', '');
        const timeB = (b.scheduledTime || "99:99").replace(':', '');
        return timeA.localeCompare(timeB);
    });

    let currentTrip = [];
    let previousStopTimeInAbsoluteMinutes = -1;
    let firstStopTimeOfCurrentLogicalTrip = -1;

    const rpdContext = profileDestEntries.length > 0 ? `(Route: ${profileDestEntries[0].lineName}, Profile: ${profileDestEntries[0].OperatingProfile}, Dest: ${profileDestEntries[0].destinationName})` : "";

    for (let i = 0; i < profileDestEntries.length; i++) {
        const entry = profileDestEntries[i];
        if (!entry.stopID || !entry.scheduledTime) continue;

        const currentStopTimeInAbsoluteMinutes =
            (parseInt(entry.DayOffset || 0) * 1440) +
            parseInt(entry.scheduledTime.split(':')[0]) * 60 +
            parseInt(entry.scheduledTime.split(':')[1]);

        if (currentTrip.length === 0) { 
            firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes;
        }
        
        if (currentTrip.length > 0) {
            // Condition 1: Time goes backward
            if (currentStopTimeInAbsoluteMinutes < previousStopTimeInAbsoluteMinutes) {
                console.log(`TRIP SPLIT (Time Regression) ${rpdContext}: Prev Stop ${currentTrip[currentTrip.length-1].stopID} (${currentTrip[currentTrip.length-1].scheduledTime} Day ${currentTrip[currentTrip.length-1].DayOffset || 0} / Abs: ${previousStopTimeInAbsoluteMinutes}), Curr Stop ${entry.stopID} (${entry.scheduledTime} Day ${entry.DayOffset || 0} / Abs: ${currentStopTimeInAbsoluteMinutes})`);
                allTrips.push([...currentTrip]); 
                currentTrip = []; 
                firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes; 
            } 
            // Condition 2: The STARTING STOP OF THE CURRENT TRIP is seen again
            // This condition is now very unlikely to be met with minStopsPerTripHeuristic = 9000
            else if (entry.stopID === currentTrip[0].stopID && 
                     currentTrip.length >= minStopsPerTripHeuristic && 
                     currentStopTimeInAbsoluteMinutes !== firstStopTimeOfCurrentLogicalTrip
                    ) {
                console.log(`TRIP SPLIT (Current Trip Start Stop Repeat) ${rpdContext}: Curr Stop ${entry.stopID} at ${entry.scheduledTime} (Abs: ${currentStopTimeInAbsoluteMinutes}), CurrentTripStartStopID: ${currentTrip[0].stopID}, TripLength: ${currentTrip.length}, minHeuristic: ${minStopsPerTripHeuristic}, FirstTimeOfCurrentTrip: ${firstStopTimeOfCurrentLogicalTrip}`);
                allTrips.push([...currentTrip]); 
                currentTrip = []; 
                firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes; 
            }
        }
        
        currentTrip.push(entry);
        previousStopTimeInAbsoluteMinutes = currentStopTimeInAbsoluteMinutes;
    }

    if (currentTrip.length > 0) {
        allTrips.push([...currentTrip]);
    }
    return allTrips;
}

// Helper to format a single time object for display
function formatTimeForDisplay(timeObject) {
    // timeObject = { absMinutes, displayTime, dayOffset }
    return timeObject.displayTime; 
}

function determineCanonicalStopSequence(specificEntriesForRPD) {
    const stopData = new Map(); // stopID -> { stopID, name, earliestAbsMinutes, firstSeenOriginalIndex }

    // The specificEntriesForRPD should already be sorted chronologically 
    // by the time this function is called in handleDownloadTimetable_ExtraPage
    specificEntriesForRPD.forEach((entry, index) => {
        if (entry.stopID && entry.scheduledTime) {
            const absMinutes = getAbsMinutes(entry.scheduledTime, parseInt(entry.DayOffset || 0));
            if (absMinutes === null) return;

            if (!stopData.has(entry.stopID)) {
                stopData.set(entry.stopID, {
                    stopID: entry.stopID,
                    name: entry.stopName,
                    earliestAbsMinutes: absMinutes, // Store the time of its first actual encountered entry
                    firstSeenOriginalIndex: index  // Store the index from the master sorted list
                });
            }
            // If you wanted to update earliestAbsMinutes for a stop if it appeared later with an even earlier time
            // (which shouldn't happen if specificEntriesForRPD is perfectly sorted), you could add logic here.
            // For now, we assume the first encounter sets its primary ordering criteria.
        }
    });

    return Array.from(stopData.values()).sort((a, b) => {
        if (a.firstSeenOriginalIndex !== b.firstSeenOriginalIndex) {
            return a.firstSeenOriginalIndex - b.firstSeenOriginalIndex;
        }
        return a.earliestAbsMinutes - b.earliestAbsMinutes; // Fallback sort
    });
}

function analyzeAndSummarizeTimes(sortedTimes) { // sortedTimes is array of { absMinutes, displayTime, dayOffset }
    // Define constants used within this function
    const MAX_INITIAL_INDIVIDUAL_TIMES = 2; 
    const MIN_TIMES_FOR_PATTERN_BLOCK = 4;  
    const MIN_INTERVALS_FOR_PATTERN = MIN_TIMES_FOR_PATTERN_BLOCK - 1;

    const n = sortedTimes.length;
    if (n === 0) return "-";

    if (n < MIN_TIMES_FOR_PATTERN_BLOCK) { 
        return sortedTimes.map(t => formatTimeForDisplay(t)).join(", ");
    }

    let resultParts = [];
    let currentIndex = 0;

    while (currentIndex < n) {
        let bestRun = {
            startIdx: -1, numIntervals: 0, interval: 0, 
            startTimeObj: null, endTimeObj: null
        };

        // Determine the limit for starting a pattern search.
        // We look for a pattern starting at currentIndex, or up to MAX_INITIAL_INDIVIDUAL_TIMES beyond it.
        // Ensure we don't search beyond where a minimal pattern could form.
        let searchStartLimit = Math.min(currentIndex + MAX_INITIAL_INDIVIDUAL_TIMES, n - MIN_INTERVALS_FOR_PATTERN);
        // If currentIndex itself is already very close to the end, adjust searchStartLimit to at least allow one check from currentIndex
        if (searchStartLimit <= currentIndex && currentIndex <= n - MIN_TIMES_FOR_PATTERN_BLOCK ) { 
            searchStartLimit = currentIndex + 1; 
        }


        for (let i = currentIndex; i < searchStartLimit; i++) {
            // Ensure there are enough elements from 'i' to form at least MIN_INTERVALS_FOR_PATTERN
            if (i + MIN_INTERVALS_FOR_PATTERN >= n) break; 

            const t1Abs = sortedTimes[i].absMinutes;
            const t2Abs = sortedTimes[i + 1].absMinutes;

            if (t1Abs === null || t2Abs === null) continue;
            let currentRunInterval = t2Abs - t1Abs;

            // Ignore intervals that are non-positive or too large for typical summaries
            if (currentRunInterval <= 0 || currentRunInterval >= 90) continue; 

            let currentRunNumIntervals = 1; // We found one interval (between sortedTimes[i] and sortedTimes[i+1])
            // Now count how many more *consecutive* intervals match currentRunInterval
            for (let k = i + 1; k < n - 1; k++) { // k is the index of the start of the next interval
                const tkAbs = sortedTimes[k].absMinutes;
                const tk1Abs = sortedTimes[k + 1].absMinutes;
                if (tkAbs === null || tk1Abs === null) break; 

                if ((tk1Abs - tkAbs) === currentRunInterval) {
                    currentRunNumIntervals++;
                } else {
                    break; 
                }
            }

            if (currentRunNumIntervals >= MIN_INTERVALS_FOR_PATTERN) {
                // Found a valid run of intervals. Check if it's better than any previously found bestRun.
                if (currentRunNumIntervals > bestRun.numIntervals || 
                    (currentRunNumIntervals === bestRun.numIntervals && i < bestRun.startIdx) || 
                    bestRun.startIdx === -1) { // Prioritize longer runs, or earlier starting runs of same length
                    bestRun = {
                        startIdx: i, // Index in sortedTimes of the first time in this pattern
                        endIdx: i + currentRunNumIntervals, // Index in sortedTimes of the last time in this pattern
                        interval: currentRunInterval,
                        numIntervals: currentRunNumIntervals, // Number of matching intervals
                        startTimeObj: sortedTimes[i],
                        endTimeObj: sortedTimes[i + currentRunNumIntervals]
                    };
                }
            }
        } 

        if (bestRun.startIdx !== -1 && bestRun.startIdx >= currentIndex) { 
            // A frequency pattern was found starting at or after currentIndex.
            // 1. Add any individual times from currentIndex UP TO the start of the identified pattern block
            for (let j = currentIndex; j < bestRun.startIdx; j++) {
                resultParts.push(formatTimeForDisplay(sortedTimes[j]));
            }

            // 2. Add the actual start time of the frequency block
            const formattedRunStartTime = formatTimeForDisplay(bestRun.startTimeObj);
            resultParts.push(formattedRunStartTime);
            
            // 3. Construct the core summary phrase (without "then" and without "from [start time]")
            let summaryCorePhrase = "";
            const formattedRunEndTime = formatTimeForDisplay(bestRun.endTimeObj);

            if (bestRun.interval < 15) {
                summaryCorePhrase = `every ${bestRun.interval} mins until ${formattedRunEndTime}`;
            } else { // Interval is 15 minutes or more
                const minutesPastHourSet = new Set();
                for (let k = bestRun.startIdx; k <= bestRun.endIdx; k++) { // Iterate through times in the actual run
                    if (sortedTimes[k].displayTime.includes(':')) {
                        minutesPastHourSet.add(sortedTimes[k].displayTime.substring(3, 5));
                    }
                }
                if (minutesPastHourSet.size >= 1 && minutesPastHourSet.size <= 4 && (bestRun.interval % 5 === 0)) {
                    let numericallySortedMinutes = Array.from(minutesPastHourSet).sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
                    
                    const startMinuteOfBlock = bestRun.startTimeObj.displayTime.substring(3,5);
                    if (numericallySortedMinutes.length > 1 && numericallySortedMinutes[0] === startMinuteOfBlock) {
                        const firstMin = numericallySortedMinutes.shift(); 
                        numericallySortedMinutes.push(firstMin);      
                    }
                    const displayMinutes = numericallySortedMinutes.join(', ');                                        
                    summaryCorePhrase = `at these mins past each hour: ${displayMinutes} until ${formattedRunEndTime}`;
                } else { 
                    summaryCorePhrase = `approx. every ${bestRun.interval} mins until ${formattedRunEndTime}`;
                }
            }
            resultParts.push("then " + summaryCorePhrase); // Add "then" before the core summary
            currentIndex = bestRun.endIdx + 1; // Advance currentIndex past this summarized block
        } else { // No suitable frequency block found from currentIndex, or remaining times are too few.
            if (currentIndex < n) {
                 resultParts.push(formatTimeForDisplay(sortedTimes[currentIndex]));
                 currentIndex++;
            } else { 
                break; // End of times
            }
        }
    } 

    // Final joining logic
    if (resultParts.length === 0) return "-";
    let finalStr = resultParts[0] || "";
    for (let i = 1; i < resultParts.length; i++) {
        const prevPartStr = resultParts[i-1] || "";
        const currentPartStr = resultParts[i] || "";
        
        if (currentPartStr.startsWith("then") && !prevPartStr.startsWith("then")) {
            // Previous was a time, current is its summary: "TIME then SUMMARY"
            finalStr += " " + currentPartStr; 
        } else {
            // All other cases (summary; summary, summary; time, time; time if it's a new segment after summary)
            finalStr += "; " + currentPartStr;
        }
    }
    return finalStr || "-";
}

async function handleDownloadTimetable_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !tteRouteNameInput_el_extra || !tteStatusMessage_el_extra) {
        console.warn("Timetable Exporter: Essential UI elements missing.");
        if(tteStatusMessage_el_extra) { tteStatusMessage_el_extra.textContent = "Init error."; tteStatusMessage_el_extra.style.color = "#e74c3c"; }
        return;
    }

    const routeName = tteRouteNameInput_el_extra.value.trim() || tteRouteNameSelect_el_extra.value;
    if (!routeName) {
        tteStatusMessage_el_extra.textContent = "Please select a route.";
        tteStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    if (!currentUser_extra || typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined' || typeof window.jspdf.jsPDF.API.autoTable === 'undefined') {
        tteStatusMessage_el_extra.textContent = "Error: PDF library not ready or not logged in.";
        tteStatusMessage_el_extra.style.color = "#e74c3c";
        return;
    }

    tteStatusMessage_el_extra.textContent = `Processing PDF timetable for route: ${routeName}...`;
    tteStatusMessage_el_extra.style.color = "#3498db";

    try {
        const routeEntries = currentWorkingSchedule_extra.filter(e => e.lineName === routeName);
        if (routeEntries.length === 0) {
            tteStatusMessage_el_extra.textContent = `No schedule data found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'portrait', 
            unit: 'pt',
            format: 'a4'
        });
        let isFirstTableInPDF = true;

        const uniqueProfileDestPairs = new Map();
        routeEntries.forEach(e => {
            if (e.OperatingProfile && e.destinationName) {
                uniqueProfileDestPairs.set(`${e.OperatingProfile}|${e.destinationName}`, true);
            }
        });

        if (uniqueProfileDestPairs.size === 0) {
            tteStatusMessage_el_extra.textContent = `No operating profile/destination combinations found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }
        
        const sortedPairs = Array.from(uniqueProfileDestPairs.keys()).sort((a,b) => {
            const [profA, destA] = a.split('|');
            const [profB, destB] = b.split('|');
            const profCompare = profA.localeCompare(profB);
            if (profCompare !== 0) return profCompare;
            return destA.localeCompare(destB);
        });

        let tablesAddedToPDF = 0;

        for (const pair of sortedPairs) {
            const [opProfile, destName] = pair.split('|');
            
            const specificEntriesForRPD = routeEntries
                .filter(e => e.OperatingProfile === opProfile && e.destinationName === destName && e.scheduledTime)
                .sort((a,b) => { 
                    const absA = getAbsMinutes(a.scheduledTime, parseInt(a.DayOffset || 0));
                    const absB = getAbsMinutes(b.scheduledTime, parseInt(b.DayOffset || 0));
                    if (absA === null && absB === null) return 0;
                    if (absA === null) return 1;
                    if (absB === null) return -1;
                    return absA - absB;
                });

            if (specificEntriesForRPD.length === 0) continue;

            const canonicalStopSequence = determineCanonicalStopSequence(specificEntriesForRPD);
            if (canonicalStopSequence.length === 0) continue;

            const tableHead = [["Stop ID", "Stop Name", "Scheduled Times"]];
            const tableBody = [];

            canonicalStopSequence.forEach(stopInfo => {
                const allTimesAtThisStop = specificEntriesForRPD
                    .filter(e => e.stopID === stopInfo.stopID) 
                    .map(e => ({ 
                        absMinutes: getAbsMinutes(e.scheduledTime, parseInt(e.DayOffset || 0)),
                        displayTime: e.scheduledTime,
                        dayOffset: parseInt(e.DayOffset || 0)
                    }));
                // This map preserves the pre-sorted order of times for this stop from specificEntriesForRPD

                const serviceDetailString = analyzeAndSummarizeTimes(allTimesAtThisStop);
                
                tableBody.push([
                    stopInfo.stopID || "",
                    stopInfo.name || "",
                    serviceDetailString
                ]);
            });

            if (tableBody.length > 0) {
                if (!isFirstTableInPDF) {
                    doc.addPage('a4', 'portrait');
                }
                isFirstTableInPDF = false;

                doc.setFontSize(14);
                doc.text(`Route: ${routeName}`, 40, 40); 
                doc.setFontSize(11);
                doc.text(`Destination: ${destName}`, 40, 55); 
                doc.text(`Operating Profile: ${opProfile}`, 40, 70);

                doc.autoTable({
                    head: tableHead,
                    body: tableBody,
                    startY: 85,
                    theme: 'grid',
                    styles: { 
                        fontSize: 7, 
                        cellPadding: 2,
                        overflow: 'linebreak' 
                    }, 
                    headStyles: { 
                        fillColor: [44, 62, 80], 
                        textColor: 255, 
                        fontSize: 8,       
                        fontStyle: 'bold', 
                        halign: 'left' 
                    },
                    columnStyles: {
                        0: { cellWidth: 55, fontStyle: 'bold' }, 
                        1: { cellWidth: 130 }, 
                        2: { cellWidth: 'auto' } 
                    },
                    margin: { top: 25, right: 30, bottom: 30, left: 40 },
                });
                tablesAddedToPDF++;
            }
        }

        if (tablesAddedToPDF > 0) {
            doc.save(`${sanitizeFirebaseKey(routeName)}_Timetable_Summary.pdf`);
            tteStatusMessage_el_extra.textContent = `Summarized Timetable PDF for ${routeName} generated successfully!`;
            tteStatusMessage_el_extra.style.color = "#2ecc71";
        } else {
            tteStatusMessage_el_extra.textContent = `No valid data to generate summarized PDF for ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
        }

    } catch (error) {
        console.error("Error generating summarized PDF timetable:", error);
        tteStatusMessage_el_extra.textContent = "Error generating summarized PDF: " + error.message;
        tteStatusMessage_el_extra.style.color = "#e74c3c";
    }
}

function rsg_getSelectedOpProfilesString_ExtraPage() {
    const selectedProfiles = [];
    document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox:checked').forEach(checkbox => {
        selectedProfiles.push(checkbox.value);
    });
    // Sorts alphabetically, e.g., ["Fr", "MF", "Sa"]
    selectedProfiles.sort((a,b) => a.localeCompare(b)); 
    
    // Joins with a comma AND a space
    return selectedProfiles.join(', ');
}

function rsg_updateDisabledProfileCheckboxes_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));
    const currentSelectedValues = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

    allCheckboxes.forEach(cb => {
        if (cb.checked) {
            cb.disabled = false;
            if (cb.parentElement) {
                cb.parentElement.style.opacity = 1;
                cb.parentElement.style.pointerEvents = 'auto';
                const labelForCb = cb.parentElement.querySelector('label');
                if (labelForCb) labelForCb.style.cursor = 'pointer';
            }
            return;
        }

        const potentialNextRawSelection = [...currentSelectedValues, cb.value];
        const finalEffectiveSelectionAfterAutoGroup = rsg_simulateAutoGroup(potentialNextRawSelection);
        const finalEffectiveSortedString = rsg_getCanonicalProfileString(finalEffectiveSelectionAfterAutoGroup);

        let canBeEnabled = false;

        if (VALID_PROFILE_COMBINATIONS_SET.has(finalEffectiveSortedString)) {
            canBeEnabled = true;
        }

        if (!canBeEnabled) {
            const prefixToTest = finalEffectiveSortedString + ",";
            for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                if (validCombo.startsWith(prefixToTest)) {
                    canBeEnabled = true;
                    break;
                }
            }
        }

        if (currentSelectedValues.length === 0) {
             const singleProfileItselfAfterPotentialGroup = rsg_simulateAutoGroup([cb.value]);
             const singleCanonical = rsg_getCanonicalProfileString(singleProfileItselfAfterPotentialGroup);
             if (VALID_PROFILE_COMBINATIONS_SET.has(singleCanonical)) {
                 canBeEnabled = true;
             } else {
                 const prefixToTestForSingle = singleCanonical + ",";
                 for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                     if (validCombo.startsWith(prefixToTestForSingle)) {
                         canBeEnabled = true;
                         break;
                     }
                 }
             }
        }

        cb.disabled = !canBeEnabled;
        if (cb.parentElement) {
            cb.parentElement.style.opacity = !canBeEnabled ? 0.5 : 1;
            cb.parentElement.style.pointerEvents = !canBeEnabled ? 'none' : 'auto';
            const labelForCb = cb.parentElement.querySelector('label');
            if (labelForCb) {
                labelForCb.style.cursor = !canBeEnabled ? 'not-allowed' : 'pointer';
            }
        }
    });
}

function rsg_simulateAutoGroup(selectedProfilesArray) {
    let simulatedSelections = [...selectedProfilesArray]; 

    for (const group of RSG_PROFILE_GROUPS_TO_MANAGE) {
        const allIndividualsPresent = group.individuals.every(ind => simulatedSelections.includes(ind));

        if (allIndividualsPresent) {
            simulatedSelections = simulatedSelections.filter(p => !group.individuals.includes(p)); 
            if (!simulatedSelections.includes(group.groupProfile)) {
                simulatedSelections.push(group.groupProfile); 
            }
        }
    }
    return simulatedSelections;
}

function rsg_handleProfileSelectionChange_ExtraPage(event) { // event can be null if called programmatically
    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));
    let selectionChangedByLogic = false;

    // Loop through each defined group (e.g., MF, MFSch, MFNSD)
    RSG_PROFILE_GROUPS_TO_MANAGE.forEach(group => {
        const groupCheckbox = allCheckboxes.find(cb => cb.value === group.groupProfile);
        if (!groupCheckbox) return; // Should not happen if profiles are populated correctly

        const individualCheckboxesInGroup = group.individuals.map(indVal => allCheckboxes.find(cb => cb.value === indVal)).filter(Boolean);
        const allIndividualsCurrentlySelected = individualCheckboxesInGroup.length === group.individuals.length && individualCheckboxesInGroup.every(cb => cb.checked);

        // Case 1: All individual days of a group are ticked
        if (allIndividualsCurrentlySelected) {
            if (!groupCheckbox.checked) { // And the group itself is not yet ticked
                // Uncheck all individuals in this group
                individualCheckboxesInGroup.forEach(cb => {
                    if (cb.checked) {
                        cb.checked = false;
                        selectionChangedByLogic = true;
                    }
                });
                // Check the group profile
                groupCheckbox.checked = true;
                selectionChangedByLogic = true;
            }
        }
        // Case 2: The group profile is ticked
        else if (groupCheckbox.checked) {
            // If the event was specifically unchecking an individual that belongs to this *currently checked* group,
            // then uncheck the group profile itself.
            if (event && event.target && group.individuals.includes(event.target.value) && !event.target.checked) {
                groupCheckbox.checked = false;
                selectionChangedByLogic = true;
            }
            // If the group profile is (still) checked, ensure all its individual members are unchecked.
            // This handles user directly clicking group, or auto-grouping just occurred.
            if (groupCheckbox.checked) {
                individualCheckboxesInGroup.forEach(cb => {
                    if (cb.checked) { // If an individual is somehow still checked along with the group
                        cb.checked = false;
                        selectionChangedByLogic = true;
                    }
                });
            }
        }
    });

    // After all programmatic changes to checkbox.checked states are complete,
    // update the visual appearance of ALL tiles to match their current checkbox state.
    allCheckboxes.forEach(cb => {
        const wrapper = cb.closest('.selectable-route-tile'); // Get the parent tile
        if (wrapper) {
            const isChecked = cb.checked;
            wrapper.classList.toggle('selected', isChecked);
            // Ensure you have a CSS variable for --default-box-shadow or use the explicit string
            const defaultBoxShadow = getComputedStyle(wrapper).getPropertyValue('--default-box-shadow').trim() || '0 1px 3px rgba(0,0,0,0.3)';
            wrapper.style.borderColor = isChecked ? '#f1c40f' : 'transparent';
            wrapper.style.boxShadow = isChecked ? '0 0 8px 1px #f1c40f' : defaultBoxShadow;
        }
    });

    // Now, get the final selected profiles string based on the updated checkbox states
    const finalCurrentSelectionsArray = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

    // Sort for consistent display and storage
    finalCurrentSelectionsArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a);
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) return orderA - orderB;
        return a.localeCompare(b);
    });
    const finalSelectedProfilesString = finalCurrentSelectionsArray.join(', ');

    // Update the display string
    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }

    // Update which checkboxes are enabled/disabled based on rules
    rsg_updateDisabledProfileCheckboxes_ExtraPage();

    // If a change was made by user interaction (event is not null) or by the grouping logic,
    // then the configuration might need to be re-evaluated against saved configs.
    if (event || selectionChangedByLogic) {
        if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') {
            rsg_loadOrPullConfiguration_ExtraPage();
        }
    }
    rsg_updateRsgActionButtonsState();
}

function rsg_setCheckedProfiles_ExtraPage(profileString) {
    // Determine which profiles to select based on the input string
    const profilesToSelect = profileString ? profileString.split(',').map(p => p.trim()).filter(Boolean) : [];

    // Get all profile checkboxes
    const allProfileCheckboxes = document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox');

    // Set the checked state for each checkbox
    allProfileCheckboxes.forEach(checkbox => {
        checkbox.checked = profilesToSelect.includes(checkbox.value);
    });

    // --- MODIFICATION START ---
    // After programmatically setting checkbox states,
    // directly update the "Currently Selected & Active" display string.

    // Use the 'profilesToSelect' array as the source of truth for what should be displayed,
    // as this is what the checkboxes were just set to.
    // Create a mutable copy if further manipulation of this array specific to display is needed,
    // otherwise, direct use is fine for sorting and joining.
    const currentDisplayProfilesArray = [...profilesToSelect];

    // Sort them for consistent display order using your existing sorting logic
    currentDisplayProfilesArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a); // Ensure getDaySortOrder_ExtraPage is robust
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) {
            return orderA - orderB;
        }
        return a.localeCompare(b); // Default alphabetical sort if order is the same
    });

    // Join the sorted profiles into a string for display
    const finalSelectedProfilesString = currentDisplayProfilesArray.join(', ');

    // Get the display element
    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');

    // Update the text content of the display element
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }
    // --- MODIFICATION END ---

    // This function correctly updates which checkboxes are enabled/disabled
    // based on your incompatibility rules and the newly set checkbox states.
    // This should always be called after checkbox states are modified.
    if (typeof rsg_updateDisabledProfileCheckboxes_ExtraPage === 'function') {
        rsg_updateDisabledProfileCheckboxes_ExtraPage();
    }
}

function rsg_clearProfileSelections_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));
    let selectionActuallyChanged = false;

    allCheckboxes.forEach(cb => {
        if (cb.checked) {
            cb.checked = false;
            selectionActuallyChanged = true;
        }
    });

    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = '(None selected)';
    }

    if (typeof rsg_updateDisabledProfileCheckboxes_ExtraPage === 'function') {
        rsg_updateDisabledProfileCheckboxes_ExtraPage();
    }

    if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') {
        rsg_loadOrPullConfiguration_ExtraPage();
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_createConfigKey_ExtraPage(routeName, opProfile, destName) { if (!routeName || !opProfile || !destName) return null; const normRoute = sanitizeFirebaseKey(String(routeName).toUpperCase()); const normProfile = sanitizeFirebaseKey(String(opProfile).toUpperCase()); const normDest = sanitizeFirebaseKey(String(destName).toUpperCase()); return `${normRoute}|${normProfile}|${normDest}`; } 

        async function rsg_loadOrPullConfiguration_ExtraPage(configKeyToLoad = null, isInitialLoadForSection = false) {
    if (!rsgRouteNameInput_el_extra || // Now refers to hidden input
        !rsgDestinationNameInput_el_extra ||
        !rsgFirstStopTimesInput_el_extra ||
        !rsgStatusMessage_el_extra || !window.firebaseOMSI) {
        console.warn("RSG Load/Pull: Aborted - Essential DOM element or Firebase missing.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "RSG components missing or Firebase not ready.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    // Now get the route name directly from rsg_selectedRoute_extra (or its hidden input for safety)
    const routeNameFromForm = rsg_selectedRoute_extra || rsgRouteNameInput_el_extra.value.trim();
    const opProfileFromForm = rsg_getSelectedOpProfilesString_ExtraPage();
    const destNameFromForm = rsgDestinationNameInput_el_extra.value.trim();
    const loadStatusMsg = document.getElementById('rsg-load-status-message-extra');


    if (configKeyToLoad) { // A specific saved configuration is being loaded (e.g., from the saved configs list)
        const configData = rsg_loadedConfigs_extra[configKeyToLoad];
        if (configData) {
            let loadedConfig = JSON.parse(JSON.stringify(configData)); // Deep copy

            rsg_currentlyEditingConfigKey_extra = configKeyToLoad;
            rsg_currentlyEditingConfigDisplayName_extra = loadedConfig.userDisplayName || configKeyToLoad;

            // Update the global selected route and the hidden input
            rsg_selectedRoute_extra = loadedConfig.routeName || ""; 
            rsgRouteNameInput_el_extra.value = rsg_selectedRoute_extra;
            // Update the display for the route tile selection
            if (rsgSelectedRouteDisplay_el_extra) {
                rsgSelectedRouteDisplay_el_extra.textContent = rsg_selectedRoute_extra || '(None selected)';
            }
            // Visually select the tile
            rsgRouteSelectionContainer_el_extra.querySelectorAll('.selectable-route-tile').forEach(tile => {
                if (tile.dataset.routeName && tile.dataset.routeName.toUpperCase() === rsg_selectedRoute_extra.toUpperCase()) {
                    tile.classList.add('selected');
                } else {
                    tile.classList.remove('selected');
                }
            });


            rsgDestinationNameInput_el_extra.value = loadedConfig.destinationName || "";
            rsg_setCheckedProfiles_ExtraPage(loadedConfig.operatingProfile || "");

            let namesOrDirectionsUpdatedInLoadedConfig = false;
            if (loadedConfig.stopSequence && Array.isArray(loadedConfig.stopSequence) && allDefinedStops_data) {
                loadedConfig.stopSequence.forEach(stopInSeq => {
                    if (stopInSeq.stopID) {
                        const masterStopDef = allDefinedStops_data[stopInSeq.stopID.toUpperCase()];
                        if (masterStopDef) {
                            if (stopInSeq.stopName !== masterStopDef.stopName) {
                                stopInSeq.stopName = masterStopDef.stopName;
                                namesOrDirectionsUpdatedInLoadedConfig = true;
                            }
                            const masterDirection = masterStopDef.direction || "";
                            if ((stopInSeq.direction || "") !== masterDirection) {
                                stopInSeq.direction = masterDirection;
                                namesOrDirectionsUpdatedInLoadedConfig = true;
                            }
                        }
                    }
                });
            }

            rsg_selectedStops_extra = loadedConfig.stopSequence || [];
            if (rsgFirstStopTimesInput_el_extra) {
                rsgFirstStopTimesInput_el_extra.value = loadedConfig.firstStopTimes || '';
            }

            // Update last loaded context variables from the loaded config
            rsg_lastLoadedRouteName_extra = loadedConfig.routeName || "";
            rsg_lastLoadedDestName_extra = loadedConfig.destinationName || "";
            rsg_lastLoadedOpProfile_extra = loadedConfig.operatingProfile || "";
            
            let statusMessageText = `Loaded configuration: "${rsg_currentlyEditingConfigDisplayName_extra}".`;
            if (namesOrDirectionsUpdatedInLoadedConfig) {
                statusMessageText += " Stop names/directions updated to latest. Save to persist.";
                rsg_isDirty = true; // Mark as dirty as it differs from originally saved state due to refresh
                if (loadStatusMsg) loadStatusMsg.style.color = "#27ae60";
            } else {
                rsg_isDirty = false;
                if (loadStatusMsg) loadStatusMsg.style.color = "#2ecc71";
            }

            rsg_resetPreviewState(statusMessageText, "success");
            if (loadStatusMsg) loadStatusMsg.textContent = statusMessageText;

        } else { // Config key provided, but data not found
            if (loadStatusMsg) {
                loadStatusMsg.textContent = `Error: Could not find data for saved configuration key "${configKeyToLoad}". Current sequence retained.`;
                loadStatusMsg.style.color = "#e74c3c";
            }
            rsg_currentlyEditingConfigKey_extra = null;
            rsg_currentlyEditingConfigDisplayName_extra = null;
            rsg_isDirty = true; 
            rsg_resetPreviewState("Failed to load saved configuration. Review inputs or continue.", "error");
        }
    } else { 
        // --- START: NEW LOGIC ---
        // This block handles cases where the user changes the route/dest/profile in the form,
        // which means they are no longer editing the previously loaded config.
        
        // If no route is selected via the tiles, it's a completely fresh start.
        if (!routeNameFromForm) {
            // Clear all related form fields to prevent carrying over old data.
            rsgDestinationNameInput_el_extra.value = '';
            rsg_setCheckedProfiles_ExtraPage(''); // This function clears profile checkboxes
            if (rsgFirstStopTimesInput_el_extra) rsgFirstStopTimesInput_el_extra.value = '';
            rsg_selectedStops_extra = []; // CRITICAL: Clear the stop sequence array
            
            // Reset the state variables
            rsg_currentlyEditingConfigKey_extra = null;
            rsg_currentlyEditingConfigDisplayName_extra = null;
            rsg_isDirty = false; // It's a clean slate, not a dirty state from a previous config
            
            // Update the UI to reflect the cleared state
            rsg_renderStopSequence_ExtraPage(); // This will now show the "add stops" placeholder
            rsg_resetPreviewState("Please select a route to begin a new configuration or load a saved one.", "info");

            // Clear the "last loaded" context
            rsg_lastLoadedRouteName_extra = "";
            rsg_lastLoadedDestName_extra = "";
            rsg_lastLoadedOpProfile_extra = "";
            
            // Refresh dependent dropdowns and exit this function
            rsg_populateDestinationSelect_ExtraPage(); 
            rsg_updateRsgActionButtonsState();
            return; // IMPORTANT: Exit here to avoid running the logic below on a cleared form
        }
        // --- END: NEW LOGIC ---

        // Refresh the current rsg_selectedStops_extra with latest master definitions.
        let namesOrDirectionsUpdatedInCurrentSequence = false;
        if (rsg_selectedStops_extra && Array.isArray(rsg_selectedStops_extra) && allDefinedStops_data) {
            rsg_selectedStops_extra.forEach(stopInSeq => {
                if (stopInSeq.stopID) {
                    const masterStopDef = allDefinedStops_data[stopInSeq.stopID.toUpperCase()];
                    if (masterStopDef) {
                        let changed = false;
                        if (stopInSeq.stopName !== masterStopDef.stopName) {
                            stopInSeq.stopName = masterStopDef.stopName;
                            changed = true;
                        }
                        const masterDirection = masterStopDef.direction || "";
                        if ((stopInSeq.direction || "") !== masterDirection) {
                            stopInSeq.direction = masterDirection;
                            changed = true;
                        }
                        if (changed) namesOrDirectionsUpdatedInCurrentSequence = true;
                    }
                }
            });
        }

        // Compare current form state with the "last loaded" state to detect changes
        let identityHasChangedBasedOnFormInputs =
            (routeNameFromForm.toUpperCase() !== (rsg_lastLoadedRouteName_extra || "").toUpperCase()) ||
            (destNameFromForm !== (rsg_lastLoadedDestName_extra || "")) ||
            (opProfileFromForm !== (rsg_lastLoadedOpProfile_extra || ""));

        // If something fundamental about the "identity" of the configuration has changed (route, dest, profile)
        // AND we were previously editing a saved config, then we should clear the editing context.
        if (rsg_currentlyEditingConfigKey_extra && identityHasChangedBasedOnFormInputs) {
            if (rsgStatusMessage_el_extra && !isInitialLoadForSection) { 
                rsgStatusMessage_el_extra.textContent = "Route/Destination/Profile parameters changed from loaded config. Edits are for a new setup.";
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }
            rsg_currentlyEditingConfigKey_extra = null; 
            rsg_currentlyEditingConfigDisplayName_extra = null;
            rsg_isDirty = true; // Mark as dirty because the user is now working on a new/modified config
        } 
        // If not editing a saved config, but identity changed or names updated in sequence, it's a dirty state.
        else if (!rsg_currentlyEditingConfigKey_extra && (identityHasChangedBasedOnFormInputs || namesOrDirectionsUpdatedInCurrentSequence)) {
            if (!isInitialLoadForSection && rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Configuration parameters or stop details updated. Review and generate preview.";
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }
            rsg_isDirty = true; // Mark as dirty
        } 
        // If nothing changed, and we were previously editing a config, stay clean.
        else if (rsg_currentlyEditingConfigKey_extra && !identityHasChangedBasedOnFormInputs && !namesOrDirectionsUpdatedInCurrentSequence) {
             rsg_isDirty = false; // Stay clean if nothing truly changed
        }


        // Always update last loaded context to current form state for future comparisons
        rsg_lastLoadedRouteName_extra = routeNameFromForm;
        rsg_lastLoadedDestName_extra = destNameFromForm;
        rsg_lastLoadedOpProfile_extra = opProfileFromForm; 
        
        rsg_renderStopSequence_ExtraPage(); // This will now use the potentially updated names/directions
        
        // Initial message for empty RSG when first loading section, or after clear.
        if (isInitialLoadForSection && rsg_selectedStops_extra.length === 0 && rsgFirstStopTimesInput_el_extra && rsgFirstStopTimesInput_el_extra.value === '') {
            rsg_resetPreviewState("Build a sequence or load a saved configuration.", "info");
        } else if (!rsg_isDirty && rsgStatusMessage_el_extra && rsgStatusMessage_el_extra.textContent === "Configuration changed. Please (re)generate preview or add short workings.") {
            if (rsgStatusMessage_el_extra.style.color !== 'rgb(231, 76, 60)' && rsgStatusMessage_el_extra.style.color !== '#e74c3c') {
                rsg_resetPreviewState(`Ready for generation. Current status: ${rsg_isDirty ? 'Dirty' : 'Clean'}.`, "info");
            }
        }
        else if (rsg_isDirty && !isInitialLoadForSection && rsgStatusMessage_el_extra && !rsgStatusMessage_el_extra.textContent.includes("parameters changed")) {
             rsg_resetPreviewState("Changes detected. Regenerate preview or save.", "info");
        }
    }
    rsg_updateRsgActionButtonsState(); // Update button states based on final form/selection state
}

        function rsg_handleSaveConfiguration_ExtraPage() {
    if (!currentUser_extra) {
        alert("Please log in to save configurations.");
        return;
    }
    // Basic check: ensure essential fields for naming are present before opening modal
    const routeName = rsgRouteNameInput_el_extra.value.trim();
    const destName = rsgDestinationNameInput_el_extra.value.trim();
    const opProfiles = rsg_getSelectedOpProfilesString_ExtraPage();

    if (!routeName || !destName || !opProfiles) {
         if(rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route, Destination, and Operating Profile(s) must be selected to save.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    if (rsg_selectedStops_extra.length === 0 || !rsgFirstStopTimesInput_el_extra.value.trim()) {
         if(rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Stop Sequence and First Stop Times are required to save.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    rsg_showSaveConfigModal_ExtraPage();
}

        function rsg_handleDestinationNameInputChange_ExtraPage() {
    if (!rsgDestinationNameInput_el_extra || !rsgDestinationNameSelect_el_extra) return;
    const typedDest = rsgDestinationNameInput_el_extra.value.trim();
    const matchedOption = Array.from(rsgDestinationNameSelect_el_extra.options).find(opt => opt.value === typedDest);
    if (matchedOption) {
        rsgDestinationNameSelect_el_extra.value = matchedOption.value;
        if (rsgDestinationNameInput_el_extra.value !== matchedOption.value) rsgDestinationNameInput_el_extra.value = matchedOption.value;
    } else {
        rsgDestinationNameSelect_el_extra.value = "";
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

        async function rsg_loadOrPullConfiguration_ExtraPage(configKeyToLoad = null, isInitialLoadForSection = false) {
    if (!rsgRouteNameInput_el_extra || // Now refers to hidden input
        !rsgDestinationNameInput_el_extra ||
        !rsgFirstStopTimesInput_el_extra ||
        !rsgStatusMessage_el_extra || !window.firebaseOMSI) {
        console.warn("RSG Load/Pull: Aborted - Essential DOM element or Firebase missing.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "RSG components missing or Firebase not ready.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    // Now get the route name directly from rsg_selectedRoute_extra (or its hidden input for safety)
    const routeNameFromForm = rsg_selectedRoute_extra || rsgRouteNameInput_el_extra.value.trim();
    const opProfileFromForm = rsg_getSelectedOpProfilesString_ExtraPage();
    const destNameFromForm = rsgDestinationNameInput_el_extra.value.trim();
    const loadStatusMsg = document.getElementById('rsg-load-status-message-extra');


    if (configKeyToLoad) { // A specific saved configuration is being loaded (e.g., from the saved configs list)
        const configData = rsg_loadedConfigs_extra[configKeyToLoad];
        if (configData) {
            let loadedConfig = JSON.parse(JSON.stringify(configData)); // Deep copy

            rsg_currentlyEditingConfigKey_extra = configKeyToLoad;
            rsg_currentlyEditingConfigDisplayName_extra = loadedConfig.userDisplayName || configKeyToLoad;

            // Update the global selected route and the hidden input
            rsg_selectedRoute_extra = loadedConfig.routeName || ""; 
            rsgRouteNameInput_el_extra.value = rsg_selectedRoute_extra;
            // Update the display for the route tile selection
            if (rsgSelectedRouteDisplay_el_extra) {
                rsgSelectedRouteDisplay_el_extra.textContent = rsg_selectedRoute_extra || '(None selected)';
            }
            // Visually select the tile
            rsgRouteSelectionContainer_el_extra.querySelectorAll('.selectable-route-tile').forEach(tile => {
                if (tile.dataset.routeName && tile.dataset.routeName.toUpperCase() === rsg_selectedRoute_extra.toUpperCase()) {
                    tile.classList.add('selected');
                } else {
                    tile.classList.remove('selected');
                }
            });


            rsgDestinationNameInput_el_extra.value = loadedConfig.destinationName || "";
            rsg_setCheckedProfiles_ExtraPage(loadedConfig.operatingProfile || "");

            let namesOrDirectionsUpdatedInLoadedConfig = false;
            if (loadedConfig.stopSequence && Array.isArray(loadedConfig.stopSequence) && allDefinedStops_data) {
                loadedConfig.stopSequence.forEach(stopInSeq => {
                    if (stopInSeq.stopID) {
                        const masterStopDef = allDefinedStops_data[stopInSeq.stopID.toUpperCase()];
                        if (masterStopDef) {
                            if (stopInSeq.stopName !== masterStopDef.stopName) {
                                stopInSeq.stopName = masterStopDef.stopName;
                                namesOrDirectionsUpdatedInLoadedConfig = true;
                            }
                            const masterDirection = masterStopDef.direction || "";
                            if ((stopInSeq.direction || "") !== masterDirection) {
                                stopInSeq.direction = masterDirection;
                                namesOrDirectionsUpdatedInLoadedConfig = true;
                            }
                        }
                    }
                });
            }

            rsg_selectedStops_extra = loadedConfig.stopSequence || [];
            if (rsgFirstStopTimesInput_el_extra) {
                rsgFirstStopTimesInput_el_extra.value = loadedConfig.firstStopTimes || '';
            }

            // Update last loaded context variables from the loaded config
            rsg_lastLoadedRouteName_extra = loadedConfig.routeName || "";
            rsg_lastLoadedDestName_extra = loadedConfig.destinationName || "";
            rsg_lastLoadedOpProfile_extra = loadedConfig.operatingProfile || "";
            
            let statusMessageText = `Loaded configuration: "${rsg_currentlyEditingConfigDisplayName_extra}".`;
            if (namesOrDirectionsUpdatedInLoadedConfig) {
                statusMessageText += " Stop names/directions updated to latest. Save to persist.";
                rsg_isDirty = true; // Mark as dirty as it differs from originally saved state due to refresh
                if (loadStatusMsg) loadStatusMsg.style.color = "#27ae60";
            } else {
                rsg_isDirty = false;
                if (loadStatusMsg) loadStatusMsg.style.color = "#2ecc71";
            }

            rsg_resetPreviewState(statusMessageText, "success");
            if (loadStatusMsg) loadStatusMsg.textContent = statusMessageText;

        } else { // Config key provided, but data not found
            if (loadStatusMsg) {
                loadStatusMsg.textContent = `Error: Could not find data for saved configuration key "${configKeyToLoad}". Current sequence retained.`;
                loadStatusMsg.style.color = "#e74c3c";
            }
            rsg_currentlyEditingConfigKey_extra = null;
            rsg_currentlyEditingConfigDisplayName_extra = null;
            rsg_isDirty = true; 
            rsg_resetPreviewState("Failed to load saved configuration. Review inputs or continue.", "error");
        }
    } else { 
        // No specific configKeyToLoad: This means the RSG section is being displayed/refreshed,
        // or form parameters (route/dest/profile) changed.

        // First, check if the currently selected route (from tiles) is still valid in rsg_selectedRoute_extra.
        // If not, clear the form to ensure a fresh start for a new config.
        if (!rsg_selectedRoute_extra) { // If no route is selected via tiles, clear other related fields
            rsgDestinationNameInput_el_extra.value = '';
            rsg_setCheckedProfiles_ExtraPage(''); // Clear profiles
            rsgFirstStopTimesInput_el_extra.value = '';
            rsg_selectedStops_extra = []; // Clear stop sequence
            rsg_currentlyEditingConfigKey_extra = null;
            rsg_currentlyEditingConfigDisplayName_extra = null;
            rsg_isDirty = false;
            rsg_renderStopSequence_ExtraPage(); // Re-render sequence to show empty
            rsg_resetPreviewState("Please select a route to begin a new configuration or load a saved one.", "info");
            // No need to proceed further if no route is selected, as other parameters are cleared.
            rsg_lastLoadedRouteName_extra = "";
            rsg_lastLoadedDestName_extra = "";
            rsg_lastLoadedOpProfile_extra = "";
            rsg_populateDestinationSelect_ExtraPage(); // Refresh destinations based on empty route
            return;
        }

        // Refresh the current rsg_selectedStops_extra with latest master definitions.
        let namesOrDirectionsUpdatedInCurrentSequence = false;
        if (rsg_selectedStops_extra && Array.isArray(rsg_selectedStops_extra) && allDefinedStops_data) {
            rsg_selectedStops_extra.forEach(stopInSeq => {
                if (stopInSeq.stopID) {
                    const masterStopDef = allDefinedStops_data[stopInSeq.stopID.toUpperCase()];
                    if (masterStopDef) {
                        let changed = false;
                        if (stopInSeq.stopName !== masterStopDef.stopName) {
                            stopInSeq.stopName = masterStopDef.stopName;
                            changed = true;
                        }
                        const masterDirection = masterStopDef.direction || "";
                        if ((stopInSeq.direction || "") !== masterDirection) {
                            stopInSeq.direction = masterDirection;
                            changed = true;
                        }
                        if (changed) namesOrDirectionsUpdatedInCurrentSequence = true;
                    }
                }
            });
        }

        // Compare current form state with the "last loaded" state to detect changes
        let identityHasChangedBasedOnFormInputs =
            (routeNameFromForm.toUpperCase() !== (rsg_lastLoadedRouteName_extra || "").toUpperCase()) ||
            (destNameFromForm !== (rsg_lastLoadedDestName_extra || "")) ||
            (opProfileFromForm !== (rsg_lastLoadedOpProfile_extra || ""));

        // If something fundamental about the "identity" of the configuration has changed (route, dest, profile)
        // AND we were previously editing a saved config, then we should clear the editing context.
        if (rsg_currentlyEditingConfigKey_extra && identityHasChangedBasedOnFormInputs) {
            if (rsgStatusMessage_el_extra && !isInitialLoadForSection) { 
                rsgStatusMessage_el_extra.textContent = "Route/Destination/Profile parameters changed from loaded config. Edits are for a new setup.";
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }
            rsg_currentlyEditingConfigKey_extra = null; 
            rsg_currentlyEditingConfigDisplayName_extra = null;
            rsg_isDirty = true; // Mark as dirty because the user is now working on a new/modified config
        } 
        // If not editing a saved config, but identity changed or names updated in sequence, it's a dirty state.
        else if (!rsg_currentlyEditingConfigKey_extra && (identityHasChangedBasedOnFormInputs || namesOrDirectionsUpdatedInCurrentSequence)) {
            if (!isInitialLoadForSection && rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Configuration parameters or stop details updated. Review and generate preview.";
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }
            rsg_isDirty = true; // Mark as dirty
        } 
        // If nothing changed, and we were previously editing a config, stay clean.
        else if (rsg_currentlyEditingConfigKey_extra && !identityHasChangedBasedOnFormInputs && !namesOrDirectionsUpdatedInCurrentSequence) {
             rsg_isDirty = false; // Stay clean if nothing truly changed
        }


        // Always update last loaded context to current form state for future comparisons
        rsg_lastLoadedRouteName_extra = routeNameFromForm;
        rsg_lastLoadedDestName_extra = destNameFromForm;
        rsg_lastLoadedOpProfile_extra = opProfileFromForm; 
        
        rsg_renderStopSequence_ExtraPage(); // This will now use the potentially updated names/directions
        
        // Initial message for empty RSG when first loading section, or after clear.
        if (isInitialLoadForSection && rsg_selectedStops_extra.length === 0 && rsgFirstStopTimesInput_el_extra && rsgFirstStopTimesInput_el_extra.value === '') {
            rsg_resetPreviewState("Build a sequence or load a saved configuration.", "info");
        } else if (!rsg_isDirty && rsgStatusMessage_el_extra && rsgStatusMessage_el_extra.textContent === "Configuration changed. Please (re)generate preview or add short workings.") {
            // If it was already set to "Configuration changed" and now is clean, keep the status if it's info/success.
            // But if it was an error, clear it.
            if (rsgStatusMessage_el_extra.style.color !== 'rgb(231, 76, 60)' && rsgStatusMessage_el_extra.style.color !== '#e74c3c') {
                rsg_resetPreviewState(`Ready for generation. Current status: ${rsg_isDirty ? 'Dirty' : 'Clean'}.`, "info");
            }
        }
        else if (rsg_isDirty && !isInitialLoadForSection && rsgStatusMessage_el_extra && !rsgStatusMessage_el_extra.textContent.includes("parameters changed")) {
            // Only set if not initial load, is dirty, and not already showing a more specific "parameters changed" message.
             rsg_resetPreviewState("Changes detected. Regenerate preview or save.", "info");
        }
        // If an error message is already displayed, don't overwrite it here.
    }

    rsg_updateRsgActionButtonsState(); // Update button states based on final form/selection state
}

        // ++ RSG Helper Function to create 'Copy Time Adjustment' buttons (sorted) ++
        function rsg_createCopyAdjustmentButtons_ExtraPage(currentStopInSequence, stopIndexInCurrentSequence, buttonsContainer) {
            if (!currentStopInSequence || !buttonsContainer || !rsg_loadedConfigs_extra || typeof rsg_loadedConfigs_extra !== 'object') {
                return;
            }

            buttonsContainer.innerHTML = ''; // Clear any existing buttons or placeholder text

            const currentRsgRouteName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
            const targetStopID = currentStopInSequence.stopID;
            
            const potentialButtonsData = [];
            const addedButtonSignatures = new Set(); // To track added "RouteName|Adjustment" for uniqueness

            for (const configKey in rsg_loadedConfigs_extra) {
                const sourceConfig = rsg_loadedConfigs_extra[configKey];

                if (!sourceConfig.routeName || sourceConfig.routeName.toUpperCase() === currentRsgRouteName || !Array.isArray(sourceConfig.stopSequence)) {
                    continue;
                }

                let sourceStopData = null;
                let sourceStopIndexInItsConfig = -1;

                for (let i = 0; i < sourceConfig.stopSequence.length; i++) {
                    if (sourceConfig.stopSequence[i].stopID === targetStopID) {
                        sourceStopData = sourceConfig.stopSequence[i];
                        sourceStopIndexInItsConfig = i;
                        break; 
                    }
                }

                if (sourceStopData && sourceStopIndexInItsConfig > 0) { // Must exist and not be the first stop in its own sequence
                    const timeAdjustmentToCopy = sourceConfig.stopSequence[sourceStopIndexInItsConfig].timeAdjustment;

                    if (typeof timeAdjustmentToCopy === 'number') {
                        const buttonSignature = `${sourceConfig.routeName}|${timeAdjustmentToCopy}`;

                        if (!addedButtonSignatures.has(buttonSignature)) {
                            potentialButtonsData.push({
                                routeName: sourceConfig.routeName,
                                timeAdjustment: timeAdjustmentToCopy,
                                operatingProfile: sourceConfig.operatingProfile || 'N/A',
                                destinationName: sourceConfig.destinationName || 'N/A'
                            });
                            addedButtonSignatures.add(buttonSignature);
                        }
                    }
                }
            }

            if (potentialButtonsData.length > 0) {
                // Sort the collected button data by routeName
                potentialButtonsData.sort((a, b) => compareLineNames_ExtraPage(a.routeName, b.routeName));

                // Now create and append buttons in sorted order
                potentialButtonsData.forEach(data => {
                    const button = document.createElement('button');
                    button.classList.add('button', 'small-action', 'neutral', 'copy-adj-button');
                    button.textContent = `Copy From ${data.routeName} (+${data.timeAdjustment} min)`;
                    button.title = `Copy ${data.timeAdjustment} min from ${data.routeName} (Profile: ${data.operatingProfile}, Dest: ${data.destinationName})`;

                    button.addEventListener('click', () => {
                        rsg_selectedStops_extra[stopIndexInCurrentSequence].timeAdjustment = data.timeAdjustment;
                        const listItem = rsgStopSequenceList_el_extra.querySelector(`li[data-index="${stopIndexInCurrentSequence}"]`);
                        if (listItem) {
                            const timeAdjInput = listItem.querySelector('.rsg-time-adjustment-input');
                            if (timeAdjInput) {
                                timeAdjInput.value = data.timeAdjustment;
                            }
                        }
                        rsg_resetPreviewState(`Time adjustment (${data.timeAdjustment} min) copied from Route ${data.routeName}. Regenerate preview.`, "info");
                    });
                    buttonsContainer.appendChild(button);
                });
            } else {
                 buttonsContainer.innerHTML = `<span style="font-size:0.75em; opacity:0.7; display:block; margin-top:0.3rem; width:100%;">No other routes serve this stop to copy adjustment from.</span>`;
            }
        }

        // In omsi_tools_extra.html

function rsg_renderStopSequence_ExtraPage() {
    if (!rsgStopSequenceList_el_extra || !rsgStopSequencePlaceholder_el_extra || !rsgFirstStopTimesContainer_el_extra) {
        console.error("RSG Render: Critical elements for rendering stop sequence are missing.");
        return;
    }

    // console.log(`RSG Render: Starting. Stop count in sequence: ${rsg_selectedStops_extra.length}. IsDirty flag: ${rsg_isDirty}.`);

    rsgStopSequenceList_el_extra.innerHTML = ''; // Clear existing items

    if (rsg_selectedStops_extra.length === 0) {
        rsgStopSequencePlaceholder_el_extra.style.display = 'block';
        rsgFirstStopTimesContainer_el_extra.style.display = 'none';
        // console.log("RSG Render: No stops in sequence, showing placeholder.");
    } else {
        rsgStopSequencePlaceholder_el_extra.style.display = 'none';
        rsgFirstStopTimesContainer_el_extra.style.display = 'block';

        rsg_selectedStops_extra.forEach((stop, loopIndex) => {
            if (!stop || typeof stop.stopID === 'undefined') {
                console.warn(`RSG Render: Skipping invalid stop data at index ${loopIndex}.`, stop);
                return; 
            }
            // console.log(`RSG Render: Processing stop at index ${loopIndex}, ID: ${stop.stopID}, Name: ${stop.stopName}`);

            const li = document.createElement('li');
            li.dataset.index = loopIndex; 
            li.draggable = true;

            const mainContentDiv = document.createElement('div');
            mainContentDiv.classList.add('rsg-li-main-content');

            const stopInfoDiv = document.createElement('div');
            stopInfoDiv.classList.add('rsg-stop-info');

            let directionTextForRsgDisplay = "";
            if (stop.direction &&
                stop.direction.trim() !== "" &&
                stop.direction.trim().toUpperCase() !== "NO DIRECTION") {
                directionTextForRsgDisplay = `Towards: ${stop.direction}`;
            }
            
            stopInfoDiv.innerHTML = `<span class="rsg-stop-name">${stop.stopName || 'N/A'}</span> <span class="rsg-stop-id">(${stop.stopID})</span>`;
            if (directionTextForRsgDisplay) { 
                 stopInfoDiv.innerHTML += `<br><small style="opacity:0.7;">${directionTextForRsgDisplay}</small>`;
            }

            const actionsDiv = document.createElement('div');
            actionsDiv.classList.add('rsg-stop-actions');

            let timeAdjInput = null;

            const renderOrUpdateWarningIcon = (currentIndex, currentStopData, inputElementForWarning, parentActionsDivForWarning) => {
                if (!inputElementForWarning || !parentActionsDivForWarning) {
                    // console.warn("renderOrUpdateWarningIcon: Missing inputElement or parentActionsDiv for index:", currentIndex);
                    return;
                }
                const existingWarning = parentActionsDivForWarning.querySelector('.rsg-time-adj-warning');
                if (existingWarning) {
                    existingWarning.remove();
                }

                const otherAdjustmentsInfo = rsg_getOtherRouteAdjustmentsForStop(currentStopData.stopID, rsg_currentlyEditingConfigKey_extra);
                const currentStopActualAdjustment = (typeof rsg_selectedStops_extra[currentIndex]?.timeAdjustment === 'number' && !isNaN(rsg_selectedStops_extra[currentIndex].timeAdjustment))
                    ? rsg_selectedStops_extra[currentIndex].timeAdjustment
                    : 0;

                if (otherAdjustmentsInfo.mostCommonValue !== null &&
                    currentStopActualAdjustment !== otherAdjustmentsInfo.mostCommonValue) {

                    const warningIcon = document.createElement('span');
                    warningIcon.className = 'rsg-time-adj-warning';
                    warningIcon.textContent = ' '; 
                    warningIcon.style.cursor = 'pointer';
                    warningIcon.style.color = '#f39c12'; 
                    warningIcon.style.fontSize = '1.1em';
                    warningIcon.style.marginLeft = '5px';
                    warningIcon.title = otherAdjustmentsInfo.suggestionTitle || `Commonly +${otherAdjustmentsInfo.mostCommonValue} min on other routes. Click to apply.`;

                    warningIcon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const targetAdjustment = otherAdjustmentsInfo.mostCommonValue;
                        if (targetAdjustment !== null && rsg_selectedStops_extra[currentIndex]) {
                            rsg_selectedStops_extra[currentIndex].timeAdjustment = targetAdjustment;
                            if (inputElementForWarning) inputElementForWarning.value = targetAdjustment;
                            warningIcon.remove();
                            rsg_isDirty = true;
                            if (rsgStatusMessage_el_extra) {
                                rsgStatusMessage_el_extra.textContent = `Time adjustment for '${currentStopData.stopName}' updated to +${targetAdjustment} min. Regenerate preview.`;
                                rsgStatusMessage_el_extra.style.color = '#2ecc71';
                            }
                            rsg_resetPreviewState("Time adjustment updated from suggestion. Regenerate preview.", "info");
                            rsg_updateRsgActionButtonsState();
                        }
                    });
                    const removeBtnInTheseActions = parentActionsDivForWarning.querySelector('button.secondary');
                    if (removeBtnInTheseActions) {
                        parentActionsDivForWarning.insertBefore(warningIcon, removeBtnInTheseActions);
                    } else {
                        parentActionsDivForWarning.appendChild(warningIcon);
                    }
                }
            };

            if (loopIndex > 0) { 
                timeAdjInput = document.createElement('input');
                timeAdjInput.type = 'number';
                timeAdjInput.classList.add('schedule-generator-input', 'rsg-time-adjustment-input');
                timeAdjInput.min = '0'; 
                timeAdjInput.max = '120'; 
                timeAdjInput.title = 'Minutes from previous stop';
                timeAdjInput.value = (typeof stop.timeAdjustment === 'number' && !isNaN(stop.timeAdjustment)) ? stop.timeAdjustment : 0;
                
                actionsDiv.appendChild(timeAdjInput); 

                renderOrUpdateWarningIcon(loopIndex, stop, timeAdjInput, actionsDiv); 

                timeAdjInput.addEventListener('input', (e) => {
                    e.stopPropagation();
                    rsg_isDirty = true;
                    const currentLiElement = timeAdjInput.closest('li');
                    if (!currentLiElement) return;
                    const changedIndex = parseInt(currentLiElement.dataset.index);
                    
                    if (rsg_selectedStops_extra[changedIndex]) {
                        let newValueFromInput = parseInt(timeAdjInput.value, 10);
                        if (!isNaN(newValueFromInput) && newValueFromInput >= 0) {
                            rsg_selectedStops_extra[changedIndex].timeAdjustment = newValueFromInput;
                        } else { 
                            rsg_selectedStops_extra[changedIndex].timeAdjustment = 0;
                            if (isNaN(newValueFromInput) || newValueFromInput < 0) timeAdjInput.value = 0; 
                        }
                        renderOrUpdateWarningIcon(changedIndex, rsg_selectedStops_extra[changedIndex], timeAdjInput, actionsDiv);
                        rsg_updateRsgActionButtonsState();
                        rsg_resetPreviewState("Time adjustment changed. Regenerate preview.", "info");
                    }
                });
            }

            const changeStopButton = document.createElement('button');
            changeStopButton.innerHTML = ''; 
            changeStopButton.classList.add('button', 'small-action', 'neutral');
            changeStopButton.title = 'Change this stop in the sequence';
            changeStopButton.style.marginRight = '4px';
            changeStopButton.addEventListener('click', (e) => {
                e.stopPropagation(); 
                const currentIndex = parseInt(li.dataset.index); 
                // --- ADD LOGGING ---
                console.log("[RSG Change Button] Clicked! Index from li.dataset.index:", li.dataset.index, "Parsed currentIndex:", currentIndex);
                if (isNaN(currentIndex)) {
                    console.error("[RSG Change Button] Error: currentIndex is NaN. li.dataset.index was:", li.dataset.index);
                    alert("Error: Could not determine which stop to change.");
                    return;
                }
                // --- END LOGGING ---
                if (typeof rsg_openReplaceStopModal_ExtraPage === 'function') {
                    // --- ADD LOGGING ---
                    console.log("[RSG Change Button] Calling rsg_openReplaceStopModal_ExtraPage with index:", currentIndex);
                    // --- END LOGGING ---
                    rsg_openReplaceStopModal_ExtraPage(currentIndex);
                } else {
                    console.error("[RSG Change Button] Error: rsg_openReplaceStopModal_ExtraPage function is not defined.");
                    alert("Error: The action for changing a stop is currently unavailable.");
                }
            });
            actionsDiv.appendChild(changeStopButton);

            const removeButton = document.createElement('button');
            removeButton.textContent = ''; 
            removeButton.classList.add('button', 'small-action', 'secondary');
            removeButton.title = 'Remove this stop from sequence';
            removeButton.addEventListener('click', (e) => {
                e.stopPropagation();
                rsg_removeStopFromSequence_ExtraPage(parseInt(li.dataset.index));
            });
            actionsDiv.appendChild(removeButton);

            mainContentDiv.appendChild(stopInfoDiv);
            mainContentDiv.appendChild(actionsDiv);
            li.appendChild(mainContentDiv);

            if (loopIndex > 0 && timeAdjInput) { 
                const copyButtonsContainer = document.createElement('div');
                copyButtonsContainer.classList.add('rsg-copy-adjustment-buttons-container');
                if (typeof rsg_createCopyAdjustmentButtons_ExtraPage === 'function') {
                    rsg_createCopyAdjustmentButtons_ExtraPage(stop, loopIndex, copyButtonsContainer, timeAdjInput, actionsDiv, renderOrUpdateWarningIcon);
                }
                li.appendChild(copyButtonsContainer);
            }
            
            rsgStopSequenceList_el_extra.appendChild(li);

            li.addEventListener('dragstart', rsg_handleDragStart_ExtraPage);
            li.addEventListener('dragover', rsg_handleDragOver_ExtraPage);
            li.addEventListener('dragleave', rsg_handleDragLeave_ExtraPage);
            li.addEventListener('drop', rsg_handleDrop_ExtraPage);
            li.addEventListener('dragend', rsg_handleDragEnd_ExtraPage);
        });
        // console.log("RSG Render: Sequence item rendering loop finished.");
    }
}

async function handleApplyMasterListStopIdChangesButton_ExtraPage() {
    if (!currentUser_extra || !masterStopListUL_el_extra || !masterListApplyChangesStatus_el_extra) {
        if (masterListApplyChangesStatus_el_extra) {
            masterListApplyChangesStatus_el_extra.textContent = "Error: System not ready or user not logged in.";
            masterListApplyChangesStatus_el_extra.style.color = '#e74c3c';
        }
        return;
    }

    masterListApplyChangesStatus_el_extra.textContent = "Processing proposed Stop ID changes...";
    masterListApplyChangesStatus_el_extra.style.color = '#f1c40f';

    const idChangeProposals = []; // Stores { originalId: string, newId: string (uppercase) }
    const allInputs = masterStopListUL_el_extra.querySelectorAll('.master-list-new-id-input');
    let hasErrors = false;
    const newProposedIDsInThisBatchSet = new Set(); // Tracks new IDs proposed in this specific batch
    const existingDefinedIDsUppercaseSet = new Set(Object.keys(allDefinedStops_data || {}).map(id => id.toUpperCase()));

    allInputs.forEach(input => {
        const originalIdFromDataset = input.dataset.originalId; // Original case from when list was rendered
        const newIdProposed = input.value.trim().toUpperCase(); // New IDs are proposed in uppercase
        const warningElement = input.parentElement.querySelector('.master-list-row-warning');
        if (warningElement) warningElement.textContent = '';

        if (newIdProposed && newIdProposed !== originalIdFromDataset.toUpperCase()) { // Only process actual changes
            if (!/^[A-Z0-9]+$/.test(newIdProposed)) {
                if (warningElement) warningElement.textContent = "Invalid characters in new ID.";
                hasErrors = true; return;
            }
            if (newProposedIDsInThisBatchSet.has(newIdProposed)) {
                if (warningElement) warningElement.textContent = "This new ID is duplicated in another proposal in this batch.";
                hasErrors = true; return;
            }
            // Check if new ID conflicts with an existing defined stop that ISN'T the one being renamed
            if (existingDefinedIDsUppercaseSet.has(newIdProposed) && newIdProposed !== originalIdFromDataset.toUpperCase()) {
                if (warningElement) warningElement.textContent = "This new ID already exists for a different stop.";
                hasErrors = true; return;
            }
            idChangeProposals.push({ originalId: originalIdFromDataset, newId: newIdProposed });
            newProposedIDsInThisBatchSet.add(newIdProposed);
        }
    });

    if (hasErrors) {
        masterListApplyChangesStatus_el_extra.textContent = "Errors in proposed IDs. Please correct and retry.";
        masterListApplyChangesStatus_el_extra.style.color = '#e74c3c';
        return;
    }

    if (idChangeProposals.length === 0) {
        masterListApplyChangesStatus_el_extra.textContent = "No actual Stop ID changes were proposed.";
        masterListApplyChangesStatus_el_extra.style.color = '#7f8c8d';
        return;
    }

    if (!confirm(`Are you sure you want to apply these ${idChangeProposals.length} Stop ID changes? This will update definitions, schedules, and related settings in Firebase.`)) {
        masterListApplyChangesStatus_el_extra.textContent = "Bulk Stop ID change operation cancelled by user.";
        masterListApplyChangesStatus_el_extra.style.color = '';
        return;
    }

    let definitionsModifiedInCache = false;
    let scheduleEntriesModifiedCount = 0;
    let closedStopsListModifiedInCache = false;
    let stopColorsModifiedInCache = false;

    // 1. Update allDefinedStops_data (local cache)
    // Keys in allDefinedStops_data should already be uppercase from loading/normalization.
    idChangeProposals.forEach(proposal => {
        const originalIdUpper = proposal.originalId.toUpperCase();
        const newIdUpper = proposal.newId; // Already uppercase

        if (allDefinedStops_data && allDefinedStops_data[originalIdUpper]) {
            const stopObjectToMove = { ...allDefinedStops_data[originalIdUpper] }; // Clone
            stopObjectToMove.stopID = newIdUpper; // Update the stopID property within the object

            delete allDefinedStops_data[originalIdUpper];
            allDefinedStops_data[newIdUpper] = stopObjectToMove;
            definitionsModifiedInCache = true;
        } else {
            console.warn(`Cannot rename stop definition: Original ID ${originalIdUpper} not found in allDefinedStops_data.`);
        }
    });

    // 2. Update stopID in currentWorkingSchedule_extra (local cache)
    if (Array.isArray(currentWorkingSchedule_extra) && currentWorkingSchedule_extra.length > 0) {
        currentWorkingSchedule_extra.forEach(entry => {
            if (entry.stopID) {
                const originalEntryStopIDUpper = entry.stopID.toUpperCase();
                let newStopIDForThisEntry = null;

                for (const proposal of idChangeProposals) {
                    if (proposal.originalId.toUpperCase() === originalEntryStopIDUpper) {
                        newStopIDForThisEntry = proposal.newId;
                        break;
                    }
                }

                if (newStopIDForThisEntry) {
                    entry.stopID = newStopIDForThisEntry; // Update to new (uppercase) ID
                    const masterDefForNewID = allDefinedStops_data[newStopIDForThisEntry];
                    if (masterDefForNewID) { // Refresh name/direction from master
                        entry.stopName = masterDefForNewID.stopName;
                        entry.direction = masterDefForNewID.direction;
                    }
                    scheduleEntriesModifiedCount++;
                }
            }
        });
    }

    // 3. Update closedStopIDs_extra (local cache)
    if (Array.isArray(closedStopIDs_extra) && closedStopIDs_extra.length > 0) {
        const originalClosedStopIDsSnapshot = [...closedStopIDs_extra];
        const updatedClosedStopIDsSet = new Set();
        closedStopIDs_extra.forEach(closedId => {
            const closedIdUpper = closedId.toUpperCase();
            let correspondingNewId = closedIdUpper;
            for (const proposal of idChangeProposals) {
                if (proposal.originalId.toUpperCase() === closedIdUpper) {
                    correspondingNewId = proposal.newId;
                    break;
                }
            }
            updatedClosedStopIDsSet.add(correspondingNewId);
        });
        closedStopIDs_extra = Array.from(updatedClosedStopIDsSet);
        if (closedStopIDs_extra.length !== originalClosedStopIDsSnapshot.length || 
            !originalClosedStopIDsSnapshot.every(id => updatedClosedStopIDsSet.has(id.toUpperCase()))) {
            closedStopsListModifiedInCache = true;
        }
    }

    // 4. Update stopSpecificRouteColours_extra (local cache)
    // Ensure keys become uppercase if they weren't already.
    if (stopSpecificRouteColours_extra && typeof stopSpecificRouteColours_extra === 'object' && Object.keys(stopSpecificRouteColours_extra).length > 0) {
        const newColoursObject = {};
        let actualColorChangeOccurred = false;
        for (const originalColorKey in stopSpecificRouteColours_extra) {
            const originalColorKeyUpper = originalColorKey.toUpperCase();
            let newKeyForColorData = originalColorKeyUpper;

            for (const proposal of idChangeProposals) {
                if (proposal.originalId.toUpperCase() === originalColorKeyUpper) {
                    newKeyForColorData = proposal.newId;
                    break;
                }
            }
            newColoursObject[newKeyForColorData] = stopSpecificRouteColours_extra[originalColorKey];
            if (newKeyForColorData !== originalColorKey || originalColorKey !== originalColorKeyUpper) { // Catches rename or case normalization
                actualColorChangeOccurred = true;
            }
        }
        if (actualColorChangeOccurred || Object.keys(newColoursObject).length !== Object.keys(stopSpecificRouteColours_extra).length) {
            stopSpecificRouteColours_extra = newColoursObject;
            stopColorsModifiedInCache = true;
        }
    }

    // 5. Persist all changes to Firebase
    if (definitionsModifiedInCache || scheduleEntriesModifiedCount > 0 || closedStopsListModifiedInCache || stopColorsModifiedInCache) {
        masterListApplyChangesStatus_el_extra.textContent = "Saving changes to Firebase...";
        try {
            if (definitionsModifiedInCache && typeof saveAllDefinedStopsToFirebase_ExtraPage === 'function') {
                await saveAllDefinedStopsToFirebase_ExtraPage();
            }

            // Always rebuild schedule if definitions changed OR schedule entries were touched,
            // as ancillary data (like uniqueBusStops with service) needs recalculation.
            if ((definitionsModifiedInCache || scheduleEntriesModifiedCount > 0) && typeof rebuildAndSaveEntireScheduleToFirebase_ExtraPage === 'function') {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
            }

            if (closedStopsListModifiedInCache && typeof saveClosedStopsToFirebase_ExtraPage === 'function') {
                await saveClosedStopsToFirebase_ExtraPage();
            }
            if (stopColorsModifiedInCache && typeof saveStopSpecificColoursToFirebase_ExtraPage === 'function') {
                await saveStopSpecificColoursToFirebase_ExtraPage();
            }

            let summaryMessage = `Successfully applied ${idChangeProposals.length} Stop ID change(s). `;
            summaryMessage += `Definitions updated: ${definitionsModifiedInCache}. `;
            summaryMessage += `Schedule entries affected: ${scheduleEntriesModifiedCount}. `;
            summaryMessage += `Closed stops list updated: ${closedStopsListModifiedInCache}. `;
            summaryMessage += `Colors map updated: ${stopColorsModifiedInCache}.`;
            masterListApplyChangesStatus_el_extra.textContent = summaryMessage;
            masterListApplyChangesStatus_el_extra.style.color = '#2ecc71';
            
            if (typeof renderUIDependentElements_ExtraPage === 'function') {
                renderUIDependentElements_ExtraPage(); // Refresh the UI with persisted changes
            }

        } catch (error) {
            console.error("Error applying bulk Stop ID changes and saving to Firebase:", error);
            masterListApplyChangesStatus_el_extra.textContent = "Error saving bulk ID changes: " + error.message;
            masterListApplyChangesStatus_el_extra.style.color = '#e74c3c';
            alert("A critical error occurred while saving bulk Stop ID changes. Some data might be inconsistent. It is recommended to refresh the page and verify the changes or reload from a backup if necessary.");
            if (typeof loadInitialData_ExtraPage === 'function') {
                 await loadInitialData_ExtraPage(); // Try to resync with DB
            }
        }
    } else {
        masterListApplyChangesStatus_el_extra.textContent = "No data changes were made that required saving to Firebase.";
        masterListApplyChangesStatus_el_extra.style.color = '#7f8c8d';
    }
}

        function rsg_handleDragStart_ExtraPage(event) {  
            rsg_draggedItemIndex_extra = parseInt(event.target.closest('li').dataset.index); event.dataTransfer.effectAllowed = 'move'; event.dataTransfer.setData('text/plain', rsg_draggedItemIndex_extra); setTimeout(() => { event.target.closest('li').classList.add('rsg-dragging-item'); }, 0); if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = "Dragging stop..."; rsgStatusMessage_el_extra.style.color = "#3498db"; }
        }

        function rsg_handleDragOver_ExtraPage(event) { 
            event.preventDefault(); event.dataTransfer.dropEffect = 'move'; const targetLi = event.target.closest('li'); if (targetLi && parseInt(targetLi.dataset.index) !== rsg_draggedItemIndex_extra) { Array.from(rsgStopSequenceList_el_extra.children).forEach(child => child.classList.remove('rsg-dragover-target')); targetLi.classList.add('rsg-dragover-target'); }
        }

        function rsg_handleDragLeave_ExtraPage(event) { 
            const targetLi = event.target.closest('li'); if (targetLi) { targetLi.classList.remove('rsg-dragover-target');}
        }

        function rsg_handleDrop_ExtraPage(event) { 
    event.preventDefault(); 
    const targetLi = event.target.closest('li'); 
    if (!targetLi) return; 
    const droppedOnItemIndex = parseInt(targetLi.dataset.index); 
    Array.from(rsgStopSequenceList_el_extra.children).forEach(child => child.classList.remove('rsg-dragover-target')); 
    if (rsg_draggedItemIndex_extra !== null && rsg_draggedItemIndex_extra !== droppedOnItemIndex) { 
        const itemToMove = rsg_selectedStops_extra.splice(rsg_draggedItemIndex_extra, 1)[0]; 
        rsg_selectedStops_extra.splice(droppedOnItemIndex, 0, itemToMove); 
        rsg_renderStopSequence_ExtraPage(); 
        rsg_resetPreviewState("Stop order changed. Regenerate preview.", "info"); 
        rsg_isDirty = true;
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_handleDragEnd_ExtraPage(event) { 
             Array.from(rsgStopSequenceList_el_extra.children).forEach(childLi => { childLi.classList.remove('rsg-dragging-item'); childLi.classList.remove('rsg-dragover-target'); }); rsg_draggedItemIndex_extra = null;
        }

        function rsg_handleStopSearch_ExtraPage(event) {
    if (!rsgStopSearchInput_el_extra || !rsgStopSearchResults_el_extra) return;
    const searchTerm = rsgStopSearchInput_el_extra.value.toLowerCase().trim();
    rsgStopSearchResults_el_extra.innerHTML = '';

    if (searchTerm.length < 2) {
        return; // Don't search if term is too short
    }

    // Use allDefinedStops_data as the source for all known stops
    // Ensure allDefinedStops_data is an object before calling Object.values
    const definedStopsArray = Object.values(allDefinedStops_data || {});

    const filteredStops = definedStopsArray.filter(stop => {
        // Ensure stop and its properties exist before trying to access them
        const stopName = stop.stopName || "";
        const stopID = stop.stopID || ""; // stop.stopID should be guaranteed if from allDefinedStops_data
        return stopName.toLowerCase().includes(searchTerm) || stopID.toLowerCase().includes(searchTerm);
    }).slice(0, 15); // Show up to 15 results

    if (filteredStops.length > 0) {
        filteredStops.forEach(stop => { // 'stop' here is an object like {stopID, stopName, direction}
            const itemDiv = document.createElement('div');
            itemDiv.classList.add('rsg-search-result-item');

            let content = `<span class="rsg-search-stop-name">${stop.stopName || 'N/A'} (${stop.stopID})</span>`;
            
            // Display direction using the consistent logic
            let directionTextForResult = "";
            if (stop.direction && stop.direction.trim() !== "" && stop.direction.trim().toUpperCase() !== "NO DIRECTION") {
                directionTextForResult = `Towards: ${stop.direction}`;
            }
            // If direction is empty or "No Direction", directionTextForResult remains "", and the line won't be added.
            if (directionTextForResult) {
                content += `<span class="rsg-search-stop-details">${directionTextForResult}</span>`;
            }


            // Display serving routes (will be empty if none serve it)
            // stopToServingRoutesMap_extra is correctly derived from currentWorkingSchedule_extra (active services)
            const servingRoutes = stopToServingRoutesMap_extra.get(stop.stopID) || new Set();

            if (servingRoutes.size > 0) {
                content += `<div class="rsg-search-serving-routes">`;
                Array.from(servingRoutes).sort(compareLineNames_ExtraPage).slice(0, 5).forEach(line => {
                    const bgColor = getRouteTileColour_ExtraPage(line, stop.stopID);
                    const textColor = getTextColourForBackground_ExtraPage(bgColor);
                    content += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor};font-size:0.7em;padding:0.1em 0.3em;">${line}</span>`;
                });
                if (servingRoutes.size > 5) content += `<span style="font-size:0.7em;opacity:0.8;"> +${servingRoutes.size - 5} more</span>`;
                content += `</div>`;
            } else {
                // Indicate that no routes currently serve this defined stop
                content += `<div class="rsg-search-serving-routes" style="font-size:0.7em;opacity:0.7;margin-top:0.2em;">(No routes currently serve this stop)</div>`;
            }

            itemDiv.innerHTML = content;
            itemDiv.addEventListener('click', () => {
                rsg_addStopToSequence_ExtraPage(stop.stopID, stop.stopName, stop.direction);
                rsgStopSearchInput_el_extra.value = '';
                rsgStopSearchResults_el_extra.innerHTML = '';
                rsgStopSearchInput_el_extra.focus();
            });
            rsgStopSearchResults_el_extra.appendChild(itemDiv);
        });
    } else {
        rsgStopSearchResults_el_extra.innerHTML = '<div class="rsg-search-result-item">No defined stops match your search.</div>';
    }
}

        function rsg_addStopToSequence_ExtraPage(stopID, stopName, direction) { 
    if (rsg_selectedStops_extra.length > 0 && rsg_selectedStops_extra[rsg_selectedStops_extra.length -1].stopID === stopID) { 
        if(rsgStatusMessage_el_extra) { 
            rsgStatusMessage_el_extra.textContent = "Stop already last in sequence."; 
            rsgStatusMessage_el_extra.style.color = "#f1c40f"; 
        } 
        return; 
    } 
    rsg_selectedStops_extra.push({ 
        stopID: stopID, 
        stopName: stopName, 
        direction: direction, 
        timeAdjustment: rsg_selectedStops_extra.length > 0 ? 2 : 0 
    }); 
    rsg_renderStopSequence_ExtraPage(); 
    rsg_resetPreviewState("Stop added. Regenerate preview if needed.", "info"); 
    rsg_isDirty = true;
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_removeStopFromSequence_ExtraPage(index) {
    if (rsg_selectedStops_extra && rsg_selectedStops_extra.length > index) {
        rsg_selectedStops_extra.splice(index, 1);
    }
    rsg_isDirty = true;
    rsg_renderStopSequence_ExtraPage();
    rsg_resetPreviewState("Stop removed. Regenerate preview if needed.", "info");
    rsg_updateRsgActionButtonsState(); // Added call
}

        // In omsi_tools_extra.html
function rsg_handleGenerateSchedulePreview_ExtraPage(isPreCheck = false, configDataToProcess = null) {
    if (!rsgRouteNameInput_el_extra ||
        !rsgDestinationNameInput_el_extra ||
        !rsgFirstStopTimesInput_el_extra ||
        !rsgStatusMessage_el_extra) {
        if (!isPreCheck && rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Critical Error: RSG form components missing.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }

    let routeName, opProfileForGeneration, destName, firstStopTimesStr, currentStopSequence;

    if (configDataToProcess) {
        routeName = (configDataToProcess.routeName || "").trim().toUpperCase();
        opProfileForGeneration = configDataToProcess.operatingProfile || "";
        destName = (configDataToProcess.destinationName || "").trim();
        firstStopTimesStr = (configDataToProcess.firstStopTimes || "").trim();
        currentStopSequence = configDataToProcess.stopSequence || [];
    } else {
        routeName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
        opProfileForGeneration = rsg_getSelectedOpProfilesString_ExtraPage();
        destName = rsgDestinationNameInput_el_extra.value.trim();
        firstStopTimesStr = rsgFirstStopTimesInput_el_extra.value.trim();
        currentStopSequence = rsg_selectedStops_extra;
    }

    if (!routeName) {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "Route Name is required.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
    if (!opProfileForGeneration && !configDataToProcess) {
        if (rsg_lastLoadedOpProfile_extra &&
            routeName.toUpperCase() === (rsg_lastLoadedRouteName_extra || "").toUpperCase() &&
            destName === (rsg_lastLoadedDestName_extra || "")) {
            opProfileForGeneration = rsg_lastLoadedOpProfile_extra;
            if (!isPreCheck && rsgStatusMessage_el_extra && !configDataToProcess) {
                rsgStatusMessage_el_extra.dataset.profileAssumed = 'true';
            }
        } else {
            if (!isPreCheck && !configDataToProcess) {
                rsgStatusMessage_el_extra.textContent = "Operating Profile is required.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            return false;
        }
    } else if (!opProfileForGeneration && configDataToProcess) {
        if (!isPreCheck && rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error: Saved configuration for route ${routeName} is missing an operating profile.`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }

    if (!destName) {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "Destination Name is required.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
    if (!currentStopSequence || currentStopSequence.length === 0) {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "Please add at least one stop to the sequence.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }

    const firstStopTimes = firstStopTimesStr.split(/\t|,|;/).map(t => t.trim()).filter(t => t.match(/^\d{2}:\d{2}$/));
    if (firstStopTimes.length === 0 && firstStopTimesStr !== "") {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "Invalid format or no valid times for first stop (HH:MM, TAB/comma/semicolon separated).";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
     if (firstStopTimes.length === 0 && firstStopTimesStr === "") {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "First stop times are required.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }

    rsg_generatedPreviewEntries_extra = [];

    // *** MODIFICATION: Get the stop ID sequence ONCE per generation ***
    const stopIdSequenceForTrip = currentStopSequence.map(s => s.stopID);

    firstStopTimes.forEach(startTimeHHMM => {
        const startParts = startTimeHHMM.split(':');
        let currentMinutesFromMidnight = parseInt(startParts[0], 10) * 60 + parseInt(startParts[1], 10);
        let currentDayOffset = 0;

        // *** MODIFICATION: Define the tripId for this entire trip ***
        const tripId = `${routeName}|${startTimeHHMM}|${destName}`;

        currentStopSequence.forEach((stop, index) => {
            if (!stop || typeof stop.stopID === 'undefined') return;
            if (index > 0) {
                const adjustment = (typeof stop.timeAdjustment === 'number' && !isNaN(stop.timeAdjustment)) ? stop.timeAdjustment : 0;
                currentMinutesFromMidnight += adjustment;
            }
            while (currentMinutesFromMidnight >= 1440) {
                currentMinutesFromMidnight -= 1440; currentDayOffset++;
            }
            while (currentMinutesFromMidnight < 0) {
                currentMinutesFromMidnight += 1440; currentDayOffset--;
            }
            const hours = Math.floor(currentMinutesFromMidnight / 60);
            const minutes = currentMinutesFromMidnight % 60;
            const scheduledTimeOutput = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            
            rsg_generatedPreviewEntries_extra.push({
                internalId: `${stop.stopID}_${routeName}_${scheduledTimeOutput.replace(':', '')}_${opProfileForGeneration.replace(/[^a-zA-Z0-9]/g, '')}_rsg${Date.now()}${index}`,
                stopID: stop.stopID, stopName: stop.stopName, direction: stop.direction,
                lineName: routeName, destinationName: destName, scheduledTime: scheduledTimeOutput,
                OperatingProfile: opProfileForGeneration, DayOffset: String(currentDayOffset),
                // *** MODIFICATION: Add the new properties to each entry ***
                tripId: tripId,
                tripStopSequence: stopIdSequenceForTrip
            });
        });
    });

    if (!isPreCheck && !configDataToProcess) {
        rsg_renderPreviewTable_ExtraPage();

        if (rsgAddToWorkingScheduleButton_el_extra) {
            const canAdd = rsg_generatedPreviewEntries_extra.length > 0;
            rsgAddToWorkingScheduleButton_el_extra.disabled = !canAdd;
            if (canAdd) {
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.add('save');
            } else {
                rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
            }
        }

        if (rsgSchedulePreviewContainer_el_extra) {
            rsgSchedulePreviewContainer_el_extra.style.display = rsg_generatedPreviewEntries_extra.length > 0 ? 'block' : 'none';
        }

        let statusMsg = "";
        let statusColor = "";
        if (rsgStatusMessage_el_extra.dataset.profileAssumed === 'true') {
             statusMsg = `Preview with assumed profile '${opProfileForGeneration}' `;
             statusMsg += rsg_generatedPreviewEntries_extra.length > 0 ? `generated ${rsg_generatedPreviewEntries_extra.length} entries.` : `generated 0 entries. Check inputs.`;
             statusColor = rsg_generatedPreviewEntries_extra.length > 0 ? '#2ecc71' : '#f1c40f';
             statusMsg += " Save will require explicit profile selection if assumption is not desired.";
        } else {
            statusMsg = rsg_generatedPreviewEntries_extra.length > 0 ? `Preview generated for ${rsg_generatedPreviewEntries_extra.length} entries.` : `Preview generated 0 entries. Check inputs.`;
            statusColor = rsg_generatedPreviewEntries_extra.length > 0 ? '#2ecc71' : '#f1c40f';
        }
        rsgStatusMessage_el_extra.textContent = statusMsg;
        rsgStatusMessage_el_extra.style.color = statusColor;
        delete rsgStatusMessage_el_extra.dataset.profileAssumed;
        rsg_updateRsgActionButtonsState();
    }
    return rsg_generatedPreviewEntries_extra.length > 0;
}

        function rsg_renderPreviewTable_ExtraPage() { 
            if (!rsgPreviewTableBody_el_extra || !rsgSchedulePreviewContainer_el_extra) return; rsgPreviewTableBody_el_extra.innerHTML = ''; if (rsg_generatedPreviewEntries_extra.length === 0) { return; } rsg_generatedPreviewEntries_extra.forEach(entry => { const row = rsgPreviewTableBody_el_extra.insertRow(); row.insertCell().textContent = entry.stopID; row.insertCell().textContent = entry.stopName; row.insertCell().textContent = entry.scheduledTime; row.insertCell().textContent = entry.lineName; row.insertCell().textContent = entry.destinationName; row.insertCell().textContent = entry.OperatingProfile; row.insertCell().textContent = entry.DayOffset; });
        }
        
        function rsg_resetPreviewState(message = "Configuration changed. Please (re)generate preview or add short workings.", messageType = "info") {
    rsg_generatedPreviewEntries_extra = [];

    if(rsgPreviewTableBody_el_extra) {
        rsgPreviewTableBody_el_extra.innerHTML = '';
    }
    if(rsgSchedulePreviewContainer_el_extra) {
        rsgSchedulePreviewContainer_el_extra.style.display = 'none';
    }

    if(rsgAddToWorkingScheduleButton_el_extra) {
        rsgAddToWorkingScheduleButton_el_extra.disabled = true;
        rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
        rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
    }

    if(rsgStatusMessage_el_extra) {
        const isCurrentMessageError = rsgStatusMessage_el_extra.style.color === 'rgb(231, 76, 60)' || rsgStatusMessage_el_extra.style.color === '#e74c3c';
        if (!isCurrentMessageError || messageType !== "info" ) {
            rsgStatusMessage_el_extra.textContent = message;
            if (messageType === "info") {
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            } else if (messageType === "success") {
                rsgStatusMessage_el_extra.style.color = "#2ecc71";
            } else if (messageType === "error") {
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            } else {
                rsgStatusMessage_el_extra.style.color = "";
            }
        }
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

async function rsg_handleAddGeneratedToWorkingSchedule_ExtraPage() {
    if (!currentUser_extra) {
        alert("Please log in to modify the working schedule.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Not logged in.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    if (!rsg_generatedPreviewEntries_extra || rsg_generatedPreviewEntries_extra.length === 0) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "No schedule entries generated in the preview to add.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    const targetRouteName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
    let targetOpProfile = rsg_getSelectedOpProfilesString_ExtraPage();
    const targetDestName = rsgDestinationNameInput_el_extra.value.trim();
    const previewSample = rsg_generatedPreviewEntries_extra[0];

    if (!targetOpProfile && previewSample && previewSample.OperatingProfile) {
        targetOpProfile = previewSample.OperatingProfile;
    }

    if (!targetRouteName || !targetOpProfile || !targetDestName) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route Name, Operating Profile, and Destination Name must be defined in Section 1 to update the schedule.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }
    
    if (previewSample.lineName.toUpperCase() !== targetRouteName ||
        previewSample.destinationName !== targetDestName ||
        previewSample.OperatingProfile !== targetOpProfile) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Form settings do not match the generated preview. Please re-generate preview if settings changed.`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const actionChoice = prompt(
        `Choose action for the ${rsg_generatedPreviewEntries_extra.length} previewed entries for:\n` +
        `Route: ${targetRouteName}\nProfile: ${targetOpProfile}\nDestination: ${targetDestName}\n\n` +
        `1. OVERWRITE existing entries for this specific Route, Profile, and Destination.\n` +
        `2. ADD these new entries (will append if R/P/D exists, or create if new).\n\n` +
        `Enter 1 or 2 (or Cancel):`
    );

    let newEntriesCount = rsg_generatedPreviewEntries_extra.length;
    let operationPerformed = false;
    const entriesToAdd = JSON.parse(JSON.stringify(rsg_generatedPreviewEntries_extra));

    if (actionChoice === "1") {
        if (confirm(`ARE YOU SURE you want to REMOVE all existing entries for Route "${targetRouteName}", Profile "${targetOpProfile}", Destination "${targetDestName}" AND THEN ADD these ${newEntriesCount} new entries?`)) {
            let removedCount = 0;
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
                const matchesRPD = entry.lineName && entry.lineName.toUpperCase() === targetRouteName &&
                                   entry.OperatingProfile === targetOpProfile &&
                                   entry.destinationName === targetDestName;
                if (matchesRPD) {
                    removedCount++;
                    return false;
                }
                return true;
            });
            
            currentWorkingSchedule_extra.push(...entriesToAdd);
            operationPerformed = true;
        } else {
             if (rsgStatusMessage_el_extra) rsgStatusMessage_el_extra.textContent = "Overwrite operation cancelled by user.";
            return;
        }
    } else if (actionChoice === "2") {
        currentWorkingSchedule_extra.push(...entriesToAdd);
        operationPerformed = true;
    } else {
        if (rsgStatusMessage_el_extra) rsgStatusMessage_el_extra.textContent = "Operation cancelled.";
        return;
    }

    if (operationPerformed) {
        try {
            if (rsgStatusMessage_el_extra) {
                 rsgStatusMessage_el_extra.textContent = `Saving changes for route "${targetRouteName}" to Firebase...`;
                 rsgStatusMessage_el_extra.style.color = "#3498db";
            }
            await saveSpecificRouteDataToFirebase_ExtraPage(targetRouteName); 
            
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Successfully saved to Firebase. Working schedule now has ${currentWorkingSchedule_extra.length} total entries.`;
                rsgStatusMessage_el_extra.style.color = "#2ecc71";
            }
            
            rsg_resetPreviewState("Successfully added to working schedule and saved to Firebase.", "success");
            renderUIDependentElements_ExtraPage();

        } catch (error) {
            console.error("Error in rsg_handleAddGeneratedToWorkingSchedule_ExtraPage (calling targeted save to Firebase):", error);
            if (rsgStatusMessage_el_extra) { 
                rsgStatusMessage_el_extra.textContent = "Error saving to Firebase: " + error.message;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
        }
    }
}

        function rsg_closeScheduleDateTimeModal_ExtraPage() {
    const modal = document.getElementById('rsg-schedule-datetime-modal-extra');
    if (modal) modal.style.display = 'none';
    rsg_batchScheduleItems = [];
}

        async function rsg_confirmScheduleGoLive_ExtraPage() {
    const goLiveInput = document.getElementById(
        "rsg-go-live-datetime-input-extra"
    );
    const modalStatus = document.getElementById(
        "rsg-schedule-datetime-modal-status-extra"
    );

    if (!goLiveInput || !modalStatus) {
        return;
    }
    const goLiveDateTime = goLiveInput.value;

    if (!goLiveDateTime) {
        modalStatus.textContent =
            "Please select a go-live date and time.";
        modalStatus.style.color = "#e74c3c";
        return;
    }
    const goLiveDateObj = new Date(goLiveDateTime);
    if (isNaN(goLiveDateObj.getTime())) {
        modalStatus.textContent = "Invalid date/time format.";
        modalStatus.style.color = "#e74c3c";
        return;
    }

    if (goLiveDateObj <= new Date()) {
        modalStatus.textContent =
            "Go-live date/time must be in the future.";
        modalStatus.style.color = "#e74c3c";
        return;
    }

    const { database, dbSet, dbRef } = window.firebaseOMSI;
    let successCount = 0;
    let errorCount = 0;
    const scheduledByUser = currentUser_extra
        ? currentUser_extra.email
        : "unknown";
    const scheduledAtTimestamp = new Date().toISOString();

    if (
        rsg_batchScheduleItems &&
        rsg_batchScheduleItems.length > 0
    ) {
        // --- BATCH SCHEDULING LOGIC ---
        modalStatus.textContent = `Processing ${rsg_batchScheduleItems.length} configurations for scheduling...`;
        modalStatus.style.color = "#f1c40f";

        for (const batchItem of rsg_batchScheduleItems) {
            const configurationToSchedule = {
                taskType: "applySchedule",
                routeName: batchItem.routeName,
                destinationName: batchItem.destinationName,
                operatingProfile: batchItem.operatingProfile,
                stopSequence: batchItem.stopSequence,
                firstStopTimes: batchItem.firstStopTimes,
                scheduledEntries: batchItem.scheduledEntries,
                goLiveDateTime: goLiveDateObj.toISOString(),
                scheduledAt: scheduledAtTimestamp,
                status: "pending",
                userEmail: scheduledByUser,
                sourceConfigKey: batchItem.configKey,
                sourceConfigName: batchItem.userDisplayName,
            };

            try {
                const scheduleKey = `sched_${Date.now()}_${sanitizeFirebaseKey(
                    batchItem.routeName
                )}_${successCount}`;
                await dbSet(
                    dbRef(
                        database,
                        `${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${scheduleKey}`
                    ),
                    configurationToSchedule
                );

                // --- OPTIMISTIC UPDATE (BATCH) ---
                if (typeof scheduledRouteUpdates_extra !== 'object' || scheduledRouteUpdates_extra === null) {
                    scheduledRouteUpdates_extra = {};
                }
                scheduledRouteUpdates_extra[scheduleKey] = configurationToSchedule;
                // --- END OPTIMISTIC UPDATE ---

                successCount++;
            } catch (error) {
                console.error("Error saving a batch schedule item to Firebase:", error);
                errorCount++;
            }
        }

        modalStatus.textContent = `Batch scheduling complete. Success: ${successCount}, Failed: ${errorCount}.`;
        modalStatus.style.color =
            errorCount > 0 ? "#e74c3c" : "#2ecc71";
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Batch scheduling: ${successCount} succeeded, ${errorCount} failed. Go-live: ${goLiveDateObj.toLocaleString()}.`;
            rsgStatusMessage_el_extra.style.color =
                errorCount > 0 ? "#e74c3c" : "#2ecc71";
        }
        
    } else {
        // --- SINGLE CONFIGURATION SCHEDULING LOGIC ---
        const routeName = rsgRouteNameInput_el_extra.value.trim();
        let operatingProfile =
            rsg_getSelectedOpProfilesString_ExtraPage();
        const destinationName =
            rsgDestinationNameInput_el_extra.value.trim();

        if (
            !operatingProfile &&
            rsg_lastLoadedOpProfile_extra &&
            routeName.toUpperCase() ===
                (
                    rsg_lastLoadedRouteName_extra || ""
                ).toUpperCase() &&
            destinationName === (rsg_lastLoadedDestName_extra || "")
        ) {
            operatingProfile = rsg_lastLoadedOpProfile_extra;
        }

        if (
            !routeName ||
            !operatingProfile ||
            !destinationName ||
            rsg_selectedStops_extra.length === 0 ||
            !rsgFirstStopTimesInput_el_extra.value.trim()
        ) {
            modalStatus.textContent =
                "Cannot schedule: Main RSG form is incomplete (Route, Profile, Dest, Sequence, Times).";
            modalStatus.style.color = "#e74c3c";
            return;
        }

        if (
            !rsg_generatedPreviewEntries_extra ||
            rsg_generatedPreviewEntries_extra.length === 0
        ) {
            modalStatus.textContent =
                "No preview entries generated for the current RSG setup. Please generate preview first.";
            modalStatus.style.color = "#e74c3c";
            return;
        }

        const configurationToSchedule = {
            taskType: "applySchedule",
            routeName: routeName,
            destinationName: destinationName,
            operatingProfile: operatingProfile,
            stopSequence: JSON.parse(
                JSON.stringify(rsg_selectedStops_extra)
            ),
            firstStopTimes:
                rsgFirstStopTimesInput_el_extra.value.trim(),
            scheduledEntries: JSON.parse(
                JSON.stringify(rsg_generatedPreviewEntries_extra)
            ),
            goLiveDateTime: goLiveDateObj.toISOString(),
            scheduledAt: scheduledAtTimestamp,
            status: "pending",
            userEmail: scheduledByUser,
        };

        modalStatus.textContent =
            "Scheduling current configuration...";
        modalStatus.style.color = "#f1c40f";

        try {
            const scheduleKey = `sched_${Date.now()}_${sanitizeFirebaseKey(
                routeName
            )}`;
            await dbSet(
                dbRef(
                    database,
                    `${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${scheduleKey}`
                ),
                configurationToSchedule
            );

            // --- OPTIMISTIC UPDATE (SINGLE) ---
            if (typeof scheduledRouteUpdates_extra !== 'object' || scheduledRouteUpdates_extra === null) {
                scheduledRouteUpdates_extra = {};
            }
            scheduledRouteUpdates_extra[scheduleKey] = configurationToSchedule;
            // --- END OPTIMISTIC UPDATE ---

            modalStatus.textContent =
                "Configuration scheduled successfully!";
            modalStatus.style.color = "#2ecc71";
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Current configuration for ${routeName} (${operatingProfile}) scheduled for ${goLiveDateObj.toLocaleString()}.`;
                rsgStatusMessage_el_extra.style.color = "#2ecc71";
            }
        } catch (error) {
            modalStatus.textContent =
                "Error scheduling: " + error.message;
            modalStatus.style.color = "#e74c3c";
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent =
                    "Error scheduling configuration.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
        }
    }

    // --- SHARED LOGIC AFTER EITHER BATCH OR SINGLE SCHEDULING ---

    // Invalidate the HTML cache and call the RENDER function directly
    // instead of the LOAD function to avoid the race condition.
    isScheduledTasksCacheValid_extra = false; 
    if (typeof renderScheduledUpdatesList_ExtraPage === 'function') {
        renderScheduledUpdatesList_ExtraPage();
    }
    // Also update the due tasks banner in case this new task is immediately due
    if (typeof checkAndDisplayDueUpdatesNotification_ExtraPage === 'function') {
        checkAndDisplayDueUpdatesNotification_ExtraPage();
    }
    
    // Close modal after a delay
    setTimeout(
        rsg_closeScheduleDateTimeModal_ExtraPage,
        errorCount > 0 ? 4000 : 2000
    );
}

        function handleScheduleThisConfiguration() {
    console.log("Schedule This Configuration button clicked!");
    const scheduleModal = document.getElementById('rsg-schedule-datetime-modal-extra');
    
    if (!currentUser_extra) {
        alert("Please log in to schedule configurations.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Please log in.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    if (scheduleModal) {
        // Perform a pre-check to ensure the current RSG form state can generate a valid preview.
        if (!rsg_handleGenerateSchedulePreview_ExtraPage(true)) { // Pass true for isPreCheck
            // The pre-check function will set its own user-facing error message.
            return; 
        }
        
        // If pre-check passes, show the modal.
        const modalStatus = document.getElementById('rsg-schedule-datetime-modal-status-extra');
        if (modalStatus) modalStatus.textContent = ''; // Clear previous modal status

        const goLiveInput = document.getElementById('rsg-go-live-datetime-input-extra');
        if (goLiveInput) {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(5, 0, 0, 0); // Default to 05:00 AM
            
            const year = tomorrow.getFullYear();
            const month = String(tomorrow.getMonth() + 1).padStart(2, '0');
            const day = String(tomorrow.getDate()).padStart(2, '0');
            const hours = String(tomorrow.getHours()).padStart(2, '0');
            const minutes = String(tomorrow.getMinutes()).padStart(2, '0');
            goLiveInput.value = `${year}-${month}-${day}T${hours}:${minutes}`;
        }
        scheduleModal.style.display = 'flex';
    } else {
        console.error("Schedule DateTime modal (rsg-schedule-datetime-modal-extra) not found!");
        if (rsgStatusMessage_el_extra) {
             rsgStatusMessage_el_extra.textContent = "Error: Scheduling modal component is missing.";
             rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
    }
}

        async function loadAndDisplayScheduledUpdates_ExtraPage() {
    const listContainer = document.getElementById('sru-updates-list-container-extra');
    if (!listContainer || !window.firebaseOMSI) {
        if (listContainer) listContainer.innerHTML = '<p>Error: Firebase not available.</p>';
        console.error("SRU/SRD Load: Firebase or list container not available.");
        return;
    }
    listContainer.innerHTML = '<p>Loading all scheduled tasks...</p>';
    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;

    // Initialize with empty objects
    scheduledRouteUpdates_extra = {};
    scheduledRouteDeletions_extra = {};

    try {
        // Fetch timetable application updates
        console.log("SRU Load: Attempting to fetch schedule application tasks...");
        const updatesSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULED_ROUTE_UPDATES));
        if (updatesSnap.exists()) {
            scheduledRouteUpdates_extra = updatesSnap.val() || {}; // Ensure it's an object
        }
        console.log(`SRU Load: Fetched ${Object.keys(scheduledRouteUpdates_extra).length} schedule application tasks.`);

        // Fetch route deletion tasks
        console.log("SRU Load: Attempting to fetch route deletion tasks...");
        const deletionsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULED_DELETIONS));
        if (deletionsSnap.exists()) {
            scheduledRouteDeletions_extra = deletionsSnap.val() || {}; // Ensure it's an object
        } else {
            scheduledRouteDeletions_extra = {}; // Path doesn't exist or is null
        }
        // --- THIS IS THE DETAILED LOG YOU WERE ASKING FOR ---
        console.log(`SRU Load: Fetched ${Object.keys(scheduledRouteDeletions_extra).length} route deletion tasks. Content:`, JSON.parse(JSON.stringify(scheduledRouteDeletions_extra)));
        // --- END OF DETAILED LOG ---

        renderScheduledUpdatesList_ExtraPage();
        
        // *** ADD THIS LINE ***
        checkAndDisplayDueUpdatesNotification_ExtraPage();

    } catch (error) {
        console.error("Error loading scheduled tasks (updates and/or deletions):", error);
        listContainer.innerHTML = `<p style="color:#e74c3c;">Error loading tasks: ${error.message}</p>`;
        // Ensure they are reset on error too
        scheduledRouteUpdates_extra = {};
        scheduledRouteDeletions_extra = {};
    }
}

        function renderScheduledUpdatesList_ExtraPage() {
    const listContainer = document.getElementById(
        "sru-updates-list-container-extra"
    );
    const batchRadiosContainer = document.getElementById(
        "sru-batch-golive-radios-container-extra"
    );

    if (!listContainer || !batchRadiosContainer) {
        if (listContainer)
            listContainer.innerHTML =
                "<p>Error: UI container missing for tasks.</p>";
        if (batchRadiosContainer)
            batchRadiosContainer.innerHTML =
                "<p>Error: UI container missing for batch apply radios.</p>";
        return;
    }

    listContainer.innerHTML =
        "<p>Processing scheduled tasks list...</p>";
    batchRadiosContainer.innerHTML =
        "<p>Processing go-live times...</p>";

    let allApplyScheduleTasks = [];
    let allDeleteTasks = [];

    if (
        typeof scheduledRouteUpdates_extra === "object" &&
        scheduledRouteUpdates_extra !== null
    ) {
        Object.entries(scheduledRouteUpdates_extra).forEach(
            ([key, value]) => {
                if (
                    value &&
                    typeof value === "object" &&
                    (value.taskType === "applySchedule" ||
                        value.taskTypeDisplay === "applySchedule")
                ) {
                    if (
                        value.status === "pending" ||
                        value.status === "error"
                    ) {
                        allApplyScheduleTasks.push({
                            key,
                            ...value,
                            taskTypeDisplay: "applySchedule",
                        });
                    }
                }
            }
        );
    }
    if (
        typeof scheduledRouteDeletions_extra === "object" &&
        scheduledRouteDeletions_extra !== null
    ) {
        Object.entries(scheduledRouteDeletions_extra).forEach(
            ([key, value]) => {
                if (
                    value &&
                    typeof value === "object" &&
                    (value.taskType === "deleteEntireRoute" ||
                        value.taskTypeDisplay ===
                            "deleteEntireRoute")
                ) {
                    if (
                        value.status === "pending" ||
                        value.status === "error"
                    ) {
                        allDeleteTasks.push({
                            key,
                            ...value,
                            taskTypeDisplay: "deleteEntireRoute",
                        });
                    }
                }
            }
        );
    }

    const individualTasksFragment =
        document.createDocumentFragment();
    let anyContentRenderedOverall = false;
    const allKnownRouteNamesFromSchedule = [
        ...new Set(
            currentWorkingSchedule_extra
                .map((e) => e.lineName)
                .filter(Boolean)
        ),
    ];
    const applyTasksGroupedByRouteThenTime = {};
    allApplyScheduleTasks.forEach((task) => {
        const routeNameForGrouping =
            task.routeName || "UnspecifiedRoute";
        const goLiveISO = task.goLiveDateTime;
        if (!goLiveISO) {
            if (
                !applyTasksGroupedByRouteThenTime[
                    "InvalidGoLiveTime"
                ]
            ) {
                applyTasksGroupedByRouteThenTime[
                    "InvalidGoLiveTime"
                ] = { UnknownTime: [] };
            }
            applyTasksGroupedByRouteThenTime["InvalidGoLiveTime"][
                "UnknownTime"
            ].push(task);
            return;
        }
        if (
            !applyTasksGroupedByRouteThenTime[routeNameForGrouping]
        ) {
            applyTasksGroupedByRouteThenTime[routeNameForGrouping] =
                {};
        }
        if (
            !applyTasksGroupedByRouteThenTime[routeNameForGrouping][
                goLiveISO
            ]
        ) {
            applyTasksGroupedByRouteThenTime[routeNameForGrouping][
                goLiveISO
            ] = [];
        }
        applyTasksGroupedByRouteThenTime[routeNameForGrouping][
            goLiveISO
        ].push(task);
    });
    const allRoutesToDisplaySet = new Set([
        ...allKnownRouteNamesFromSchedule,
        ...Object.keys(applyTasksGroupedByRouteThenTime).filter(
            (rn) =>
                rn !== "UnspecifiedRoute" &&
                rn !== "InvalidGoLiveTime"
        ),
        ...allDeleteTasks
            .map((t) => t.routeName)
            .filter(Boolean)
            .filter((rn) => rn !== "UnspecifiedRoute"),
    ]);
    const sortedRoutesToDisplay = Array.from(
        allRoutesToDisplaySet
    ).sort(compareLineNames_ExtraPage);
    if (
        sortedRoutesToDisplay.length > 0 ||
        (applyTasksGroupedByRouteThenTime["UnspecifiedRoute"] &&
            Object.keys(
                applyTasksGroupedByRouteThenTime["UnspecifiedRoute"]
            ).length > 0) ||
        (applyTasksGroupedByRouteThenTime["InvalidGoLiveTime"] &&
            Object.keys(
                applyTasksGroupedByRouteThenTime[
                    "InvalidGoLiveTime"
                ]
            ).length > 0) ||
        allDeleteTasks.some(
            (task) =>
                !task.routeName ||
                task.routeName === "UnspecifiedRoute"
        )
    ) {
        const sectionTitle = document.createElement("h3");
        sectionTitle.className = "subsection-title";
        sectionTitle.textContent =
            "Individually Pending & Actionable Scheduled Tasks (Grouped by Route)";
        sectionTitle.style.color = "#B2DFDB";
        sectionTitle.style.marginBottom = "1em";
        individualTasksFragment.appendChild(sectionTitle);
    }
    sortedRoutesToDisplay.forEach((routeName) => {
        const tasksByTimeForThisRoute =
            applyTasksGroupedByRouteThenTime[routeName];
        const deleteTasksForThisRoute = allDeleteTasks.filter(
            (task) =>
                task.routeName === routeName &&
                (task.status === "pending" ||
                    task.status === "error")
        );
        if (
            (tasksByTimeForThisRoute &&
                Object.keys(tasksByTimeForThisRoute).length > 0) ||
            deleteTasksForThisRoute.length > 0
        ) {
            anyContentRenderedOverall = true;
            const routeGroupDiv = document.createElement("div");
            routeGroupDiv.className = "sru-route-group subsection";
            routeGroupDiv.style.marginBottom = "2rem";
            routeGroupDiv.style.paddingTop = "0.5rem";
            routeGroupDiv.style.borderLeft = "3px solid #607D8B";
            const routeHeading = document.createElement("h4");
            routeHeading.style.marginTop = "0.2em";
            routeHeading.style.marginBottom = "0.5em";
            routeHeading.style.fontSize = "1.2em";
            routeHeading.style.borderBottom = "1px solid #555";
            routeHeading.style.paddingBottom = "0.4em";
            routeHeading.textContent = `Route: ${routeName}`;
            routeGroupDiv.appendChild(routeHeading);
            const cancelAllForRouteButton =
                document.createElement("button");
            cancelAllForRouteButton.className =
                "button tertiary sru-cancel-all-for-route-btn";
            cancelAllForRouteButton.textContent =
                "Cancel All Pending Updates for This Route";
            cancelAllForRouteButton.title = `Review and cancel all pending timetable updates for Route ${routeName}`;
            cancelAllForRouteButton.style.display = "block";
            cancelAllForRouteButton.style.width = "fit-content";
            cancelAllForRouteButton.style.marginBottom = "1em";
            cancelAllForRouteButton.style.fontSize = "0.85em";
            cancelAllForRouteButton.style.backgroundColor =
                "#b33930";
            cancelAllForRouteButton.style.color = "white";
            cancelAllForRouteButton.dataset.routeName = routeName;
            routeGroupDiv.appendChild(cancelAllForRouteButton);
            let contentAddedForThisRouteSection = false;
            if (
                tasksByTimeForThisRoute &&
                Object.keys(tasksByTimeForThisRoute).length > 0
            ) {
                contentAddedForThisRouteSection = true;
                const applyUpdatesSubheading =
                    document.createElement("h5");
                applyUpdatesSubheading.textContent =
                    "Timetable Updates for this route:";
                applyUpdatesSubheading.style.color = "#DAF7A6";
                applyUpdatesSubheading.style.fontSize = "1em";
                applyUpdatesSubheading.style.marginBottom = "0.5em";
                routeGroupDiv.appendChild(applyUpdatesSubheading);
                const sortedGoLiveTimes = Object.keys(
                    tasksByTimeForThisRoute
                ).sort(
                    (a, b) =>
                        new Date(a).getTime() -
                        new Date(b).getTime()
                );
                sortedGoLiveTimes.forEach((goLiveISO) => {
                    const batchOfTasks =
                        tasksByTimeForThisRoute[goLiveISO];
                    batchOfTasks.sort((a, b) => {
                        const opA = a.operatingProfile || "";
                        const opB = b.operatingProfile || "";
                        const destA = a.destinationName || "";
                        const destB = b.destinationName || "";
                        if (opA.localeCompare(opB) !== 0)
                            return opA.localeCompare(opB);
                        return destA.localeCompare(destB);
                    });
                    const batchContainerDiv =
                        document.createElement("div");
                    batchContainerDiv.className =
                        "sru-batch-container subsection";
                    batchContainerDiv.style.marginLeft = "1em";
                    batchContainerDiv.style.marginBottom = "1rem";
                    batchContainerDiv.style.padding = "0.8rem";
                    batchContainerDiv.style.borderLeft =
                        "4px solid #3498db";
                    batchContainerDiv.dataset.scheduleKey =
                        goLiveISO + "_" + routeName;
                    let batchStatusSummary = batchOfTasks.some(
                        (t) => t.status === "error"
                    )
                        ? "error (in batch)"
                        : "pending";
                    let batchDetailsHTML = `<h6 class="sru-task-title-heading" style="margin-top:0; margin-bottom:0.6em; font-size:1.0em; color: #ecf0f1;">Batch Go-Live: ${new Date(
                        goLiveISO
                    ).toLocaleString()} <span style="font-weight:bold; color:${
                        batchStatusSummary === "pending"
                            ? "#f39c12"
                            : "#e74c3c"
                    }">(${batchStatusSummary})</span></h6>`;
                    batchDetailsHTML += `<p style="font-size:0.85em; margin-bottom:0.5em;">Contains ${batchOfTasks.length} update(s). Applying replaces <strong>entire Route ${routeName}</strong>.</p>`;
                    batchDetailsHTML +=
                        '<ul style="font-size:0.8em; padding-left:1.5em; margin-bottom:0.75em;">';
                    batchOfTasks.forEach((task) => {
                        let taskStatusColor =
                            task.status === "pending"
                                ? "#f1c40f"
                                : task.status === "error"
                                ? "#e74c3c"
                                : "#bdc3c7";
                        batchDetailsHTML += `<li style="margin-bottom:0.2em;">Target: (P: ${
                            task.operatingProfile || "N/A"
                        }, D: ${task.destinationName || "N/A"}) - ${
                            task.scheduledEntries
                                ? task.scheduledEntries.length
                                : 0
                        } entries. Status: <span style="color:${taskStatusColor}; font-weight:bold;">${
                            task.status || "N/A"
                        }</span></li>`;
                    });
                    batchDetailsHTML += "</ul>";
                    
                    // --- MODIFICATION 1: Create the new responsive container ---
                    const batchActionsDiv = document.createElement("div");
                    batchActionsDiv.className = "sru-batch-actions"; // Use the new class for flexbox styling

                    const applyBatchButton =
                        document.createElement("button");
                    applyBatchButton.className =
                        "button save sru-apply-batch-btn";
                    applyBatchButton.textContent = `Apply This Batch Now`;
                    applyBatchButton.title = `Delete all for Route ${routeName}, apply ${batchOfTasks.length} updates.`;
                    applyBatchButton.addEventListener("click", () =>
                        handleApplyScheduledRouteBatch_ExtraPage(
                            batchOfTasks
                        )
                    );
                    batchActionsDiv.appendChild(applyBatchButton);

                    batchOfTasks.forEach((task) => {
                        // --- MODIFICATION 2: Update the class and remove inline styles for the cancel buttons ---
                        const cancelTaskButton = document.createElement("button");
                        cancelTaskButton.className = "button secondary sru-cancel-task-btn"; // Use 'secondary' for red, remove 'small-action' and 'neutral'
                        cancelTaskButton.textContent = `Cancel Update: (P: ${
                            task.operatingProfile || "N/A"
                        }, D: ${task.destinationName || "N/A"})`;
                        cancelTaskButton.title = `Cancel only this specific update task: ${task.key}`;
                        cancelTaskButton.dataset.key = task.key;
                        cancelTaskButton.dataset.taskType =
                            "applySchedule";
                        batchActionsDiv.appendChild(
                            cancelTaskButton
                        );
                    });
                    batchContainerDiv.innerHTML = batchDetailsHTML;
                    batchContainerDiv.appendChild(batchActionsDiv);
                    routeGroupDiv.appendChild(batchContainerDiv);
                });
            }
            if (deleteTasksForThisRoute.length > 0) {
                contentAddedForThisRouteSection = true;
                const routeDeletionsSubheading =
                    document.createElement("h5");
                routeDeletionsSubheading.textContent =
                    "Scheduled Withdrawal for this Route:";
                routeDeletionsSubheading.style.color = "#E74C3C";
                routeDeletionsSubheading.style.marginTop =
                    tasksByTimeForThisRoute &&
                    Object.keys(tasksByTimeForThisRoute).length > 0
                        ? "1.5em"
                        : "0.5em";
                routeDeletionsSubheading.style.fontSize = "1em";
                routeDeletionsSubheading.style.borderTop =
                    tasksByTimeForThisRoute &&
                    Object.keys(tasksByTimeForThisRoute).length > 0
                        ? "1px dashed #555"
                        : "none";
                routeDeletionsSubheading.style.paddingTop =
                    tasksByTimeForThisRoute &&
                    Object.keys(tasksByTimeForThisRoute).length > 0
                        ? "0.75em"
                        : "0";
                routeGroupDiv.appendChild(routeDeletionsSubheading);
                deleteTasksForThisRoute.sort(
                    (a, b) =>
                        new Date(a.goLiveDateTime).getTime() -
                        new Date(b.goLiveDateTime).getTime()
                );
                deleteTasksForThisRoute.forEach((task) => {
                    const itemDiv = document.createElement("div");
                    itemDiv.classList.add("subsection");
                    itemDiv.style.marginBottom = "0.75rem";
                    itemDiv.style.padding = "0.75rem";
                    itemDiv.style.marginLeft = "1em";
                    itemDiv.style.borderLeft = "4px solid #c0392b";
                    itemDiv.dataset.scheduleKey = task.key;
                    itemDiv.dataset.taskType = "deleteEntireRoute";
                    let statusColor =
                        task.status === "pending"
                            ? "#f39c12"
                            : task.status === "error"
                            ? "#e74c3c"
                            : "#ecf0f1";
                    let actionsHTML = "";
                    if (
                        task.status === "pending" ||
                        task.status === "error"
                    ) {
                        actionsHTML = `<button class="button small-action tertiary sru-execute-deletion-btn" data-key="${
                            task.key
                        }" style="background-color:${
                            task.status === "error"
                                ? "#d35400"
                                : "#e67e22"
                        };">${
                            task.status === "error"
                                ? "Retry"
                                : "Withdraw Route Now"
                        }</button> `;
                    }
                    actionsHTML += `<button class="button small-action neutral sru-cancel-task-btn" data-key="${task.key}" data-task-type="deleteEntireRoute" style="margin-left:8px;">Cancel</button>`;
                    itemDiv.innerHTML = `
                        <h6 class="sru-task-title-heading" style="margin-top:0; margin-bottom:0.4em; font-size:1.0em; color: #e74c3c;">ROUTE WITHDRAWN (Go-Live: ${new Date(
                            task.goLiveDateTime
                        ).toLocaleString()})</h6>
                        <p style="font-size:0.9em;">Status: <span style="font-weight:bold; color:${statusColor};">${
                        task.status || "N/A"
                    }</span></p>
                        <p style="font-size:0.8em; opacity:0.8;">By: ${
                            task.userEmail || "System"
                        } (ID: ${
                        task.key ? task.key.substring(0, 10) : "N/A"
                    }...)</p>
                        ${
                            task.lastError
                                ? `<p style="font-size:0.8em; color:#e74c3c;">Error: ${task.lastError}</p>`
                                : ""
                        }
                        <div class="scheduled-update-actions" style="margin-top:0.75em;">${actionsHTML}</div>`;
                    routeGroupDiv.appendChild(itemDiv);
                });
            }
            if (!contentAddedForThisRouteSection) {
                const noTasksMsg = document.createElement("p");
                noTasksMsg.textContent = `(No pending or error tasks currently scheduled for Route ${routeName})`;
                noTasksMsg.style.fontSize = "0.85em";
                noTasksMsg.style.opacity = "0.7";
                noTasksMsg.style.paddingLeft = "1em";
                noTasksMsg.style.fontStyle = "italic";
                routeGroupDiv.appendChild(noTasksMsg);
            }
            individualTasksFragment.appendChild(routeGroupDiv);
        }
    });

    function renderSpecialCategoryTasksToFragment(
        fragment,
        categoryName,
        categoryKey,
        tasksByTime,
        deleteTasks,
        headingColor = "#f1c40f"
    ) {
        const categoryApplyTasksByTime = tasksByTime
            ? tasksByTime[categoryKey]
            : null;
        const categoryDeleteTasksFiltered = deleteTasks
            ? deleteTasks.filter(
                    (task) =>
                        (task.routeName || "UnspecifiedRoute") ===
                            categoryKey &&
                        (task.status === "pending" ||
                            task.status === "error")
                )
            : [];

        if (
            (categoryApplyTasksByTime &&
                Object.keys(categoryApplyTasksByTime).length > 0) ||
            categoryDeleteTasksFiltered.length > 0
        ) {
            anyContentRenderedOverall = true;
            const specialRouteGroupDiv =
                document.createElement("div");
            specialRouteGroupDiv.className =
                "sru-route-group subsection";
            specialRouteGroupDiv.style.marginBottom = "2rem";
            specialRouteGroupDiv.style.paddingTop = "0.5rem";
            specialRouteGroupDiv.style.borderLeft = `3px solid ${headingColor}`;

            const specialRouteHeading =
                document.createElement("h4");
            specialRouteHeading.style.marginTop = "0.2em";
            specialRouteHeading.style.marginBottom = "1em";
            specialRouteHeading.style.fontSize = "1.2em";
            specialRouteHeading.style.borderBottom =
                "1px solid #555";
            specialRouteHeading.style.paddingBottom = "0.4em";
            specialRouteHeading.style.color = headingColor;
            specialRouteHeading.textContent = `Category: ${categoryName}`;
            specialRouteGroupDiv.appendChild(specialRouteHeading);

            let contentAddedForThisSpecialCategory = false;

            if (
                categoryApplyTasksByTime &&
                Object.keys(categoryApplyTasksByTime).length > 0
            ) {
                contentAddedForThisSpecialCategory = true;
                const applyUpdatesSubheading =
                    document.createElement("h5");
                applyUpdatesSubheading.textContent =
                    "Timetable Updates in this category:";
                applyUpdatesSubheading.style.color = "#DAF7A6";
                applyUpdatesSubheading.style.fontSize = "1em";
                applyUpdatesSubheading.style.marginBottom = "0.5em";
                specialRouteGroupDiv.appendChild(
                    applyUpdatesSubheading
                );

                Object.keys(categoryApplyTasksByTime)
                    .sort(
                        (a, b) =>
                            new Date(a).getTime() -
                            new Date(b).getTime()
                    )
                    .forEach((goLiveISO) => {
                        const batchOfTasks =
                            categoryApplyTasksByTime[goLiveISO];
                        const batchContainerDiv =
                            document.createElement("div");
                        batchContainerDiv.className =
                            "sru-batch-container subsection";
                        batchContainerDiv.style.marginLeft = "1em";
                        batchContainerDiv.style.marginBottom =
                            "1rem";
                        batchContainerDiv.style.padding = "0.8rem";
                        batchContainerDiv.style.borderLeft =
                            "4px solid #aaa";
                        batchContainerDiv.dataset.scheduleKey =
                            goLiveISO + "_" + categoryKey;

                        let batchStatusSummary = batchOfTasks.some(
                            (t) => t.status === "error"
                        )
                            ? "error (in batch)"
                            : "pending";
                        let batchDetailsHTML = `<h6 class="sru-task-title-heading" style="margin-top:0; margin-bottom:0.6em; font-size:1.0em; color: #ecf0f1;">Batch Go-Live: ${
                            goLiveISO === "UnknownTime"
                                ? "Unknown"
                                : new Date(
                                        goLiveISO
                                    ).toLocaleString()
                        } <span style="font-weight:bold; color:${
                            batchStatusSummary === "pending"
                                ? "#f39c12"
                                : "#e74c3c"
                        }">(${batchStatusSummary})</span></h6>`;
                        batchDetailsHTML += `<p style="font-size:0.85em; margin-bottom:0.5em;">Contains ${batchOfTasks.length} update(s). Review route names if "Unspecified".</p>`;
                        batchDetailsHTML +=
                            '<ul style="font-size:0.8em; padding-left:1.5em; margin-bottom:0.75em;">';
                        batchOfTasks.forEach((task) => {
                            let taskStatusColor =
                                task.status === "pending"
                                    ? "#f1c40f"
                                    : task.status === "error"
                                    ? "#e74c3c"
                                    : "#bdc3c7";
                            batchDetailsHTML += `<li style="margin-bottom:0.2em;">Route: ${
                                task.routeName || "N/A"
                            }, P: ${
                                task.operatingProfile || "N/A"
                            }, D: ${
                                task.destinationName || "N/A"
                            } - ${
                                task.scheduledEntries
                                    ? task.scheduledEntries.length
                                    : 0
                            } entries. Status: <span style="color:${taskStatusColor}; font-weight:bold;">${
                                task.status || "N/A"
                            }</span></li>`;
                        });
                        batchDetailsHTML += "</ul>";
                        
                        // --- Also apply the new responsive container to these special categories ---
                        const batchActionsDiv = document.createElement("div");
                        batchActionsDiv.className = "sru-batch-actions";

                        batchOfTasks.forEach((task) => {
                            const cancelTaskButton = document.createElement("button");
                            // --- And apply the new classes/styles here too ---
                            cancelTaskButton.className = "button secondary sru-cancel-task-btn";
                            cancelTaskButton.textContent = `Cancel Update for Route ${
                                task.routeName || "N/A"
                            }`;
                            cancelTaskButton.title = `Cancel only this specific update task: ${task.key}`;
                            cancelTaskButton.dataset.key = task.key;
                            cancelTaskButton.dataset.taskType = "applySchedule";
                            batchActionsDiv.appendChild(cancelTaskButton);
                        });
                        
                        batchContainerDiv.innerHTML = batchDetailsHTML;
                        batchContainerDiv.appendChild(batchActionsDiv);
                        specialRouteGroupDiv.appendChild(batchContainerDiv);
                    });
            }

            if (categoryDeleteTasksFiltered.length > 0) {
                contentAddedForThisSpecialCategory = true;
                const routeDeletionsSubheading =
                    document.createElement("h5");
                routeDeletionsSubheading.textContent =
                    "Scheduled Deletions in this category:";
                routeDeletionsSubheading.style.color = "#E74C3C";
                routeDeletionsSubheading.style.marginTop =
                    categoryApplyTasksByTime &&
                    Object.keys(categoryApplyTasksByTime).length > 0
                        ? "1.5em"
                        : "0.5em";
                routeDeletionsSubheading.style.fontSize = "1em";
                specialRouteGroupDiv.appendChild(
                    routeDeletionsSubheading
                );

                categoryDeleteTasksFiltered.forEach((task) => {
                    const itemDiv = document.createElement("div");
                    itemDiv.classList.add("subsection");
                    itemDiv.style.marginBottom = "0.75rem";
                    itemDiv.style.padding = "0.75rem";
                    itemDiv.style.marginLeft = "1em";
                    itemDiv.style.borderLeft = "4px solid #c0392b";
                    itemDiv.dataset.scheduleKey = task.key;
                    itemDiv.dataset.taskType = "deleteEntireRoute";

                    let statusColor =
                        task.status === "pending"
                            ? "#f39c12"
                            : task.status === "error"
                            ? "#e74c3c"
                            : "#ecf0f1";
                    let actionsHTML = "";
                    if (
                        task.status === "pending" ||
                        task.status === "error"
                    ) {
                        actionsHTML = `<button class="button small-action tertiary sru-execute-deletion-btn" data-key="${
                            task.key
                        }" style="background-color:${
                            task.status === "error"
                                ? "#d35400"
                                : "#e67e22"
                        };">${
                            task.status === "error"
                                ? "Retry"
                                : "Withdraw Route Now"
                        }</button> `;
                    }
                    actionsHTML += `<button class="button small-action neutral sru-cancel-task-btn" data-key="${task.key}" data-task-type="deleteEntireRoute" style="margin-left:8px;">Cancel</button>`;
                    itemDiv.innerHTML = `<h6 class="sru-task-title-heading" style="margin-top:0; margin-bottom:0.4em; font-size:1.0em; color: #e74c3c;">DELETE ENTIRE ROUTE ${
                        task.routeName || ""
                    } (Go-Live: ${new Date(
                        task.goLiveDateTime
                    ).toLocaleString()})</h6> <p style="font-size:0.9em;">Status: <span style="font-weight:bold; color:${statusColor};">${
                        task.status || "N/A"
                    }</span></p> <p style="font-size:0.8em; opacity:0.8;">By: ${
                        task.userEmail || "System"
                    } (ID: ${
                        task.key ? task.key.substring(0, 10) : "N/A"
                    }...)</p> ${
                        task.lastError
                            ? `<p style="font-size:0.8em; color:#e74c3c;">Error: ${task.lastError}</p>`
                            : ""
                    } <div class="scheduled-update-actions" style="margin-top:0.75em;">${actionsHTML}</div>`;
                    specialRouteGroupDiv.appendChild(itemDiv);
                });
            }

            if (!contentAddedForThisSpecialCategory) {
                const noTasksMsg = document.createElement("p");
                noTasksMsg.textContent = `(No pending or error tasks found in category: ${categoryName})`;
                noTasksMsg.style.fontSize = "0.85em";
                noTasksMsg.style.opacity = "0.7";
                noTasksMsg.style.paddingLeft = "1em";
                noTasksMsg.style.fontStyle = "italic";
                specialRouteGroupDiv.appendChild(noTasksMsg);
            }
            fragment.appendChild(specialRouteGroupDiv);
        }
    }
    renderSpecialCategoryTasksToFragment(
        individualTasksFragment,
        "Tasks with Unspecified Route Name",
        "UnspecifiedRoute",
        applyTasksGroupedByRouteThenTime,
        allDeleteTasks,
        "#BCAAA4"
    );
    renderSpecialCategoryTasksToFragment(
        individualTasksFragment,
        "Tasks with Invalid Go-Live Time",
        "InvalidGoLiveTime",
        applyTasksGroupedByRouteThenTime,
        [],
        "#EF9A9A"
    );
    listContainer.innerHTML = "";
    if (!anyContentRenderedOverall) {
        listContainer.innerHTML =
            '<p style="text-align:center; opacity:0.8;">No pending or error tasks found to display.</p>';
    } else {
        listContainer.appendChild(individualTasksFragment);
    }
    cachedScheduledTasksHTML_extra = listContainer.innerHTML;

    const batchRadiosFragment = document.createDocumentFragment();
    const sruApplyAllForTimeButton = document.getElementById(
        "sru-apply-all-for-time-button-extra"
    );
    const sruApplyAllStatusMessage = document.getElementById(
        "sru-apply-all-status-message-extra"
    );

    if (batchRadiosContainer && sruApplyAllForTimeButton) {
        const allPendingTasksForRadio = [
            ...allApplyScheduleTasks.filter(task => task.status === 'pending' && task.goLiveDateTime),
            ...allDeleteTasks.filter(task => task.status === 'pending' && task.goLiveDateTime)
        ];

        const uniqueGoLiveTimesForRadio = [
            ...new Set(
                allPendingTasksForRadio.map(
                    (task) => task.goLiveDateTime
                )
            ),
        ].sort(
            (a, b) => new Date(a).getTime() - new Date(b).getTime()
        );

        if (uniqueGoLiveTimesForRadio.length > 0) {
            uniqueGoLiveTimesForRadio.forEach((isoTime) => {
                const tasksForThisTime =
                    allPendingTasksForRadio.filter(
                        (t) => t.goLiveDateTime === isoTime
                    );
                
                const affectedRoutesAtThisTime = [
                    ...new Set(
                        tasksForThisTime.map(
                            (t) => t.routeName || "Unspecified"
                        )
                    ),
                ].sort(compareLineNames_ExtraPage);

                const totalTasksForThisTime = tasksForThisTime.length;
                const radioId = `sru-batch-golive-${new Date(
                    isoTime
                ).getTime()}`;

                const radioLabel = document.createElement("label");
                radioLabel.htmlFor = radioId;
                radioLabel.style.display = "block";
                radioLabel.style.marginBottom = "0.5em";
                radioLabel.style.cursor = "pointer";
                radioLabel.style.color = "#ecf0f1";
                
                const radioButton = document.createElement("input");
                radioButton.type = "radio";
                radioButton.name = "sruBatchGoLiveTime_extra";
                radioButton.id = radioId;
                radioButton.value = isoTime;
                radioButton.style.marginRight = "10px";
                radioButton.style.verticalAlign = "middle";
                radioButton.addEventListener("change", () => {
                    if (sruApplyAllForTimeButton)
                        sruApplyAllForTimeButton.disabled = false;
                    if (sruApplyAllStatusMessage) {
                        sruApplyAllStatusMessage.textContent = `Selected Go-Live: ${new Date(
                            isoTime
                        ).toLocaleString()}. This will process ${totalTasksForThisTime} task(s) affecting ${
                            affectedRoutesAtThisTime.length
                        } route(s): ${affectedRoutesAtThisTime.join(
                            ", "
                        )}.`;
                        sruApplyAllStatusMessage.style.color =
                            "#f1c40f";
                    }
                });
                
                radioLabel.appendChild(radioButton);
                radioLabel.appendChild(
                    document.createTextNode(
                        `${new Date(
                            isoTime
                        ).toLocaleString()} (${totalTasksForThisTime} total tasks for ${
                            affectedRoutesAtThisTime.length
                        } routes: ${affectedRoutesAtThisTime.join(", ")})`
                    )
                );
                batchRadiosFragment.appendChild(radioLabel);
            });
            if (sruApplyAllForTimeButton)
                sruApplyAllForTimeButton.disabled = true;
        } else {
            const p = document.createElement("p");
            p.style.opacity = "0.7";
            p.textContent =
                "No pending tasks with valid go-live times available.";
            batchRadiosFragment.appendChild(p);
            if (sruApplyAllForTimeButton)
                sruApplyAllForTimeButton.disabled = true;
        }
        batchRadiosContainer.innerHTML = "";
        batchRadiosContainer.appendChild(batchRadiosFragment);
        cachedBatchRadiosHTML_extra = batchRadiosContainer.innerHTML;
    }
    
    isScheduledTasksCacheValid_extra = true;
}

async function handleApplyAllBatchesForSelectedTime_ExtraPage() {
    if (!currentUser_extra) {
        if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = "Please log in."; sruApplyAllStatusMessage_el_extra.style.color = "#e74c3c"; }
        return;
    }

    const selectedRadio = document.querySelector('input[name="sruBatchGoLiveTime_extra"]:checked');
    if (!selectedRadio) {
        if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = "Please select a Go-Live Time from the list above."; sruApplyAllStatusMessage_el_extra.style.color = "#f1c40f"; }
        return;
    }

    const selectedGoLiveDateTimeISO = selectedRadio.value;
    if(sruApplyAllStatusMessage_el_extra) {
        sruApplyAllStatusMessage_el_extra.textContent = `Preparing to apply all tasks for ${new Date(selectedGoLiveDateTimeISO).toLocaleString()}...`;
        sruApplyAllStatusMessage_el_extra.style.color = "#3498db";
    }

    // --- MODIFICATION START: Gather BOTH update and delete tasks ---
    const tasksToProcess = [];
    // Gather update tasks
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.entries(scheduledRouteUpdates_extra).forEach(([key, task]) => {
            if (task && (task.taskType === 'applySchedule' || task.taskTypeDisplay === 'applySchedule') && task.status === 'pending' && task.goLiveDateTime === selectedGoLiveDateTimeISO) {
                tasksToProcess.push({ key, ...task, taskType: 'applySchedule' }); // Normalize taskType
            }
        });
    }
    // Gather delete tasks
    if (typeof scheduledRouteDeletions_extra === 'object' && scheduledRouteDeletions_extra !== null) {
         Object.entries(scheduledRouteDeletions_extra).forEach(([key, task]) => {
            if (task && (task.taskType === 'deleteEntireRoute' || task.taskTypeDisplay === 'deleteEntireRoute') && task.status === 'pending' && task.goLiveDateTime === selectedGoLiveDateTimeISO) {
                tasksToProcess.push({ key, ...task, taskType: 'deleteEntireRoute' }); // Normalize taskType
            }
        });
    }
    // --- MODIFICATION END ---

    if (tasksToProcess.length === 0) {
        if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = "No valid pending tasks found for the selected time. The list might have refreshed."; sruApplyAllStatusMessage_el_extra.style.color = "#f1c40f"; }
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh the list
        return;
    }

    const tasksGroupedByRoute = tasksToProcess.reduce((acc, task) => {
        const routeName = task.routeName || "UnspecifiedRoute";
        if (!acc[routeName]) {
            acc[routeName] = [];
        }
        acc[routeName].push(task);
        return acc;
    }, {});

    const affectedRouteNames = Object.keys(tasksGroupedByRoute).sort(compareLineNames_ExtraPage);
    const confirmMessage = `EXTREME CAUTION!\n\nYou are about to apply ALL pending tasks scheduled for:\nGo-Live Time: ${new Date(selectedGoLiveDateTimeISO).toLocaleString()}\n\nThis will affect the following ${affectedRouteNames.length} route(s):\n- ${affectedRouteNames.join('\n- ')}\n\nFor EACH route, its current schedule data will be DELETED/REPLACED. This is IRREVERSIBLE.\nAre you sure you want to proceed?`;

    if (!confirm(confirmMessage)) {
        if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = "Bulk operation cancelled by user."; sruApplyAllStatusMessage_el_extra.style.color = ""; }
        return;
    }

    if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = `Processing ${tasksToProcess.length} tasks for ${affectedRouteNames.length} routes. This may take some time...`; }
    if(sruApplyAllForTimeButton_el_extra) sruApplyAllForTimeButton_el_extra.disabled = true;


    let allAffectedTaskKeysAndTypes = [];
    let totalEntriesAdded = 0;

    let tempWorkingSchedule = JSON.parse(JSON.stringify(currentWorkingSchedule_extra));

    // --- MODIFICATION START: Process deletions first, then updates for each route ---
    for (const routeName of affectedRouteNames) {
        const tasksForThisRoute = tasksGroupedByRoute[routeName];
        if (!tasksForThisRoute || tasksForThisRoute.length === 0) continue;

        const hasDeletionTask = tasksForThisRoute.some(t => t.taskType === 'deleteEntireRoute');
        const updateTasks = tasksForThisRoute.filter(t => t.taskType === 'applySchedule');

        // Step 1: Remove all existing entries for this route from the temporary schedule
        tempWorkingSchedule = tempWorkingSchedule.filter(entry => 
            !entry.lineName || entry.lineName.toUpperCase() !== routeName.toUpperCase()
        );

        // Step 2: If there are updates, collect their entries and add them back
        if (updateTasks.length > 0) {
            let allNewEntriesForThisRoute = [];
            updateTasks.forEach(task => {
                if (task.scheduledEntries && task.scheduledEntries.length > 0) {
                     allNewEntriesForThisRoute.push(...JSON.parse(JSON.stringify(task.scheduledEntries)));
                }
            });
            const entriesToAddWithUniqueIds = allNewEntriesForThisRoute.map((e, idx) => ({
                ...e,
                internalId: e.internalId || `${e.stopID}_${e.lineName}_${(e.scheduledTime||"0000").replace(':','')}_applyAll_${Date.now()}_${idx}`
            }));
            tempWorkingSchedule.push(...entriesToAddWithUniqueIds);
            totalEntriesAdded += entriesToAddWithUniqueIds.length;
        }
        
        // Collect all task keys for status update
        tasksForThisRoute.forEach(task => allAffectedTaskKeysAndTypes.push({ key: task.key, type: task.taskType }));
    }
    // --- MODIFICATION END ---

    try {
        currentWorkingSchedule_extra = tempWorkingSchedule; 
        
        await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
        console.log("Bulk apply: Main schedule rebuilt and saved to Firebase.");

        const { database, dbUpdate, dbRef } = window.firebaseOMSI;
        const appliedAtTimestamp = new Date().toISOString();
        const appliedByEmail = currentUser_extra ? currentUser_extra.email : "system (bulk apply)";
        const statusUpdates = {};
        
        allAffectedTaskKeysAndTypes.forEach(taskInfo => {
            const firebasePath = taskInfo.type === 'applySchedule' ? FB_PATH_SCHEDULED_ROUTE_UPDATES : FB_PATH_SCHEDULED_DELETIONS;
            statusUpdates[`${firebasePath}/${taskInfo.key}/status`] = 'applied (all for time)';
            statusUpdates[`${firebasePath}/${taskInfo.key}/appliedAt`] = appliedAtTimestamp;
            statusUpdates[`${firebasePath}/${taskInfo.key}/appliedBy`] = appliedByEmail;
        });

        await dbUpdate(dbRef(database), statusUpdates);
        console.log("Bulk apply: Status of all affected tasks updated in Firebase.");

        if(sruApplyAllStatusMessage_el_extra) {
            sruApplyAllStatusMessage_el_extra.textContent = `Successfully applied all tasks for ${new Date(selectedGoLiveDateTimeISO).toLocaleString()}. ${affectedRouteNames.length} routes affected. Schedule is live.`;
            sruApplyAllStatusMessage_el_extra.style.color = "#2ecc71";
        }
        await loadAndDisplayScheduledUpdates_ExtraPage(); // Use await to ensure data is fresh before next step
        renderUIDependentElements_ExtraPage();

    } catch (error) {
        console.error("Error applying all tasks for selected time:", error);
        if(sruApplyAllStatusMessage_el_extra) {
            sruApplyAllStatusMessage_el_extra.textContent = `CRITICAL ERROR applying tasks: ${error.message}. Schedule may be inconsistent. MANUAL REVIEW REQUIRED.`;
            sruApplyAllStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // Attempt to mark tasks as error
        const { database, dbUpdate, dbRef } = window.firebaseOMSI;
        const errorStatusUpdates = {};
        allAffectedTaskKeysAndTypes.forEach(taskInfo => {
            const firebasePath = taskInfo.type === 'applySchedule' ? FB_PATH_SCHEDULED_ROUTE_UPDATES : FB_PATH_SCHEDULED_DELETIONS;
            errorStatusUpdates[`${firebasePath}/${taskInfo.key}/status`] = 'error';
            errorStatusUpdates[`${firebasePath}/${taskInfo.key}/lastError`] = `Bulk Apply Error: ${error.message}`;
        });
        await dbUpdate(dbRef(database), errorStatusUpdates).catch(err => console.error("Failed to mark tasks as error:", err));
        await loadAndDisplayScheduledUpdates_ExtraPage();
    } finally {
        if(sruApplyAllForTimeButton_el_extra) sruApplyAllForTimeButton_el_extra.disabled = false;
    }
}

        async function handleCancelScheduledTask_ExtraPage(
    taskKey,
    taskType
) {
    if (!taskKey || !taskType) {
        alert(
            "Error: Invalid task key or type for cancellation/deletion provided to handler."
        );
        return;
    }

    let taskCollection;
    let firebasePath;
    let taskDescription = "";
    let userFriendlyTaskName = "";

    if (taskType === "deleteEntireRoute") {
        taskCollection = scheduledRouteDeletions_extra;
        firebasePath = FB_PATH_SCHEDULED_DELETIONS;
        taskDescription = "route deletion task";
        userFriendlyTaskName = "Scheduled Route Deletion";
    } else if (taskType === "applySchedule") {
        taskCollection = scheduledRouteUpdates_extra;
        firebasePath = FB_PATH_SCHEDULED_ROUTE_UPDATES;
        taskDescription = "schedule application/update task";
        userFriendlyTaskName = "Scheduled Timetable Update";
    } else {
        alert(
            `Error: Unknown task type "${taskType}" for cancellation/deletion.`
        );
        return;
    }

    if (
        !taskCollection ||
        typeof taskCollection !== "object" ||
        taskCollection === null
    ) {
        alert(
            `Error: Task data for type "${userFriendlyTaskName}" is not loaded or is invalid in the system. The list will attempt to refresh.`
        );
        if (
            typeof loadAndDisplayScheduledUpdates_ExtraPage ===
            "function"
        )
            loadAndDisplayScheduledUpdates_ExtraPage();
        return;
    }

    if (!taskCollection[taskKey]) {
        alert(
            `Error: Task with key "${taskKey}" not found for type "${userFriendlyTaskName}". It might have already been processed or deleted. The list will refresh.`
        );
        if (
            typeof loadAndDisplayScheduledUpdates_ExtraPage ===
            "function"
        )
            loadAndDisplayScheduledUpdates_ExtraPage();
        return;
    }

    const taskToCancel = taskCollection[taskKey];
    const routeNameForConfirm =
        taskToCancel.routeName || "Unknown Route";
    const goLiveForConfirm = taskToCancel.goLiveDateTime
        ? new Date(taskToCancel.goLiveDateTime).toLocaleString()
        : "Unknown Go-Live";
    const profileForConfirm =
        taskType === "applySchedule"
            ? taskToCancel.operatingProfile || "N/A"
            : "N/A (Deletion Task)";

    let actionVerb = "DELETE RECORD of";
    if (
        taskToCancel.status === "pending" ||
        taskToCancel.status === "error"
    ) {
        actionVerb = "CANCEL and DELETE record of";
    }

    // --- MODIFICATION START: Corrected the confirmation message ---
    // The original message incorrectly used HTML and had a syntax error for variables.
    // This new version uses plain text and the correct ${variable} syntax.
    if (
        !confirm(
            `Are you sure you want to ${actionVerb} the ${taskDescription} for:\nRoute: "${routeNameForConfirm}"\nProfile(s): "${profileForConfirm}"\nGo-Live: ${goLiveForConfirm}\n\nThis action cannot be undone.`
        )
    ) {
    // --- MODIFICATION END ---
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent =
                "Operation cancelled by user.";
            rsgStatusMessage_el_extra.style.color = "";
            setTimeout(() => {
                if (
                    rsgStatusMessage_el_extra.textContent ===
                    "Operation cancelled by user."
                )
                    rsgStatusMessage_el_extra.textContent = "";
            }, 3000);
        }
        return;
    }

    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        alert(
            "Firebase components not available. Cannot process cancellation."
        );
        return;
    }
    const { database, dbRemove, dbRef } = window.firebaseOMSI;

    try {
        await dbRemove(
            dbRef(database, `${firebasePath}/${taskKey}`)
        );

        if (taskCollection && taskCollection[taskKey]) {
            delete taskCollection[taskKey];
        }

        isScheduledTasksCacheValid_extra = false; 

        if (
            typeof loadAndDisplayScheduledUpdates_ExtraPage ===
            "function"
        )
            loadAndDisplayScheduledUpdates_ExtraPage();
        if (
            typeof checkAndDisplayDueUpdatesNotification_ExtraPage ===
            "function"
        )
            checkAndDisplayDueUpdatesNotification_ExtraPage();

        const successMsg = `${userFriendlyTaskName} for "${routeNameForConfirm}" (Profile: ${profileForConfirm}, Go-Live: ${goLiveForConfirm}) has been cancelled/record deleted.`;
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = successMsg;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
            setTimeout(() => {
                if (
                    rsgStatusMessage_el_extra.textContent ===
                    successMsg
                )
                    rsgStatusMessage_el_extra.textContent = "";
            }, 4000);
        } else {
            alert(successMsg);
        }
    } catch (error) {
        alert(
            `Error deleting task record from Firebase: ${error.message}. Please try refreshing the list.`
        );
        if (
            typeof loadAndDisplayScheduledUpdates_ExtraPage ===
            "function"
        )
            loadAndDisplayScheduledUpdates_ExtraPage();
    }
}

        async function handleApplyScheduledRouteBatch_ExtraPage(tasksInBatch) {
    if (!currentUser_extra) {
        alert("Please log in to apply batch updates.");
        return;
    }
    if (!tasksInBatch || tasksInBatch.length === 0) {
        alert("No tasks provided for batch application.");
        return;
    }

    const representativeTask = tasksInBatch[0];
    const targetRouteName = representativeTask.routeName.toUpperCase();
    const goLiveDateTimeForDisplay = new Date(representativeTask.goLiveDateTime).toLocaleString();

    let allNewEntriesForRoute = [];
    let involvedProfiles = new Set();
    let involvedDestinations = new Set();
    let taskKeysInBatch = [];

    tasksInBatch.forEach(task => {
        if ((task.taskTypeDisplay === 'applySchedule' || task.taskType === 'applySchedule') && task.routeName.toUpperCase() === targetRouteName) {
            if (task.scheduledEntries && task.scheduledEntries.length > 0) {
                allNewEntriesForRoute.push(...JSON.parse(JSON.stringify(task.scheduledEntries)));
                involvedProfiles.add(task.operatingProfile);
                involvedDestinations.add(task.destinationName);
            }
            if (task.key) {
                taskKeysInBatch.push(task.key);
            }
        }
    });

    if (allNewEntriesForRoute.length === 0) {
        alert(`No actual schedule entries found within the selected batch for Route "${targetRouteName}". Cannot apply.`);
        return;
    }

    const profileList = Array.from(involvedProfiles).join(', ') || "N/A";
    const destList = Array.from(involvedDestinations).join(', ') || "N/A";

    const confirmMessage = `Apply BATCH update for Route: ${targetRouteName}\n` +
                         `Go-Live: ${goLiveDateTimeForDisplay}\n\n` +
                         `This batch includes ${tasksInBatch.length} update(s) which will define the following for this route:\n` +
                         `Operating Profile(s): ${profileList}\n` +
                         `Destination(s): ${destList}\n\n` +
                         `WARNING: This will DELETE ALL existing schedules for the ENTIRE Route "${targetRouteName}" (across all its current profiles and destinations).\n` +
                         `Then, ${allNewEntriesForRoute.length} new entries from this batch will be added, forming the new complete schedule for this route.\n\n` +
                         `Proceed with wiping the whole route and applying this batch?`;

    if (!confirm(confirmMessage)) {
        alert("Batch application cancelled by user.");
        return;
    }

    if (rsgStatusMessage_el_extra) {
        rsgStatusMessage_el_extra.textContent = `Processing batch for Route ${targetRouteName}... This may take a moment.`;
        rsgStatusMessage_el_extra.style.color = "#3498db";
    }

    const { database, dbRef, dbUpdate } = window.firebaseOMSI; 
    let removedCount = 0;

    currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
        const matchesRouteOnly = entry.lineName && entry.lineName.toUpperCase() === targetRouteName;
        if (matchesRouteOnly) {
            removedCount++;
            return false;
        }
        return true;
    });

    const entriesToAddWithUniqueIds = allNewEntriesForRoute.map((e, idx) => ({
        ...e,
        internalId: e.internalId || `${e.stopID}_${e.lineName}_${(e.scheduledTime||"0000").replace(':','')}_batchApply_${Date.now()}_${idx}`
    }));
    currentWorkingSchedule_extra.push(...entriesToAddWithUniqueIds);

    try {
        await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);

        const appliedAtTimestamp = new Date().toISOString();
        const appliedByEmail = currentUser_extra ? currentUser_extra.email : "system (batch)";
        
        let individualUpdateSuccessCount = 0;
        let individualUpdateFailureCount = 0;
        
        for (const taskKey of taskKeysInBatch) {
            if (!taskKey || typeof taskKey !== 'string' || taskKey.trim() === "") {
                individualUpdateFailureCount++;
                continue;
            }

            const taskNodeRef = dbRef(database, `${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`);
            const updatesForThisIndividualTask = {
                status: 'applied (batch)', 
                appliedAt: appliedAtTimestamp,             
                appliedBy: appliedByEmail                  
            };

            try {
                await dbUpdate(taskNodeRef, updatesForThisIndividualTask); 
                individualUpdateSuccessCount++;
            } catch (e) {
                individualUpdateFailureCount++;
            }
        }

        loadAndDisplayScheduledUpdates_ExtraPage();
        renderUIDependentElements_ExtraPage();

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Batch update for Route ${targetRouteName} applied successfully. Live schedule updated. Status update attempts: ${individualUpdateSuccessCount} success, ${individualUpdateFailureCount} fail.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
            setTimeout(() => { if (rsgStatusMessage_el_extra.textContent && rsgStatusMessage_el_extra.textContent.includes(`Batch update for Route ${targetRouteName}`)) rsgStatusMessage_el_extra.textContent = ''; }, 7000);
        } else {
            alert(`Batch update for Route ${targetRouteName} applied successfully. Live schedule updated. Status update attempts: ${individualUpdateSuccessCount} success, ${individualUpdateFailureCount} fail.`);
        }

    } catch (error) {
        alert(`Error applying batch update for Route "${targetRouteName}": ${error.message}. The live schedule may be in an inconsistent state. Review carefully.`);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error applying batch for Route ${targetRouteName}: ${error.message}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        
        taskKeysInBatch.forEach(taskKey => {
            if (taskKey && typeof taskKey === 'string' && taskKey.trim() !== "") {
                const taskErrorPath = `${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`;
                const errorUpdatesForThisTask = {
                    status: 'error',
                    lastError: `Batch Apply Error (Main Schedule): ${error.message}`
                };
                dbUpdate(dbRef(database, taskErrorPath), errorUpdatesForThisTask)
                    .catch(err => {});
            }
        });
        loadAndDisplayScheduledUpdates_ExtraPage(); 
    }
}

function rsg_updateRsgActionButtonsState() {
    const routeName = rsgRouteNameInput_el_extra.value.trim();
    const opProfiles = rsg_getSelectedOpProfilesString_ExtraPage();
    const destName = rsgDestinationNameInput_el_extra.value.trim();
    const firstStopTimes = rsgFirstStopTimesInput_el_extra.value.trim();
    // stopSequenceHasItems is no longer part of formIsComplete for enabling Generate button
    // const stopSequenceHasItems = rsg_selectedStops_extra && rsg_selectedStops_extra.length > 0;

    const formIsComplete = routeName && opProfiles && destName && firstStopTimes; // Removed stopSequenceHasItems
    const previewExists = rsg_generatedPreviewEntries_extra && rsg_generatedPreviewEntries_extra.length > 0;

    const tickedCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox:checked');
    const tickedSavedConfigsCount = tickedCheckboxes.length;
    const disableMainFormActionsDueToBatchSelection = tickedSavedConfigsCount > 1;

    let shouldGenerateButtonBeDisabled;
    let shouldSaveButtonBeDisabled;
    let shouldScheduleThisButtonBeDisabled;
    let shouldAddPreviewButtonBeDisabled;

    if (disableMainFormActionsDueToBatchSelection) {
        shouldGenerateButtonBeDisabled = true;
        shouldSaveButtonBeDisabled = true;
        shouldScheduleThisButtonBeDisabled = true;
        shouldAddPreviewButtonBeDisabled = true;
    } else {
        shouldGenerateButtonBeDisabled = !formIsComplete;
        shouldSaveButtonBeDisabled = !formIsComplete || !previewExists;
        shouldScheduleThisButtonBeDisabled = !formIsComplete || !previewExists;
        shouldAddPreviewButtonBeDisabled = !formIsComplete || !previewExists;
    }

    if (rsgGenerateScheduleButton_el_extra) {
        rsgGenerateScheduleButton_el_extra.disabled = shouldGenerateButtonBeDisabled;
    }

    if (rsgSaveConfigurationButton_el_extra) {
        rsgSaveConfigurationButton_el_extra.disabled = shouldSaveButtonBeDisabled;
    }

    if (rsgScheduleThisConfigButton_el_extra) {
        rsgScheduleThisConfigButton_el_extra.disabled = shouldScheduleThisButtonBeDisabled;
    }

    if (rsgAddToWorkingScheduleButton_el_extra) {
        rsgAddToWorkingScheduleButton_el_extra.disabled = shouldAddPreviewButtonBeDisabled;
        if (!shouldAddPreviewButtonBeDisabled) {
            rsgAddToWorkingScheduleButton_el_extra.classList.remove('neutral');
            rsgAddToWorkingScheduleButton_el_extra.classList.add('save');
        } else {
            rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
            rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
        }
    }

    if (rsgScheduleSelectedConfigsButton_el_extra) {
        rsgScheduleSelectedConfigsButton_el_extra.disabled = (tickedSavedConfigsCount === 0);
    }
}

function rsg_openCopyFromModal_ExtraPage() { 
    if (!rsgCopyModal_el_extra || !rsgCopySourceRouteNameSelect_el_extra || !rsgCopySourceDestNameSelect_el_extra || !rsgCopyModalStatus_el_extra || !rsgCopySourceOpProfileSelect_el_extra) {
        console.error("RSG Copy Modal: One or more essential DOM elements are missing for modal open.");
        return;
    }
    const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))].filter(Boolean).sort(compareLineNames_ExtraPage); 
    
    // Populate Source Route Select
    rsgCopySourceRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route --</option>'; 
    uniqueRoutes.forEach(route => { 
        const opt = document.createElement('option'); 
        opt.value = route; 
        opt.textContent = route; 
        rsgCopySourceRouteNameSelect_el_extra.appendChild(opt); 
    }); 
    
    // Trigger population of dependent dropdowns (Destination, then Profile)
    // Call rsg_populateCopySourceDestinationSelect_ExtraPage which will in turn call profile population
    if (typeof rsg_populateCopySourceDestinationSelect_ExtraPage === 'function') {
        rsg_populateCopySourceDestinationSelect_ExtraPage(); 
    } else { // Fallback if dest populator somehow not ready, at least try to clear profiles
        if (typeof rsg_populateCopySourceOpProfileSelect_ExtraPage === 'function') {
            rsg_populateCopySourceOpProfileSelect_ExtraPage();
        }
    }
    
    if (rsgCopyModalStatus_el_extra) rsgCopyModalStatus_el_extra.textContent = ''; 
    if (rsgCopyModal_el_extra) rsgCopyModal_el_extra.style.display = 'flex';
}

        function rsg_closeCopyFromModal_ExtraPage() { 
             if (rsgCopyModal_el_extra) rsgCopyModal_el_extra.style.display = 'none';
        }

        function rsg_populateCopySourceDestinationSelect_ExtraPage() { 
    if (!rsgCopySourceDestNameSelect_el_extra || !rsgCopySourceRouteNameSelect_el_extra) { // Removed check for text input
        console.warn("RSG Copy Modal: Destination select or route select missing for populating destinations.");
        // Attempt to populate profiles even if destination can't be fully processed, as profiles might depend only on route
        if (typeof rsg_populateCopySourceOpProfileSelect_ExtraPage === 'function') {
            rsg_populateCopySourceOpProfileSelect_ExtraPage();
        }
        return;
    }

    // Read directly from the route SELECT element
    const selectedRoute = rsgCopySourceRouteNameSelect_el_extra.value.trim().toUpperCase(); 
    
    rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Destination --</option>'; 
    
    if (!selectedRoute) { 
        rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route First --</option>'; 
    } else {
        const uniqueDestinations = [...new Set(currentWorkingSchedule_extra.filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName).map(e => e.destinationName))].sort(); 
        if (uniqueDestinations.length > 0) { 
            uniqueDestinations.forEach(dest => { 
                const opt = document.createElement('option'); 
                opt.value = dest; 
                opt.textContent = dest; 
                rsgCopySourceDestNameSelect_el_extra.appendChild(opt); 
            }); 
        } else { 
            rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- No Destinations for this Route --</option>';
        }
    }
    // Call to populate profiles after destinations are set/cleared
    if (typeof rsg_populateCopySourceOpProfileSelect_ExtraPage === 'function') {
        rsg_populateCopySourceOpProfileSelect_ExtraPage();
    }
}

       async function rsg_handleCopyDataFromSource_ExtraPage() {
    if (!rsgCopySourceRouteNameSelect_el_extra || !rsgCopySourceOpProfileSelect_el_extra || !rsgCopySourceDestNameSelect_el_extra || !rsgCopyModalStatus_el_extra || !window.firebaseOMSI) {
        if (rsgCopyModalStatus_el_extra) {
            rsgCopyModalStatus_el_extra.textContent = "Error: Required elements for copy are missing.";
            rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
        }
        return;
    }
    // Read all values from SELECT elements
    const sourceRouteName = rsgCopySourceRouteNameSelect_el_extra.value;
    const sourceOpProfile = rsgCopySourceOpProfileSelect_el_extra.value;
    const sourceDestName = rsgCopySourceDestNameSelect_el_extra.value;

    if (!sourceRouteName || !sourceOpProfile || !sourceDestName) {
        rsgCopyModalStatus_el_extra.textContent = "All source fields (Route, Operating Profile, Destination) must be selected.";
        rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
        return;
    }

    rsgCopyModalStatus_el_extra.textContent = "Fetching source data...";
    rsgCopyModalStatus_el_extra.style.color = "#f1c40f";

    let sourceConfigData = null;
    let sourceStopSequence = [];
    let sourceFirstStopTimes = "";

    const sourceConfigKey = rsg_createConfigKey_ExtraPage(sourceRouteName, sourceOpProfile, sourceDestName);
    if (rsg_loadedConfigs_extra && rsg_loadedConfigs_extra[sourceConfigKey]) {
        sourceConfigData = rsg_loadedConfigs_extra[sourceConfigKey];
        console.log(`Copy From: Found matching saved RSG config: ${sourceConfigKey}`);
    }

    if (sourceConfigData) {
        sourceStopSequence = sourceConfigData.stopSequence || [];
        sourceFirstStopTimes = sourceConfigData.firstStopTimes || "";
    } else {
        console.log(`Copy From: No saved RSG config found for ${sourceRouteName}/${sourceOpProfile}/${sourceDestName}. Deriving from live schedule.`);
        const sourceRouteNameUpper = sourceRouteName.toUpperCase();
        const relevantEntries = currentWorkingSchedule_extra.filter(entry =>
            entry.lineName && entry.lineName.toUpperCase() === sourceRouteNameUpper &&
            entry.OperatingProfile === sourceOpProfile &&
            entry.destinationName === sourceDestName
        );

        if (relevantEntries.length > 0) {
            relevantEntries.sort((a, b) => {
                const absA = getAbsMinutes(a.scheduledTime, parseInt(a.DayOffset || 0));
                const absB = getAbsMinutes(b.scheduledTime, parseInt(b.DayOffset || 0));
                if (absA === null && absB === null) return 0;
                if (absA === null) return 1;
                if (absB === null) return -1;
                return absA - absB;
            });
            
            const firstTripSequence = [];
            if (relevantEntries.length > 0) {
                const firstStopIDOfJourney = relevantEntries[0].stopID;
                const firstDepartureTimeOfJourneyAbs = getAbsMinutes(relevantEntries[0].scheduledTime, parseInt(relevantEntries[0].DayOffset || 0));
                let absTimeOfPrevStopInSequence = -1; 
                const MIN_STOPS_BEFORE_START_ID_REPEAT_CONSIDERED_NEW_TRIP = 3; 

                for (let i = 0; i < relevantEntries.length; i++) {
                    const entry = relevantEntries[i];
                    if (!entry.stopID || !entry.scheduledTime) continue;
                    const currentTimeAbs = getAbsMinutes(entry.scheduledTime, parseInt(entry.DayOffset || 0));
                    if (currentTimeAbs === null) continue;

                    if (firstTripSequence.length > 0 && absTimeOfPrevStopInSequence !== -1) {
                        if (currentTimeAbs < absTimeOfPrevStopInSequence) break; 
                        if (entry.stopID === firstStopIDOfJourney) {
                            if (firstDepartureTimeOfJourneyAbs !== null && 
                                currentTimeAbs > (firstDepartureTimeOfJourneyAbs + 15) &&
                                firstTripSequence.length >= MIN_STOPS_BEFORE_START_ID_REPEAT_CONSIDERED_NEW_TRIP) {
                                break; 
                            }
                        }
                    }
                    
                    let calculatedTimeAdjustment = 0;
                    if (firstTripSequence.length > 0 && absTimeOfPrevStopInSequence !== -1) {
                         calculatedTimeAdjustment = currentTimeAbs - absTimeOfPrevStopInSequence;
                         if (calculatedTimeAdjustment < 0) calculatedTimeAdjustment = 2; 
                         else if (calculatedTimeAdjustment > 180) calculatedTimeAdjustment = 60; 
                    }
                    firstTripSequence.push({ 
                        stopID: entry.stopID, 
                        stopName: entry.stopName || entry.stopID, 
                        direction: entry.direction || "", 
                        timeAdjustment: calculatedTimeAdjustment
                    }); 
                    absTimeOfPrevStopInSequence = currentTimeAbs;
                }
            }
            sourceStopSequence = firstTripSequence;

            if (sourceStopSequence.length > 0) {
                const firstStopIdInPulledSequence = sourceStopSequence[0].stopID;
                const departuresForFirstStop = [...new Set(
                    relevantEntries
                        .filter(e => e.stopID === firstStopIdInPulledSequence && (e.DayOffset === "0" || !e.DayOffset))
                        .map(e => e.scheduledTime)
                        .filter(t => t && t.match(/^\d{2}:\d{2}$/))
                )].sort((a,b) => parseInt(a.replace(':','')) - parseInt(b.replace(':','')));
                sourceFirstStopTimes = departuresForFirstStop.join('\t'); 
            }
        }
    }

    if (sourceStopSequence.length > 0) {
        rsg_selectedStops_extra = JSON.parse(JSON.stringify(sourceStopSequence)); 
        if (rsgFirstStopTimesInput_el_extra) {
            rsgFirstStopTimesInput_el_extra.value = sourceFirstStopTimes;
        }
        rsg_renderStopSequence_ExtraPage(); 

        rsg_lastLoadedRouteName_extra = rsgRouteNameInput_el_extra.value.trim(); 
        rsg_lastLoadedDestName_extra = rsgDestinationNameInput_el_extra.value.trim();   
        rsg_lastLoadedOpProfile_extra = rsg_getSelectedOpProfilesString_ExtraPage(); 
        
        rsg_currentlyEditingConfigKey_extra = null; 
        rsg_currentlyEditingConfigDisplayName_extra = null;
        rsg_isDirty = true;

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Sequence and times successfully copied from source [${sourceRouteName} / ${sourceOpProfile} / ${sourceDestName}]. Please review.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
        }
        rsg_resetPreviewState("Data copied from source. Regenerate preview if settings are complete.", "success");
        rsg_closeCopyFromModal_ExtraPage();
    } else {
        rsgCopyModalStatus_el_extra.textContent = `No sequence data found or derived for source: ${sourceRouteName} (Profile: ${sourceOpProfile}, Dest: ${sourceDestName}). Nothing copied.`;
        rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
    }
    if(typeof rsg_updateRsgActionButtonsState === 'function') rsg_updateRsgActionButtonsState();
}

        function showExtraPageSection(sectionId) {
    if (!toolSectionsWrapper_el_extra) {
        return;
    }
    const allSections = toolSectionsWrapper_el_extra.querySelectorAll(".tool-content-section");
    allSections.forEach((s) => {
        s.style.display = "none";
    });
    const sectionToShow = document.getElementById(sectionId);
    if (sectionToShow) {
        sectionToShow.style.display = "block";
        localStorage.setItem("omsiExtraToolsActiveSection", sectionId);
        
        // Clear any running intervals from other sections
        if (keyDeparturesIntervalId_extra) {
            clearInterval(keyDeparturesIntervalId_extra);
            keyDeparturesIntervalId_extra = null;
        }

        // Run setup functions based on which section is being shown
        if (sectionId === "day-profile-override-section_extra") {
            if (typeof loadAndDisplayOverrides_ExtraPage === 'function') loadAndDisplayOverrides_ExtraPage();
            if (typeof dpo_populateProfileCheckboxes_ExtraPage === 'function') dpo_populateProfileCheckboxes_ExtraPage();
            if (typeof dpo_populateRouteSelection_ExtraPage === 'function') dpo_populateRouteSelection_ExtraPage();
            if (typeof updateSelectedDateInfo_ExtraPage === 'function') updateSelectedDateInfo_ExtraPage();
            if (typeof dpo_updateActionButtonsState === 'function') dpo_updateActionButtonsState();
        } else if (sectionId === "key-departures-section_extra") {
            if (typeof displayKeyDepartures_ExtraPage === 'function') {
                displayKeyDepartures_ExtraPage();
                keyDeparturesIntervalId_extra = setInterval(displayKeyDepartures_ExtraPage, KEY_DEPARTURES_REFRESH_INTERVAL_MS);
            }
        } else if (sectionId === "stop-manager-tool-section_extra") {
            if (typeof populateMasterStopList_ExtraPage === 'function') populateMasterStopList_ExtraPage();
        } else if (sectionId === "global-route-deletion-section_extra") {
            if (typeof populateGlobalRouteToDeleteList_ExtraPage === 'function') populateGlobalRouteToDeleteList_ExtraPage();
        } else if (sectionId === "route-schedule-generator-section_extra") {
            if (typeof rsg_populateRouteTiles_ExtraPage === 'function') rsg_populateRouteTiles_ExtraPage();
            if (typeof rsg_populateProfileCheckboxes_ExtraPage === 'function') rsg_populateProfileCheckboxes_ExtraPage();
            if (typeof rsg_renderSavedConfigsList_ExtraPage === 'function') rsg_renderSavedConfigsList_ExtraPage();
            if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') rsg_loadOrPullConfiguration_ExtraPage(null, true);
        } else if (sectionId === "route-profile-deletion-section_extra") {
            if (typeof rpd_populateRouteSelect_ExtraPage === 'function') rpd_populateRouteSelect_ExtraPage();
        } else if (sectionId === "view-departures-section_extra") {
            if (typeof populateStopSelectorForDeparturesView_ExtraPage === 'function') populateStopSelectorForDeparturesView_ExtraPage();
            if (typeof displayDeparturesForSelectedStop_ExtraPage === 'function') displayDeparturesForSelectedStop_ExtraPage();
        } else if (sectionId === "timetable-exporter-section_extra") {
            if (typeof populateTimetableExporterRouteSelect_ExtraPage === 'function') populateTimetableExporterRouteSelect_ExtraPage();
        } else if (sectionId === "scheduled-route-updates-section_extra") {
            if (isScheduledTasksCacheValid_extra && cachedScheduledTasksHTML_extra && cachedBatchRadiosHTML_extra) {
                const listContainer = document.getElementById("sru-updates-list-container-extra");
                const batchRadiosContainer = document.getElementById("sru-batch-golive-radios-container-extra");
                if (listContainer) listContainer.innerHTML = cachedScheduledTasksHTML_extra;
                if (batchRadiosContainer) batchRadiosContainer.innerHTML = cachedBatchRadiosHTML_extra;
                if (typeof checkAndDisplayDueUpdatesNotification_ExtraPage === 'function') checkAndDisplayDueUpdatesNotification_ExtraPage();
            } else {
                if (typeof loadAndDisplayScheduledUpdates_ExtraPage === 'function') loadAndDisplayScheduledUpdates_ExtraPage();
            }
        } else if (sectionId === "scheduled-route-deletion-section_extra") {
            if (typeof srd_populateRouteSelect_ExtraPage === 'function') srd_populateRouteSelect_ExtraPage();
        } else if (sectionId === 'config-data-section_extra') {
            if (typeof displaySchoolHolidays_ExtraPage === 'function') displaySchoolHolidays_ExtraPage();
            if (typeof renderEditableOpProfiles_ExtraPage === 'function') renderEditableOpProfiles_ExtraPage();
        } else if (sectionId === 'calendar-view-section_extra') {
             if (typeof renderCalendarView_ExtraPage === 'function') {
                cv_currentDisplayDate_extra = new Date();
                renderCalendarView_ExtraPage();
             }
        } else if (sectionId === 'curtailment-config-section_extra') {
            if (typeof op_points_populateRouteSelect === 'function') op_points_populateRouteSelect();
            if (typeof op_points_populateReturnOriginSelect === 'function') op_points_populateReturnOriginSelect();
        } else if (sectionId === 'trip-curtailment-section_extra') {
            if (typeof curtail_populateSelectors === 'function') curtail_populateSelectors();
        } else if (sectionId === 'route-curtailment-section_extra') {
            if (typeof slc_populateRouteSelect === 'function') slc_populateRouteSelect();
            if (typeof slc_renderActiveCurtailments === 'function') slc_renderActiveCurtailments();
        }
    }
}

        async function updateAuthUI_ExtraPage(user) {
            currentUser_extra = user;
            const authHeading = authSection_el_extra ? authSection_el_extra.querySelector('h2') : null;

            if (user) { // User is logged in
                if (loginFormContainer_el_extra) loginFormContainer_el_extra.style.display = 'none';
                if (logoutContainer_el_extra) logoutContainer_el_extra.style.display = 'flex';
                if (authHeading) authHeading.style.display = 'none';
                if (authSection_el_extra) authSection_el_extra.classList.add('auth-section-compact');
                
                if (topMenuBar_el_extra) topMenuBar_el_extra.style.display = 'block';
                if (loggedInUserEmailDisplay_el_extra) loggedInUserEmailDisplay_el_extra.textContent = user.email;
                if (currentProfileDisplayContainer_el) currentProfileDisplayContainer_el.style.display = 'block';

                await loadInitialData_ExtraPage();
		setupFirebaseListeners_ExtraPage();
                
            } else { // User is logged out
                if (authSection_el_extra) {
                    authSection_el_extra.style.display = 'block';
                    authSection_el_extra.classList.remove('auth-section-compact');
                }
                if (loginFormContainer_el_extra) loginFormContainer_el_extra.style.display = 'block';
                if (logoutContainer_el_extra) logoutContainer_el_extra.style.display = 'none';
                if (authHeading) authHeading.style.display = 'block';
                
                if (topMenuBar_el_extra) topMenuBar_el_extra.style.display = 'none';
                
                if (authStatus_el_extra) authStatus_el_extra.textContent = 'Please log in.';
                if (loggedInUserEmailDisplay_el_extra) loggedInUserEmailDisplay_el_extra.textContent = '';
                if (currentProfileDisplayContainer_el) currentProfileDisplayContainer_el.style.display = 'none';
                if (toolSectionsWrapper_el_extra) {
                    toolSectionsWrapper_el_extra.querySelectorAll('.tool-content-section').forEach(s => s.style.display = 'none');
                }

                // Clear sensitive data on logout
                currentWorkingSchedule_extra = [];
                allDefinedStops_data = {};
            }
        }
        
// In omsi_tools_extra.html
async function loadInitialData_ExtraPage() {
    console.log("%cPERFORMANCE TEST: Starting loadInitialData_ExtraPage...", "color: cyan; font-weight: bold;");
    const totalStartTime = performance.now();

    currentWorkingSchedule_extra = [];
    rsg_loadedConfigs_extra = {};
    allDefinedStops_data = {};
    globalCustomRouteColours_extra = {}; // Reset before loading

    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        console.error("Firebase not connected.");
        return;
    }

    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;

    try {
        let startTime, duration;

        startTime = performance.now();
        console.log("[PERF] Loading RSG configurations...");
        const rsgConfigsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_RSG_CONFIGS));
        rsg_loadedConfigs_extra = rsgConfigsSnap.exists() ? rsgConfigsSnap.val() || {} : {};
        duration = performance.now() - startTime;
        console.log(`[PERF] ...loaded ${Object.keys(rsg_loadedConfigs_extra).length} RSG configs in ${duration.toFixed(2)} ms.`);

        startTime = performance.now();
        console.log("[PERF] Flattening RSG configs into a full schedule...");
        let flatScheduleFromConfigs = [];
        Object.values(rsg_loadedConfigs_extra).forEach(config => {
            if (config && config.stopSequence && config.firstStopTimes) {
                const trips = generateScheduleTripsFromConfig(config);
                trips.forEach(tripEntries => {
                    flatScheduleFromConfigs.push(...tripEntries);
                });
            }
        });
        currentWorkingSchedule_extra = flatScheduleFromConfigs;
        duration = performance.now() - startTime;
        console.log(`[PERF] ...flattened configs into ${currentWorkingSchedule_extra.length} schedule entries in ${duration.toFixed(2)} ms.`);

        // --- START: THIS IS THE CRITICAL FIX ---
        // This block was missing, causing custom colors not to be loaded.
        startTime = performance.now();
        console.log("[PERF] Loading Global Custom Route Colours...");
        const globalColoursSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS));
        globalCustomRouteColours_extra = globalColoursSnap.exists() ? globalColoursSnap.val() || {} : {};
        duration = performance.now() - startTime;
        console.log(`[PERF] ...loaded ${Object.keys(globalCustomRouteColours_extra).length} global color rules in ${duration.toFixed(2)} ms.`);
        // --- END: CRITICAL FIX ---

        startTime = performance.now();
        console.log("[PERF] Loading Master Stop Definitions...");
        const allDefinedStopsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_ALL_DEFINED_STOPS));
        allDefinedStops_data = allDefinedStopsSnap.exists() ? allDefinedStopsSnap.val() || {} : {};
        duration = performance.now() - startTime;
        console.log(`[PERF] ...loaded ${Object.keys(allDefinedStops_data).length} master stop definitions in ${duration.toFixed(2)} ms.`);
        
        startTime = performance.now();
        console.log("[PERF] Building Stop-to-Route Map...");
        stopToServingRoutesMap_extra.clear();
        currentWorkingSchedule_extra.forEach(entry => {
            if (entry.stopID && entry.lineName) {
                if (!stopToServingRoutesMap_extra.has(entry.stopID)) {
                    stopToServingRoutesMap_extra.set(entry.stopID, new Set());
                }
                stopToServingRoutesMap_extra.get(entry.stopID).add(entry.lineName);
            }
        });
        duration = performance.now() - startTime;
        console.log(`[PERF] ...built stop-to-route map in ${duration.toFixed(2)} ms.`);
        
        startTime = performance.now();
        console.log("[PERF] Loading Operating Profiles list...");
        const opProfilesSnap = await dbGet(dbRef(database, FB_PATH_EDITABLE_OP_PROFILES));
        if (opProfilesSnap.exists()) RSG_OPERATING_PROFILES_LIST = opProfilesSnap.val();
        duration = performance.now() - startTime;
        console.log(`[PERF] ...loaded ${RSG_OPERATING_PROFILES_LIST.length} operating profiles in ${duration.toFixed(2)} ms.`);

        startTime = performance.now();
        console.log("[PERF] Loading School Holidays...");
        const shSnap = await dbGet(dbRef(database, FB_PATH_SCHOOL_HOLIDAYS));
        if (shSnap.exists()) schoolHolidayDateRanges_extra = shSnap.val(); else schoolHolidayDateRanges_extra = DEFAULT_SCHOOL_HOLIDAY_RANGES;
        duration = performance.now() - startTime;
        console.log(`[PERF] ...loaded ${schoolHolidayDateRanges_extra.length} school holiday ranges in ${duration.toFixed(2)} ms.`);

        startTime = performance.now();
        console.log("[PERF] Loading Day Profile Overrides...");
        const dpoSnap = await dbGet(dbChild(dbRef(database), FB_PATH_OPERATIONAL_OVERRIDES));
        operationalOverrides_data = dpoSnap.exists() ? dpoSnap.val() || {} : {};
        duration = performance.now() - startTime;
        console.log(`[PERF] ...loaded ${Object.keys(operationalOverrides_data).length} DPO records in ${duration.toFixed(2)} ms.`);

        startTime = performance.now();
        console.log("[PERF] Loading Mass Curtailments...");
        const massCurtailmentsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_MASS_CURTAILMENTS));
        massCurtailments_data = massCurtailmentsSnap.exists() ? massCurtailmentsSnap.val() || {} : {};
        duration = performance.now() - startTime;
        console.log(`[PERF] ...loaded ${Object.keys(massCurtailments_data).length} mass curtailment records in ${duration.toFixed(2)} ms.`);
        
    } catch (error) {
        console.error("Firebase Load Error (Extra Tools):", error);
    }
    
    await fetchBankHolidays_ExtraPage();
    await updateCurrentProfileDisplay_ExtraPage();
    renderUIDependentElements_ExtraPage();

    const totalDuration = performance.now() - totalStartTime;
    console.log(`%cPERFORMANCE TEST: loadInitialData_ExtraPage finished in ${totalDuration.toFixed(2)} ms.`, "color: cyan; font-weight: bold;");
}

function renderUIDependentElements_ExtraPage() {
    const lastSectionFromStorage = localStorage.getItem('omsiExtraToolsActiveSection');
    let sectionIdToShow = null;
    let calledShowSection = false; // Flag to ensure showExtraPageSection is called at most once initially by this function

    console.log(`[RenderUI] Attempting to determine initial section. Last from storage: ${lastSectionFromStorage}`);

    // Priority 1: Try to show the section from localStorage if it's valid
    if (lastSectionFromStorage && document.getElementById(lastSectionFromStorage)) {
        // Further check: Is it a real tool section linked to a menu button?
        const isKnownToolSection = topMenuBar_el_extra && Array.from(topMenuBar_el_extra.querySelectorAll('.menu-button')).some(b => b.dataset.section === lastSectionFromStorage);
        if (isKnownToolSection) {
            sectionIdToShow = lastSectionFromStorage;
            console.log(`[RenderUI] Valid section found in localStorage: ${sectionIdToShow}`);
        } else {
            // The stored section ID might be old or invalid (e.g., tool removed)
            console.log(`[RenderUI] Section from localStorage ('${lastSectionFromStorage}') is not a known tool section. Clearing from storage.`);
            localStorage.removeItem('omsiExtraToolsActiveSection');
            sectionIdToShow = null; // Ensure it's null so we try the default next
        }
    }

    // Priority 2: If no valid section from localStorage, and user is logged in, try the first menu button
    if (!sectionIdToShow && currentUser_extra && topMenuBar_el_extra) {
        const firstButton = topMenuBar_el_extra.querySelector('.menu-button');
        if (firstButton && firstButton.dataset.section) {
            sectionIdToShow = firstButton.dataset.section;
            console.log(`[RenderUI] No valid localStorage section. Defaulting to first menu button section: ${sectionIdToShow}`);
        }
    }

    // Now, actually show the determined section (if any)
    if (sectionIdToShow && typeof showExtraPageSection === 'function') {
        showExtraPageSection(sectionIdToShow);
        calledShowSection = true;
    } else if (currentUser_extra && !calledShowSection) {
        // User is logged in, but no section could be determined (e.g., localStorage empty/invalid, and no menu buttons)
        // This state would result in the "blue screen" if not handled.
        console.warn("[RenderUI] User is logged in, but no default section could be determined to display. All tool sections will remain hidden.");
        // Ensure all tool sections are indeed hidden if no specific one is chosen.
        // `showExtraPageSection` normally handles hiding others, but if it's not called,
        // we might want an explicit hide here, though `updateAuthUI_ExtraPage(null)` initial call usually does this.
        if (toolSectionsWrapper_el_extra) {
            toolSectionsWrapper_el_extra.querySelectorAll(".tool-content-section.section").forEach((s) => {
                s.style.display = "none";
            });
        }
    }
    // If not logged in (currentUser_extra is null), updateAuthUI_ExtraPage(null) would have hidden all sections
    // and the top menu bar, so no specific section showing logic is needed here for that case.
}

        document.addEventListener('DOMContentLoaded', () => {
    console.log("OMSI Tools Extra DOMContentLoaded");

const topMenuBar = document.getElementById('top-menu-bar_extra');
            if (topMenuBar) {
                const menuButtons = topMenuBar.querySelectorAll('.menu-button');
                menuButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        if (currentUser_extra && typeof showExtraPageSection === 'function') {
                            showExtraPageSection(button.dataset.section);
                        }
                    });
                });
            }

if (rsgOpenPasteAdjModalButton_el_extra && typeof rsg_openPasteAdjModal_ExtraPage === 'function') {
    rsgOpenPasteAdjModalButton_el_extra.addEventListener('click', rsg_openPasteAdjModal_ExtraPage);
}
if (rsgPasteAdjApplyButton_el_extra && typeof rsg_applyPastedAdjustments_ExtraPage === 'function') {
    rsgPasteAdjApplyButton_el_extra.addEventListener('click', rsg_applyPastedAdjustments_ExtraPage);
}
if (rsgPasteAdjCancelButton_el_extra && typeof rsg_closePasteAdjModal_ExtraPage === 'function') {
    rsgPasteAdjCancelButton_el_extra.addEventListener('click', rsg_closePasteAdjModal_ExtraPage);
}
if (rsgPasteAdjModal_el_extra && typeof rsg_closePasteAdjModal_ExtraPage === 'function') {
    rsgPasteAdjModal_el_extra.addEventListener('click', (e) => {
        if (e.target === rsgPasteAdjModal_el_extra) {
            rsg_closePasteAdjModal_ExtraPage();
        }
    });
}

if (document.getElementById('slc-route-select-extra')) {
    document.getElementById('slc-route-select-extra').addEventListener('change', slc_populateDestinationSelect);
    document.getElementById('slc-route-select-extra').addEventListener('change', slc_populateReturnDestinationSelect);
}
if (document.getElementById('slc-destination-select-extra')) {
    document.getElementById('slc-destination-select-extra').addEventListener('change', slc_populateCurtailmentPointsSelect);
    document.getElementById('slc-destination-select-extra').addEventListener('change', slc_populateReturnDestinationSelect);
}
if (document.getElementById('slc-activate-button-extra')) {
    document.getElementById('slc-activate-button-extra').addEventListener('click', slc_handleActivateCurtailment);
}
if (document.getElementById('slc-refresh-list-button-extra')) {
    document.getElementById('slc-refresh-list-button-extra').addEventListener('click', slc_renderActiveCurtailments);
}

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/live-tracker/sw-omsitoolsextra.js')
                .then(registration => {
                    console.log('Service Worker registered with scope:', registration.scope);
                    // Removed direct call to getFCMTokenAndStore from here.
                    // It will be called from authOnAuthStateChanged once user is confirmed logged in.
                })
                .catch(error => {
                    console.error('Service Worker registration failed:', error);
                });
        });
    }

if (document.getElementById('curtail-route-select-extra')) {
    document.getElementById('curtail-route-select-extra').addEventListener('change', () => {
        // This now calls both the original function for single trips and the new one for mass curtailment
        curtail_populateDestSelect();
        mrc_setupToolForRoute();
    });
}
if (document.getElementById('rc-term-stop-search-input-extra')) {
    document.getElementById('rc-term-stop-search-input-extra').addEventListener('input', mrc_handleStopSearch);
}
if (document.getElementById('rc-activate-button-extra')) {
    document.getElementById('rc-activate-button-extra').addEventListener('click', mrc_handleActivateCurtailment);
}


    if (dpoSelectAllRoutesButton_el_extra && typeof dpo_selectAllRoutes_ExtraPage === 'function') {
        dpoSelectAllRoutesButton_el_extra.addEventListener('click', dpo_selectAllRoutes_ExtraPage);
    }

const opPointsRouteSelect = document.getElementById('op-points-route-select-extra');
if (opPointsRouteSelect) {
    opPointsRouteSelect.addEventListener('change', op_points_populateDestSelect);
}
const curtailRouteSelect = document.getElementById('curtail-route-select-extra');
            if (curtailRouteSelect) {
                curtailRouteSelect.addEventListener('change', curtail_populateDestSelect);
            }
const opPointsDestSelect = document.getElementById('op-points-dest-select-extra');
if (opPointsDestSelect) {
    opPointsDestSelect.addEventListener('change', () => {
        op_points_populateLastStopSelect();
        op_points_displayDefinedPoints();
        op_points_updateCopyButtonState(); // <-- ADD THIS LINE
    });
}
const opPointsAddBtn = document.getElementById('op-points-add-btn-extra');
if (opPointsAddBtn) {
    opPointsAddBtn.addEventListener('click', op_points_handleAddPoint);
}

const opPointsCopyBtn = document.getElementById('op-points-copy-from-route-btn-extra');
    if (opPointsCopyBtn && typeof op_points_openCopyModal === 'function') {
        opPointsCopyBtn.addEventListener('click', op_points_openCopyModal);
    }

const opCopySourceDestSelect = document.getElementById('op-copy-source-dest-select-extra');
    if (opCopySourceDestSelect && typeof op_points_findAndDisplayEligiblePoints === 'function') {
        opCopySourceDestSelect.addEventListener('change', op_points_findAndDisplayEligiblePoints);
    }

const opCopyCancelBtn = document.getElementById('op-copy-modal-cancel-button-extra');
    if (opCopyCancelBtn && typeof op_points_closeCopyModal === 'function') {
        opCopyCancelBtn.addEventListener('click', op_points_closeCopyModal);
    }

    const opCopyConfirmBtn = document.getElementById('op-copy-modal-confirm-button-extra');
    if (opCopyConfirmBtn && typeof op_points_performCopy === 'function') {
        opCopyConfirmBtn.addEventListener('click', op_points_performCopy);
    }

const opCopySourceRouteSelect = document.getElementById('op-copy-source-route-select-extra');
    if (opCopySourceRouteSelect && typeof op_points_populateCopyModalDestSelect === 'function') {
        opCopySourceRouteSelect.addEventListener('change', op_points_populateCopyModalDestSelect);
    }

const opPointsLastStopSelect = document.getElementById('op-points-last-stop-select-extra');
const opPointsDestNameInput = document.getElementById('op-points-dest-name-input-extra');
if (opPointsLastStopSelect && opPointsDestNameInput) {
    opPointsLastStopSelect.addEventListener('change', () => {
        const selectedOption = opPointsLastStopSelect.options[opPointsLastStopSelect.selectedIndex];
        if (selectedOption && selectedOption.value) {
            const stopInfo = allDefinedStops_data[selectedOption.value.toUpperCase()];
            opPointsDestNameInput.value = stopInfo ? stopInfo.stopName : '';
        }
    });
}
const curtailFetchBtn = document.getElementById('curtail-fetch-trips-btn-extra');
if (curtailFetchBtn) {
    curtailFetchBtn.addEventListener('click', curtail_fetchTodaysTrips);
}
const curtailModal = document.getElementById('curtail-intervention-modal-extra');
const curtailModalCancelBtn = document.getElementById('curtail-modal-cancel-button-extra');
if (curtailModal && curtailModalCancelBtn) {
    const closeModal = () => curtailInterventionModal_el_extra.style.display = 'none';
    curtailModalCancelBtn.addEventListener('click', closeModal);
    curtailModal.addEventListener('click', (e) => {
        if (e.target === curtailInterventionModal_el_extra) closeModal();
    });
}
const { database, dbOnValue, dbRef } = window.firebaseOMSI;
const liveInterventionsRef = dbRef(database, FB_PATH_LIVE_INTERVENTIONS);
dbOnValue(liveInterventionsRef, (snapshot) => {
    liveCurtailmentData = snapshot.exists() ? snapshot.val() : {};
    if (document.getElementById('trip-curtailment-section_extra').style.display !== 'none') {
        curtail_renderTripCards();
    }
});

    // --- General UI Listeners ---
    const iphoneTestBtn = document.getElementById('iphoneTestNotificationBtn');
    if (iphoneTestBtn) {
        iphoneTestBtn.addEventListener('click', () => {
            console.log("TEST BUTTON CLICKED - Listener Fired!"); // Debug log

            // Ensure Notification API is supported
            if (!("Notification" in window)) {
                console.log("Browser does not support native desktop notifications."); // Log instead of alert
                alert("Your browser does not support desktop notifications."); // Keep alert for user feedback
                return;
            }

            // Check if permission is granted
            if (Notification.permission === "granted") {
                try {
                    const options = {
                        body: "Success! This is a desktop/OS notification from your Home Screen app.",
                        icon: '/live-tracker/assets/icons/icon-192x192.png', // Ensure this path is correct
                        // Add data to the notification itself for the click action
                        data: {
                            url: 'https://076189.github.io/live-tracker/omsi_tools_extra.html' // URL to open on click
                        }
                    };
                    const notification = new Notification("iPhone Test Notification!", options);

                    console.log("Notification object created successfully."); // Debug log

                    notification.onclick = function(event) {
                        console.log('Test notification clicked directly.', event); // Debug log
                        event.preventDefault(); // Prevent default browser action if any

                        const clickUrl = this.data.url; // Get URL from the notification's data

                        if (clickUrl) {
                            // Directly open the window using window.open for main page context
                            window.open(clickUrl, '_blank');
                        }
                        this.close(); // Close the notification after click
                    };

                } catch (e) {
                    console.error("Error creating native notification:", e); // Log the error
                    alert("Error creating notification: " + e.message); // Alert user to error
                }
            } else {
                console.warn("Notification permission not granted. Current status:", Notification.permission); // Log the status
                // Provide user guidance if permission is not granted
                if (Notification.permission === "default") {
                    alert("Notification permission not granted. Please click 'Enable Desktop Alerts' first and allow the prompt.");
                } else if (Notification.permission === "denied") {
                    alert("Notification permission was denied. You need to enable it in your browser's site settings.");
                }
            }
        });
    }

    const enableDesktopBtn = document.getElementById('enableDesktopNotificationsBtn_extra');
    if (enableDesktopBtn) {
        enableDesktopBtn.addEventListener('click', async () => {
            // This uses the newer requestNotificationPermission function which handles localStorage
            if (typeof requestNotificationPermission === 'function') {
                await requestNotificationPermission();
            } else if (!("Notification" in window)) { // Fallback if new function isn't there
                alert("This browser does not support desktop notifications.");
            } else { // Original simpler logic if new function is missing
                const permission = await Notification.requestPermission();
                if (permission === "granted") {
                    alert("Desktop notifications enabled!");
                    localStorage.setItem('desktopNotificationPreference_omsiExtra', 'granted');
                } else if (permission === "denied") {
                    alert("Desktop notifications denied. You can change this in your browser's site settings if you change your mind.");
                    localStorage.setItem('desktopNotificationPreference_omsiExtra', 'denied');
                } else {
                    alert("Notification permission request dismissed or not acted upon.");
                }
            }
        });
    }

    const kdRefreshBtn = document.getElementById('kd-refresh-btn_extra');
    if (kdRefreshBtn && typeof displayKeyDepartures_ExtraPage === 'function') {
        kdRefreshBtn.addEventListener('click', displayKeyDepartures_ExtraPage);
    }

    const cvPrevMonthBtn = document.getElementById('cv-prev-month-btn_extra');
    const cvNextMonthBtn = document.getElementById('cv-next-month-btn_extra');

    if (cvPrevMonthBtn && typeof renderCalendarView_ExtraPage === 'function') {
        cvPrevMonthBtn.addEventListener('click', () => {
            cv_currentDisplayDate_extra.setMonth(cv_currentDisplayDate_extra.getMonth() - 1);
            renderCalendarView_ExtraPage();
        });
    }
    if (cvNextMonthBtn && typeof renderCalendarView_ExtraPage === 'function') {
        cvNextMonthBtn.addEventListener('click', () => {
            cv_currentDisplayDate_extra.setMonth(cv_currentDisplayDate_extra.getMonth() + 1);
            renderCalendarView_ExtraPage();
        });
    }

    // --- Firebase Auth Initialization ---
    function initializeExtraAppLogic() {
        console.log("Firebase ready, Extra app logic init.");
        if (!window.firebaseOMSI || !window.firebaseOMSI.auth) {
            console.error("Extra Tools: Firebase OMSI object not found during initializeExtraAppLogic.");
            if (typeof updateAuthUI_ExtraPage === 'function') updateAuthUI_ExtraPage(null);
            if (authStatus_el_extra) authStatus_el_extra.textContent = 'Critical Firebase init error for app logic.';
            return;
        }

        const {
            auth,
            authOnAuthStateChanged,
            // We no longer destructure authSignInWithEmailAndPassword or authSignOut here.
            // We will access them directly from window.firebaseOMSI to ensure scope availability.
        } = window.firebaseOMSI;

        authOnAuthStateChanged(auth, async user => {
            if (typeof updateAuthUI_ExtraPage === 'function') {
                await updateAuthUI_ExtraPage(user);
            }

            if (user) {
                console.log("FCM DEBUG: User authenticated. Attempting to get FCM token.");
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.ready;

                        if (registration && typeof getFCMTokenAndStore === 'function') {
                            if (window.firebaseOMSI.messaging && window.firebaseOMSI.fcmGetToken) {
                                console.log("FCM DEBUG: Messaging and getToken already available. Proceeding.");
                                await getFCMTokenAndStore(registration);
                            } else {
                                console.warn("FCM DEBUG: Messaging or getToken not immediately available. Attempting to get it explicitly.");
                            }
                        } else {
                            console.warn("FCM DEBUG: Service Worker not ready or getFCMTokenAndStore function not defined.");
                        }

                        setTimeout(async () => {
                            console.log("FCM DEBUG: Retrying FCM token acquisition after delay...");
                            if (window.firebaseOMSI.messaging && window.firebaseOMSI.fcmGetToken && currentUser_extra) {
                                try {
                                    const retryRegistration = await navigator.serviceWorker.ready;
                                    if (retryRegistration) {
                                        await getFCMTokenAndStore(retryRegistration);
                                    }
                                } catch (err) {
                                    console.error("FCM DEBUG: Error during FCM token retry:", err);
                                }
                            } else {
                                console.warn("FCM DEBUG: FCM or currentUser still not ready after retry delay.");
                            }
                        }, 3000);

                    } catch (err) {
                        console.error("FCM DEBUG: Error waiting for Service Worker ready:", err);
                    }
                } else {
                    console.warn("FCM DEBUG: Service Worker not supported in this browser.");
                }
            } else {
                console.log("FCM DEBUG: User logged out. Skipping FCM token acquisition.");
            }

            if (user && selectNewStopIdFormat_el_extra && inputNewStopName_el_extra && inputNewStopId_el_extra &&
                !inputNewStopName_el_extra.value && !inputNewStopId_el_extra.value &&
                typeof autoGenerateAndSetNewStopId_ExtraPage === 'function') {
                autoGenerateAndSetNewStopId_ExtraPage();
            }
        });

        if (adminLoginForm_el_extra && inputEmail_el_extra && inputPassword_el_extra && authStatus_el_extra) {
            adminLoginForm_el_extra.addEventListener('submit', (e) => {
                e.preventDefault();
                authStatus_el_extra.textContent = 'Logging in...';
                authStatus_el_extra.style.color = '#f1c40f'; // Yellow for processing
                // *** IMPORTANT CHANGE HERE ***
                window.firebaseOMSI.authSignInWithEmailAndPassword(window.firebaseOMSI.auth, inputEmail_el_extra.value, inputPassword_el_extra.value)
                    .catch(err => {
                        authStatus_el_extra.textContent = `Login Error: ${err.message}`;
                        authStatus_el_extra.style.color = '#e74c3c'; // Red for error
                    });
            });
        }

        const logoutButtonElement = document.getElementById('logoutButton_extra');
        if (logoutButtonElement) {
            logoutButtonElement.addEventListener('click', () => {
                console.log("Logout button clicked. Cleaning up...");
                localStorage.removeItem('omsiExtraToolsActiveSection');

                if (tripAlertIntervalId_extra) { clearInterval(tripAlertIntervalId_extra); tripAlertIntervalId_extra = null; console.log("Trip alert monitor stopped."); }
                if (keyDeparturesIntervalId_extra) { clearInterval(keyDeparturesIntervalId_extra); keyDeparturesIntervalId_extra = null; console.log("Key departures monitor stopped.");}
                
                todayKeyTripEvents_extra = [];
                shownTripAlerts_extra = {};
                lastAlertDataPreparedDate_extra = null;
                
                const globalBanner = document.getElementById('global-notification-banner');
                if (globalBanner) globalBanner.style.display = 'none';

                // *** IMPORTANT CHANGE HERE ***
                window.firebaseOMSI.authSignOut(window.firebaseOMSI.auth).catch(e => console.error("Sign-out error (Extra):", e));
            });
        }
    }

    if (window.firebaseOMSI && window.firebaseOMSI.auth) {
        initializeExtraAppLogic();
    } else {
        document.addEventListener('firebaseReady', () => {
            if (window.firebaseOMSI && window.firebaseOMSI.auth) {
                initializeExtraAppLogic();
            } else {
                console.error("Extra Tools: Firebase still not ready after firebaseReady event!");
                if (typeof updateAuthUI_ExtraPage === 'function') updateAuthUI_ExtraPage(null);
                if (authStatus_el_extra) authStatus_el_extra.textContent = 'Fatal: Firebase did not initialize.';
            }
        }, {
            once: true
        });
    }

    // --- Day Profile Override (DPO) Section Listeners ---
    if (overrideDateInput_el_extra && typeof updateSelectedDateInfo_ExtraPage === 'function') {
        overrideDateInput_el_extra.addEventListener('change', updateSelectedDateInfo_ExtraPage);
    }
    if (dpoApplyOverrideToRoutesButton_el_extra && typeof dpo_applyOverrideToRoutes_ExtraPage === 'function') {
        dpoApplyOverrideToRoutesButton_el_extra.addEventListener('click', dpo_applyOverrideToRoutes_ExtraPage);
    }
    if (dpoClearOverrideForRoutesButton_el_extra && typeof dpo_clearOverrideForRoutes_ExtraPage === 'function') {
        dpoClearOverrideForRoutesButton_el_extra.addEventListener('click', dpo_clearOverrideForRoutes_ExtraPage);
    }
    if (dpoClearRouteSelectionButton_el_extra && typeof dpo_clearRouteSelections_ExtraPage === 'function') {
        dpoClearRouteSelectionButton_el_extra.addEventListener('click', dpo_clearRouteSelections_ExtraPage);
    }
    if (dpoSelectAllRoutesButton_el_extra && typeof dpo_selectAllRoutes_ExtraPage === 'function') {
        dpoSelectAllRoutesButton_el_extra.addEventListener('click', dpo_selectAllRoutes_ExtraPage);
    }
    const dpoClearProfileCBsBtn = document.getElementById('dpo-clear-profile-checkboxes-button-extra');
    if (dpoClearProfileCBsBtn && typeof dpo_clearProfileSelections_ExtraPage === 'function') {
        dpoClearProfileCBsBtn.addEventListener('click', dpo_clearProfileSelections_ExtraPage);
    }


    // --- Stop Manager & Creation Section Listeners ---
    if (selectNewStopIdFormat_el_extra && typeof autoGenerateAndSetNewStopId_ExtraPage === 'function') {
         selectNewStopIdFormat_el_extra.addEventListener('change', autoGenerateAndSetNewStopId_ExtraPage);
    }
    if (inputNewStopName_el_extra && typeof autoGenerateAndSetNewStopId_ExtraPage === 'function') {
        inputNewStopName_el_extra.addEventListener('input', autoGenerateAndSetNewStopId_ExtraPage);
    }
    if (inputNewStopId_el_extra && newStopIdAvailability_el_extra) {
        inputNewStopId_el_extra.addEventListener('input', () => {
            const newStopId = inputNewStopId_el_extra.value.trim().toUpperCase();
            if (!newStopId) {
                newStopIdAvailability_el_extra.textContent = '';
                return;
            }
            if (!/^[A-Z0-9]+$/.test(newStopId)) { // Ensure only A-Z, 0-9
                newStopIdAvailability_el_extra.textContent = 'ID invalid chars (A-Z, 0-9 only).';
                newStopIdAvailability_el_extra.style.color = '#e74c3c';
                return;
            }
            // Check against allDefinedStops_data keys (which should be uppercase)
            const definedStopIDsUppercase = allDefinedStops_data ? Object.keys(allDefinedStops_data) : [];
            if (definedStopIDsUppercase.includes(newStopId)) {
                newStopIdAvailability_el_extra.textContent = 'ID already exists in definitions!';
                newStopIdAvailability_el_extra.style.color = '#e74c3c';
            } else {
                newStopIdAvailability_el_extra.textContent = 'ID available.';
                newStopIdAvailability_el_extra.style.color = '#2ecc71';
            }
        });
    }
    if (buttonAddNewStop_el_extra && typeof handleAddStopDetails_ExtraPage === 'function') {
        buttonAddNewStop_el_extra.addEventListener('click', handleAddStopDetails_ExtraPage);
    }
    if (fileInputBulkAddStops_el_extra && typeof handleExcelFileForBulkAdd_ExtraPage === 'function') {
        fileInputBulkAddStops_el_extra.addEventListener('change', handleExcelFileForBulkAdd_ExtraPage);
    }
    if (buttonBulkAddNewStops_el_extra && typeof handleBulkAddStops_ExtraPage === 'function') {
        buttonBulkAddNewStops_el_extra.addEventListener('click', handleBulkAddStops_ExtraPage);
    }
    if (masterStopListFilterInput_el_extra && typeof populateMasterStopList_ExtraPage === 'function') {
        masterStopListFilterInput_el_extra.addEventListener('input', populateMasterStopList_ExtraPage);
    }
    if (refreshMasterStopListButton_el_extra && typeof loadInitialData_ExtraPage === 'function' && typeof populateMasterStopList_ExtraPage === 'function') {
        refreshMasterStopListButton_el_extra.addEventListener('click', async () => { // made async
            if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "Refreshing stop data...";
            await loadInitialData_ExtraPage(); // Data loading can be awaited
            populateMasterStopList_ExtraPage(); // Then populate
            if (masterStopListStatus_el_extra && masterStopListStatus_el_extra.textContent.includes("Refreshing")) {
                masterStopListStatus_el_extra.textContent = "Stop list refreshed.";
            }
        });
    }
    if (applyMasterListStopIdChangesButton_el_extra && typeof handleApplyMasterListStopIdChangesButton_ExtraPage === 'function') {
        applyMasterListStopIdChangesButton_el_extra.addEventListener('click', handleApplyMasterListStopIdChangesButton_ExtraPage);
    }
    if (exportUniqueStopsButton_el_extra) { /* Export logic is complex, assumed correct from previous state */ }
    if (findDuplicateStopsByNameDirButton_el_extra && typeof findDuplicateStopsByNameAndDirection_ExtraPage === 'function') {
        findDuplicateStopsByNameDirButton_el_extra.addEventListener('click', findDuplicateStopsByNameAndDirection_ExtraPage);
    }

    // --- Global Route Deletion Section Listeners ---
    if (deleteEntireRouteButton_el_extra && typeof handleDeleteEntireRouteGlobally_ExtraPage === 'function') {
        deleteEntireRouteButton_el_extra.addEventListener('click', handleDeleteEntireRouteGlobally_ExtraPage);
    }

    // --- Route Profile Deletion (RPD) Section Listeners ---
    if (rpdRouteSelect_el_extra && typeof rpd_handleRouteNameSelectChange_ExtraPage === 'function') {
        rpdRouteSelect_el_extra.addEventListener('change', rpd_handleRouteNameSelectChange_ExtraPage);
    }
    if (rpdRouteInput_el_extra && typeof rpd_handleRouteNameInputChange_ExtraPage === 'function') {
        // Using 'input' for more responsive update than 'blur'
        rpdRouteInput_el_extra.addEventListener('input', rpd_handleRouteNameInputChange_ExtraPage);
    }
    if (rpdDestinationSelect_el_extra && typeof rpd_handleDestinationNameSelectChange_ExtraPage === 'function') {
        rpdDestinationSelect_el_extra.addEventListener('change', rpd_handleDestinationNameSelectChange_ExtraPage);
    }
    if (rpdDestinationInput_el_extra && typeof rpd_handleDestinationNameInputChange_ExtraPage === 'function') {
        // Using 'input' for more responsive update
        rpdDestinationInput_el_extra.addEventListener('input', rpd_handleDestinationNameInputChange_ExtraPage);
    }
    if (rpdClearDestinationButton_el_extra && typeof rpd_handleClearDestination_ExtraPage === 'function') {
        rpdClearDestinationButton_el_extra.addEventListener('click', rpd_handleClearDestination_ExtraPage);
    }
    if (rpdDeleteProfilesButton_el_extra && typeof handleDeleteRouteProfiles_ExtraPage === 'function') {
        rpdDeleteProfilesButton_el_extra.addEventListener('click', handleDeleteRouteProfiles_ExtraPage);
    }

    // --- Route Schedule Generator (RSG) Section Listeners ---
    if (rsgClearRouteSelectionButton_el_extra && typeof rsg_clearRouteSelection_ExtraPage === 'function') {
        rsgClearRouteSelectionButton_el_extra.addEventListener('click', rsg_clearRouteSelection_ExtraPage);
    }
    const rsgClearProfileCBsBtn = document.getElementById('rsg-clear-profile-checkboxes-button-extra');
    if (rsgClearProfileCBsBtn && typeof rsg_clearProfileSelections_ExtraPage === 'function') {
        rsgClearProfileCBsBtn.addEventListener('click', rsg_clearProfileSelections_ExtraPage);
    }
    if (rsgDestinationNameSelect_el_extra && typeof rsg_handleDestinationNameSelectChange_ExtraPage === 'function') {
        rsgDestinationNameSelect_el_extra.addEventListener('change', rsg_handleDestinationNameSelectChange_ExtraPage);
    }
    if (rsgDestinationNameInput_el_extra && typeof rsg_handleDestinationNameInputChange_ExtraPage === 'function') {
        rsgDestinationNameInput_el_extra.addEventListener('blur', rsg_handleDestinationNameInputChange_ExtraPage); // Or 'input' if preferred
    }
    if (rsgStopSearchInput_el_extra && typeof rsg_handleStopSearch_ExtraPage === 'function') {
        rsgStopSearchInput_el_extra.addEventListener('input', rsg_handleStopSearch_ExtraPage);
    }
    if (rsgGenerateScheduleButton_el_extra && typeof rsg_handleGenerateSchedulePreview_ExtraPage === 'function') {
    rsgGenerateScheduleButton_el_extra.addEventListener('click', () => rsg_handleGenerateSchedulePreview_ExtraPage(false));
}
if (rsgSaveConfigurationButton_el_extra && typeof rsg_handleSaveConfiguration_ExtraPage === 'function') {
    rsgSaveConfigurationButton_el_extra.addEventListener('click', rsg_handleSaveConfiguration_ExtraPage);
}
if (rsgAddToWorkingScheduleButton_el_extra && typeof rsg_handleAddGeneratedToWorkingSchedule_ExtraPage === 'function') {
    rsgAddToWorkingScheduleButton_el_extra.addEventListener('click', rsg_handleAddGeneratedToWorkingSchedule_ExtraPage);
}
if (rsgScheduleThisConfigButton_el_extra && typeof handleScheduleThisConfiguration === 'function') {
    rsgScheduleThisConfigButton_el_extra.addEventListener('click', handleScheduleThisConfiguration);
}
if (rsgScheduleDateTimeConfirmBtn && typeof rsg_confirmScheduleGoLive_ExtraPage === 'function') {
    rsgScheduleDateTimeConfirmBtn.addEventListener('click', rsg_confirmScheduleGoLive_ExtraPage);
}
    if (rsgScheduleDateTimeCancelBtn && typeof rsg_closeScheduleDateTimeModal_ExtraPage === 'function') {
        rsgScheduleDateTimeCancelBtn.addEventListener('click', rsg_closeScheduleDateTimeModal_ExtraPage);
    }
    if (rsgScheduleDateTimeModal && typeof rsg_closeScheduleDateTimeModal_ExtraPage === 'function') {
        rsgScheduleDateTimeModal.addEventListener('click', (event) => {
            if (event.target === rsgScheduleDateTimeModal) rsg_closeScheduleDateTimeModal_ExtraPage();
        });
    }
    if (rsgFirstStopTimesInput_el_extra && typeof rsg_updateRsgActionButtonsState === 'function') {
        rsgFirstStopTimesInput_el_extra.addEventListener('input', () => {
            rsg_isDirty = true; console.log("RSG User Edit: First stop times changed. rsg_isDirty is true.");
            rsg_updateRsgActionButtonsState();
        });
        rsgFirstStopTimesInput_el_extra.addEventListener('keydown', function(event) {
            if (event.key === 'Tab') {
                event.preventDefault(); let start = this.selectionStart; let end = this.selectionEnd;
                this.value = this.value.substring(0, start) + '\t' + this.value.substring(end);
                this.selectionStart = this.selectionEnd = start + 1;
                this.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
            }
        });
    }
    const rsgPullFirstStopTimesButton_local = document.getElementById('rsg-pull-first-stop-times-button-extra');
    if (rsgPullFirstStopTimesButton_local && typeof rsg_pullCurrentFirstStopTimes_ExtraPage === 'function') {
        rsgPullFirstStopTimesButton_local.addEventListener('click', rsg_pullCurrentFirstStopTimes_ExtraPage);
    }
    const rsgScheduleSelectedBtn_local = document.getElementById('rsg-schedule-selected-configs-button-extra');
    if (rsgScheduleSelectedBtn_local && typeof rsg_handleScheduleSelectedConfigs_ExtraPage === 'function') {
        rsgScheduleSelectedBtn_local.addEventListener('click', rsg_handleScheduleSelectedConfigs_ExtraPage);
    }
    const rsgSelectAllGlobalCheckbox_local = document.getElementById('rsg-select-all-configs-checkbox-extra');
    if (rsgSelectAllGlobalCheckbox_local && typeof rsg_handleSelectAllConfigsChange_ExtraPage === 'function') {
        rsgSelectAllGlobalCheckbox_local.addEventListener('change', rsg_handleSelectAllConfigsChange_ExtraPage);
    }
    if (rsgOpenCopyModalButton_el_extra && typeof rsg_openCopyFromModal_ExtraPage === 'function') {
        rsgOpenCopyModalButton_el_extra.addEventListener('click', rsg_openCopyFromModal_ExtraPage);
    }
    if (rsgCopyModalCancelButton_el_extra && typeof rsg_closeCopyFromModal_ExtraPage === 'function') {
        rsgCopyModalCancelButton_el_extra.addEventListener('click', rsg_closeCopyFromModal_ExtraPage);
    }
    if (rsgCopyModalActionButton_el_extra && typeof rsg_handleCopyDataFromSource_ExtraPage === 'function') {
        rsgCopyModalActionButton_el_extra.addEventListener('click', rsg_handleCopyDataFromSource_ExtraPage);
    }
    if (rsgCopyModal_el_extra && typeof rsg_closeCopyFromModal_ExtraPage === 'function') {
        rsgCopyModal_el_extra.addEventListener('click', (event) => {
            if (event.target === rsgCopyModal_el_extra) rsg_closeCopyFromModal_ExtraPage();
        });
    }
    if (rsgCopySourceRouteNameSelect_el_extra && typeof rsg_populateCopySourceDestinationSelect_ExtraPage === 'function') {
        rsgCopySourceRouteNameSelect_el_extra.addEventListener('change', rsg_populateCopySourceDestinationSelect_ExtraPage);
    }
    if (rsgCopySourceDestNameSelect_el_extra && typeof rsg_populateCopySourceOpProfileSelect_ExtraPage === 'function') {
        rsgCopySourceDestNameSelect_el_extra.addEventListener('change', rsg_populateCopySourceOpProfileSelect_ExtraPage);
    }

    const rsgSaveConfirmBtn_local = document.getElementById('rsg-save-config-confirm-button-extra');
    if (rsgSaveConfirmBtn_local && typeof rsg_performSaveConfiguration_ExtraPage === 'function') {
        rsgSaveConfirmBtn_local.addEventListener('click', rsg_performSaveConfiguration_ExtraPage);
    }
    const rsgSaveCancelBtn_local = document.getElementById('rsg-save-config-cancel-button-extra');
    if (rsgSaveCancelBtn_local && typeof rsg_hideSaveConfigModal_ExtraPage === 'function') {
        rsgSaveCancelBtn_local.addEventListener('click', rsg_hideSaveConfigModal_ExtraPage);
    }
    const rsgSaveModal_local = document.getElementById('rsg-save-config-modal-extra');
    if (rsgSaveModal_local && typeof rsg_hideSaveConfigModal_ExtraPage === 'function') {
        rsgSaveModal_local.addEventListener('click', (event) => {
            if (event.target === rsgSaveModal_local) rsg_hideSaveConfigModal_ExtraPage();
        });
    }
    // Listeners for RSG Rename Config Modal (if it exists and has these IDs)
    // const rsgRenameConfirmBtn_local = document.getElementById('rsg-rename-config-confirm-button-extra');
    // if (rsgRenameConfirmBtn_local && typeof rsg_performRenameConfiguration_ExtraPage === 'function') {
    //    rsgRenameConfirmBtn_local.addEventListener('click', () => rsg_performRenameConfiguration_ExtraPage(rsg_configKeyToRename_extra));
    // }
    // const rsgRenameCancelBtn_local = document.getElementById('rsg-rename-config-cancel-button-extra');
    // if (rsgRenameCancelBtn_local && typeof rsg_hideRenameConfigModal_ExtraPage === 'function') {
    //    rsgRenameCancelBtn_local.addEventListener('click', rsg_hideRenameConfigModal_ExtraPage);
    // }
    // const rsgRenameModal_local = document.getElementById('rsg-rename-config-modal-extra');
    // if (rsgRenameModal_local && typeof rsg_hideRenameConfigModal_ExtraPage === 'function') {
    //     rsgRenameModal_local.addEventListener('click', (event) => { if (event.target === rsgRenameModal_local) rsg_hideRenameConfigModal_ExtraPage(); });
    // }

    if (rsgReplaceStopSearchInput_el_extra && typeof rsg_handleReplaceStopSearch_ExtraPage === 'function') {
        rsgReplaceStopSearchInput_el_extra.addEventListener('input', rsg_handleReplaceStopSearch_ExtraPage);
    }
    if (rsgReplaceStopModalCancelButton_el_extra && typeof rsg_closeReplaceStopModal_ExtraPage === 'function') {
        rsgReplaceStopModalCancelButton_el_extra.addEventListener('click', rsg_closeReplaceStopModal_ExtraPage);
    }
    if (rsgReplaceStopModal_el_extra && typeof rsg_closeReplaceStopModal_ExtraPage === 'function') {
        rsgReplaceStopModal_el_extra.addEventListener('click', (event) => {
            if (event.target === rsgReplaceStopModal_el_extra) rsg_closeReplaceStopModal_ExtraPage();
        });
    }

    // --- Scheduled Route Deletion (SRD) Section Listeners ---
    if (srdRouteNameSelect_el_extra && srdRouteNameInput_el_extra) {
        srdRouteNameSelect_el_extra.addEventListener('change', () => {
            if (srdRouteNameInput_el_extra) srdRouteNameInput_el_extra.value = srdRouteNameSelect_el_extra.value;
            if (srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = '';
        });
        srdRouteNameInput_el_extra.addEventListener('input', () => {
            const typedValue = srdRouteNameInput_el_extra.value.trim().toUpperCase();
            let matchedSelectValue = "";
            if (srdRouteNameSelect_el_extra) {
                const matchedOption = Array.from(srdRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedValue);
                if (matchedOption) matchedSelectValue = matchedOption.value;
                if (srdRouteNameSelect_el_extra.value !== matchedSelectValue) srdRouteNameSelect_el_extra.value = matchedSelectValue;
            }
            if (srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = '';
        });
    }
    if (srdScheduleDeletionButton_el_extra && typeof srd_confirmAndScheduleDeletion_ExtraPage === 'function') {
        srdScheduleDeletionButton_el_extra.addEventListener('click', srd_confirmAndScheduleDeletion_ExtraPage);
    }

    // --- Scheduled Route Updates (SRU) Section Listeners ---
    const sruRefreshButton_local = document.getElementById('sru-refresh-list-button-extra');
    if (sruRefreshButton_local && typeof loadAndDisplayScheduledUpdates_ExtraPage === 'function') {
        sruRefreshButton_local.addEventListener('click', () => {
            isScheduledTasksCacheValid_extra = false; // Invalidate cache on manual refresh
            loadAndDisplayScheduledUpdates_ExtraPage();
        });
    }
    if (sruApplyAllForTimeButton_el_extra && typeof handleApplyAllBatchesForSelectedTime_ExtraPage === 'function') {
        sruApplyAllForTimeButton_el_extra.addEventListener('click', handleApplyAllBatchesForSelectedTime_ExtraPage);
    }
    // Delegated listener for SRU list items (includes the fix for sru-cancel-all-for-route-btn)
    const sruListContainer_local = document.getElementById('sru-updates-list-container-extra');
    if (sruListContainer_local) {
        if (!sruListContainer_local.dataset.listenerAttachedSruMain) {
            sruListContainer_local.addEventListener('click', function(event) {
                const targetCancelAllForRouteButton = event.target.closest('button.sru-cancel-all-for-route-btn');
                if (targetCancelAllForRouteButton) {
                    const routeName = targetCancelAllForRouteButton.dataset.routeName;
                    if (routeName && typeof handleCancelAllUpdatesForRoute_Master === 'function') {
                        handleCancelAllUpdatesForRoute_Master(routeName);
                    } else {
                        console.error("SRU: 'Cancel All For Route' button missing routeName or handler.", targetCancelAllForRouteButton.dataset);
                        alert("Error processing per-route cancellation.");
                    }
                    return;
                }
                const targetCancelButton = event.target.closest('button.sru-cancel-task-btn');
                if (targetCancelButton) {
                    const taskKey = targetCancelButton.dataset.key;
                    const taskType = targetCancelButton.dataset.taskType;
                    if (taskKey && taskType && typeof handleCancelScheduledTask_ExtraPage === 'function') {
                        handleCancelScheduledTask_ExtraPage(taskKey, taskType);
                    } else {
                        console.error("SRU: Individual cancel button missing data or handler.", targetCancelButton.dataset);
                        alert("Error processing individual task cancellation.");
                    }
                    return;
                }
                const targetExecuteDeletionButton = event.target.closest('button.sru-execute-deletion-btn');
                if (targetExecuteDeletionButton) {
                    const taskKey = targetExecuteDeletionButton.dataset.key;
                    if (taskKey && typeof handleExecuteScheduledDeletion_ExtraPage === 'function') {
                        handleExecuteScheduledDeletion_ExtraPage(taskKey);
                    } else {
                        console.error("SRU: Execute deletion button missing data or handler.", targetExecuteDeletionButton.dataset);
                        alert("Error processing route deletion execution.");
                    }
                    return;
                }
                // Placeholder for Apply This Batch Now (sru-apply-batch-btn)
                const targetApplyBatchButton = event.target.closest('button.sru-apply-batch-btn');
                if (targetApplyBatchButton) {
                    // This requires finding the tasks associated with this specific batch to pass to handleApplyScheduledRouteBatch_ExtraPage
                    // For example, you might need to traverse up to its parent '.sru-batch-container'
                    // then use a data attribute on that container (e.g., data-batch-key or similar that was set during rendering)
                    // to retrieve the correct array of tasks from scheduledRouteUpdates_extra.
                    // const batchContainer = targetApplyBatchButton.closest('.sru-batch-container');
                    // const batchIdentifier = batchContainer ? batchContainer.dataset.scheduleKey : null; // If you set such a key
                    // if (batchIdentifier && typeof handleApplyScheduledRouteBatch_ExtraPage === 'function') {
                    //      const tasksForThisBatch = ... logic to find tasks using batchIdentifier ...
                    //      if (tasksForThisBatch && tasksForThisBatch.length > 0) {
                    //          handleApplyScheduledRouteBatch_ExtraPage(tasksForThisBatch);
                    //      } else { alert('Could not find tasks for this specific batch.'); }
                    // } else {
                    //      alert('Cannot apply this specific batch - identifier or handler missing.');
                    // }
                    console.log("SRU: 'Apply This Batch Now' button clicked. Specific batch application logic needs to be fully implemented here if desired.");
                    if (rsgStatusMessage_el_extra) {
                        rsgStatusMessage_el_extra.textContent = "'Apply this batch' not yet fully wired up here. Use 'Apply All for Selected Go-Live Time' for now.";
                        rsgStatusMessage_el_extra.style.color = "#f1c40f";
                    }
                    return;
                }
            });
            sruListContainer_local.dataset.listenerAttachedSruMain = 'true';
        }
    }
    if (sruCancelModalConfirmButton_el_extra && sruCancelModalCancelButton_el_extra && sruCancelModalSelectAllCheckbox_el_extra && sruCancelModalCheckboxesContainer_el_extra) {
        if (typeof sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage === 'function') {
            sruCancelModalConfirmButton_el_extra.addEventListener('click', sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage);
        }
        if (typeof sru_closeCancelRouteTimeSelectModal_ExtraPage === 'function') {
            sruCancelModalCancelButton_el_extra.addEventListener('click', sru_closeCancelRouteTimeSelectModal_ExtraPage);
        }
        sruCancelModalSelectAllCheckbox_el_extra.addEventListener('change', (event) => {
            const isChecked = event.target.checked;
            const timeCheckboxes = sruCancelModalCheckboxesContainer_el_extra.querySelectorAll('input[type="checkbox"][name="sruCancelSelectedGoLiveTimeCheckbox_extra"]');
            timeCheckboxes.forEach(cb => { cb.checked = isChecked; });
            const anyChecked = Array.from(timeCheckboxes).some(cb => cb.checked);
            if (sruCancelModalConfirmButton_el_extra) sruCancelModalConfirmButton_el_extra.disabled = !anyChecked;
        });
        if (sruCancelRouteTimeSelectModal_el_extra && typeof sru_closeCancelRouteTimeSelectModal_ExtraPage === 'function') {
             sruCancelRouteTimeSelectModal_el_extra.addEventListener('click', (event) => {
                if (event.target === sruCancelRouteTimeSelectModal_el_extra) sru_closeCancelRouteTimeSelectModal_ExtraPage();
            });
        }
    }
    if (sruCancelAllPendingUpdatesGloballyButton_el_extra && typeof handleCancelAllUpdatesAllRoutes_Global === 'function') {
        sruCancelAllPendingUpdatesGloballyButton_el_extra.addEventListener('click', handleCancelAllUpdatesAllRoutes_Global);
    }


    // --- Timetable Exporter Section Listeners ---
    if (tteRouteNameSelect_el_extra && tteRouteNameInput_el_extra) {
        tteRouteNameSelect_el_extra.addEventListener('change', () => {
            if (tteRouteNameInput_el_extra) tteRouteNameInput_el_extra.value = tteRouteNameSelect_el_extra.value;
            if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = '';
        });
        tteRouteNameInput_el_extra.addEventListener('input', () => {
            const typedValue = tteRouteNameInput_el_extra.value.trim().toUpperCase();
            let matchedSelectValue = "";
            if (tteRouteNameSelect_el_extra) {
                const matchedOption = Array.from(tteRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedValue);
                if (matchedOption) matchedSelectValue = matchedOption.value;
                if (tteRouteNameSelect_el_extra.value !== matchedSelectValue) tteRouteNameSelect_el_extra.value = matchedSelectValue;
            }
            if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = '';
        });
    }
    if (tteDownloadTimetableButton_el_extra && typeof handleDownloadTimetable_ExtraPage === 'function') {
        tteDownloadTimetableButton_el_extra.addEventListener('click', handleDownloadTimetable_ExtraPage);
    }

    // --- Service Analyzer Section Listeners ---
    if (serviceAnalyzerStopSelect_el_extra && typeof triggerStopAnalysisDynamically === 'function') {
        serviceAnalyzerStopSelect_el_extra.addEventListener('change', function() {
            const selectedStopID = this.value;
            if (serviceAnalyzerStopInput_el_extra) {
                const selectedOption = this.options[this.selectedIndex];
                serviceAnalyzerStopInput_el_extra.value = (selectedOption && selectedOption.value) ? selectedOption.text : "";
            }
            triggerStopAnalysisDynamically(selectedStopID);
        });
    }
    if (serviceAnalyzerStopInput_el_extra && serviceAnalyzerStopSelect_el_extra && typeof triggerStopAnalysisDynamically === 'function') {
        serviceAnalyzerStopInput_el_extra.addEventListener('input', function() { // 'input' for immediate feedback
            const typedValueLower = this.value.toLowerCase().trim();
            if (typedValueLower === "") {
                if (serviceAnalyzerStopSelect_el_extra.value !== "") serviceAnalyzerStopSelect_el_extra.value = "";
                if(serviceAnalyzerStopSummary_el_extra) serviceAnalyzerStopSummary_el_extra.innerHTML = `<span style="color:#f1c40f;">Please select or enter a stop.</span>`;
                return;
            }
            const options = Array.from(serviceAnalyzerStopSelect_el_extra.options);
            const matchedOption = options.find(opt =>
                opt.text.toLowerCase().includes(typedValueLower) ||
                (opt.value && opt.value.toLowerCase() === typedValueLower)
            );
            if (matchedOption) {
                if (serviceAnalyzerStopSelect_el_extra.value !== matchedOption.value) {
                    serviceAnalyzerStopSelect_el_extra.value = matchedOption.value;
                    // Trigger analysis if select value changes due to typing
                    triggerStopAnalysisDynamically(matchedOption.value);
                }
            } else {
                if (serviceAnalyzerStopSelect_el_extra.value !== "") serviceAnalyzerStopSelect_el_extra.value = "";
                 // If typing and no match, you might want to clear summary or show "no match"
                 if(serviceAnalyzerStopSummary_el_extra) serviceAnalyzerStopSummary_el_extra.innerHTML = `<span style="color:#f1c40f;">Searching for stop matching "${this.value}"...</span>`;
            }
        });
        serviceAnalyzerStopInput_el_extra.addEventListener('blur', function() { // Analyze on blur if a value is present
            const typedValue = this.value.trim();
            // If select has a value, it means a match was found during 'input' or already selected
            // So, we only analyze typed value if dropdown didn't make a selection
            if (typedValue && !serviceAnalyzerStopSelect_el_extra.value) {
                triggerStopAnalysisDynamically(typedValue);
            } else if (!typedValue && !serviceAnalyzerStopSelect_el_extra.value){
                if(serviceAnalyzerStopSummary_el_extra) serviceAnalyzerStopSummary_el_extra.innerHTML = `<span style="color:#f1c40f;">Please select or enter a stop.</span>`;
            }
            // if serviceAnalyzerStopSelect_el_extra.value IS set, analysis would have happened on change or input sync
        });
    }

    // --- Config Data Section Listeners ---
    const shSaveButton_el_extra = document.getElementById('sh-save-button-extra');
    const shClearFormButton_el_extra = document.getElementById('sh-clear-form-button-extra');
    const opProfileAddButton_el_extra = document.getElementById('op-profile-add-button-extra');

    if (shSaveButton_el_extra && typeof handleSaveSchoolHoliday_ExtraPage === 'function') {
        shSaveButton_el_extra.addEventListener('click', handleSaveSchoolHoliday_ExtraPage);
    }
    if (shClearFormButton_el_extra && typeof clearSchoolHolidayForm_ExtraPage === 'function') {
        shClearFormButton_el_extra.addEventListener('click', clearSchoolHolidayForm_ExtraPage);
    }
    if (opProfileAddButton_el_extra && typeof handleAddOpProfile_ExtraPage === 'function') {
        opProfileAddButton_el_extra.addEventListener('click', handleAddOpProfile_ExtraPage);
    }

});



// Helper function to generate sequence HTML for a given set of profiles
function generateSequenceMapForProfiles(
    profilesToAnalyze,
    currentDestName,
    allEntriesForRoute // All schedule entries for the main route being analyzed
) {
    const sequencesMap = new Map(); // Key: sequenceSignature, Value: { sequence: [stopObjects], profiles: Set() }

    if (!profilesToAnalyze || profilesToAnalyze.length === 0) {
        return sequencesMap; // Return an empty map if no profiles to analyze
    }

    const sortedProfiles = [...profilesToAnalyze].sort(); // Process profiles in a consistent order

    for (const opProfile of sortedProfiles) {
        // Filter entries for the current operating profile and destination
        const specificProfileEntries = allEntriesForRoute.filter(e =>
            e.destinationName === currentDestName && e.OperatingProfile === opProfile
        );

        if (specificProfileEntries.length === 0) continue; // No entries for this specific profile/destination

        // Sort these specificProfileEntries chronologically to correctly identify the first trip
        specificProfileEntries.sort((a, b) => {
            const dayOffsetA = parseInt(a.DayOffset || 0);
            const dayOffsetB = parseInt(b.DayOffset || 0);
            if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;

            const timeA = (a.scheduledTime || "99:99").replace(':', ''); // Fallback for missing time
            const timeB = (b.scheduledTime || "99:99").replace(':', '');
            return timeA.localeCompare(timeB);
        });

        const sequenceForThisProfileTrip = [];
        if (specificProfileEntries.length > 0) {
            const firstStopIDOfThisJourneyPattern = specificProfileEntries[0].stopID;
            let previousStopTimeInAbsoluteMinutes = -1;
            // Heuristic: Minimum stops to process before considering a repeat of the first stop ID as a new trip.
            // This helps distinguish a genuine new trip from a route that might loop back to its start ID quickly.
            // Adjust if necessary. If routes are very short (e.g. 2-stop shuttles that repeat often), this might need tuning.
            const MIN_STOPS_BEFORE_FIRST_ID_REVISIT_BREAK = 3;

            for (let i = 0; i < specificProfileEntries.length; i++) {
                const entry = specificProfileEntries[i];

                if (!entry.stopID || !entry.scheduledTime) {
                    console.warn(`Service Analyzer: Skipping entry for ${opProfile} (Dest: ${currentDestName}) due to missing stopID/time:`, entry);
                    continue;
                }

                const currentStopTimeInAbsoluteMinutes =
                    (parseInt(entry.DayOffset || 0) * 1440) +
                    parseInt(entry.scheduledTime.split(':')[0]) * 60 +
                    parseInt(entry.scheduledTime.split(':')[1]);

                // These break conditions apply only after the very first stop (i > 0)
                if (i > 0) {
                    // Condition 1: Time regresses (e.g., next day's service, or data error)
                    if (currentStopTimeInAbsoluteMinutes < previousStopTimeInAbsoluteMinutes) {
                        break; // End of the current trip's sequence
                    }
                    // Condition 2: Encountered the starting stop ID again *after* a few other stops
                    if (entry.stopID === firstStopIDOfThisJourneyPattern &&
                        sequenceForThisProfileTrip.length >= MIN_STOPS_BEFORE_FIRST_ID_REVISIT_BREAK) {
                        break; // Assumed start of the next iteration of this trip pattern
                    }
                }

                sequenceForThisProfileTrip.push({
                    stopID: entry.stopID,
                    name: entry.stopName || entry.stopID,
                    direction: entry.direction || 'N/A'
                });
                previousStopTimeInAbsoluteMinutes = currentStopTimeInAbsoluteMinutes;
            }
        }

        if (sequenceForThisProfileTrip.length > 0) {
            const sequenceSignature = sequenceForThisProfileTrip.map(s => s.stopID).join('->');
            if (!sequencesMap.has(sequenceSignature)) {
                sequencesMap.set(sequenceSignature, {
                    sequence: sequenceForThisProfileTrip,
                    profiles: new Set()
                });
            }
            sequencesMap.get(sequenceSignature).profiles.add(opProfile);
        }
    } // End opProfile loop
    return sequencesMap;
}

function populateStopSelectorForDeparturesView_ExtraPage() {
    // This function now uses the global constants defined above
    if (!selectStopForDeparturesView_extra) {
        console.error("View Departures: Stop selector element not found.");
        return;
    }
    
    const currentVal = selectStopForDeparturesView_extra.value;
    selectStopForDeparturesView_extra.innerHTML = '<option value="">-- Select Stop --</option>';

    if (currentWorkingSchedule_extra.length === 0) {
        selectStopForDeparturesView_extra.innerHTML = '<option value="">-- No Stops Loaded --</option>';
        return;
    }

    const stopsMap = new Map();
    // Iterates over the globally available schedule data
    currentWorkingSchedule_extra.forEach(e => {
        if (e.stopID && !stopsMap.has(e.stopID.toUpperCase())) {
            stopsMap.set(e.stopID.toUpperCase(), { stopID: e.stopID, stopName: e.stopName || e.stopID });
        }
    });
    
    const sortedStops = Array.from(stopsMap.values()).sort((a,b) => (a.stopName || "").toLowerCase().localeCompare((b.stopName || "").toLowerCase()));

    sortedStops.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s.stopID;
        opt.textContent = `${s.stopName} (${s.stopID})`;
        selectStopForDeparturesView_extra.appendChild(opt);
    });

    if (stopsMap.has(currentVal.toUpperCase())) {
        selectStopForDeparturesView_extra.value = currentVal;
    }
}

function displayDeparturesForSelectedStop_ExtraPage() {
    const selectEl = document.getElementById('selectStopForDeparturesView_extra');
    const listEl = document.getElementById('stopDeparturesList_extra');
    const noDeparturesMsg = document.getElementById('noDeparturesForStopMessage_extra');

    if (!selectEl || !listEl || !noDeparturesMsg) return;
    
    const selectedStopID = selectEl.value;
    listEl.innerHTML = '';

    if (!selectedStopID) {
        noDeparturesMsg.textContent = 'Select a stop to view its scheduled departures.';
        noDeparturesMsg.style.display = 'block';
        return;
    }

    const todaysActiveProfiles = getOperatingCodesForDate_ExtraPage(new Date());

    const departures = currentWorkingSchedule_extra
        .filter(e => {
            if (e.stopID !== selectedStopID || !e.scheduledTime) {
                return false;
            }
            const departureProfiles = e.OperatingProfile.split(',').map(p => p.trim());
            return departureProfiles.some(dp => todaysActiveProfiles.includes(dp));
        })
        .sort((a, b) => {
            // --- NEW: Simplified sort by time on the clock, ignoring DayOffset ---

            // Level 1: Time of Day
            const timeA = (a.scheduledTime || "99:99").replace(':', '');
            const timeB = (b.scheduledTime || "99:99").replace(':', '');
            if (timeA !== timeB) return timeA.localeCompare(timeB);

            // Level 2: Route Name (as a tie-breaker)
            const routeCompare = compareLineNames_ExtraPage(a.lineName, b.lineName);
            if (routeCompare !== 0) return routeCompare;

            // Level 3: Destination Name (as a final tie-breaker)
            return (a.destinationName || "").localeCompare(b.destinationName || "");
        });


    if (departures.length === 0) {
        noDeparturesMsg.textContent = 'No scheduled departures found for this stop today.';
        noDeparturesMsg.style.display = 'block';
    } else {
        noDeparturesMsg.style.display = 'none';
        departures.forEach(d => {
            const li = document.createElement('li');
            const tile = document.createElement('span');
            tile.className = 'route-tile-tools-list';
            tile.textContent = d.lineName || 'N/A';
            const bgColor = getRouteTileColour_ExtraPage(d.lineName, selectedStopID);
            tile.style.backgroundColor = bgColor;
            tile.style.color = getTextColourForBackground_ExtraPage(bgColor);

            const span = document.createElement('span');
            span.style.marginLeft = '0.5em';
            span.innerHTML = `to ${d.destinationName || 'Unknown'} <strong style="margin-left:0.5em;">at ${d.scheduledTime}</strong> <small style="opacity:0.7;margin-left:0.75em;">(P: ${d.OperatingProfile || 'N/A'})</small>${d.DayOffset && d.DayOffset !== "0" ? `<small style="opacity:0.7;margin-left:0.3em;color:#FFD700;">(+${d.DayOffset}d)</small>`: ''}`;
            
            li.appendChild(tile);
            li.appendChild(span);
            listEl.appendChild(li);
        });
    }
}

</script>
</body>
</html>
