<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMSI Countdown - Tools</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        @font-face {
            font-family: 'NJFont Medium Web';
            src: url('fonts/NJFont-Medium.ttf') format('truetype');
            font-weight: normal;font-style: normal;font-display: swap;
        }
        body {
            font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            margin:0;
        }
        .page-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }
        .tool-content {
            display: none;
        }
        h1 { font-size: 2rem; margin-bottom: 1.5rem; font-weight: normal; text-align: center; color: #ffffff; }
        h2 { font-size: 1.5rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: normal; border-bottom: 1px solid #7f8c8d; padding-bottom: 0.25rem;}

        .section {
            background-color: rgba(0,0,0,0.15);
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #current-profile-display-container { text-align: center; margin-bottom: 1.5rem; padding: 0.5rem; background-color: rgba(255,255,255,0.05); border-radius: 0.25rem;}
        #current-profile-display { font-size: 0.9rem; opacity: 0.9; font-style: italic;}

        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;}
        .form-section div { margin-bottom: 0.75rem; }

        label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.85rem;
            color: #bdc3c7;
        }

        input[type="text"],
        input[type="email"],
        input[type="password"],
        input[type="time"],
        input[type="color"],
        select {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size:0.9rem;
        }
        input[type="color"] { height: 2.75rem; padding: 0.25rem; }
        #inputOperatingProfile { max-width: 100%;}
        #selectDayOffset, #selectRouteNameColour, #selectStopForDeparturesView { max-width: 100%; }
        #selectDayOffset option, #selectRouteNameColour option, #selectStopForDeparturesView option { background-color: #34495e; color: #ecf0f1; }


        #inputStopID, #inputLineName, #bulkEditTargetStopID, #bulkEditTargetLineName {
            text-transform: uppercase;
        }

        .button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin-right: 0.5rem; margin-top:0.5rem;
        }
        .button:hover { background-color: #2980b9; }
        .button.small-action { padding: 0.2rem 0.4rem; font-size: 0.9rem; margin: 0 0.15rem; line-height: 1; min-width: 20px; text-align:center;}
        .button.secondary { background-color: #e74c3c; }
        .button.secondary:hover { background-color: #c0392b; }
        .button.tertiary { background-color: #f39c12; }
        .button.tertiary:hover { background-color: #e67e22; }
        .button.neutral { background-color: #7f8c8d; }
        .button.neutral:hover { background-color: #95a5a6; color: #2c3e50; }


        .file-upload-label { display: inline-block; cursor: pointer; background-color: #95a5a6; color: #2c3e50; padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem; transition: background-color 0.2s; margin-bottom: 0.5rem; }
        .file-upload-label:hover { background-color: #7f8c8d; }
        #file-status { font-size: 0.9rem; margin-top: 0.25rem; margin-bottom:1rem; opacity: 0.9; min-height: 1.2em; }

        #currentScheduleTableContainer {
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid #7f8c8d;
            margin-top: 0.5rem;
            border-radius: 0.25rem;
        }
        table { width: 100%; border-collapse: collapse; font-size: 0.8rem;}
        th, td {
            padding: 0.4rem 0.5rem;
            text-align: left;
            border-bottom: 1px solid #34495e;
            white-space: nowrap;
        }
        th { background-color: rgba(0,0,0,0.2); font-weight: normal; color: #bdc3c7; cursor: pointer; user-select:none;}
        th:hover { background-color: rgba(0,0,0,0.3); }
        th .sort-arrow { margin-left: 5px; font-size: 0.7em; display:inline-block; width:10px; }

        .actions-section { margin-top: 1.5rem; }
        #stageScheduleButton { background-color: #27ae60; }
        #stagingStatusMessage { text-align:center; margin-bottom: 1rem; font-size: 0.9em; color: #f1c40f; min-height:1.2em; }


        .info-section { margin-top:2rem; padding:1rem; background-color: rgba(0,0,0,0.1); border-radius:0.25rem; font-size:0.8rem; }
        .info-section h3 { font-size:1rem; margin-bottom:0.5rem; color: #ffffff; }
        .info-section p { line-height:1.6; color:#bdc3c7; }

        .tooltip { position: relative; display: inline-block; cursor: help; margin-left: 4px; font-size:0.8em; background-color:#7f8c8d; color:white; border-radius:50%; width:14px; height:14px; text-align:center; line-height:14px;}
        .tooltip .tooltiptext {
            visibility: hidden; width: 280px; background-color: #34495e; color: #fff;
            text-align: left; border-radius: 6px; padding: 8px; position: absolute;
            z-index: 10; bottom: 135%; left: 50%; margin-left: -140px; opacity: 0; transition: opacity 0.3s;
            font-size: 0.75rem; line-height: 1.4; border: 1px solid #7f8c8d;
        }
        .tooltip .tooltiptext::after {
            content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px;
            border-width: 5px; border-style: solid; border-color: #34495e transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .filter-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; margin-bottom: 1rem; align-items: end;}
        .filter-controls div { margin-bottom: 0; }
        .filter-controls input[type="text"] { margin-bottom:0; }
        .filter-controls button { margin-top:0; }

        .current-details-display {
            margin-top: 0.5rem;
            font-size: 0.85em;
            background-color: rgba(0,0,0,0.2);
            padding: 0.5rem;
            border-radius: 0.25rem;
            color: #bdc3c7;
        }
        .current-details-display p { margin: 0.2rem 0; }
        .current-details-display span { font-style: italic; color: #ecf0f1; }

        .event-section div, .stop-status-section div, .route-colour-management div, .view-stop-departures div {
            margin-bottom: 0.75rem;
        }
        .event-section label, .stop-status-section label, .route-colour-management label, .view-stop-departures label {
             margin-bottom: 0.25rem;
        }

        #currentRouteColoursListContainer {
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            padding: 0.75rem;
            margin-top: 1rem;
            max-height: 200px;
            overflow-y: auto;
        }
        #currentRouteColoursList li {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #currentRouteColoursList li:last-child { border-bottom: none; }
        .colour-preview-box {
            width: 20px;
            height: 20px;
            border: 1px solid #ecf0f1;
            margin-right: 10px;
            display: inline-block;
            vertical-align: middle;
        }
        #currentRouteColoursList .route-info { flex-grow: 1; }

        .route-tile-tools-list {
            display: inline-block;
            padding: 0.2em 0.55em;
            margin-right: 0.6em;
            border-radius: 0.25rem;
            font-size: 0.8em;
            font-weight: bold;
            color: white;
            text-align: center;
            line-height: 1.3;
            min-width: 28px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.25);
            vertical-align: middle;
        }
        #stopDeparturesList li {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.1rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #stopDeparturesList li:last-child {
            border-bottom: none;
        }

    </style>
</head>
<body lang="en-GB">
    <div class="page-container">
        <h1>Bus Schedule Setup & Management</h1>

        <div id="auth-section" class="section">
            <h2>Admin Login</h2>
            <div id="login-form-container">
                <form id="adminLoginForm">
                    <div class="form-grid" style="grid-template-columns: 1fr;">
                        <div><label for="inputEmail">Email</label><input type="email" id="inputEmail" autocomplete="email"></div>
                        <div><label for="inputPassword">Password</label><input type="password" id="inputPassword" autocomplete="current-password"></div>
                    </div>
                    <button id="loginButton" type="submit" class="button">Login</button>
                </form>
                <p id="auth-status" style="margin-top: 0.5em; color: #f1c40f;"></p>
            </div>
            <div id="logout-container" style="display:none;"> <p>Logged in as: <span id="loggedInUserEmail"></span></p> <button id="logoutButton" class="button secondary">Logout</button>
            </div>
        </div>

        <div id="main-tool-content" style="display:none;">

            <div id="current-profile-display-container" class="section">
                <p id="current-profile-display">Today's Auto Profile: (determining...)</p>
            </div>

            <div class="section manual-entry-form">
                <h2>Add / Edit Schedule Entry</h2>
                <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;"><em>Entries added or modified here are part of the working schedule. Use actions below to stage it for automated update or apply it live immediately.</em></p>
                <input type="hidden" id="editingEntryIndex" value="-1">
                <div class="form-grid">
                    <div><label for="inputStopID">Stop ID</label><input type="text" id="inputStopID" autocomplete="off"></div>
                    <div><label for="inputStopName">Stop Name</label><input type="text" id="inputStopName" autocomplete="off"></div>
                    <div><label for="inputDirection">Direction</label><input type="text" id="inputDirection" autocomplete="off"></div>
                    <div><label for="inputLineName">Line Name</label><input type="text" id="inputLineName" autocomplete="off"></div>
                    <div><label for="inputDestinationName">Destination Name</label><input type="text" id="inputDestinationName" autocomplete="off"></div>
                    <div><label for="inputScheduledTime">Scheduled Time (HH:MM)</label><input type="time" id="inputScheduledTime" autocomplete="off"></div>
                </div>
                <div>
                    <label for="inputOperatingProfile">Operating Profile(s)
                        <span class="tooltip">?
                            <span class="tooltiptext">
                                Enter comma-separated codes. Valid codes include: <br>
                                <strong>Days:</strong> Mo, Tu, We, Th, Fr, Sa, Su <br>
                                <strong>Weekday Grps:</strong> Mo-Fr <br>
                                <strong>School Status (Combine):</strong> Sch (School Day), NSD (Non-School Day/Hol). <br>
                                <em>e.g., MoSch, TuNSD, MFSch, MFNSD</em> <br>
                                <strong>Special Days:</strong> GoodFriday, BankHoliday, XmasDay, BoxingDay, NewYearsDay, SchoolHoliday (general) <br>
                                <strong>Example usage:</strong> Sa,Su,BankHoliday
                            </span>
                        </span>
                    </label>
                    <input type="text" id="inputOperatingProfile" placeholder="e.g., MoSch,TuSch or Sa,BankHoliday" autocomplete="off">
                </div>
                <div>
                    <label for="selectDayOffset">Day Offset (for overnight services)</label>
                    <select id="selectDayOffset">
                        <option value="0">0 (Same Day)</option>
                        <option value="1">1 (Next Day)</option>
                    </select>
                </div>
                <div style="margin-top:1rem;">
                    <button id="addEntryButton" class="button">Add Entry</button>
                    <button id="updateEntryButton" class="button tertiary" style="display:none;">Update Entry</button>
                    <button id="cancelEditButton" class="button secondary" style="display:none;">Cancel Edit</button>
                </div>
            </div>

            <div class="section bulk-edit-stop-details-section">
                <h2>Update Stop Name & Direction by Stop ID (in current working schedule)</h2>
                <div class="form-grid" style="grid-template-columns: 1fr; gap: 0.75rem;">
                    <div><label for="bulkEditTargetStopID">Target Stop ID to Update</label><input type="text" id="bulkEditTargetStopID" placeholder="Enter Stop ID (case-insensitive)" autocomplete="off"></div>
                    <div class="current-details-display"><p><strong>Current Name:</strong> <span id="currentBulkEditStopNameDisplay">- Enter Stop ID above -</span></p><p><strong>Current Direction:</strong> <span id="currentBulkEditDirectionDisplay">- Enter Stop ID above -</span></p></div>
                    <div><label for="bulkEditNewStopName">New Stop Name (leave blank to keep current)</label><input type="text" id="bulkEditNewStopName" placeholder="Enter new stop name" autocomplete="off"></div>
                    <div><label for="bulkEditNewDirection">New "Towards" Text (leave blank to keep current)</label><input type="text" id="bulkEditNewDirection" placeholder="Enter new direction text" autocomplete="off"></div>
                    <div style="margin-top: 0.5rem;"><button id="bulkUpdateDetailsButton" class="button" style="width:auto;">Update These Stop Details</button></div>
                </div>
            </div>
            <div class="section bulk-edit-route-destination">
                <h2>Update Destination for a Route (in current working schedule)</h2>
                <div class="form-grid" style="grid-template-columns: 1fr 1.5fr 1.5fr auto; align-items:end; gap: 0.75rem;">
                    <div><label for="bulkEditTargetLineName">Target Line Name</label><input type="text" id="bulkEditTargetLineName" placeholder="e.g., 186" autocomplete="off"></div>
                    <div><label for="bulkEditOldDestination">Old Destination (optional)</label><input type="text" id="bulkEditOldDestination" placeholder="Leave blank to update all" autocomplete="off"></div>
                    <div><label for="bulkEditNewDestination">New Destination Name</label><input type="text" id="bulkEditNewDestination" placeholder="Enter new destination" autocomplete="off"></div>
                    <div style="padding-bottom:0.05rem;"><button id="bulkUpdateRouteDestinationButton" class="button" style="width:100%;">Update Destination</button></div>
                </div>
            </div>
            <div class="section random-event-generator">
                <h2>Random Event Generator (affects current working schedule)</h2>
                <div class="form-grid event-section" style="grid-template-columns: 1.5fr 1.5fr auto; align-items:end;">
                    <div><label for="selectEventRoute">Select Route (Line Name):</label><select id="selectEventRoute"><option value="">-- Select a Route --</option></select></div>
                    <div><label for="selectEventImpactStop">Impact from Stop (Optional):</label><select id="selectEventImpactStop"><option value="">-- Route Wide / First Stop --</option></select></div>
                    <div style="padding-bottom:0.05rem;"><button id="triggerEventButton" class="button tertiary" style="width:100%;">Trigger Random Event</button></div>
                </div>
                <p id="eventStatusMessage" style="font-size:0.9rem; margin-top:0.5rem; min-height:1.2em; color: #f1c40f;"></p>
            </div>
            <div class="section stop-status-section">
                <h2>Manage Bus Stop Status (Live Effect)</h2>
                <div class="form-grid stop-status-section" style="grid-template-columns: 2fr auto auto; align-items:end;">
                    <div><label for="selectStopForStatusChange">Select Stop:</label><select id="selectStopForStatusChange"><option value="">-- Select a Stop --</option></select></div>
                    <div style="padding-bottom:0.05rem;"><button id="closeStopButton" class="button secondary" style="width:100%;">Close Stop</button></div>
                    <div style="padding-bottom:0.05rem;"><button id="reopenStopButton" class="button" style="background-color: #2ecc71; width:100%;">Reopen Stop</button></div>
                </div>
                <p id="stopStatusMessage" style="font-size:0.9rem; margin-top:0.5rem; min-height:1.2em; color: #f1c40f;"></p>
            </div>

            <div class="section route-colour-management">
                <h2>Route Tile Colour Management</h2>
                <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">Define custom colours for specific routes. These will override default colours on the arrivals board. Select a route from the dropdown (populated from your current working schedule).</p>
                <div class="form-grid" style="grid-template-columns: 1.5fr 1fr auto; align-items: end; gap: 0.75rem;">
                    <div><label for="selectRouteNameColour">Route Name</label><select id="selectRouteNameColour"><option value="">-- Select a Route --</option></select></div>
                    <div><label for="inputRouteColour">Select Colour</label><input type="color" id="inputRouteColour" value="#73809C" autocomplete="off"></div>
                    <div style="padding-bottom:0.05rem;"><button id="saveRouteColourButton" class="button" style="width:100%;">Save Colour</button></div>
                </div>
                <div id="currentRouteColoursListContainer"><h3 style="font-size: 1.1rem; margin-bottom: 0.5rem; color: #ecf0f1;">Current Route Colours</h3><ul id="currentRouteColoursList" style="list-style: none; padding: 0;"></ul><p id="noCustomColoursMessage" style="font-style: italic; opacity: 0.7; text-align:center; padding: 0.5rem 0;">No routes in working schedule to assign colours to.</p></div>
                <p id="routeColourStatusMessage" style="font-size:0.9rem; margin-top:0.75rem; min-height:1.2em; color: #f1c40f;"></p>
            </div>
            <div class="section view-stop-departures">
                <h2>View Scheduled Departures by Stop (from Working Schedule)</h2>
                <div class="form-grid" style="grid-template-columns: 1fr 2fr; align-items: start; gap: 1.5rem;">
                    <div><label for="selectStopForDeparturesView">Select Bus Stop:</label><select id="selectStopForDeparturesView"><option value="">-- Select a Stop --</option></select></div>
                    <div><label>Scheduled Departures:</label><div id="stopDeparturesListContainer" style="max-height: 350px; overflow-y: auto; border: 1px solid #4A5568; border-radius: 0.25rem; padding: 0.75rem; background-color: rgba(0,0,0,0.05);"><ul id="stopDeparturesList" style="list-style: none; padding: 0;"></ul><p id="noDeparturesForStopMessage" style="text-align: center; padding: 1rem; font-style: italic; opacity: 0.7;">Select a stop to view its scheduled departures.</p></div></div>
                </div>
            </div>
            <div class="section schedule-display">
                <h2>Current Working Schedule (<span id="entryCount">0</span> entries)</h2>
                <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.5rem;"><em>This table shows the schedule you are currently preparing. Use actions below to make it live.</em></p>
                <div class="filter-controls">
                    <div><label for="filterStopID">Filter Stop ID:</label><input type="text" id="filterStopID" placeholder="e.g. EDGWHLS" autocomplete="off"></div>
                    <div><label for="filterLineName">Filter Line:</label><input type="text" id="filterLineName" placeholder="e.g. 186" autocomplete="off"></div>
                    <div><label for="filterOperatingProfile">Filter Profile:</label><input type="text" id="filterOperatingProfile" placeholder="e.g. MoSch" autocomplete="off"></div>
                    <div><label>&nbsp;</label><button id="clearFiltersButton" class="button neutral" style="width:100%; padding:0.5rem;">Clear Filters</button></div>
                </div>
                <div id="currentScheduleTableContainer"><table><thead><tr><th data-sortkey="stopID">Stop ID <span class="sort-arrow"></span></th><th data-sortkey="stopName">Stop Name <span class="sort-arrow"></span></th><th data-sortkey="direction">Direction <span class="sort-arrow"></span></th><th data-sortkey="lineName">Line <span class="sort-arrow"></span></th><th data-sortkey="destinationName">Destination <span class="sort-arrow"></span></th><th data-sortkey="scheduledTime">Time <span class="sort-arrow"></span></th><th data-sortkey="OperatingProfile">Profile(s) <span class="sort-arrow"></span></th><th data-sortkey="DayOffset">Offset <span class="sort-arrow"></span></th><th style="width:100px;">Actions</th></tr></thead><tbody id="currentScheduleTableBody"></tbody></table></div>
            </div>
            <div class="section count-file-upload">
                <h2>Upload Full Schedule (replaces current working schedule)</h2>
                <p style="font-size:0.8em; margin-bottom:0.5em;"><em>Note: Uploading a .COUNT file will replace all entries in the "Current Working Schedule" table above.</em></p>
                <label for="count-file-input" class="file-upload-label">Choose .COUNT File</label>
                <input type="file" id="count-file-input" accept=".COUNT,.txt" style="display: none;">
                <p id="file-status">No file selected.</p>
            </div>
            <div class="actions-section section">
                <h2>Schedule Deployment</h2>
                <div id="stagingStatusMessage" style="text-align:center; margin-bottom: 1rem; font-size: 0.9em; color: #f1c40f;">Checking status...</div>
                <button id="stageScheduleButton" class="button">Stage Current Working Schedule for Update</button>
                <button id="applyNowButton" class="button tertiary" style="margin-left: 0.5rem;">Apply Staged Schedule Live NOW</button>
                <hr style="margin: 1.5rem 0; border-color: rgba(255,255,255,0.1);">
                <button id="viewArrivalsButton" class="button" style="margin-left: 0.5rem;">View Arrivals Board</button>
            </div>

        </div> </div> <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      // THIS IS YOUR ACTUAL FIREBASE CONFIGURATION
      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s",
        authDomain: "omsi-c5505.firebaseapp.com",
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "omsi-c5505",
        storageBucket: "omsi-c5505.appspot.com", 
        messagingSenderId: "503595375440",
        appId: "1:503595375440:web:356be6684b77ff5909ea55",
        measurementId: "G-VN7X65V3F9"
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);

      window.firebaseOMSI = {
          database: database,
          auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut
      };
      console.log("Firebase Initialized for OMSI Tools (with Auth).");
    </script>

    <script>
        // --- Global Variables & DOM Elements ---
        const inputStopID = document.getElementById('inputStopID');
        const inputStopName = document.getElementById('inputStopName');
        const inputDirection = document.getElementById('inputDirection');
        const inputLineName = document.getElementById('inputLineName');
        const inputDestinationName = document.getElementById('inputDestinationName');
        const inputScheduledTime = document.getElementById('inputScheduledTime');
        const inputOperatingProfile = document.getElementById('inputOperatingProfile');
        const selectDayOffset = document.getElementById('selectDayOffset');
        const addEntryButton = document.getElementById('addEntryButton');
        const updateEntryButton = document.getElementById('updateEntryButton');
        const cancelEditButton = document.getElementById('cancelEditButton');
        const editingEntryIndexInput = document.getElementById('editingEntryIndex');
        const countFileInput = document.getElementById('count-file-input');
        const fileStatusElement = document.getElementById('file-status');
        const currentProfileDisplayElement = document.getElementById('current-profile-display');
        const currentScheduleTableBody = document.getElementById('currentScheduleTableBody');
        const entryCountElement = document.getElementById('entryCount');
        const filterStopIDInput = document.getElementById('filterStopID');
        const filterLineNameInput = document.getElementById('filterLineName');
        const filterOperatingProfileInput = document.getElementById('filterOperatingProfile');
        const clearFiltersButton = document.getElementById('clearFiltersButton');
        const bulkEditTargetStopIDInput = document.getElementById('bulkEditTargetStopID');
        const currentBulkEditStopNameDisplay = document.getElementById('currentBulkEditStopNameDisplay');
        const currentBulkEditDirectionDisplay = document.getElementById('currentBulkEditDirectionDisplay');
        const bulkEditNewStopNameInput = document.getElementById('bulkEditNewStopName');
        const bulkEditNewDirectionInput = document.getElementById('bulkEditNewDirection');
        const bulkUpdateDetailsButton = document.getElementById('bulkUpdateDetailsButton');
        const bulkEditTargetLineNameInput = document.getElementById('bulkEditTargetLineName');
        const bulkEditOldDestinationInput = document.getElementById('bulkEditOldDestination');
        const bulkEditNewDestinationInput = document.getElementById('bulkEditNewDestination');
        const bulkUpdateRouteDestinationButton = document.getElementById('bulkUpdateRouteDestinationButton');
        const selectEventRoute = document.getElementById('selectEventRoute');
        const selectEventImpactStop = document.getElementById('selectEventImpactStop');
        const triggerEventButton = document.getElementById('triggerEventButton');
        const eventStatusMessage = document.getElementById('eventStatusMessage');
        const selectStopForStatusChange = document.getElementById('selectStopForStatusChange');
        const closeStopButton = document.getElementById('closeStopButton');
        const reopenStopButton = document.getElementById('reopenStopButton');
        const stopStatusMessage = document.getElementById('stopStatusMessage');
        const stageScheduleButton = document.getElementById('stageScheduleButton');
        const applyNowButton = document.getElementById('applyNowButton');
        const viewArrivalsButton = document.getElementById('viewArrivalsButton');
        const stagingStatusMessage = document.getElementById('stagingStatusMessage');
        const selectRouteNameColour = document.getElementById('selectRouteNameColour');
        const inputRouteColour = document.getElementById('inputRouteColour');
        const saveRouteColourButton = document.getElementById('saveRouteColourButton');
        const currentRouteColoursList = document.getElementById('currentRouteColoursList');
        const noCustomColoursMessage = document.getElementById('noCustomColoursMessage');
        const routeColourStatusMessage = document.getElementById('routeColourStatusMessage');
        const selectStopForDeparturesView = document.getElementById('selectStopForDeparturesView');
        const stopDeparturesList = document.getElementById('stopDeparturesList');
        const noDeparturesForStopMessage = document.getElementById('noDeparturesForStopMessage');
        
        const mainToolContentDiv = document.getElementById('main-tool-content');
        const loginFormContainer = document.getElementById('login-form-container');
        const logoutContainer = document.getElementById('logout-container');
        const loginButton = document.getElementById('loginButton');
        const logoutButton = document.getElementById('logoutButton');
        const inputEmail = document.getElementById('inputEmail');
        const inputPassword = document.getElementById('inputPassword');
        const authStatus = document.getElementById('auth-status');
        const loggedInUserEmailDisplay = document.getElementById('loggedInUserEmail');

        // const inputServiceMessage = document.getElementById('inputServiceMessage'); // Removed
        // const setServiceMessageButton = document.getElementById('setServiceMessageButton'); // Removed
        // const serviceMessageStatus = document.getElementById('serviceMessageStatus'); // Removed
        // const currentLiveServiceMessageDisplay = document.getElementById('currentLiveServiceMessageDisplay'); // Removed


        let currentUser = null; 
        let currentWorkingSchedule = [];
        let ukBankHolidaysData = { dates: [], titles: {} };
        const schoolHolidayDateRanges = [ ]; 
        let activeFilters = { stopID: '', lineName: '', operatingProfile: '' };
        let sortConfig = { key: null, direction: 'asc' };
        let closedStopIDs = [];
        let customRouteColours = {};
        let effectiveRouteColourMapTools = {};

        const eventTypes = [ 
            { name: "Delay Route (5-15 min)", type: "DELAY_ROUTE", minDelay: 5, maxDelay: 15 },
            { name: "Delay From Stop (3-10 min)", type: "DELAY_FROM_STOP", minDelay: 3, maxDelay: 10 },
            { name: "Curtail Service", type: "CURTAIL" }
        ];
        const FB_PATH_LIVE_SCHEDULE_DATA = '/liveSchedule/allScheduledBusData';
        const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
        const FB_PATH_PENDING_SCHEDULE_DATA = '/pendingSchedule/allScheduledBusData';
        const FB_PATH_PENDING_UNIQUE_STOPS = '/pendingSchedule/uniqueBusStops';
        const FB_PATH_PENDING_TIMESTAMP = '/pendingSchedule/uploadTimestamp';
        const FB_PATH_APPSTATE_STATUS = '/appState/scheduleStatus';
        const FB_PATH_APPSTATE_LAST_UPDATED = '/appState/scheduleLastUpdated';
        const FB_PATH_APPSTATE_CLOSED_STOPS = '/appState/closedStopIDs';
        const FB_PATH_SETTINGS_CUSTOM_COLOURS = '/settings/customRouteColours';
        // const FB_PATH_APPSTATE_SERVICE_MESSAGE = '/appState/serviceMessage';  // Removed
        const CUSTOM_ROUTE_COLOURS_KEY = 'omsiCustomRouteTileColours';

        const initialRouteColourMapForTools = { 
            "1": "#DC2626", "2": "#DC2626", "3": "#DC2626", "4": "#00783A", "5": "#00783A", "6": "#00783A",
            "7": "#FFD300", "8": "#FFD300", "9": "#FFD300", "10": "#970006", "11": "#76D0BD", "12": "#F3A9BB",
            "186": "#E32017", "32":  "#00A4A7", "N5":  "#0019A8", "C11": "#FFD300","107": "#76D0BD",
            "221": "#93002F", "240": "#C9A0DC", "251": "#F8A960","303": "#868F98", "305": "#CF7EA2",
            "SL1": "#5F259F", "SL10": "#A05A2C"
        };
        const DEFAULT_ROUTE_COLOUR_TOOLS = "#73809C";

        function updateAuthUI(user) {
            currentUser = user;
            if (user) {
                if (loginFormContainer) loginFormContainer.style.display = 'none';
                if (logoutContainer) logoutContainer.style.display = 'block';
                if (authStatus) authStatus.textContent = '';
                if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = user.email;
                if (mainToolContentDiv) mainToolContentDiv.style.display = 'block';
            } else {
                if (loginFormContainer) loginFormContainer.style.display = 'block';
                if (logoutContainer) logoutContainer.style.display = 'none';
                if (authStatus) authStatus.textContent = 'Please log in to use the tools.';
                if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = '';
                if (mainToolContentDiv) mainToolContentDiv.style.display = 'none';
                // if(currentLiveServiceMessageDisplay) currentLiveServiceMessageDisplay.textContent = "- Login to manage -"; // Removed
            }
        }

        function parseLineName(lineNameStr) { const name = String(lineNameStr || "").toUpperCase().trim(); const numericPrefixRegex = new RegExp(/^(\d+)([A-Z]*)$/); const alphaNumericRegex = new RegExp(/^([A-Z]+)(\d+)?([A-Z]*)$/); const numericPrefixMatch = name.match(numericPrefixRegex); if (numericPrefixMatch) return { type: 'numeric', number: parseInt(numericPrefixMatch[1], 10), suffix: numericPrefixMatch[2] || '', original: name }; const alphaNumericMatch = name.match(alphaNumericRegex); if (alphaNumericMatch) return { type: 'alpha', prefix: alphaNumericMatch[1], number: alphaNumericMatch[2] ? parseInt(alphaNumericMatch[2], 10) : null, suffix: alphaNumericMatch[3] || '', original: name }; return { type: 'other', original: name }; }
        function compareLineNames(lineAStr, lineBStr) { const parsedA = parseLineName(lineAStr); const parsedB = parseLineName(lineBStr); if (parsedA.type === 'numeric' && parsedB.type === 'alpha') return -1; if (parsedA.type === 'alpha' && parsedB.type === 'numeric') return 1; if (parsedA.type === 'numeric' && parsedB.type === 'numeric') { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type === 'alpha' && parsedB.type === 'alpha') { const prefixCompare = parsedA.prefix.localeCompare(parsedB.prefix); if (prefixCompare !== 0) return prefixCompare; if (parsedA.number === null && parsedB.number !== null) return -1; if (parsedA.number !== null && parsedB.number === null) return 1; if (parsedA.number !== null && parsedB.number !== null) { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; } return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type !== 'other' && parsedB.type === 'other') return -1; if (parsedA.type === 'other' && parsedB.type !== 'other') return 1; return (parsedA.original || "").localeCompare(parsedB.original || ""); }
        async function fetchBankHolidaysForSetup() { try { const response = await fetch('https://www.gov.uk/bank-holidays.json'); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); if (data['england-and-wales'] && data['england-and-wales'].events) { const events = data['england-and-wales'].events; ukBankHolidaysData = { dates: events.map(event => event.date), titles: events.reduce((acc, event) => { acc[event.date] = event.title; return acc; }, {}) }; } else { console.warn("Setup: Bank holiday data not in expected format."); } } catch (error) { console.error("Setup: Failed to fetch UK bank holidays:", error); if(currentProfileDisplayElement) currentProfileDisplayElement.textContent = "Current Auto Profile: (Bank Hol. check failed)"; } updateCurrentProfileDisplayOnSetup(); }
        function isSchoolHolidayPeriodForSetup(dateObject) { if (!schoolHolidayDateRanges || schoolHolidayDateRanges.length === 0) return false; const checkTime = dateObject.getTime(); for (const range of schoolHolidayDateRanges) { try { const startTime = new Date(range.start + "T00:00:00").getTime(); const endTime = new Date(range.end + "T23:59:59").getTime(); if (checkTime >= startTime && checkTime <= endTime) return true; } catch (e) { console.error("Invalid date in schoolHolidayDateRanges (setup):", range, e); } } return false; }
        function updateCurrentProfileDisplayOnSetup() { const now = new Date(); const dayOfWeek = now.getDay(); const todayDateString = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`; let profileDisplayText = ""; let isBankHol = false; let serviceTypeDisplay = ""; if (ukBankHolidaysData && ukBankHolidaysData.dates.includes(todayDateString)) { const holidayTitle = ukBankHolidaysData.titles[todayDateString] || "Bank Holiday"; isBankHol = true; if (holidayTitle.toLowerCase().includes("good friday")) { profileDisplayText = "Good Friday"; serviceTypeDisplay = "(Sat Service)"; } else { profileDisplayText = holidayTitle; serviceTypeDisplay = "(Sun Service)"; } } let dayName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][dayOfWeek]; if (!isBankHol) { profileDisplayText = dayName; const isSchHol = isSchoolHolidayPeriodForSetup(now); if (isSchHol) { profileDisplayText += " (School Hol)"; } else if (dayOfWeek >= 1 && dayOfWeek <= 5) { profileDisplayText += " (School Term)"; } } else { profileDisplayText += ` ${serviceTypeDisplay} - Observed on a ${dayName}`; const isSchHolOnBH = isSchoolHolidayPeriodForSetup(now); if (isSchHolOnBH) { profileDisplayText += " (School Hol)"; } } if (currentProfileDisplayElement) { currentProfileDisplayElement.textContent = `Today's Auto Profile: ${profileDisplayText}`; } }
        function applyFiltersAndSort(schedule) { let dataToDisplay = [...schedule]; if (activeFilters.stopID) dataToDisplay = dataToDisplay.filter(e=>(e.stopID||"").toLowerCase().includes(activeFilters.stopID.toLowerCase())); if (activeFilters.lineName) dataToDisplay = dataToDisplay.filter(e=>(e.lineName||"").toLowerCase().includes(activeFilters.lineName.toLowerCase())); if (activeFilters.operatingProfile) dataToDisplay = dataToDisplay.filter(e=>(e.OperatingProfile||"").toLowerCase().includes(activeFilters.operatingProfile.toLowerCase())); if (sortConfig.key) { dataToDisplay.sort((a,b) => { let valA=a[sortConfig.key]||"", valB=b[sortConfig.key]||""; if(sortConfig.key==='scheduledTime'){valA=(String(valA)||"").replace(':','');valB=(String(valB)||"").replace(':','');} else if(sortConfig.key==='lineName')return compareLineNames(valA,valB)*(sortConfig.direction==='asc'?1:-1); else if(sortConfig.key==='DayOffset'){valA=parseInt(valA||"0");valB=parseInt(valB||"0");} else if(typeof valA==='string'&&typeof valB==='string'){valA=valA.toLowerCase();valB=valB.toLowerCase();} if(valA<valB)return sortConfig.direction==='asc'?-1:1; if(valA>valB)return sortConfig.direction==='asc'?1:-1; return 0; }); } else { dataToDisplay.sort((a,b)=>{ const lineCmp = compareLineNames(a.lineName, b.lineName); if (lineCmp !== 0) return lineCmp; const timeA = (a.scheduledTime || "").replace(':', ''); const timeB = (b.scheduledTime || "").replace(':', ''); const timeCmp = timeA.localeCompare(timeB); if (timeCmp !== 0) return timeCmp; const stopIDCmp = (a.stopID || "").localeCompare(b.stopID || ""); return stopIDCmp; }); } return dataToDisplay; }
        function updateSortArrows() { document.querySelectorAll('#currentScheduleTableContainer th[data-sortkey]').forEach(th=>{const s=th.querySelector('.sort-arrow');if(s)s.textContent='';if(th.dataset.sortkey===sortConfig.key&&s)s.textContent=sortConfig.direction==='asc'?' ▲':' ▼';});}
        function resetForm() { inputStopID.value=''; inputStopName.value=''; inputDirection.value=''; inputLineName.value=''; inputDestinationName.value=''; inputScheduledTime.value=''; inputOperatingProfile.value=''; selectDayOffset.value='0'; editingEntryIndexInput.value='-1'; addEntryButton.style.display='inline-block'; updateEntryButton.style.display='none'; cancelEditButton.style.display='none'; inputStopID.focus(); }
        function loadEntryForEdit(idx) { const dataToRender = applyFiltersAndSort(currentWorkingSchedule); if (idx < 0 || idx >= dataToRender.length) return; const entryToLoad = dataToRender[idx]; const actualEditIndex = currentWorkingSchedule.findIndex(item => item.internalId === entryToLoad.internalId); if(actualEditIndex < 0) return; const entry = currentWorkingSchedule[actualEditIndex]; inputStopID.value=entry.stopID||''; inputStopName.value=entry.stopName||''; inputDirection.value=entry.direction||''; inputLineName.value=entry.lineName||''; inputDestinationName.value=entry.destinationName||''; inputScheduledTime.value=entry.scheduledTime||''; inputOperatingProfile.value=entry.OperatingProfile||''; selectDayOffset.value=entry.DayOffset||'0'; editingEntryIndexInput.value = actualEditIndex; addEntryButton.style.display='none'; updateEntryButton.style.display='inline-block'; cancelEditButton.style.display='inline-block'; inputStopID.focus(); }
        function handleInputStopIDChange() { const currentStopId = inputStopID.value.trim().toUpperCase(); const editingIdx = parseInt(editingEntryIndexInput.value); if (currentStopId && (editingIdx === -1 || (currentWorkingSchedule[editingIdx] && currentWorkingSchedule[editingIdx].stopID.toUpperCase() !== currentStopId))) { let existingEntry = null; for (let i = currentWorkingSchedule.length - 1; i >= 0; i--) { if (currentWorkingSchedule[i].stopID.toUpperCase() === currentStopId) { existingEntry = currentWorkingSchedule[i]; break; } } if (existingEntry) { if (!inputStopName.value) inputStopName.value = existingEntry.stopName; if (!inputDirection.value) inputDirection.value = existingEntry.direction; } } }
        function handleAddOrUpdateEntry() { const schedTime=inputScheduledTime.value; if(!schedTime.match(/^([01]\d|2[0-3]):([0-5]\d)$/)){ alert("Scheduled Time must be in HH:MM format (e.g., 09:30 or 23:15)."); inputScheduledTime.focus();return; } if(!inputStopID.value.trim()||!inputLineName.value.trim()||!inputOperatingProfile.value.trim()){ alert("Stop ID, Line Name, and Operating Profile are required.");return; } const entry={ stopID:inputStopID.value.trim().toUpperCase(), stopName:inputStopName.value.trim(), direction:inputDirection.value.trim(), lineName:inputLineName.value.trim().toUpperCase(), destinationName:inputDestinationName.value.trim(), scheduledTime:schedTime, OperatingProfile:inputOperatingProfile.value.trim(), DayOffset:selectDayOffset.value, internalId:'' }; const editIdx=parseInt(editingEntryIndexInput.value); if(editIdx > -1 && editIdx < currentWorkingSchedule.length){ entry.internalId=currentWorkingSchedule[editIdx].internalId; currentWorkingSchedule[editIdx]=entry; } else { entry.internalId=`manual_${Date.now()}_${Math.random().toString(36).substr(2,5)}`; currentWorkingSchedule.push(entry); } sortConfig = { key: null, direction: 'asc' }; renderScheduleTable(); resetForm(); }
        function handleDeleteEntry(originalIndexPassed) { if(originalIndexPassed <0 || originalIndexPassed >=currentWorkingSchedule.length) { console.warn("Delete: Invalid index", originalIndexPassed); return; } if(confirm(`Delete ${currentWorkingSchedule[originalIndexPassed].lineName} at ${currentWorkingSchedule[originalIndexPassed].scheduledTime} from working schedule?`)){ currentWorkingSchedule.splice(originalIndexPassed,1); renderScheduleTable(); } }
        function isValidScheduleDataFromText(jsonData) { if (!jsonData || jsonData.length === 0) return false; const requiredColumns = ['StopID', 'StopName', 'Direction', 'LineName', 'DestinationName', 'ScheduledTime', 'OperatingProfile']; const firstEntry = jsonData[0]; const allColumnsPresent = requiredColumns.every(col => col in firstEntry); if (!allColumnsPresent) { const missingCols = requiredColumns.filter(col => !(col in firstEntry)); alert(`Uploaded .COUNT file is missing expected headers: ${missingCols.join(', ')}.\nExpected headers are: StopID, StopName, Direction, LineName, DestinationName, ScheduledTime, OperatingProfile (DayOffset is also common). Header case matters.`); return false; } return true; }
        function handleCountFileUpload(event) { const file = event.target.files[0]; if (file) { if (fileStatusElement) fileStatusElement.textContent = `Processing ${file.name}...`; setTimeout(() => { const reader = new FileReader(); reader.onload = function(e) { try { const fileContent = e.target.result; const lines = fileContent.split(/\r?\n/); if (lines.length < 2) { alert("The .COUNT file is empty or does not contain enough data (header + at least one entry)."); if (fileStatusElement) fileStatusElement.textContent = "File processing failed: Not enough data."; if (countFileInput) countFileInput.value = ""; return; } const headers = lines[0].split('\t').map(h => h.trim()); const jsonData = []; for (let i = 1; i < lines.length; i++) { const line = lines[i].trim(); if (line === "") continue; const values = line.split('\t').map(v => v.trim()); if (values.length < headers.length && values.every(v => v === "")) continue; if (values.length < headers.length && values.length > 0) { console.warn(`Line ${i+1} has fewer columns (${values.length}) than headers (${headers.length}). Some data might be missing for this row. Row: "${line}"`); for(let k = values.length; k < headers.length; k++) { values.push(''); } } let entry = {}; headers.forEach((header, index) => { entry[header] = values[index] !== undefined ? values[index] : ""; }); jsonData.push(entry); } if (isValidScheduleDataFromText(jsonData)) { if (currentWorkingSchedule.length > 0 && !confirm("Uploading this .COUNT file will replace all entries in the current working schedule. Continue?")) { if (fileStatusElement) fileStatusElement.textContent = "Upload cancelled."; if (countFileInput) countFileInput.value = ""; return; } currentWorkingSchedule = jsonData.map((row, index) => { let scheduledTime = String(row.ScheduledTime || "").trim(); if (scheduledTime.match(/^\d{1,2}:\d{2}(:\d{2})?$/)) { const parts = scheduledTime.split(':'); scheduledTime = `${String(parts[0]).padStart(2, '0')}:${String(parts[1]).padStart(2, '0')}`; } else if (scheduledTime.length === 4 && !scheduledTime.includes(':')) { scheduledTime = `${scheduledTime.substring(0,2)}:${scheduledTime.substring(2,4)}`; } else if (scheduledTime.length === 3 && !scheduledTime.includes(':')) { scheduledTime = `0${scheduledTime.substring(0,1)}:${scheduledTime.substring(1,3)}`; } return { internalId: `${String(row.StopID||'s').trim().toUpperCase()}_${String(row.LineName||'l').trim().toUpperCase()}_${scheduledTime.replace(':','')}_${index}_countfile`, stopID: String(row.StopID || "").trim().toUpperCase(), stopName: String(row.StopName || "").trim(), direction: String(row.Direction || "").trim(), lineName: String(row.LineName || "").trim().toUpperCase(), destinationName: String(row.DestinationName || "").trim(), scheduledTime: scheduledTime, OperatingProfile: String(row.OperatingProfile || "").trim(), DayOffset: String(row.DayOffset || "0").trim() }; }); sortConfig = { key: null, direction: 'asc' }; renderScheduleTable(); if (fileStatusElement) fileStatusElement.textContent = `${file.name} processed. ${currentWorkingSchedule.length} entries loaded into working schedule.`; } else { if (fileStatusElement) fileStatusElement.textContent = "File processing failed: Invalid file structure or missing/mismatched headers."; } } catch (error) { console.error("Error processing .COUNT file:", error); alert(`Error reading .COUNT file: ${error.message}.`); if (fileStatusElement) fileStatusElement.textContent = "Error loading file."; } if (countFileInput) countFileInput.value = ""; }; reader.onerror = () => { alert("Could not read the file."); if (fileStatusElement) fileStatusElement.textContent = "Error reading file."; if (countFileInput) countFileInput.value = ""; }; reader.readAsText(file); }, 50); } }
        function handleBulkUpdateStopDetails() { if (!currentUser) { alert("Please log in."); return; } const targetStopID = bulkEditTargetStopIDInput.value.trim().toUpperCase(); const newStopName = bulkEditNewStopNameInput.value.trim(); const newDirection = bulkEditNewDirectionInput.value.trim(); if (!targetStopID) { alert("Please enter the Target Stop ID to update."); bulkEditTargetStopIDInput.focus(); return; } if (!newStopName && !newDirection) { alert("Please enter a new Stop Name or a new Direction to update."); return; } let updatedCount = 0; currentWorkingSchedule.forEach(entry => { if (entry.stopID && entry.stopID.toUpperCase() === targetStopID) { let entryChanged = false; if (newStopName) { entry.stopName = newStopName; entryChanged = true; } if (newDirection) { entry.direction = newDirection; entryChanged = true; } if (entryChanged) updatedCount++; } }); if (updatedCount > 0) { renderScheduleTable(); alert(`${updatedCount} entries for Stop ID "${targetStopID}" were updated in the working schedule.\nRemember to 'Stage' or 'Apply' your changes.`); bulkEditNewStopNameInput.value = ''; bulkEditNewDirectionInput.value = ''; displayCurrentDetailsForBulkStopEdit(); } else { alert(`No entries found with Stop ID "${targetStopID}" in working schedule. No changes made.`); } }
        function handleBulkUpdateRouteDestination() { if (!currentUser) { alert("Please log in."); return; } const targetLineName = bulkEditTargetLineNameInput.value.trim().toUpperCase(); const oldDestination = bulkEditOldDestinationInput.value.trim(); const newDestination = bulkEditNewDestinationInput.value.trim(); if (!targetLineName) { alert("Please enter a Target Line Name."); bulkEditTargetLineNameInput.focus(); return; } if (!newDestination) { alert("Please enter the New Destination Name."); bulkEditNewDestinationInput.focus(); return; } let updatedCount = 0; currentWorkingSchedule.forEach(entry => { if (entry.lineName && entry.lineName.toUpperCase() === targetLineName) { if (oldDestination) { if (entry.destinationName && entry.destinationName.toLowerCase() === oldDestination.toLowerCase()) { entry.destinationName = newDestination; updatedCount++; } } else { entry.destinationName = newDestination; updatedCount++; } } }); if (updatedCount > 0) { renderScheduleTable(); alert(`${updatedCount} entries for Line "${targetLineName}" had their destination updated to "${newDestination}" in the working schedule.\nRemember to 'Stage' or 'Apply' your changes.`); } else { alert(`No entries found for Line "${targetLineName}"` + (oldDestination ? ` with Old Destination "${oldDestination}"` : "") + " in working schedule. No changes made."); } }
        function displayCurrentDetailsForBulkStopEdit() { const targetStopID = bulkEditTargetStopIDInput.value.trim().toUpperCase(); if (!targetStopID) { currentBulkEditStopNameDisplay.textContent = "- Type Stop ID above -"; currentBulkEditDirectionDisplay.textContent = "- Type Stop ID above -"; return; } const existingEntry = currentWorkingSchedule.find(entry => entry.stopID && entry.stopID.toUpperCase() === targetStopID); if (existingEntry) { currentBulkEditStopNameDisplay.textContent = existingEntry.stopName || "N/A"; currentBulkEditDirectionDisplay.textContent = existingEntry.direction || "N/A"; } else { currentBulkEditStopNameDisplay.textContent = "- No match found in working schedule -"; currentBulkEditDirectionDisplay.textContent = "- No match found in working schedule -"; } }
        
        function handleStageSchedule() {
            if (!currentUser) { alert("Please log in to stage a schedule."); return; }
            if (currentWorkingSchedule.length === 0) { if (!confirm("The current working schedule is empty. Are you sure you want to stage an empty schedule? This would clear the live schedule upon next update.")) { stagingStatusMessage.textContent = "Staging of empty schedule cancelled."; stagingStatusMessage.style.color = "#e74c3c"; return; } }
            let dataToStage = JSON.parse(JSON.stringify(currentWorkingSchedule));
            dataToStage.sort((a, b) => { const lineCmp = compareLineNames(a.lineName, b.lineName); if (lineCmp !== 0) return lineCmp; const timeA = (a.scheduledTime || "").replace(':', ''); const timeB = (b.scheduledTime || "").replace(':', ''); const timeCmp = timeA.localeCompare(timeB); if (timeCmp !== 0) return timeCmp; return (a.stopID || "").localeCompare(b.stopID || ""); });
            const finalScheduleData = dataToStage.map((entry, index) => ({ ...entry, internalId: entry.internalId || `${entry.stopID.toUpperCase()}_${entry.lineName.toUpperCase()}_${(entry.scheduledTime||"").replace(':', '')}_${index}_staged` }));
            const stopsMap = new Map();
            finalScheduleData.forEach(row => { if (row.stopID && !stopsMap.has(row.stopID)) { stopsMap.set(row.stopID, { stopID: row.stopID, stopName: row.stopName, direction: row.direction }); } });
            const finalUniqueStops = Array.from(stopsMap.values()).sort((a,b)=>{ const nC=(a.stopName||"").localeCompare(b.stopName||""); return nC!==0?nC:(a.direction||"").localeCompare(b.direction||""); });

            if (window.firebaseOMSI) {
                const { database, dbUpdate, dbRef } = window.firebaseOMSI;
                const updates = {};
                updates[FB_PATH_PENDING_SCHEDULE_DATA] = finalScheduleData;
                updates[FB_PATH_PENDING_UNIQUE_STOPS] = finalUniqueStops;
                updates[FB_PATH_PENDING_TIMESTAMP] = new Date().toISOString();
                updates[FB_PATH_APPSTATE_STATUS] = 'update_staged';
                dbUpdate(dbRef(database), updates)
                    .then(() => {
                        alert("Working schedule STAGED to Firebase.");
                        updateStagingStatusDisplay(); 
                    })
                    .catch((error) => {
                        console.error("Error staging to Firebase: ", error);
                        alert("Error staging to Firebase. Check console.");
                        if(stagingStatusMessage) { stagingStatusMessage.textContent = "Error staging to Firebase."; stagingStatusMessage.style.color = "#e74c3c"; }
                    });
            } else {
                console.warn("Firebase not available, cannot stage.");
                alert("Firebase not available. Staging failed.");
            }
        }

        function handleApplyNow() {
            if (!currentUser) { alert("Please log in to apply a schedule."); return; }
            if (window.firebaseOMSI) {
                const { database, dbGet, dbUpdate, dbRef, dbChild } = window.firebaseOMSI; 
                dbGet(dbChild(dbRef(database), '/pendingSchedule'))
                    .then((snapshot) => {
                        if (snapshot.exists()) {
                            const pendingData = snapshot.val();
                            if (!confirm("Are you sure you want to apply the Firebase staged schedule to live NOW?")) {
                                if (stagingStatusMessage) { stagingStatusMessage.textContent = "Immediate application cancelled."; stagingStatusMessage.style.color = "#e74c3c"; }
                                return;
                            }
                            let liveAllScheduledBusData = [];
                            if (Array.isArray(pendingData.allScheduledBusData)) {
                                liveAllScheduledBusData = pendingData.allScheduledBusData.filter(item => item != null);
                            } else if (typeof pendingData.allScheduledBusData === 'object' && pendingData.allScheduledBusData !== null) {
                                liveAllScheduledBusData = Object.values(pendingData.allScheduledBusData).filter(item => item != null);
                            }
                            let liveUniqueBusStops = [];
                             if (Array.isArray(pendingData.uniqueBusStops)) {
                                liveUniqueBusStops = pendingData.uniqueBusStops.filter(item => item != null);
                            } else if (typeof pendingData.uniqueBusStops === 'object' && pendingData.uniqueBusStops !== null) {
                                liveUniqueBusStops = Object.values(pendingData.uniqueBusStops).filter(item => item != null);
                            }
                            let hasInvalidKeyInSchedule = false;
                            function checkKeysRecursively(obj, path) { if (typeof obj !== 'object' || obj === null) return; for (const key in obj) { if (/[.#$/\[\]]/.test(key)) { console.error(`INVALID KEY at ${path}: key='${key}'`); hasInvalidKeyInSchedule = true; } if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) { checkKeysRecursively(obj[key], `${path}.${key}`); } } }
                            liveAllScheduledBusData.forEach((item, index) => { if (typeof item !== 'object' || item === null) { hasInvalidKeyInSchedule = true; return; } checkKeysRecursively(item, `liveAllScheduledBusData[${index}]`); });
                            liveUniqueBusStops.forEach((item, index) => { if (typeof item !== 'object' || item === null) { hasInvalidKeyInSchedule = true; return; } checkKeysRecursively(item, `liveUniqueBusStops[${index}]`); });
                            if (hasInvalidKeyInSchedule) { alert("Found invalid keys in the schedule data. Cannot apply to Firebase. Check console for details."); return; }

                            const liveScheduleUpdates = {};
                            liveScheduleUpdates[FB_PATH_LIVE_SCHEDULE_DATA] = liveAllScheduledBusData;
                            liveScheduleUpdates[FB_PATH_LIVE_UNIQUE_STOPS] = liveUniqueBusStops;
                            
                            dbUpdate(dbRef(database), liveScheduleUpdates) 
                            .then(() => {
                                const appStateUpdates = {};
                                appStateUpdates[FB_PATH_APPSTATE_LAST_UPDATED] = new Date().toISOString();
                                appStateUpdates[FB_PATH_APPSTATE_STATUS] = 'idle';
                                appStateUpdates['/pendingSchedule'] = null; 
                                return dbUpdate(dbRef(database), appStateUpdates);
                            })
                            .then(() => {
                                alert("Staged schedule from Firebase has been applied LIVE!");
                                updateStagingStatusDisplay();
                            })
                            .catch(error => {
                                console.error("Error applying staged schedule from Firebase: ", error);
                                alert("Error applying Firebase schedule. Check console. Error: " + error.message);
                            });
                        } else {
                            alert("No staged schedule found in Firebase to apply.");
                            if (stagingStatusMessage) { stagingStatusMessage.textContent = "No Firebase staged schedule to apply."; stagingStatusMessage.style.color = "#e74c3c"; }
                        }
                    }).catch(error => {
                        console.error("Error fetching pending schedule from Firebase: ", error);
                        alert("Error fetching Firebase staged schedule. Check console. Error: " + error.message);
                    });
            } else {
                console.warn("Firebase not available, cannot apply now.");
                alert("Firebase not available.");
            }
        }


        async function loadInitialData() {
            console.log("Tools: Attempting to load initial data, prioritizing Firebase...");
            let sourceMessage = "Loading data...";
            if (fileStatusElement) fileStatusElement.textContent = sourceMessage;

            currentWorkingSchedule = []; 
            closedStopIDs = [];
            customRouteColours = {};

            if (!window.firebaseOMSI) {
                console.warn("Tools: Firebase not initialized. Cannot load data from Firebase.");
                sourceMessage = "Firebase not connected. No data loaded.";
            } else {
                const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
                try {
                    const liveScheduleSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_SCHEDULE_DATA));
                    if (liveScheduleSnapshot.exists() && Array.isArray(liveScheduleSnapshot.val())) {
                        currentWorkingSchedule = liveScheduleSnapshot.val().map((entry, index) => ({
                            ...entry,
                            internalId: entry.internalId || `${(entry.stopID || 's')}_${(entry.lineName||'l')}_${(entry.scheduledTime||"").replace(':','')}_${index}_fbloaded`
                        }));
                    }

                    const closedStopsSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_CLOSED_STOPS));
                    if (closedStopsSnapshot.exists()) { const fbClosedStops = closedStopsSnapshot.val(); for (const stopID in fbClosedStops) { if (fbClosedStops[stopID] === true) { closedStopIDs.push(stopID); } } }

                    const customColoursSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_CUSTOM_COLOURS));
                    if (customColoursSnapshot.exists()) { customRouteColours = customColoursSnapshot.val(); }
                    
                    sourceMessage = `Data loaded from Firebase. ${currentWorkingSchedule.length} schedule entries.`;
                } catch (error) {
                    console.error("Tools: Error loading initial data from Firebase:", error);
                    sourceMessage = "Error loading data from Firebase. Check console.";
                }
            }
            if (fileStatusElement) fileStatusElement.textContent = sourceMessage;
            loadAndApplyCustomRouteColoursForTools();
            renderScheduleTable();
            updateStagingStatusDisplay(); 
            populateStopStatusSelector();
            // listenForLiveServiceMessage(); // Already removed in previous step, ensuring it's gone
        }

        async function updateStagingStatusDisplay() {
            let pendingTimestamp = null; let liveTimestamp = null; let firebaseStatus = "Checking Firebase...";
            if (window.firebaseOMSI) {
                const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
                try {
                    const pendingSnap = await dbGet(dbChild(dbRef(database), FB_PATH_PENDING_TIMESTAMP));
                    if (pendingSnap.exists()) pendingTimestamp = pendingSnap.val();
                    const liveSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_LAST_UPDATED));
                    if (liveSnap.exists()) liveTimestamp = liveSnap.val();
                    const statusSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_STATUS));
                    const currentFbStatus = statusSnap.exists() ? statusSnap.val() : 'unknown';
                    firebaseStatus = `Firebase status: ${currentFbStatus}.`;

                    if (currentFbStatus === 'update_staged' && pendingTimestamp) {
                        applyNowButton.disabled = false;
                    } else { 
                        pendingTimestamp = null; 
                        applyNowButton.disabled = true;
                    }

                } catch (e) { firebaseStatus = "Error fetching Firebase status."; console.error(firebaseStatus, e); applyNowButton.disabled = true;}
            } else { firebaseStatus = "Firebase not available."; applyNowButton.disabled = true;}
            let msg = "";
            if (pendingTimestamp) { msg = `A schedule was STAGED to Firebase on: ${new Date(pendingTimestamp).toLocaleString()}.<br>Awaiting 'Apply Staged Schedule Live NOW'.`; if(stagingStatusMessage) stagingStatusMessage.style.color = "#2ecc71"; }
            else { msg = "No schedule is currently staged in Firebase. Changes here can be staged."; if(stagingStatusMessage) stagingStatusMessage.style.color = "#f1c40f"; }
            if (liveTimestamp) { msg += `<br>Current LIVE schedule in Firebase was last updated: ${new Date(liveTimestamp).toLocaleString()}`; }
            else { msg += "<br>No LIVE schedule has been set in Firebase yet."; }
            msg += `<br><small>(${firebaseStatus})</small>`;
            if(stagingStatusMessage) stagingStatusMessage.innerHTML = msg;
        }
        
        function saveClosedStops() { if (!currentUser) { alert("Please log in."); return; } localStorage.setItem('closedBusStopIDs', JSON.stringify(closedStopIDs)); if (window.firebaseOMSI) { const { database, dbSet, dbRef } = window.firebaseOMSI; const fbClosedStops = {}; closedStopIDs.forEach(id => fbClosedStops[id] = true); dbSet(dbRef(database, FB_PATH_APPSTATE_CLOSED_STOPS), fbClosedStops) .then(() => { return dbSet(dbRef(database, FB_PATH_APPSTATE_LAST_UPDATED), new Date().toISOString()); }) .catch(error => console.error("Error saving closed stops to Firebase: ", error)); } }
        function saveCustomRouteColours() { if (!currentUser) { alert("Please log in."); return; } localStorage.setItem(CUSTOM_ROUTE_COLOURS_KEY, JSON.stringify(customRouteColours)); if (window.firebaseOMSI) { const { database, dbSet, dbRef } = window.firebaseOMSI; dbSet(dbRef(database, FB_PATH_SETTINGS_CUSTOM_COLOURS), customRouteColours) .then(() => { return dbSet(dbRef(database, FB_PATH_APPSTATE_LAST_UPDATED), new Date().toISOString()); }) .catch(error => console.error("Error saving custom route colours to Firebase: ", error)); } if (routeColourStatusMessage) { routeColourStatusMessage.textContent = 'Custom colours saved.'; setTimeout(() => { if(routeColourStatusMessage) routeColourStatusMessage.textContent = ''; }, 4000); } loadAndApplyCustomRouteColoursForTools(); if(selectStopForDeparturesView.value) displayDeparturesForSelectedStop(); renderCustomRouteColours(); }
        
        function populateRouteSelectorForEvents() { if (!selectEventRoute) return; const currentVal = selectEventRoute.value; selectEventRoute.innerHTML = '<option value="">-- Select a Route --</option>'; const uniqueLineNames = [...new Set(currentWorkingSchedule.map(entry => entry.lineName))].sort(compareLineNames); uniqueLineNames.forEach(lineName => { if (lineName) { const option = document.createElement('option'); option.value = lineName; option.textContent = lineName; selectEventRoute.appendChild(option); } }); if (uniqueLineNames.includes(currentVal)) selectEventRoute.value = currentVal; else selectEventRoute.value = ""; populateImpactStopSelector(); }
        function populateImpactStopSelector() { if (!selectEventImpactStop || !selectEventRoute) return; const selectedRoute = selectEventRoute.value; const currentVal = selectEventImpactStop.value; selectEventImpactStop.innerHTML = '<option value="">-- Route Wide / First Stop --</option>'; if (selectedRoute) { const stopsOnRoute = currentWorkingSchedule .filter(entry => entry.lineName === selectedRoute) .map(entry => ({ id: entry.stopID, name: entry.stopName, time: entry.scheduledTime })) .sort((a,b) => (a.time || "").replace(':','') - (b.time || "").replace(':','')); const uniqueStopsOnRoute = []; const seenStopIDs = new Set(); for (const stop of stopsOnRoute) { if (stop.id && !seenStopIDs.has(stop.id)) { uniqueStopsOnRoute.push(stop); seenStopIDs.add(stop.id); } } uniqueStopsOnRoute.forEach(stop => { const option = document.createElement('option'); option.value = stop.id; option.textContent = `${stop.id} - ${stop.name || 'Unknown'}`; selectEventImpactStop.appendChild(option); }); if (seenStopIDs.has(currentVal)) selectEventImpactStop.value = currentVal; else selectEventImpactStop.value = ""; } }
        async function populateStopStatusSelector() { if (!selectStopForStatusChange || !window.firebaseOMSI) return; const currentVal = selectStopForStatusChange.value; selectStopForStatusChange.innerHTML = '<option value="">-- Select a Stop --</option>'; const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const snapshot = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_UNIQUE_STOPS)); let stopsToDisplay = []; if (snapshot.exists() && Array.isArray(snapshot.val())) { stopsToDisplay = snapshot.val(); } else if (snapshot.exists()) { stopsToDisplay = Object.values(snapshot.val());} stopsToDisplay.sort((a,b) => (a.stopName||"").localeCompare(b.stopName||"")); stopsToDisplay.forEach(stop => { if(!stop || !stop.stopID) return; const option = document.createElement('option'); option.value = stop.stopID; const isClosed = closedStopIDs.includes(stop.stopID); option.textContent = `${stop.stopName || stop.stopID} (${stop.stopID})${isClosed ? ' (Currently Closed)' : ''}`; selectStopForStatusChange.appendChild(option); }); if (currentVal && stopsToDisplay.find(s => s && s.stopID === currentVal)) { selectStopForStatusChange.value = currentVal; } else { selectStopForStatusChange.value = ""; } } catch (e) {console.error("Error populating stop status selector from Firebase", e)} }
        function handleStopStatusChange(action) { if (!currentUser) { alert("Please log in."); return; } const stopIDToChange = selectStopForStatusChange.value; if (!stopIDToChange) { stopStatusMessage.textContent = "Please select a stop."; return; } const stopIndexInClosedList = closedStopIDs.indexOf(stopIDToChange); const stopName = selectStopForStatusChange.options[selectStopForStatusChange.selectedIndex].text.split(' (')[0]; if (action === 'close') { if (stopIndexInClosedList === -1) { closedStopIDs.push(stopIDToChange); stopStatusMessage.textContent = `Stop '${stopName}' marked as closed.`; } else { stopStatusMessage.textContent = `Stop '${stopName}' is already closed.`; } } else if (action === 'reopen') { if (stopIndexInClosedList !== -1) { closedStopIDs.splice(stopIndexInClosedList, 1); stopStatusMessage.textContent = `Stop '${stopName}' marked as reopened.`; } else { stopStatusMessage.textContent = `Stop '${stopName}' is not currently closed.`; } } saveClosedStops(); populateStopStatusSelector(); }
        function applyRandomEvent() { if (!currentUser) { alert("Please log in."); return; } const selectedRoute = selectEventRoute.value; const impactFromStopID = selectEventImpactStop.value; if (!selectedRoute) { eventStatusMessage.textContent = "Please select a route to affect."; return; } const availableEventTypes = [...eventTypes]; if (!impactFromStopID) { const index = availableEventTypes.findIndex(e => e.type === "DELAY_FROM_STOP"); if (index > -1) availableEventTypes.splice(index, 1); } if (availableEventTypes.length === 0) { eventStatusMessage.textContent = "No applicable event types for current selection."; return; } const eventChoice = availableEventTypes[Math.floor(Math.random() * availableEventTypes.length)]; eventStatusMessage.textContent = `Applying event: ${eventChoice.name} to route ${selectedRoute} in working schedule...`; let eventApplied = false; let details = `Event: ${eventChoice.name}. `; switch (eventChoice.type) { case "DELAY_ROUTE": case "DELAY_FROM_STOP": const delayMinutes = Math.floor(Math.random() * (eventChoice.maxDelay - eventChoice.minDelay + 1)) + eventChoice.minDelay; let applyDelay = (eventChoice.type === "DELAY_ROUTE"); let delayedCount = 0; currentWorkingSchedule.forEach(entry => { if (entry.lineName === selectedRoute) { if (!applyDelay && eventChoice.type === "DELAY_FROM_STOP" && entry.stopID === impactFromStopID) { applyDelay = true; } if (applyDelay) { if (!entry.scheduledTime) return; const timeParts = entry.scheduledTime.split(':'); if (timeParts.length === 2) { let hours = parseInt(timeParts[0]); let minutes = parseInt(timeParts[1]); minutes += delayMinutes; hours += Math.floor(minutes / 60); minutes %= 60; hours %= 24; entry.scheduledTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`; entry.eventNotes = (entry.eventNotes || "") + ` Delayed +${delayMinutes}m.`; delayedCount++; eventApplied = true; } } } }); details += `${delayedCount} entries for route ${selectedRoute} delayed by ${delayMinutes} mins.`; if (!eventApplied && eventChoice.type === "DELAY_FROM_STOP" && impactFromStopID) details += " (Impact stop not found or no subsequent services)."; break; case "CURTAIL": const routeEntriesForCurtail = currentWorkingSchedule.filter(e => e.lineName === selectedRoute); if (routeEntriesForCurtail.length > 0) { const uniqueStopObjs = []; const stopIdsOnRoute = new Set(); const orderedRouteStops = [...routeEntriesForCurtail].sort((a,b) => (a.scheduledTime||"").localeCompare(b.scheduledTime||"")); orderedRouteStops.forEach(e => { if(!stopIdsOnRoute.has(e.stopID)) { uniqueStopObjs.push({id: e.stopID, name: e.stopName}); stopIdsOnRoute.add(e.stopID); } }); if (uniqueStopObjs.length > 1) { let newDestStop; let curtailAtIndex = -1; if (impactFromStopID) { curtailAtIndex = uniqueStopObjs.findIndex(s => s.id === impactFromStopID); if (curtailAtIndex >= 0 && curtailAtIndex < uniqueStopObjs.length -1) { newDestStop = uniqueStopObjs[curtailAtIndex]; } else if (curtailAtIndex === uniqueStopObjs.length -1 && uniqueStopObjs.length > 1) { newDestStop = uniqueStopObjs[curtailAtIndex -1]; curtailAtIndex = curtailAtIndex -1; } } if (!newDestStop && uniqueStopObjs.length > 1) { const maxIndex = uniqueStopObjs.length - 2; curtailAtIndex = Math.floor(Math.random() * (maxIndex + 1)); newDestStop = uniqueStopObjs[curtailAtIndex]; } if (newDestStop) { let actualCurtailments = 0; let destinationsUpdated = 0; currentWorkingSchedule = currentWorkingSchedule.filter(entry => { if (entry.lineName === selectedRoute) { const entryStopIndexInUnique = uniqueStopObjs.findIndex(s => s.id === entry.stopID); if (entryStopIndexInUnique > curtailAtIndex) { actualCurtailments++; eventApplied = true; return false; } } return true; }); currentWorkingSchedule.forEach(entry => { if(entry.lineName === selectedRoute && entry.destinationName !== newDestStop.name){ entry.destinationName = newDestStop.name; entry.eventNotes = (entry.eventNotes || "") + ` Curtailed to ${newDestStop.name}.`; destinationsUpdated++; eventApplied = true; } }); if (actualCurtailments > 0 || destinationsUpdated > 0) { details += `Route ${selectedRoute} services now terminate at ${newDestStop.name}. ${actualCurtailments} stops removed, ${destinationsUpdated} destinations updated.`; } else { details += "Could not apply curtailment (no entries changed or removed)."; } } else { details += "Could not determine a suitable curtailment point (e.g., route too short, or selected impact stop was the first)."; } } else { details += "Route too short to curtail (needs at least 2 unique stops)."; } } break; } if (eventApplied) { renderScheduleTable(); eventStatusMessage.textContent = details + " Changes are in the 'Working Schedule'. Stage or Apply to save."; } else { eventStatusMessage.textContent = details + " No changes applied to working schedule."; } populateRouteSelectorForEvents(); if(selectEventRoute) selectEventRoute.value = ""; populateImpactStopSelector(); }
        function loadAndApplyCustomRouteColoursForTools() { effectiveRouteColourMapTools = { ...initialRouteColourMapForTools, ...customRouteColours }; }
        function renderCustomRouteColours() { if (!currentRouteColoursList || !noCustomColoursMessage) return; currentRouteColoursList.innerHTML = ''; const uniqueScheduleRoutes = [...new Set(currentWorkingSchedule.map(entry => entry.lineName))] .filter(name => name && name.trim() !== "") .sort(compareLineNames); if (uniqueScheduleRoutes.length === 0) { noCustomColoursMessage.textContent = 'No routes in working schedule to assign colours to.'; noCustomColoursMessage.style.display = 'block'; return; } noCustomColoursMessage.style.display = 'none'; uniqueScheduleRoutes.forEach(routeName => { const upperRouteName = routeName.toUpperCase(); const isCustom = customRouteColours.hasOwnProperty(upperRouteName); const displayColour = isCustom ? customRouteColours[upperRouteName] : DEFAULT_ROUTE_COLOUR_TOOLS; const li = document.createElement('li'); const colourBox = document.createElement('span'); colourBox.className = 'colour-preview-box'; colourBox.style.backgroundColor = displayColour; const routeInfo = document.createElement('span'); routeInfo.className = 'route-info'; let statusText = isCustom ? "" : ` <small style="opacity:0.7;">(Default)</small>`; routeInfo.innerHTML = `Route: ${routeName} - Colour: ${displayColour.toUpperCase()}${statusText}`; const actionContainer = document.createElement('div'); actionContainer.style.marginLeft = 'auto'; if (isCustom) { const removeBtn = document.createElement('button'); removeBtn.textContent = 'Remove Custom'; removeBtn.classList.add('button', 'small-action', 'secondary'); removeBtn.onclick = () => handleRemoveRouteColour(upperRouteName); actionContainer.appendChild(removeBtn); } li.appendChild(colourBox); li.appendChild(routeInfo); li.appendChild(actionContainer); currentRouteColoursList.appendChild(li); }); }
        function populateRouteSelectorForColours() { if (!selectRouteNameColour) return; const currentVal = selectRouteNameColour.value; selectRouteNameColour.innerHTML = '<option value="">-- Select a Route --</option>'; const uniqueLineNames = [...new Set(currentWorkingSchedule.map(entry => entry.lineName))] .filter(name => name && name.trim() !== "") .sort(compareLineNames); uniqueLineNames.forEach(lineName => { const option = document.createElement('option'); option.value = lineName; option.textContent = lineName; selectRouteNameColour.appendChild(option); }); if (uniqueLineNames.includes(currentVal)) { selectRouteNameColour.value = currentVal; } selectRouteNameColour.dispatchEvent(new Event('change')); }
        function handleSaveRouteColour() { if (!currentUser) { alert("Please log in."); return; } if (!selectRouteNameColour || !inputRouteColour || !routeColourStatusMessage) return; const routeName = selectRouteNameColour.value; const colour = inputRouteColour.value; if (!routeName) { routeColourStatusMessage.textContent = 'Please select a route name.'; routeColourStatusMessage.style.color = '#e74c3c'; return; } if (!colour.match(/^#[0-9a-fA-F]{6}$/)) { routeColourStatusMessage.textContent = 'Invalid colour format. Please use hex (e.g., #RRGGBB).'; routeColourStatusMessage.style.color = '#e74c3c'; return; } customRouteColours[routeName.toUpperCase()] = colour.toUpperCase(); saveCustomRouteColours(); }
        function handleRemoveRouteColour(routeNameKey) { if (!currentUser) { alert("Please log in."); return; } if (customRouteColours.hasOwnProperty(routeNameKey)) { if (confirm(`Are you sure you want to remove the custom colour for route ${routeNameKey}? It will revert to default.`)) { delete customRouteColours[routeNameKey]; saveCustomRouteColours(); if (selectRouteNameColour.value.toUpperCase() === routeNameKey) { inputRouteColour.value = DEFAULT_ROUTE_COLOUR_TOOLS; } } } }
        function getRouteTileColourForTools(lineName) { const upperLineName = String(lineName || "").toUpperCase(); if (effectiveRouteColourMapTools[upperLineName]) { return effectiveRouteColourMapTools[upperLineName]; } if (upperLineName.startsWith("N")) return effectiveRouteColourMapTools["N5"] || DEFAULT_ROUTE_COLOUR_TOOLS; if (upperLineName.startsWith("SL")) return effectiveRouteColourMapTools["SL1"] || DEFAULT_ROUTE_COLOUR_TOOLS; return DEFAULT_ROUTE_COLOUR_TOOLS; }
        function getTextColourForBackgroundTools(hexColour) { if (!hexColour || hexColour.length < 7) return '#FFFFFF'; const r = parseInt(hexColour.slice(1, 3), 16); const g = parseInt(hexColour.slice(3, 5), 16); const b = parseInt(hexColour.slice(5, 7), 16); const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255; return luminance > 0.5 ? '#000000' : '#FFFFFF'; }
        function getDaySortOrder(profileString) { if (!profileString) return 99; const profiles = profileString.toUpperCase().split(',').map(p => p.trim()); if (profiles.some(p => p.startsWith("MO") && !p.startsWith("MO-FR"))) return 1; if (profiles.some(p => p.startsWith("TU"))) return 2; if (profiles.some(p => p.startsWith("WE"))) return 3; if (profiles.some(p => p.startsWith("TH"))) return 4; if (profiles.some(p => p.startsWith("FR") && !p.startsWith("MO-FR"))) return 5; if (profiles.some(p => p.startsWith("MF") || p.startsWith("MO-FR"))) return 6; if (profiles.some(p => p.startsWith("SA"))) return 7; if (profiles.some(p => p.startsWith("SU"))) return 8; if (profiles.includes("GOODFRIDAY")) return 10; if (profiles.includes("BANKHOLIDAY")) return 11; if (profiles.includes("XMASDAY")) return 12; if (profiles.includes("BOXINGDAY")) return 13; if (profiles.includes("NEWYEARSDAY")) return 14; if (profiles.includes("SCHOOLHOLIDAY")) return 20; return 99; }
        function populateStopSelectorForDeparturesView() { if (!selectStopForDeparturesView) return; const currentSelectedStop = selectStopForDeparturesView.value; selectStopForDeparturesView.innerHTML = '<option value="">-- Select a Stop --</option>'; if (currentWorkingSchedule.length === 0) { displayDeparturesForSelectedStop(); return; } const uniqueStopsMap = new Map(); currentWorkingSchedule.forEach(entry => { if (entry.stopID && !uniqueStopsMap.has(entry.stopID)) { uniqueStopsMap.set(entry.stopID, { stopID: entry.stopID, stopName: entry.stopName || entry.stopID }); } }); const sortedStops = Array.from(uniqueStopsMap.values()).sort((a, b) => { return (a.stopName.toLowerCase()).localeCompare(b.stopName.toLowerCase()); }); sortedStops.forEach(stop => { const option = document.createElement('option'); option.value = stop.stopID; option.textContent = `${stop.stopName} (${stop.stopID})`; selectStopForDeparturesView.appendChild(option); }); if (uniqueStopsMap.has(currentSelectedStop)) { selectStopForDeparturesView.value = currentSelectedStop; } displayDeparturesForSelectedStop(); }
        
        function displayDeparturesForSelectedStop() { 
            if (!selectStopForDeparturesView || !stopDeparturesList || !noDeparturesForStopMessage) return; 
            const selectedStopID = selectStopForDeparturesView.value; 
            stopDeparturesList.innerHTML = ''; 
            if (!selectedStopID) { 
                noDeparturesForStopMessage.textContent = 'Select a stop to view its scheduled departures.'; 
                noDeparturesForStopMessage.style.display = 'block'; return; 
            } 
            const departures = currentWorkingSchedule
                .filter(entry => entry.stopID === selectedStopID)
                .sort((a, b) => {
                    // 1. Sort by Days of Operation (Operating Profile)
                    const dayOrderA = getDaySortOrder(a.OperatingProfile);
                    const dayOrderB = getDaySortOrder(b.OperatingProfile);
                    if (dayOrderA !== dayOrderB) {
                        return dayOrderA - dayOrderB;
                    }

                    // 2. Sort by Time
                    const timeA = (a.scheduledTime || "9999").replace(':', '');
                    const timeB = (b.scheduledTime || "9999").replace(':', '');
                    if (timeA !== timeB) {
                        return timeA.localeCompare(timeB);
                    }

                    // 3. Sort by Route (Line Name)
                    const lineNameComparison = compareLineNames(a.lineName, b.lineName);
                    if (lineNameComparison !== 0) {
                        return lineNameComparison;
                    }
                    
                    // 4. Fallback sort by full OperatingProfile string if all else is equal
                    const profileA = a.OperatingProfile || "";
                    const profileB = b.OperatingProfile || "";
                    return profileA.localeCompare(profileB);
                }); 
            if (departures.length === 0) { 
                noDeparturesForStopMessage.textContent = 'No scheduled departures found for this stop in the working schedule.'; 
                noDeparturesForStopMessage.style.display = 'block'; 
            } else { 
                noDeparturesForStopMessage.style.display = 'none'; 
                departures.forEach(dep => { 
                    const li = document.createElement('li'); 
                    const lineTile = document.createElement('span'); 
                    lineTile.classList.add('route-tile-tools-list'); 
                    lineTile.textContent = dep.lineName || 'N/A'; 
                    const tileBGColour = getRouteTileColourForTools(dep.lineName); 
                    lineTile.style.backgroundColor = tileBGColour; 
                    lineTile.style.color = getTextColourForBackgroundTools(tileBGColour); 
                    const textSpan = document.createElement('span'); 
                    textSpan.innerHTML = ` to ${dep.destinationName || 'Unknown'} <span style="font-weight: bold; margin-left: 0.5em;">at ${dep.scheduledTime || 'N/A'}</span> <small style="opacity: 0.7; margin-left: 0.75em;">(Profile: ${dep.OperatingProfile || 'N/A'})</small> ${dep.DayOffset && dep.DayOffset !== "0" ? `<small style="opacity:0.7; margin-left:0.3em;color:#FFD700;">(+${dep.DayOffset}d)</small>` : ''} `; 
                    li.appendChild(lineTile); 
                    li.appendChild(textSpan); 
                    stopDeparturesList.appendChild(li); 
                }); 
            } 
        }
        function renderScheduleTable() { if (!currentScheduleTableBody || !entryCountElement) return; const dataToRender = applyFiltersAndSort(currentWorkingSchedule); currentScheduleTableBody.innerHTML = ''; entryCountElement.textContent = dataToRender.length + (currentWorkingSchedule.length !== dataToRender.length ? ` of ${currentWorkingSchedule.length} total (working)` : ' (working)'); if (dataToRender.length === 0) { const r=currentScheduleTableBody.insertRow(), c=r.insertCell(); c.colSpan=9; c.textContent=activeFilters.stopID||activeFilters.lineName||activeFilters.operatingProfile?"No entries match filters in working schedule.":"Working schedule is empty. Add or upload."; c.style.textAlign="center";c.style.padding="1rem";c.style.fontStyle="italic"; } else { dataToRender.forEach((entry) => { const originalIndex = currentWorkingSchedule.findIndex(item => item.internalId === entry.internalId); const r=currentScheduleTableBody.insertRow(); r.insertCell().textContent=entry.stopID||''; r.insertCell().textContent=entry.stopName||''; r.insertCell().textContent=entry.direction||''; r.insertCell().textContent=entry.lineName||''; r.insertCell().textContent=entry.destinationName||''; r.insertCell().textContent=entry.scheduledTime||''; r.insertCell().textContent=entry.OperatingProfile||''; r.insertCell().textContent=entry.DayOffset||'0'; const actCell=r.insertCell(); const editBtn=document.createElement('button'); editBtn.textContent="Edit";editBtn.classList.add('button','small-action','tertiary'); editBtn.onclick=()=>loadEntryForEdit(originalIndex);actCell.appendChild(editBtn); const delBtn=document.createElement('button'); delBtn.textContent="Del";delBtn.classList.add('button','small-action','secondary'); delBtn.onclick=()=>handleDeleteEntry(originalIndex);actCell.appendChild(delBtn); }); } updateSortArrows(); populateRouteSelectorForEvents(); populateStopStatusSelector(); populateRouteSelectorForColours(); populateStopSelectorForDeparturesView(); renderCustomRouteColours(); }

        // handleSetServiceMessage function removed
        // listenForLiveServiceMessage function removed

        document.addEventListener('DOMContentLoaded', () => {
            if (window.firebaseOMSI && window.firebaseOMSI.auth) {
                const { auth, authOnAuthStateChanged, authSignInWithEmailAndPassword, authSignOut } = window.firebaseOMSI;
                const adminLoginForm = document.getElementById('adminLoginForm');

                authOnAuthStateChanged(auth, (user) => {
                    updateAuthUI(user); 
                    if (user) {
                        console.log("User signed in, proceeding to load initial data for tools.");
                        fetchBankHolidaysForSetup();
                        loadInitialData(); 
                        // listenForLiveServiceMessage(); // Call removed
                    } else {
                        console.log("User signed out or not yet signed in.");
                        currentWorkingSchedule = []; renderScheduleTable(); 
                        updateStagingStatusDisplay(); 
                        // Service message display clear if needed (though elements are gone)
                    }
                });

                if (adminLoginForm) { 
                    adminLoginForm.addEventListener('submit', (event) => { 
                        event.preventDefault(); 
                        const email = inputEmail.value; 
                        const password = inputPassword.value; 
                        if(authStatus) authStatus.textContent = 'Logging in...'; 
                        authSignInWithEmailAndPassword(auth, email, password)
                            .then(() => { /* onAuthStateChanged handles UI */ })
                            .catch((error) => { 
                                console.error("Login failed:", error); 
                                if(authStatus) authStatus.textContent = `Error: ${error.message}`; 
                            }); 
                    });
                }
                if (logoutButton) {
                    logoutButton.addEventListener('click', () => { 
                        authSignOut(auth).catch((error) => console.error("Sign-out failed:", error)); 
                    });
                }
            } else {
                console.warn("Firebase Auth object not found on window. OMSI Tools auth will not function.");
                updateAuthUI(null); 
            }

            if (stageScheduleButton) stageScheduleButton.addEventListener('click', handleStageSchedule);
            if (applyNowButton) applyNowButton.addEventListener('click', handleApplyNow);
            if (viewArrivalsButton) viewArrivalsButton.addEventListener('click', () => { window.location.href = "omsi_arrivals.html"; });
            if (addEntryButton) addEntryButton.addEventListener('click', handleAddOrUpdateEntry);
            if (updateEntryButton) updateEntryButton.addEventListener('click', handleAddOrUpdateEntry);
            if (cancelEditButton) cancelEditButton.addEventListener('click', resetForm);
            if (countFileInput) countFileInput.addEventListener('change', handleCountFileUpload);
            if(filterStopIDInput) filterStopIDInput.addEventListener('input', () => { activeFilters.stopID = filterStopIDInput.value; renderScheduleTable(); });
            if(filterLineNameInput) filterLineNameInput.addEventListener('input', () => { activeFilters.lineName = filterLineNameInput.value; renderScheduleTable(); });
            if(filterOperatingProfileInput) filterOperatingProfileInput.addEventListener('input', () => { activeFilters.operatingProfile = filterOperatingProfileInput.value; renderScheduleTable(); });
            if(clearFiltersButton) clearFiltersButton.addEventListener('click', () => { filterStopIDInput.value = ''; activeFilters.stopID = ''; filterLineNameInput.value = ''; activeFilters.lineName = ''; filterOperatingProfileInput.value = ''; activeFilters.operatingProfile = ''; sortConfig = { key: null, direction: 'asc' }; renderScheduleTable(); });
            document.querySelectorAll('#currentScheduleTableContainer th[data-sortkey]').forEach(headerCell => { headerCell.addEventListener('click', () => { const sortKey = headerCell.dataset.sortkey; if (sortConfig.key === sortKey) { sortConfig.direction = sortConfig.direction === 'asc' ? 'desc' : 'asc'; } else { sortConfig.key = sortKey; sortConfig.direction = 'asc'; } renderScheduleTable(); }); });
            if(inputStopID) { inputStopID.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); handleInputStopIDChange(); }); inputStopID.addEventListener('blur', handleInputStopIDChange); }
            if(inputLineName) { inputLineName.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); }); }
            if(bulkEditTargetStopIDInput) { bulkEditTargetStopIDInput.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); displayCurrentDetailsForBulkStopEdit(); }); bulkEditTargetStopIDInput.addEventListener('blur', displayCurrentDetailsForBulkStopEdit); }
            if(bulkEditTargetLineNameInput) { bulkEditTargetLineNameInput.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); }); }
            if(bulkUpdateDetailsButton) bulkUpdateDetailsButton.addEventListener('click', handleBulkUpdateStopDetails);
            if(bulkUpdateRouteDestinationButton) bulkUpdateRouteDestinationButton.addEventListener('click', handleBulkUpdateRouteDestination);
            if (selectEventRoute) selectEventRoute.addEventListener('change', populateImpactStopSelector);
            if (triggerEventButton) triggerEventButton.addEventListener('click', applyRandomEvent);
            if (closeStopButton) closeStopButton.addEventListener('click', () => handleStopStatusChange('close'));
            if (reopenStopButton) reopenStopButton.addEventListener('click', () => handleStopStatusChange('reopen'));
            if (saveRouteColourButton) saveRouteColourButton.addEventListener('click', handleSaveRouteColour);
            if (selectRouteNameColour) { selectRouteNameColour.addEventListener('change', () => { const selectedRoute = selectRouteNameColour.value; if (selectedRoute && customRouteColours[selectedRoute.toUpperCase()]) { inputRouteColour.value = customRouteColours[selectedRoute.toUpperCase()]; } else { inputRouteColour.value = DEFAULT_ROUTE_COLOUR_TOOLS; } }); }
            if (selectStopForDeparturesView) { selectStopForDeparturesView.addEventListener('change', displayDeparturesForSelectedStop); }
            
            // Event listener for setServiceMessageButton removed

            fetchBankHolidaysForSetup(); 
        });
    </script>
</body>
</html>
}
