<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMSI Tools - Extra Modules</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <link rel="manifest" href="/live-tracker/manifest-omsitoolsextra.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OMSI Extra Tools">
    <meta name="theme-color" content="#2c3e50">
    <link rel="apple-touch-icon" href="/live-tracker/assets/icons/apple-touch-icon-180x180.png">
    <style>
        @font-face {
    font-family: 'NJFont Medium Web';
    src: url('fonts/NJFont-Medium.ttf') format('truetype'); /* Relative path */
    font-weight: normal;font-style: normal;font-display: swap;
}
body {
    font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
    background: linear-gradient(135deg, #2c3e50, #34495e);
    color: #ecf0f1;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 1rem;
    margin:0;
}
.page-container {
    width: 100%;
    max-width: 1400px;
    margin: 0 auto;
}
#top-menu-bar_extra {
    background-color: rgba(0,0,0,0.25); padding: 0.75rem; border-radius: 0.5rem;
    margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    text-align: center; display: block;
}
.menu-button {
    cursor: pointer; background-color: #3498db; color: white;
    padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem;
    transition: background-color 0.2s; border: none; margin: 0.25rem;
}
.menu-button:hover { background-color: #2980b9; }
.tool-content-section {
    display: block;
    background-color: rgba(0,0,0,0.15); padding: 1.5rem;
    border-radius: 0.5rem; margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}
#auth-section {
     margin-bottom: 1.5rem; background-color: rgba(0,0,0,0.15); padding: 1.5rem;
     border-radius: 0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

#current-profile-display-container {
    text-align: center; margin-bottom: 1.5rem; padding: 0.75rem;
    background-color: rgba(255,255,255,0.05); border-radius: 0.25rem; display: block;
}
#auth-section.auth-section-compact {
    padding: 0.75rem;
    background-color: rgba(255,255,255,0.05);
    border-radius: 0.25rem;
    text-align: center;
}

#logout-container_extra {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
}

.logged-in-username {
    font-size: 0.9rem;
    color: #FFFFFF;
}
#current-profile-display { font-size: 0.9rem; opacity: 1; font-style: normal; color: #FFFFFF;}
h1 { font-size: 2rem; margin-bottom: 1.5rem; font-weight: normal; text-align: center; color: #ffffff; }
h2 { font-size: 1.5rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: normal; border-bottom: 1px solid #7f8c8d; padding-bottom: 0.25rem;}
h3.subsection-title { font-size: 1.25rem; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: normal; color: #e0e0e0; border-bottom: 1px solid rgba(127,140,141,0.5); padding-bottom: 0.2rem;}
.subsection {
    background-color: rgba(0,0,0,0.1); padding: 1rem; border-radius: 0.375rem;
    margin-top: 1rem; margin-bottom: 1rem; border: 1px solid rgba(127,140,141,0.2);
}
.form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;}
.form-field-group { margin-bottom: 1rem; }
label { display: block; margin-bottom: 0.25rem; font-size: 0.85rem; color: #bdc3c7; }
input[type="text"], input[type="email"], input[type="password"], input[type="time"],
input[type="color"], input[type="number"], input[type="date"], input[type="datetime-local"],
select, textarea {
    width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
    background-color: #34495e; color: #ecf0f1; font-size:0.9rem; box-sizing: border-box;
}
input[type="date"]::-webkit-calendar-picker-indicator,
input[type="datetime-local"]::-webkit-calendar-picker-indicator {
    filter: invert(0.8); cursor:pointer;
}
select option { background-color: #34495e; color: #ecf0f1; }
.button {
    cursor: pointer; background-color: #3498db; color: white;
    padding: 0.5rem 0.8rem;
    border-radius: 0.25rem; font-size: 0.9rem;
    transition: background-color 0.2s; border: none; margin-right: 0.5rem; margin-top:0.5rem;
    display: inline-block;
    text-align: center;
    vertical-align: middle;
    box-sizing: border-box;
}
.button:hover { background-color: #2980b9; }
.button.secondary { background-color: #e74c3c; }
.button.secondary:hover { background-color: #c0392b; }
.button.save { background-color: #27ae60; }
.button.save:hover { background-color: #229954; }
.button.tertiary { background-color: #f39c12; }
.button.tertiary:hover { background-color: #e67e22; }
.button.neutral { background-color: #7f8c8d; }
.button.neutral:hover { background-color: #95a5a6; color: #2c3e50; }
.button.small-action { padding: 0.2rem 0.4rem; font-size: 0.8rem; margin: 0 0.15rem; line-height: 1; min-width: 20px; text-align:center; font-weight: bold;}

/* --- ADD THESE STYLES FOR DISABLED BUTTONS --- */
.button:disabled,
.button[disabled] { /* Targets buttons with the disabled attribute */
    background-color: #5D6D7E !important; /* A muted grey. Use !important to override specific button colors like .save or .secondary when disabled */
    color: #a0a0a0 !important;             /* Lighter grey text for contrast */
    cursor: not-allowed;        /* This shows the "no entry" sign cursor */
    opacity: 0.65;              /* Makes it look more faded/disabled */
    /* Prevent any hover style changes that might imply interactivity */
    box-shadow: none;           /* Remove any box-shadow if present on normal buttons */
}

.schedule-generator-input {
    width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
    background-color: #34495e; color: #ecf0f1; font-size: 0.9rem;
}

#masterStopListUL_extra li.master-stop-list-item {
    display: grid;
    grid-template-columns: 2.5fr 1.5fr 1fr;
    gap: 1rem; padding: 0.75rem 0.5rem;
    border-bottom: 1px solid #34495e;
    transition: background-color 0.15s ease-in-out; align-items: start;
}
#masterStopListUL_extra li.master-stop-list-item:last-child { border-bottom: none; }
.master-stop-original-info .stop-name-master { font-weight: bold; color: #ecf0f1; font-size: 1.05em; }
.master-stop-original-info .stop-direction-master { font-size: 0.85em; color: #95a5a6; margin-bottom: 0.3rem; }
.master-stop-original-info .stop-id-master { font-weight: normal; color: #bdc3c7; font-size: 0.95em; }
.master-stop-original-info .stop-details-grid { display: grid; grid-template-columns: auto 1fr; gap: 0.2rem 0.8rem; font-size: 0.85em; margin-top: 0.4rem; }
.master-stop-original-info .detail-label { font-weight: normal; color: #bdc3c7; opacity: 0.8; }
.master-stop-original-info .detail-value { color: #ecf0f1; }
.master-stop-original-info .detail-value.status-closed { color: #e74c3c; font-weight: bold; }
.master-stop-original-info .detail-value.status-open { color: #2ecc71; }
.master-stop-original-info .serving-routes-container { margin-top: 0.4rem; margin-bottom: 0.2rem; display: flex; flex-wrap: wrap; gap: 0.3em; padding: 0.25rem 0;}
.master-stop-new-id-section label { font-size: 0.8em; display: block; margin-bottom: 0.2em; color: #bdc3c7; }
.master-list-new-id-input { margin-bottom: 0.25rem; }
.master-list-row-warning { font-size: 0.8em; color: #f39c12; min-height: 1.2em; margin-top: 0.25rem; }
.master-stop-actions { margin-top: 0rem; padding-top: 0rem; border-top: none; display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-start; }
.master-stop-actions .button { width: 100%; margin: 0; }
.route-tile-tools-list {
    display: inline-block; padding: 0.2em 0.55em; margin-right: 0.3em; margin-bottom: 0.3em;
    border-radius: 0.25rem; font-size: 0.8em; font-weight: bold; color: white;
    text-align: center; line-height: 1.3; min-width: 28px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.25); vertical-align: middle;
}
#newStopIdAvailability_extra { font-size: 0.8em; min-height: 1.1em; margin-top: 0.25rem; }

.selectable-route-tile-container {
    display: flex;
    flex-wrap: wrap;
    gap: 0.6rem;
    padding: 0.25rem 0;
}
.selectable-route-tile {
    display: inline-block;
    padding: 0.4em 0.8em;
    border-radius: 0.25rem;
    font-size: 0.9em;
    font-weight: bold;
    text-align: center;
    line-height: 1.4;
    min-width: 40px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    cursor: pointer;
    border: 2px solid transparent;
    transition: border-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
}
.selectable-route-tile:hover {
    transform: translateY(-1px);
}
.selectable-route-tile.selected {
    border-color: #f1c40f !important;
    box-shadow: 0 0 8px 1px #f1c40f !important;
}

#duplicateStopsByNameDirResults_extra ul { list-style: none; padding-left: 0; }
#duplicateStopsByNameDirResults_extra li { margin-bottom: 0rem; }
.duplicate-set-to-merge {
    border: 1px solid #4a5568;
    padding: 0.75rem;
    margin-bottom: 0.75rem;
    border-radius: 0.25rem;
    background-color: rgba(0,0,0,0.05);
}
.duplicate-set-to-merge p { margin-bottom: 0.35rem; }
.duplicate-set-to-merge .stop-id-options label {
    display: block;
    margin-bottom: 0.25rem;
    font-size: 0.9em;
    cursor: pointer;
}
 .duplicate-set-to-merge .stop-id-options input[type="radio"] {
    margin-right: 0.35em;
    vertical-align: middle;
}

#rsg-stop-sequence-list-extra li {
    display: flex;
    flex-direction: column;
    padding: 0.6rem 0.5rem;
    border-bottom: 1px solid #4A5568;
    background-color: rgba(255,255,255,0.03);
    cursor: grab;
}
#rsg-stop-sequence-list-extra li:active {
    cursor: grabbing;
    background-color: rgba(255,255,255,0.07);
}
#rsg-stop-sequence-list-extra li.rsg-dragging-placeholder {
    opacity: 0.5;
    background-color: #567a9a;
    border: 1px dashed #ecf0f1;
}
#rsg-stop-sequence-list-extra li:last-child {
    border-bottom: none;
}

.rsg-li-main-content {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    margin-bottom: 0.5rem;
}

#rsg-stop-sequence-list-extra .rsg-stop-info {
    flex-grow: 1;
    margin-right: 1rem;
}
#rsg-stop-sequence-list-extra .rsg-stop-name {
    font-weight: bold;
}
#rsg-stop-sequence-list-extra .rsg-stop-id {
    font-size: 0.85em; color: #bdc3c7; margin-left: 0.5em;
}
#rsg-stop-sequence-list-extra .rsg-stop-actions {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}
#rsg-stop-sequence-list-extra .rsg-stop-actions button {
    padding: 0.15rem 0.35rem;
    font-size: 0.75rem;
    line-height: 1;
}
#rsg-stop-sequence-list-extra .rsg-time-adjustment-input {
    width: 70px;
    padding: 0.25rem;
    font-size: 0.85em;
    text-align: center;
}

.rsg-copy-adjustment-buttons-container {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
    margin-top: 0.5rem;
    align-items: center;
    width: 100%;
    padding-top: 0.3rem;
    border-top: 1px solid rgba(127,140,141,0.15);
}
.rsg-copy-adjustment-buttons-container .button.copy-adj-button {
    font-size: 0.7em;
    padding: 0.2em 0.5em;
    line-height: 1.3;
    white-space: nowrap;
    margin: 0;
    background-color: #546E7A;
    color: white;
}
.rsg-copy-adjustment-buttons-container .button.copy-adj-button:hover {
    background-color: #607D8B;
}

#dpo-selectable-profiles-container-extra > div,
#rsg-selectable-profiles-container-extra > div {
    display: inline-flex;
    align-items: center;
    background-color: #4A5568;
    color: #ecf0f1;
    padding: 0.4em 0.8em;
    border-radius: 0.25rem;
    border: 1px solid transparent;
    cursor: pointer;
    transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

#dpo-selectable-profiles-container-extra > div > label,
#rsg-selectable-profiles-container-extra > div > label {
    font-size: 0.9em;
    font-weight: normal;
    cursor: pointer;
    line-height: 1.4;
    /* The color is inherited from the parent div or can be set here if needed */
}

#dpo-selectable-profiles-container-extra > div > input[type="checkbox"],
#rsg-selectable-profiles-container-extra > div > input[type="checkbox"] {
    margin-right: 8px;
    vertical-align: middle;
    height: 1em;
    width: 1em;
}

#dpo-selectable-profiles-container-extra > div:has(input[type="checkbox"]:checked),
#rsg-selectable-profiles-container-extra > div:has(input[type="checkbox"]:checked) {
    border-color: #f1c40f !important;
    box-shadow: 0 0 6px 1px #f1c40f !important;
}

#dpo-selectable-profiles-container-extra > div:hover,
#rsg-selectable-profiles-container-extra > div:hover {
    background-color: #5D6D7E;
}

/* General label styling for the text within the profile containers if not handled by the above.
   The rule #rsg-selectable-profiles-container-extra label (and its DPO equivalent) 
   might become redundant if the div > label selector above is sufficient for all text styling within the tile.
   You can test this and remove this more general block if it's not needed or causes conflicts.
*/
#rsg-selectable-profiles-container-extra label,
#dpo-selectable-profiles-container-extra label {
    color: #ecf0f1;
    font-size: 0.85em; /* This was your original general label size for these containers */
     /* margin-right for label itself may not be needed if wrapped in styled div and using gap on parent */
}
#rsg-selectable-profiles-container-extra > div { /* Assuming each checkbox+label is wrapped in a div */
    display: inline-flex; 
    align-items: center;
    background-color: #4A5568; 
    padding: 0.3em 0.6em;
    border-radius: 0.25rem;
    margin-right: 0.5rem;
    margin-bottom: 0.5rem;
    border: 1px solid transparent; 
}
#rsg-selectable-profiles-container-extra > div:has(input[type="checkbox"]:checked) { 
    border-color: #f1c40f;
    box-shadow: 0 0 5px #f1c40f;
}


#rsg-stop-search-results-extra {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid #4A5568;
    border-radius: 0.25rem;
    background-color: #34495e;
    margin-top: 0.25rem;
}
#rsg-stop-search-results-extra .rsg-search-result-item {
    padding: 0.5rem 0.6rem;
    cursor: pointer;
    border-bottom: 1px solid #2c3e50;
}
#rsg-stop-search-results-extra .rsg-search-result-item:last-child {
    border-bottom: none;
}
#rsg-stop-search-results-extra .rsg-search-result-item:hover {
    background-color: #4a6a80;
}
#rsg-stop-search-results-extra .rsg-search-stop-name {
    font-weight: bold; display: block;
}
#rsg-stop-search-results-extra .rsg-search-stop-details {
    font-size: 0.8em; color: #bdc3c7; display: block; margin-top:0.1em;
}
#rsg-stop-search-results-extra .rsg-search-serving-routes {
    margin-top: 0.3em;
}

.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
}

.rpd-profile-tile {
    background-color: #4A5568;
    color: white;
}

.rsg-modal {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    z-index: 1050;
    display: flex;
    justify-content: center;
    align-items: center;
}

.rsg-modal-content {
    background: linear-gradient(145deg, #3a506b, #2c3e50);
    color: #ecf0f1;
    padding: 20px 25px;
    border-radius: 8px;
    width: 90%;
    max-width: 500px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    border: 1px solid #4a6a80;
}

.rsg-modal-content h4 {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1.3em;
    color: #ffffff;
    border-bottom: 1px solid #567a9a;
    padding-bottom: 0.5rem;
}

.rsg-modal-content .form-field-group {
    margin-bottom: 1rem;
}
.rsg-modal-content label {
    font-size: 0.9em;
}
.rsg-modal-content input.schedule-generator-input {
    background-color: #2c3e50;
    border-color: #567a9a;
}

.rsg-modal-actions {
    margin-top: 1.5rem;
    text-align: right;
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
}
.rsg-modal-actions .button {
    margin-top: 0;
}
/* Style for checkbox items within the cancel modal */
#sru-cancel-modal-checkboxes-container-extra .sru-cancel-time-item label {
    color: #ecf0f1; /* Ensure label text is light */
    font-size: 0.9em;
    cursor: pointer;
}
#sru-cancel-modal-checkboxes-container-extra .sru-cancel-time-item input[type="checkbox"] {
    margin-right: 8px;
    vertical-align: middle;
}
#sru-cancel-modal-checkboxes-container-extra .sru-cancel-time-item {
    display: block; /* Each checkbox on a new line */
    margin-bottom: 0.4rem;
    padding: 0.2rem 0.1rem;
}
    </style>
</head>
<body>
    <div class="page-container">
        <h1>OMSI Tools - Extra Modules</h1>
        <div id="global-notification-banner" style="display: none; padding: 12px 15px; background-color: #27ae60; color: white; text-align: center; position: sticky; top: 0; left: 0; width: 100%; z-index: 1060; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
        </div>

        <div id="auth-section" class="section">
            <h2>Admin Login</h2>
            <div id="login-form-container_extra">
                <form id="adminLoginForm_extra">
                    <div class="form-grid" style="grid-template-columns: 1fr;">
                        <div><label for="inputEmail_extra">Email</label><input type="email" id="inputEmail_extra" autocomplete="email"></div>
                        <div><label for="inputPassword_extra">Password</label><input type="password" id="inputPassword_extra" autocomplete="current-password"></div>
                    </div>
                    <button id="loginButton_extra" type="submit" class="button">Login</button>
                </form>
                <p id="auth-status_extra" style="margin-top: 0.5em; color: #f1c40f;"></p>
            </div>
            <div id="logout-container_extra"> <span id="loggedInUserEmail_extra" class="logged-in-username"></span>
                <button id="logoutButton_extra" class="button secondary small-action">Logout</button>
            </div>
        </div>

        <div id="current-profile-display-container" style="display:block;"> <p id="current-profile-display">Today's Operating Profile: (loading...)</p>
        </div>

        <div id="top-menu-bar_extra" style="display:block;"> <div id="main-menu-buttons_extra">
                <button class="menu-button" data-section="day-profile-override-section_extra">Day Profile Override</button>
                <button class="menu-button" data-section="stop-manager-tool-section_extra">Stop Management & Creation</button>
                <button class="menu-button" data-section="global-route-deletion-section_extra">Global Route Deletion</button>
                <button class="menu-button" data-section="route-schedule-generator-section_extra">Route Schedule Generator</button>
                <button class="menu-button" data-section="route-profile-deletion-section_extra">Route Profile Deletion</button>
                <button class="menu-button" data-section="service-analyzer-section_extra">Service Analyzer</button>
                <button class="menu-button" data-section="timetable-exporter-section_extra">Timetable Exporter</button>
                <button class="menu-button" data-section="scheduled-route-updates-section_extra">Scheduled Tasks</button>
                <button class="menu-button" data-section="scheduled-route-deletion-section_extra">Schedule Route Deletion</button>
            </div>
        </div>

        <div id="tool-sections-wrapper_extra">

            <div id="timetable-exporter-section_extra" class="tool-content-section section">
                <h2>Route Timetable Exporter</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Select a route to download its full timetable as a PDF file.</p>
                <div class="subsection">
                    <h3 class="subsection-title">Select Route</h3>
                    <div class="form-grid" style="grid-template-columns: 3fr 1fr; align-items: end;">
                        <div>
                            <label for="tte-routeName-select-extra">Route Name (Select or Type):</label>
                            <select id="tte-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Route --</option>
                            </select>
                            <input type="text" id="tte-routeName-input-extra" class="schedule-generator-input" placeholder="Or Type Route Name">
                        </div>
                        <div>
                            <button id="tte-downloadTimetable-button-extra" class="button save" style="width:100%;">Download Timetable</button>
                        </div>
                    </div>
                    <p id="tte-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
                </div>
            </div>

            <div id="service-analyzer-section_extra" class="tool-content-section section">
                <h2>Service Analyzer</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity:0.8;">
                    Analyze stop coverage and view all routes serving a stop.
                </p>
                <div class="form-grid" style="grid-template-columns: 2fr 1fr; align-items: end;">
                    <div>
                        <label for="service-analyzer-stop-select-extra">Stop Name/ID (Select or Type):</label>
                        <select id="service-analyzer-stop-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                            <option value="">-- Select Stop --</option>
                        </select>
                        <input type="text" id="service-analyzer-stop-input-extra" class="schedule-generator-input" placeholder="Or Type Stop Name/ID">
                    </div>
                </div>
                <div id="service-analyzer-stop-summary-extra" style="margin-top:1rem; min-height:3em; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border: 1px solid rgba(127,140,141,0.2);">Select a stop to analyze.</div>
            </div>

            <div id="day-profile-override-section_extra" class="tool-content-section section">
                <h2>Operational Day Profile Override</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Use this tool to manually set a specific operating profile for an upcoming date...
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">Select Date and Override Profile</h3>
                    <div class="form-grid" style="grid-template-columns: 1fr; gap: 1rem;">
                        <div>
                            <label for="overrideDate_extra">Date to Override:</label>
                            <input type="date" id="overrideDate_extra" class="schedule-generator-input">
                        </div>
                        <div class="form-field-group">
                            <label>Operating Profile(s) (select one or more):</label>
                            <div id="dpo-selectable-profiles-container-extra" class="selectable-route-tile-container" style="background-color: rgba(0,0,0,0.05); padding: 0.5rem; border-radius: 0.25rem; min-height:30px;">
                                <p id="dpo-profiles-placeholder-extra" style="font-size:0.85em; opacity:0.7;">Loading profiles...</p>
                            </div>
                            <div style="margin-top:0.25rem; display:flex; justify-content:space-between; align-items:center;">
                                <span style="font-size:0.8em;">Selected Override Profile: <strong id="dpo-selected-profiles-display-extra" style="color:#f1c40f;">(None selected)</strong></span>
                                <button id="dpo-clear-profile-checkboxes-button-extra" class="button small-action neutral">Clear Sel.</button>
                            </div>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem;">
                            <button id="setOverrideButton_extra" class="button save">Set Override for Date</button>
                            <button id="clearOverrideButton_extra" class="button secondary" style="display:none;">Clear Override for Date</button>
                        </div>
                        <div style="grid-column: 1 / -1; margin-top: 0.5rem; font-size: 0.85em;">
                            <p><strong>Selected Date:</strong> <span id="selectedDateDisplay_extra">(select a date)</span></p>
                            <p><strong>Auto Profile for Date:</strong> <span id="autoProfileForSelectedDate_extra">(select a date)</span></p>
                            <p><strong>Current Override for Date:</strong> <span id="currentOverrideForSelectedDate_extra" style="font-weight:bold;">(select a date)</span></p>
                            <p id="overrideStatusMessage_extra" style="min-height:1.2em; margin-top: 0.5rem; font-weight:bold;"></p>
                        </div>
                    </div>
                    </div>
                <div class="subsection" style="margin-top: 2rem;">
                    <h3 class="subsection-title">Currently Active Overrides (Next 30 Days)</h3>
                    <div id="activeOverridesList_extra" style="max-height: 200px; overflow-y: auto; background-color: rgba(0,0,0,0.05); padding: 0.5rem; border-radius: 0.25rem;">
                        <p>Loading active overrides...</p>
                    </div>
                </div>
            </div>

            <div id="stop-manager-tool-section_extra" class="tool-content-section section">
                 <h2>Stop Management & Creation (Live Updates)</h2>
                 <div class="subsection">
                    <h3 class="subsection-title">Add New Stop Definition (Placeholder)</h3>
                    <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); align-items: end;">
                        <div>
                            <label for="inputNewStopName_extra">Stop Name:</label>
                            <input type="text" id="inputNewStopName_extra" class="schedule-generator-input" placeholder="e.g., High Street / Central Avenue">
                        </div>
                        <div>
                            <label for="selectNewStopIdFormat_extra">ID Format Suggestion:</label>
                            <select id="selectNewStopIdFormat_extra" class="schedule-generator-input">
                                <option value="NUM">Numeric (e.g., 101)</option>
                                <option value="BP">Bus Point (e.g., BP123)</option>
                                <option value="LE">Location E (e.g., LE45)</option>
                                <option value="RO">Route Objective (e.g., RO67)</option>
                                <option value="Custom">Custom (type below)</option>
                            </select>
                        </div>
                        <div>
                            <label for="inputNewStopId_extra">New Stop ID (Uppercase Alphanumeric):</label>
                            <input type="text" id="inputNewStopId_extra" class="schedule-generator-input" placeholder="Auto-suggest or type custom">
                            <div id="newStopIdAvailability_extra"></div>
                        </div>
                         <div>
                            <label for="inputNewStopDirection_extra">"Towards" Text (Optional):</label>
                            <input type="text" id="inputNewStopDirection_extra" class="schedule-generator-input" placeholder="e.g., Town Centre">
                        </div>
                        <div style="padding-bottom:0.05rem;">
                            <button id="buttonAddNewStop_extra" class="button save">Add Stop Definition</button>
                        </div>
                    </div>
                    <p id="addNewStopStatus_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Bulk Add Stop Definitions (Replaces ALL Existing Stops/Schedules)</h3>
                     <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        <strong>DANGER ZONE:</strong> Uploading an Excel (.xlsx) file here will <strong>DELETE ALL current schedules and stop definitions</strong> from Firebase and replace them with placeholder entries derived from the uploaded file.
                        The Excel file should have columns (no headers needed in file): UserProvidedStopID (optional), StopName (required if ID not provided), Direction (optional), LineName(s) (comma-separated, optional, defaults to "INFO_ONLY").
                    </p>
                    <input type="file" id="fileInputBulkAddStops_extra" accept=".xlsx" style="display:none;">
                    <label for="fileInputBulkAddStops_extra" class="button neutral">Choose Excel File (.xlsx)</label>
                    <span id="fileNameBulkAddStops_extra" style="margin-left:10px; font-size:0.9em;">No file selected.</span>
                    <button id="buttonBulkAddNewStops_extra" class="button secondary" style="margin-top:0.75rem;">Bulk Replace All Data With Excel Definitions</button>
                    <p id="bulkAddNewStopsStatus_extra" style="min-height:1.2em; margin-top:0.5rem; white-space:pre-wrap;"></p>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Master Stop List & Actions (Live Data)</h3>
                    <div class="form-field-group">
                        <label for="masterStopListFilterInput_extra">Filter Stops (by ID, Name, Direction, Route, Status):</label>
                        <input type="text" id="masterStopListFilterInput_extra" class="schedule-generator-input" placeholder="Type to filter...">
                    </div>
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
                        <button id="refreshMasterStopListButton_extra" class="button neutral">Refresh List</button>
                        <button id="exportUniqueStopsButton_extra" class="button" style="background-color: #16a085;">Export Stops to Excel</button>
                    </div>
                    <p id="masterStopListStatus_extra" style="min-height:1.2em; margin-bottom:0.5rem; font-size:0.9em;"></p>
                    <ul id="masterStopListUL_extra" style="max-height: 500px; overflow-y: auto; border: 1px solid #4A5568; padding: 0; list-style:none; border-radius:0.25rem;">
                        <p style="text-align:center; padding:1rem; opacity:0.7;">Loading stops...</p>
                    </ul>
                    <button id="applyMasterListStopIdChangesButton_extra" class="button save" style="margin-top:1rem;">Apply All Proposed Stop ID Changes (Bulk)</button>
                    <p id="masterListApplyChangesStatus_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Stop Name/Direction Duplicate Management</h3>
                    <button id="findDuplicateStopsByNameDirButton_extra" class="button tertiary">Find Duplicates (Name/Dir)</button>
                    <div id="duplicateStopsByNameDirResults_extra" style="margin-top:0.75rem;">
                        <p>Click button above to scan for stops with identical names and directions but different StopIDs.</p>
                    </div>
                </div>
            </div>

            <div id="global-route-deletion-section_extra" class="tool-content-section section">
                <h2>Global Route Deletion (Live)</h2>
                <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                    Click on route tiles below to select them for deletion. This action deletes ALL data for the selected route(s) from the live schedule, including global and stop-specific color settings. This is irreversible.
                </p>
                <div class="form-field-group">
                    <label style="display:block; margin-bottom:0.5rem;">Select Route(s) to Delete Globally by clicking tiles:</label>
                    <div id="globalRouteDeletionListContainer_el_extra" class="subsection" style="max-height: 300px; overflow-y: auto; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border: 1px solid rgba(127,140,141,0.2);">
                        <p>Loading routes...</p>
                    </div>
                </div>
                <button id="deleteEntireRouteButton_el_extra" class="button secondary" style="margin-top: 0.5rem;">Delete Selected Route(s) (Live)</button>
                <p id="deleteEntireRouteStatusMessage_el_extra" style="min-height:1.2em; margin-top:0.75rem;"></p>
            </div>

            <div id="route-profile-deletion-section_extra" class="tool-content-section section">
                <h2>Selective Route Profile Deletion</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Select a route, optionally a specific destination, and then one or more operating profiles to delete all associated schedule entries from the live Firebase data.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">1. Select Route & Destination (Optional)</h3>
                    <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));">
                        <div>
                            <label for="rpd-route-name-select-extra">Route Name (Select or Type):</label>
                            <select id="rpd-route-name-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Existing Route --</option>
                            </select>
                            <input type="text" id="rpd-route-name-input-extra" class="schedule-generator-input" placeholder="e.g., 4X or type new">
                        </div>
                        <div>
                            <label for="rpd-destination-name-select-extra">Destination (Optional - Select or Type):</label>
                            <div style="display:flex; align-items: center; gap: 0.5rem;">
                                <select id="rpd-destination-name-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem; flex-grow:1;">
                                    <option value="">-- Optional: All Destinations --</option>
                                </select>
                                <button id="rpd-clear-destination-button-extra" class="button small-action neutral" title="Clear Destination Filter" style="display:none;">âœ•</button>
                            </div>
                            <input type="text" id="rpd-destination-name-input-extra" class="schedule-generator-input" placeholder="Leave blank for all destinations">
                        </div>
                    </div>
                </div>
                <div class="subsection">
                    <h3 class="subsection-title">2. Select Profile(s) to Delete for this Route/Destination</h3>
                    <div id="rpd-profile-list-container-extra" style="min-height: 50px; padding:0.5rem; background-color: rgba(0,0,0,0.05); border-radius:0.25rem; border:1px solid #4A5568;">
                        <p style="font-size:0.85em; opacity:0.7;">Select a route (and optionally destination) above.</p>
                    </div>
                </div>
                <div class="subsection">
                     <h3 class="subsection-title">3. Execute Deletion</h3>
                    <button id="rpd-delete-profiles-button-extra" class="button secondary">Delete Selected Profile(s) for Route/Destination</button>
                    <p id="rpd-status-message-extra" style="min-height:1.2em; margin-top: 0.75rem; font-weight:bold;"></p>
                </div>
            </div>

            <div id="route-schedule-generator-section_extra" class="tool-content-section section">
                <h2>Route Schedule Generator</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity:0.8;">
                    Define a route, its operating profile(s), primary destination, a sequence of stops with inter-stop timings, and departure times for the first stop. Then generate, preview, and add the full schedule to the main working schedule or schedule it for a future go-live.
                </p>

                <div>
                    <div class="subsection">
                        <h3 class="subsection-title">1. Route, Profile & Destination</h3>
                        <div class="form-field-group">
                            <label for="rsg-routeName-select-extra">Route Name (Select or Type):</label>
                            <select id="rsg-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Existing Route --</option>
                            </select>
                            <input type="text" id="rsg-routeName-input-extra" class="schedule-generator-input" placeholder="e.g., 4X or type new">
                        </div>
                        <div class="form-field-group">
                            <label>Operating Profile(s) (select one or more):</label>
                            <div id="rsg-selectable-profiles-container-extra" class="selectable-route-tile-container" style="background-color: rgba(0,0,0,0.05); padding: 0.5rem; border-radius: 0.25rem; min-height:30px;">
                                <p id="rsg-profiles-placeholder-extra" style="font-size:0.85em; opacity:0.7;">Loading profiles...</p>
                            </div>
                            <div style="margin-top:0.25rem; display:flex; justify-content:space-between; align-items:center;">
                                <span style="font-size:0.8em;">Currently Selected: <strong id="rsg-selected-profiles-display-extra" style="color:#f1c40f;">(None selected)</strong></span>
                                <button id="rsg-clear-profile-checkboxes-button-extra" class="button small-action neutral">Clear Sel.</button>
                            </div>
                        </div>
                        <div class="form-field-group">
                            <label for="rsg-destinationName-select-extra">Primary Destination (Select or Type):</label>
                            <select id="rsg-destinationName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Existing Destination --</option>
                            </select>
                            <input type="text" id="rsg-destinationName-input-extra" class="schedule-generator-input" placeholder="e.g., City Centre or type new">
                        </div>
                    </div>

                    <div class="subsection">
                        <h3 class="subsection-title">2. Stop Sequence & Timings</h3>
                        <div class="form-field-group">
                            <label for="rsg-stop-search-input-extra">Add Stop to Sequence (Search by Name/ID):</label>
                            <input type="text" id="rsg-stop-search-input-extra" class="schedule-generator-input" placeholder="Type to search stops...">
                            <div id="rsg-stop-search-results-extra"></div>
                        </div>
                        <div class="form-field-group" style="margin-top: 0.75rem; margin-bottom: 0.75rem;">
                            <button id="rsg-open-copy-modal-button-extra" class="button neutral" style="width:100%;">Copy Stop Sequence From Route</button>
                        </div>
                        <div class="form-field-group">
                            <label>Current Stop Sequence (Drag to reorder):</label>
                            <ul id="rsg-stop-sequence-list-extra" style="border: 1px solid #4A5568; padding: 0.5rem; border-radius: 0.25rem; background-color: rgba(0,0,0,0.05);">
                                <p id="rsg-stop-sequence-placeholder-extra" style="text-align:center; opacity:0.7; padding:1rem;">Search and add stops above.</p>
                            </ul>
                        </div>
                        <div id="rsg-first-stop-times-container-extra" class="form-field-group" style="display:none;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                                <label for="rsg-first-stop-times-input-extra">Departure Times for First Stop (HH:MM, TAB separated):</label>
                                <button id="rsg-pull-first-stop-times-button-extra" class="button neutral" style="padding: 0.2em 0.6em; font-size: 0.8em; line-height: 1.2;">Pull Current Times</button>
                            </div>
                            <textarea id="rsg-first-stop-times-input-extra" class="schedule-generator-input" rows="2" placeholder="e.g., 07:00	07:15	07:30 (use Tab to separate)"></textarea>
                        </div>
                    </div> <div id="rsg-schedule-preview-container-extra" class="subsection" style="margin-top:1.5rem; display:none;">
                        <h3 class="subsection-title">Schedule Preview</h3>
                        <div style="max-height: 400px; overflow-y: auto;">
                            <table id="rsg-preview-table-extra" style="width:100%; border-collapse:collapse; font-size:0.85em;">
                                <thead>
                                    <tr style="background-color:#34495e;">
                                        <th style="padding:5px; border:1px solid #4A5568;">StopID</th>
                                        <th style="padding:5px; border:1px solid #4A5568;">StopName</th>
                                        <th style="padding:5px; border:1px solid #4A5568;">Time</th>
                                        <th style="padding:5px; border:1px solid #4A5568;">Route</th>
                                        <th style="padding:5px; border:1px solid #4A5568;">Dest</th>
                                        <th style="padding:5px; border:1px solid #4A5568;">Profile</th>
                                        <th style="padding:5px; border:1px solid #4A5568;">Offset</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="subsection">
                        <h3 class="subsection-title">3. Actions & Configurations</h3>
                        <div class="form-field-group" style="display: flex; margin-bottom: 0.5rem;">
                            <button id="rsg-generate-schedule-button-extra" class="button" style="flex: 1; margin-right: 0.25rem;">Generate Schedule Preview</button>
                            <button id="rsg-schedule-this-config-button-extra" class="button tertiary" style="flex: 1; margin-left: 0.25rem;">Schedule Current Setup</button>
                        </div>
                        <div class="form-field-group" style="display: flex; margin-bottom: 0.5rem;">
                            <button id="rsg-save-configuration-button-extra" class="button" style="flex: 1; margin-right: 0.25rem;">Save Current Setup</button>
                            <button id="rsg-add-to-working-schedule-button-extra" class="button neutral" style="flex: 1; margin-left: 0.25rem;" disabled>Add Preview to Working Schedule (Live)</button>
                        </div>

                        <div class="form-field-group" style="margin-top: 1rem;">
                             <button id="rsg-schedule-selected-configs-button-extra" class="button save" style="width:100%;" disabled>Schedule Selected Saved Configurations</button>
                        </div>

                        <div class="form-field-group" style="margin-top: 1rem;">
                             <label>Saved Configurations (click name to load, or tick to schedule):</label>
                             <div style="margin-bottom: 0.5em; padding: 0.25em 0;">
                                 <input type="checkbox" id="rsg-select-all-configs-checkbox-extra" style="vertical-align: middle; margin-right: 5px;">
                                 <label for="rsg-select-all-configs-checkbox-extra" style="cursor:pointer; color: #ecf0f1; font-size: 0.9em;">Select All (Everything)</label>
                             </div>
                             <div id="rsg-saved-configs-list-extra" style="border: 1px solid #4A5568; padding:0.25rem 0.5rem; border-radius: 0.25rem; background-color: rgba(0,0,0,0.05);">
                                <p id="rsg-no-saved-configs-message-extra" style="padding:0.5em; text-align:center; opacity:0.7;">Loading saved configurations...</p>
                             </div>
                             <p id="rsg-load-status-message-extra" style="font-size:0.8em; min-height:1.1em; margin-top:0.25rem;"></p>
                        </div>
                    </div>
                </div>

                <p id="rsg-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold; text-align:center;"></p>
                </div>

            <div id="scheduled-route-deletion-section_extra" class="tool-content-section section">
                <h2>Schedule Route Deletion</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Select a route and a future date/time to schedule its complete deletion from the live schedule and associated settings.
                    The deletion will need to be manually confirmed or processed from the "Scheduled Tasks" list when due.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">Select Route and Go-Live Time</h3>
                    <div class="form-grid" style="grid-template-columns: 2fr 1.5fr 1fr; align-items: end;">
                        <div>
                            <label for="srd-routeName-select-extra">Route Name (Select or Type):</label>
                            <select id="srd-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Route --</option>
                            </select>
                            <input type="text" id="srd-routeName-input-extra" class="schedule-generator-input" placeholder="Or Type Route Name">
                        </div>
                        <div>
                            <label for="srd-go-live-datetime-input-extra">Deletion Go-Live Date and Time:</label>
                            <input type="datetime-local" id="srd-go-live-datetime-input-extra" class="schedule-generator-input">
                        </div>
                        <div>
                            <button id="srd-schedule-deletion-button-extra" class="button secondary" style="width:100%;">Schedule Deletion</button>
                        </div>
                    </div>
                    <p id="srd-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
                </div>
            </div>

            <div id="scheduled-route-updates-section_extra" class="tool-content-section section">
                <h2>Scheduled Tasks</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity:0.8;">
                    View and manage route timetables and deletions scheduled to go live automatically.
                </p>

                <div class="subsection" id="sru-apply-all-batches-section-extra" style="margin-bottom: 2rem; border-bottom: 2px solid #7f8c8d; padding-bottom: 1.5rem; background-color: rgba(0,0,0,0.1);">
                    <h3 class="subsection-title" style="font-size: 1.3em; color: #66CCCC;">Apply All Pending Batches for a Specific Go-Live Time</h3>
                    <p style="font-size:0.9em; opacity:0.85; margin-bottom:1.2rem; color: #f1c40f;">
                        <strong>Important:</strong> Select a Go-Live Date/Time from the list below. Clicking "Apply All for Selected Time"
                        will process <strong>ALL</strong> pending timetable updates scheduled for that exact time, across <strong>ALL</strong> affected routes simultaneously.
                        For each affected route, its entire current schedule will be <strong>DELETED</strong> and replaced by the new schedule entries from the batch.
                        This is a significant bulk operation.
                    </p>
                    <div id="sru-batch-golive-radios-container-extra" style="margin-bottom: 1.2rem; background-color: rgba(0,0,0,0.08); padding: 1rem; border-radius: 0.375rem; border: 1px solid rgba(127,140,141,0.2);">
                        <p style="opacity:0.7;">Loading available batch go-live times...</p>
                    </div>
                    <button id="sru-apply-all-for-time-button-extra" class="button save" style="background-color: #e67e22; width:100%; padding: 0.75rem; font-size: 1em;" disabled>Apply All Updates for Selected Go-Live Time</button>
                    <p id="sru-apply-all-status-message-extra" style="min-height:1.5em; margin-top:1rem; font-weight:bold; text-align:center;"></p>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Individually Pending & Actionable Scheduled Tasks</h3>
                    <button id="sru-refresh-list-button-extra" class="button neutral" style="margin-bottom:0.75rem;">Refresh List</button>
                    <div id="sru-updates-list-container-extra" style="background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border:1px solid rgba(127,140,141,0.2);">
                        <p>Loading scheduled tasks...</p>
                    </div>
                </div>

                <div class="subsection" style="margin-top: 2.5rem; border-top: 2px solid #e74c3c; padding-top: 1.5rem; background-color: rgba(231, 76, 60, 0.05);">
                    <h3 class="subsection-title" style="color: #e74c3c; font-size:1.3em;">Global Cancellation - Danger Zone</h3>
                    <p style="font-size:0.9em; opacity:0.85; margin-bottom:1.2rem; color: #fAD7A0;">
                        <strong>EXTREME CAUTION:</strong> Clicking the button below will attempt to cancel <strong>ALL</strong> currently pending timetable updates
                        across <strong>ALL routes and ALL scheduled go-live times</strong>. This action cannot be easily undone.
                        <br>(Scheduled <i>route deletions</i> will NOT be affected by this button.)
                    </p>
                    <button id="sru-cancel-all-pending-updates-globally-button-extra" class="button secondary" style="width:100%; background-color: #c0392b; padding: 0.75rem; font-size: 1em;">
                        Cancel ALL Pending Timetable Updates (Global)
                    </button>
                    <p id="sru-cancel-all-global-status-message-extra" style="min-height:1.5em; margin-top:1rem; font-weight:bold; text-align:center;"></p>
                </div>
            </div>

        </div> </div> <div id="rsg-save-config-modal-extra" class="rsg-modal" style="display:none;">
        <div class="rsg-modal-content">
            <h4 style="margin-top:0;">Save Configuration As</h4>
            <div class="form-field-group">
                <label for="rsg-config-name-input-extra">Configuration Name:</label>
                <input type="text" id="rsg-config-name-input-extra" class="schedule-generator-input" placeholder="e.g., 4_Skippingdale_MFSch">
            </div>
            <div class="rsg-modal-actions">
                <button id="rsg-save-config-confirm-button-extra" class="button save">Save</button>
                <button id="rsg-save-config-cancel-button-extra" class="button neutral">Cancel</button>
            </div>
            <p id="rsg-save-config-modal-status-extra" style="min-height:1.2em; margin-top:0.75em; font-size:0.85em;"></p>
        </div>
    </div>

    <div id="rsg-copy-modal-extra" class="rsg-modal" style="display:none;">
        <div class="rsg-modal-content" style="max-width: 550px;">
            <h3 class="subsection-title" style="margin-top:0; padding-bottom: 0.5rem; border-color: #567a9a;">Copy Stops From Source</h3>
            <div class="form-field-group">
                <label for="rsg-copy-source-routeName-select-extra">Source Route (Select or Type):</label>
                 <select id="rsg-copy-source-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                    <option value="">-- Select Source Route --</option>
                </select>
                <input type="text" id="rsg-copy-source-routeName-input-extra" class="schedule-generator-input" placeholder="e.g., 10 or type new">
            </div>
            <div class="form-field-group">
                <label for="rsg-copy-source-operatingProfile-input-extra">Source Operating Profile:</label>
                <input type="text" id="rsg-copy-source-operatingProfile-input-extra" class="schedule-generator-input" placeholder="e.g., MFSch">
            </div>
            <div class="form-field-group">
                 <label for="rsg-copy-source-destinationName-select-extra">Source Destination (Select or Type):</label>
                 <select id="rsg-copy-source-destinationName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                    <option value="">-- Select Source Destination --</option>
                </select>
                <input type="text" id="rsg-copy-source-destinationName-input-extra" class="schedule-generator-input" placeholder="e.g., Hospital or type new">
            </div>
            <p id="rsg-copy-modal-status-extra" style="min-height:1.2em; margin-top:0.5em; font-size:0.85em;"></p>
            <div class="rsg-modal-actions">
                <button id="rsg-copy-modal-action-button-extra" class="button save">Copy Data</button>
                <button id="rsg-copy-modal-cancel-button-extra" class="button neutral">Cancel</button>
            </div>
        </div>
    </div>

    <div id="rsg-schedule-datetime-modal-extra" class="rsg-modal" style="display:none;">
        <div class="rsg-modal-content">
            <h4 style="margin-top:0;">Set Go-Live Date & Time</h4>
             <div class="form-field-group">
                <label for="rsg-go-live-datetime-input-extra">Scheduled Go-Live Date and Time:</label>
                <input type="datetime-local" id="rsg-go-live-datetime-input-extra" class="schedule-generator-input">
            </div>
            <div class="rsg-modal-actions">
                <button id="rsg-schedule-datetime-confirm-button-extra" class="button save">Confirm Schedule</button>
                <button id="rsg-schedule-datetime-cancel-button-extra" class="button neutral">Cancel</button>
            </div>
            <p id="rsg-schedule-datetime-modal-status-extra" style="min-height:1.2em; margin-top:0.75em; font-size:0.85em;"></p>
        </div>
    </div>

    <div id="sru-cancel-route-time-select-modal-extra" class="rsg-modal" style="display:none;">
        <div class="rsg-modal-content" style="max-width: 600px;">
            <h4 id="sru-cancel-modal-title-extra" style="margin-top:0;">Select Go-Live Time(s) to Cancel Updates</h4>
            <p id="sru-cancel-modal-route-info-extra" style="margin-bottom: 1rem; font-size: 0.9em;"></p>

            <div class="form-field-group">
                <div style="margin-bottom: 0.5em; padding: 0.25em 0; border-bottom: 1px solid #567a9a; margin-bottom: 0.75em;">
                    <input type="checkbox" id="sru-cancel-modal-select-all-times-extra" style="vertical-align: middle; margin-right: 5px;">
                    <label for="sru-cancel-modal-select-all-times-extra" style="cursor:pointer; color: #ecf0f1; font-size: 0.9em;">Select All Times Below</label>
                </div>
                <div id="sru-cancel-modal-checkboxes-container-extra" style="max-height: 200px; overflow-y: auto; padding: 0.5rem; border: 1px solid #567a9a; border-radius: 0.25rem; background-color: rgba(0,0,0,0.05);">
                    <p style="opacity:0.7;">Loading available times...</p>
                </div>
            </div>

            <div class="rsg-modal-actions">
                <button id="sru-cancel-modal-confirm-button-extra" class="button secondary">Confirm Cancellation for Selected Time(s)</button>
                <button id="sru-cancel-modal-cancel-button-extra" class="button neutral">Close</button>
            </div>
            <p id="sru-cancel-modal-status-extra" style="min-height:1.2em; margin-top:0.75em; font-size:0.85em;"></p>
        </div>
    </div>


    <script type="module">
      // Firebase App initialization (content unchanged)
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s", // Replace with your actual Firebase API Key
        authDomain: "omsi-c5505.firebaseapp.com", // Replace with your actual Firebase Auth Domain
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app", // Replace with your actual Firebase Database URL
        projectId: "omsi-c5505", // Replace with your actual Firebase Project ID
        storageBucket: "omsi-c5505.appspot.com", // Replace with your actual Firebase Storage Bucket
        messagingSenderId: "503595375440", // Replace with your actual Firebase Messaging Sender ID
        appId: "1:503595375440:web:356be6684b77ff5909ea55", // Replace with your actual Firebase App ID
        measurementId: "G-VN7X65V3F9" // Replace with your actual Firebase Measurement ID
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);

      window.firebaseOMSI = {
          database: database, auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut
      };
      document.dispatchEvent(new CustomEvent('firebaseReady', { detail: window.firebaseOMSI }));
    </script>

</body>
<script type="module">
      // Firebase App initialization (content unchanged)
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s", // Replace with your actual Firebase API Key
        authDomain: "omsi-c5505.firebaseapp.com", // Replace with your actual Firebase Auth Domain
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app", // Replace with your actual Firebase Database URL
        projectId: "omsi-c5505", // Replace with your actual Firebase Project ID
        storageBucket: "omsi-c5505.appspot.com", // Replace with your actual Firebase Storage Bucket
        messagingSenderId: "503595375440", // Replace with your actual Firebase Messaging Sender ID
        appId: "1:503595375440:web:356be6684b77ff5909ea55", // Replace with your actual Firebase App ID
        measurementId: "G-VN7X65V3F9" // Replace with your actual Firebase Measurement ID
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);

      window.firebaseOMSI = {
          database: database, auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut
      };
      document.dispatchEvent(new CustomEvent('firebaseReady', { detail: window.firebaseOMSI }));
    </script>

<script>
// --- Global State Variables ---
        let rsg_configKeyToRename_extra = null;
        let currentUser_extra = null;
        let pageSpecificSettings = {};
        let rsg_currentlyEditingConfigKey_extra = null;
        let rsg_currentlyEditingConfigDisplayName_extra = null;
        let rsg_isDirty = false;
        let rsg_batchScheduleItems = [];
        let sruCancelModalContext = { routeName: null };
        let scheduledRouteDeletions_extra = {};
        let stopToServingRoutesMap_extra = new Map();
        let ukBankHolidaysData_extra = { dates: [], titles: {} };
        const schoolHolidayDateRanges_extra = [
    { start: '2025-05-24', end: '2025-06-01' }, // Summer half term 2025
    { start: '2025-07-19', end: '2025-09-02' }, // Summer holidays 2025
    { start: '2025-10-25', end: '2025-11-02' }, // Autumn half term 2025
    { start: '2025-12-20', end: '2026-01-04' }, // Christmas 2025/26
    { start: '2026-02-14', end: '2026-02-22' }, // Spring half term 2026
    { start: '2026-04-03', end: '2026-04-20' }, // Easter 2026
    { start: '2026-05-23', end: '2026-05-31' }, // Summer half term 2026
    { start: '2026-07-18', end: '2026-09-02' }, // Summer holidays 2026
    { start: '2026-10-24', end: '2026-11-01' }, // Autumn half term 2026
    { start: '2026-12-19', end: '2027-01-04' }, // Christmas 2026/27
    { start: '2027-02-13', end: '2027-02-21' }, // Spring half term 2027
    { start: '2027-03-26', end: '2027-04-13' }, // Easter 2027
    { start: '2027-05-29', end: '2027-06-06' }, // Summer half term 2027
    { start: '2027-07-22', end: '2027-08-31' }  // Summer holidays 2027 (END DATE TBC)
];
        let currentWorkingSchedule_extra = []; // This will be populated by flattening the new structure on load
        let closedStopIDs_extra = [];
        let globalCustomRouteColours_extra = {};
        let stopSpecificRouteColours_extra = {};
        let uniqueStopsMasterList_extra = [];
        let processedExcelStopsData_extra = [];
        let rsg_selectedStops_extra = [];
        let rsg_generatedPreviewEntries_extra = [];
        let rsg_loadedConfigs_extra = {};
        let rsg_lastLoadedRouteName_extra = null;
        let rsg_lastLoadedDestName_extra = null;
        let rsg_lastLoadedOpProfile_extra = null;
        let rsg_draggedItemIndex_extra = null;
        let scheduledRouteUpdates_extra = {};


        // --- Firebase Path Constants ---
        const FB_PATH_PAGE_EXTRA_SETTINGS = '/settings/extraModulesPageSettings';
        const FB_PATH_OPERATIONAL_OVERRIDES = '/operationalOverrides';
        const FB_PATH_SCHEDULED_DELETIONS = '/scheduledRouteDeletions';
        const FB_PATH_SCHEDULES_BY_ROUTE = '/liveSchedule/schedulesByRoute'; // New path for structured schedule data
        const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
        const FB_PATH_APPSTATE_LAST_UPDATED = '/appState/scheduleLastUpdated';
        const FB_PATH_APPSTATE_CLOSED_STOPS = '/appState/closedStopIDs';
        const FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS = '/settings/customRouteColours';
        const FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS = '/settings/stopSpecificRouteColours';
        const FB_PATH_RSG_CONFIGS = '/rsgConfigs';
        const FB_PATH_SCHEDULED_UPDATES = '/scheduledUpdates';
        const FB_PATH_SCHEDULED_ROUTE_UPDATES = '/scheduledRouteUpdates';
        const BANK_HOLIDAY_CACHE_DURATION_MS = 24 * 60 * 60 * 1000;


        // --- DOM Elements ---
        const tteRouteNameSelect_el_extra = document.getElementById('tte-routeName-select-extra');
        const tteRouteNameInput_el_extra = document.getElementById('tte-routeName-input-extra');
        const tteDownloadTimetableButton_el_extra = document.getElementById('tte-downloadTimetable-button-extra');
        const tteStatusMessage_el_extra = document.getElementById('tte-status-message-extra');
        const rsgSelectAllConfigsCheckbox_el_extra = document.getElementById('rsg-select-all-configs-checkbox-extra');
        const authSection_el_extra = document.getElementById('auth-section');
        const loginFormContainer_el_extra = document.getElementById('login-form-container_extra');
        const adminLoginForm_el_extra = document.getElementById('adminLoginForm_extra');
        const inputEmail_el_extra = document.getElementById('inputEmail_extra');
        const inputPassword_el_extra = document.getElementById('inputPassword_extra');
        const authStatus_el_extra = document.getElementById('auth-status_extra');
        const logoutContainer_el_extra = document.getElementById('logout-container_extra');
        const loggedInUserEmailDisplay_el_extra = document.getElementById('loggedInUserEmail_extra');
        const topMenuBar_el_extra = document.getElementById('top-menu-bar_extra');
        const toolSectionsWrapper_el_extra = document.getElementById('tool-sections-wrapper_extra');
        const currentProfileDisplayContainer_el = document.getElementById('current-profile-display-container');
        const currentProfileDisplayElement_el = document.getElementById('current-profile-display');
        // Day Profile Override
        const overrideDateInput_el_extra = document.getElementById('overrideDate_extra');
        const overrideProfileInput_el_extra = document.getElementById('overrideProfile_extra');
        const setOverrideButton_el_extra = document.getElementById('setOverrideButton_extra');
        const clearOverrideButton_el_extra = document.getElementById('clearOverrideButton_extra');
        const overrideStatusMessage_el_extra = document.getElementById('overrideStatusMessage_extra');
        const selectedDateDisplay_el_extra = document.getElementById('selectedDateDisplay_extra');
        const autoProfileForSelectedDate_el_extra = document.getElementById('autoProfileForSelectedDate_extra');
        const currentOverrideForSelectedDate_el_extra = document.getElementById('currentOverrideForSelectedDate_extra');
        const activeOverridesList_el_extra = document.getElementById('activeOverridesList_extra');
        // Stop Management & Creation
        const selectNewStopIdFormat_el_extra = document.getElementById('selectNewStopIdFormat_extra');
        const inputNewStopId_el_extra = document.getElementById('inputNewStopId_extra');
        const newStopIdAvailability_el_extra = document.getElementById('newStopIdAvailability_extra');
        const inputNewStopName_el_extra = document.getElementById('inputNewStopName_extra');
        const inputNewStopDirection_el_extra = document.getElementById('inputNewStopDirection_extra');
        const buttonAddNewStop_el_extra = document.getElementById('buttonAddNewStop_extra');
        const addNewStopStatus_el_extra = document.getElementById('addNewStopStatus_extra');
        const fileInputBulkAddStops_el_extra = document.getElementById('fileInputBulkAddStops_extra');
        const fileNameBulkAddStops_el_extra = document.getElementById('fileNameBulkAddStops_extra');
        const buttonBulkAddNewStops_el_extra = document.getElementById('buttonBulkAddNewStops_extra');
        const bulkAddNewStopsStatus_el_extra = document.getElementById('bulkAddNewStopsStatus_extra');
        const masterStopListFilterInput_el_extra = document.getElementById('masterStopListFilterInput_extra');
        const refreshMasterStopListButton_el_extra = document.getElementById('refreshMasterStopListButton_extra');
        const masterStopListUL_el_extra = document.getElementById('masterStopListUL_extra');
        const masterStopListStatus_el_extra = document.getElementById('masterStopListStatus_extra');
        const applyMasterListStopIdChangesButton_el_extra = document.getElementById('applyMasterListStopIdChangesButton_extra');
        const masterListApplyChangesStatus_el_extra = document.getElementById('masterListApplyChangesStatus_extra');
        const exportUniqueStopsButton_el_extra = document.getElementById('exportUniqueStopsButton_extra');
        const findDuplicateStopsByNameDirButton_el_extra = document.getElementById('findDuplicateStopsByNameDirButton_extra');
        const duplicateStopsByNameDirResults_el_extra = document.getElementById('duplicateStopsByNameDirResults_extra');
        // Global Route Deletion
        const globalRouteDeletionListContainer_el_extra = document.getElementById('globalRouteDeletionListContainer_el_extra');
        const deleteEntireRouteButton_el_extra = document.getElementById('deleteEntireRouteButton_el_extra');
        const deleteEntireRouteStatusMessage_el_extra = document.getElementById('deleteEntireRouteStatusMessage_el_extra');
        // Route Schedule Generator (RSG)
        const rsgRouteNameSelect_el_extra = document.getElementById('rsg-routeName-select-extra');
        const rsgRouteNameInput_el_extra = document.getElementById('rsg-routeName-input-extra');
        //const rsgOperatingProfileInput_el_extra = document.getElementById('rsg-operatingProfile-input-extra');
        const rsgDestinationNameSelect_el_extra = document.getElementById('rsg-destinationName-select-extra');
        const rsgDestinationNameInput_el_extra = document.getElementById('rsg-destinationName-input-extra');
        const rsgStopSearchInput_el_extra = document.getElementById('rsg-stop-search-input-extra');
        const rsgStopSearchResults_el_extra = document.getElementById('rsg-stop-search-results-extra');
        const rsgStopSequenceList_el_extra = document.getElementById('rsg-stop-sequence-list-extra');
        const rsgStopSequencePlaceholder_el_extra = document.getElementById('rsg-stop-sequence-placeholder-extra');
        const rsgFirstStopTimesContainer_el_extra = document.getElementById('rsg-first-stop-times-container-extra');
        const rsgFirstStopTimesInput_el_extra = document.getElementById('rsg-first-stop-times-input-extra');
        const rsgGenerateScheduleButton_el_extra = document.getElementById('rsg-generate-schedule-button-extra');
        const rsgSaveConfigurationButton_el_extra = document.getElementById('rsg-save-configuration-button-extra');
        const rsgAddToWorkingScheduleButton_el_extra = document.getElementById('rsg-add-to-working-schedule-button-extra');
        const rsgStatusMessage_el_extra = document.getElementById('rsg-status-message-extra');
        const rsgSchedulePreviewContainer_el_extra = document.getElementById('rsg-schedule-preview-container-extra');
        const rsgPreviewTableBody_el_extra = document.getElementById('rsg-preview-table-extra')?.getElementsByTagName('tbody')[0];
        const rsgOpenCopyModalButton_el_extra = document.getElementById('rsg-open-copy-modal-button-extra');
        const rsgCopyModal_el_extra = document.getElementById('rsg-copy-modal-extra');
        const rsgCopySourceRouteNameSelect_el_extra = document.getElementById('rsg-copy-source-routeName-select-extra');
        const rsgCopySourceRouteNameInput_el_extra = document.getElementById('rsg-copy-source-routeName-input-extra');
        const rsgCopySourceOpProfileInput_el_extra = document.getElementById('rsg-copy-source-operatingProfile-input-extra');
        const rsgCopySourceDestNameSelect_el_extra = document.getElementById('rsg-copy-source-destinationName-select-extra');
        const rsgCopySourceDestNameInput_el_extra = document.getElementById('rsg-copy-source-destinationName-input-extra');
        const rsgCopyModalStatus_el_extra = document.getElementById('rsg-copy-modal-status-extra');
        const rsgCopyModalCancelButton_el_extra = document.getElementById('rsg-copy-modal-cancel-button-extra');
        const rsgCopyModalActionButton_el_extra = document.getElementById('rsg-copy-modal-action-button-extra');
        // Route Profile Deletion (RPD) - NEW
        const rpdRouteSelect_el_extra = document.getElementById('rpd-route-name-select-extra');
        const rpdRouteInput_el_extra = document.getElementById('rpd-route-name-input-extra');
        const rpdDestinationSelect_el_extra = document.getElementById('rpd-destination-name-select-extra');
        const rpdDestinationInput_el_extra = document.getElementById('rpd-destination-name-input-extra');
        const rpdClearDestinationButton_el_extra = document.getElementById('rpd-clear-destination-button-extra');
        const rpdProfileListContainer_el_extra = document.getElementById('rpd-profile-list-container-extra');
        const rpdDeleteProfilesButton_el_extra = document.getElementById('rpd-delete-profiles-button-extra');
        const rpdStatusMessage_el_extra = document.getElementById('rpd-status-message-extra');
        const srdRouteNameSelect_el_extra = document.getElementById('srd-routeName-select-extra');
const srdRouteNameInput_el_extra = document.getElementById('srd-routeName-input-extra');
const srdGoLiveDateTimeInput_el_extra = document.getElementById('srd-go-live-datetime-input-extra');
const srdScheduleDeletionButton_el_extra = document.getElementById('srd-schedule-deletion-button-extra');
const srdStatusMessage_el_extra = document.getElementById('srd-status-message-extra');
const rsgScheduleSelectedConfigsButton_el_extra = document.getElementById('rsg-schedule-selected-configs-button-extra');
const rsgScheduleThisConfigButton_el_extra = document.getElementById('rsg-schedule-this-config-button-extra');
const rsgScheduleDateTimeConfirmBtn = document.getElementById('rsg-schedule-datetime-confirm-button-extra');
const rsgScheduleDateTimeCancelBtn = document.getElementById('rsg-schedule-datetime-cancel-button-extra');
const rsgScheduleDateTimeModal = document.getElementById('rsg-schedule-datetime-modal-extra');
const sruBatchGoLiveRadiosContainer_el_extra = document.getElementById('sru-batch-golive-radios-container-extra');
const sruApplyAllForTimeButton_el_extra = document.getElementById('sru-apply-all-for-time-button-extra');
const sruApplyAllStatusMessage_el_extra = document.getElementById('sru-apply-all-status-message-extra');
// For the "Cancel Route Updates by Specific Time(s)" Modal
const sruCancelRouteTimeSelectModal_el_extra = document.getElementById('sru-cancel-route-time-select-modal-extra');
const sruCancelModalTitle_el_extra = document.getElementById('sru-cancel-modal-title-extra');
const sruCancelModalRouteInfo_el_extra = document.getElementById('sru-cancel-modal-route-info-extra');
const sruCancelModalCheckboxesContainer_el_extra = document.getElementById('sru-cancel-modal-checkboxes-container-extra');
const sruCancelModalSelectAllCheckbox_el_extra = document.getElementById('sru-cancel-modal-select-all-times-extra');
const sruCancelModalConfirmButton_el_extra = document.getElementById('sru-cancel-modal-confirm-button-extra');
const sruCancelModalCancelButton_el_extra = document.getElementById('sru-cancel-modal-cancel-button-extra');
const sruCancelModalStatus_el_extra = document.getElementById('sru-cancel-modal-status-extra');

// For the Global "Cancel ALL Pending Updates" Button
const sruCancelAllPendingUpdatesGloballyButton_el_extra = document.getElementById('sru-cancel-all-pending-updates-globally-button-extra');
const sruCancelAllGlobalStatusMessage_el_extra = document.getElementById('sru-cancel-all-global-status-message-extra');


        // --- Helper Functions ---
        function sanitizeFirebaseKey(text) {
            if (typeof text !== 'string') return '';
            // Replace forbidden characters with an underscore
            // Firebase forbids '.', '#', '$', '[', ']'
            return text.replace(/[.#$[\]]/g, '_');
        }

// Function to populate the route dropdown for Scheduled Route Deletion (SRD)
function srd_populateRouteSelect_ExtraPage() {
    if (!srdRouteNameSelect_el_extra || !currentWorkingSchedule_extra) {
        console.warn("SRD: Route select element or schedule data not available.");
        return;
    }
    // Get unique routes that actually have schedule entries (not just definitions)
    const uniqueRoutesWithSchedules = [...new Set(
        currentWorkingSchedule_extra
            .filter(e => e.lineName && e.scheduledTime) // Ensure it's a route with actual schedule entries
            .map(e => e.lineName)
    )].sort(compareLineNames_ExtraPage);

    const currentInputValue = srdRouteNameInput_el_extra ? srdRouteNameInput_el_extra.value.trim() : "";

    srdRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Route to Delete --</option>';
    uniqueRoutesWithSchedules.forEach(route => {
        const opt = document.createElement('option');
        opt.value = route;
        opt.textContent = route;
        srdRouteNameSelect_el_extra.appendChild(opt);
    });

    if (currentInputValue) {
        const matchedOption = uniqueRoutesWithSchedules.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
        srdRouteNameSelect_el_extra.value = matchedOption ? matchedOption : "";
    } else {
        srdRouteNameSelect_el_extra.value = "";
    }
    if(srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = '';
}

function rsg_pullCurrentFirstStopTimes_ExtraPage() {
    if (!currentUser_extra) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Please log in to pull times.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    if (!rsgRouteNameInput_el_extra || !rsgDestinationNameInput_el_extra || !rsgFirstStopTimesInput_el_extra || !rsgStatusMessage_el_extra) {
        console.error("RSG Pull Times: Essential DOM elements missing.");
        alert("Error: RSG form components for pulling times are missing.");
        return;
    }

    const routeName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
    const opProfilesString = rsg_getSelectedOpProfilesString_ExtraPage(); // Returns comma-separated string like "MF, Sa"
    const destName = rsgDestinationNameInput_el_extra.value.trim();

    if (!routeName) {
        rsgStatusMessage_el_extra.textContent = "Please select/enter a Route Name first.";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }
    if (!opProfilesString) {
        rsgStatusMessage_el_extra.textContent = "Please select Operating Profile(s) first.";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }
    if (!destName) {
        rsgStatusMessage_el_extra.textContent = "Please select/enter a Destination Name first.";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    if (!rsg_selectedStops_extra || rsg_selectedStops_extra.length === 0) {
        rsgStatusMessage_el_extra.textContent = "No stops in the sequence. Add the first stop to pull its times.";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    const firstStopID = rsg_selectedStops_extra[0].stopID;
    const selectedOpProfilesArray = opProfilesString.split(',').map(p => p.trim()).filter(Boolean);
    const uniqueTimesSet = new Set();

    currentWorkingSchedule_extra.forEach(entry => {
        if (entry.lineName && entry.lineName.toUpperCase() === routeName &&
            entry.destinationName === destName &&
            entry.stopID === firstStopID &&
            entry.OperatingProfile && selectedOpProfilesArray.includes(entry.OperatingProfile) &&
            (entry.DayOffset === "0" || !entry.DayOffset) && // Primarily pull times for DayOffset 0
            entry.scheduledTime && entry.scheduledTime.match(/^\d{2}:\d{2}$/)) {
            uniqueTimesSet.add(entry.scheduledTime);
        }
    });

    if (uniqueTimesSet.size > 0) {
        const sortedTimes = Array.from(uniqueTimesSet).sort((a, b) => {
            const timeAVal = parseInt(a.replace(':', ''), 10);
            const timeBVal = parseInt(b.replace(':', ''), 10);
            return timeAVal - timeBVal;
        });
        rsgFirstStopTimesInput_el_extra.value = sortedTimes.join('\t');
        rsgStatusMessage_el_extra.textContent = `Pulled ${sortedTimes.length} unique first stop time(s) for the selected parameters.`;
        rsgStatusMessage_el_extra.style.color = "#2ecc71";
        rsg_isDirty = true; // Mark configuration as dirty
        console.log(`RSG User Edit: First stop times pulled. rsg_isDirty is true. Times: "${rsgFirstStopTimesInput_el_extra.value}"`);
        // Trigger input event for the textarea if other logic depends on it
        rsgFirstStopTimesInput_el_extra.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
    } else {
        rsgFirstStopTimesInput_el_extra.value = ''; // Clear if no times found
        rsgStatusMessage_el_extra.textContent = "No existing first stop times found in the main schedule for the current RSG Route, Profile(s), Destination, and First Stop (with DayOffset 0).";
        rsgStatusMessage_el_extra.style.color = "#f1c40f";
    }
}

function sru_openCancelRouteTimeSelectModal_ExtraPage(routeName) {
    if (!sruCancelRouteTimeSelectModal_el_extra || !sruCancelModalTitle_el_extra || 
        !sruCancelModalRouteInfo_el_extra || !sruCancelModalCheckboxesContainer_el_extra || 
        !sruCancelModalStatus_el_extra || !sruCancelModalSelectAllCheckbox_el_extra ||
        !sruCancelModalConfirmButton_el_extra) {
        console.error("SRU Cancel Modal: Essential modal elements are missing from the DOM.");
        alert("Error: Cancellation modal components are not fully available.");
        return;
    }

    sruCancelModalStatus_el_extra.textContent = '';
    sruCancelModalRouteInfo_el_extra.textContent = `Route: ${routeName}`;
    sruCancelModalTitle_el_extra.textContent = `Cancel Updates for Route: ${routeName}`;
    sruCancelModalCheckboxesContainer_el_extra.innerHTML = '<p style="opacity:0.7;">Loading available go-live times...</p>';
    sruCancelModalSelectAllCheckbox_el_extra.checked = false; // Reset select all

    const pendingApplyTasksForRoute = [];
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.values(scheduledRouteUpdates_extra).forEach(task => {
            if (task && task.routeName === routeName &&
                (task.taskType === 'applySchedule' || task.taskTypeDisplay === 'applySchedule') &&
                task.status === 'pending' && task.goLiveDateTime) {
                pendingApplyTasksForRoute.push(task);
            }
        });
    }

    sruCancelModalContext.routeName = routeName; // Store routeName in context

    const uniqueGoLiveTimes = [...new Set(pendingApplyTasksForRoute.map(task => task.goLiveDateTime))]
        .sort((a, b) => new Date(a).getTime() - new Date(b).getTime());

    if (uniqueGoLiveTimes.length === 0) {
        sruCancelModalCheckboxesContainer_el_extra.innerHTML = '<p style="opacity:0.7;">No pending updates with specific go-live times found for this route to cancel.</p>';
        sruCancelModalConfirmButton_el_extra.disabled = true;
        sruCancelModalSelectAllCheckbox_el_extra.disabled = true;
    } else {
        sruCancelModalCheckboxesContainer_el_extra.innerHTML = ''; // Clear "Loading..."
        uniqueGoLiveTimes.forEach((isoTime, index) => {
            const tasksAtThisTimeCount = pendingApplyTasksForRoute.filter(t => t.goLiveDateTime === isoTime).length;
            const checkboxId = `sru-cancel-cb-time-${index}`;
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'sru-cancel-time-item'; // For potential specific styling

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = 'sruCancelSelectedGoLiveTimeCheckbox_extra';
            checkbox.id = checkboxId;
            checkbox.value = isoTime;
            checkbox.dataset.taskCount = tasksAtThisTimeCount; // Store task count for info
            checkbox.addEventListener('change', () => { // Handle individual checkbox changes
                const allTimeCheckboxes = sruCancelModalCheckboxesContainer_el_extra.querySelectorAll('input[type="checkbox"]');
                const allChecked = Array.from(allTimeCheckboxes).every(cb => cb.checked);
                sruCancelModalSelectAllCheckbox_el_extra.checked = allChecked;
            });

            const label = document.createElement('label');
            label.htmlFor = checkboxId;
            label.textContent = `${new Date(isoTime).toLocaleString()} (${tasksAtThisTimeCount} task(s))`;
            
            itemDiv.appendChild(checkbox);
            itemDiv.appendChild(label);
            sruCancelModalCheckboxesContainer_el_extra.appendChild(itemDiv);
        });
        sruCancelModalConfirmButton_el_extra.disabled = false;
        sruCancelModalSelectAllCheckbox_el_extra.disabled = false;
    }
    sruCancelRouteTimeSelectModal_el_extra.style.display = 'flex';
}

function sru_closeCancelRouteTimeSelectModal_ExtraPage() {
    if (sruCancelRouteTimeSelectModal_el_extra) {
        sruCancelRouteTimeSelectModal_el_extra.style.display = 'none';
    }
    sruCancelModalContext.routeName = null; // Clear context
    if (sruCancelModalCheckboxesContainer_el_extra) sruCancelModalCheckboxesContainer_el_extra.innerHTML = ''; // Clear checkboxes
    if (sruCancelModalSelectAllCheckbox_el_extra) sruCancelModalSelectAllCheckbox_el_extra.checked = false;
}

async function sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage() {
    if (!sruCancelModalContext.routeName) {
        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = "Error: Route context is missing. Please close and retry.";
            sruCancelModalStatus_el_extra.style.color = "#e74c3c";
        }
        return;
    }
    const routeName = sruCancelModalContext.routeName;

    const selectedTimeCheckboxes = sruCancelModalCheckboxesContainer_el_extra.querySelectorAll('input[type="checkbox"]:checked');
    const selectedGoLiveTimesISO = Array.from(selectedTimeCheckboxes).map(cb => cb.value);

    if (selectedGoLiveTimesISO.length === 0) {
        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = "No go-live time(s) selected for cancellation.";
            sruCancelModalStatus_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    const tasksToCancelKeys = [];
    let totalTasksAffectedCount = 0;
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.entries(scheduledRouteUpdates_extra).forEach(([key, task]) => {
            if (task && task.routeName === routeName &&
                selectedGoLiveTimesISO.includes(task.goLiveDateTime) &&
                (task.taskType === 'applySchedule' || task.taskTypeDisplay === 'applySchedule') &&
                task.status === 'pending') {
                tasksToCancelKeys.push(key);
                totalTasksAffectedCount++;
            }
        });
    }

    if (tasksToCancelKeys.length === 0) { // Should ideally not happen if checkboxes were based on pending tasks
        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = "No matching pending updates found for the selected criteria. The list might have changed.";
            sruCancelModalStatus_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    
    const selectedTimesReadable = selectedGoLiveTimesISO.map(iso => new Date(iso).toLocaleString()).join(', ');
    const confirmMsg = `Are you sure you want to cancel all ${totalTasksAffectedCount} pending timetable update(s) for Route "${routeName}" scheduled for the following time(s):\n- ${selectedTimesReadable}\nThis action cannot be undone.`;
    
    if (!confirm(confirmMsg)) {
        if(sruCancelModalStatus_el_extra) sruCancelModalStatus_el_extra.textContent = "Cancellation aborted by user.";
        return;
    }

    if(sruCancelModalStatus_el_extra) {
        sruCancelModalStatus_el_extra.textContent = `Cancelling ${totalTasksAffectedCount} task(s) for Route "${routeName}"...`;
        sruCancelModalStatus_el_extra.style.color = "#f1c40f";
    }

    const { database, dbUpdate, dbRef } = window.firebaseOMSI;
    const updatesToRemove = {};
    tasksToCancelKeys.forEach(taskKey => {
        updatesToRemove[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`] = null;
    });

    try {
        await dbUpdate(dbRef(database), updatesToRemove);
        
        tasksToCancelKeys.forEach(taskKey => { // Update local cache
            if (scheduledRouteUpdates_extra && scheduledRouteUpdates_extra[taskKey]) {
                delete scheduledRouteUpdates_extra[taskKey];
            }
        });

        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = `Successfully cancelled ${totalTasksAffectedCount} update(s) for Route "${routeName}".`;
            sruCancelModalStatus_el_extra.style.color = "#2ecc71";
        }
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh the main list
        setTimeout(sru_closeCancelRouteTimeSelectModal_ExtraPage, 1800);

    } catch (error) {
        console.error(`Error cancelling updates for route ${routeName}:`, error);
        if(sruCancelModalStatus_el_extra) {
            sruCancelModalStatus_el_extra.textContent = `Error cancelling updates: ${error.message}`;
            sruCancelModalStatus_el_extra.style.color = "#e74c3c";
        }
    }
}

async function handleCancelAllUpdatesForRoute_Master(routeName) {
    if (!routeName) {
        console.error("handleCancelAllUpdatesForRoute_Master called without routeName");
        return;
    }

    const pendingApplyTasksForRoute = [];
     if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.values(scheduledRouteUpdates_extra).forEach(task => {
            if (task && task.routeName === routeName &&
                (task.taskType === 'applySchedule' || task.taskTypeDisplay === 'applySchedule') &&
                task.status === 'pending' && task.goLiveDateTime) {
                pendingApplyTasksForRoute.push(task);
            }
        });
    }

    if (pendingApplyTasksForRoute.length === 0) {
        alert(`No pending timetable updates found for Route "${routeName}" to cancel.`);
        return;
    }

    const uniqueGoLiveTimesForRoute = [...new Set(pendingApplyTasksForRoute.map(task => task.goLiveDateTime))];

    if (uniqueGoLiveTimesForRoute.length === 1) {
        // Only one go-live time, directly use the execution logic for that single time.
        // We need to pass routeName and the single goLiveDateTimeISO to a function that can handle it.
        // For simplicity, we'll construct what sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage expects.
        sruCancelModalContext.routeName = routeName; // Set context for the execution function
        
        // Simulate selection of this single time to pass to the execution function
        // This is a bit of a workaround; ideally, sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage
        // would take routeName and an array of ISO times.
        // For now, we can directly call a firebase removal.

        const tasksToCancelKeys = pendingApplyTasksForRoute.map(task => {
             // Find the key for this task in scheduledRouteUpdates_extra
            for (const key in scheduledRouteUpdates_extra) {
                if (scheduledRouteUpdates_extra[key] === task) return key;
            }
            return null;
        }).filter(Boolean);


        if (tasksToCancelKeys.length > 0) {
            const confirmMsg = `Are you sure you want to cancel all ${tasksToCancelKeys.length} pending timetable update(s) for Route "${routeName}" scheduled for ${new Date(uniqueGoLiveTimesForRoute[0]).toLocaleString()}?`;
            if (!confirm(confirmMsg)) return;

            if (rsgStatusMessage_el_extra) { // Use a general status message
                 rsgStatusMessage_el_extra.textContent = `Cancelling updates for Route ${routeName}...`;
                 rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }

            const { database, dbUpdate, dbRef } = window.firebaseOMSI;
            const updatesToRemove = {};
            tasksToCancelKeys.forEach(taskKey => {
                updatesToRemove[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`] = null;
            });

            try {
                await dbUpdate(dbRef(database), updatesToRemove);
                tasksToCancelKeys.forEach(taskKey => {
                    if (scheduledRouteUpdates_extra && scheduledRouteUpdates_extra[taskKey]) {
                        delete scheduledRouteUpdates_extra[taskKey];
                    }
                });
                if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = `Successfully cancelled updates for Route "${routeName}".`;
                    rsgStatusMessage_el_extra.style.color = "#2ecc71";
                }
                loadAndDisplayScheduledUpdates_ExtraPage();
            } catch (error) {
                 if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = `Error cancelling updates for ${routeName}: ${error.message}`;
                    rsgStatusMessage_el_extra.style.color = "#e74c3c";
                }
            }
        }

    } else if (uniqueGoLiveTimesForRoute.length > 1) {
        sru_openCancelRouteTimeSelectModal_ExtraPage(routeName); // Open modal for selection
    } else {
        alert(`No specific go-live times found for pending updates on Route "${routeName}". This shouldn't happen if tasks were found.`);
    }
}

async function handleCancelAllUpdatesAllRoutes_Global() {
    if (!currentUser_extra) {
        if(sruCancelAllGlobalStatusMessage_el_extra) { sruCancelAllGlobalStatusMessage_el_extra.textContent = "Please log in."; sruCancelAllGlobalStatusMessage_el_extra.style.color = "#e74c3c"; }
        return;
    }

    const pendingApplyScheduleTaskKeys = [];
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.entries(scheduledRouteUpdates_extra).forEach(([key, task]) => {
            if (task && (task.taskType === 'applySchedule' || task.taskTypeDisplay === 'applySchedule') && task.status === 'pending') {
                pendingApplyScheduleTaskKeys.push(key);
            }
        });
    }

    if (pendingApplyScheduleTaskKeys.length === 0) {
        if(sruCancelAllGlobalStatusMessage_el_extra) {
            sruCancelAllGlobalStatusMessage_el_extra.textContent = "No pending timetable updates found across all routes to cancel.";
            sruCancelAllGlobalStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    const userConfirmation = prompt(`EXTREME CAUTION!\nYou are about to cancel ALL ${pendingApplyScheduleTaskKeys.length} pending timetable updates for ALL routes and ALL go-live times.\nThis action CANNOT BE UNDONE.\n\nTo confirm, please type "CANCEL ALL UPDATES" in the box below:`);

    if (userConfirmation !== "CANCEL ALL UPDATES") {
        if(sruCancelAllGlobalStatusMessage_el_extra) {
            sruCancelAllGlobalStatusMessage_el_extra.textContent = "Global cancellation aborted by user or incorrect confirmation.";
            sruCancelAllGlobalStatusMessage_el_extra.style.color = "";
        }
        return;
    }

    if(sruCancelAllGlobalStatusMessage_el_extra) {
        sruCancelAllGlobalStatusMessage_el_extra.textContent = `Processing global cancellation of ${pendingApplyScheduleTaskKeys.length} task(s)...`;
        sruCancelAllGlobalStatusMessage_el_extra.style.color = "#f1c40f";
    }
    if(sruCancelAllPendingUpdatesGloballyButton_el_extra) sruCancelAllPendingUpdatesGloballyButton_el_extra.disabled = true;

    const { database, dbUpdate, dbRef } = window.firebaseOMSI;
    const updatesToNullify = {};
    pendingApplyScheduleTaskKeys.forEach(key => {
        updatesToNullify[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${key}`] = null;
    });

    try {
        await dbUpdate(dbRef(database), updatesToNullify);
        pendingApplyScheduleTaskKeys.forEach(key => { // Update local cache
            if (scheduledRouteUpdates_extra && scheduledRouteUpdates_extra[key]) {
                delete scheduledRouteUpdates_extra[key];
            }
        });
        
        if(sruCancelAllGlobalStatusMessage_el_extra) {
            sruCancelAllGlobalStatusMessage_el_extra.textContent = `Successfully cancelled all ${pendingApplyScheduleTaskKeys.length} pending timetable updates globally.`;
            sruCancelAllGlobalStatusMessage_el_extra.style.color = "#2ecc71";
        }
        loadAndDisplayScheduledUpdates_ExtraPage();
    } catch (error) {
        console.error("Error performing global cancellation of scheduled updates:", error);
         if(sruCancelAllGlobalStatusMessage_el_extra) {
            sruCancelAllGlobalStatusMessage_el_extra.textContent = `Error during global cancellation: ${error.message}`;
            sruCancelAllGlobalStatusMessage_el_extra.style.color = "#e74c3c";
        }
    } finally {
        if(sruCancelAllPendingUpdatesGloballyButton_el_extra) sruCancelAllPendingUpdatesGloballyButton_el_extra.disabled = false;
    }
}

// --- START: Day Profile Override (DPO) Checkbox Logic ---

function dpo_getCanonicalProfileString_ExtraPage(profileArray) {
    if (!Array.isArray(profileArray)) return "";
    return profileArray.map(p => String(p).trim()).sort((a,b) => a.localeCompare(b)).join(',');
}

function dpo_simulateAutoGroup_ExtraPage(selectedProfilesArray) {
    let simulatedSelections = [...selectedProfilesArray]; 
    // Assuming RSG_PROFILE_GROUPS_TO_MANAGE is suitable here
    RSG_PROFILE_GROUPS_TO_MANAGE.forEach(group => {
        const allIndividualsPresent = group.individuals.every(ind => simulatedSelections.includes(ind));
        if (allIndividualsPresent) {
            simulatedSelections = simulatedSelections.filter(p => !group.individuals.includes(p)); 
            if (!simulatedSelections.includes(group.groupProfile)) {
                simulatedSelections.push(group.groupProfile); 
            }
        }
    });
    return simulatedSelections;
}

function dpo_populateProfileCheckboxes_ExtraPage() {
    const container = document.getElementById('dpo-selectable-profiles-container-extra');
    const placeholder = document.getElementById('dpo-profiles-placeholder-extra'); // Make sure this ID is in your HTML for DPO
    if (!container) {
        console.error("DPO Profile checkbox container not found!");
        return;
    }
    container.innerHTML = ''; // Clear previous content

    // Assuming RSG_OPERATING_PROFILES_LIST is suitable for DPO as well
    if (RSG_OPERATING_PROFILES_LIST.length === 0 && placeholder) {
        placeholder.textContent = "No profiles defined for selection.";
        container.appendChild(placeholder);
        return;
    }
    if (placeholder) placeholder.style.display = 'none';

    RSG_OPERATING_PROFILES_LIST.forEach(profileValue => {
        const wrapper = document.createElement('div');
        wrapper.style.display = 'inline-flex'; 
        wrapper.style.alignItems = 'center';
        wrapper.style.marginRight = '10px'; // Spacing for tiles

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        const safeProfileId = profileValue.replace(/[^a-zA-Z0-9_-]/g, '');
        checkbox.id = `dpo-profile-cb-${safeProfileId}-extra`;
        checkbox.value = profileValue;
        checkbox.name = 'dpoOperatingProfileCheckbox_extra';
        checkbox.classList.add('dpo-profile-checkbox'); 

        checkbox.addEventListener('change', dpo_handleProfileSelectionChange_ExtraPage);

        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.textContent = profileValue;
        label.style.marginLeft = "4px"; 
        label.style.cursor = "pointer";
        label.style.color = "#ecf0f1"; 

        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        container.appendChild(wrapper);
    });
    dpo_updateDisabledProfileCheckboxes_ExtraPage(); // Initial update of enabled/disabled states
}

function dpo_updateDisabledProfileCheckboxes_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox'));
    const currentSelectedValues = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

    allCheckboxes.forEach(cb => {
        if (cb.checked) { // Always enable if checked
            cb.disabled = false;
            if (cb.parentElement) {
                cb.parentElement.style.opacity = 1;
                const labelForCb = cb.parentElement.querySelector('label');
                if (labelForCb) labelForCb.style.cursor = 'pointer';
            }
            return;
        }

        // Simulate adding this checkbox's value to the current selection
        const potentialNextRawSelection = [...currentSelectedValues, cb.value];
        const finalEffectiveSelectionAfterAutoGroup = dpo_simulateAutoGroup_ExtraPage(potentialNextRawSelection);
        const finalEffectiveSortedString = dpo_getCanonicalProfileString_ExtraPage(finalEffectiveSelectionAfterAutoGroup);
        
        let canBeEnabled = false;
        // Check if this exact combination is valid
        if (VALID_PROFILE_COMBINATIONS_SET.has(finalEffectiveSortedString)) {
            canBeEnabled = true;
        }
        
        // If not exact, check if it's a valid start to a longer combination
        if (!canBeEnabled) {
            const prefixToTest = finalEffectiveSortedString + ",";
            for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                if (validCombo.startsWith(prefixToTest)) {
                    canBeEnabled = true;
                    break;
                }
            }
        }
        
        // Special case for initial selection (currentSelectedValues is empty)
        if (currentSelectedValues.length === 0) {
             const singleProfileItselfAfterPotentialGroup = dpo_simulateAutoGroup_ExtraPage([cb.value]);
             const singleCanonical = dpo_getCanonicalProfileString_ExtraPage(singleProfileItselfAfterPotentialGroup);
             if (VALID_PROFILE_COMBINATIONS_SET.has(singleCanonical)) {
                 canBeEnabled = true;
             } else {
                 const prefixToTestForSingle = singleCanonical + ",";
                 for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                     if (validCombo.startsWith(prefixToTestForSingle)) {
                         canBeEnabled = true;
                         break;
                     }
                 }
             }
        }

        cb.disabled = !canBeEnabled;
        if (cb.parentElement) {
            cb.parentElement.style.opacity = !canBeEnabled ? 0.5 : 1;
            const labelForCb = cb.parentElement.querySelector('label');
            if (labelForCb) {
                labelForCb.style.cursor = !canBeEnabled ? 'not-allowed' : 'pointer';
            }
        }
    });
}

function dpo_handleProfileSelectionChange_ExtraPage(event) {
    let currentSelectionsArray = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox:checked')).map(cb => cb.value);
    const allCheckboxes = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox'));

    // Handle auto-grouping (e.g., Mo-Fr implies individual days)
    // Assuming RSG_PROFILE_GROUPS_TO_MANAGE is suitable
    RSG_PROFILE_GROUPS_TO_MANAGE.forEach(group => {
        const groupCheckbox = allCheckboxes.find(cb => cb.value === group.groupProfile);
        if (!groupCheckbox) return; 
        currentSelectionsArray = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value); // Re-evaluate current selections
        const allIndividualsInGroupSelected = group.individuals.every(day => currentSelectionsArray.includes(day));

        if (allIndividualsInGroupSelected) {
            if (!groupCheckbox.checked) { // If individuals are all selected, but group isn't
                group.individuals.forEach(day => {
                    const cb = allCheckboxes.find(c => c.value === day);
                    if (cb && cb.checked) { cb.checked = false; }
                });
                groupCheckbox.checked = true;
            }
        } else if (groupCheckbox.checked) { // If group is selected, but not all individuals are
            // If the event target was one of the individuals and it's being unchecked, uncheck the group
            if (event && event.target && group.individuals.includes(event.target.value) && !event.target.checked) {
                 groupCheckbox.checked = false;
            }
            // Ensure individuals are unchecked if group is checked
             group.individuals.forEach(day => {
                const cb = allCheckboxes.find(c => c.value === day);
                if(cb && cb.checked) cb.checked = false;
            });
        }
    });

    // Re-get the selections after auto-grouping
    currentSelectionsArray = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox:checked')).map(cb => cb.value);
    
    // Sort for consistent display and storage
    currentSelectionsArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a); // Make sure this helper exists or adapt from RSG
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) return orderA - orderB;
        return a.localeCompare(b);
    });

    const finalSelectedProfilesString = currentSelectionsArray.join(', ');
    const displayElement = document.getElementById('dpo-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }

    dpo_updateDisabledProfileCheckboxes_ExtraPage();
}

function dpo_getSelectedOpProfilesString_ExtraPage() {
    const selectedProfiles = [];
    document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox:checked').forEach(checkbox => {
        selectedProfiles.push(checkbox.value);
    });
    selectedProfiles.sort((a,b) => a.localeCompare(b)); // Consistent sort
    return selectedProfiles.join(','); // Join with just comma for storage
}

function dpo_setCheckedProfiles_ExtraPage(profileString) {
    const profilesToSelect = profileString ? profileString.split(',').map(p => p.trim()).filter(Boolean) : [];
    const allCheckboxes = document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox');
    allCheckboxes.forEach(checkbox => {
        checkbox.checked = profilesToSelect.includes(checkbox.value);
    });
    // After setting, trigger the logic that handles display and disabled states
    dpo_handleProfileSelectionChange_ExtraPage(null); // Pass null as no specific event triggered this
}

function dpo_clearProfileSelections_ExtraPage() {
    const allCheckboxes = document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox');
    allCheckboxes.forEach(cb => cb.checked = false);
    dpo_handleProfileSelectionChange_ExtraPage(null); // Update display and disabled states
}

// --- END: Day Profile Override (DPO) Checkbox Logic ---

async function handleEditStopFromMasterList_ExtraPage(stopID, currentName, currentDirection) {
    if (!currentUser_extra) {
        alert("Please log in to edit stop details.");
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "Not logged in.";
        return;
    }

    const newStopName = prompt(`Editing Stop: ${stopID}\nEnter new Stop Name (current: "${currentName || ''}"):`, currentName || '');
    if (newStopName === null) { // User cancelled the first prompt
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `Edit cancelled for stop ${stopID}.`;
        return;
    }

    const newDirection = prompt(`Editing Stop: ${stopID}\nEnter new "Towards" text (current: "${currentDirection || ''}"):`, currentDirection || '');
    if (newDirection === null) { // User cancelled the second prompt
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `Edit cancelled for stop ${stopID}.`;
        return;
    }

    // Trim inputs
    const trimmedNewStopName = newStopName.trim();
    const trimmedNewDirection = newDirection.trim();
    const trimmedCurrentName = (currentName || "").trim();
    const trimmedCurrentDirection = (currentDirection || "").trim();

    const nameChanged = trimmedNewStopName !== trimmedCurrentName;
    const directionChanged = trimmedNewDirection !== trimmedCurrentDirection;

    if (!nameChanged && !directionChanged) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `No changes made to Stop ID "${stopID}".`;
        return;
    }

    if (masterStopListStatus_el_extra) {
        masterStopListStatus_el_extra.textContent = `Updating entries for stop ${stopID}...`;
        masterStopListStatus_el_extra.style.color = "#f1c40f";
    }

    let updatedCount = 0;
    currentWorkingSchedule_extra.forEach(entry => {
        if (entry.stopID && entry.stopID.toUpperCase() === stopID.toUpperCase()) {
            let entryModified = false;
            if (nameChanged) {
                entry.stopName = trimmedNewStopName; // Update with new name (can be blank if user cleared it)
                entryModified = true;
            }
            if (directionChanged) {
                entry.direction = trimmedNewDirection; // Update with new direction (can be blank)
                entryModified = true;
            }
            if (entryModified) {
                updatedCount++;
            }
        }
    });

    if (updatedCount > 0) {
        try {
            await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
            // Ancillary data like unique stops will be updated by rebuildAndSaveEntireScheduleToFirebase_ExtraPage
            
            if (masterStopListStatus_el_extra) {
                masterStopListStatus_el_extra.textContent = `${updatedCount} schedule entries for Stop ID "${stopID}" updated. Name set to "${trimmedNewStopName}", Direction to "${trimmedNewDirection}".`;
                masterStopListStatus_el_extra.style.color = "#2ecc71";
            }
            renderUIDependentElements_ExtraPage(); // This should re-trigger populateMasterStopList_ExtraPage if that section is active
        } catch (error) {
            console.error(`Error saving Stop ID ${stopID} changes to Firebase:`, error);
            if (masterStopListStatus_el_extra) {
                masterStopListStatus_el_extra.textContent = `Error saving changes for stop ${stopID}: ${error.message}`;
                masterStopListStatus_el_extra.style.color = "#e74c3c";
            }
            // Consider reloading initial data to revert local changes if save fails critically
            // loadInitialData_ExtraPage(); 
        }
    } else {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `No schedule entries were modified for Stop ID "${stopID}". This might happen if the stop only exists as a definition.`;
    }
}

async function handleApplyScheduledRouteBatch_ExtraPage(tasksInBatch) {
    if (!currentUser_extra) {
        alert("Please log in to apply batch updates.");
        return;
    }
    if (!tasksInBatch || tasksInBatch.length === 0) {
        alert("No tasks provided for batch application.");
        return;
    }

    const representativeTask = tasksInBatch[0]; // Assuming all tasks in batch are for the same route & time
    const targetRouteName = representativeTask.routeName.toUpperCase();
    const goLiveDateTimeForDisplay = new Date(representativeTask.goLiveDateTime).toLocaleString();

    let allNewEntriesForRoute = [];
    let involvedProfiles = new Set();
    let involvedDestinations = new Set();
    let taskKeysInBatch = []; // To update status of all processed tasks

    tasksInBatch.forEach(task => {
        // Ensure we only aggregate 'applySchedule' tasks for the correct route
        if ((task.taskTypeDisplay === 'applySchedule' || task.taskType === 'applySchedule') && task.routeName.toUpperCase() === targetRouteName) {
            if (task.scheduledEntries && task.scheduledEntries.length > 0) {
                // Deep copy entries to avoid issues if the same task object is somehow reused
                allNewEntriesForRoute.push(...JSON.parse(JSON.stringify(task.scheduledEntries)));
                involvedProfiles.add(task.operatingProfile);
                involvedDestinations.add(task.destinationName);
            }
            taskKeysInBatch.push(task.key);
        }
    });

    if (allNewEntriesForRoute.length === 0) {
        alert(`No actual schedule entries found within the selected batch for Route "${targetRouteName}". Cannot apply.`);
        return;
    }

    const profileList = Array.from(involvedProfiles).join(', ') || "N/A";
    const destList = Array.from(involvedDestinations).join(', ') || "N/A";

    const confirmMessage = `Apply BATCH update for Route: ${targetRouteName}\n` +
                         `Go-Live: ${goLiveDateTimeForDisplay}\n\n` +
                         `This batch includes ${tasksInBatch.length} update(s) which will define the following for this route:\n` +
                         `Operating Profile(s): ${profileList}\n` +
                         `Destination(s): ${destList}\n\n` +
                         `WARNING: This will DELETE ALL existing schedules for the ENTIRE Route "${targetRouteName}" (across all its current profiles and destinations).\n` +
                         `Then, ${allNewEntriesForRoute.length} new entries from this batch will be added, forming the new complete schedule for this route.\n\n` +
                         `Proceed with wiping the whole route and applying this batch?`;

    if (!confirm(confirmMessage)) {
        alert("Batch application cancelled by user.");
        return;
    }

    if (rsgStatusMessage_el_extra) { // Use a general status message element if available
        rsgStatusMessage_el_extra.textContent = `Processing batch for Route ${targetRouteName}... This may take a moment.`;
        rsgStatusMessage_el_extra.style.color = "#3498db";
    }

    const { database, dbUpdate, dbRef } = window.firebaseOMSI;
    let removedCount = 0;

    // 1. Filter out ALL existing entries for this targetRouteName from the local working schedule
    currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
        const matchesRouteOnly = entry.lineName && entry.lineName.toUpperCase() === targetRouteName;
        if (matchesRouteOnly) {
            removedCount++;
            return false;
        }
        return true;
    });
    console.log(`Batch Apply: Removed <span class="math-inline">\{removedCount\} existing entries for Route "</span>{targetRouteName}".`);

    // 2. Add all new entries from the batch, ensuring unique internalIds
    const entriesToAddWithUniqueIds = allNewEntriesForRoute.map((e, idx) => ({
        ...e,
        internalId: e.internalId || `<span class="math-inline">\{e\.stopID\}\_</span>{e.lineName}_${(e.scheduledTime||"0000").replace(':','')}_batchApply_${Date.now()}_${idx}`
    }));
    currentWorkingSchedule_extra.push(...entriesToAddWithUniqueIds);
    console.log(`Batch Apply: Added <span class="math-inline">\{entriesToAddWithUniqueIds\.length\} new entries for Route "</span>{targetRouteName}".`);

    try {
        // 3. Rebuild and save the entire schedule to Firebase.
        await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
        console.log(`Batch Apply: Main schedule rebuilt and saved to Firebase for Route "${targetRouteName}".`);

        // 4. Update the status of all processed scheduled items in Firebase
        const updatesToFirebaseStatus = {};
        const appliedAtTimestamp = new Date().toISOString();
        const appliedByEmail = currentUser_extra ? currentUser_extra.email : "system (batch)";

        taskKeysInBatch.forEach(taskKey => {
            // This assumes all tasks in the batch were 'applySchedule' tasks from FB_PATH_SCHEDULED_ROUTE_UPDATES
            updatesToFirebaseStatus[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/status`] = 'applied (batch)';
            updatesToFirebaseStatus[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/appliedAt`] = appliedAtTimestamp;
            updatesToFirebaseStatus[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/appliedBy`] = appliedByEmail;
        });

        await dbUpdate(dbRef(database), updatesToFirebaseStatus);
        console.log("DEBUG: Task keys being processed:", JSON.stringify(taskKeysInBatch));
console.log("DEBUG: Data being sent to Firebase for status update:", JSON.stringify(updatesToFirebaseStatus));

        // Refresh UI
        loadAndDisplayScheduledUpdates_ExtraPage(); 
        renderUIDependentElements_ExtraPage(); 

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Batch update for Route ${targetRouteName} applied successfully. Live schedule updated.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
            setTimeout(() => { if (rsgStatusMessage_el_extra.textContent && rsgStatusMessage_el_extra.textContent.includes(`Batch update for Route ${targetRouteName}`)) rsgStatusMessage_el_extra.textContent = ''; }, 7000);
        } else {
            alert(`Batch update for Route ${targetRouteName} applied successfully. Live schedule updated.`);
        }

    } catch (error) {
        console.error("Error applying scheduled batch update:", error);
        alert(`Error applying batch update for Route "${targetRouteName}": ${error.message}. The live schedule may be in an inconsistent state. Review carefully.`);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error applying batch for Route ${targetRouteName}: ${error.message}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // Attempt to mark tasks as 'error' in Firebase
        const errorUpdates = {};
        taskKeysInBatch.forEach(taskKey => {
            errorUpdates[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/status`] = 'error';
            errorUpdates[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/lastError`] = `Batch Apply Error: ${error.message}`;
        });
        await dbUpdate(dbRef(database), errorUpdates).catch(err => console.error("Failed to mark batch tasks as error:", err));
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh to show error state
    }
}

function checkAndDisplayDueUpdatesNotification_ExtraPage() {
    const banner = document.getElementById('global-notification-banner');
    if (!banner || !currentUser_extra) { // Only show if logged in and banner element exists
        if (banner) banner.style.display = 'none'; // Ensure banner is hidden if no user
        return;
    }

    let dueTasksDetails = []; // To store info about due tasks for the banner message
    const now = new Date().getTime();

    console.log("Banner Check: Function called at", new Date().toLocaleString());
    console.log("Banner Check: Current epoch time (now):", now);

    // Check 'applySchedule' tasks (typically from RSG - timetable updates)
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.values(scheduledRouteUpdates_extra).forEach(task => {
            if (task && task.status === 'pending' && task.goLiveDateTime) {
                const goLiveTimeEpoch = new Date(task.goLiveDateTime).getTime();
                // console.log(`Banner Check (Update Task ${task.key || 'N/A'}): Status: ${task.status}, GoLiveISO: ${task.goLiveDateTime}, GoLiveEpoch: ${goLiveTimeEpoch}, Due: ${goLiveTimeEpoch <= now}`);
                if (goLiveTimeEpoch <= now) {
                    dueTasksDetails.push({
                        type: 'Timetable Update',
                        name: `Route ${task.routeName || 'N/A'} (for P: ${task.operatingProfile || 'N/A'} to D: ${task.destinationName || 'N/A'})`,
                        key: task.key,
                        goLive: new Date(task.goLiveDateTime).toLocaleString()
                    });
                }
            }
        });
    }

    // Check 'deleteEntireRoute' tasks
    if (typeof scheduledRouteDeletions_extra === 'object' && scheduledRouteDeletions_extra !== null) {
        Object.values(scheduledRouteDeletions_extra).forEach(task => {
            if (task && task.status === 'pending' && task.goLiveDateTime) {
                const goLiveTimeEpoch = new Date(task.goLiveDateTime).getTime();
                // console.log(`Banner Check (Delete Task ${task.key || 'N/A'}): Status: ${task.status}, GoLiveISO: ${task.goLiveDateTime}, GoLiveEpoch: ${goLiveTimeEpoch}, Due: ${goLiveTimeEpoch <= now}`);
                if (goLiveTimeEpoch <= now) {
                    dueTasksDetails.push({
                        type: 'Route Deletion',
                        name: `Route ${task.routeName || 'N/A'}`,
                        key: task.key,
                        goLive: new Date(task.goLiveDateTime).toLocaleString()
                    });
                }
            }
        });
    }

    console.log("Banner Check: Total dueTasksDetails found:", dueTasksDetails.length, JSON.parse(JSON.stringify(dueTasksDetails)));

    if (dueTasksDetails.length > 0) {
        // Sort by go-live time, earliest first, for display consistency if you show details
        dueTasksDetails.sort((a,b) => new Date(a.goLive).getTime() - new Date(b.goLive).getTime());
        
        let message = `${dueTasksDetails.length} scheduled task(s) are now due or overdue.`;
        // Example: Show details of the first due task in the console for easier debugging
        if (dueTasksDetails[0]) {
           console.log("Banner Check: First due task details:", dueTasksDetails[0]);
        }
        
        banner.innerHTML = `${message} 
            <button id="view-due-tasks-button" class="button small-action neutral" style="margin-left:15px; background-color: #ecf0f1; color: #2c3e50; padding: 0.3em 0.6em; font-size: 0.85em;">
                View & Manage Tasks
            </button>`;
        banner.style.backgroundColor = '#27ae60'; // Green for due tasks
        banner.style.display = 'block';

        const viewButton = document.getElementById('view-due-tasks-button');
        if (viewButton) {
            // Ensure only one listener is attached, or handle re-attachment carefully if innerHTML is used often
            if (!viewButton.dataset.listenerAttached) {
                viewButton.addEventListener('click', () => {
                    showExtraPageSection('scheduled-route-updates-section_extra'); // Navigate to the tasks page
                    // You might choose to hide the banner after click or let it persist
                    // banner.style.display = 'none'; 
                });
                viewButton.dataset.listenerAttached = 'true';
            }
        }
    } else {
        banner.style.display = 'none';
    }
}

// Function to handle confirming and saving the scheduled deletion
async function srd_confirmAndScheduleDeletion_ExtraPage() {
    if (!currentUser_extra || !window.firebaseOMSI || !window.firebaseOMSI.database || !window.firebaseOMSI.auth) { // Added auth check here
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Not logged in or Firebase (database/auth) not available.";
            srdStatusMessage_el_extra.style.color = "#e74c3c";
        }
        console.error("SRD Save: currentUser_extra, window.firebaseOMSI, or its database/auth components are missing.");
        return;
    }

    const routeName = srdRouteNameInput_el_extra.value.trim() || srdRouteNameSelect_el_extra.value;
    const goLiveDateTimeValue = srdGoLiveDateTimeInput_el_extra.value;

    if (!routeName) {
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Please select or enter a route name to schedule for deletion.";
            srdStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    if (!goLiveDateTimeValue) {
        // ... (error handling for goLiveDateTimeValue) ...
        return;
    }

    const goLiveDateObj = new Date(goLiveDateTimeValue);
    if (isNaN(goLiveDateObj.getTime())) {
        // ... (error handling for invalid date) ...
        return;
    }

    if (goLiveDateObj <= new Date()) {
        // ... (error handling for past date) ...
        return;
    }

    // Destructure auth here to ensure it's in scope for this function
    const { database, dbSet, dbRef, auth } = window.firebaseOMSI;

    // Crucial check for UID
    console.log("SRD Save: Current User from auth object:", auth.currentUser ? auth.currentUser.uid : "No user from auth object");
    console.log("SRD Save: Current User from currentUser_extra variable:", currentUser_extra ? currentUser_extra.uid : "No user from currentUser_extra");
    console.log("SRD Save: Expected Admin UID:", 'PBVTn1GvcAfIZWNLzuP1brUtJDu1');

    // Use the UID from the auth object directly for the most reliable check
    if (!auth.currentUser || auth.currentUser.uid !== 'PBVTn1GvcAfIZWNLzuP1brUtJDu1') {
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Permission Denied: You are not authorized to perform this action.";
            srdStatusMessage_el_extra.style.color = "#e74c3c";
        }
        console.error("SRD Save: Permission Denied. UID mismatch or no authenticated user. Actual UID:", auth.currentUser ? auth.currentUser.uid : "null");
        return; // Stop if not the admin user
    }


    if (!confirm(`Are you sure you want to schedule the DELETION of all data for route "${routeName}" to occur on ${goLiveDateObj.toLocaleString()}? This action, once processed, cannot be easily undone.`)) {
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Scheduled deletion cancelled by user.";
            srdStatusMessage_el_extra.style.color = "";
        }
        return;
    }

    const deletionTask = {
        taskType: "deleteEntireRoute",
        routeName: routeName,
        goLiveDateTime: goLiveDateObj.toISOString(),
        scheduledAt: new Date().toISOString(),
        status: "pending",
        userEmail: currentUser_extra.email // currentUser_extra should be the admin user here
    };

    if (srdStatusMessage_el_extra) {
        srdStatusMessage_el_extra.textContent = `Scheduling deletion for route "${routeName}"...`;
        srdStatusMessage_el_extra.style.color = "#3498db";
    }

    try {
        const deletionTaskKey = `delSched_${Date.now()}_${sanitizeFirebaseKey(routeName)}`;
        await dbSet(dbRef(database, `${FB_PATH_SCHEDULED_DELETIONS}/${deletionTaskKey}`), deletionTask);

        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = `Deletion for route "${routeName}" successfully scheduled for ${goLiveDateObj.toLocaleString()}. It will appear in the 'Scheduled Tasks' list.`;
            srdStatusMessage_el_extra.style.color = "#2ecc71";
        }
        if(srdRouteNameInput_el_extra) srdRouteNameInput_el_extra.value = '';
        if(srdRouteNameSelect_el_extra) srdRouteNameSelect_el_extra.value = '';
        if(srdGoLiveDateTimeInput_el_extra) srdGoLiveDateTimeInput_el_extra.value = '';

    } catch (error) {
        console.error("Error scheduling route deletion to Firebase:", error); // This will show the permission denied
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Error scheduling deletion: " + error.message;
            srdStatusMessage_el_extra.style.color = "#e74c3c";
        }
    }
}

        function getYYYYMMDD_ExtraPage(dateSource) { const d = dateSource ? new Date(dateSource) : new Date(); const year = d.getFullYear(); const month = String(d.getMonth() + 1).padStart(2, '0'); const day = String(d.getDate()).padStart(2, '0'); return `${year}-${month}-${day}`; }
        function formatDateToDDMonthYYYY_ExtraPage(dateStringYYYYMMDD) { if (!dateStringYYYYMMDD || !/^\d{4}-\d{2}-\d{2}$/.test(dateStringYYYYMMDD)) return "Invalid Date"; const [year, month, day] = dateStringYYYYMMDD.split('-'); const dateObj = new Date(year, month - 1, day); const options = { day: '2-digit', month: 'long', year: 'numeric' }; return dateObj.toLocaleDateString('en-GB', options); }
        function getUniqueStopsFromSchedule_ExtraPage() { if (!currentWorkingSchedule_extra || currentWorkingSchedule_extra.length === 0) return []; const stopsMap = new Map(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID && !stopsMap.has(entry.stopID.toUpperCase())) { stopsMap.set(entry.stopID.toUpperCase(), { stopID: entry.stopID, stopName: entry.stopName || "Unknown Name", direction: entry.direction || "No Direction" }); } }); return Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase())); }
        function parseLineName_ExtraPage(lineNameStr) { const name = String(lineNameStr || "").toUpperCase().trim(); const numericPrefixRegex = new RegExp(/^(\d+)([A-Z]*)$/); const alphaNumericRegex = new RegExp(/^([A-Z]+)(\d+)?([A-Z]*)$/); const numericPrefixMatch = name.match(numericPrefixRegex); if (numericPrefixMatch) return { type: 'numeric', number: parseInt(numericPrefixMatch[1], 10), suffix: numericPrefixMatch[2] || '', original: name }; const alphaNumericMatch = name.match(alphaNumericRegex); if (alphaNumericMatch) return { type: 'alpha', prefix: alphaNumericMatch[1], number: alphaNumericMatch[2] ? parseInt(alphaNumericMatch[2], 10) : null, suffix: alphaNumericMatch[3] || '', original: name }; return { type: 'other', original: name }; }
        function compareLineNames_ExtraPage(lineAStr, lineBStr) { const parsedA = parseLineName_ExtraPage(lineAStr); const parsedB = parseLineName_ExtraPage(lineBStr); if (parsedA.type === 'numeric' && parsedB.type === 'alpha') return -1; if (parsedA.type === 'alpha' && parsedB.type === 'numeric') return 1; if (parsedA.type === 'numeric' && parsedB.type === 'numeric') { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type === 'alpha' && parsedB.type === 'alpha') { const prefixCompare = parsedA.prefix.localeCompare(parsedB.prefix); if (prefixCompare !== 0) return prefixCompare; if (parsedA.number === null && parsedB.number !== null) return -1; if (parsedA.number !== null && parsedB.number === null) return 1; if (parsedA.number !== null && parsedB.number !== null) { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; } return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type !== 'other' && parsedB.type === 'other') return -1; if (parsedA.type === 'other' && parsedB.type !== 'other') return 1; return (parsedA.original || "").localeCompare(parsedB.original || ""); }
        const initialRouteColourMapForTools_extra = {}; const DEFAULT_ROUTE_COLOUR_TOOLS_extra = "#73809C"; const NIGHT_BUS_BLUE_COLOR_extra = (initialRouteColourMapForTools_extra["NIGHT_DEFAULT"] || "#4CDBE6").toUpperCase();
        function getRouteTileColour_ExtraPage(lineName, stopID = null) { const upName = String(lineName || "").toUpperCase(); if (stopID && stopSpecificRouteColours_extra[stopID.toUpperCase()] && stopSpecificRouteColours_extra[stopID.toUpperCase()][upName]) { return stopSpecificRouteColours_extra[stopID.toUpperCase()][upName]; } if (globalCustomRouteColours_extra[upName]) return globalCustomRouteColours_extra[upName]; if (initialRouteColourMapForTools_extra[upName]) return initialRouteColourMapForTools_extra[upName]; if (upName.startsWith("N")) return globalCustomRouteColours_extra["NIGHT_DEFAULT"] || NIGHT_BUS_BLUE_COLOR_extra; if (upName.startsWith("SL")) return globalCustomRouteColours_extra["SL_DEFAULT"] || "#D32F2F"; return DEFAULT_ROUTE_COLOUR_TOOLS_extra; }
        function getTextColourForBackground_ExtraPage(hex) { if(!hex || hex.length < 7) return '#FFFFFF'; const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16); return ((0.299*r + 0.587*g + 0.114*b)/255) > 0.5 ? '#000000' : '#FFFFFF'; }
        
async function fetchBankHolidays_ExtraPage() {
            const cacheKeyData = 'omsiToolsBankHolidaysData';
            const cacheKeyExpiry = 'omsiToolsBankHolidaysExpiry';
            const now = new Date().getTime();

            try {
                const cachedExpiryString = localStorage.getItem(cacheKeyExpiry);
                if (cachedExpiryString) {
                    const cachedExpiry = parseInt(cachedExpiryString, 10);
                    if (now < cachedExpiry) {
                        const cachedDataString = localStorage.getItem(cacheKeyData);
                        if (cachedDataString) {
                            ukBankHolidaysData_extra = JSON.parse(cachedDataString);
                            console.log("ExtraPage: Loaded UK bank holidays from cache.");
                            // The call to updateCurrentProfileDisplay_ExtraPage() was removed from here previously.
                            return; // Data loaded from cache, no need to fetch
                        }
                    } else {
                        console.log("ExtraPage: Bank holiday cache expired.");
                    }
                }
            } catch (e) {
                console.warn("ExtraPage: Error reading bank holidays from localStorage, will attempt fetch.", e);
            }

            console.log("ExtraPage: Fetching UK bank holidays from network (https://www.gov.uk/bank-holidays.json)...");
            try {
                const response = await fetch('https://www.gov.uk/bank-holidays.json');
                if (!response.ok) {
                    // Attempt to use stale cache data if fetch fails
                    const staleDataString = localStorage.getItem(cacheKeyData);
                    if (staleDataString) {
                        console.warn(`ExtraPage: HTTP error ${response.status} fetching bank holidays. Using stale cache data if available.`);
                        ukBankHolidaysData_extra = JSON.parse(staleDataString);
                    } else {
                        // No stale data, and fetch failed
                        throw new Error(`HTTP error! status: ${response.status}. No cache available.`);
                    }
                } else {
                    const data = await response.json();
                    if (data['england-and-wales'] && data['england-and-wales'].events) {
                        const events = data['england-and-wales'].events;
                        ukBankHolidaysData_extra = {
                            dates: events.map(event => event.date),
                            titles: events.reduce((acc, event) => { acc[event.date] = event.title; return acc; }, {})
                        };
                        try {
                            localStorage.setItem(cacheKeyData, JSON.stringify(ukBankHolidaysData_extra));
                            localStorage.setItem(cacheKeyExpiry, (now + BANK_HOLIDAY_CACHE_DURATION_MS).toString());
                            console.log("ExtraPage: Fetched and cached UK bank holidays for 24 hours.");
                        } catch (e) {
                            console.warn("ExtraPage: Error saving bank holidays to localStorage. Data might be very large or storage full.", e);
                        }
                    } else {
                        ukBankHolidaysData_extra = { dates: [], titles: {} }; // Fallback to empty if data structure is unexpected
                        console.warn("ExtraPage: Bank holiday data from network was in an unexpected format.");
                    }
                }
            } catch (error) {
                console.error("ExtraPage: Critical error fetching UK bank holidays:", error);
                // Attempt to use stale cache even on critical fetch error
                const staleDataString = localStorage.getItem(cacheKeyData);
                if (staleDataString) {
                    console.warn(`ExtraPage: Using stale cache data due to critical fetch error: ${error.message}`);
                    ukBankHolidaysData_extra = JSON.parse(staleDataString);
                } else {
                    ukBankHolidaysData_extra = { dates: [], titles: {} }; // Default to empty if fetch fails & no stale cache
                }
                // Only update UI to show failure if no data at all could be presented
                if(currentProfileDisplayElement_el && (!staleDataString && Object.keys(ukBankHolidaysData_extra.titles).length === 0)) {
                     currentProfileDisplayElement_el.textContent = "Today's Operating Profile: (Bank Hol. check failed)";
                }
            }
            // The call to updateCurrentProfileDisplay_ExtraPage(); was correctly removed from here.
            // loadInitialData_ExtraPage will call it after this function completes.
        }

        function isSchoolHolidayPeriod_ExtraPage(dateObject) { if (!schoolHolidayDateRanges_extra || schoolHolidayDateRanges_extra.length === 0) return false; const checkTime = dateObject.getTime(); for (const range of schoolHolidayDateRanges_extra) { try { const startTime = new Date(range.start + "T00:00:00").getTime(); const endTime = new Date(range.end + "T23:59:59").getTime(); if (checkTime >= startTime && checkTime <= endTime) return true; } catch (e) { console.error("Invalid date in schoolHolidayDateRanges_extra:", range, e); } } return false; }
      
  function getOperatingCodesForDate_ExtraPage(dateObject) {
    const n = dateObject;
    const dOW = n.getDay();
    const todayDateString = `${n.getFullYear()}-${String(n.getMonth() + 1).padStart(2, '0')}-${String(n.getDate()).padStart(2, '0')}`;
    let potentialDateCodes = new Set();
    let isBankHolidayToday = false;

    if (ukBankHolidaysData_extra && ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(todayDateString)) {
        const holidayTitle = ukBankHolidaysData_extra.titles[todayDateString] || "";
        isBankHolidayToday = true;
        if (holidayTitle.toLowerCase().includes("good friday")) {
            potentialDateCodes.add("Sa");
        } else {
            potentialDateCodes.add("Su");
        }
    }

    if (!isBankHolidayToday) {
        const isSchHol = isSchoolHolidayPeriod_ExtraPage(n);
        const schoolSuffix = isSchHol ? "NSD" : "Sch";
        let dayCode = "";
        switch (dOW) {
            case 0: dayCode = "Su"; break;
            case 1: dayCode = "Mo"; break;
            case 2: dayCode = "Tu"; break;
            case 3: dayCode = "We"; break;
            case 4: dayCode = "Th"; break;
            case 5: dayCode = "Fr"; break;
            case 6: dayCode = "Sa"; break;
        }
        potentialDateCodes.add(dayCode);
        if (dOW >= 1 && dOW <= 5) {
            potentialDateCodes.add(dayCode + schoolSuffix);
            potentialDateCodes.add("MF" + schoolSuffix);
            potentialDateCodes.add("MF");
        }
    }
    
    const finalFilteredCodes = Array.from(potentialDateCodes).filter(code => 
        typeof RSG_OPERATING_PROFILES_LIST !== 'undefined' && RSG_OPERATING_PROFILES_LIST.includes(code)
    );
    
    return finalFilteredCodes;
}

        // Inside omsi_tools_extra.html

async function updateCurrentProfileDisplay_ExtraPage() {
    const now = new Date();
    const todayDateString = getYYYYMMDD_ExtraPage(now); 
    let profileDisplayText = "";
    let serviceTypeDisplay = ""; 
    let operatingCodes = [];
    let isOverridden = false;
    let finalDisplayLabel = "Today's Operating Profile:"; 

    if (window.firebaseOMSI && window.firebaseOMSI.database && currentUser_extra) {
        const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
        try {
            const overrideSnap = await dbGet(dbChild(dbRef(database), `${FB_PATH_OPERATIONAL_OVERRIDES}/${todayDateString}`));
            if (overrideSnap.exists()) {
                const overrideProfileValue = overrideSnap.val();
                profileDisplayText = `${overrideProfileValue} (Manual Override)`;
                operatingCodes = [overrideProfileValue];
                isOverridden = true;
                finalDisplayLabel = "Today's Profile:"; 
            }
        } catch (error) {
            console.error("Error fetching today's override for profile display:", error);
        }
    }

    if (!isOverridden) {
        let isBankHol = false;
        if (ukBankHolidaysData_extra && ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(todayDateString)) {
            let holidayTitle = ukBankHolidaysData_extra.titles[todayDateString] || "Bank Holiday";
            // --- MODIFICATION HERE ---
            holidayTitle = toTitleCase_display(holidayTitle); // Apply title case
            // --- END MODIFICATION ---
            isBankHol = true;
            if (holidayTitle.toLowerCase().includes("good friday")) { // Keep toLowerCase for logic
                profileDisplayText = holidayTitle;
                serviceTypeDisplay = "(Saturday Service)";
            } else {
                profileDisplayText = holidayTitle;
                serviceTypeDisplay = "(Sunday Service)";
            }
        }

        let dayName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][now.getDay()];

        if (!isBankHol) {
            profileDisplayText = dayName;
            if (isSchoolHolidayPeriod_ExtraPage(now)) { 
                profileDisplayText += " (School Holiday)";
            }
        } else {
            profileDisplayText += ` ${serviceTypeDisplay} - Observed on a ${dayName}`;
            if (isSchoolHolidayPeriod_ExtraPage(now)) {
                profileDisplayText += " (School Holiday Period)";
            }
        }
        operatingCodes = getOperatingCodesForDate_ExtraPage(now); 
    }

    if (currentProfileDisplayElement_el) {
        if (isOverridden) {
            currentProfileDisplayElement_el.textContent = `${finalDisplayLabel} ${profileDisplayText}`;
        } else {
            const codesString = operatingCodes.length > 0 ? ` [Codes: ${operatingCodes.join(', ')}]` : " [Codes: N/A]";
            currentProfileDisplayElement_el.textContent = `${finalDisplayLabel} ${profileDisplayText}${codesString}`;
        }
    }
}

        // --- Day Profile Override Functions ---
        async function loadAndDisplayOverrides_ExtraPage() { if (!activeOverridesList_el_extra || !window.firebaseOMSI) return; activeOverridesList_el_extra.innerHTML = '<p>Loading active overrides...</p>'; const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const snapshot = await dbGet(dbChild(dbRef(database), FB_PATH_OPERATIONAL_OVERRIDES)); let html = ""; if (snapshot.exists()) { const overrides = snapshot.val(); const today = new Date(); today.setHours(0,0,0,0); const thirtyDaysLater = new Date(today); thirtyDaysLater.setDate(today.getDate() + 90); const relevantOverrides = []; for (const dateKey in overrides) { if (/^\d{4}-\d{2}-\d{2}$/.test(dateKey)) { const overrideDate = new Date(dateKey + "T00:00:00"); if (overrideDate >= today && overrideDate <= thirtyDaysLater) { relevantOverrides.push({ date: dateKey, profile: overrides[dateKey] }); } } } relevantOverrides.sort((a,b) => a.date.localeCompare(b.date)); if (relevantOverrides.length > 0) { html = "<ul>"; relevantOverrides.forEach(ov => { html += `<li><strong>${formatDateToDDMonthYYYY_ExtraPage(ov.date)}:</strong> ${ov.profile}</li>`; }); html += "</ul>"; } else { html = "<p>No overrides set for the next 30 days.</p>"; } } else { html = "<p>No overrides currently set in the system.</p>"; } activeOverridesList_el_extra.innerHTML = html; } catch (error) { console.error("Error loading overrides:", error); activeOverridesList_el_extra.innerHTML = "<p>Error loading overrides.</p>"; } }
        
async function updateSelectedDateInfo_ExtraPage() {
    if (!overrideDateInput_el_extra || !selectedDateDisplay_el_extra || !autoProfileForSelectedDate_el_extra || !currentOverrideForSelectedDate_el_extra || !clearOverrideButton_el_extra) return;
    const selectedDateStr = overrideDateInput_el_extra.value;
    clearOverrideButton_el_extra.style.display = 'none';

    // Clear DPO checkboxes before updating
    dpo_clearProfileSelections_ExtraPage(); 

    if (!selectedDateStr) {
        selectedDateDisplay_el_extra.textContent = "(select a date)";
        autoProfileForSelectedDate_el_extra.textContent = "(select a date)";
        currentOverrideForSelectedDate_el_extra.textContent = "(select a date)";
        // dpo_clearProfileSelections_ExtraPage(); // Already called above
        return;
    }
    selectedDateDisplay_el_extra.textContent = formatDateToDDMonthYYYY_ExtraPage(selectedDateStr);
    const dateObj = new Date(selectedDateStr + "T00:00:00");
    const autoCodes = getOperatingCodesForDate_ExtraPage(dateObj); // Ensure this uses RSG_OPERATING_PROFILES_LIST if DPO one isn't separate
    autoProfileForSelectedDate_el_extra.textContent = autoCodes.join(', ') || "N/A";

    if (window.firebaseOMSI) {
        const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
        try {
            const overrideSnap = await dbGet(dbChild(dbRef(database), `${FB_PATH_OPERATIONAL_OVERRIDES}/${selectedDateStr}`));
            if (overrideSnap.exists()) {
                const overrideProfileString = overrideSnap.val();
                currentOverrideForSelectedDate_el_extra.textContent = overrideProfileString;
                currentOverrideForSelectedDate_el_extra.style.color = "#f1c40f";
                clearOverrideButton_el_extra.style.display = 'inline-block';
                dpo_setCheckedProfiles_ExtraPage(overrideProfileString); // << MODIFIED: Set checkboxes
            } else {
                currentOverrideForSelectedDate_el_extra.textContent = "(none)";
                currentOverrideForSelectedDate_el_extra.style.color = "";
                // dpo_clearProfileSelections_ExtraPage(); // Already called at the top
            }
        } catch (error) {
            console.error("Error fetching override for selected date:", error);
            currentOverrideForSelectedDate_el_extra.textContent = "(error fetching)";
            // dpo_clearProfileSelections_ExtraPage(); // Already called at the top
        }
    }
}
        async function handleSetOverride_ExtraPage() {
            // --- START: Added Debugging ---
            console.log("DPO Set Action: Attempting to set override.");
            if (window.firebaseOMSI && window.firebaseOMSI.auth) {
                const authInstance = window.firebaseOMSI.auth;
                console.log("DPO Set Action: Firebase SDK auth.currentUser UID:", authInstance.currentUser ? authInstance.currentUser.uid : "SDK auth.currentUser is null");
            }
            console.log("DPO Set Action: currentUser_extra variable UID:", currentUser_extra ? currentUser_extra.uid : "currentUser_extra is null");
            console.log("DPO Set Action: Expected Admin UID for write:", 'PBVTn1GvcAfIZWNLzuP1brUtJDu1');
            // --- END: Added Debugging ---

            if (!currentUser_extra || !overrideDateInput_el_extra /* Ensure overrideProfileInput_el_extra is removed if using DPO checkboxes */ || !overrideStatusMessage_el_extra || !window.firebaseOMSI) { 
                if (overrideStatusMessage_el_extra) {
                    overrideStatusMessage_el_extra.textContent = "Error: System not ready or not logged in."; 
                    overrideStatusMessage_el_extra.style.color="#e74c3c";
                }
                console.error("DPO Set: Prerequisite check failed (currentUser_extra, DOM elements for date/status, or Firebase).");
                return; 
            }

            const dateKey = overrideDateInput_el_extra.value;
            const profile = dpo_getSelectedOpProfilesString_ExtraPage(); // Gets profile from DPO checkboxes

            if (!dateKey) { 
                overrideStatusMessage_el_extra.textContent = "Please select a date."; 
                overrideStatusMessage_el_extra.style.color="#e74c3c"; 
                return; 
            }
            if (!profile) { 
                overrideStatusMessage_el_extra.textContent = "Please select an override profile using the checkboxes."; 
                overrideStatusMessage_el_extra.style.color="#e74c3c"; 
                return; 
            }

            const { database, dbSet, dbRef } = window.firebaseOMSI; 
            try {
                console.log(`DPO Set: Attempting Firebase write to /operationalOverrides/${dateKey} with profile: "${profile}"`);
                await dbSet(dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${dateKey}`), profile);
                
                overrideStatusMessage_el_extra.textContent = `Override for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)} set to "${profile}".`;
                overrideStatusMessage_el_extra.style.color="#2ecc71";
                
                if (typeof loadAndDisplayOverrides_ExtraPage === 'function') loadAndDisplayOverrides_ExtraPage();
                if (typeof updateSelectedDateInfo_ExtraPage === 'function') updateSelectedDateInfo_ExtraPage(); 
                
                if (dateKey === getYYYYMMDD_ExtraPage(new Date())) { // If today's date was overridden
                    if (typeof updateCurrentProfileDisplay_ExtraPage === 'function') await updateCurrentProfileDisplay_ExtraPage();    
                }
            } catch (error) {
                console.error("DPO Set: Error setting override:", error); 
                overrideStatusMessage_el_extra.textContent = "Error setting override: " + error.message; // This will show Firebase permission denied
                overrideStatusMessage_el_extra.style.color="#e74c3c";
            } 
        }

async function handleClearOverride_ExtraPage() {
            // --- START: Added Debugging ---
            console.log("DPO Clear Action: Attempting to clear override.");
            if (window.firebaseOMSI && window.firebaseOMSI.auth) {
                const authInstance = window.firebaseOMSI.auth;
                console.log("DPO Clear Action: Firebase SDK auth.currentUser UID:", authInstance.currentUser ? authInstance.currentUser.uid : "SDK auth.currentUser is null");
            }
            console.log("DPO Clear Action: currentUser_extra variable UID:", currentUser_extra ? currentUser_extra.uid : "currentUser_extra is null");
            console.log("DPO Clear Action: Expected Admin UID for write:", 'PBVTn1GvcAfIZWNLzuP1brUtJDu1');
            // --- END: Added Debugging ---

            if (!currentUser_extra || !overrideDateInput_el_extra || !overrideStatusMessage_el_extra || !window.firebaseOMSI) {
                if (overrideStatusMessage_el_extra) {
                    overrideStatusMessage_el_extra.textContent = "Error: System not ready or not logged in for clear.";
                    overrideStatusMessage_el_extra.style.color="#e74c3c";
                }
                console.error("DPO Clear: Prerequisite check failed.");
                return;
            }
            const dateKey = overrideDateInput_el_extra.value;
            if (!dateKey) {
                overrideStatusMessage_el_extra.textContent = "Please select a date to clear its override.";
                overrideStatusMessage_el_extra.style.color="#e74c3c";
                return;
            }

            // Check if an override actually exists for this date before confirming deletion
            const { database, dbGet, dbRemove, dbRef, dbChild } = window.firebaseOMSI;
            const overrideRef = dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${dateKey}`);
            const currentOverrideSnap = await dbGet(overrideRef);

            if (!currentOverrideSnap.exists()) {
                overrideStatusMessage_el_extra.textContent = `No override found for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)} to clear.`;
                overrideStatusMessage_el_extra.style.color="#f1c40f";
                if (clearOverrideButton_el_extra) clearOverrideButton_el_extra.style.display = 'none'; // Hide button if nothing to clear
                dpo_clearProfileSelections_ExtraPage(); // Clear checkboxes as well
                return;
            }

            if (!confirm(`Are you sure you want to clear the override for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)}?`)) {
                overrideStatusMessage_el_extra.textContent = "Clear override cancelled.";
                overrideStatusMessage_el_extra.style.color="#7f8c8d";
                return;
            }
            
            try {
                console.log(`DPO Clear: Attempting Firebase remove for /operationalOverrides/${dateKey}`);
                await dbRemove(overrideRef); // Use the ref directly
                
                overrideStatusMessage_el_extra.textContent = `Override for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)} cleared.`;
                overrideStatusMessage_el_extra.style.color="#2ecc71";
                
                // This is the crucial call to ensure checkboxes are cleared
                dpo_clearProfileSelections_ExtraPage(); 
                
                loadAndDisplayOverrides_ExtraPage(); // Refresh the list of active overrides
                updateSelectedDateInfo_ExtraPage();  // Update the display for the selected date
                
                // If today's date was cleared, refresh the main profile display
                if (dateKey === getYYYYMMDD_ExtraPage(new Date())) {
                    await updateCurrentProfileDisplay_ExtraPage();    
                }
            } catch (error) {
                console.error("DPO Clear: Error clearing override:", error);
                overrideStatusMessage_el_extra.textContent = "Error clearing override: " + error.message; 
                overrideStatusMessage_el_extra.style.color="#e74c3c";
            }
        }

        // Make sure the second, shorter definition of handleClearOverride_ExtraPage (previously around lines 1136-1149)
        // is REMOVED from your file.


        // --- Ancillary Data Save Function ---
        async function updateAncillaryScheduleData_ExtraPage() {
            if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available for ancillary data update.");
            const { database, dbSet, dbUpdate, dbRef } = window.firebaseOMSI;

            // 1. Regenerate uniqueBusStops from the current in-memory flat schedule
            const stopsMap = new Map();
            currentWorkingSchedule_extra.forEach(row => {
                if (row.stopID && !stopsMap.has(row.stopID.toUpperCase())) {
                    stopsMap.set(row.stopID.toUpperCase(), { stopID: row.stopID, stopName: row.stopName, direction: row.direction });
                }
            });
            const finalUniqueStops = Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase()));

            try {
                console.log("Attempting to save unique bus stops (ancillary)...");
                await dbSet(dbRef(database, FB_PATH_LIVE_UNIQUE_STOPS), finalUniqueStops);
                console.log("Unique bus stops saved. Attempting to save last updated timestamp (ancillary)...");
                await dbUpdate(dbRef(database), { [FB_PATH_APPSTATE_LAST_UPDATED]: new Date().toISOString() });
                console.log("Ancillary schedule data (unique stops, timestamp) updated.");
            } catch (error) {
                console.error("Error saving ancillary schedule data:", error);
                // Decide if this error should be propagated or just logged
                throw error; // Propagate for now
            }
        }

        // --- REBUILDS ENTIRE SCHEDULE in new structured format ---
        async function rebuildAndSaveEntireScheduleToFirebase_ExtraPage(flatScheduleDataToSave) {
    if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available.");
    const { database, dbSet, dbRef } = window.firebaseOMSI;

    console.log("Rebuilding entire schedule into new nested structure (in memory)...");
    const newSchedulesByRoute = {}; // This object will be built in memory first
    flatScheduleDataToSave.forEach(entry => {
        if (!entry.lineName || !entry.OperatingProfile || !entry.destinationName) {
            console.warn("Skipping entry with missing route/profile/destination:", entry);
            return;
        }
        const saneRoute = sanitizeFirebaseKey(entry.lineName);
        const saneProfile = sanitizeFirebaseKey(entry.OperatingProfile);
        const saneDest = sanitizeFirebaseKey(entry.destinationName);

        if (!newSchedulesByRoute[saneRoute]) newSchedulesByRoute[saneRoute] = {};
        if (!newSchedulesByRoute[saneRoute][saneProfile]) newSchedulesByRoute[saneRoute][saneProfile] = {};
        if (!newSchedulesByRoute[saneRoute][saneProfile][saneDest]) newSchedulesByRoute[saneRoute][saneProfile][saneDest] = { entries: [] };
        
        const entryForStorage = { ...entry };
        // Ensure these key fields are present in the stored entry, even if they were part of the key structure
        entryForStorage.lineName = entry.lineName;
        entryForStorage.OperatingProfile = entry.OperatingProfile;
        entryForStorage.destinationName = entry.destinationName;

        newSchedulesByRoute[saneRoute][saneProfile][saneDest].entries.push(entryForStorage);
    });

    // Sort entries within each R/P/D for consistency
    for (const routeKey in newSchedulesByRoute) {
        for (const profileKey in newSchedulesByRoute[routeKey]) {
            for (const destKey in newSchedulesByRoute[routeKey][profileKey]) {
                newSchedulesByRoute[routeKey][profileKey][destKey].entries.sort((a, b) => {
                    const timeA = (a.scheduledTime || "9999").replace(':', ''); // Use a sortable time format
                    const timeB = (b.scheduledTime || "9999").replace(':', '');
                    const timeCompare = timeA.localeCompare(timeB);
                    if (timeCompare !== 0) return timeCompare;
                    // Optional: Add secondary sort criteria if needed, e.g., by stopName or internalId
                    return (a.stopName || "").localeCompare(b.stopName || "");
                });
            }
        }
    }
    
    try {
        console.log(`Attempting to save schedule to Firebase using PER-ROUTE writes. Total routes: ${Object.keys(newSchedulesByRoute).length}`);
        
        const writePromises = [];

        // Clear the entire schedulesByRoute path first to ensure a clean slate.
        // This is a single delete operation for the parent path.
        console.log(`Clearing existing data at ${FB_PATH_SCHEDULES_BY_ROUTE} before writing new data...`);
        await dbSet(dbRef(database, FB_PATH_SCHEDULES_BY_ROUTE), null);
        console.log(`Path ${FB_PATH_SCHEDULES_BY_ROUTE} cleared.`);

        // Now write each route's data individually
        for (const saneRoute in newSchedulesByRoute) {
            if (Object.hasOwnProperty.call(newSchedulesByRoute, saneRoute)) { // Ensure it's an own property
                const routeData = newSchedulesByRoute[saneRoute];
                const routePath = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}`;
                console.log(`Writing data for route: ${saneRoute} to path: ${routePath}`);
                writePromises.push(dbSet(dbRef(database, routePath), routeData));
            }
        }

        await Promise.all(writePromises);
        console.log("Entire schedule saved successfully to Firebase using per-route writes.");

        // After a full rebuild, also update ancillary data
        await updateAncillaryScheduleData_ExtraPage(); // Uses the global currentWorkingSchedule_extra

    } catch (error) {
        console.error("Error saving entire rebuilt schedule with per-route writes:", error);
        // This error will be propagated to the calling function (e.g., handleBulkAddStops_ExtraPage)
        // which should then inform the user via its status message element.
        throw error; 
    }
}


        // --- Stop Management Functions ---
        function getBaseStopName_ExtraPage(fullStopName) { if (!fullStopName) return ""; let baseName = String(fullStopName).trim(); baseName = baseName.replace(/\s*\(Stand [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\(Bay [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\(Stop [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\([A-Z0-9]\)\s*$/i, ''); baseName = baseName.replace(/\s*-\s*Bay\s*[A-Z0-9]+\s*$/i,''); baseName = baseName.replace(/\s*Stop\s*[A-Z0-9]+\s*$/i,''); return baseName.trim(); }
        function getRandomIdFormat_ExtraPage() { const formats = ["NUM", "BP", "LE", "RO"]; return formats[Math.floor(Math.random() * formats.length)]; }
        function generateUniqueStopId_ExtraPage(format, stopName = "", allExistingStopIDsSet) { const targetBaseName = getBaseStopName_ExtraPage(stopName).toUpperCase(); let prefix = ""; let numericRegex; let baseStartNumber = 1; const MAX_NUMERIC_PART = 99999; switch (format) { case "NUM": prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; case "BP": prefix = "BP"; numericRegex = /^BP(\d+)$/; baseStartNumber = 1; break; case "LE": prefix = "LE"; numericRegex = /^LE(\d+)$/; baseStartNumber = 1; break; case "RO": prefix = "RO"; numericRegex = /^RO(\d+)$/; baseStartNumber = 1; break; default: console.warn(`generateUniqueStopId_ExtraPage: Unknown format "${format}", defaulting to NUM.`); format="NUM"; prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; if (/^[A-Z]+$/.test(format)) {prefix = format.toUpperCase(); numericRegex = new RegExp(`^${prefix}(\\d+)$`); baseStartNumber = 1;} break; } let highestNumInNameSequence = 0; let nameSpecificSequenceFound = false; if (targetBaseName && currentWorkingSchedule_extra) { currentWorkingSchedule_extra.forEach(entry => { if (entry.stopName && entry.stopID) { const existingEntryBaseName = getBaseStopName_ExtraPage(entry.stopName).toUpperCase(); if (existingEntryBaseName === targetBaseName) { const match = entry.stopID.toUpperCase().match(numericRegex); if (match && match[1]) { const numPart = parseInt(match[1], 10); if (!isNaN(numPart) && numPart <= MAX_NUMERIC_PART && numPart > highestNumInNameSequence) { highestNumInNameSequence = numPart; } nameSpecificSequenceFound = true; } } } }); } let nextNumInSequence = nameSpecificSequenceFound ? highestNumInNameSequence + 1 : baseStartNumber; if (format === "NUM" && nextNumInSequence < 101) nextNumInSequence = 101; if (baseStartNumber > MAX_NUMERIC_PART) { console.warn(`Suggest ID (single): Base start ${baseStartNumber} for ${format} exceeds MAX. Fallback.`); return prefix + "MAX_S_ERR" + Math.floor(Math.random()*1000); } let attempts = 0; const maxAttempts = MAX_NUMERIC_PART + 2000; let candidateId = ""; while (attempts < maxAttempts) { if (nextNumInSequence > MAX_NUMERIC_PART) { console.warn(`Suggest ID (single): All numbers up to ${MAX_NUMERIC_PART} exhausted for ${prefix}, base ${targetBaseName}. Fallback.`); let fA = 0, fId; do { fId = prefix + "RND" + String(Date.now()).slice(-3) + (Math.floor(Math.random()*900)+100); fA++; if (fA > 50) return prefix + "FB_FAIL" + Math.floor(Math.random()*1000); } while (allExistingStopIDsSet.has(fId.toUpperCase())); return fId; } candidateId = prefix + nextNumInSequence; if (!allExistingStopIDsSet.has(candidateId.toUpperCase())) return candidateId; nextNumInSequence++; attempts++; } console.warn(`CRITICAL: Could not generate unique Stop ID for ${format}, name: "${stopName}". Final fallback.`); let fA2 = 0, fId2; do { fId2 = prefix + "ULTRA_FB" + String(Date.now()).slice(-5) + (Math.floor(Math.random()*90)+10); fA2++; if (fA2 > 50) return prefix + "ULTRA_CRIT_FAIL" + Math.floor(Math.random()*100); } while (allExistingStopIDsSet.has(fId2.toUpperCase())); return fId2; }
        function autoGenerateAndSetNewStopId_ExtraPage() { if (!currentUser_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !selectNewStopIdFormat_el_extra) return; const currentStopName = inputNewStopName_el_extra.value.trim(); if (!currentStopName) { inputNewStopId_el_extra.value = ""; selectNewStopIdFormat_el_extra.selectedIndex = 0; if(addNewStopStatus_el_extra) {addNewStopStatus_el_extra.textContent = "Enter stop name for ID suggestion."; addNewStopStatus_el_extra.style.color = "";} if (newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = ''; return; } const actualBaseName = getBaseStopName_ExtraPage(currentStopName).toUpperCase(); let formatToUse = null; if (actualBaseName && currentWorkingSchedule_extra && currentWorkingSchedule_extra.length > 0) { for (const existingEntry of currentWorkingSchedule_extra) { if (existingEntry.stopID && existingEntry.stopName) { const existingEntryBaseName = getBaseStopName_ExtraPage(existingEntry.stopName).toUpperCase(); if (existingEntryBaseName === actualBaseName) { const existingId = existingEntry.stopID.toUpperCase(); if (existingId.startsWith("BP") && /BP\d+/.test(existingId)) formatToUse = "BP"; else if (existingId.startsWith("LE") && /LE\d+/.test(existingId)) formatToUse = "LE"; else if (existingId.startsWith("RO") && /RO\d+/.test(existingId)) formatToUse = "RO"; else if (/^\d+$/.test(existingId) && parseInt(existingId, 10) >= 100) formatToUse = "NUM"; if (formatToUse) break; } } } } if (!formatToUse) formatToUse = getRandomIdFormat_ExtraPage(); selectNewStopIdFormat_el_extra.value = formatToUse; const allCurrentScheduleIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase())); const suggestedId = generateUniqueStopId_ExtraPage(formatToUse, currentStopName, allCurrentScheduleIDs); inputNewStopId_el_extra.value = suggestedId; inputNewStopId_el_extra.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })); if (addNewStopStatus_el_extra) { addNewStopStatus_el_extra.textContent = `Auto-suggested ID: ${suggestedId} (Format: "${formatToUse}").`; addNewStopStatus_el_extra.style.color = '#bdc3c7'; } }
        async function handleAddStopDetails_ExtraPage() {
    if (!currentUser_extra || !addNewStopStatus_el_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !inputNewStopDirection_el_extra) {
        // Basic guards for UI elements
        if (addNewStopStatus_el_extra) {
            addNewStopStatus_el_extra.textContent = "Error: UI components missing for adding stop.";
            addNewStopStatus_el_extra.style.color = '#e74c3c';
        }
        return;
    }
    const newStopID = inputNewStopId_el_extra.value.trim().toUpperCase();
    const newStopName = inputNewStopName_el_extra.value.trim();
    const newStopDirection = inputNewStopDirection_el_extra.value.trim();

    if (!newStopID) { 
        addNewStopStatus_el_extra.textContent = "New Stop ID is required."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopId_el_extra.focus(); 
        return; 
    }
    if (!/^[A-Z0-9]+$/.test(newStopID)) { 
        addNewStopStatus_el_extra.textContent = "Stop ID: A-Z, 0-9 only."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopId_el_extra.focus(); 
        return; 
    }
    if (!newStopName) { 
        addNewStopStatus_el_extra.textContent = "New Stop Name is required."; 
        addNewStopStatus_el_extra.style.color = '#e74c3c'; 
        inputNewStopName_el_extra.focus(); 
        return; 
    }

    const existingStopIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase()));
    if (existingStopIDs.has(newStopID)) { 
        addNewStopStatus_el_extra.textContent = `Stop ID "${newStopID}" already exists.`; 
        if(newStopIdAvailability_el_extra){ 
            newStopIdAvailability_el_extra.textContent = 'ID already exists!'; 
            newStopIdAvailability_el_extra.style.color = '#e74c3c'; 
        } 
        inputNewStopId_el_extra.focus(); 
        return; 
    }

    // Create the minimal stop definition for the flat list
    const newStopDefinitionForFlatList = {
        internalId: `${newStopID}_definition_${Date.now()}`, // Unique internal ID
        stopID: newStopID,
        stopName: newStopName,
        direction: newStopDirection
        // No lineName, OperatingProfile, destinationName, scheduledTime, DayOffset are added here
        // as this is just a stop definition.
    };
    
    currentWorkingSchedule_extra.push(newStopDefinitionForFlatList); // Add to local working schedule

    addNewStopStatus_el_extra.textContent = `Adding stop "${newStopID}" and updating unique stops list in Firebase...`;
    addNewStopStatus_el_extra.style.color = '#f1c40f'; // Processing color

    try {
        // *** MODIFIED PART: Only update ancillary data (which saves unique stops) ***
        await updateAncillaryScheduleData_ExtraPage(); 
        
        addNewStopStatus_el_extra.textContent = `Stop "${newStopID} - ${newStopName}" definition added. Unique stops list updated in Firebase.`;
        addNewStopStatus_el_extra.style.color = '#2ecc71'; // Success color

        // Clear form fields for next entry
        inputNewStopId_el_extra.value = ''; 
        inputNewStopName_el_extra.value = ''; 
        inputNewStopDirection_el_extra.value = '';
        if(newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = '';
        if(selectNewStopIdFormat_el_extra) selectNewStopIdFormat_el_extra.selectedIndex = 0;
        
        // Auto-suggest for the next one if the function exists and elements are present
        if (typeof autoGenerateAndSetNewStopId_ExtraPage === 'function' && inputNewStopName_el_extra && inputNewStopId_el_extra) {
            autoGenerateAndSetNewStopId_ExtraPage();
        }
        
        renderUIDependentElements_ExtraPage(); // Refresh UI lists (like master stop list, dropdowns)

    } catch (error) {
        console.error("Error adding new stop definition (ancillary data update phase):", error);
        addNewStopStatus_el_extra.textContent = "Error saving stop definition to Firebase: " + error.message;
        addNewStopStatus_el_extra.style.color = '#e74c3c';
        
        // Important: Revert the local addition if Firebase update failed
        currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(
            entry => entry.internalId !== newStopDefinitionForFlatList.internalId
        );
        renderUIDependentElements_ExtraPage(); // Refresh UI to reflect reversion
    }
}
        function generateUniqueStopId_ExtraPage_BulkAware(format, stopName, newlyGeneratedIDsInBatchSet, baseNameAndFormatToGeneratedNumericPartsMap) { const targetBaseName = getBaseStopName_ExtraPage(stopName).toUpperCase(); let prefix = ""; let numericRegex; let baseStartNumber = 1; const MAX_NUMERIC_PART = 99999; switch (format) { case "NUM": prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; case "BP": prefix = "BP"; numericRegex = /^BP(\d+)$/; baseStartNumber = 1; break; case "LE": prefix = "LE"; numericRegex = /^LE(\d+)$/; baseStartNumber = 1; break; case "RO": prefix = "RO"; numericRegex = /^RO(\d+)$/; baseStartNumber = 1; break; default: console.warn(`generateUniqueStopId_ExtraPage_BulkAware (Replace Mode): Unknown format "${format}" for "${stopName}". Defaulting to NUM.`); format = "NUM"; prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; } const keyForMap = `${targetBaseName}_${format}`; if (!baseNameAndFormatToGeneratedNumericPartsMap.has(keyForMap)) { baseNameAndFormatToGeneratedNumericPartsMap.set(keyForMap, new Set()); } const numericPartsForThisGroup = baseNameAndFormatToGeneratedNumericPartsMap.get(keyForMap); let highestNumInGroup = 0; numericPartsForThisGroup.forEach(numStr => { const num = parseInt(numStr, 10); if (!isNaN(num) && num > highestNumInGroup) highestNumInGroup = num; }); let nextNumInSequence = highestNumInGroup > 0 ? highestNumInGroup + 1 : baseStartNumber; if (format === "NUM" && nextNumInSequence < 101) nextNumInSequence = 101; if (baseStartNumber > MAX_NUMERIC_PART) { console.warn(`BulkAware (Replace): Base start ${baseStartNumber} for ${format} exceeds MAX. Fallback.`); return prefix + "B_MAX_S_ERR" + Math.floor(Math.random()*1000); } let attempts = 0; const maxAttempts = MAX_NUMERIC_PART + 2000; let candidateId = ""; while (attempts < maxAttempts) { if (nextNumInSequence > MAX_NUMERIC_PART) { console.warn(`BulkAware (Replace): All numbers up to ${MAX_NUMERIC_PART} exhausted for ${prefix}, base ${targetBaseName}. Fallback.`); let fA = 0, fId; do { fId = prefix + "BRND" + String(Date.now()).slice(-4) + (Math.floor(Math.random()*900)+100); fA++; if (fA > 50) return prefix + "B_FB_FAIL" + Math.floor(Math.random()*1000); } while (newlyGeneratedIDsInBatchSet.has(fId.toUpperCase())); return fId; } candidateId = prefix + nextNumInSequence; if (!newlyGeneratedIDsInBatchSet.has(candidateId.toUpperCase())) { const match = candidateId.match(numericRegex); if(match && match[1]) numericPartsForThisGroup.add(match[1]); return candidateId; } nextNumInSequence++; attempts++; } console.warn(`CRITICAL_BULK (Replace): Could not generate unique Stop ID for ${format}, name: "${stopName}". Final fallback.`); let fA2 = 0, fId2; do { fId2 = prefix + "B_ULTRA_FB" + String(Date.now()).slice(-5) + (Math.floor(Math.random()*9000)+1000); fA2++; if (fA2 > 50) throw new Error("Bulk Fallback ID gen failed catastrophically."); } while (newlyGeneratedIDsInBatchSet.has(fId2.toUpperCase())); return fId2; }
        async function handleBulkAddStops_ExtraPage() {
            if (!currentUser_extra) { alert("Log in."); if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="Not logged in."; bulkAddNewStopsStatus_el_extra.style.color="#e74c3c";} return; }
            const stopsToProcessFromExcel = processedExcelStopsData_extra;
            if (!stopsToProcessFromExcel || stopsToProcessFromExcel.length === 0) { if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="No Excel data processed."; bulkAddNewStopsStatus_el_extra.style.color="#f1c40f";} return; }
            if (!confirm(`DANGER! This will DELETE ALL existing schedules and then add ${stopsToProcessFromExcel.length} stop definition(s) from Excel. This action CANNOT BE UNDONE. Proceed?`)) { if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="Bulk replace operation cancelled."; bulkAddNewStopsStatus_el_extra.style.color="#7f8c8d";} return; }
            if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = `Replacing all stops with ${stopsToProcessFromExcel.length} definitions from file...`; bulkAddNewStopsStatus_el_extra.style.color = '#f1c40f'; }
            let newFlatScheduleEntries = []; const newlyGeneratedOrUsedIDsInThisBatch = new Set(); const baseNameToFormatMapForThisBatch = new Map(); const baseNameAndFormatToGeneratedNumericPartsMap = new Map(); let errorsEncountered = 0; let totalPlaceholdersCreated = 0; let uniqueStopIDsAddedCount = 0; let statusMessages = [`Starting bulk replacement (Excel rows: ${stopsToProcessFromExcel.length})...\n`];
            for (const stopData of stopsToProcessFromExcel) {
                const excelStopName = (stopData.stopName || "").trim(); const excelDirection = (stopData.direction || "").trim(); const excelUserProvidedStopID = (stopData.userProvidedStopID || "").trim(); const excelBaseName = getBaseStopName_ExtraPage(excelStopName).toUpperCase();
                let excelLineNames = (stopData.lineNameInput && stopData.lineNameInput.trim() !== "") ? stopData.lineNameInput.split(',').map(ln => ln.trim().toUpperCase()).filter(ln => ln !== "") : ["INFO_ONLY"];
                if (excelLineNames.length === 0) excelLineNames = ["INFO_ONLY"];
                if (!excelStopName && !excelUserProvidedStopID) { statusMessages.push(`Row ${stopData.originalLineNumber}: Skipped. StopName or StopID required.`); errorsEncountered++; continue; }
                let finalStopID = ""; let idSourceMessage = ""; let chosenFormatForThisStop = "";
                if (excelUserProvidedStopID) { 
                    const providedIDUpper = excelUserProvidedStopID.toUpperCase();
                    if (!/^[A-Z0-9]+$/.test(providedIDUpper)) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Provided StopID "${excelUserProvidedStopID}" invalid chars. Skipped.`); errorsEncountered++; continue; }
                    if (newlyGeneratedOrUsedIDsInThisBatch.has(providedIDUpper)) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Provided StopID "${excelUserProvidedStopID}" is duplicated within this Excel file. Skipped.`); errorsEncountered++; continue; }
                    finalStopID = excelUserProvidedStopID; idSourceMessage = "user-provided";
                    if (finalStopID.startsWith("BP")) chosenFormatForThisStop = "BP"; else if (finalStopID.startsWith("LE")) chosenFormatForThisStop = "LE"; else if (finalStopID.startsWith("RO")) chosenFormatForThisStop = "RO"; else if (/^\d+$/.test(finalStopID)) chosenFormatForThisStop = "NUM"; else chosenFormatForThisStop = "Custom";
                } else { if (baseNameToFormatMapForThisBatch.has(excelBaseName)) { chosenFormatForThisStop = baseNameToFormatMapForThisBatch.get(excelBaseName); } else { chosenFormatForThisStop = getRandomIdFormat_ExtraPage(); baseNameToFormatMapForThisBatch.set(excelBaseName, chosenFormatForThisStop); } finalStopID = generateUniqueStopId_ExtraPage_BulkAware(chosenFormatForThisStop, excelStopName, newlyGeneratedOrUsedIDsInThisBatch, baseNameAndFormatToGeneratedNumericPartsMap); idSourceMessage = `auto-gen (${chosenFormatForThisStop})`; }
                if (!finalStopID) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Failed to obtain a final StopID. Skipped.`); errorsEncountered++; continue;}
                newlyGeneratedOrUsedIDsInThisBatch.add(finalStopID.toUpperCase()); uniqueStopIDsAddedCount++;
                excelLineNames.forEach(ln => {
                    newFlatScheduleEntries.push({
                        internalId: `${finalStopID}_${ln.replace(/[^A-Z0-9]/ig, '')}_phReplace_${Date.now()}_${newFlatScheduleEntries.length}`,
                        stopID: finalStopID, stopName: excelStopName, direction: excelDirection, lineName: ln,
                        destinationName: "To Be Defined", OperatingProfile: "AllDays", scheduledTime: "00:00", DayOffset: "0"
                    });
                    totalPlaceholdersCreated++;
                });
                statusMessages.push(`Row ${stopData.originalLineNumber}: Processed "${excelStopName}" -> ID: ${finalStopID} [${idSourceMessage}]. Routes: ${excelLineNames.join(', ')}.`);
            }
            let finalSummaryParts = []; if (totalPlaceholdersCreated > 0) finalSummaryParts.push(`Prepared ${totalPlaceholdersCreated} placeholder schedule entries for ${uniqueStopIDsAddedCount} unique StopIDs from the file.`); if (errorsEncountered > 0) finalSummaryParts.push(`${errorsEncountered} row(s) from Excel skipped due to errors.`); if (newFlatScheduleEntries.length === 0 && errorsEncountered === 0) finalSummaryParts.push("No valid stop definitions found in the file to process."); statusMessages.push("\n--- Summary ---\n" + finalSummaryParts.join('\n')); if (bulkAddNewStopsStatus_el_extra) bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n');
            if (errorsEncountered > 0 && newFlatScheduleEntries.length > 0) { if (!confirm(`There were ${errorsEncountered} error(s) processing rows. However, ${newFlatScheduleEntries.length} placeholder entries are ready to REPLACE the entire schedule. Proceed?`)) { statusMessages.push("Bulk replacement aborted by user due to errors."); if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; } return; } statusMessages.push("Attempting to save successfully processed entries..."); }
            else if (newFlatScheduleEntries.length === 0) { if (bulkAddNewStopsStatus_el_extra) bulkAddNewStopsStatus_el_extra.style.color = errorsEncountered > 0 ? '#e74c3c' : '#f1c40f'; return; }
            currentWorkingSchedule_extra = newFlatScheduleEntries; closedStopIDs_extra = []; stopSpecificRouteColours_extra = {};
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
                await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                statusMessages.push(`\nSuccessfully REPLACED all schedules. Added ${totalPlaceholdersCreated} placeholder entries for ${uniqueStopIDsAddedCount} StopIDs to Firebase in the new structure.`);
                if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#2ecc71'; }
                if (fileInputBulkAddStops_el_extra) fileInputBulkAddStops_el_extra.value = '';
                if (fileNameBulkAddStops_el_extra) fileNameBulkAddStops_el_extra.textContent = 'No file selected.';
                processedExcelStopsData_extra = []; renderUIDependentElements_ExtraPage();
            } catch (error) {
                statusMessages.push("\nDATABASE ERROR: Error saving replaced schedule to Firebase!");
                if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; }
                console.error("Error bulk replacing stops and saving to Firebase:", error);
            }
        }
        function handleExcelFileForBulkAdd_ExtraPage(event) { const file = event.target.files[0]; if (!fileInputBulkAddStops_el_extra || !fileNameBulkAddStops_el_extra || !bulkAddNewStopsStatus_el_extra) return; if (!file) { fileNameBulkAddStops_el_extra.textContent = "No file selected."; processedExcelStopsData_extra = []; return; } fileNameBulkAddStops_el_extra.textContent = `Processing ${file.name}...`; bulkAddNewStopsStatus_el_extra.textContent = ""; processedExcelStopsData_extra = []; const reader = new FileReader(); reader.onload = function(e) { try { const data = new Uint8Array(e.target.result); const workbook = XLSX.read(data, {type: 'array'}); const firstSheetName = workbook.SheetNames[0]; const worksheet = workbook.Sheets[firstSheetName]; const jsonData = XLSX.utils.sheet_to_json(worksheet, {header:1, defval:''}); if (jsonData.length === 0) { bulkAddNewStopsStatus_el_extra.textContent = "Excel file empty or no data."; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileNameBulkAddStops_el_extra.textContent = `Error: ${file.name} is empty.`; fileInputBulkAddStops_el_extra.value = ''; return; } let validEntries = 0; let tempProcessedData = []; jsonData.forEach((row, index) => { if (!Array.isArray(row) || row.every(cell => String(cell).trim() === '')) return; const userProvidedStopID = String(row[0] || "").trim(); const stopName = String(row[1] || "").trim(); const direction = String(row[2] || "").trim(); const lineNameInput = String(row[3] || "").trim(); if (!stopName && !userProvidedStopID) { console.warn(`Skipping Excel row ${index + 1}: StopName and StopID both missing.`); return; } tempProcessedData.push({ originalLineNumber: index + 1, userProvidedStopID: userProvidedStopID, stopName: stopName, direction: direction, lineNameInput: lineNameInput }); validEntries++; }); processedExcelStopsData_extra = tempProcessedData; if (validEntries > 0) { fileNameBulkAddStops_el_extra.textContent = `${file.name} (${validEntries} valid rows ready).`; bulkAddNewStopsStatus_el_extra.textContent = `${validEntries} stop definitions processed. Ready for Bulk Replace operation.`; bulkAddNewStopsStatus_el_extra.style.color = '#2ecc71'; } else { fileNameBulkAddStops_el_extra.textContent = `No valid data in ${file.name}.`; bulkAddNewStopsStatus_el_extra.textContent = "No valid definitions (StopName/StopID required)."; bulkAddNewStopsStatus_el_extra.style.color = '#f1c40f'; fileInputBulkAddStops_el_extra.value = ''; } } catch (error) { console.error("Error processing Excel:", error); fileNameBulkAddStops_el_extra.textContent = `Error processing ${file.name}.`; bulkAddNewStopsStatus_el_extra.textContent = "Error processing Excel: " + error.message; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileInputBulkAddStops_el_extra.value = ''; } }; reader.onerror = () => { fileNameBulkAddStops_el_extra.textContent = "Error reading file."; bulkAddNewStopsStatus_el_extra.textContent = "Could not read file."; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileInputBulkAddStops_el_extra.value = ''; }; reader.readAsArrayBuffer(file); }
        
function populateMasterStopList_ExtraPage() {
            if (!masterStopListUL_el_extra || !masterStopListStatus_el_extra) return;
            
            // Ensure uniqueStopsMasterList_extra is up-to-date based on currentWorkingSchedule_extra
            uniqueStopsMasterList_extra = getUniqueStopsFromSchedule_ExtraPage(); 
            
            const filterText = masterStopListFilterInput_el_extra.value.toLowerCase().trim();
            masterStopListUL_el_extra.innerHTML = '';
            let displayedCount = 0;

            if (uniqueStopsMasterList_extra.length === 0) {
                masterStopListStatus_el_extra.textContent = 'No unique stops loaded.';
                masterStopListUL_el_extra.innerHTML = '<p style="text-align:center; padding:1rem; opacity:0.7;">No stops to display.</p>'; // Clearer message
                return;
            }

            uniqueStopsMasterList_extra.forEach(stop => {
                if (!stop || !stop.stopID) return;

                // --- Get serving routes from the pre-calculated map ---
                const servingRouteNamesArray = Array.from(stopToServingRoutesMap_extra.get(stop.stopID) || new Set());
                // --- End of logic to get serving routes ---

                const stopIdLower = stop.stopID.toLowerCase();
                const stopNameLower = (stop.stopName || "").toLowerCase();
                const stopDirectionLower = (stop.direction || "").toLowerCase();
                const isClosed = closedStopIDs_extra.includes(stop.stopID.toUpperCase());
                const closureStatus = isClosed ? "Closed" : "Open";

                if (filterText) {
                    const matchesStopId = stopIdLower.includes(filterText);
                    const matchesStopName = stopNameLower.includes(filterText);
                    const matchesDirection = stopDirectionLower.includes(filterText);
                    const matchesStatus = closureStatus.toLowerCase().includes(filterText);
                    const matchesRoute = servingRouteNamesArray.some(routeName => 
                        routeName.toLowerCase().includes(filterText)
                    );
                    if (!(matchesStopId || matchesStopName || matchesDirection || matchesStatus || matchesRoute)) {
                        return; 
                    }
                }
                
                displayedCount++;
                const li = document.createElement('li');
                li.classList.add('master-stop-list-item');
                li.dataset.originalStopid = stop.stopID;

                const originalInfoDiv = document.createElement('div');
                originalInfoDiv.classList.add('master-stop-original-info');

                let originalContent = `<span class="stop-name-master">${stop.stopName || 'N/A'}</span><br>
                                   <span class="stop-direction-master">Towards: ${stop.direction || 'N/A'}</span><br>
                                   <span class="stop-id-master">Stop ID: ${stop.stopID}</span>`;
                
                // Add closure status to the details grid
                originalContent += `<div class="master-stop-original-info .stop-details-grid" style="margin-top:0.3rem;">
                                        <span class="detail-label">Status:</span>
                                        <span class="detail-value ${isClosed ? 'status-closed' : 'status-open'}">${closureStatus}</span>
                                    </div>`;


                if (servingRouteNamesArray.length > 0) {
                    const sortedRouteNamesForDisplay = [...servingRouteNamesArray].sort(compareLineNames_ExtraPage);
                    originalContent += `<div class="serving-routes-container" style="margin-top:0.3rem;">`;
                    sortedRouteNamesForDisplay.slice(0, 10).forEach(lineName => {
                        const bgColor = getRouteTileColour_ExtraPage(lineName, stop.stopID);
                        const textColor = getTextColourForBackground_ExtraPage(bgColor);
                        originalContent += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor}; font-size:0.7em; padding:0.15em 0.4em;">${lineName}</span>`;
                    });
                    if (sortedRouteNamesForDisplay.length > 10) {
                        originalContent += `<span style="font-size:0.7em; opacity:0.8;">...and ${sortedRouteNamesForDisplay.length - 10} more.</span>`;
                    }
                    originalContent += `</div>`;
                }
                originalInfoDiv.innerHTML = originalContent;

                const newIdSectionDiv = document.createElement('div');
                newIdSectionDiv.classList.add('master-stop-new-id-section');
                const newIdLabel = document.createElement('label');
                newIdLabel.textContent = 'Propose New ID (optional):';
                const newIdInput = document.createElement('input');
                newIdInput.type = 'text';
                newIdInput.classList.add('schedule-generator-input', 'master-list-new-id-input');
                newIdInput.dataset.originalId = stop.stopID;
                newIdInput.placeholder = "Enter new ID, then Apply Bulk";
                newIdInput.value = stop.stopID; 

                const warningP = document.createElement('p');
                warningP.classList.add('master-list-row-warning');

                newIdInput.addEventListener('input', () => {
                    const enteredID = newIdInput.value.trim().toUpperCase();
                    warningP.textContent = ''; 
                    warningP.style.color = '#f39c12'; 

                    if (!enteredID) return; 
                    if (enteredID === stop.stopID.toUpperCase()) return;

                    if (!/^[A-Z0-9]+$/.test(enteredID)) {
                        warningP.textContent = 'Invalid chars in ID.';
                        return;
                    }
                    const allCurrentAndProposedIDs = new Set(uniqueStopsMasterList_extra.map(s => s.stopID.toUpperCase()));
                    document.querySelectorAll('#masterStopListUL_extra .master-list-new-id-input').forEach(inp => {
                        if (inp !== newIdInput) { 
                            const otherProposed = inp.value.trim().toUpperCase();
                            if (otherProposed && otherProposed !== inp.dataset.originalId.toUpperCase()) { 
                                allCurrentAndProposedIDs.add(otherProposed);
                            }
                        }
                    });

                    if (allCurrentAndProposedIDs.has(enteredID)) {
                        warningP.textContent = 'ID taken or proposed elsewhere!';
                    } else {
                        warningP.textContent = 'New ID available.';
                        warningP.style.color = '#2ecc71'; 
                    }
                });

                newIdSectionDiv.appendChild(newIdLabel);
                newIdSectionDiv.appendChild(newIdInput);
                newIdSectionDiv.appendChild(warningP);

                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('master-stop-actions');

                const editBtn = document.createElement('button');
                editBtn.className = 'button small-action';
                editBtn.textContent = 'Edit Name / Direction';
                editBtn.addEventListener('click', () => handleEditStopFromMasterList_ExtraPage(stop.stopID, stop.stopName, stop.direction));

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'button small-action secondary';
                deleteBtn.textContent = 'Delete Stop';
                deleteBtn.addEventListener('click', () => handleDeleteStopFromMasterList_ExtraPage(stop.stopID));

                const toggleBtn = document.createElement('button');
                toggleBtn.className = `button small-action ${isClosed ? "save" : "secondary"}`; 
                toggleBtn.textContent = isClosed ? "Reopen Stop" : "Close Stop";
                toggleBtn.addEventListener('click', () => handleToggleStopStatusFromMasterList_ExtraPage(stop.stopID));

                actionsDiv.appendChild(editBtn);
                actionsDiv.appendChild(deleteBtn);
                actionsDiv.appendChild(toggleBtn);

                li.appendChild(originalInfoDiv);
                li.appendChild(newIdSectionDiv);
                li.appendChild(actionsDiv);
                masterStopListUL_el_extra.appendChild(li);
            });
            
            if (displayedCount === 0 && uniqueStopsMasterList_extra.length > 0 && filterText) {
                 masterStopListUL_el_extra.innerHTML = `<p style="text-align:center; padding:1rem; opacity:0.7;">No stops match your filter "${filterText}".</p>`;
            }


            masterStopListStatus_el_extra.textContent = `Showing ${displayedCount} of ${uniqueStopsMasterList_extra.length} unique stops. ${filterText ? `Filter active: "${filterText}"` : ''}`;
        }
        async function handleToggleStopStatusFromMasterList_ExtraPage(stopID) { if (!currentUser_extra) { alert("Log in."); return; } const stopIdUpper = stopID.toUpperCase(); const idx = closedStopIDs_extra.indexOf(stopIdUpper); if (idx === -1) closedStopIDs_extra.push(stopIdUpper); else closedStopIDs_extra.splice(idx, 1); try { await saveClosedStopsToFirebase_ExtraPage(); const status = idx === -1 ? "closed" : "reopened"; alert(`Stop "${stopID}" marked ${status}.`); populateMasterStopList_ExtraPage(); } catch (error) { alert("Error saving status: " + error.message); if (idx === -1) closedStopIDs_extra.pop(); else closedStopIDs_extra.splice(idx, 0, stopIdUpper); } }
        async function handleApplyMasterListStopIdChangesButton_ExtraPage() {
            if (!currentUser_extra || !masterStopListUL_el_extra || !masterListApplyChangesStatus_el_extra) return;
            masterListApplyChangesStatus_el_extra.textContent = "Processing ID changes..."; masterListApplyChangesStatus_el_extra.style.color = '#f1c40f';
            const idChangeProposals = []; const allInputs = masterStopListUL_el_extra.querySelectorAll('.master-list-new-id-input'); let hasErrors = false; const newProposedIDsInThisBatch = new Set();
            allInputs.forEach(input => { 
                const originalId = input.dataset.originalId; const newId = input.value.trim().toUpperCase(); const warningElement = input.parentElement.querySelector('.master-list-row-warning'); if (warningElement) warningElement.textContent = ''; if (newId && newId !== originalId.toUpperCase()) { if (!/^[A-Z0-9]+$/.test(newId)) { if(warningElement) warningElement.textContent = "Invalid chars!"; hasErrors = true; return; } if (newProposedIDsInThisBatch.has(newId)) { if(warningElement) warningElement.textContent = "Duplicate New ID!"; hasErrors = true; return; } const existingStopConflict = currentWorkingSchedule_extra.some(e => e.stopID.toUpperCase() === newId && !Array.from(allInputs).some(inp => inp.dataset.originalId.toUpperCase() === newId)); if (existingStopConflict) { if(warningElement) warningElement.textContent = "Conflicts existing ID!"; hasErrors = true; return; } idChangeProposals.push({ originalId: originalId, newId: newId }); newProposedIDsInThisBatch.add(newId); }
            });
            if (hasErrors) { masterListApplyChangesStatus_el_extra.textContent = "Errors in proposed IDs. Correct and retry."; masterListApplyChangesStatus_el_extra.style.color = '#e74c3c'; return; }
            if (idChangeProposals.length === 0) { masterListApplyChangesStatus_el_extra.textContent = "No Stop ID changes proposed."; masterListApplyChangesStatus_el_extra.style.color = '#7f8c8d'; return; }
            if (!confirm(`Apply ${idChangeProposals.length} Stop ID changes to Firebase?`)) { masterListApplyChangesStatus_el_extra.textContent = "Bulk ID change cancelled."; masterListApplyChangesStatus_el_extra.style.color = '#7f8c8d'; return; }
            let actualUpdateCount = 0; const originalToNewIdMap = new Map(idChangeProposals.map(p => [p.originalId.toUpperCase(), p.newId]));
            currentWorkingSchedule_extra.forEach(entry => { const originalEntryStopIDUpper = entry.stopID.toUpperCase(); if (originalToNewIdMap.has(originalEntryStopIDUpper)) { entry.stopID = originalToNewIdMap.get(originalEntryStopIDUpper); actualUpdateCount++; } });
            const updatedClosedStopIDs = new Set(); closedStopIDs_extra.forEach(closedId => { updatedClosedStopIDs.add(originalToNewIdMap.get(closedId.toUpperCase()) || closedId); }); closedStopIDs_extra = Array.from(updatedClosedStopIDs);
            const updatedStopSpecificColours = {}; for (const oldStopIdKey in stopSpecificRouteColours_extra) { updatedStopSpecificColours[originalToNewIdMap.get(oldStopIdKey.toUpperCase()) || oldStopIdKey] = stopSpecificRouteColours_extra[oldStopIdKey]; } stopSpecificRouteColours_extra = updatedStopSpecificColours;
            if (actualUpdateCount > 0 || idChangeProposals.some(p => closedStopIDs_extra.includes(p.newId.toUpperCase()) || stopSpecificRouteColours_extra[p.newId.toUpperCase()])) {
                try {
                    await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra); 
                    await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                    masterListApplyChangesStatus_el_extra.textContent = `Applied ${idChangeProposals.length} Stop ID change(s) (${actualUpdateCount} entries).`; masterListApplyChangesStatus_el_extra.style.color = '#2ecc71';
                    renderUIDependentElements_ExtraPage();
                } catch (error) { console.error("Error applying bulk ID changes:", error); masterListApplyChangesStatus_el_extra.textContent = "Error saving bulk ID changes: " + error.message; masterListApplyChangesStatus_el_extra.style.color = '#e74c3c'; alert("Critical error saving bulk Stop ID changes. Data inconsistent. Refresh."); }
            } else { masterListApplyChangesStatus_el_extra.textContent = "No schedule entries affected by proposed changes."; masterListApplyChangesStatus_el_extra.style.color = '#f1c40f'; }
        }
        function findDuplicateStopsByNameAndDirection_ExtraPage() { if (!currentUser_extra) { alert("Please log in."); if (duplicateStopsByNameDirResults_el_extra) duplicateStopsByNameDirResults_el_extra.textContent = "Please log in."; return; } if (!duplicateStopsByNameDirResults_el_extra) { console.error("Result display element not found."); return; } duplicateStopsByNameDirResults_el_extra.innerHTML = "<p>Checking for duplicates...</p>"; duplicateStopsByNameDirResults_el_extra.style.color = "#f1c40f"; const stopsToCheck = getUniqueStopsFromSchedule_ExtraPage(); if (!stopsToCheck || stopsToCheck.length === 0) { duplicateStopsByNameDirResults_el_extra.textContent = "No stops loaded."; return; } const signatureMap = new Map(); stopsToCheck.forEach(stop => { if (stop.stopName && stop.stopID) { const name = stop.stopName.trim().toLowerCase(); const direction = (stop.direction || "").trim().toLowerCase(); const signature = `${name}|${direction}`; if (!signatureMap.has(signature)) signatureMap.set(signature, []); signatureMap.get(signature).push({id: stop.stopID, name: stop.stopName, direction: stop.direction}); } }); let duplicateSets = []; signatureMap.forEach((stops, signature) => { if (stops.length > 1) { duplicateSets.push({ signature: signature, name: stops[0].name, direction: stops[0].direction || "", stops: stops.map(s => ({ id: s.id, entryCount: currentWorkingSchedule_extra.filter(entry => entry.stopID === s.id).length })).sort((a,b) => b.entryCount - a.id.localeCompare(b.id)) }); } }); if (duplicateSets.length === 0) { duplicateStopsByNameDirResults_el_extra.textContent = "No duplicate stops found (name & direction)."; duplicateStopsByNameDirResults_el_extra.style.color = "#2ecc71"; } else { let html = `<p>${duplicateSets.length} set(s) of duplicate stops found:</p><ul>`; duplicateSets.forEach((set, index) => { html += `<li class="duplicate-set-to-merge">`; html += `<p><strong>Name:</strong> "${set.name}", <strong>Direction:</strong> "${set.direction || '(None)'}"</p>`; html += `<p>Conflicting StopIDs (select one to keep):</p><div class="stop-id-options">`; set.stops.forEach((stop, radioIndex) => { const radioName = `master_for_set_${index}`; const isChecked = radioIndex === 0 ? "checked" : ""; html += `<label><input type="radio" name="${radioName}" value="${stop.id}" ${isChecked}> ${stop.id} (${stop.entryCount} entries)</label><br>`; }); html += `</div></li>`; }); html += `</ul><button id="mergeDuplicateStopsButton_extra" class="button save" style="margin-top:1rem;">Merge Selected Duplicates</button>`; html += `<p id="mergeDuplicateStopsStatus_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>`; duplicateStopsByNameDirResults_el_extra.innerHTML = html; duplicateStopsByNameDirResults_el_extra.style.color = "#e74c3c"; const mergeButton = document.getElementById('mergeDuplicateStopsButton_extra'); if (mergeButton) mergeButton.addEventListener('click', handleMergeDuplicateStops_ExtraPage); } }
        async function handleMergeDuplicateStops_ExtraPage() {
            if (!currentUser_extra) { alert("Log in."); return; }
            const mergeStatusEl = document.getElementById('mergeDuplicateStopsStatus_extra'); if (!mergeStatusEl) return;
            mergeStatusEl.textContent = "Processing merges..."; mergeStatusEl.style.color = "#f1c40f";
            const duplicateSetElements = duplicateStopsByNameDirResults_el_extra.querySelectorAll('.duplicate-set-to-merge'); if (duplicateSetElements.length === 0) { mergeStatusEl.textContent = "No duplicate sets found."; return; }
            let changesMade = false; let totalEntriesReassigned = 0; let stopIDsMergedAwayOverall = new Set();
            for (let i = 0; i < duplicateSetElements.length; i++) { 
                const radioName = `master_for_set_${i}`; const selectedRadio = duplicateStopsByNameDirResults_el_extra.querySelector(`input[name="${radioName}"]:checked`); if (!selectedRadio) continue; const masterStopID = selectedRadio.value; const masterStopDetails = uniqueStopsMasterList_extra.find(s => s.stopID === masterStopID) || currentWorkingSchedule_extra.find(e => e.stopID === masterStopID); if (!masterStopDetails) continue; const masterStopName = masterStopDetails.stopName; const masterStopDirection = masterStopDetails.direction; const allRadiosInSet = duplicateStopsByNameDirResults_el_extra.querySelectorAll(`input[name="${radioName}"]`); const stopIDsInThisSet = Array.from(allRadiosInSet).map(radio => radio.value); const stopIDsToMergeAway = stopIDsInThisSet.filter(id => id !== masterStopID); if (stopIDsToMergeAway.length > 0) { changesMade = true; stopIDsToMergeAway.forEach(idToMerge => { stopIDsMergedAwayOverall.add(idToMerge.toUpperCase()); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === idToMerge) { entry.stopID = masterStopID; entry.stopName = masterStopName; entry.direction = masterStopDirection; totalEntriesReassigned++; } }); }); }
            }
            if (!changesMade) { mergeStatusEl.textContent = "No merges selected."; mergeStatusEl.style.color = "#7f8c8d"; return; }
            closedStopIDs_extra = closedStopIDs_extra.filter(id => !stopIDsMergedAwayOverall.has(id.toUpperCase())); stopIDsMergedAwayOverall.forEach(idToMergeUpper => { if (stopSpecificRouteColours_extra[idToMergeUpper]) delete stopSpecificRouteColours_extra[idToMergeUpper]; });
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra); 
                await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                mergeStatusEl.textContent = `Merged duplicates. ${totalEntriesReassigned} entries reassigned.`; mergeStatusEl.style.color = "#2ecc71";
                renderUIDependentElements_ExtraPage(); findDuplicateStopsByNameAndDirection_ExtraPage();
            } catch (error) { console.error("Error saving merged stops:", error); mergeStatusEl.textContent = "Error saving merged stops: " + error.message; mergeStatusEl.style.color = "#e74c3c"; alert("CRITICAL: Error saving merged stops. Data inconsistent. Refresh."); }
        }
        async function saveClosedStopsToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; const fbClosedObject = {}; closedStopIDs_extra.forEach(id => { if (typeof id === 'string') fbClosedObject[id.toUpperCase()] = true; }); await dbSet(dbRef(database, FB_PATH_APPSTATE_CLOSED_STOPS), fbClosedObject); console.log("Closed stops saved (Extra)."); }
        async function saveGlobalColoursToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; await dbSet(dbRef(database, FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS), globalCustomRouteColours_extra); console.log("Global route colours saved (Extra)."); }
        async function saveStopSpecificColoursToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; await dbSet(dbRef(database, FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS), stopSpecificRouteColours_extra); console.log("Stop-specific colours saved (Extra)."); }

        // --- Global Route Deletion Functions ---
        function populateGlobalRouteToDeleteList_ExtraPage() { if (!globalRouteDeletionListContainer_el_extra) return; globalRouteDeletionListContainer_el_extra.innerHTML = ''; if (!currentWorkingSchedule_extra || currentWorkingSchedule_extra.length === 0) { globalRouteDeletionListContainer_el_extra.innerHTML = '<p>No routes loaded.</p>'; return; } const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName).filter(Boolean))].sort(compareLineNames_ExtraPage); if (uniqueRoutes.length === 0) { globalRouteDeletionListContainer_el_extra.innerHTML = '<p>No valid routes to list.</p>'; return; } const tileContainer = document.createElement('div'); tileContainer.className = 'selectable-route-tile-container'; uniqueRoutes.forEach(lineName => { const tile = document.createElement('span'); tile.className = 'selectable-route-tile'; tile.textContent = lineName; tile.dataset.lineName = lineName; const bgColor = getRouteTileColour_ExtraPage(lineName); tile.style.backgroundColor = bgColor; tile.style.color = getTextColourForBackground_ExtraPage(bgColor); tile.setAttribute('role', 'checkbox'); tile.setAttribute('aria-checked', 'false'); tile.tabIndex = 0; tile.addEventListener('click', () => { const isSelected = tile.classList.toggle('selected'); tile.setAttribute('aria-checked', isSelected.toString()); }); tile.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); tile.click(); }}); tileContainer.appendChild(tile); }); globalRouteDeletionListContainer_el_extra.appendChild(tileContainer); }
        async function handleDeleteEntireRouteGlobally_ExtraPage() {
            if (!currentUser_extra || !deleteEntireRouteStatusMessage_el_extra || !globalRouteDeletionListContainer_el_extra) return;
            const selectedTiles = globalRouteDeletionListContainer_el_extra.querySelectorAll('.selectable-route-tile.selected');
            if (selectedTiles.length === 0) { deleteEntireRouteStatusMessage_el_extra.textContent = "Select route(s) to delete."; deleteEntireRouteStatusMessage_el_extra.style.color = '#f1c40f'; return; }
            const routesToDelete = Array.from(selectedTiles).map(t => t.dataset.lineName);
            if (!confirm(`EXTREME CAUTION!\nDelete ALL data for route(s): ${routesToDelete.join(', ')} from Firebase? CANNOT BE UNDONE.`)) { deleteEntireRouteStatusMessage_el_extra.textContent = "Global deletion cancelled."; return; }
            deleteEntireRouteStatusMessage_el_extra.textContent = `Deleting route(s): ${routesToDelete.join(', ')}...`; deleteEntireRouteStatusMessage_el_extra.style.color = '#f1c40f';
            const { database, dbRemove, dbRef } = window.firebaseOMSI; let firebaseRemovalPromises = [];
            routesToDelete.forEach(routeNameToDelete => {
                const saneRouteName = sanitizeFirebaseKey(routeNameToDelete);
                const routePath = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRouteName}`;
                firebaseRemovalPromises.push(dbRemove(dbRef(database, routePath)));
            });
            const originalScheduleLength = currentWorkingSchedule_extra.length;
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry =>
                !(entry.lineName && routesToDelete.map(r => r.toUpperCase()).includes(entry.lineName.toUpperCase()))
            );
            const scheduleEntriesRemovedCount = originalScheduleLength - currentWorkingSchedule_extra.length;
            let globalColoursRemoved = false; routesToDelete.forEach(route => { if (globalCustomRouteColours_extra[route.toUpperCase()]) { delete globalCustomRouteColours_extra[route.toUpperCase()]; globalColoursRemoved = true; } });
            let specificColoursNeedSave = false; Object.keys(stopSpecificRouteColours_extra).forEach(stopID => { routesToDelete.forEach(route => { if (stopSpecificRouteColours_extra[stopID] && stopSpecificRouteColours_extra[stopID][route.toUpperCase()]) { delete stopSpecificRouteColours_extra[stopID][route.toUpperCase()]; if (Object.keys(stopSpecificRouteColours_extra[stopID]).length === 0) delete stopSpecificRouteColours_extra[stopID]; specificColoursNeedSave = true; } }); });
            try {
                await Promise.all(firebaseRemovalPromises); 
                if (globalColoursRemoved) await saveGlobalColoursToFirebase_ExtraPage();
                if (specificColoursNeedSave) await saveStopSpecificColoursToFirebase_ExtraPage();
                await updateAncillaryScheduleData_ExtraPage(); 
                deleteEntireRouteStatusMessage_el_extra.textContent = `Route(s) ${routesToDelete.join(', ')} deleted. ${scheduleEntriesRemovedCount} entries removed.`;
                deleteEntireRouteStatusMessage_el_extra.style.color = '#2ecc71';
                renderUIDependentElements_ExtraPage();
            } catch (error) {
                console.error("Error deleting route(s) globally:", error);
                deleteEntireRouteStatusMessage_el_extra.textContent = "Error saving deletions: " + error.message;
                deleteEntireRouteStatusMessage_el_extra.style.color = '#e74c3c';
                alert("Critical error saving global route deletions. Data inconsistent. Refresh.");
            }
        }

        // ++ Route Profile Deletion Functions (NEW SECTION) ++
        /**
         * @description Populates the route select dropdown for the Route Profile Deletion tool.
         */
        function rpd_populateRouteSelect_ExtraPage() {
            if (!rpdRouteSelect_el_extra || !rpdRouteInput_el_extra) return;
            const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))]
                .filter(Boolean)
                .sort(compareLineNames_ExtraPage);

            const currentInputValue = rpdRouteInput_el_extra.value.trim();
            rpdRouteSelect_el_extra.innerHTML = '<option value="">-- Select Route --</option>';
            uniqueRoutes.forEach(route => {
                const opt = document.createElement('option');
                opt.value = route;
                opt.textContent = route;
                rpdRouteSelect_el_extra.appendChild(opt);
            });

            const matchedRoute = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
            if (matchedRoute) {
                rpdRouteSelect_el_extra.value = matchedRoute;
            } else if (currentInputValue) {
                rpdRouteSelect_el_extra.value = ""; 
            }
            // Chain updates
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Handles changes to the route name input field for RPD.
         */
        function rpd_handleRouteNameInputChange_ExtraPage() {
            if (!rpdRouteInput_el_extra || !rpdRouteSelect_el_extra) return;
            const typedRouteUpper = rpdRouteInput_el_extra.value.trim().toUpperCase();
            const matchedOption = Array.from(rpdRouteSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper);

            if (matchedOption) {
                rpdRouteSelect_el_extra.value = matchedOption.value;
                if (rpdRouteInput_el_extra.value !== matchedOption.value) {
                    rpdRouteInput_el_extra.value = matchedOption.value;
                }
            } else {
                rpdRouteSelect_el_extra.value = ""; 
            }
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Handles changes to the route name select dropdown for RPD.
         */
        function rpd_handleRouteNameSelectChange_ExtraPage() {
            if (!rpdRouteSelect_el_extra || !rpdRouteInput_el_extra) return;
            rpdRouteInput_el_extra.value = rpdRouteSelect_el_extra.value;
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Populates the destination select dropdown for RPD based on selected route.
         */
        function rpd_populateDestinationSelect_ExtraPage() {
            if (!rpdDestinationSelect_el_extra || !rpdDestinationInput_el_extra || !rpdRouteInput_el_extra) return;

            const selectedRoute = rpdRouteInput_el_extra.value.trim().toUpperCase();
            const currentDestInputValue = rpdDestinationInput_el_extra.value.trim();

            rpdDestinationSelect_el_extra.innerHTML = '<option value="">-- Optional: All Destinations --</option>'; // Modified default text

            if (!selectedRoute) {
                rpdDestinationInput_el_extra.value = ""; 
                rpdDestinationSelect_el_extra.disabled = true;
                rpdDestinationInput_el_extra.disabled = true;
                if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = 'none';
                rpd_populateProfileList_ExtraPage(); 
                return;
            }

            rpdDestinationSelect_el_extra.disabled = false;
            rpdDestinationInput_el_extra.disabled = false;

            const uniqueDestinations = [...new Set(
                currentWorkingSchedule_extra
                    .filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName)
                    .map(e => e.destinationName)
            )].sort();

            if (uniqueDestinations.length > 0) {
                uniqueDestinations.forEach(dest => {
                    const opt = document.createElement('option');
                    opt.value = dest;
                    opt.textContent = dest;
                    rpdDestinationSelect_el_extra.appendChild(opt);
                });
                const matchedDest = uniqueDestinations.find(d => d === currentDestInputValue);
                if (matchedDest) {
                    rpdDestinationSelect_el_extra.value = matchedDest;
                } else {
                     rpdDestinationSelect_el_extra.value = ""; // Default to "All Destinations" if typed value doesn't match
                }
            } else {
                 rpdDestinationSelect_el_extra.innerHTML = '<option value="">-- No Specific Destinations --</option>';
                 rpdDestinationInput_el_extra.value = ""; // Clear input if no destinations exist
            }
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }
        
        /**
         * @description Handles changes to the destination name input field for RPD.
         */
        function rpd_handleDestinationNameInputChange_ExtraPage() {
            if (!rpdDestinationInput_el_extra || !rpdDestinationSelect_el_extra) return;
            const typedDest = rpdDestinationInput_el_extra.value.trim();
            const matchedOption = Array.from(rpdDestinationSelect_el_extra.options).find(opt => opt.value === typedDest);

            if (matchedOption) {
                rpdDestinationSelect_el_extra.value = matchedOption.value;
                if (rpdDestinationInput_el_extra.value !== matchedOption.value) {
                   rpdDestinationInput_el_extra.value = matchedOption.value;
                }
            } else {
                rpdDestinationSelect_el_extra.value = ""; // If typing something not in list, clear select to imply "All Destinations" or new
            }
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }

        /**
         * @description Handles changes to the destination name select dropdown for RPD.
         */
        function rpd_handleDestinationNameSelectChange_ExtraPage() {
            if (!rpdDestinationSelect_el_extra || !rpdDestinationInput_el_extra) return;
            rpdDestinationInput_el_extra.value = rpdDestinationSelect_el_extra.value; // Sync input with select
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }
        
        /**
         * @description Clears the destination selection for RPD.
         */
        function rpd_handleClearDestination_ExtraPage() {
            if (!rpdDestinationInput_el_extra || !rpdDestinationSelect_el_extra || !rpdClearDestinationButton_el_extra) return;
            rpdDestinationInput_el_extra.value = "";
            rpdDestinationSelect_el_extra.value = ""; // This will select "-- Optional: All Destinations --"
            rpdClearDestinationButton_el_extra.style.display = 'none';
            rpd_populateProfileList_ExtraPage(); 
        }

        /**
         * @description Fetches and displays available profiles for selection based on route and optional destination.
         */
        async function rpd_populateProfileList_ExtraPage() {
            if (!rpdProfileListContainer_el_extra || !rpdRouteInput_el_extra || !rpdDestinationInput_el_extra || !window.firebaseOMSI) {
                if (rpdProfileListContainer_el_extra) rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; opacity:0.7;">Required elements missing for profile listing.</p>';
                return;
            }

            const routeName = rpdRouteInput_el_extra.value.trim();
            const destinationName = rpdDestinationInput_el_extra.value.trim(); // This is the specific destination, if selected

            rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; opacity:0.7;">Select a route to see available profiles.</p>';

            if (!routeName) {
                return; 
            }

            rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; color:#f1c40f;">Loading profiles...</p>';

            // Use currentWorkingSchedule_extra to derive profiles to ensure original casing and relevance
            let profilesOfInterest = currentWorkingSchedule_extra.filter(entry => {
                if (entry.lineName !== routeName) return false;
                if (destinationName && entry.destinationName !== destinationName) return false; // Filter by dest if specified
                return true; // Passes if route matches, and dest matches (if dest was specified)
            });

            let availableOriginalProfileNames = [...new Set(profilesOfInterest.map(e => e.OperatingProfile))].sort();

            if (availableOriginalProfileNames.length === 0) {
                if (destinationName) {
                    rpdProfileListContainer_el_extra.innerHTML = `<p style="font-size:0.85em; color:#f1c40f;">No profiles found for route "${routeName}" with destination "${destinationName}".</p>`;
                } else {
                    rpdProfileListContainer_el_extra.innerHTML = `<p style="font-size:0.85em; color:#f1c40f;">No profiles found for route "${routeName}".</p>`;
                }
                return;
            }

            let html = '<div class="selectable-route-tile-container" style="margin-top:0.5rem;">'; 
            availableOriginalProfileNames.forEach(profileName => {
                html += `
                    <label class="selectable-route-tile rpd-profile-tile" style="background-color: #4A5568; color: white; border-color: transparent;" tabindex="0">
                        <input type="checkbox" class="rpd-profile-checkbox sr-only" value="${profileName}">
                        ${profileName}
                    </label>
                `;
            });
            html += '</div>';
            rpdProfileListContainer_el_extra.innerHTML = html;

            rpdProfileListContainer_el_extra.querySelectorAll('.rpd-profile-tile').forEach(tile => {
                const checkbox = tile.querySelector('.rpd-profile-checkbox');
                const toggleSelection = () => {
                    checkbox.checked = !checkbox.checked;
                    tile.classList.toggle('selected', checkbox.checked); 
                    tile.style.borderColor = checkbox.checked ? '#f1c40f' : 'transparent'; // Visual feedback
                    tile.setAttribute('aria-checked', checkbox.checked.toString());
                };
                tile.addEventListener('click', toggleSelection);
                tile.addEventListener('keydown', (e) => {
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        toggleSelection();
                    }
                });
            });
        }


        /**
         * @description Handles the deletion of selected route profiles.
         */
        async function handleDeleteRouteProfiles_ExtraPage() {
            if (!currentUser_extra || !window.firebaseOMSI) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Not logged in or Firebase not available."; rpdStatusMessage_el_extra.style.color = "#e74c3c";}
                return;
            }

            const routeName = rpdRouteInput_el_extra.value.trim();
            const destinationName = rpdDestinationInput_el_extra.value.trim(); // Optional, if empty means all destinations
            const selectedProfileCheckboxes = rpdProfileListContainer_el_extra.querySelectorAll('.rpd-profile-checkbox:checked');

            if (!routeName) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Please select a route."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}
                return;
            }
            if (selectedProfileCheckboxes.length === 0) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Please select at least one profile to delete."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}
                return;
            }

            const profilesToDeleteOriginalNames = Array.from(selectedProfileCheckboxes).map(cb => cb.value);
            const saneRoute = sanitizeFirebaseKey(routeName);
            const saneDest = destinationName ? sanitizeFirebaseKey(destinationName) : null;

            let confirmMessage = `ARE YOU SURE?\nThis will delete ALL schedule entries for:\nRoute: "${routeName}"`;
            if (saneDest) {
                confirmMessage += `\nDestination: "${destinationName}"`;
            } else {
                confirmMessage += ` (across ALL its destinations)`;
            }
            confirmMessage += `\nFor Operating Profile(s): ${profilesToDeleteOriginalNames.join(', ')}\n\nThis action CANNOT BE UNDONE.`;

            if (!confirm(confirmMessage)) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Profile deletion cancelled."; rpdStatusMessage_el_extra.style.color = "";}
                return;
            }

            if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Deleting profiles from Firebase..."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}

            const { database, dbRemove, dbRef } = window.firebaseOMSI;
            const removalPromises = [];

            profilesToDeleteOriginalNames.forEach(profileName => {
                const saneProfile = sanitizeFirebaseKey(profileName);
                let pathToDelete;
                if (saneDest) { // Delete specific destination under profile
                    pathToDelete = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}/${saneProfile}/${saneDest}`;
                } else { // Delete entire profile node for the route
                    pathToDelete = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}/${saneProfile}`;
                }
                console.log("Firebase path marked for deletion:", pathToDelete);
                removalPromises.push(dbRemove(dbRef(database, pathToDelete)));
            });

            try {
                await Promise.all(removalPromises);
                console.log("Firebase removal operations complete for selected profiles.");

                const originalLength = currentWorkingSchedule_extra.length;
                currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
                    const routeMatch = entry.lineName === routeName;
                    const profileMatch = profilesToDeleteOriginalNames.includes(entry.OperatingProfile);
                    // If saneDest is specified, entry must match it. If saneDest is null, destination doesn't matter for removal of whole profile.
                    const destMatch = saneDest ? (entry.destinationName === destinationName) : true;
                    
                    return !(routeMatch && profileMatch && destMatch);
                });
                const removedCount = originalLength - currentWorkingSchedule_extra.length;
                console.log(`${removedCount} entries removed from local currentWorkingSchedule_extra.`);

                await updateAncillaryScheduleData_ExtraPage();

                if(rpdStatusMessage_el_extra) {
                    rpdStatusMessage_el_extra.textContent = `Successfully deleted ${profilesToDeleteOriginalNames.length} profile(s) (${removedCount} schedule entries affected) for route "${routeName}"${saneDest ? ' and destination "' + destinationName + '"' : ' (all destinations for those profiles)'}. Ancillary data updated.`;
                    rpdStatusMessage_el_extra.style.color = "#2ecc71";
                }
                
                rpd_populateProfileList_ExtraPage(); // Refresh profile list
                renderUIDependentElements_ExtraPage(); 

            } catch (error) {
                console.error("Error deleting route profiles:", error);
                if(rpdStatusMessage_el_extra) {
                    rpdStatusMessage_el_extra.textContent = "Error deleting profiles from Firebase: " + error.message;
                    rpdStatusMessage_el_extra.style.color = "#e74c3c";
                }
                alert("Failed to delete profiles from Firebase. Data might be inconsistent. It's recommended to reload data from Firebase or review carefully.");
            }
        }
        // ++ END Route Profile Deletion Functions ++




        // ++ Route Schedule Generator Functions START ++
const RSG_OPERATING_PROFILES_LIST = [
    "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su",
    "MF",
    "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MFSch",
    "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MFNSD",
    "Christmas Day", "Boxing Day", "New Years Day"
];

const RSG_PROFILE_GROUPS_TO_MANAGE = [
    { individuals: ["Mo", "Tu", "We", "Th", "Fr"], groupProfile: "MF" },
    { individuals: ["MoSch", "TuSch", "WeSch", "ThSch", "FrSch"], groupProfile: "MFSch" },
    { individuals: ["MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"], groupProfile: "MFNSD" }
];

const RSG_PROFILE_INCOMPATIBILITY_RULES = {
    "Mo": ["MoSch", "MoNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MoSch": ["Mo", "MoNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MoNSD": ["Mo", "MoSch", "MF", "MFSch", "MFNSD", "AllDays"],
    "Tu": ["TuSch", "TuNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "TuSch": ["Tu", "TuNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "We": ["WeSch", "WeNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "Th": ["ThSch", "ThNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "Fr": ["FrSch", "FrNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MF": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MFSch", "MFNSD", "AllDays"],
    "MFSch": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MF", "MFNSD", "AllDays"],
    "MFNSD": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MF", "MFSch", "AllDays"],
    "Sa": ["SaNSD", "AllDays"],
    "SaNSD": ["Sa", "AllDays"],
    "Su": ["SuNSD", "AllDays"],
    "SuNSD": ["Su", "AllDays"],
    "AllDays": RSG_OPERATING_PROFILES_LIST.filter(p => p !== "AllDays"),
    "SchoolHoliday": ["AllDays", "MFSch", "MFNSD", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"],
    "BankHoliday": ["AllDays", "MFSch", "MFNSD", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"]
};

for (const keyProfile_extra in RSG_PROFILE_INCOMPATIBILITY_RULES) {
    RSG_PROFILE_INCOMPATIBILITY_RULES[keyProfile_extra].forEach(disabledProfile_extra => {
        if (!RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra]) {
            RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra] = [];
        }
        if (!RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra].includes(keyProfile_extra)) {
            RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra].push(keyProfile_extra);
        }
    });
}

const MASTER_VALID_PROFILE_COMBINATIONS_LIST_EXTRA = [
    "Mo", "Mo,Tu", "Mo,Tu,We", "Mo,Tu,We,Th", "Mo,Tu,We,Th,Sa", "Mo,Tu,We,Th,Sa,Su",
    "Mo,Tu,We,Th,Su", "Mo,Tu,We,Fr", "Mo,Tu,We,Fr,Sa", "Mo,Tu,We,Fr,Sa,Su",
    "Mo,Tu,We,Fr,Su", "Mo,Tu,We,Sa", "Mo,Tu,We,Sa,Su", "Mo,Tu,We,Su", "Mo,Tu,Th",
    "Mo,Tu,Th,Sa", "Mo,Tu,Th,Sa,Su", "Mo,Tu,Th,Su", "Mo,Tu,Fr", "Mo,Tu,Fr,Sa",
    "Mo,Tu,Fr,Sa,Su", "Mo,Tu,Fr,Su", "Mo,Tu,Sa", "Mo,Tu,Sa,Su", "Mo,Tu,Su", "Mo,We",
    "Mo,We,Th", "Mo,We,Th,Fr", "Mo,We,Th,Fr,Sa", "Mo,We,Th,Fr,Sa,Su", "Mo,We,Th,Fr,Su",
    "Mo,We,Th,Sa", "Mo,We,Th,Sa,Su", "Mo,We,Th,Su", "Mo,We,Fr", "Mo,We,Fr,Sa",
    "Mo,We,Fr,Sa,Su", "Mo,We,Fr,Su", "Mo,We,Sa", "Mo,We,Sa,Su", "Mo,We,Su", "Mo,Th",
    "Mo,Th,Fr", "Mo,Th,Fr,Sa", "Mo,Th,Fr,Sa,Su", "Mo,Th,Fr,Su", "Mo,Th,Sa",
    "Mo,Th,Sa,Su", "Mo,Th,Su", "Mo,Fr", "Mo,Fr,Sa", "Mo,Fr,Sa,Su", "Mo,Fr,Su", "Mo,Sa",
    "Mo,Sa,Su", "Mo,Su",
    "MoSch", "MoSch,TuSch", "MoSch,TuSch,WeSch", "MoSch,TuSch,WeSch,ThSch", "MoSch,TuSch,WeSch,FrSch",
    "MoSch,TuSch,ThSch", "MoSch,TuSch,ThSch,FrSch", "MoSch,TuSch,FrSch", "MoSch,WeSch",
    "MoSch,WeSch,ThSch", "MoSch,WeSch,ThSch,FrSch", "MoSch,WeSch,FrSch", "MoSch,ThSch",
    "MoSch,ThSch,FrSch", "MoSch,FrSch",
    "MoNSD", "MoNSD,TuNSD", "MoNSD,TuNSD,WeNSD", "MoNSD,TuNSD,WeNSD,ThNSD", "MoNSD,TuNSD,WeNSD,FrNSD",
    "MoNSD,TuNSD,ThNSD", "MoNSD,TuNSD,ThNSD,FrNSD", "MoNSD,TuNSD,FrNSD", "MoNSD,WeNSD",
    "MoNSD,WeNSD,ThNSD", "MoNSD,WeNSD,ThNSD,FrNSD", "MoNSD,WeNSD,FrNSD", "MoNSD,ThNSD",
    "MoNSD,ThNSD,FrNSD", "MoNSD,FrNSD",
    "Tu", "Tu,We", "Tu,We,Th", "Tu,We,Th,Fr", "Tu,We,Th,Fr,Sa", "Tu,We,Th,Fr,Sa,Su",
    "Tu,We,Th,Fr,Su", "Tu,We,Th,Sa", "Tu,We,Th,Sa,Su", "Tu,We,Th,Su", "Tu,We,Fr",
    "Tu,We,Fr,Sa", "Tu,We,Fr,Sa,Su", "Tu,We,Fr,Su", "Tu,We,Sa", "Tu,We,Sa,Su", "Tu,We,Su",
    "Tu,Th", "Tu,Th,Fr", "Tu,Th,Fr,Sa", "Tu,Th,Fr,Sa,Su", "Tu,Th,Fr,Su", "Tu,Th,Sa",
    "Tu,Th,Sa,Su", "Tu,Th,Su", "Tu,Fr", "Tu,Fr,Sa", "Tu,Fr,Sa,Su", "Tu,Fr,Su", "Tu,Sa",
    "Tu,Sa,Su", "Tu,Su",
    "TuSch", "TuSch,WeSch", "TuSch,WeSch,ThSch", "TuSch,WeSch,FrSch", "TuSch,ThSch", "TuSch,ThSch,FrSch",
    "TuSch,FrSch",
    "TuNSD", "TuNSD,WeNSD", "TuNSD,WeNSD,ThNSD", "TuNSD,WeNSD,ThNSD,FrNSD", "TuNSD,WeNSD,FrNSD",
    "TuNSD,ThNSD", "TuNSD,ThNSD,FrNSD", "TuNSD,FrNSD",
    "We", "We,Th", "We,Th,Fr", "We,Th,Fr,Sa", "We,Th,Fr,Sa,Su", "We,Th,Fr,Su", "We,Th,Sa",
    "We,Th,Sa,Su", "We,Th,Su", "We,Fr", "We,Fr,Sa", "We,Fr,Sa,Su", "We,Fr,Su", "We,Sa",
    "We,Sa,Su", "We,Su",
    "WeSch", "WeSch,ThSch", "WeSch,ThSch,FrSch", "WeSch,FrSch",
    "WeNSD", "WeNSD,ThNSD", "WeNSD,ThNSD,FrNSD", "WeNSD,FrNSD",
    "Th", "Th,Fr", "Th,Fr,Sa", "Th,Fr,Sa,Su", "Th,Fr,Su", "Th,Sa", "Th,Sa,Su", "Th,Su",
    "ThSch", "ThSch,FrSch",
    "ThNSD", "ThNSD,FrNSD",
    "Fr", "Fr,Sa", "Fr,Sa,Su", "Fr,Su",
    "FrSch", "FrNSD",
    "MF", "MF,Sa", "MF,Sa,Su", "MF,Su",
    "MFSch", "MFNSD",
    "Sa", "Sa,Su",
    "Su",
    "Christmas Day",
    "Boxing Day",
    "New Years Day"
];

// Helper function to create a canonical string (sorted, comma-separated)
function rsg_getCanonicalProfileString(profileArray) {
    if (!Array.isArray(profileArray)) return "";
    return profileArray.map(p => String(p).trim()).sort((a,b) => a.localeCompare(b)).join(',');
}

const VALID_PROFILE_COMBINATIONS_SET = new Set(
    MASTER_VALID_PROFILE_COMBINATIONS_LIST_EXTRA.map(s => rsg_getCanonicalProfileString(s.split(',')))
);

function rsg_showSaveConfigModal_ExtraPage() {
    const routeNameInput = rsgRouteNameInput_el_extra;
    const destinationNameInput = rsgDestinationNameInput_el_extra;
    // rsg_getSelectedOpProfilesString_ExtraPage() will be called to get current profiles
    const configNameInput = document.getElementById('rsg-config-name-input-extra');
    const modal = document.getElementById('rsg-save-config-modal-extra');
    const modalStatus = document.getElementById('rsg-save-config-modal-status-extra');

    if (!routeNameInput || !destinationNameInput || !configNameInput || !modal || !modalStatus) {
        console.error("RSG Save Modal Error: One or more essential DOM elements are missing.");
        if (rsgStatusMessage_el_extra) { 
            rsgStatusMessage_el_extra.textContent = "Error: Save dialog components missing.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const currentRouteName = routeNameInput.value.trim();
    const currentDestName = destinationNameInput.value.trim();
    const currentOpProfiles = rsg_getSelectedOpProfilesString_ExtraPage();

    if (!currentRouteName || !currentDestName || !currentOpProfiles) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route, Destination, and at least one Operating Profile must be selected to suggest a name for saving.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    
    if (!rsg_selectedStops_extra || rsg_selectedStops_extra.length === 0 || !rsgFirstStopTimesInput_el_extra || !rsgFirstStopTimesInput_el_extra.value.trim()) {
       if (rsgStatusMessage_el_extra) {
           rsgStatusMessage_el_extra.textContent = "Stop Sequence and First Stop Times are required to save a configuration.";
           rsgStatusMessage_el_extra.style.color = "#f1c40f";
       }
       return;
   }

    let defaultConfigName;

    if (rsg_currentlyEditingConfigKey_extra && rsg_currentlyEditingConfigDisplayName_extra) {
        defaultConfigName = rsg_currentlyEditingConfigDisplayName_extra;
    } else {
        const defaultNameRoutePart = currentRouteName.replace(/[^a-zA-Z0-9\s,-]/g, '').trim() || "Route";
        const defaultNameDestPart = currentDestName.replace(/[^a-zA-Z0-9\s,-]/g, '').trim() || "Dest";
        const defaultNameProfilePart = currentOpProfiles.replace(/[^a-zA-Z0-9\s,-]/g, '').trim() || "Profile";
        defaultConfigName = `${defaultNameRoutePart} to ${defaultNameDestPart} - ${defaultNameProfilePart}`;
    }

    configNameInput.value = defaultConfigName;
    if (modalStatus) { // Ensure modalStatus element exists before setting its properties
        modalStatus.textContent = ''; 
        modalStatus.style.color = ''; // Reset color
    }
    modal.style.display = 'flex';
}

function rsg_hideSaveConfigModal_ExtraPage() {
    const modal = document.getElementById('rsg-save-config-modal-extra');
    if (modal) modal.style.display = 'none';
}

async function saveSpecificRouteDataToFirebase_ExtraPage(targetRouteName) {
    if (!currentUser_extra || !window.firebaseOMSI || !window.firebaseOMSI.database) {
        console.error("saveSpecificRouteDataToFirebase_ExtraPage: Not logged in or Firebase not available.");
        // Potentially update a status message for the user
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Error: Cannot save route - not logged in or Firebase connection issue.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        throw new Error("Authentication or Firebase connection issue.");
    }

    const { database, dbSet, dbRef, dbRemove } = window.firebaseOMSI; // Ensure dbRemove is destructured
    const saneRouteToUpdate = sanitizeFirebaseKey(targetRouteName); // Assuming sanitizeFirebaseKey is globally available
    const routePathInFirebase = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRouteToUpdate}`;

    console.log(`saveSpecificRouteDataToFirebase_ExtraPage: Preparing to update route "${targetRouteName}" (sanitized: "${saneRouteToUpdate}") in Firebase.`);

    // Filter currentWorkingSchedule_extra to get all entries ONLY for the targetRouteName
    const entriesForThisRoute = currentWorkingSchedule_extra.filter(
        e => e.lineName && e.lineName.toUpperCase() === targetRouteName.toUpperCase()
    );

    if (entriesForThisRoute.length === 0) {
        // If the route now has no entries (e.g., user deleted all its schedules via RSG overwrite with empty)
        // then we should delete this route's node in Firebase.
        console.log(`Route "${targetRouteName}" has no schedule entries in currentWorkingSchedule_extra. Removing its node from Firebase at ${routePathInFirebase}.`);
        try {
            await dbRemove(dbRef(database, routePathInFirebase));
            console.log(`Successfully removed node for route "${targetRouteName}" from Firebase.`);
        } catch (error) {
            console.error(`Error removing node for empty route "${targetRouteName}" from Firebase:`, error);
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Error clearing empty route "${targetRouteName}" in Firebase: ${error.message}`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            // We should still proceed to update ancillary data even if removal fails,
            // as the local schedule (which ancillary data is based on) reflects the route as empty.
        }
    } else {
        // Build the structured data for this specific route
        const routeDataForFirebase = {}; // This will hold { profileKey: { destKey: { entries: [] } } }

        entriesForThisRoute.forEach(entry => {
            // Ensure necessary fields are present for structuring
            if (!entry.OperatingProfile || !entry.destinationName) {
                console.warn("saveSpecificRouteDataToFirebase_ExtraPage: Skipping entry with missing OperatingProfile or destinationName:", entry);
                return;
            }
            const saneProfile = sanitizeFirebaseKey(entry.OperatingProfile);
            const saneDest = sanitizeFirebaseKey(entry.destinationName);

            if (!routeDataForFirebase[saneProfile]) {
                routeDataForFirebase[saneProfile] = {};
            }
            if (!routeDataForFirebase[saneProfile][saneDest]) {
                routeDataForFirebase[saneProfile][saneDest] = { entries: [] };
            }

            const entryForStorage = { ...entry };
            // Ensure these key fields are explicitly part of the stored entry object
            entryForStorage.lineName = entry.lineName;
            entryForStorage.OperatingProfile = entry.OperatingProfile;
            entryForStorage.destinationName = entry.destinationName;

            routeDataForFirebase[saneProfile][saneDest].entries.push(entryForStorage);
        });

        // Sort entries within each R/P/D for consistency
        for (const profileKey in routeDataForFirebase) {
            for (const destKey in routeDataForFirebase[profileKey]) {
                if (routeDataForFirebase[profileKey][destKey].entries) {
                    routeDataForFirebase[profileKey][destKey].entries.sort((a, b) => {
                        const timeA = (a.scheduledTime || "9999").replace(':', '');
                        const timeB = (b.scheduledTime || "9999").replace(':', '');
                        const timeCompare = timeA.localeCompare(timeB);
                        if (timeCompare !== 0) return timeCompare;
                        return (a.stopName || "").localeCompare(b.stopName || ""); // Secondary sort
                    });
                }
            }
        }
        
        console.log(`Attempting to save data for route "${targetRouteName}" to Firebase path: ${routePathInFirebase}`);
        try {
            await dbSet(dbRef(database, routePathInFirebase), routeDataForFirebase);
            console.log(`Successfully saved data for route "${targetRouteName}" to Firebase.`);
        } catch (error) {
             console.error(`Error saving data for route "${targetRouteName}" to Firebase:`, error);
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Error saving route "${targetRouteName}" to Firebase: ${error.message}`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            throw error; // Propagate error to the caller
        }
    }

    // After saving the specific route (or removing it if empty),
    // always update ancillary data based on the full currentWorkingSchedule_extra
    try {
        console.log(`Updating ancillary data after changes to route "${targetRouteName}".`);
        await updateAncillaryScheduleData_ExtraPage(); // This function should be async
        console.log(`Ancillary data updated successfully.`);
    } catch (error) {
        console.error(`Error updating ancillary data after saving route "${targetRouteName}":`, error);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Route data saved, but error updating ancillary data (like unique stops): ${error.message}`;
            // Keep the color as potentially error, or change to warning
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // Decide if this error should also be propagated
    }
}

async function rsg_performSaveConfiguration_ExtraPage() {
            console.log("RSG Save Process: Triggered.");
            const configNameInput = document.getElementById('rsg-config-name-input-extra');
            const modalStatus = document.getElementById('rsg-save-config-modal-status-extra');

            if (!configNameInput || !modalStatus) { /* ... error handling ... */ return; }

            const userDefinedConfigName = configNameInput.value.trim();
            if (!userDefinedConfigName) { /* ... error handling ... */ return; }

            console.log(`RSG Save Process: Modal name: "${userDefinedConfigName}". Currently Editing Key: '${rsg_currentlyEditingConfigKey_extra}', DisplayName: '${rsg_currentlyEditingConfigDisplayName_extra}'`);

            let firebaseKey = null;
            let operationType = ""; 
            // ... (your existing logic for determining firebaseKey and operationType) ...
            if (rsg_currentlyEditingConfigKey_extra && userDefinedConfigName === rsg_currentlyEditingConfigDisplayName_extra) {
                firebaseKey = rsg_currentlyEditingConfigKey_extra;
                operationType = "overwrite_loaded_config";
            } else { /* ... logic to findMatchForKey or create new ... */ 
                let foundMatchForKey = null;
                for (const keyInCache in rsg_loadedConfigs_extra) {
                    if (Object.hasOwnProperty.call(rsg_loadedConfigs_extra, keyInCache)) {
                        const existingConfig = rsg_loadedConfigs_extra[keyInCache];
                        if (existingConfig.userDisplayName === userDefinedConfigName) {
                            foundMatchForKey = keyInCache; break;
                        }
                    }
                }
                if (foundMatchForKey) {
                    firebaseKey = foundMatchForKey; operationType = "overwrite_other_by_display_name";
                } else {
                    firebaseKey = sanitizeFirebaseKey(userDefinedConfigName); operationType = "save_new_config";
                }
            }
            console.log(`RSG Save Process: Operation determined: ${operationType}, Firebase Key: ${firebaseKey}`);
            if (!firebaseKey) { /* ... error handling ... */ return; }
            
            // Synchronization step (ensure this accurately reflects the current UI for time adjustments)
            // The 'input' listeners on timeAdjInput should have already updated rsg_selectedStops_extra items.
            // This block can serve as a final explicit sync if needed, or can be simplified if array is trusted.
            console.log("RSG Save Process: Beginning final sync of time adjustments from UI to rsg_selectedStops_extra array.");
            if (rsgStopSequenceList_el_extra && rsg_selectedStops_extra) {
                const displayedStopItems = rsgStopSequenceList_el_extra.querySelectorAll('li[data-index]');
                displayedStopItems.forEach(li => {
                    const index = parseInt(li.dataset.index);
                    if (rsg_selectedStops_extra[index]) {
                        if (index === 0) { 
                            if(rsg_selectedStops_extra[index].timeAdjustment !== 0) rsg_selectedStops_extra[index].timeAdjustment = 0;
                        } else {
                            const timeAdjInput = li.querySelector('.rsg-time-adjustment-input');
                            if (timeAdjInput) {
                                const uiValue = parseInt(timeAdjInput.value, 10);
                                const currentArrayValue = rsg_selectedStops_extra[index].timeAdjustment;
                                if (!isNaN(uiValue) && uiValue >= 0) {
                                    if (currentArrayValue !== uiValue) {
                                        console.log(`RSG Save Sync: Updating index ${index} from UI value ${uiValue} (was ${currentArrayValue})`);
                                        rsg_selectedStops_extra[index].timeAdjustment = uiValue;
                                    }
                                } else {
                                    if (currentArrayValue !== 0) {
                                        console.log(`RSG Save Sync: Invalid UI value for index ${index} ("${timeAdjInput.value}"), setting to 0 (was ${currentArrayValue})`);
                                        rsg_selectedStops_extra[index].timeAdjustment = 0;
                                    }
                                }
                            } else if (typeof rsg_selectedStops_extra[index].timeAdjustment === 'undefined' || rsg_selectedStops_extra[index].timeAdjustment === null) {
                                 console.log(`RSG Save Sync: No input or undefined adjustment for index ${index}, setting to 0.`);
                                rsg_selectedStops_extra[index].timeAdjustment = 0; 
                            }
                        }
                    }
                });
            }
            console.log("RSG Save Process: Finished final sync of time adjustments.");

            const currentRouteName = rsgRouteNameInput_el_extra.value.trim();
            const currentDestName = rsgDestinationNameInput_el_extra.value.trim();
            const currentOpProfiles = rsg_getSelectedOpProfilesString_ExtraPage();
            const stopSequenceToSave = rsg_selectedStops_extra; // This array should reflect removed stops and time edits
            const firstStopTimesToSave = rsgFirstStopTimesInput_el_extra.value.trim();

            // Detailed logging of what's about to be saved
            console.log("RSG Save Process: Data to be packaged for Firebase:");
            console.log(`  - User Display Name: "${userDefinedConfigName}"`);
            console.log(`  - Route Name: "${currentRouteName}"`);
            console.log(`  - Dest Name: "${currentDestName}"`);
            console.log(`  - Op Profiles: "${currentOpProfiles}"`);
            console.log(`  - First Stop Times: "${firstStopTimesToSave}"`);
            console.log(`  - Stop Sequence Length: ${stopSequenceToSave.length}`);
            console.log("  - Stop Sequence (sample - first 5, with ID, Name, Adjustment):", 
                stopSequenceToSave.slice(0,5).map(s => ({id:s.stopID, name:s.stopName, adj:s.timeAdjustment}))
            );

            if (!currentRouteName || !currentDestName || !currentOpProfiles || stopSequenceToSave.length === 0 || !firstStopTimesToSave) {
                modalStatus.textContent = "Cannot save: All fields (Route, Dest, Profile, Sequence, Times) are required.";
                modalStatus.style.color = "#e74c3c";
                return;
            }

            const configurationToSave = {
                userDisplayName: userDefinedConfigName, 
                routeName: currentRouteName,
                destinationName: currentDestName,
                operatingProfile: currentOpProfiles,
                stopSequence: JSON.parse(JSON.stringify(stopSequenceToSave)), 
                firstStopTimes: firstStopTimesToSave,
                lastSaved: new Date().toISOString()
            };
            
            modalStatus.textContent = `Saving configuration "${userDefinedConfigName}"...`;
            // ... (Firebase save logic as before) ...
            const { database, dbSet, dbRef } = window.firebaseOMSI;
            try {
                const fullSavePath = `${FB_PATH_RSG_CONFIGS}/${firebaseKey}`;
                await dbSet(dbRef(database, fullSavePath), configurationToSave);
                
                rsg_loadedConfigs_extra[firebaseKey] = JSON.parse(JSON.stringify(configurationToSave)); 
                rsg_renderSavedConfigsList_ExtraPage(); 

                modalStatus.textContent = `Configuration "${userDefinedConfigName}" saved successfully!`;
                // ... (status updates and context variable updates as before) ...
                rsg_currentlyEditingConfigKey_extra = firebaseKey;
                rsg_currentlyEditingConfigDisplayName_extra = userDefinedConfigName;
                rsg_lastLoadedRouteName_extra = currentRouteName;
                rsg_lastLoadedDestName_extra = currentDestName;
                rsg_lastLoadedOpProfile_extra = currentOpProfiles;
                
                rsg_isDirty = false; 
                console.log("RSG State: Configuration saved successfully, rsg_isDirty reset to false.");

                setTimeout(rsg_hideSaveConfigModal_ExtraPage, 1500);
            } catch (error) {
                // ... (error handling as before) ...
                console.error("Error saving RSG configuration to Firebase:", error);
                modalStatus.textContent = "Error saving configuration: " + error.message;
            }
        }

async function rsg_performRenameConfiguration_ExtraPage(configKeyToRename, newDisplayName) {
    const statusElement = document.getElementById('rsg-load-status-message-extra'); // Use the status message for the saved configs list

    if (!configKeyToRename) {
        if (statusElement) {
            statusElement.textContent = "Error: No configuration key provided for renaming.";
            statusElement.style.color = "#e74c3c";
        }
        console.error("rsg_performRenameConfiguration_ExtraPage: configKeyToRename is missing.");
        return;
    }

    // newDisplayName is assumed to be non-empty and trimmed by the caller
    // If it could still be empty, an additional check here would be good. For now, we assume caller handles it.

    const configToUpdate = rsg_loadedConfigs_extra[configKeyToRename];
    if (!configToUpdate) {
        if (statusElement) {
            statusElement.textContent = "Error: Original configuration data could not be found. Cannot rename.";
            statusElement.style.color = "#e74c3c";
        }
        console.error(`Failed to find config data for key: ${configKeyToRename} in rsg_loadedConfigs_extra.`);
        return;
    }

    if (statusElement) {
        statusElement.textContent = `Renaming configuration to "${newDisplayName}"...`;
        statusElement.style.color = "#f1c40f";
    }

    const updatedConfigData = {
        ...configToUpdate,
        userDisplayName: newDisplayName, // Already trimmed by caller
        lastSaved: new Date().toISOString()
    };

    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        await dbSet(dbRef(database, `${FB_PATH_RSG_CONFIGS}/${configKeyToRename}`), updatedConfigData);
        rsg_loadedConfigs_extra[configKeyToRename] = updatedConfigData; // Update local cache
        rsg_renderSavedConfigsList_ExtraPage(); // Refresh the displayed list

        if (statusElement) {
            statusElement.textContent = `Configuration successfully renamed to "${newDisplayName}"!`;
            statusElement.style.color = "#2ecc71";
        }
        // No modal to hide anymore for this process
    } catch (error) {
        console.error("Error renaming RSG configuration in Firebase:", error);
        if (statusElement) {
            statusElement.textContent = "Error renaming configuration: " + error.message;
            statusElement.style.color = "#e74c3c";
        }
    }
}

function toTitleCase_rsg(str) {
    if (!str || typeof str !== 'string') return "";
    // This will convert "LAKESIDE" to "Lakeside", "HIGH STREET" to "High Street", etc.
    return str.replace(/\w\S*/g, function(txt){
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
}

function rsg_handleSavedConfigCheckboxChange_ExtraPage() {
    const checkboxes = document.querySelectorAll('.rsg-saved-config-checkbox');
    const tickedCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox:checked');
    const tickedCount = tickedCheckboxes.length;

    if (rsgScheduleSelectedConfigsButton_el_extra) {
        rsgScheduleSelectedConfigsButton_el_extra.disabled = (tickedCount === 0);
    }

    const disableMainActions = tickedCount > 1;

    if (rsgGenerateScheduleButton_el_extra) {
        rsgGenerateScheduleButton_el_extra.disabled = disableMainActions;
    }
    if (rsgSaveConfigurationButton_el_extra) {
        rsgSaveConfigurationButton_el_extra.disabled = disableMainActions;
    }
    if (rsgAddToWorkingScheduleButton_el_extra) {
        if (disableMainActions) {
            rsgAddToWorkingScheduleButton_el_extra.disabled = true;
            rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
            rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
        } else {
            const previewExistsForMainForm = rsg_generatedPreviewEntries_extra && rsg_generatedPreviewEntries_extra.length > 0;
            rsgAddToWorkingScheduleButton_el_extra.disabled = !previewExistsForMainForm;
             if (previewExistsForMainForm) {
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.add('save');
            } else {
                rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
            }
        }
    }
    rsg_updateSelectAllCheckboxesStates();
}

async function rsg_handleScheduleSelectedConfigs_ExtraPage() {
    console.log("Batch Scheduling: Starting for selected saved configs.");
    if (!currentUser_extra) {
        alert("Please log in to schedule configurations.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Please log in.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const tickedCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox:checked');
    if (tickedCheckboxes.length === 0) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "No saved configurations selected to schedule.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    rsg_batchScheduleItems = []; // Clear previous batch items
    let validConfigsForBatchCount = 0;
    let firstInvalidConfigName = null;

    for (const checkbox of tickedCheckboxes) {
        const configKey = checkbox.dataset.configKey;
        const configData = rsg_loadedConfigs_extra[configKey];

        if (configData) {
            // Validate this config by trying to generate its preview entries (isPreCheck = true)
            // rsg_handleGenerateSchedulePreview_ExtraPage will populate rsg_generatedPreviewEntries_extra
            if (rsg_handleGenerateSchedulePreview_ExtraPage(true, configData)) {
                rsg_batchScheduleItems.push({
                    configKey: configKey, // Keep key for reference
                    userDisplayName: configData.userDisplayName || configKey,
                    routeName: configData.routeName,
                    destinationName: configData.destinationName,
                    operatingProfile: configData.operatingProfile,
                    stopSequence: JSON.parse(JSON.stringify(configData.stopSequence)), // Deep copy
                    firstStopTimes: configData.firstStopTimes,
                    scheduledEntries: JSON.parse(JSON.stringify(rsg_generatedPreviewEntries_extra)) // Crucial: copy the generated entries for this config
                });
                validConfigsForBatchCount++;
            } else {
                console.warn(`Batch Scheduling: Config "${configData.userDisplayName || configKey}" is invalid or produced no entries. Skipping.`);
                if (!firstInvalidConfigName) firstInvalidConfigName = configData.userDisplayName || configKey;
            }
        } else {
            console.warn(`Batch Scheduling: Could not find config data for key ${configKey}. Skipping.`);
             if (!firstInvalidConfigName) firstInvalidConfigName = `Key: ${configKey}`;
        }
    }
    
    // Clear the global preview entries after batch processing is done, so it doesn't interfere with main form.
    rsg_generatedPreviewEntries_extra = [];

    if (rsg_batchScheduleItems.length > 0) {
        const scheduleModal = document.getElementById('rsg-schedule-datetime-modal-extra');
        if (scheduleModal) {
            const modalStatus = document.getElementById('rsg-schedule-datetime-modal-status-extra');
            if (modalStatus) {
                 modalStatus.textContent = `Preparing to schedule ${rsg_batchScheduleItems.length} configuration(s). ${firstInvalidConfigName ? `Some (${tickedCheckboxes.length - validConfigsForBatchCount}) were skipped due to issues (e.g., ${firstInvalidConfigName}).` : ''}`;
                 modalStatus.style.color = firstInvalidConfigName ? "#f1c40f" : ""; // Yellow if some skipped
            }
            
            const goLiveInput = document.getElementById('rsg-go-live-datetime-input-extra');
            if (goLiveInput) { // Set default go-live time
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(5, 0, 0, 0); // Default 05:00 AM
                goLiveInput.value = `${tomorrow.getFullYear()}-${String(tomorrow.getMonth() + 1).padStart(2, '0')}-${String(tomorrow.getDate()).padStart(2, '0')}T${String(tomorrow.getHours()).padStart(2, '0')}:${String(tomorrow.getMinutes()).padStart(2, '0')}`;
            }
            scheduleModal.style.display = 'flex';
        } else {
            console.error("Batch Scheduling: Schedule DateTime modal not found!");
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Error: Scheduling modal component is missing.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
        }
    } else {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `No valid configurations to schedule. ${firstInvalidConfigName ? `Problem with "${firstInvalidConfigName}".` : 'Please check selected items.'}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
    }
}

function rsg_renderSavedConfigsList_ExtraPage() {
    const container = document.getElementById('rsg-saved-configs-list-extra');
    if (!container) {
        return;
    }
    container.innerHTML = '';

    const activeRouteNamesFromSchedule = [...new Set(
        currentWorkingSchedule_extra
            .map(entry => entry.lineName)
            .filter(Boolean)
    )];

    const configsByRouteFromSaved = {};
    if (rsg_loadedConfigs_extra && typeof rsg_loadedConfigs_extra === 'object') {
        Object.keys(rsg_loadedConfigs_extra).forEach(key => {
            const configData = rsg_loadedConfigs_extra[key];
            const routeNameFromConfig = configData.routeName || "Unspecified Route";
            if (!configsByRouteFromSaved[routeNameFromConfig]) {
                configsByRouteFromSaved[routeNameFromConfig] = [];
            }
            configsByRouteFromSaved[routeNameFromConfig].push({ key: key, data: configData });
        });
    }

    const allRouteNamesToDisplaySet = new Set([
        ...activeRouteNamesFromSchedule,
        ...Object.keys(configsByRouteFromSaved).filter(rn => rn !== "Unspecified Route")
    ]);
    const sortedAllRouteNamesToDisplay = Array.from(allRouteNamesToDisplaySet).sort(compareLineNames_ExtraPage);

    if (sortedAllRouteNamesToDisplay.length === 0 && !(configsByRouteFromSaved["Unspecified Route"] && configsByRouteFromSaved["Unspecified Route"].length > 0)) {
        const p = document.createElement('p');
        p.id = "rsg-no-saved-configs-message-extra";
        p.style.padding = "0.5em";
        p.style.textAlign = "center";
        p.style.opacity = "0.7";
        p.textContent = "No active routes in schedule and no configurations saved yet.";
        container.appendChild(p);
        rsg_updateSelectAllCheckboxesStates(); // Update even if no items
        return;
    }

    sortedAllRouteNamesToDisplay.forEach(routeName => {
        const routeHeadingContainer = document.createElement('div');
        routeHeadingContainer.style.display = 'flex';
        routeHeadingContainer.style.alignItems = 'center';
        routeHeadingContainer.style.marginTop = "0.8em";
        routeHeadingContainer.style.marginBottom = "0.4em";
        routeHeadingContainer.style.borderBottom = "1px solid rgba(127,140,141,0.3)";
        routeHeadingContainer.style.paddingBottom = "0.2em";
         if (container.children.length > 0 && container.lastChild.tagName !== 'H4' && container.lastChild.firstChild?.tagName !== 'H4') { // check if previous was not a heading
            routeHeadingContainer.style.marginTop = "1.2em";
        }


        const routeSelectAllCheckbox = document.createElement('input');
        routeSelectAllCheckbox.type = 'checkbox';
        routeSelectAllCheckbox.classList.add('rsg-select-route-configs-checkbox-extra');
        routeSelectAllCheckbox.dataset.routeName = routeName;
        routeSelectAllCheckbox.style.marginRight = '8px';
        routeSelectAllCheckbox.style.verticalAlign = 'middle';
        routeSelectAllCheckbox.addEventListener('change', rsg_handleSelectRouteConfigsChange_ExtraPage);
        routeHeadingContainer.appendChild(routeSelectAllCheckbox);

        const routeHeading = document.createElement('h4');
        routeHeading.textContent = `Route ${routeName}:`;
        routeHeading.style.margin = "0"; // Reset margin as it's inside a flex container
        routeHeading.style.fontSize = "1.1em";
        routeHeading.style.color = "#ecf0f1";
        routeHeadingContainer.appendChild(routeHeading);
        container.appendChild(routeHeadingContainer);

        const configsForThisRoute = configsByRouteFromSaved[routeName];

        if (configsForThisRoute && configsForThisRoute.length > 0) {
            configsForThisRoute.sort((a, b) => {
                const nameA = (a.data.userDisplayName || a.key).toLowerCase();
                const nameB = (b.data.userDisplayName || b.key).toLowerCase();
                const nameCompare = nameA.localeCompare(nameB);
                if (nameCompare !== 0) return nameCompare;
                const destA = a.data.destinationName || "";
                const destB = b.data.destinationName || "";
                return destA.localeCompare(destB);
            });

            configsForThisRoute.forEach(configItem => {
                const configKey = configItem.key;
                const configData = configItem.data;
                const originalUserDisplayName = configData.userDisplayName || configKey;
                const routeNameForDesc = configData.routeName || "N/A";
                let destinationNameForDesc = configData.destinationName || "N/A";
                if (destinationNameForDesc !== "N/A") {
                    destinationNameForDesc = toTitleCase_rsg(destinationNameForDesc);
                }
                let operatingProfileForDesc = configData.operatingProfile || "N/A";
                if (operatingProfileForDesc !== "N/A" && typeof operatingProfileForDesc === 'string') {
                    operatingProfileForDesc = operatingProfileForDesc.split(',')
                                                 .map(p => p.trim())
                                                 .join(', ');
                }
                const descriptiveParametersString = `${routeNameForDesc} to ${destinationNameForDesc} - ${operatingProfileForDesc}`;

                const itemDiv = document.createElement('div');
                itemDiv.style.padding = "0.4em 0.6em 0.4em 28px"; // Indent items under route's select all
                itemDiv.style.marginBottom = "0.3em";
                itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)";
                itemDiv.style.borderRadius = "0.25rem";
                itemDiv.style.display = "flex";
                itemDiv.style.justifyContent = "space-between";
                itemDiv.style.alignItems = "center";
                itemDiv.addEventListener('mouseover', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.1)");
                itemDiv.addEventListener('mouseout', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)");
                itemDiv.title = `Load: ${originalUserDisplayName}\n(Parameters: ${descriptiveParametersString})\n(Key: ${configKey})`;

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `rsg-config-checkbox-${configKey}`;
                checkbox.dataset.configKey = configKey;
                checkbox.dataset.parentRouteName = routeName; // Link to parent route for per-route select all
                checkbox.classList.add('rsg-saved-config-checkbox');
                checkbox.style.marginRight = '10px';
                checkbox.style.verticalAlign = 'middle';
                checkbox.addEventListener('change', rsg_handleSavedConfigCheckboxChange_ExtraPage);
                itemDiv.appendChild(checkbox);

                const nameSpan = document.createElement('span');
                nameSpan.textContent = originalUserDisplayName;
                nameSpan.style.flexGrow = "1";
                nameSpan.style.cursor = "pointer";
                nameSpan.addEventListener('click', () => rsg_handleLoadSelectedConfig_ExtraPage(configKey));
                itemDiv.appendChild(nameSpan);

                const actionButtonsDiv = document.createElement('div');
                actionButtonsDiv.style.display = 'flex';
                actionButtonsDiv.style.alignItems = 'center';

                const renameBtn = document.createElement('button');
                renameBtn.textContent = 'Rename';
                renameBtn.classList.add('button', 'small-action', 'neutral');
                renameBtn.style.marginRight = "0.3em";
                renameBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const statusElement = document.getElementById('rsg-load-status-message-extra');
                    if (statusElement) statusElement.textContent = "";
                    const newNameFromPrompt = prompt(`Enter new name for configuration currently named "${originalUserDisplayName}":`, originalUserDisplayName);
                    if (newNameFromPrompt === null) { }
                    else if (newNameFromPrompt.trim() === "") { }
                    else if (newNameFromPrompt.trim() === originalUserDisplayName) { }
                    else { rsg_performRenameConfiguration_ExtraPage(configKey, newNameFromPrompt.trim()); }
                });
                actionButtonsDiv.appendChild(renameBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'âœ•';
                deleteBtn.classList.add('button', 'small-action', 'secondary');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    rsg_handleDeleteSavedConfig_ExtraPage(configKey, originalUserDisplayName);
                });
                actionButtonsDiv.appendChild(deleteBtn);

                itemDiv.appendChild(actionButtonsDiv);
                container.appendChild(itemDiv);
            });
        } else {
            const noConfigsForRouteMsg = document.createElement('p');
            noConfigsForRouteMsg.textContent = "(No saved RSG configurations for this route)";
            noConfigsForRouteMsg.style.fontSize = "0.85em";
            noConfigsForRouteMsg.style.fontStyle = "italic";
            noConfigsForRouteMsg.style.opacity = "0.7";
            noConfigsForRouteMsg.style.paddingLeft = "28px"; // Indent message as well
            noConfigsForRouteMsg.style.marginBottom = "0.5em";
            container.appendChild(noConfigsForRouteMsg);
            routeSelectAllCheckbox.disabled = true; // Disable select all if no items for this route
        }
    });

    if (configsByRouteFromSaved["Unspecified Route"] && configsByRouteFromSaved["Unspecified Route"].length > 0) {
        const unspecifiedHeadingContainer = document.createElement('div');
        unspecifiedHeadingContainer.style.display = 'flex';
        unspecifiedHeadingContainer.style.alignItems = 'center';
        unspecifiedHeadingContainer.style.marginTop = "1.2em";
        unspecifiedHeadingContainer.style.marginBottom = "0.4em";
        unspecifiedHeadingContainer.style.borderBottom = "1px solid rgba(127,140,141,0.3)";
        unspecifiedHeadingContainer.style.paddingBottom = "0.2em";

        const unspecifiedSelectAllCheckbox = document.createElement('input');
        unspecifiedSelectAllCheckbox.type = 'checkbox';
        unspecifiedSelectAllCheckbox.classList.add('rsg-select-route-configs-checkbox-extra');
        unspecifiedSelectAllCheckbox.dataset.routeName = "Unspecified Route";
        unspecifiedSelectAllCheckbox.style.marginRight = '8px';
        unspecifiedSelectAllCheckbox.style.verticalAlign = 'middle';
        unspecifiedSelectAllCheckbox.addEventListener('change', rsg_handleSelectRouteConfigsChange_ExtraPage);
        unspecifiedHeadingContainer.appendChild(unspecifiedSelectAllCheckbox);

        const unspecifiedHeading = document.createElement('h4');
        unspecifiedHeading.textContent = "Route: Unspecified Route (from saved configs)";
        unspecifiedHeading.style.margin = "0";
        unspecifiedHeading.style.fontSize = "1.1em";
        unspecifiedHeading.style.color = "#ecf0f1";
        unspecifiedHeadingContainer.appendChild(unspecifiedHeading);
        container.appendChild(unspecifiedHeadingContainer);

        configsByRouteFromSaved["Unspecified Route"].forEach(configItem => {
             const configKey = configItem.key;
            const configData = configItem.data;
            const originalUserDisplayName = configData.userDisplayName || configKey;
            const descriptiveParametersString = `Unspecified Route - Profile: ${configData.operatingProfile || 'N/A'} - Dest: ${toTitleCase_rsg(configData.destinationName || 'N/A')}`;

            const itemDiv = document.createElement('div');
            itemDiv.style.padding = "0.4em 0.6em 0.4em 28px";
            itemDiv.style.marginBottom = "0.3em";
            itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)";
            itemDiv.style.borderRadius = "0.25rem";
            itemDiv.style.display = "flex";
            itemDiv.style.justifyContent = "space-between";
            itemDiv.style.alignItems = "center";
            itemDiv.addEventListener('mouseover', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.1)");
            itemDiv.addEventListener('mouseout', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)");
            itemDiv.title = `Load: ${originalUserDisplayName}\n(Parameters: ${descriptiveParametersString})\n(Key: ${configKey})`;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `rsg-config-checkbox-${configKey}`;
            checkbox.dataset.configKey = configKey;
            checkbox.dataset.parentRouteName = "Unspecified Route";
            checkbox.classList.add('rsg-saved-config-checkbox');
            checkbox.style.marginRight = '10px';
            checkbox.style.verticalAlign = 'middle';
            checkbox.addEventListener('change', rsg_handleSavedConfigCheckboxChange_ExtraPage);
            itemDiv.appendChild(checkbox);

            const nameSpan = document.createElement('span');
            nameSpan.textContent = originalUserDisplayName;
            nameSpan.style.flexGrow = "1";
            nameSpan.style.cursor = "pointer";
            nameSpan.addEventListener('click', () => rsg_handleLoadSelectedConfig_ExtraPage(configKey));
            itemDiv.appendChild(nameSpan);

            const actionButtonsDiv = document.createElement('div');
            actionButtonsDiv.style.display = 'flex';
            actionButtonsDiv.style.alignItems = 'center';

            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Rename';
            renameBtn.classList.add('button', 'small-action', 'neutral');
            renameBtn.style.marginRight = "0.3em";
            renameBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const statusElement = document.getElementById('rsg-load-status-message-extra');
                if (statusElement) statusElement.textContent = "";
                const newNameFromPrompt = prompt(`Enter new name for configuration currently named "${originalUserDisplayName}":`, originalUserDisplayName);
                if (newNameFromPrompt === null) {}
                else if (newNameFromPrompt.trim() === "") {}
                else if (newNameFromPrompt.trim() === originalUserDisplayName) {}
                else { rsg_performRenameConfiguration_ExtraPage(configKey, newNameFromPrompt.trim()); }
            });
            actionButtonsDiv.appendChild(renameBtn);

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'âœ•';
            deleteBtn.classList.add('button', 'small-action', 'secondary');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                rsg_handleDeleteSavedConfig_ExtraPage(configKey, originalUserDisplayName);
            });
            actionButtonsDiv.appendChild(deleteBtn);

            itemDiv.appendChild(actionButtonsDiv);
            container.appendChild(itemDiv);
        });
         if (configsByRouteFromSaved["Unspecified Route"].length === 0) {
            unspecifiedSelectAllCheckbox.disabled = true;
        }
    }
    rsg_handleSavedConfigCheckboxChange_ExtraPage();
    rsg_updateSelectAllCheckboxesStates();
}

function rsg_handleSelectAllConfigsChange_ExtraPage() {
    const isChecked = rsgSelectAllConfigsCheckbox_el_extra.checked;
    const individualCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox');
    const perRouteCheckboxes = document.querySelectorAll('.rsg-select-route-configs-checkbox-extra');

    individualCheckboxes.forEach(cb => cb.checked = isChecked);
    perRouteCheckboxes.forEach(cb => {
        // Only check per-route if it's not disabled (i.e., has items under it)
        if (!cb.disabled) {
            cb.checked = isChecked;
        }
    });

    rsg_handleSavedConfigCheckboxChange_ExtraPage(); // Update main button states
}

function rsg_handleSelectRouteConfigsChange_ExtraPage(event) {
    const sourceCheckbox = event.target;
    const routeName = sourceCheckbox.dataset.routeName;
    const isChecked = sourceCheckbox.checked;

    const individualCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox');
    individualCheckboxes.forEach(cb => {
        if (cb.dataset.parentRouteName === routeName) {
            cb.checked = isChecked;
        }
    });

    rsg_updateSelectAllCheckboxesStates(); // Update global select all based on this change
    rsg_handleSavedConfigCheckboxChange_ExtraPage(); // Update main button states
}

function rsg_updateSelectAllCheckboxesStates() {
    // Update Per-Route "Select All" Checkboxes
    const perRouteCheckboxes = document.querySelectorAll('.rsg-select-route-configs-checkbox-extra');
    perRouteCheckboxes.forEach(perRouteCb => {
        if (perRouteCb.disabled) return; // Skip if it has no items

        const routeName = perRouteCb.dataset.routeName;
        const individualCheckboxesForRoute = document.querySelectorAll(`.rsg-saved-config-checkbox[data-parent-route-name="${routeName}"]`);
        
        if (individualCheckboxesForRoute.length > 0) {
            const allCheckedForRoute = Array.from(individualCheckboxesForRoute).every(cb => cb.checked);
            perRouteCb.checked = allCheckedForRoute;
        } else {
            perRouteCb.checked = false; // No items, so can't be "all checked"
        }
    });

    // Update Global "Select All (Everything)" Checkbox
    if (rsgSelectAllConfigsCheckbox_el_extra) {
        const allIndividualCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox');
        if (allIndividualCheckboxes.length > 0) {
            const allItemsCheckedOverall = Array.from(allIndividualCheckboxes).every(cb => cb.checked);
            rsgSelectAllConfigsCheckbox_el_extra.checked = allItemsCheckedOverall;
        } else {
            rsgSelectAllConfigsCheckbox_el_extra.checked = false; // No items to select
        }
    }
}

async function rsg_handleDeleteSavedConfig_ExtraPage(configKey, displayName) {
    if (!confirm(`Are you sure you want to delete the saved configuration: "${displayName}"? This cannot be undone.`)) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Deletion cancelled.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    if (!window.firebaseOMSI || !window.firebaseOMSI.database || !window.firebaseOMSI.dbGet) { // Added dbGet check
        alert("Firebase components not available. Cannot delete configuration.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Firebase components not available.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    // Make sure dbGet is correctly aliased as get if you use it directly like in the check below
    const { database, dbRemove, dbRef, dbGet: get } = window.firebaseOMSI; // Using alias 'get' for dbGet
    const configPath = `${FB_PATH_RSG_CONFIGS}/${configKey}`;

    if (rsgStatusMessage_el_extra) {
        rsgStatusMessage_el_extra.textContent = `Attempting to delete "${displayName}" (key: ${configKey}) from Firebase path: ${configPath}...`;
        rsgStatusMessage_el_extra.style.color = "#3498db"; // Blue for processing
    }
    console.log(`Attempting to delete from Firebase path: ${configPath}`);

    try {
        await dbRemove(dbRef(database, configPath));
        console.log(`Firebase dbRemove promise resolved for path: ${configPath}. Attempting to verify deletion from server...`);

        // VERIFICATION STEP: Try to fetch the data again immediately after deletion.
        // This helps confirm if the server actually processed the delete.
        const checkSnapshot = await get(dbRef(database, configPath)); // Using the aliased 'get'

        if (checkSnapshot.exists()) {
            // If it still exists, the delete didn't work on the server.
            console.error(`VERIFICATION FAILED: Config "${displayName}" (key: ${configKey}) still exists in Firebase at ${configPath} after dbRemove was called and resolved. This is unexpected.`);
            alert(`Error: Deletion for "${displayName}" appeared to succeed client-side, but the data is still present on the server. Please check Firebase rules for path "${FB_PATH_RSG_CONFIGS}" and its children, and network connectivity. Refreshing the list to reflect the server state.`);
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Deletion of "${displayName}" failed to persist on server. List refreshed.`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            // Force a reload of all RSG configs from Firebase to ensure UI matches the server.
            loadInitialData_ExtraPage(); // Or a more targeted reload for RSG configs if available
            return;
        } else {
            console.log(`VERIFICATION SUCCESS: Config "${displayName}" (key: ${configKey}) confirmed deleted from Firebase server path: ${configPath}.`);
        }

        // If verification passes (or if you skip verification), update local cache and UI.
        delete rsg_loadedConfigs_extra[configKey];
        rsg_renderSavedConfigsList_ExtraPage();

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Configuration "${displayName}" deleted successfully.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
        }

    } catch (error) { // This catch is for errors from dbRemove or the verification 'get'
        console.error(`Error during Firebase operation for configuration "${displayName}" (key: ${configKey}):`, error);
        alert(`Failed to delete configuration "${displayName}". Error: ${error.message}. The list may be out of sync. Please refresh.`);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error deleting configuration "${displayName}": ${error.message}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // On error, it's good practice to reload data to ensure UI consistency.
        loadInitialData_ExtraPage(); // Or a more targeted reload for RSG configs
    }
}

function rsg_getOtherRouteAdjustmentsForStop(targetStopID, currentEditingConfigKey) {
    const adjustmentsMap = new Map(); // Key: adjustmentValue, Value: { count: N, routeNames: Set() }

    if (!rsg_loadedConfigs_extra || typeof rsg_loadedConfigs_extra !== 'object') {
        return { hasDiscrepancies: false, mostCommonValue: null, suggestionTitle: '' };
    }

    for (const configKey in rsg_loadedConfigs_extra) {
        // Skip the configuration currently being edited to avoid comparing with its own (potentially unsaved) state
        if (configKey === currentEditingConfigKey) {
            continue;
        }

        const config = rsg_loadedConfigs_extra[configKey];
        if (config && Array.isArray(config.stopSequence)) {
            for (let i = 0; i < config.stopSequence.length; i++) {
                const stopInOtherConfig = config.stopSequence[i];
                // We only care about adjustments for the same stopID,
                // and only if it's not the first stop in that other sequence (index > 0),
                // and if timeAdjustment is a valid number.
                if (stopInOtherConfig.stopID === targetStopID &&
                    i > 0 && // Not the first stop (as first stop has no preceding adjustment)
                    typeof stopInOtherConfig.timeAdjustment === 'number' &&
                    !isNaN(stopInOtherConfig.timeAdjustment)) {

                    const adjValue = stopInOtherConfig.timeAdjustment;
                    if (!adjustmentsMap.has(adjValue)) {
                        adjustmentsMap.set(adjValue, { count: 0, routeNames: new Set() });
                    }
                    const existingEntry = adjustmentsMap.get(adjValue);
                    existingEntry.count++;
                    existingEntry.routeNames.add(config.routeName || "Unknown Route");
                }
            }
        }
    }

    if (adjustmentsMap.size === 0) {
        return { hasDiscrepancies: false, mostCommonValue: null, suggestionTitle: '' }; // No other routes use this stop with an adjustment
    }

    let mostCommonValue = null;
    let maxCount = 0;
    let allUniqueAdjustmentsFromOthers = [];

    adjustmentsMap.forEach((data, adjValue) => {
        allUniqueAdjustmentsFromOthers.push(adjValue);
        if (data.count > maxCount) {
            maxCount = data.count;
            mostCommonValue = adjValue;
        } else if (data.count === maxCount) {
            // Tie-breaking rule: prefer the smaller adjustment value if counts are equal
            if (mostCommonValue === null || adjValue < mostCommonValue) {
                mostCommonValue = adjValue;
            }
        }
    });
    
    let suggestionTitle = '';
    if (mostCommonValue !== null) {
        const routesUsingMostCommon = Array.from(adjustmentsMap.get(mostCommonValue)?.routeNames || []).slice(0,3).join(', ');
        const andMore = (adjustmentsMap.get(mostCommonValue)?.routeNames.size || 0) > 3 ? ' & more' : '';
        suggestionTitle = `Commonly +${mostCommonValue} min (on routes: ${routesUsingMostCommon}${andMore}). Click to apply.`;
    }


    return {
        // hasDiscrepancies: true if there are other adjustments and the current one differs from the mostCommon
        // This will be checked in the rendering function against the current stop's actual adjustment.
        allUniqueAdjustmentsFromOthers: allUniqueAdjustmentsFromOthers.sort((a,b) => a-b),
        mostCommonValue: mostCommonValue, // The adjustment value to suggest
        suggestionTitle: suggestionTitle  // Tooltip for the warning icon
    };
}

function rsg_handleLoadSelectedConfig_ExtraPage(configKey) {
    const configData = rsg_loadedConfigs_extra[configKey];
    const loadStatusMsg = document.getElementById('rsg-load-status-message-extra');

    if (!configData) {
        if (loadStatusMsg) loadStatusMsg.textContent = "Error: Could not find configuration data for " + configKey;
        rsg_currentlyEditingConfigKey_extra = null; 
        rsg_currentlyEditingConfigDisplayName_extra = null;
        rsg_updateRsgActionButtonsState(); // Added call, even on failure to reset buttons if needed
        return;
    }

    rsg_currentlyEditingConfigKey_extra = configKey;
    rsg_currentlyEditingConfigDisplayName_extra = configData.userDisplayName || configKey;

    rsgRouteNameInput_el_extra.value = configData.routeName || "";
    rsgDestinationNameInput_el_extra.value = configData.destinationName || "";
    rsg_setCheckedProfiles_ExtraPage(configData.operatingProfile || "");
    rsg_selectedStops_extra = JSON.parse(JSON.stringify(configData.stopSequence || []));
    rsgFirstStopTimesInput_el_extra.value = configData.firstStopTimes || "";

    rsg_lastLoadedRouteName_extra = configData.routeName || "";
    rsg_lastLoadedDestName_extra = configData.destinationName || "";
    rsg_lastLoadedOpProfile_extra = configData.operatingProfile || "";

    rsg_renderStopSequence_ExtraPage();
    rsg_resetPreviewState(`Loaded configuration: "${rsg_currentlyEditingConfigDisplayName_extra}". Adjust and save if needed.`, "success");
    if (loadStatusMsg) loadStatusMsg.textContent = `Loaded: "${rsg_currentlyEditingConfigDisplayName_extra}"`;
    rsg_isDirty = false;

    rsgRouteNameInput_el_extra.dispatchEvent(new Event('blur'));
    setTimeout(() => {
         rsgDestinationNameInput_el_extra.dispatchEvent(new Event('blur'));
    },50);
    rsg_updateRsgActionButtonsState(); // Added call
}

function getDaySortOrder_ExtraPage(profile) {
    if (!profile) return 9999;
    const p = String(profile).toUpperCase().replace(/\s+/g, ''); 
    const has = (keywords) => keywords.some(kw => p.includes(kw));
    let baseScore = 9000;

    if (has(["MONDAY", "MO"])) baseScore = 100;
    else if (has(["TUESDAY", "TU"])) baseScore = 200;
    else if (has(["WEDNESDAY", "WE"])) baseScore = 300;
    else if (has(["THURSDAY", "TH"])) baseScore = 400;
    else if (has(["FRIDAY", "FR"]) && !p.includes("GOODFRIDAY")) baseScore = 500;
    else if (has(["MON-FRI", "MONTOFRI", "WEEKDAY", "MF"])) baseScore = 600; 
    else if (has(["SATURDAY", "SA"]) && !p.includes("GOODFRIDAY")) baseScore = 700; 
    else if (has(["SUNDAY", "SU"])) baseScore = 800;

    if (baseScore < 9000) { 
        if (has(["SCH"])) return baseScore + 1;    
        if (has(["NSD"])) return baseScore + 2;    
        return baseScore; 
    }
    // Specific holiday scores (ensure these match what's in RSG_OPERATING_PROFILES_LIST if they are standalone)
    if (has(["CHRISTMASDAY"])) return 9030; // Example scores
    if (has(["BOXINGDAY"])) return 9040;
    if (has(["NEWYEARSDAY"])) return 9050;
    // Removed GoodFriday, SchoolHoliday, BankHoliday, AllDays from here if they are no longer primary types

    if (String(profile).includes(',')) { // For sorting already combined strings if needed elsewhere
        const parts = String(profile).split(',');
        let minScoreForParts = 9999;
        for (const part of parts) {
            minScoreForParts = Math.min(minScoreForParts, getDaySortOrder_ExtraPage(part.trim())); 
        }
        return minScoreForParts;
    }
    return baseScore; 
}

function rsg_populateProfileCheckboxes_ExtraPage() {
    const container = document.getElementById('rsg-selectable-profiles-container-extra');
    const placeholder = document.getElementById('rsg-profiles-placeholder-extra');
    if (!container) {
        console.error("RSG Profile checkbox container not found!");
        return;
    }
    container.innerHTML = ''; 

    if (RSG_OPERATING_PROFILES_LIST.length === 0 && placeholder) {
        placeholder.textContent = "No profiles defined to display.";
        container.appendChild(placeholder);
        return;
    }

    RSG_OPERATING_PROFILES_LIST.forEach(profileValue => {
        const wrapper = document.createElement('div');
        wrapper.style.display = 'inline-flex'; 
        wrapper.style.alignItems = 'center';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        const safeProfileId = profileValue.replace(/[^a-zA-Z0-9_-]/g, '');
        checkbox.id = `rsg-profile-cb-${safeProfileId}-extra`;
        checkbox.value = profileValue;
        checkbox.name = 'rsgOperatingProfileCheckbox_extra';
        checkbox.classList.add('rsg-profile-checkbox'); 

        checkbox.addEventListener('change', rsg_handleProfileSelectionChange_ExtraPage);

        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.textContent = profileValue;
        label.style.marginLeft = "4px"; 
        label.style.cursor = "pointer";
        label.style.color = "#ecf0f1"; 

        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        container.appendChild(wrapper);
    });
    // DO NOT call rsg_handleProfileSelectionChange_ExtraPage or rsg_updateDisabledProfileCheckboxes_ExtraPage here.
    // The initial state will be set after the first call to rsg_loadOrPullConfiguration_ExtraPage from showExtraPageSection.
}

function populateTimetableExporterRouteSelect_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !currentWorkingSchedule_extra) {
        console.warn("Timetable Exporter: Route select element or schedule data not available.");
        return;
    }
    const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName).filter(Boolean))].sort(compareLineNames_ExtraPage);
    
    const currentInputValue = tteRouteNameInput_el_extra ? tteRouteNameInput_el_extra.value.trim() : "";
    
    tteRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Route --</option>';
    uniqueRoutes.forEach(route => {
        const opt = document.createElement('option');
        opt.value = route;
        opt.textContent = route;
        tteRouteNameSelect_el_extra.appendChild(opt);
    });

    if (currentInputValue) {
        const matchedOption = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
        tteRouteNameSelect_el_extra.value = matchedOption ? matchedOption : "";
    } else {
        tteRouteNameSelect_el_extra.value = "";
    }
}

// --- Helper Functions for PDF Timetable Generation ---

// Helper to convert HH:MM time string to absolute minutes from start of day
function getAbsMinutes(timeStr, dayOffset = 0) {
    // Check if timeStr is valid and in HH:MM format
    if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {
        // console.warn("getAbsMinutes: Invalid timeStr provided:", timeStr);
        return null; 
    }
    const parts = timeStr.split(':');
    if (parts.length !== 2) {
        // console.warn("getAbsMinutes: timeStr not in HH:MM format:", timeStr);
        return null;
    }

    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    
    // Ensure hours and minutes are valid numbers
    if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
        // console.warn("getAbsMinutes: Invalid hours or minutes in timeStr:", timeStr);
        return null;
    }

    // Ensure dayOffset is treated as a number, default to 0 if NaN or invalid
    const numericDayOffset = parseInt(dayOffset, 10);
    const validDayOffset = isNaN(numericDayOffset) ? 0 : numericDayOffset;
    
    return (validDayOffset * 1440) + (hours * 60) + minutes;
}

function toTitleCase_display(str) {
    if (!str || typeof str !== 'string') return "";
    return str.toLowerCase().split(' ').map(function(word) {
        if (word.length > 0) {
            // Handle special cases like "Year's" correctly
            if (word.includes("'")) {
                const parts = word.split("'");
                parts[0] = parts[0].charAt(0).toUpperCase() + parts[0].substring(1);
                return parts.join("'");
            }
            return word.charAt(0).toUpperCase() + word.substring(1);
        }
        return "";
    }).join(' ');
}

async function handleDownloadTimetable_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !tteRouteNameInput_el_extra || !tteStatusMessage_el_extra) {
        console.warn("Timetable Exporter: Essential UI elements are missing for download.");
        if(tteStatusMessage_el_extra) {
             tteStatusMessage_el_extra.textContent = "Initialization error. Try refreshing.";
             tteStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const routeName = tteRouteNameInput_el_extra.value.trim() || tteRouteNameSelect_el_extra.value;

    if (!routeName) {
        tteStatusMessage_el_extra.textContent = "Please select or enter a route name.";
        tteStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    if (!currentUser_extra || typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined' || typeof window.jspdf.jsPDF.API.autoTable === 'undefined') {
        tteStatusMessage_el_extra.textContent = "Error: PDF library not ready or not logged in.";
        tteStatusMessage_el_extra.style.color = "#e74c3c";
        console.error("jsPDF or jsPDF-AutoTable not correctly loaded. window.jspdf:", window.jspdf);
        return;
    }

    tteStatusMessage_el_extra.textContent = `Processing PDF timetable for route: ${routeName}...`;
    tteStatusMessage_el_extra.style.color = "#3498db";

    try {
        const routeEntries = currentWorkingSchedule_extra.filter(e => e.lineName === routeName);
        if (routeEntries.length === 0) {
            tteStatusMessage_el_extra.textContent = `No schedule data found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'landscape',
            unit: 'pt',
            format: 'a4'
        });
        let isFirstTableInPDF = true;

        const uniqueProfileDestPairs = new Map();
        routeEntries.forEach(e => {
            if (e.OperatingProfile && e.destinationName) {
                uniqueProfileDestPairs.set(`${e.OperatingProfile}|${e.destinationName}`, true);
            }
        });

        if (uniqueProfileDestPairs.size === 0) {
            tteStatusMessage_el_extra.textContent = `No operating profile/destination combinations found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }
        
        const sortedPairs = Array.from(uniqueProfileDestPairs.keys()).sort((a,b) => {
            const [profA, destA] = a.split('|');
            const [profB, destB] = b.split('|');
            const profCompare = profA.localeCompare(profB);
            if (profCompare !== 0) return profCompare;
            return destA.localeCompare(destB);
        });

        let tablesAddedToPDF = 0;

        for (const pair of sortedPairs) {
            const [opProfile, destName] = pair.split('|');
            let specificEntries = routeEntries.filter(e =>
                e.OperatingProfile === opProfile && e.destinationName === destName
            );

            if (specificEntries.length === 0) continue;

            specificEntries.sort((a, b) => {
                const dayOffsetA = parseInt(a.DayOffset || 0);
                const dayOffsetB = parseInt(b.DayOffset || 0);
                if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
                const timeA = (a.scheduledTime || "99:99").replace(':', '');
                const timeB = (b.scheduledTime || "99:99").replace(':', '');
                return timeA.localeCompare(timeB);
            });

            const trips = segmentEntriesIntoTrips_forTimetable(specificEntries);
            if (trips.length === 0) continue;

            const stopOrderMap = new Map();
            let globalStopIndexForOrdering = 0;
            trips.forEach(trip => { // Use all trips to define the superset of stops in order
                trip.forEach(entry => {
                    if (!entry.stopID || !entry.scheduledTime) return;
                    const currentStopTimeAbsVal = (parseInt(entry.DayOffset || 0) * 1440) +
                                             parseInt(entry.scheduledTime.split(':')[0]) * 60 +
                                             parseInt(entry.scheduledTime.split(':')[1]);
                    if (!stopOrderMap.has(entry.stopID)) {
                        stopOrderMap.set(entry.stopID, {
                            stopID: entry.stopID, name: entry.stopName, direction: entry.direction,
                            earliestTimeAbs: currentStopTimeAbsVal, 
                            firstSeenIndex: globalStopIndexForOrdering++
                        });
                    }
                });
            });
            const canonicalStopSequence = Array.from(stopOrderMap.values()).sort((a,b) => a.firstSeenIndex - b.firstSeenIndex);

            if (canonicalStopSequence.length === 0) continue;

            const tableHead = [["Stop ID", "Stop Name", "Stop Aim"]];
            trips.forEach((trip, index) => {
                tableHead[0].push(trip[0] ? `${trip[0].scheduledTime}` : `Trip ${index + 1}`);
            });

            const tableBody = [];
            canonicalStopSequence.forEach(stopInfo => {
                const row = [stopInfo.stopID || "", stopInfo.name || "", stopInfo.direction || ""];
                trips.forEach(trip => {
                    const entryForStopInTrip = trip.find(e => e.stopID === stopInfo.stopID);
                    row.push(entryForStopInTrip ? entryForStopInTrip.scheduledTime : "-");
                });
                tableBody.push(row);
            });

            if (tableBody.length > 0) {
                if (!isFirstTableInPDF) {
                    doc.addPage('a4', 'landscape');
                }
                isFirstTableInPDF = false;

                doc.setFontSize(14);
                doc.text(`Route: ${routeName}`, 40, 40);
                doc.setFontSize(11);
                doc.text(`Direction: Towards ${destName}`, 40, 55); // Adjusted Y for spacing
                doc.text(`Operating Profile: ${opProfile}`, 40, 70); // Adjusted Y for spacing

                doc.autoTable({
                    head: tableHead,
                    body: tableBody,
                    startY: 85, // Adjusted startY
                    theme: 'grid',
                    styles: { fontSize: 6, cellPadding: 1.5, overflow: 'visible' }, // 'ellipsize' or 'visible' or 'linebreak'
                    headStyles: { fillColor: [44, 62, 80], textColor: 255, fontSize: 7, fontStyle: 'bold', halign: 'center' },
                    columnStyles: {
                        0: { cellWidth: 50, fontStyle: 'bold' }, 
                        1: { cellWidth: 120 },
                        2: { cellWidth: 100 },
                        // For time columns, you might let them auto-adjust or set a small fixed width if many
                    },
                    margin: { top: 25, right: 30, bottom: 30, left: 40 }, // Adjusted top margin
                    tableWidth: 'auto',
                });
                tablesAddedToPDF++;
            }
        }

        if (tablesAddedToPDF > 0) {
            doc.save(`${sanitizeFirebaseKey(routeName)}_Timetable.pdf`);
            tteStatusMessage_el_extra.textContent = `Timetable PDF for ${routeName} generated successfully!`;
            tteStatusMessage_el_extra.style.color = "#2ecc71";
        } else {
            tteStatusMessage_el_extra.textContent = `No valid trip data found to generate PDF for route ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
        }

    } catch (error) {
        console.error("Error generating PDF timetable:", error);
        tteStatusMessage_el_extra.textContent = "Error generating PDF: " + error.message;
        tteStatusMessage_el_extra.style.color = "#e74c3c";
    }
}

// --- Helper function to segment entries into individual trips for PDF Timetable ---

function segmentEntriesIntoTrips_forTimetable(profileDestEntries, minStopsPerTripHeuristic = 1) { // <-- SET TO 200
    const allTrips = [];
    if (!profileDestEntries || profileDestEntries.length === 0) {
        return allTrips;
    }

    profileDestEntries.sort((a, b) => {
        const dayOffsetA = parseInt(a.DayOffset || 0);
        const dayOffsetB = parseInt(b.DayOffset || 0);
        if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
        const timeA = (a.scheduledTime || "99:99").replace(':', '');
        const timeB = (b.scheduledTime || "99:99").replace(':', '');
        return timeA.localeCompare(timeB);
    });

    let currentTrip = [];
    let previousStopTimeInAbsoluteMinutes = -1;
    let firstStopTimeOfCurrentLogicalTrip = -1;

    const rpdContext = profileDestEntries.length > 0 ? `(Route: ${profileDestEntries[0].lineName}, Profile: ${profileDestEntries[0].OperatingProfile}, Dest: ${profileDestEntries[0].destinationName})` : "";

    for (let i = 0; i < profileDestEntries.length; i++) {
        const entry = profileDestEntries[i];
        if (!entry.stopID || !entry.scheduledTime) continue;

        const currentStopTimeInAbsoluteMinutes =
            (parseInt(entry.DayOffset || 0) * 1440) +
            parseInt(entry.scheduledTime.split(':')[0]) * 60 +
            parseInt(entry.scheduledTime.split(':')[1]);

        if (currentTrip.length === 0) { 
            firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes;
        }
        
        if (currentTrip.length > 0) {
            // Condition 1: Time goes backward
            if (currentStopTimeInAbsoluteMinutes < previousStopTimeInAbsoluteMinutes) {
                console.log(`TRIP SPLIT (Time Regression) ${rpdContext}: Prev Stop ${currentTrip[currentTrip.length-1].stopID} (${currentTrip[currentTrip.length-1].scheduledTime} Day ${currentTrip[currentTrip.length-1].DayOffset || 0} / Abs: ${previousStopTimeInAbsoluteMinutes}), Curr Stop ${entry.stopID} (${entry.scheduledTime} Day ${entry.DayOffset || 0} / Abs: ${currentStopTimeInAbsoluteMinutes})`);
                allTrips.push([...currentTrip]); 
                currentTrip = []; 
                firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes; 
            } 
            // Condition 2: The STARTING STOP OF THE CURRENT TRIP is seen again
            // This condition is now very unlikely to be met with minStopsPerTripHeuristic = 9000
            else if (entry.stopID === currentTrip[0].stopID && 
                     currentTrip.length >= minStopsPerTripHeuristic && 
                     currentStopTimeInAbsoluteMinutes !== firstStopTimeOfCurrentLogicalTrip
                    ) {
                console.log(`TRIP SPLIT (Current Trip Start Stop Repeat) ${rpdContext}: Curr Stop ${entry.stopID} at ${entry.scheduledTime} (Abs: ${currentStopTimeInAbsoluteMinutes}), CurrentTripStartStopID: ${currentTrip[0].stopID}, TripLength: ${currentTrip.length}, minHeuristic: ${minStopsPerTripHeuristic}, FirstTimeOfCurrentTrip: ${firstStopTimeOfCurrentLogicalTrip}`);
                allTrips.push([...currentTrip]); 
                currentTrip = []; 
                firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes; 
            }
        }
        
        currentTrip.push(entry);
        previousStopTimeInAbsoluteMinutes = currentStopTimeInAbsoluteMinutes;
    }

    if (currentTrip.length > 0) {
        allTrips.push([...currentTrip]);
    }
    return allTrips;
}

// Helper to format a single time object for display
function formatTimeForDisplay(timeObject) {
    // timeObject = { absMinutes, displayTime, dayOffset }
    return timeObject.displayTime; 
}

function determineCanonicalStopSequence(specificEntriesForRPD) {
    const stopData = new Map(); // stopID -> { stopID, name, earliestAbsMinutes, firstSeenOriginalIndex }

    // The specificEntriesForRPD should already be sorted chronologically 
    // by the time this function is called in handleDownloadTimetable_ExtraPage
    specificEntriesForRPD.forEach((entry, index) => {
        if (entry.stopID && entry.scheduledTime) {
            const absMinutes = getAbsMinutes(entry.scheduledTime, parseInt(entry.DayOffset || 0));
            if (absMinutes === null) return;

            if (!stopData.has(entry.stopID)) {
                stopData.set(entry.stopID, {
                    stopID: entry.stopID,
                    name: entry.stopName,
                    earliestAbsMinutes: absMinutes, // Store the time of its first actual encountered entry
                    firstSeenOriginalIndex: index  // Store the index from the master sorted list
                });
            }
            // If you wanted to update earliestAbsMinutes for a stop if it appeared later with an even earlier time
            // (which shouldn't happen if specificEntriesForRPD is perfectly sorted), you could add logic here.
            // For now, we assume the first encounter sets its primary ordering criteria.
        }
    });

    return Array.from(stopData.values()).sort((a, b) => {
        if (a.firstSeenOriginalIndex !== b.firstSeenOriginalIndex) {
            return a.firstSeenOriginalIndex - b.firstSeenOriginalIndex;
        }
        return a.earliestAbsMinutes - b.earliestAbsMinutes; // Fallback sort
    });
}

function analyzeAndSummarizeTimes(sortedTimes) { // sortedTimes is array of { absMinutes, displayTime, dayOffset }
    // Define constants used within this function
    const MAX_INITIAL_INDIVIDUAL_TIMES = 2; 
    const MIN_TIMES_FOR_PATTERN_BLOCK = 4;  
    const MIN_INTERVALS_FOR_PATTERN = MIN_TIMES_FOR_PATTERN_BLOCK - 1;

    const n = sortedTimes.length;
    if (n === 0) return "-";

    if (n < MIN_TIMES_FOR_PATTERN_BLOCK) { 
        return sortedTimes.map(t => formatTimeForDisplay(t)).join(", ");
    }

    let resultParts = [];
    let currentIndex = 0;

    while (currentIndex < n) {
        let bestRun = {
            startIdx: -1, numIntervals: 0, interval: 0, 
            startTimeObj: null, endTimeObj: null
        };

        // Determine the limit for starting a pattern search.
        // We look for a pattern starting at currentIndex, or up to MAX_INITIAL_INDIVIDUAL_TIMES beyond it.
        // Ensure we don't search beyond where a minimal pattern could form.
        let searchStartLimit = Math.min(currentIndex + MAX_INITIAL_INDIVIDUAL_TIMES, n - MIN_INTERVALS_FOR_PATTERN);
        // If currentIndex itself is already very close to the end, adjust searchStartLimit to at least allow one check from currentIndex
        if (searchStartLimit <= currentIndex && currentIndex <= n - MIN_TIMES_FOR_PATTERN_BLOCK ) { 
            searchStartLimit = currentIndex + 1; 
        }


        for (let i = currentIndex; i < searchStartLimit; i++) {
            // Ensure there are enough elements from 'i' to form at least MIN_INTERVALS_FOR_PATTERN
            if (i + MIN_INTERVALS_FOR_PATTERN >= n) break; 

            const t1Abs = sortedTimes[i].absMinutes;
            const t2Abs = sortedTimes[i + 1].absMinutes;

            if (t1Abs === null || t2Abs === null) continue;
            let currentRunInterval = t2Abs - t1Abs;

            // Ignore intervals that are non-positive or too large for typical summaries
            if (currentRunInterval <= 0 || currentRunInterval >= 90) continue; 

            let currentRunNumIntervals = 1; // We found one interval (between sortedTimes[i] and sortedTimes[i+1])
            // Now count how many more *consecutive* intervals match currentRunInterval
            for (let k = i + 1; k < n - 1; k++) { // k is the index of the start of the next interval
                const tkAbs = sortedTimes[k].absMinutes;
                const tk1Abs = sortedTimes[k + 1].absMinutes;
                if (tkAbs === null || tk1Abs === null) break; 

                if ((tk1Abs - tkAbs) === currentRunInterval) {
                    currentRunNumIntervals++;
                } else {
                    break; 
                }
            }

            if (currentRunNumIntervals >= MIN_INTERVALS_FOR_PATTERN) {
                // Found a valid run of intervals. Check if it's better than any previously found bestRun.
                if (currentRunNumIntervals > bestRun.numIntervals || 
                    (currentRunNumIntervals === bestRun.numIntervals && i < bestRun.startIdx) || 
                    bestRun.startIdx === -1) { // Prioritize longer runs, or earlier starting runs of same length
                    bestRun = {
                        startIdx: i, // Index in sortedTimes of the first time in this pattern
                        endIdx: i + currentRunNumIntervals, // Index in sortedTimes of the last time in this pattern
                        interval: currentRunInterval,
                        numIntervals: currentRunNumIntervals, // Number of matching intervals
                        startTimeObj: sortedTimes[i],
                        endTimeObj: sortedTimes[i + currentRunNumIntervals]
                    };
                }
            }
        } 

        if (bestRun.startIdx !== -1 && bestRun.startIdx >= currentIndex) { 
            // A frequency pattern was found starting at or after currentIndex.
            // 1. Add any individual times from currentIndex UP TO the start of the identified pattern block
            for (let j = currentIndex; j < bestRun.startIdx; j++) {
                resultParts.push(formatTimeForDisplay(sortedTimes[j]));
            }

            // 2. Add the actual start time of the frequency block
            const formattedRunStartTime = formatTimeForDisplay(bestRun.startTimeObj);
            resultParts.push(formattedRunStartTime);
            
            // 3. Construct the core summary phrase (without "then" and without "from [start time]")
            let summaryCorePhrase = "";
            const formattedRunEndTime = formatTimeForDisplay(bestRun.endTimeObj);

            if (bestRun.interval < 15) {
                summaryCorePhrase = `every ${bestRun.interval} mins until ${formattedRunEndTime}`;
            } else { // Interval is 15 minutes or more
                const minutesPastHourSet = new Set();
                for (let k = bestRun.startIdx; k <= bestRun.endIdx; k++) { // Iterate through times in the actual run
                    if (sortedTimes[k].displayTime.includes(':')) {
                        minutesPastHourSet.add(sortedTimes[k].displayTime.substring(3, 5));
                    }
                }
                if (minutesPastHourSet.size >= 1 && minutesPastHourSet.size <= 4 && (bestRun.interval % 5 === 0)) {
                    let numericallySortedMinutes = Array.from(minutesPastHourSet).sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
                    
                    const startMinuteOfBlock = bestRun.startTimeObj.displayTime.substring(3,5);
                    if (numericallySortedMinutes.length > 1 && numericallySortedMinutes[0] === startMinuteOfBlock) {
                        const firstMin = numericallySortedMinutes.shift(); 
                        numericallySortedMinutes.push(firstMin);      
                    }
                    const displayMinutes = numericallySortedMinutes.join(', ');                                        
                    summaryCorePhrase = `at these mins past each hour: ${displayMinutes} until ${formattedRunEndTime}`;
                } else { 
                    summaryCorePhrase = `approx. every ${bestRun.interval} mins until ${formattedRunEndTime}`;
                }
            }
            resultParts.push("then " + summaryCorePhrase); // Add "then" before the core summary
            currentIndex = bestRun.endIdx + 1; // Advance currentIndex past this summarized block
        } else { // No suitable frequency block found from currentIndex, or remaining times are too few.
            if (currentIndex < n) {
                 resultParts.push(formatTimeForDisplay(sortedTimes[currentIndex]));
                 currentIndex++;
            } else { 
                break; // End of times
            }
        }
    } 

    // Final joining logic
    if (resultParts.length === 0) return "-";
    let finalStr = resultParts[0] || "";
    for (let i = 1; i < resultParts.length; i++) {
        const prevPartStr = resultParts[i-1] || "";
        const currentPartStr = resultParts[i] || "";
        
        if (currentPartStr.startsWith("then") && !prevPartStr.startsWith("then")) {
            // Previous was a time, current is its summary: "TIME then SUMMARY"
            finalStr += " " + currentPartStr; 
        } else {
            // All other cases (summary; summary, summary; time, time; time if it's a new segment after summary)
            finalStr += "; " + currentPartStr;
        }
    }
    return finalStr || "-";
}

async function handleDownloadTimetable_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !tteRouteNameInput_el_extra || !tteStatusMessage_el_extra) {
        console.warn("Timetable Exporter: Essential UI elements missing.");
        if(tteStatusMessage_el_extra) { tteStatusMessage_el_extra.textContent = "Init error."; tteStatusMessage_el_extra.style.color = "#e74c3c"; }
        return;
    }

    const routeName = tteRouteNameInput_el_extra.value.trim() || tteRouteNameSelect_el_extra.value;
    if (!routeName) {
        tteStatusMessage_el_extra.textContent = "Please select a route.";
        tteStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    if (!currentUser_extra || typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined' || typeof window.jspdf.jsPDF.API.autoTable === 'undefined') {
        tteStatusMessage_el_extra.textContent = "Error: PDF library not ready or not logged in.";
        tteStatusMessage_el_extra.style.color = "#e74c3c";
        return;
    }

    tteStatusMessage_el_extra.textContent = `Processing PDF timetable for route: ${routeName}...`;
    tteStatusMessage_el_extra.style.color = "#3498db";

    try {
        const routeEntries = currentWorkingSchedule_extra.filter(e => e.lineName === routeName);
        if (routeEntries.length === 0) {
            tteStatusMessage_el_extra.textContent = `No schedule data found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'portrait', 
            unit: 'pt',
            format: 'a4'
        });
        let isFirstTableInPDF = true;

        const uniqueProfileDestPairs = new Map();
        routeEntries.forEach(e => {
            if (e.OperatingProfile && e.destinationName) {
                uniqueProfileDestPairs.set(`${e.OperatingProfile}|${e.destinationName}`, true);
            }
        });

        if (uniqueProfileDestPairs.size === 0) {
            tteStatusMessage_el_extra.textContent = `No operating profile/destination combinations found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }
        
        const sortedPairs = Array.from(uniqueProfileDestPairs.keys()).sort((a,b) => {
            const [profA, destA] = a.split('|');
            const [profB, destB] = b.split('|');
            const profCompare = profA.localeCompare(profB);
            if (profCompare !== 0) return profCompare;
            return destA.localeCompare(destB);
        });

        let tablesAddedToPDF = 0;

        for (const pair of sortedPairs) {
            const [opProfile, destName] = pair.split('|');
            
            const specificEntriesForRPD = routeEntries
                .filter(e => e.OperatingProfile === opProfile && e.destinationName === destName && e.scheduledTime)
                .sort((a,b) => { 
                    const absA = getAbsMinutes(a.scheduledTime, parseInt(a.DayOffset || 0));
                    const absB = getAbsMinutes(b.scheduledTime, parseInt(b.DayOffset || 0));
                    if (absA === null && absB === null) return 0;
                    if (absA === null) return 1;
                    if (absB === null) return -1;
                    return absA - absB;
                });

            if (specificEntriesForRPD.length === 0) continue;

            const canonicalStopSequence = determineCanonicalStopSequence(specificEntriesForRPD);
            if (canonicalStopSequence.length === 0) continue;

            const tableHead = [["Stop ID", "Stop Name", "Scheduled Times"]];
            const tableBody = [];

            canonicalStopSequence.forEach(stopInfo => {
                const allTimesAtThisStop = specificEntriesForRPD
                    .filter(e => e.stopID === stopInfo.stopID) 
                    .map(e => ({ 
                        absMinutes: getAbsMinutes(e.scheduledTime, parseInt(e.DayOffset || 0)),
                        displayTime: e.scheduledTime,
                        dayOffset: parseInt(e.DayOffset || 0)
                    }));
                // This map preserves the pre-sorted order of times for this stop from specificEntriesForRPD

                const serviceDetailString = analyzeAndSummarizeTimes(allTimesAtThisStop);
                
                tableBody.push([
                    stopInfo.stopID || "",
                    stopInfo.name || "",
                    serviceDetailString
                ]);
            });

            if (tableBody.length > 0) {
                if (!isFirstTableInPDF) {
                    doc.addPage('a4', 'portrait');
                }
                isFirstTableInPDF = false;

                doc.setFontSize(14);
                doc.text(`Route: ${routeName}`, 40, 40); 
                doc.setFontSize(11);
                doc.text(`Destination: ${destName}`, 40, 55); 
                doc.text(`Operating Profile: ${opProfile}`, 40, 70);

                doc.autoTable({
                    head: tableHead,
                    body: tableBody,
                    startY: 85,
                    theme: 'grid',
                    styles: { 
                        fontSize: 7, 
                        cellPadding: 2,
                        overflow: 'linebreak' 
                    }, 
                    headStyles: { 
                        fillColor: [44, 62, 80], 
                        textColor: 255, 
                        fontSize: 8,       
                        fontStyle: 'bold', 
                        halign: 'left' 
                    },
                    columnStyles: {
                        0: { cellWidth: 55, fontStyle: 'bold' }, 
                        1: { cellWidth: 130 }, 
                        2: { cellWidth: 'auto' } 
                    },
                    margin: { top: 25, right: 30, bottom: 30, left: 40 },
                });
                tablesAddedToPDF++;
            }
        }

        if (tablesAddedToPDF > 0) {
            doc.save(`${sanitizeFirebaseKey(routeName)}_Timetable_Summary.pdf`);
            tteStatusMessage_el_extra.textContent = `Summarized Timetable PDF for ${routeName} generated successfully!`;
            tteStatusMessage_el_extra.style.color = "#2ecc71";
        } else {
            tteStatusMessage_el_extra.textContent = `No valid data to generate summarized PDF for ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
        }

    } catch (error) {
        console.error("Error generating summarized PDF timetable:", error);
        tteStatusMessage_el_extra.textContent = "Error generating summarized PDF: " + error.message;
        tteStatusMessage_el_extra.style.color = "#e74c3c";
    }
}

function rsg_getSelectedOpProfilesString_ExtraPage() {
    const selectedProfiles = [];
    document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox:checked').forEach(checkbox => {
        selectedProfiles.push(checkbox.value);
    });
    // Sorts alphabetically, e.g., ["Fr", "MF", "Sa"]
    selectedProfiles.sort((a,b) => a.localeCompare(b)); 
    
    // Joins with a comma AND a space
    return selectedProfiles.join(', '); // Changed from .join(',')
}

function rsg_updateDisabledProfileCheckboxes_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));
    const currentSelectedValues = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

    allCheckboxes.forEach(cb => {
        if (cb.checked) {
            cb.disabled = false;
            if (cb.parentElement) {
                cb.parentElement.style.opacity = 1;
                cb.parentElement.style.pointerEvents = 'auto';
                const labelForCb = cb.parentElement.querySelector('label');
                if (labelForCb) labelForCb.style.cursor = 'pointer';
            }
            return;
        }

        const potentialNextRawSelection = [...currentSelectedValues, cb.value];
        const finalEffectiveSelectionAfterAutoGroup = rsg_simulateAutoGroup(potentialNextRawSelection);
        const finalEffectiveSortedString = rsg_getCanonicalProfileString(finalEffectiveSelectionAfterAutoGroup);

        let canBeEnabled = false;

        if (VALID_PROFILE_COMBINATIONS_SET.has(finalEffectiveSortedString)) {
            canBeEnabled = true;
        }

        if (!canBeEnabled) {
            const prefixToTest = finalEffectiveSortedString + ",";
            for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                if (validCombo.startsWith(prefixToTest)) {
                    canBeEnabled = true;
                    break;
                }
            }
        }

        if (currentSelectedValues.length === 0) {
             const singleProfileItselfAfterPotentialGroup = rsg_simulateAutoGroup([cb.value]);
             const singleCanonical = rsg_getCanonicalProfileString(singleProfileItselfAfterPotentialGroup);
             if (VALID_PROFILE_COMBINATIONS_SET.has(singleCanonical)) {
                 canBeEnabled = true;
             } else {
                 const prefixToTestForSingle = singleCanonical + ",";
                 for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                     if (validCombo.startsWith(prefixToTestForSingle)) {
                         canBeEnabled = true;
                         break;
                     }
                 }
             }
        }

        cb.disabled = !canBeEnabled;
        if (cb.parentElement) {
            cb.parentElement.style.opacity = !canBeEnabled ? 0.5 : 1;
            cb.parentElement.style.pointerEvents = !canBeEnabled ? 'none' : 'auto';
            const labelForCb = cb.parentElement.querySelector('label');
            if (labelForCb) {
                labelForCb.style.cursor = !canBeEnabled ? 'not-allowed' : 'pointer';
            }
        }
    });
}

function rsg_simulateAutoGroup(selectedProfilesArray) {
    let simulatedSelections = [...selectedProfilesArray]; 

    for (const group of RSG_PROFILE_GROUPS_TO_MANAGE) {
        const allIndividualsPresent = group.individuals.every(ind => simulatedSelections.includes(ind));

        if (allIndividualsPresent) {
            simulatedSelections = simulatedSelections.filter(p => !group.individuals.includes(p)); 
            if (!simulatedSelections.includes(group.groupProfile)) {
                simulatedSelections.push(group.groupProfile); 
            }
        }
    }
    return simulatedSelections;
}

function rsg_handleProfileSelectionChange_ExtraPage(event) {
    let currentSelectionsArray = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox:checked')).map(cb => cb.value);
    let selectionChangedByAutoGroup = false;

    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));

    RSG_PROFILE_GROUPS_TO_MANAGE.forEach(group => {
        const groupCheckbox = allCheckboxes.find(cb => cb.value === group.groupProfile);
        if (!groupCheckbox) return; 

        currentSelectionsArray = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);
        const allIndividualsInGroupSelected = group.individuals.every(day => currentSelectionsArray.includes(day));

        if (allIndividualsInGroupSelected) {
            if (!groupCheckbox.checked) {
                group.individuals.forEach(day => {
                    const cb = allCheckboxes.find(c => c.value === day);
                    if (cb && cb.checked) { cb.checked = false; }
                });
                groupCheckbox.checked = true;
                selectionChangedByAutoGroup = true;
            }
        } else if (groupCheckbox.checked) {
            let anIndividualWasAlsoCheckedAndUnchecked = false;
            group.individuals.forEach(day => {
                const cb = allCheckboxes.find(c => c.value === day);
                if (cb && cb.checked) {
                    cb.checked = false;
                    anIndividualWasAlsoCheckedAndUnchecked = true;
                }
            });
            if (anIndividualWasAlsoCheckedAndUnchecked) selectionChangedByAutoGroup = true;
        }
    });

    if (selectionChangedByAutoGroup) {
        currentSelectionsArray = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox:checked')).map(cb => cb.value);
    }

    currentSelectionsArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a);
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) {
            return orderA - orderB;
        }
        return a.localeCompare(b); 
    });

    const finalSelectedProfilesString = currentSelectionsArray.join(', '); 

    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }

    rsg_updateDisabledProfileCheckboxes_ExtraPage(); 

    if (event || selectionChangedByAutoGroup) {
        if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') {
             rsg_loadOrPullConfiguration_ExtraPage();
        }
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

function rsg_setCheckedProfiles_ExtraPage(profileString) {
    // Determine which profiles to select based on the input string
    const profilesToSelect = profileString ? profileString.split(',').map(p => p.trim()).filter(Boolean) : [];

    // Get all profile checkboxes
    const allProfileCheckboxes = document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox');

    // Set the checked state for each checkbox
    allProfileCheckboxes.forEach(checkbox => {
        checkbox.checked = profilesToSelect.includes(checkbox.value);
    });

    // --- MODIFICATION START ---
    // After programmatically setting checkbox states,
    // directly update the "Currently Selected & Active" display string.

    // Use the 'profilesToSelect' array as the source of truth for what should be displayed,
    // as this is what the checkboxes were just set to.
    // Create a mutable copy if further manipulation of this array specific to display is needed,
    // otherwise, direct use is fine for sorting and joining.
    const currentDisplayProfilesArray = [...profilesToSelect];

    // Sort them for consistent display order using your existing sorting logic
    currentDisplayProfilesArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a); // Ensure getDaySortOrder_ExtraPage is robust
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) {
            return orderA - orderB;
        }
        return a.localeCompare(b); // Default alphabetical sort if order is the same
    });

    // Join the sorted profiles into a string for display
    const finalSelectedProfilesString = currentDisplayProfilesArray.join(', ');

    // Get the display element
    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');

    // Update the text content of the display element
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }
    // --- MODIFICATION END ---

    // This function correctly updates which checkboxes are enabled/disabled
    // based on your incompatibility rules and the newly set checkbox states.
    // This should always be called after checkbox states are modified.
    if (typeof rsg_updateDisabledProfileCheckboxes_ExtraPage === 'function') {
        rsg_updateDisabledProfileCheckboxes_ExtraPage();
    }
}

function rsg_clearProfileSelections_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));
    let selectionActuallyChanged = false;

    allCheckboxes.forEach(cb => {
        if (cb.checked) {
            cb.checked = false;
            selectionActuallyChanged = true;
        }
    });

    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = '(None selected)';
    }

    if (typeof rsg_updateDisabledProfileCheckboxes_ExtraPage === 'function') {
        rsg_updateDisabledProfileCheckboxes_ExtraPage();
    }

    if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') {
        rsg_loadOrPullConfiguration_ExtraPage();
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_createConfigKey_ExtraPage(routeName, opProfile, destName) { if (!routeName || !opProfile || !destName) return null; const normRoute = sanitizeFirebaseKey(String(routeName).toUpperCase()); const normProfile = sanitizeFirebaseKey(String(opProfile).toUpperCase()); const normDest = sanitizeFirebaseKey(String(destName).toUpperCase()); return `${normRoute}|${normProfile}|${normDest}`; } 

        async function rsg_loadOrPullConfiguration_ExtraPage(configKeyToLoad = null, isInitialLoadForSection = false) {
    if (!rsgRouteNameInput_el_extra || !rsgDestinationNameInput_el_extra || !rsgFirstStopTimesInput_el_extra || !rsgStatusMessage_el_extra || !window.firebaseOMSI) {
        console.warn("RSG Load/Pull: Aborted - Essential DOM element or Firebase missing.");
        return;
    }

    const routeNameFromForm = rsgRouteNameInput_el_extra.value.trim();
    const opProfileFromForm = rsg_getSelectedOpProfilesString_ExtraPage();
    const destNameFromForm = rsgDestinationNameInput_el_extra.value.trim();

    if (configKeyToLoad) {
        const configData = rsg_loadedConfigs_extra[configKeyToLoad];
        if (configData) {
            rsgRouteNameInput_el_extra.value = configData.routeName || "";
            rsgDestinationNameInput_el_extra.value = configData.destinationName || "";
            rsg_setCheckedProfiles_ExtraPage(configData.operatingProfile || "");
            
            rsg_selectedStops_extra = JSON.parse(JSON.stringify(configData.stopSequence || []));
            if (rsgFirstStopTimesInput_el_extra) {
                rsgFirstStopTimesInput_el_extra.value = configData.firstStopTimes || '';
            }

            rsg_currentlyEditingConfigKey_extra = configKeyToLoad;
            rsg_currentlyEditingConfigDisplayName_extra = configData.userDisplayName || configKeyToLoad;
            rsg_lastLoadedRouteName_extra = configData.routeName || "";
            rsg_lastLoadedDestName_extra = configData.destinationName || "";
            rsg_lastLoadedOpProfile_extra = configData.operatingProfile || "";
            rsg_isDirty = false;

            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Loaded saved configuration: "${rsg_currentlyEditingConfigDisplayName_extra}".`;
                rsgStatusMessage_el_extra.style.color = "#2ecc71";
            }
            rsg_renderStopSequence_ExtraPage();
            if (typeof rsg_resetPreviewState === 'function') {
                 rsg_resetPreviewState("Configuration loaded. Generate preview if desired.", "success");
            }
        } else {
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Error: Could not find data for saved configuration key "${configKeyToLoad}". Current sequence retained.`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            rsg_currentlyEditingConfigKey_extra = null;
            rsg_currentlyEditingConfigDisplayName_extra = null;
            rsg_isDirty = true; 
            rsg_renderStopSequence_ExtraPage();
             if (typeof rsg_resetPreviewState === 'function') {
                rsg_resetPreviewState("Failed to load saved configuration. Review inputs or continue with current setup.", "error");
            }
        }
    } else { 
        let identityHasChangedBasedOnFormInputs =
            (routeNameFromForm.toUpperCase() !== (rsg_lastLoadedRouteName_extra || "").toUpperCase()) ||
            (destNameFromForm !== (rsg_lastLoadedDestName_extra || "")) ||
            (opProfileFromForm !== (rsg_lastLoadedOpProfile_extra || ""));

        if (identityHasChangedBasedOnFormInputs || rsg_currentlyEditingConfigKey_extra) {
            if ( (rsg_currentlyEditingConfigKey_extra && identityHasChangedBasedOnFormInputs) ||
                 (!rsg_currentlyEditingConfigKey_extra && identityHasChangedBasedOnFormInputs && (rsg_lastLoadedRouteName_extra || rsg_lastLoadedDestName_extra || rsg_lastLoadedOpProfile_extra))
               ) {
                 if (rsgStatusMessage_el_extra && !isInitialLoadForSection) { 
                    rsgStatusMessage_el_extra.textContent = "Route/Destination/Profile parameters changed. Current stop sequence retained for new/modified setup.";
                    rsgStatusMessage_el_extra.style.color = "#f1c40f";
                 }
            }
            rsg_currentlyEditingConfigKey_extra = null; 
            rsg_currentlyEditingConfigDisplayName_extra = null;
            if (!isInitialLoadForSection && identityHasChangedBasedOnFormInputs) { 
                rsg_isDirty = true; 
                console.log("RSG dirty: Route/Dest/Profile params changed from last loaded state.");
            }
        }

        rsg_lastLoadedRouteName_extra = routeNameFromForm;
        rsg_lastLoadedDestName_extra = destNameFromForm;
        rsg_lastLoadedOpProfile_extra = opProfileFromForm; 
        
        rsg_renderStopSequence_ExtraPage(); 
        
        if (!isInitialLoadForSection) {
            if (typeof rsg_resetPreviewState === 'function') {
                rsg_resetPreviewState("Parameters changed. Current stop sequence retained. Regenerate preview if needed.", "info");
            }
        } else if (rsg_selectedStops_extra.length === 0 && rsgFirstStopTimesInput_el_extra && rsgFirstStopTimesInput_el_extra.value === '') {
            if (typeof rsg_resetPreviewState === 'function') {
                rsg_resetPreviewState("Build a sequence or load a saved configuration.", "info");
            }
        }
    }
}

        function rsg_handleSaveConfiguration_ExtraPage() {
    if (!currentUser_extra) {
        alert("Please log in to save configurations.");
        return;
    }
    // Basic check: ensure essential fields for naming are present before opening modal
    const routeName = rsgRouteNameInput_el_extra.value.trim();
    const destName = rsgDestinationNameInput_el_extra.value.trim();
    const opProfiles = rsg_getSelectedOpProfilesString_ExtraPage();

    if (!routeName || !destName || !opProfiles) {
         if(rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route, Destination, and Operating Profile(s) must be selected to save.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    if (rsg_selectedStops_extra.length === 0 || !rsgFirstStopTimesInput_el_extra.value.trim()) {
         if(rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Stop Sequence and First Stop Times are required to save.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    rsg_showSaveConfigModal_ExtraPage();
}

        function rsg_populateRouteSelect_ExtraPage() { 
            if (!rsgRouteNameSelect_el_extra || !rsgRouteNameInput_el_extra) return; const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))].filter(Boolean).sort(compareLineNames_ExtraPage); const currentInputValue = rsgRouteNameInput_el_extra.value.trim(); rsgRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Existing Route --</option>'; uniqueRoutes.forEach(route => { const opt = document.createElement('option'); opt.value = route; opt.textContent = route; rsgRouteNameSelect_el_extra.appendChild(opt); }); const matchedRoute = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase()); if (matchedRoute) rsgRouteNameSelect_el_extra.value = matchedRoute; else if (currentInputValue) rsgRouteNameSelect_el_extra.value = ""; rsg_populateDestinationSelect_ExtraPage();
        }

        function rsg_handleRouteNameInputChange_ExtraPage() {
    if (!rsgRouteNameInput_el_extra || !rsgRouteNameSelect_el_extra) return;

    const typedRouteValue = rsgRouteNameInput_el_extra.value.trim();
    const typedRouteUpper = typedRouteValue.toUpperCase();

    if (rsg_lastLoadedRouteName_extra && typedRouteUpper !== rsg_lastLoadedRouteName_extra.toUpperCase()) {
        rsg_currentlyEditingConfigKey_extra = null;
        rsg_currentlyEditingConfigDisplayName_extra = null;
    }

    const matchedOption = Array.from(rsgRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper);

    if (matchedOption) {
        rsgRouteNameSelect_el_extra.value = matchedOption.value;
        if (rsgRouteNameInput_el_extra.value !== matchedOption.value) {
            rsgRouteNameInput_el_extra.value = matchedOption.value;
        }
    } else {
        rsgRouteNameSelect_el_extra.value = ""; 
    }

    rsg_populateDestinationSelect_ExtraPage(); 
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_handleRouteNameSelectChange_ExtraPage() { 
    if (!rsgRouteNameSelect_el_extra || !rsgRouteNameInput_el_extra) return; 
    rsgRouteNameInput_el_extra.value = rsgRouteNameSelect_el_extra.value; 
    rsg_populateDestinationSelect_ExtraPage();
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_populateDestinationSelect_ExtraPage() { 
            if (!rsgDestinationNameSelect_el_extra || !rsgDestinationNameInput_el_extra || !rsgRouteNameInput_el_extra) return; const selectedRoute = rsgRouteNameInput_el_extra.value.trim().toUpperCase(); const currentDestInputValue = rsgDestinationNameInput_el_extra.value.trim(); rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- Select Existing Destination --</option>'; if (!selectedRoute) { rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- Select Route First --</option>'; return; } const uniqueDestinations = [...new Set( currentWorkingSchedule_extra.filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName).map(e => e.destinationName) )].sort(); uniqueDestinations.forEach(dest => { const opt = document.createElement('option'); opt.value = dest; opt.textContent = dest; rsgDestinationNameSelect_el_extra.appendChild(opt); }); const matchedDest = uniqueDestinations.find(d => d === currentDestInputValue); if (matchedDest) rsgDestinationNameSelect_el_extra.value = matchedDest; else if (uniqueDestinations.length === 0 && selectedRoute) rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- No Destinations for Route --</option>'; else rsgDestinationNameSelect_el_extra.value = "";
        }

        function rsg_handleDestinationNameInputChange_ExtraPage() { 
    if (!rsgDestinationNameInput_el_extra || !rsgDestinationNameSelect_el_extra) return; 
    const typedDest = rsgDestinationNameInput_el_extra.value.trim(); 
    const matchedOption = Array.from(rsgDestinationNameSelect_el_extra.options).find(opt => opt.value === typedDest); 
    if (matchedOption) { 
        rsgDestinationNameSelect_el_extra.value = matchedOption.value; 
        if (rsgDestinationNameInput_el_extra.value !== matchedOption.value) rsgDestinationNameInput_el_extra.value = matchedOption.value; 
    } else {
        rsgDestinationNameSelect_el_extra.value = ""; 
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_handleDestinationNameSelectChange_ExtraPage() { 
    if (!rsgDestinationNameSelect_el_extra || !rsgDestinationNameInput_el_extra) return; 
    rsgDestinationNameInput_el_extra.value = rsgDestinationNameSelect_el_extra.value;
    rsg_updateRsgActionButtonsState(); // Added call
}

        // ++ RSG Helper Function to create 'Copy Time Adjustment' buttons (sorted) ++
        function rsg_createCopyAdjustmentButtons_ExtraPage(currentStopInSequence, stopIndexInCurrentSequence, buttonsContainer) {
            if (!currentStopInSequence || !buttonsContainer || !rsg_loadedConfigs_extra || typeof rsg_loadedConfigs_extra !== 'object') {
                return;
            }

            buttonsContainer.innerHTML = ''; // Clear any existing buttons or placeholder text

            const currentRsgRouteName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
            const targetStopID = currentStopInSequence.stopID;
            
            const potentialButtonsData = [];
            const addedButtonSignatures = new Set(); // To track added "RouteName|Adjustment" for uniqueness

            for (const configKey in rsg_loadedConfigs_extra) {
                const sourceConfig = rsg_loadedConfigs_extra[configKey];

                if (!sourceConfig.routeName || sourceConfig.routeName.toUpperCase() === currentRsgRouteName || !Array.isArray(sourceConfig.stopSequence)) {
                    continue;
                }

                let sourceStopData = null;
                let sourceStopIndexInItsConfig = -1;

                for (let i = 0; i < sourceConfig.stopSequence.length; i++) {
                    if (sourceConfig.stopSequence[i].stopID === targetStopID) {
                        sourceStopData = sourceConfig.stopSequence[i];
                        sourceStopIndexInItsConfig = i;
                        break; 
                    }
                }

                if (sourceStopData && sourceStopIndexInItsConfig > 0) { // Must exist and not be the first stop in its own sequence
                    const timeAdjustmentToCopy = sourceConfig.stopSequence[sourceStopIndexInItsConfig].timeAdjustment;

                    if (typeof timeAdjustmentToCopy === 'number') {
                        const buttonSignature = `${sourceConfig.routeName}|${timeAdjustmentToCopy}`;

                        if (!addedButtonSignatures.has(buttonSignature)) {
                            potentialButtonsData.push({
                                routeName: sourceConfig.routeName,
                                timeAdjustment: timeAdjustmentToCopy,
                                operatingProfile: sourceConfig.operatingProfile || 'N/A',
                                destinationName: sourceConfig.destinationName || 'N/A'
                            });
                            addedButtonSignatures.add(buttonSignature);
                        }
                    }
                }
            }

            if (potentialButtonsData.length > 0) {
                // Sort the collected button data by routeName
                potentialButtonsData.sort((a, b) => compareLineNames_ExtraPage(a.routeName, b.routeName));

                // Now create and append buttons in sorted order
                potentialButtonsData.forEach(data => {
                    const button = document.createElement('button');
                    button.classList.add('button', 'small-action', 'neutral', 'copy-adj-button');
                    button.textContent = `Copy From ${data.routeName} (+${data.timeAdjustment} min)`;
                    button.title = `Copy ${data.timeAdjustment} min from ${data.routeName} (Profile: ${data.operatingProfile}, Dest: ${data.destinationName})`;

                    button.addEventListener('click', () => {
                        rsg_selectedStops_extra[stopIndexInCurrentSequence].timeAdjustment = data.timeAdjustment;
                        const listItem = rsgStopSequenceList_el_extra.querySelector(`li[data-index="${stopIndexInCurrentSequence}"]`);
                        if (listItem) {
                            const timeAdjInput = listItem.querySelector('.rsg-time-adjustment-input');
                            if (timeAdjInput) {
                                timeAdjInput.value = data.timeAdjustment;
                            }
                        }
                        rsg_resetPreviewState(`Time adjustment (${data.timeAdjustment} min) copied from Route ${data.routeName}. Regenerate preview.`, "info");
                    });
                    buttonsContainer.appendChild(button);
                });
            } else {
                 buttonsContainer.innerHTML = `<span style="font-size:0.75em; opacity:0.7; display:block; margin-top:0.3rem; width:100%;">No other routes serve this stop to copy adjustment from.</span>`;
            }
        }

        // In omsi_tools_extra.html

function rsg_renderStopSequence_ExtraPage() {
    if (!rsgStopSequenceList_el_extra || !rsgStopSequencePlaceholder_el_extra || !rsgFirstStopTimesContainer_el_extra) {
        console.error("RSG Render: Critical elements missing.");
        return;
    }
    
    console.log(`RSG Render: Starting. Stop count: ${rsg_selectedStops_extra.length}. Dirty: ${rsg_isDirty}.`);

    rsgStopSequenceList_el_extra.innerHTML = ''; 

    if (rsg_selectedStops_extra.length === 0) {
        rsgStopSequencePlaceholder_el_extra.style.display = 'block';
        rsgFirstStopTimesContainer_el_extra.style.display = 'none';
        console.log("RSG Render: No stops to render, showing placeholder.");
    } else {
        rsgStopSequencePlaceholder_el_extra.style.display = 'none';
        rsgFirstStopTimesContainer_el_extra.style.display = 'block';

        rsg_selectedStops_extra.forEach((stop, loopIndex) => {
            console.log(`RSG Render: LOOP START for index ${loopIndex}, stopID: ${stop.stopID}`);

            const li = document.createElement('li');
            li.dataset.index = loopIndex;
            li.draggable = true;

            const mainContentDiv = document.createElement('div');
            mainContentDiv.classList.add('rsg-li-main-content');

            const stopInfoDiv = document.createElement('div');
            stopInfoDiv.classList.add('rsg-stop-info');
            stopInfoDiv.innerHTML = `<span class="rsg-stop-name">${stop.stopName}</span> <span class="rsg-stop-id">(${stop.stopID})</span>`;
            if (stop.direction) stopInfoDiv.innerHTML += `<br><small style="opacity:0.7;">Towards: ${stop.direction}</small>`;

            const actionsDiv = document.createElement('div');
            actionsDiv.classList.add('rsg-stop-actions');

            let timeAdjInput = null;

            // --- Define renderOrUpdateWarningIcon at the start of the loop iteration ---
            // It will be in scope for all subsequent conditional blocks within this iteration.
            const renderOrUpdateWarningIcon = (currentIndex, currentStopData, inputElement, parentActionsDiv) => {
                if (!inputElement || !parentActionsDiv) {
                    // This guard is important if this function were to be called when inputElement is null (e.g. for first stop)
                    // However, our calls to it are always within loopIndex > 0 context.
                    console.warn("renderOrUpdateWarningIcon called with invalid inputElement or parentActionsDiv for index:", currentIndex);
                    return;
                }
                const existingWarning = parentActionsDiv.querySelector('.rsg-time-adj-warning');
                if (existingWarning) {
                    existingWarning.remove();
                }

                const otherAdjustmentsInfo = rsg_getOtherRouteAdjustmentsForStop(currentStopData.stopID, rsg_currentlyEditingConfigKey_extra);
                // Use rsg_selectedStops_extra to get the most up-to-date adjustment value for comparison
                const currentStopActualAdjustment = (typeof rsg_selectedStops_extra[currentIndex]?.timeAdjustment === 'number' && !isNaN(rsg_selectedStops_extra[currentIndex].timeAdjustment))
                    ? rsg_selectedStops_extra[currentIndex].timeAdjustment
                    : 0;

                if (otherAdjustmentsInfo.mostCommonValue !== null &&
                    currentStopActualAdjustment !== otherAdjustmentsInfo.mostCommonValue) {

                    const warningIcon = document.createElement('span');
                    warningIcon.className = 'rsg-time-adj-warning';
                    warningIcon.textContent = ' âš ï¸';
                    warningIcon.style.cursor = 'pointer';
                    warningIcon.style.color = '#f39c12';
                    warningIcon.style.fontSize = '1.1em';
                    warningIcon.style.marginLeft = '5px';
                    warningIcon.title = otherAdjustmentsInfo.suggestionTitle || `Commonly +${otherAdjustmentsInfo.mostCommonValue} min. Click to apply.`;

                    warningIcon.addEventListener('click', () => {
                        const targetAdjustment = otherAdjustmentsInfo.mostCommonValue;
                        if (targetAdjustment !== null) {
                            rsg_selectedStops_extra[currentIndex].timeAdjustment = targetAdjustment;
                            if (inputElement) inputElement.value = targetAdjustment;
                            warningIcon.remove(); 
                            rsg_isDirty = true;
                            if (rsgStatusMessage_el_extra) {
                                rsgStatusMessage_el_extra.textContent = `Time adjustment for '${currentStopData.stopName}' changed to +${targetAdjustment} min. Regenerate preview.`;
                                rsgStatusMessage_el_extra.style.color = '#2ecc71';
                            }
                            rsg_resetPreviewState("Time adjustment updated. Regenerate preview.", "info");
                        }
                    });
                    const removeBtnInActions = parentActionsDiv.querySelector('button.secondary');
                    if (removeBtnInActions) {
                        parentActionsDiv.insertBefore(warningIcon, removeBtnInActions);
                    } else {
                        parentActionsDiv.appendChild(warningIcon);
                    }
                }
            };
            // --- End of renderOrUpdateWarningIcon definition for this iteration ---

            if (loopIndex > 0) {
                timeAdjInput = document.createElement('input');
                timeAdjInput.type = 'number';
                timeAdjInput.classList.add('schedule-generator-input', 'rsg-time-adjustment-input');
                timeAdjInput.min = '0';
                timeAdjInput.title = 'Minutes from previous stop';
                timeAdjInput.value = (typeof stop.timeAdjustment === 'number' && !isNaN(stop.timeAdjustment)) ? stop.timeAdjustment : 0;
                
                actionsDiv.appendChild(timeAdjInput); // Add input first

                // Initial call to render/update its warning icon
                renderOrUpdateWarningIcon(loopIndex, stop, timeAdjInput, actionsDiv);

                // Event listener for dynamic updates on this input
                timeAdjInput.addEventListener('input', () => { 
                    rsg_isDirty = true;
                    const currentLiElement = timeAdjInput.closest('li');
                    const changedIndex = parseInt(currentLiElement.dataset.index);
                    const stopDataForListener = rsg_selectedStops_extra[changedIndex];
                    
                    let newValueFromInput = parseInt(timeAdjInput.value, 10);

                    if (rsg_selectedStops_extra[changedIndex]) {
                        if (!isNaN(newValueFromInput) && newValueFromInput >= 0) {
                            rsg_selectedStops_extra[changedIndex].timeAdjustment = newValueFromInput;
                        } else { 
                            rsg_selectedStops_extra[changedIndex].timeAdjustment = 0;
                            if (isNaN(newValueFromInput) || newValueFromInput < 0) timeAdjInput.value = 0; 
                        }
                    }
                    if (stopDataForListener) { // Ensure data is valid before updating warning
                         renderOrUpdateWarningIcon(changedIndex, stopDataForListener, timeAdjInput, actionsDiv);
                    }
                });
            } 

            const removeButton = document.createElement('button');
            removeButton.textContent = 'âœ•';
            removeButton.classList.add('button', 'small-action', 'secondary');
            removeButton.title = 'Remove Stop';
            removeButton.addEventListener('click', () => rsg_removeStopFromSequence_ExtraPage(parseInt(li.dataset.index)));
            actionsDiv.appendChild(removeButton);

            mainContentDiv.appendChild(stopInfoDiv);
            mainContentDiv.appendChild(actionsDiv);
            li.appendChild(mainContentDiv);

            if (loopIndex > 0) {
                const copyButtonsContainer = document.createElement('div');
                copyButtonsContainer.classList.add('rsg-copy-adjustment-buttons-container');
                // 'renderOrUpdateWarningIcon' is now in scope for this entire iteration
                rsg_createCopyAdjustmentButtons_ExtraPage(stop, loopIndex, copyButtonsContainer, timeAdjInput, actionsDiv, renderOrUpdateWarningIcon);
                li.appendChild(copyButtonsContainer);
            }
            
            console.log(`RSG Render: PRE-APPEND for index ${loopIndex}, stopID: ${stop.stopID}`);
            rsgStopSequenceList_el_extra.appendChild(li);
            console.log(`RSG Render: POST-APPEND for index ${loopIndex}, stopID: ${stop.stopID}`);

            li.addEventListener('dragstart', rsg_handleDragStart_ExtraPage);
            li.addEventListener('dragover', rsg_handleDragOver_ExtraPage);
            li.addEventListener('dragleave', rsg_handleDragLeave_ExtraPage);
            li.addEventListener('drop', rsg_handleDrop_ExtraPage);
            li.addEventListener('dragend', rsg_handleDragEnd_ExtraPage);
        });
        console.log("RSG Render: Loop finished.");
    }
}

        function rsg_handleDragStart_ExtraPage(event) {  
            rsg_draggedItemIndex_extra = parseInt(event.target.closest('li').dataset.index); event.dataTransfer.effectAllowed = 'move'; event.dataTransfer.setData('text/plain', rsg_draggedItemIndex_extra); setTimeout(() => { event.target.closest('li').classList.add('rsg-dragging-item'); }, 0); if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = "Dragging stop..."; rsgStatusMessage_el_extra.style.color = "#3498db"; }
        }

        function rsg_handleDragOver_ExtraPage(event) { 
            event.preventDefault(); event.dataTransfer.dropEffect = 'move'; const targetLi = event.target.closest('li'); if (targetLi && parseInt(targetLi.dataset.index) !== rsg_draggedItemIndex_extra) { Array.from(rsgStopSequenceList_el_extra.children).forEach(child => child.classList.remove('rsg-dragover-target')); targetLi.classList.add('rsg-dragover-target'); }
        }

        function rsg_handleDragLeave_ExtraPage(event) { 
            const targetLi = event.target.closest('li'); if (targetLi) { targetLi.classList.remove('rsg-dragover-target');}
        }

        function rsg_handleDrop_ExtraPage(event) { 
    event.preventDefault(); 
    const targetLi = event.target.closest('li'); 
    if (!targetLi) return; 
    const droppedOnItemIndex = parseInt(targetLi.dataset.index); 
    Array.from(rsgStopSequenceList_el_extra.children).forEach(child => child.classList.remove('rsg-dragover-target')); 
    if (rsg_draggedItemIndex_extra !== null && rsg_draggedItemIndex_extra !== droppedOnItemIndex) { 
        const itemToMove = rsg_selectedStops_extra.splice(rsg_draggedItemIndex_extra, 1)[0]; 
        rsg_selectedStops_extra.splice(droppedOnItemIndex, 0, itemToMove); 
        rsg_renderStopSequence_ExtraPage(); 
        rsg_resetPreviewState("Stop order changed. Regenerate preview.", "info"); 
        rsg_isDirty = true;
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_handleDragEnd_ExtraPage(event) { 
             Array.from(rsgStopSequenceList_el_extra.children).forEach(childLi => { childLi.classList.remove('rsg-dragging-item'); childLi.classList.remove('rsg-dragover-target'); }); rsg_draggedItemIndex_extra = null;
        }

        function rsg_handleStopSearch_ExtraPage(event) { 
            if (!rsgStopSearchInput_el_extra || !rsgStopSearchResults_el_extra) return; const searchTerm = rsgStopSearchInput_el_extra.value.toLowerCase(); rsgStopSearchResults_el_extra.innerHTML = ''; if (searchTerm.length < 2) { return; } const uniqueStops = getUniqueStopsFromSchedule_ExtraPage(); const filteredStops = uniqueStops.filter(stop => stop.stopName.toLowerCase().includes(searchTerm) || stop.stopID.toLowerCase().includes(searchTerm)).slice(0, 10); if (filteredStops.length > 0) { filteredStops.forEach(stop => { const itemDiv = document.createElement('div'); itemDiv.classList.add('rsg-search-result-item'); let content = `<span class="rsg-search-stop-name">${stop.stopName} (${stop.stopID})</span>`; content += `<span class="rsg-search-stop-details">Towards: ${stop.direction || 'N/A'}</span>`; const servingRoutes = new Set(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === stop.stopID && entry.lineName && entry.lineName !== "INFO_ONLY") { servingRoutes.add(entry.lineName); } }); if (servingRoutes.size > 0) { content += `<div class="rsg-search-serving-routes">`; Array.from(servingRoutes).sort(compareLineNames_ExtraPage).slice(0, 5).forEach(line => { const bgColor = getRouteTileColour_ExtraPage(line, stop.stopID); const textColor = getTextColourForBackground_ExtraPage(bgColor); content += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor};font-size:0.7em;padding:0.1em 0.3em;">${line}</span>`; }); if (servingRoutes.size > 5) content += `<span style="font-size:0.7em;opacity:0.8;"> +${servingRoutes.size - 5} more</span>`; content += `</div>`; } itemDiv.innerHTML = content; itemDiv.addEventListener('click', () => { rsg_addStopToSequence_ExtraPage(stop.stopID, stop.stopName, stop.direction); rsgStopSearchInput_el_extra.value = ''; rsgStopSearchResults_el_extra.innerHTML = ''; rsgStopSearchInput_el_extra.focus(); }); rsgStopSearchResults_el_extra.appendChild(itemDiv); }); } else { rsgStopSearchResults_el_extra.innerHTML = '<div class="rsg-search-result-item">No stops found.</div>'; }
        }

        function rsg_addStopToSequence_ExtraPage(stopID, stopName, direction) { 
    if (rsg_selectedStops_extra.length > 0 && rsg_selectedStops_extra[rsg_selectedStops_extra.length -1].stopID === stopID) { 
        if(rsgStatusMessage_el_extra) { 
            rsgStatusMessage_el_extra.textContent = "Stop already last in sequence."; 
            rsgStatusMessage_el_extra.style.color = "#f1c40f"; 
        } 
        return; 
    } 
    rsg_selectedStops_extra.push({ 
        stopID: stopID, 
        stopName: stopName, 
        direction: direction, 
        timeAdjustment: rsg_selectedStops_extra.length > 0 ? 2 : 0 
    }); 
    rsg_renderStopSequence_ExtraPage(); 
    rsg_resetPreviewState("Stop added. Regenerate preview if needed.", "info"); 
    rsg_isDirty = true;
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_removeStopFromSequence_ExtraPage(index) {
    if (rsg_selectedStops_extra && rsg_selectedStops_extra.length > index) {
        rsg_selectedStops_extra.splice(index, 1);
    }
    rsg_isDirty = true;
    rsg_renderStopSequence_ExtraPage();
    rsg_resetPreviewState("Stop removed. Regenerate preview if needed.", "info");
    rsg_updateRsgActionButtonsState(); // Added call
}

        function rsg_handleGenerateSchedulePreview_ExtraPage(isPreCheck = false, configDataToProcess = null) {
    if (!rsgRouteNameInput_el_extra ||
        !rsgDestinationNameInput_el_extra ||
        !rsgFirstStopTimesInput_el_extra ||
        !rsgStatusMessage_el_extra) {
        if (!isPreCheck && rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Critical Error: RSG form components missing.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }

    let routeName, opProfileForGeneration, destName, firstStopTimesStr, currentStopSequence;

    if (configDataToProcess) {
        routeName = (configDataToProcess.routeName || "").trim().toUpperCase();
        opProfileForGeneration = configDataToProcess.operatingProfile || "";
        destName = (configDataToProcess.destinationName || "").trim();
        firstStopTimesStr = (configDataToProcess.firstStopTimes || "").trim();
        currentStopSequence = configDataToProcess.stopSequence || [];
    } else {
        routeName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
        opProfileForGeneration = rsg_getSelectedOpProfilesString_ExtraPage();
        destName = rsgDestinationNameInput_el_extra.value.trim();
        firstStopTimesStr = rsgFirstStopTimesInput_el_extra.value.trim();
        currentStopSequence = rsg_selectedStops_extra;
    }

    if (!routeName) {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "Route Name is required.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
    if (!opProfileForGeneration && !configDataToProcess) {
        if (rsg_lastLoadedOpProfile_extra &&
            routeName.toUpperCase() === (rsg_lastLoadedRouteName_extra || "").toUpperCase() &&
            destName === (rsg_lastLoadedDestName_extra || "")) {
            opProfileForGeneration = rsg_lastLoadedOpProfile_extra;
            if (!isPreCheck && rsgStatusMessage_el_extra && !configDataToProcess) {
                rsgStatusMessage_el_extra.dataset.profileAssumed = 'true';
            }
        } else {
            if (!isPreCheck && !configDataToProcess) {
                rsgStatusMessage_el_extra.textContent = "Operating Profile is required.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            return false;
        }
    } else if (!opProfileForGeneration && configDataToProcess) {
        if (!isPreCheck && rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error: Saved configuration for route ${routeName} is missing an operating profile.`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }

    if (!destName) {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "Destination Name is required.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
    if (!currentStopSequence || currentStopSequence.length === 0) {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "Please add at least one stop to the sequence.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }

    const firstStopTimes = firstStopTimesStr.split(/\t|,|;/).map(t => t.trim()).filter(t => t.match(/^\d{2}:\d{2}$/));
    if (firstStopTimes.length === 0 && firstStopTimesStr !== "") {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "Invalid format or no valid times for first stop (HH:MM, TAB/comma/semicolon separated).";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
     if (firstStopTimes.length === 0 && firstStopTimesStr === "") {
        if (!isPreCheck && !configDataToProcess) {
            rsgStatusMessage_el_extra.textContent = "First stop times are required.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }

    rsg_generatedPreviewEntries_extra = [];

    firstStopTimes.forEach(startTimeHHMM => {
        const startParts = startTimeHHMM.split(':');
        let currentMinutesFromMidnight = parseInt(startParts[0], 10) * 60 + parseInt(startParts[1], 10);
        let currentDayOffset = 0;

        currentStopSequence.forEach((stop, index) => {
            if (!stop || typeof stop.stopID === 'undefined') return;
            if (index > 0) {
                const adjustment = (typeof stop.timeAdjustment === 'number' && !isNaN(stop.timeAdjustment)) ? stop.timeAdjustment : 0;
                currentMinutesFromMidnight += adjustment;
            }
            while (currentMinutesFromMidnight >= 1440) {
                currentMinutesFromMidnight -= 1440; currentDayOffset++;
            }
            while (currentMinutesFromMidnight < 0) {
                currentMinutesFromMidnight += 1440; currentDayOffset--;
            }
            const hours = Math.floor(currentMinutesFromMidnight / 60);
            const minutes = currentMinutesFromMidnight % 60;
            const scheduledTimeOutput = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            
            rsg_generatedPreviewEntries_extra.push({
                internalId: `${stop.stopID}_${routeName}_${scheduledTimeOutput.replace(':', '')}_${opProfileForGeneration.replace(/[^a-zA-Z0-9]/g, '')}_rsg${Date.now()}${index}`,
                stopID: stop.stopID, stopName: stop.stopName, direction: stop.direction,
                lineName: routeName, destinationName: destName, scheduledTime: scheduledTimeOutput,
                OperatingProfile: opProfileForGeneration, DayOffset: String(currentDayOffset)
            });
        });
    });

    if (!isPreCheck && !configDataToProcess) {
        rsg_renderPreviewTable_ExtraPage();

        if (rsgAddToWorkingScheduleButton_el_extra) {
            const canAdd = rsg_generatedPreviewEntries_extra.length > 0;
            rsgAddToWorkingScheduleButton_el_extra.disabled = !canAdd;
            if (canAdd) {
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.add('save');
            } else {
                rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
            }
        }

        if (rsgSchedulePreviewContainer_el_extra) {
            rsgSchedulePreviewContainer_el_extra.style.display = rsg_generatedPreviewEntries_extra.length > 0 ? 'block' : 'none';
        }

        let statusMsg = "";
        let statusColor = "";
        if (rsgStatusMessage_el_extra.dataset.profileAssumed === 'true') {
             statusMsg = `Preview with assumed profile '${opProfileForGeneration}' `;
             statusMsg += rsg_generatedPreviewEntries_extra.length > 0 ? `generated ${rsg_generatedPreviewEntries_extra.length} entries.` : `generated 0 entries. Check inputs.`;
             statusColor = rsg_generatedPreviewEntries_extra.length > 0 ? '#2ecc71' : '#f1c40f';
             statusMsg += " Save will require explicit profile selection if assumption is not desired.";
        } else {
            statusMsg = rsg_generatedPreviewEntries_extra.length > 0 ? `Preview generated for ${rsg_generatedPreviewEntries_extra.length} entries.` : `Preview generated 0 entries. Check inputs.`;
            statusColor = rsg_generatedPreviewEntries_extra.length > 0 ? '#2ecc71' : '#f1c40f';
        }
        rsgStatusMessage_el_extra.textContent = statusMsg;
        rsgStatusMessage_el_extra.style.color = statusColor;
        delete rsgStatusMessage_el_extra.dataset.profileAssumed;
        rsg_updateRsgActionButtonsState(); // Added call
    }
    return rsg_generatedPreviewEntries_extra.length > 0;
}

        function rsg_renderPreviewTable_ExtraPage() { 
            if (!rsgPreviewTableBody_el_extra || !rsgSchedulePreviewContainer_el_extra) return; rsgPreviewTableBody_el_extra.innerHTML = ''; if (rsg_generatedPreviewEntries_extra.length === 0) { return; } rsg_generatedPreviewEntries_extra.forEach(entry => { const row = rsgPreviewTableBody_el_extra.insertRow(); row.insertCell().textContent = entry.stopID; row.insertCell().textContent = entry.stopName; row.insertCell().textContent = entry.scheduledTime; row.insertCell().textContent = entry.lineName; row.insertCell().textContent = entry.destinationName; row.insertCell().textContent = entry.OperatingProfile; row.insertCell().textContent = entry.DayOffset; });
        }
        
        function rsg_resetPreviewState(message = "Configuration changed. Please (re)generate preview or add short workings.", messageType = "info") {
    rsg_generatedPreviewEntries_extra = [];

    if(rsgPreviewTableBody_el_extra) {
        rsgPreviewTableBody_el_extra.innerHTML = '';
    }
    if(rsgSchedulePreviewContainer_el_extra) {
        rsgSchedulePreviewContainer_el_extra.style.display = 'none';
    }

    if(rsgAddToWorkingScheduleButton_el_extra) {
        rsgAddToWorkingScheduleButton_el_extra.disabled = true;
        rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
        rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
    }

    if(rsgStatusMessage_el_extra) {
        const isCurrentMessageError = rsgStatusMessage_el_extra.style.color === 'rgb(231, 76, 60)' || rsgStatusMessage_el_extra.style.color === '#e74c3c';
        if (!isCurrentMessageError || messageType !== "info" ) {
            rsgStatusMessage_el_extra.textContent = message;
            if (messageType === "info") {
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            } else if (messageType === "success") {
                rsgStatusMessage_el_extra.style.color = "#2ecc71";
            } else if (messageType === "error") {
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            } else {
                rsgStatusMessage_el_extra.style.color = "";
            }
        }
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

async function rsg_handleAddGeneratedToWorkingSchedule_ExtraPage() {
    if (!currentUser_extra) {
        alert("Please log in to modify the working schedule.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Not logged in.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    if (!rsg_generatedPreviewEntries_extra || rsg_generatedPreviewEntries_extra.length === 0) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "No schedule entries generated in the preview to add.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    // Get target details from RSG form inputs
    const targetRouteName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
    let targetOpProfile = rsg_getSelectedOpProfilesString_ExtraPage(); // From checkboxes
    const targetDestName = rsgDestinationNameInput_el_extra.value.trim();

    const previewSample = rsg_generatedPreviewEntries_extra[0]; // Assuming preview is not empty here

    // If checkboxes were empty, but preview was generated (e.g. from a loaded config or assumed profile),
    // use the profile from the preview sample for consistency in the confirmation and subsequent operations.
    if (!targetOpProfile && previewSample && previewSample.OperatingProfile) {
        targetOpProfile = previewSample.OperatingProfile;
        console.log("rsg_handleAddGeneratedToWorkingSchedule: Using Operating Profile from preview sample as checkboxes were empty:", targetOpProfile);
    }

    // Validate that the preview matches the current form settings for Route, Destination, and final Operating Profile
    if (previewSample.lineName.toUpperCase() !== targetRouteName ||
        previewSample.destinationName !== targetDestName ||
        previewSample.OperatingProfile !== targetOpProfile) {

        let mismatchDetail = "";
        if (previewSample.lineName.toUpperCase() !== targetRouteName) mismatchDetail += `Route (Preview: ${previewSample.lineName}, Form: ${targetRouteName}). `;
        if (previewSample.destinationName !== targetDestName) mismatchDetail += `Destination (Preview: ${previewSample.destinationName}, Form: ${targetDestName}). `;
        if (previewSample.OperatingProfile !== targetOpProfile) mismatchDetail += `Profile (Preview: ${previewSample.OperatingProfile}, Form: ${targetOpProfile}). `;

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Form settings (Route/Dest/Profile) do not match the generated preview. Mismatches: ${mismatchDetail}Please re-generate preview if settings changed.`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }
    
    if (!targetRouteName || !targetOpProfile || !targetDestName) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route Name, Operating Profile, and Destination Name must be defined in Section 1 to update the schedule.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const actionChoice = prompt(
        `Choose action for the ${rsg_generatedPreviewEntries_extra.length} previewed entries for:\n` +
        `Route: ${targetRouteName}\nProfile: ${targetOpProfile}\nDestination: ${targetDestName}\n\n` +
        `1. OVERWRITE existing entries for this specific Route, Profile, and Destination.\n` +
        `2. ADD these new entries (will append if R/P/D exists, or create if new).\n\n` +
        `Enter 1 or 2 (or Cancel):`
    );

    let newEntriesCount = rsg_generatedPreviewEntries_extra.length;
    let operationPerformed = false;
    // Deep copy the preview entries to avoid modifying the preview state directly
    const entriesToAdd = JSON.parse(JSON.stringify(rsg_generatedPreviewEntries_extra));

    if (actionChoice === "1") { // OVERWRITE for specific R/P/D
        if (confirm(`ARE YOU SURE you want to REMOVE all existing entries for Route "${targetRouteName}", Profile "${targetOpProfile}", Destination "${targetDestName}" AND THEN ADD these ${newEntriesCount} new entries?`)) {
            let removedCount = 0;
            // Filter out existing entries that match the exact R/P/D
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
                const matchesRPD = entry.lineName && entry.lineName.toUpperCase() === targetRouteName &&
                                   entry.OperatingProfile === targetOpProfile &&
                                   entry.destinationName === targetDestName;
                if (matchesRPD) {
                    removedCount++;
                    return false; // Exclude this entry
                }
                return true; // Keep other entries
            });
            
            // Add the new entries from the preview
            currentWorkingSchedule_extra.push(...entriesToAdd);
            
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Locally removed ${removedCount} existing entries. Will add ${newEntriesCount} new entries for ${targetRouteName}/${targetOpProfile}/${targetDestName}. Preparing to save...`;
                rsgStatusMessage_el_extra.style.color = "#f1c40f"; // Yellow for processing
            }
            operationPerformed = true;
        } else {
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Overwrite operation cancelled by user.";
                rsgStatusMessage_el_extra.style.color = ""; // Neutral
            }
            return; // User cancelled overwrite confirmation
        }
    } else if (actionChoice === "2") { // ADD (append)
        currentWorkingSchedule_extra.push(...entriesToAdd); // Append new entries
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `${newEntriesCount} entries will be ADDED to the working schedule (for ${targetRouteName}/${targetOpProfile}/${targetDestName} if applicable). Preparing to save...`;
            rsgStatusMessage_el_extra.style.color = "#f1c40f"; // Yellow for processing
        }
        operationPerformed = true;
    } else {
        if (actionChoice !== null && rsgStatusMessage_el_extra) { // User entered something other than 1 or 2
            rsgStatusMessage_el_extra.textContent = "Invalid choice. Operation cancelled.";
        } else if (rsgStatusMessage_el_extra) { // User pressed Cancel on the prompt
             rsgStatusMessage_el_extra.textContent = "Add to working schedule cancelled.";
        }
        if (rsgStatusMessage_el_extra) rsgStatusMessage_el_extra.style.color = ""; // Neutral
        return; // Invalid choice or cancelled
    }

    if (operationPerformed) {
        // Ensure targetRouteName for the save operation is correctly from the RSG form
        const rsgRouteNameForSave = rsgRouteNameInput_el_extra.value.trim().toUpperCase(); 

        if (!rsgRouteNameForSave) { // Should have been caught earlier, but a good final check
            console.error("RSG Add to Working: Critical error - targetRouteName is empty before Firebase save.");
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Error: Route name missing for save operation. Cannot proceed.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            return; 
        }

        try {
            // *** THIS IS THE MODIFIED PART ***
            // Call the new targeted save function, passing only the route name.
            // The save function will then extract all data for this route (across all its R/P/Ds)
            // from the currentWorkingSchedule_extra and update Firebase accordingly.
            if (rsgStatusMessage_el_extra) { // Update status before await
                 rsgStatusMessage_el_extra.textContent = `Saving changes for route "${rsgRouteNameForSave}" to Firebase...`;
                 rsgStatusMessage_el_extra.style.color = "#3498db"; // Blue for in-progress
            }
            await saveSpecificRouteDataToFirebase_ExtraPage(rsgRouteNameForSave); 
            
            // Success message after saveSpecificRouteDataToFirebase_ExtraPage completes
            if (rsgStatusMessage_el_extra) {
                const messageAction = actionChoice === "1" 
                    ? `Overwrote entries for R/P/D "${targetRouteName}/${targetOpProfile}/${targetDestName}" and added ${newEntriesCount} new ones.` 
                    : `Added ${newEntriesCount} entries for R/P/D "${targetRouteName}/${targetOpProfile}/${targetDestName}".`;
                rsgStatusMessage_el_extra.textContent = `Successfully saved to Firebase. ${messageAction} Working schedule now has ${currentWorkingSchedule_extra.length} total entries.`;
                rsgStatusMessage_el_extra.style.color = "#2ecc71"; // Green for success
            }
            
            // Reset the RSG preview and update UI elements
            rsg_resetPreviewState("Successfully added to working schedule and saved to Firebase. Ready for new generation.", "success");
            renderUIDependentElements_ExtraPage(); // Refresh any UI elements dependent on the schedule

        } catch (error) {
            // Error handling specifically for the saveSpecificRouteDataToFirebase_ExtraPage call
            // The saveSpecificRouteDataToFirebase_ExtraPage function might set its own detailed error message.
            console.error("Error in rsg_handleAddGeneratedToWorkingSchedule_ExtraPage (calling targeted save to Firebase):", error);
            if (rsgStatusMessage_el_extra && !rsgStatusMessage_el_extra.textContent.includes("Error saving route")) { 
                // Check if a more specific error wasn't already set by the save function
                rsgStatusMessage_el_extra.textContent = "Error saving to Firebase: " + error.message + ". Local changes might not be live. Please review.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            // At this point, currentWorkingSchedule_extra reflects the local changes,
            // but Firebase save failed. The user needs to be aware.
        }
    }
}
        // ++ END Route Schedule Generator Functions ++

// ++ Functions for "Schedule This Configuration" -- START ++
        function rsg_closeScheduleDateTimeModal_ExtraPage() {
    const modal = document.getElementById('rsg-schedule-datetime-modal-extra');
    if (modal) modal.style.display = 'none';
    rsg_batchScheduleItems = [];
}

        async function rsg_confirmScheduleGoLive_ExtraPage() {
    const goLiveInput = document.getElementById('rsg-go-live-datetime-input-extra');
    const modalStatus = document.getElementById('rsg-schedule-datetime-modal-status-extra');

    if (!goLiveInput || !modalStatus) { return; }
    const goLiveDateTime = goLiveInput.value;

    if (!goLiveDateTime) {
        modalStatus.textContent = "Please select a go-live date and time.";
        modalStatus.style.color = "#e74c3c";
        return;
    }
    const goLiveDateObj = new Date(goLiveDateTime);
    if (isNaN(goLiveDateObj.getTime())) {
        modalStatus.textContent = "Invalid date/time format.";
        modalStatus.style.color = "#e74c3c";
        return;
    }

    if (goLiveDateObj <= new Date()) {
        modalStatus.textContent = "Go-live date/time must be in the future.";
        modalStatus.style.color = "#e74c3c";
        return;
    }

    const { database, dbSet, dbRef } = window.firebaseOMSI;
    let successCount = 0;
    let errorCount = 0;
    const scheduledByUser = currentUser_extra ? currentUser_extra.email : "unknown";
    const scheduledAtTimestamp = new Date().toISOString();

    if (rsg_batchScheduleItems && rsg_batchScheduleItems.length > 0) {
        modalStatus.textContent = `Processing ${rsg_batchScheduleItems.length} configurations for scheduling...`;
        modalStatus.style.color = "#f1c40f";

        for (const batchItem of rsg_batchScheduleItems) {
            const configurationToSchedule = {
                taskType: "applySchedule",
                routeName: batchItem.routeName,
                destinationName: batchItem.destinationName,
                operatingProfile: batchItem.operatingProfile,
                stopSequence: batchItem.stopSequence,
                firstStopTimes: batchItem.firstStopTimes,
                scheduledEntries: batchItem.scheduledEntries,
                goLiveDateTime: goLiveDateObj.toISOString(),
                scheduledAt: scheduledAtTimestamp,
                status: "pending",
                userEmail: scheduledByUser,
                sourceConfigKey: batchItem.configKey,
                sourceConfigName: batchItem.userDisplayName
            };

            try {
                const scheduleKey = `sched_${Date.now()}_${sanitizeFirebaseKey(batchItem.routeName)}_${successCount}`;
                await dbSet(dbRef(database, `${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${scheduleKey}`), configurationToSchedule);
                successCount++;
            } catch (error) {
                errorCount++;
            }
        }

        modalStatus.textContent = `Batch scheduling complete. Success: ${successCount}, Failed: ${errorCount}.`;
        modalStatus.style.color = errorCount > 0 ? "#e74c3c" : "#2ecc71";
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Batch scheduling: ${successCount} succeeded, ${errorCount} failed. Go-live: ${goLiveDateObj.toLocaleString()}.`;
            rsgStatusMessage_el_extra.style.color = errorCount > 0 ? "#e74c3c" : "#2ecc71";
        }
        rsg_batchScheduleItems = [];
        setTimeout(rsg_closeScheduleDateTimeModal_ExtraPage, errorCount > 0 ? 4000 : 2000);

    } else {
        const routeName = rsgRouteNameInput_el_extra.value.trim();
        let operatingProfile = rsg_getSelectedOpProfilesString_ExtraPage();
        const destinationName = rsgDestinationNameInput_el_extra.value.trim();

        if (!operatingProfile && rsg_lastLoadedOpProfile_extra &&
            routeName.toUpperCase() === (rsg_lastLoadedRouteName_extra || "").toUpperCase() &&
            destinationName === (rsg_lastLoadedDestName_extra || "")) {
            operatingProfile = rsg_lastLoadedOpProfile_extra;
        }

        if (!routeName || !operatingProfile || !destinationName || rsg_selectedStops_extra.length === 0 || !rsgFirstStopTimesInput_el_extra.value.trim()) {
             modalStatus.textContent = "Cannot schedule: Main RSG form is incomplete (Route, Profile, Dest, Sequence, Times).";
             modalStatus.style.color = "#e74c3c";
             return;
        }

        if (!rsg_generatedPreviewEntries_extra || rsg_generatedPreviewEntries_extra.length === 0) {
             modalStatus.textContent = "No preview entries generated for the current RSG setup. Please generate preview first.";
             modalStatus.style.color = "#e74c3c";
             return;
        }

        const configurationToSchedule = {
            taskType: "applySchedule",
            routeName: routeName,
            destinationName: destinationName,
            operatingProfile: operatingProfile,
            stopSequence: JSON.parse(JSON.stringify(rsg_selectedStops_extra)),
            firstStopTimes: rsgFirstStopTimesInput_el_extra.value.trim(),
            scheduledEntries: JSON.parse(JSON.stringify(rsg_generatedPreviewEntries_extra)),
            goLiveDateTime: goLiveDateObj.toISOString(),
            scheduledAt: scheduledAtTimestamp,
            status: "pending",
            userEmail: scheduledByUser
        };

        modalStatus.textContent = "Scheduling current configuration...";
        modalStatus.style.color = "#f1c40f";

        try {
            const scheduleKey = `sched_${Date.now()}_${sanitizeFirebaseKey(routeName)}`;
            await dbSet(dbRef(database, `${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${scheduleKey}`), configurationToSchedule);
            modalStatus.textContent = "Configuration scheduled successfully!";
            modalStatus.style.color = "#2ecc71";
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Current configuration for ${routeName} (${operatingProfile}) scheduled for ${goLiveDateObj.toLocaleString()}.`;
                rsgStatusMessage_el_extra.style.color = "#2ecc71";
            }
            setTimeout(rsg_closeScheduleDateTimeModal_ExtraPage, 2000);
        } catch (error) {
            modalStatus.textContent = "Error scheduling: " + error.message;
            modalStatus.style.color = "#e74c3c";
             if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Error scheduling configuration.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
        }
    }
    if (typeof loadAndDisplayScheduledUpdates_ExtraPage === 'function') {
        loadAndDisplayScheduledUpdates_ExtraPage();
    }
}

        function handleScheduleThisConfiguration() {
            console.log("Schedule This Configuration button clicked!");
            const scheduleModal = document.getElementById('rsg-schedule-datetime-modal-extra');
            
            if (!currentUser_extra) {
                alert("Please log in to schedule configurations.");
                if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = "Please log in.";
                    rsgStatusMessage_el_extra.style.color = "#e74c3c";
                }
                return;
            }

            if (scheduleModal) {
                // Perform a pre-check to ensure the current RSG form state can generate a valid preview.
                // The rsg_handleGenerateSchedulePreview_ExtraPage(true) function itself will set status messages if validation fails.
                if (!rsg_handleGenerateSchedulePreview_ExtraPage(true)) { // Pass true for isPreCheck
                    // rsg_handleGenerateSchedulePreview_ExtraPage(true) will already set rsgStatusMessage_el_extra on failure.
                    // We could add an additional, more direct message here if desired, but it might be redundant.
                    // e.g., if(rsgStatusMessage_el_extra) rsgStatusMessage_el_extra.textContent = "Cannot schedule: current RSG form is invalid. Please correct and generate a preview.";
                    return; 
                }
                
                // If pre-check passes (meaning a valid schedule *could* be generated), then proceed to show modal.
                const modalStatus = document.getElementById('rsg-schedule-datetime-modal-status-extra');
                if (modalStatus) modalStatus.textContent = ''; // Clear previous modal status

                const goLiveInput = document.getElementById('rsg-go-live-datetime-input-extra');
                if (goLiveInput) {
                    const tomorrow = new Date();
                    tomorrow.setDate(tomorrow.getDate() + 1); // Default to tomorrow
                    tomorrow.setHours(5, 0, 0, 0); // Default to 05:00 AM (typical service change time)
                    
                    const year = tomorrow.getFullYear();
                    const month = String(tomorrow.getMonth() + 1).padStart(2, '0');
                    const day = String(tomorrow.getDate()).padStart(2, '0');
                    const hours = String(tomorrow.getHours()).padStart(2, '0');
                    const minutes = String(tomorrow.getMinutes()).padStart(2, '0');
                    goLiveInput.value = `${year}-${month}-${day}T${hours}:${minutes}`;
                }
                scheduleModal.style.display = 'flex';
            } else {
                console.error("Schedule DateTime modal (rsg-schedule-datetime-modal-extra) not found!");
                if (rsgStatusMessage_el_extra) {
                     rsgStatusMessage_el_extra.textContent = "Error: Scheduling modal component is missing.";
                     rsgStatusMessage_el_extra.style.color = "#e74c3c";
                }
            }
        }
        // ++ Functions for "Schedule This Configuration" -- END ++

// ++ Scheduled Route Updates (SRU) Functions -- START ++

        async function loadAndDisplayScheduledUpdates_ExtraPage() {
    const listContainer = document.getElementById('sru-updates-list-container-extra');
    if (!listContainer || !window.firebaseOMSI) {
        if (listContainer) listContainer.innerHTML = '<p>Error: Firebase not available.</p>';
        console.error("SRU/SRD Load: Firebase or list container not available.");
        return;
    }
    listContainer.innerHTML = '<p>Loading all scheduled tasks...</p>';
    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;

    // Initialize with empty objects
    scheduledRouteUpdates_extra = {};
    scheduledRouteDeletions_extra = {};

    try {
        // Fetch timetable application updates
        console.log("SRU Load: Attempting to fetch schedule application tasks...");
        const updatesSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULED_ROUTE_UPDATES));
        if (updatesSnap.exists()) {
            scheduledRouteUpdates_extra = updatesSnap.val() || {}; // Ensure it's an object
        }
        console.log(`SRU Load: Fetched ${Object.keys(scheduledRouteUpdates_extra).length} schedule application tasks.`);

        // Fetch route deletion tasks
        console.log("SRU Load: Attempting to fetch route deletion tasks...");
        const deletionsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULED_DELETIONS));
        if (deletionsSnap.exists()) {
            scheduledRouteDeletions_extra = deletionsSnap.val() || {}; // Ensure it's an object
        } else {
            scheduledRouteDeletions_extra = {}; // Path doesn't exist or is null
        }
        // --- THIS IS THE DETAILED LOG YOU WERE ASKING FOR ---
        console.log(`SRU Load: Fetched ${Object.keys(scheduledRouteDeletions_extra).length} route deletion tasks. Content:`, JSON.parse(JSON.stringify(scheduledRouteDeletions_extra)));
        // --- END OF DETAILED LOG ---

        renderScheduledUpdatesList_ExtraPage();
        
        // *** ADD THIS LINE ***
        checkAndDisplayDueUpdatesNotification_ExtraPage();

    } catch (error) {
        console.error("Error loading scheduled tasks (updates and/or deletions):", error);
        listContainer.innerHTML = `<p style="color:#e74c3c;">Error loading tasks: ${error.message}</p>`;
        // Ensure they are reset on error too
        scheduledRouteUpdates_extra = {};
        scheduledRouteDeletions_extra = {};
    }
}

        function renderScheduledUpdatesList_ExtraPage() {
    const listContainer = document.getElementById('sru-updates-list-container-extra');
    if (!listContainer) {
        return;
    }
    listContainer.innerHTML = '<p>Processing scheduled tasks list...</p>';

    let allApplyScheduleTasks = [];
    let allDeleteTasks = [];

    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.entries(scheduledRouteUpdates_extra).forEach(([key, value]) => {
            if (value && typeof value === 'object' && (value.taskType === 'applySchedule' || value.taskTypeDisplay === 'applySchedule')) {
                // We only care about pending or errored tasks for individual display
                if (value.status === 'pending' || value.status === 'error') {
                     allApplyScheduleTasks.push({ key, ...value, taskTypeDisplay: 'applySchedule' });
                }
            }
        });
    }
    if (typeof scheduledRouteDeletions_extra === 'object' && scheduledRouteDeletions_extra !== null) {
        Object.entries(scheduledRouteDeletions_extra).forEach(([key, value]) => {
            if (value && typeof value === 'object' && (value.taskType === 'deleteEntireRoute' || value.taskTypeDisplay === 'deleteEntireRoute')) {
                if (value.status === 'pending' || value.status === 'error') {
                    allDeleteTasks.push({ key, ...value, taskTypeDisplay: 'deleteEntireRoute' });
                }
            }
        });
    }

    const allKnownRouteNamesFromSchedule = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName).filter(Boolean))];
    const applyTasksGroupedByRouteThenTime = {};
    allApplyScheduleTasks.forEach(task => {
        const routeNameForGrouping = task.routeName || "UnspecifiedRoute";
        const goLiveISO = task.goLiveDateTime;
        if (!goLiveISO) {
            if (!applyTasksGroupedByRouteThenTime["InvalidGoLiveTime"]) {
                applyTasksGroupedByRouteThenTime["InvalidGoLiveTime"] = { "UnknownTime": [] };
            }
            applyTasksGroupedByRouteThenTime["InvalidGoLiveTime"]["UnknownTime"].push(task);
            return;
        }
        if (!applyTasksGroupedByRouteThenTime[routeNameForGrouping]) {
            applyTasksGroupedByRouteThenTime[routeNameForGrouping] = {};
        }
        if (!applyTasksGroupedByRouteThenTime[routeNameForGrouping][goLiveISO]) {
            applyTasksGroupedByRouteThenTime[routeNameForGrouping][goLiveISO] = [];
        }
        applyTasksGroupedByRouteThenTime[routeNameForGrouping][goLiveISO].push(task);
    });

    listContainer.innerHTML = ''; // Clear previous content
    let anyContentRenderedOverall = false;

    const allRoutesToDisplaySet = new Set([
        ...allKnownRouteNamesFromSchedule,
        ...Object.keys(applyTasksGroupedByRouteThenTime).filter(rn => rn !== "UnspecifiedRoute" && rn !== "InvalidGoLiveTime"),
        ...allDeleteTasks.map(t => t.routeName).filter(Boolean).filter(rn => rn !== "UnspecifiedRoute")
    ]);
    const sortedRoutesToDisplay = Array.from(allRoutesToDisplaySet).sort(compareLineNames_ExtraPage);

    if (sortedRoutesToDisplay.length > 0 || 
        (applyTasksGroupedByRouteThenTime["UnspecifiedRoute"] && Object.keys(applyTasksGroupedByRouteThenTime["UnspecifiedRoute"]).length > 0) ||
        (applyTasksGroupedByRouteThenTime["InvalidGoLiveTime"] && Object.keys(applyTasksGroupedByRouteThenTime["InvalidGoLiveTime"]).length > 0) ||
        allDeleteTasks.some(task => !task.routeName || task.routeName === "UnspecifiedRoute")
    ) {
        const sectionTitle = document.createElement('h3');
        sectionTitle.className = 'subsection-title';
        sectionTitle.textContent = 'Individually Pending & Actionable Scheduled Tasks (Grouped by Route)';
        sectionTitle.style.color = '#B2DFDB'; // Light teal for visibility
        sectionTitle.style.marginBottom = '1em';
        listContainer.appendChild(sectionTitle);
    }


    sortedRoutesToDisplay.forEach(routeName => {
        const tasksByTimeForThisRoute = applyTasksGroupedByRouteThenTime[routeName];
        const deleteTasksForThisRoute = allDeleteTasks.filter(task => task.routeName === routeName && (task.status === 'pending' || task.status === 'error'));

        if ((tasksByTimeForThisRoute && Object.keys(tasksByTimeForThisRoute).length > 0) || deleteTasksForThisRoute.length > 0) {
            anyContentRenderedOverall = true;
            const routeGroupDiv = document.createElement('div');
            routeGroupDiv.className = 'sru-route-group subsection'; // Added class for potential specific styling
            routeGroupDiv.style.marginBottom = '2rem'; 
            routeGroupDiv.style.paddingTop = '0.5rem';
            routeGroupDiv.style.borderLeft = '3px solid #607D8B'; // Accent border for the route group

            const routeHeading = document.createElement('h4');
            routeHeading.style.marginTop = '0.2em'; 
            routeHeading.style.marginBottom = '0.5em'; 
            routeHeading.style.fontSize = '1.2em'; 
            routeHeading.style.borderBottom = '1px solid #555';
            routeHeading.style.paddingBottom = '0.4em'; 
            routeHeading.textContent = `Route: ${routeName}`;
            routeGroupDiv.appendChild(routeHeading);

            // START: Add "Cancel All Updates for This Route" button
            const cancelAllForRouteButton = document.createElement('button');
            cancelAllForRouteButton.className = 'button tertiary sru-cancel-all-for-route-btn';
            cancelAllForRouteButton.textContent = 'Cancel All Pending Updates for This Route';
            cancelAllForRouteButton.title = `Review and cancel all pending timetable updates for Route ${routeName}`;
            cancelAllForRouteButton.style.display = 'block'; 
            cancelAllForRouteButton.style.width = 'fit-content'; 
            cancelAllForRouteButton.style.marginBottom = '1em'; // Space below this button
            cancelAllForRouteButton.style.fontSize = '0.85em';
            cancelAllForRouteButton.style.backgroundColor = '#b33930'; // A distinct warning/cancel color
            cancelAllForRouteButton.style.color = 'white';
            cancelAllForRouteButton.dataset.routeName = routeName;
            cancelAllForRouteButton.addEventListener('click', (e) => {
                const targetRoute = e.target.dataset.routeName;
                if (targetRoute && typeof handleCancelAllUpdatesForRoute_Master === 'function') {
                    handleCancelAllUpdatesForRoute_Master(targetRoute);
                } else {
                    console.error("handleCancelAllUpdatesForRoute_Master function not found or targetRoute missing for button on route:", routeName);
                    alert("Error: Action handler not found for this button.");
                }
            });
            routeGroupDiv.appendChild(cancelAllForRouteButton);
            // END: Add "Cancel All Updates for This Route" button

            let contentAddedForThisRouteSection = false;

            if (tasksByTimeForThisRoute && Object.keys(tasksByTimeForThisRoute).length > 0) {
                contentAddedForThisRouteSection = true;
                const applyUpdatesSubheading = document.createElement('h5');
                applyUpdatesSubheading.textContent = "Timetable Updates for this route:";
                applyUpdatesSubheading.style.color = "#DAF7A6"; // Light green
                applyUpdatesSubheading.style.fontSize = "1em";
                applyUpdatesSubheading.style.marginBottom = "0.5em";
                routeGroupDiv.appendChild(applyUpdatesSubheading);

                const sortedGoLiveTimes = Object.keys(tasksByTimeForThisRoute).sort((a,b) => new Date(a).getTime() - new Date(b).getTime());
                sortedGoLiveTimes.forEach(goLiveISO => {
                    const batchOfTasks = tasksByTimeForThisRoute[goLiveISO];
                    // Sort tasks within a batch for consistent display (e.g., by profile then destination)
                    batchOfTasks.sort((a, b) => {
                         const opA = a.operatingProfile || ""; const opB = b.operatingProfile || "";
                         const destA = a.destinationName || ""; const destB = b.destinationName || "";
                         if (opA.localeCompare(opB) !== 0) return opA.localeCompare(opB);
                         return destA.localeCompare(destB);
                    });

                    const batchContainerDiv = document.createElement('div');
                    batchContainerDiv.className = 'sru-batch-container subsection'; // Nested subsection for batch
                    batchContainerDiv.style.marginLeft = "1em"; 
                    batchContainerDiv.style.marginBottom = "1rem";
                    batchContainerDiv.style.padding = "0.8rem"; 
                    batchContainerDiv.style.borderLeft = "4px solid #3498db"; // Accent for apply batch

                    let batchStatusSummary = batchOfTasks.some(t => t.status === 'error') ? 'error (in batch)' : 'pending';

                    let batchDetailsHTML = `<h6 style="margin-top:0; margin-bottom:0.6em; font-size:1.0em; color: #ecf0f1;">Batch Go-Live: ${new Date(goLiveISO).toLocaleString()} <span style="font-weight:bold; color:${batchStatusSummary === 'pending' ? '#f39c12' : '#e74c3c'}">(${batchStatusSummary})</span></h6>`;
                    batchDetailsHTML += `<p style="font-size:0.85em; margin-bottom:0.5em;">Contains ${batchOfTasks.length} update(s). Applying replaces <strong>entire Route ${routeName}</strong>.</p>`;
                    batchDetailsHTML += '<ul style="font-size:0.8em; padding-left:1.5em; margin-bottom:0.75em;">';
                    batchOfTasks.forEach(task => {
                        let taskStatusColor = task.status === 'pending' ? '#f1c40f' : (task.status === 'error' ? '#e74c3c' : '#bdc3c7');
                        batchDetailsHTML += `<li style="margin-bottom:0.2em;">Target: (P: ${task.operatingProfile || 'N/A'}, D: ${task.destinationName || 'N/A'}) - ${task.scheduledEntries ? task.scheduledEntries.length : 0} entries. Status: <span style="color:${taskStatusColor}; font-weight:bold;">${task.status || 'N/A'}</span></li>`;
                    });
                    batchDetailsHTML += '</ul>';

                    const batchActionsDiv = document.createElement('div');
                    batchActionsDiv.style.marginTop = "0.5em";
                    
                    const applyBatchButton = document.createElement('button');
                    applyBatchButton.className = 'button save sru-apply-batch-btn';
                    applyBatchButton.textContent = `Apply This Batch Now`;
                    applyBatchButton.title = `Delete all for Route ${routeName}, apply ${batchOfTasks.length} updates.`;
                    applyBatchButton.addEventListener('click', () => handleApplyScheduledRouteBatch_ExtraPage(batchOfTasks));
                    batchActionsDiv.appendChild(applyBatchButton);

                    // Individual cancel buttons for tasks within this specific batch
                    batchOfTasks.forEach(task => {
                        const cancelTaskButton = document.createElement('button');
                        cancelTaskButton.className = 'button small-action neutral sru-cancel-task-btn';
                        cancelTaskButton.textContent = `Cancel Update: (P: ${task.operatingProfile || 'N/A'}, D: ${task.destinationName || 'N/A'})`;
                        cancelTaskButton.style.marginLeft = "8px"; 
                        cancelTaskButton.style.fontSize = "0.75em";
                        cancelTaskButton.title = `Cancel only this specific update task: ${task.key}`;
                        cancelTaskButton.dataset.key = task.key; 
                        cancelTaskButton.dataset.taskType = 'applySchedule';
                        // Event listener for this specific cancel button is now added at the end of renderScheduledUpdatesList_ExtraPage
                        batchActionsDiv.appendChild(cancelTaskButton);
                    });
                    batchContainerDiv.innerHTML = batchDetailsHTML;
                    batchContainerDiv.appendChild(batchActionsDiv);
                    routeGroupDiv.appendChild(batchContainerDiv);
                });
            }

            if (deleteTasksForThisRoute.length > 0) {
                contentAddedForThisRouteSection = true;
                const routeDeletionsSubheading = document.createElement('h5');
                routeDeletionsSubheading.textContent = "Scheduled Withdrawal for this Route:";
                routeDeletionsSubheading.style.color = "#E74C3C"; // Red
                routeDeletionsSubheading.style.marginTop = (tasksByTimeForThisRoute && Object.keys(tasksByTimeForThisRoute).length > 0) ? "1.5em" : "0.5em";
                routeDeletionsSubheading.style.fontSize = "1em";
                routeDeletionsSubheading.style.borderTop = (tasksByTimeForThisRoute && Object.keys(tasksByTimeForThisRoute).length > 0) ? "1px dashed #555" : "none";
                routeDeletionsSubheading.style.paddingTop = (tasksByTimeForThisRoute && Object.keys(tasksByTimeForThisRoute).length > 0) ? "0.75em" : "0";

                routeGroupDiv.appendChild(routeDeletionsSubheading);

                deleteTasksForThisRoute.sort((a,b) => new Date(a.goLiveDateTime).getTime() - new Date(b.goLiveDateTime).getTime());
                deleteTasksForThisRoute.forEach(task => {
                    const itemDiv = document.createElement('div');
                    itemDiv.classList.add('subsection'); // Or a more specific class like 'sru-deletion-task-item'
                    itemDiv.style.marginBottom = '0.75rem'; 
                    itemDiv.style.padding = '0.75rem';
                    itemDiv.style.marginLeft = "1em"; 
                    itemDiv.style.borderLeft = "4px solid #c0392b"; // Accent for deletion task
                    itemDiv.dataset.scheduleKey = task.key; // For targeting if needed
                    itemDiv.dataset.taskType = 'deleteEntireRoute';

                    let statusColor = task.status === 'pending' ? '#f39c12' : (task.status === 'error' ? '#e74c3c' : '#ecf0f1');
                    
                    let actionsHTML = '';
                    if (task.status === 'pending' || task.status === 'error') {
                        actionsHTML = `<button class="button small-action tertiary sru-execute-deletion-btn" data-key="${task.key}" style="background-color:${task.status === 'error' ? '#d35400' : '#e67e22'};">${task.status === 'error' ? 'Retry' : 'Withdraw Route Now'}</button> `;
                    }
                    actionsHTML += `<button class="button small-action neutral sru-cancel-task-btn" data-key="${task.key}" data-task-type="deleteEntireRoute" style="margin-left:8px;">Cancel</button>`;

                    itemDiv.innerHTML = `
                        <h6 style="margin-top:0; margin-bottom:0.4em; font-size:1.0em; color: #e74c3c;">ROUTE WITHDRAWN (Go-Live: ${new Date(task.goLiveDateTime).toLocaleString()})</h6>
                        <p style="font-size:0.9em;">Status: <span style="font-weight:bold; color:${statusColor};">${task.status || 'N/A'}</span></p>
                        <p style="font-size:0.8em; opacity:0.8;">By: ${task.userEmail || 'System'} (ID: ${task.key ? task.key.substring(0,10) : 'N/A'}...)</p>
                        ${task.lastError ? `<p style="font-size:0.8em; color:#e74c3c;">Error: ${task.lastError}</p>` : ''}
                        <div class="scheduled-update-actions" style="margin-top:0.75em;">${actionsHTML}</div>`;
                    routeGroupDiv.appendChild(itemDiv);
                });
            }

            if (!contentAddedForThisRouteSection) {
                const noTasksMsg = document.createElement('p');
                noTasksMsg.textContent = `(No pending or error tasks currently scheduled for Route ${routeName})`;
                noTasksMsg.style.fontSize = '0.85em'; 
                noTasksMsg.style.opacity = '0.7';
                noTasksMsg.style.paddingLeft = '1em'; 
                noTasksMsg.style.fontStyle = 'italic';
                routeGroupDiv.appendChild(noTasksMsg);
            }
            listContainer.appendChild(routeGroupDiv);
        }
    }); // End of sortedRoutesToDisplay.forEach

    // Function to render special categories (Unspecified Route, Invalid GoLiveTime)
    function renderSpecialCategoryTasks(categoryName, categoryKey, tasksByTime, deleteTasks, headingColor = "#f1c40f") {
        const categoryApplyTasksByTime = tasksByTime ? tasksByTime[categoryKey] : null;
        const categoryDeleteTasksFiltered = deleteTasks ? deleteTasks.filter(task => (task.routeName || "UnspecifiedRoute") === categoryKey && (task.status === 'pending' || task.status === 'error')) : [];

        if ((categoryApplyTasksByTime && Object.keys(categoryApplyTasksByTime).length > 0) || categoryDeleteTasksFiltered.length > 0) {
            anyContentRenderedOverall = true;
            const specialRouteGroupDiv = document.createElement('div');
            specialRouteGroupDiv.className = 'sru-route-group subsection';
            specialRouteGroupDiv.style.marginBottom = '2rem'; 
            specialRouteGroupDiv.style.paddingTop = '0.5rem';
            specialRouteGroupDiv.style.borderLeft = `3px solid ${headingColor}`;

            const specialRouteHeading = document.createElement('h4');
            specialRouteHeading.style.marginTop = '0.2em'; 
            specialRouteHeading.style.marginBottom = '1em';
            specialRouteHeading.style.fontSize = '1.2em'; 
            specialRouteHeading.style.borderBottom = '1px solid #555';
            specialRouteHeading.style.paddingBottom = '0.4em'; 
            specialRouteHeading.style.color = headingColor;
            specialRouteHeading.textContent = `Category: ${categoryName}`;
            specialRouteGroupDiv.appendChild(specialRouteHeading);

            let contentAddedForThisSpecialCategory = false;

            if (categoryApplyTasksByTime && Object.keys(categoryApplyTasksByTime).length > 0) {
                contentAddedForThisSpecialCategory = true;
                const applyUpdatesSubheading = document.createElement('h5');
                applyUpdatesSubheading.textContent = "Timetable Updates in this category:";
                applyUpdatesSubheading.style.color = "#DAF7A6"; 
                applyUpdatesSubheading.style.fontSize = "1em"; 
                applyUpdatesSubheading.style.marginBottom = "0.5em";
                specialRouteGroupDiv.appendChild(applyUpdatesSubheading);

                 Object.keys(categoryApplyTasksByTime).sort((a,b) => new Date(a).getTime() - new Date(b).getTime()).forEach(goLiveISO => {
                    const batchOfTasks = categoryApplyTasksByTime[goLiveISO];
                    // Batch container for special category tasks
                    const batchContainerDiv = document.createElement('div');
                    batchContainerDiv.className = 'sru-batch-container subsection';
                    batchContainerDiv.style.marginLeft = "1em"; 
                    batchContainerDiv.style.marginBottom = "1rem";
                    batchContainerDiv.style.padding = "0.8rem"; 
                    batchContainerDiv.style.borderLeft = "4px solid #aaa"; // Neutral accent

                    let batchStatusSummary = batchOfTasks.some(t => t.status === 'error') ? 'error (in batch)' : 'pending';
                    let batchDetailsHTML = `<h6 style="margin-top:0; margin-bottom:0.6em; font-size:1.0em; color: #ecf0f1;">Batch Go-Live: ${goLiveISO === "UnknownTime" ? "Unknown" : new Date(goLiveISO).toLocaleString()} <span style="font-weight:bold; color:${batchStatusSummary === 'pending' ? '#f39c12' : '#e74c3c'}">(${batchStatusSummary})</span></h6>`;
                    batchDetailsHTML += `<p style="font-size:0.85em; margin-bottom:0.5em;">Contains ${batchOfTasks.length} update(s). Review route names if "Unspecified".</p>`;
                    batchDetailsHTML += '<ul style="font-size:0.8em; padding-left:1.5em; margin-bottom:0.75em;">';
                    batchOfTasks.forEach(task => {
                        let taskStatusColor = task.status === 'pending' ? '#f1c40f' : (task.status === 'error' ? '#e74c3c' : '#bdc3c7');
                        batchDetailsHTML += `<li style="margin-bottom:0.2em;">Route: ${task.routeName || 'N/A'}, P: ${task.operatingProfile || 'N/A'}, D: ${task.destinationName || 'N/A'} - ${task.scheduledEntries ? task.scheduledEntries.length : 0} entries. Status: <span style="color:${taskStatusColor}; font-weight:bold;">${task.status || 'N/A'}</span></li>`;
                    });
                    batchDetailsHTML += '</ul>';
                     batchContainerDiv.innerHTML = batchDetailsHTML;
                    // Add cancel buttons for these special category tasks too
                    const batchActionsDiv = document.createElement('div');
                    batchActionsDiv.style.marginTop = "0.5em";
                     batchOfTasks.forEach(task => {
                            const cancelTaskButton = document.createElement('button');
                            cancelTaskButton.className = 'button small-action neutral sru-cancel-task-btn';
                            cancelTaskButton.textContent = `Cancel Update for Route ${task.routeName || 'N/A'}`;
                            cancelTaskButton.style.marginLeft = "8px"; 
                            cancelTaskButton.style.fontSize = "0.75em";
                            cancelTaskButton.title = `Cancel only this specific update task: ${task.key}`;
                            cancelTaskButton.dataset.key = task.key; 
                            cancelTaskButton.dataset.taskType = 'applySchedule';
                            batchActionsDiv.appendChild(cancelTaskButton);
                    });
                    batchContainerDiv.appendChild(batchActionsDiv);
                    specialRouteGroupDiv.appendChild(batchContainerDiv);
                });
            }

            if (categoryDeleteTasksFiltered.length > 0) {
                contentAddedForThisSpecialCategory = true;
                const routeDeletionsSubheading = document.createElement('h5');
                routeDeletionsSubheading.textContent = "Scheduled Deletions in this category:";
                routeDeletionsSubheading.style.color = "#E74C3C";
                routeDeletionsSubheading.style.marginTop = (categoryApplyTasksByTime && Object.keys(categoryApplyTasksByTime).length > 0) ? "1.5em" : "0.5em";
                routeDeletionsSubheading.style.fontSize = "1em";
                specialRouteGroupDiv.appendChild(routeDeletionsSubheading);

                categoryDeleteTasksFiltered.forEach(task => {
                    const itemDiv = document.createElement('div');
                    itemDiv.classList.add('subsection');
                    itemDiv.style.marginBottom = '0.75rem'; 
                    itemDiv.style.padding = '0.75rem';
                    itemDiv.style.marginLeft = "1em"; 
                    itemDiv.style.borderLeft = "4px solid #c0392b";
                    itemDiv.dataset.scheduleKey = task.key; 
                    itemDiv.dataset.taskType = 'deleteEntireRoute';

                     let statusColor = task.status === 'pending' ? '#f39c12' : (task.status === 'error' ? '#e74c3c' : '#ecf0f1');
                    let actionsHTML = '';
                    if(task.status === 'pending' || task.status === 'error'){
                         actionsHTML = `<button class="button small-action tertiary sru-execute-deletion-btn" data-key="${task.key}" style="background-color:${task.status === 'error' ? '#d35400':'#e67e22'};">${task.status === 'error' ? 'Retry' : 'Withdraw Route Now'}</button> `;
                    }
                    actionsHTML += `<button class="button small-action neutral sru-cancel-task-btn" data-key="${task.key}" data-task-type="deleteEntireRoute" style="margin-left:8px;">Cancel</button>`;

                    itemDiv.innerHTML = `<h6 style="margin-top:0; margin-bottom:0.4em; font-size:1.0em; color: #e74c3c;">DELETE ENTIRE ROUTE ${task.routeName || ''} (Go-Live: ${new Date(task.goLiveDateTime).toLocaleString()})</h6> <p style="font-size:0.9em;">Status: <span style="font-weight:bold; color:${statusColor};">${task.status || 'N/A'}</span></p> <p style="font-size:0.8em; opacity:0.8;">By: ${task.userEmail || 'System'} (ID: ${task.key ? task.key.substring(0,10) : 'N/A'}...)</p> ${task.lastError ? `<p style="font-size:0.8em; color:#e74c3c;">Error: ${task.lastError}</p>` : ''} <div class="scheduled-update-actions" style="margin-top:0.75em;">${actionsHTML}</div>`;
                    specialRouteGroupDiv.appendChild(itemDiv);
                });
            }

             if (!contentAddedForThisSpecialCategory) {
                const noTasksMsg = document.createElement('p');
                noTasksMsg.textContent = `(No pending or error tasks found in category: ${categoryName})`;
                noTasksMsg.style.fontSize = '0.85em'; 
                noTasksMsg.style.opacity = '0.7';
                noTasksMsg.style.paddingLeft = '1em'; 
                noTasksMsg.style.fontStyle = 'italic';
                specialRouteGroupDiv.appendChild(noTasksMsg);
            }
            listContainer.appendChild(specialRouteGroupDiv);
        }
    } // End of renderSpecialCategoryTasks

    renderSpecialCategoryTasks("Tasks with Unspecified Route Name", "UnspecifiedRoute", applyTasksGroupedByRouteThenTime, allDeleteTasks, "#BCAAA4"); // Greyish for unspecified
    renderSpecialCategoryTasks("Tasks with Invalid Go-Live Time", "InvalidGoLiveTime", applyTasksGroupedByRouteThenTime, [], "#EF9A9A"); // Light red for invalid time


    if (!anyContentRenderedOverall) {
        listContainer.innerHTML = '<p style="text-align:center; opacity:0.8;">No pending or error tasks found to display.</p>';
    }

    // Populate radio buttons for the "Apply All Batches for a Specific Go-Live Time" feature
    if (sruBatchGoLiveRadiosContainer_el_extra && sruApplyAllForTimeButton_el_extra) {
        const allPendingApplyScheduleTasksForRadioPopulation = [];
         if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
            Object.values(scheduledRouteUpdates_extra).forEach(value => {
                if (value && typeof value === 'object' && 
                    (value.taskType === 'applySchedule' || value.taskTypeDisplay === 'applySchedule') &&
                    value.status === 'pending' && value.goLiveDateTime) { // Only pending for batch apply
                     allPendingApplyScheduleTasksForRadioPopulation.push(value);
                }
            });
        }

        const uniqueGoLiveTimesForRadio = [...new Set(allPendingApplyScheduleTasksForRadioPopulation.map(task => task.goLiveDateTime))]
            .sort((a,b) => new Date(a).getTime() - new Date(b).getTime());

        sruBatchGoLiveRadiosContainer_el_extra.innerHTML = ''; // Clear previous
        if (uniqueGoLiveTimesForRadio.length > 0) {
            uniqueGoLiveTimesForRadio.forEach(isoTime => {
                const tasksForThisTime = allPendingApplyScheduleTasksForRadioPopulation.filter(t => t.goLiveDateTime === isoTime);
                const affectedRoutesAtThisTime = [...new Set(tasksForThisTime.map(t => t.routeName || "Unspecified"))].sort(compareLineNames_ExtraPage);
                const totalUpdatesForThisTime = tasksForThisTime.length;

                const radioId = `sru-batch-golive-${new Date(isoTime).getTime()}`; // Unique ID for radio
                const radioLabel = document.createElement('label');
                radioLabel.htmlFor = radioId;
                radioLabel.style.display = 'block';
                radioLabel.style.marginBottom = '0.5em';
                radioLabel.style.cursor = 'pointer';
                radioLabel.style.color = '#ecf0f1';

                const radioButton = document.createElement('input');
                radioButton.type = 'radio';
                radioButton.name = 'sruBatchGoLiveTime_extra'; // Shared name for radio group
                radioButton.id = radioId;
                radioButton.value = isoTime;
                radioButton.style.marginRight = '10px';
                radioButton.style.verticalAlign = 'middle';
                radioButton.addEventListener('change', () => {
                    if(sruApplyAllForTimeButton_el_extra) sruApplyAllForTimeButton_el_extra.disabled = false;
                    if (sruApplyAllStatusMessage_el_extra) {
                        sruApplyAllStatusMessage_el_extra.textContent = `Selected Go-Live: ${new Date(isoTime).toLocaleString()}. This will affect ${affectedRoutesAtThisTime.length} route(s): ${affectedRoutesAtThisTime.join(', ')} with ${totalUpdatesForThisTime} total update task(s).`;
                        sruApplyAllStatusMessage_el_extra.style.color = '#f1c40f';
                    }
                });

                radioLabel.appendChild(radioButton);
                radioLabel.appendChild(document.createTextNode(`${new Date(isoTime).toLocaleString()} (${totalUpdatesForThisTime} tasks for ${affectedRoutesAtThisTime.length} routes: ${affectedRoutesAtThisTime.join(', ')})`));
                sruBatchGoLiveRadiosContainer_el_extra.appendChild(radioLabel);
            });
            if(sruApplyAllForTimeButton_el_extra) sruApplyAllForTimeButton_el_extra.disabled = true; // Initially disabled
        } else {
            sruBatchGoLiveRadiosContainer_el_extra.innerHTML = '<p style="opacity:0.7;">No pending batches with valid go-live times available to apply globally by time.</p>';
            if(sruApplyAllForTimeButton_el_extra) sruApplyAllForTimeButton_el_extra.disabled = true;
        }
    }


    // Re-attach generic listeners might be needed if items are fully re-rendered
    // However, it's better to attach listeners when elements are created.
    // The listeners for sru-cancel-task-btn and sru-execute-deletion-btn are attached directly above.
    // The listener for sru-cancel-all-for-route-btn is also attached directly.
}

async function handleApplyAllBatchesForSelectedTime_ExtraPage() {
    if (!currentUser_extra) {
        if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = "Please log in."; sruApplyAllStatusMessage_el_extra.style.color = "#e74c3c"; }
        return;
    }

    const selectedRadio = document.querySelector('input[name="sruBatchGoLiveTime_extra"]:checked');
    if (!selectedRadio) {
        if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = "Please select a Go-Live Time from the list above."; sruApplyAllStatusMessage_el_extra.style.color = "#f1c40f"; }
        return;
    }

    const selectedGoLiveDateTimeISO = selectedRadio.value;
    if(sruApplyAllStatusMessage_el_extra) {
        sruApplyAllStatusMessage_el_extra.textContent = `Preparing to apply all batches for ${new Date(selectedGoLiveDateTimeISO).toLocaleString()}...`;
        sruApplyAllStatusMessage_el_extra.style.color = "#3498db";
    }

    const tasksToProcessForSelectedTime = [];
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.entries(scheduledRouteUpdates_extra).forEach(([key, task]) => {
            if (task && task.taskType === 'applySchedule' && task.status === 'pending' && task.goLiveDateTime === selectedGoLiveDateTimeISO && task.scheduledEntries && task.scheduledEntries.length > 0) {
                tasksToProcessForSelectedTime.push({ key, ...task });
            }
        });
    }

    if (tasksToProcessForSelectedTime.length === 0) {
        if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = "No valid pending timetable updates found for the selected time. The list might have refreshed."; sruApplyAllStatusMessage_el_extra.style.color = "#f1c40f"; }
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh the list as something changed
        return;
    }

    const tasksGroupedByRoute = tasksToProcessForSelectedTime.reduce((acc, task) => {
        const routeName = task.routeName || "UnspecifiedRoute";
        if (!acc[routeName]) {
            acc[routeName] = [];
        }
        acc[routeName].push(task);
        return acc;
    }, {});

    const affectedRouteNames = Object.keys(tasksGroupedByRoute).sort(compareLineNames_ExtraPage);
    const confirmMessage = `EXTREME CAUTION!\n\nYou are about to apply ALL pending timetable updates scheduled for:\nGo-Live Time: ${new Date(selectedGoLiveDateTimeISO).toLocaleString()}\n\nThis will affect the following ${affectedRouteNames.length} route(s):\n- ${affectedRouteNames.join('\n- ')}\n\nFor EACH of these routes, ALL of their current schedule data will be DELETED and REPLACED with the new schedule from these batches.\n\nThis action is IRREVERSIBLE for the live schedule data.\nAre you absolutely sure you want to proceed?`;

    if (!confirm(confirmMessage)) {
        if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = "Bulk batch application cancelled by user."; sruApplyAllStatusMessage_el_extra.style.color = ""; }
        return;
    }

    if(sruApplyAllStatusMessage_el_extra) { sruApplyAllStatusMessage_el_extra.textContent = `Processing ${tasksToProcessForSelectedTime.length} tasks for ${affectedRouteNames.length} routes. This may take some time...`; }
    if(sruApplyAllForTimeButton_el_extra) sruApplyAllForTimeButton_el_extra.disabled = true;


    let allAffectedTaskKeys = [];
    let totalEntriesAdded = 0;
    let errorsDuringLocalProcessing = [];

    // Create a deep copy of the working schedule to modify
    let tempWorkingSchedule = JSON.parse(JSON.stringify(currentWorkingSchedule_extra));

    for (const routeName of affectedRouteNames) {
        const tasksForThisRoute = tasksGroupedByRoute[routeName];
        if (!tasksForThisRoute || tasksForThisRoute.length === 0) continue;

        let allNewEntriesForThisRoute = [];
        tasksForThisRoute.forEach(task => {
            allNewEntriesForThisRoute.push(...JSON.parse(JSON.stringify(task.scheduledEntries))); // Deep copy entries
            if (task.key) allAffectedTaskKeys.push(task.key);
        });

        if (allNewEntriesForThisRoute.length === 0) {
            errorsDuringLocalProcessing.push(`Route ${routeName}: No schedule entries found in its tasks for this batch time. Skipped adding new entries, but existing data for this route (if any) will be removed as part of the overwrite.`);
            // Continue to remove existing entries for this route to fulfill "overwrite"
        }
        
        // Remove all existing entries for this route from the temporary schedule
        let removedCountForRoute = 0;
        tempWorkingSchedule = tempWorkingSchedule.filter(entry => {
            if (entry.lineName && entry.lineName.toUpperCase() === routeName.toUpperCase()) {
                removedCountForRoute++;
                return false;
            }
            return true;
        });

        // Add new (or potentially empty if error above) entries for this route
        const entriesToAddWithUniqueIds = allNewEntriesForThisRoute.map((e, idx) => ({
            ...e,
            internalId: e.internalId || `${e.stopID}_${e.lineName}_${(e.scheduledTime||"0000").replace(':','')}_applyAllBatches_${Date.now()}_${idx}`
        }));
        tempWorkingSchedule.push(...entriesToAddWithUniqueIds);
        totalEntriesAdded += entriesToAddWithUniqueIds.length;
    }

    if (errorsDuringLocalProcessing.length > 0) {
        alert("Some issues were found during local processing:\n" + errorsDuringLocalProcessing.join("\n") + "\n\nProceeding with Firebase update based on processed data. Review affected routes carefully after completion.");
    }

    try {
        // Update the main global working schedule with the processed data
        currentWorkingSchedule_extra = tempWorkingSchedule; 
        
        await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
        console.log("Bulk apply: Main schedule rebuilt and saved to Firebase.");

        const { database, dbUpdate, dbRef } = window.firebaseOMSI;
        const appliedAtTimestamp = new Date().toISOString();
        const appliedByEmail = currentUser_extra ? currentUser_extra.email : "system (bulk apply)";
        const statusUpdates = {};
        allAffectedTaskKeys.forEach(taskKey => {
            statusUpdates[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}/status`] = 'applied (all batches for time)';
            statusUpdates[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}/appliedAt`] = appliedAtTimestamp;
            statusUpdates[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}/appliedBy`] = appliedByEmail;
        });

        await dbUpdate(dbRef(database), statusUpdates);
        console.log("Bulk apply: Status of affected tasks updated in Firebase.");

        if(sruApplyAllStatusMessage_el_extra) {
            sruApplyAllStatusMessage_el_extra.textContent = `Successfully applied all batches for ${new Date(selectedGoLiveDateTimeISO).toLocaleString()}. ${affectedRouteNames.length} routes updated, ${totalEntriesAdded} total new entries added. Schedule is live.`;
            sruApplyAllStatusMessage_el_extra.style.color = "#2ecc71";
        }
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh the list
        renderUIDependentElements_ExtraPage();     // Refresh other UI if needed

    } catch (error) {
        console.error("Error applying all batches for selected time:", error);
        if(sruApplyAllStatusMessage_el_extra) {
            sruApplyAllStatusMessage_el_extra.textContent = `CRITICAL ERROR applying batches: ${error.message}. Schedule may be inconsistent. MANUAL REVIEW REQUIRED.`;
            sruApplyAllStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // Attempt to mark tasks as error if main save failed
        const { database, dbUpdate, dbRef } = window.firebaseOMSI; // ensure it's in scope
        const errorStatusUpdates = {};
         allAffectedTaskKeys.forEach(taskKey => {
            errorStatusUpdates[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}/status`] = 'error';
            errorStatusUpdates[`${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}/lastError`] = `Bulk Apply Error (Main Schedule): ${error.message}`;
        });
        await dbUpdate(dbRef(database), errorStatusUpdates).catch(err => console.error("Failed to mark batch tasks as error:", err));
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh to show error state
    } finally {
        if(sruApplyAllForTimeButton_el_extra) sruApplyAllForTimeButton_el_extra.disabled = false;
    }
}

        async function handleCancelScheduledTask_ExtraPage(taskKey, taskType) {
            if (!taskKey || !taskType) {
                alert("Error: Invalid task key or type for cancellation/deletion.");
                console.error("handleCancelScheduledTask_ExtraPage: Missing taskKey or taskType.");
                return;
            }

            let taskCollection;
            let firebasePath;
            let taskDescription = "";
            let userFriendlyTaskName = "";

            if (taskType === 'deleteEntireRoute') {
                taskCollection = scheduledRouteDeletions_extra;
                firebasePath = FB_PATH_SCHEDULED_DELETIONS;
                taskDescription = "route deletion task";
                userFriendlyTaskName = "Scheduled Route Deletion";
            } else if (taskType === 'applySchedule') { // Assuming 'applySchedule' is the other type
                taskCollection = scheduledRouteUpdates_extra;
                firebasePath = FB_PATH_SCHEDULED_ROUTE_UPDATES;
                taskDescription = "schedule application task";
                userFriendlyTaskName = "Scheduled Timetable Update";
            } else {
                alert(`Error: Unknown task type "${taskType}" for cancellation/deletion.`);
                console.error(`handleCancelScheduledTask_ExtraPage: Unknown task type "${taskType}".`);
                return;
            }

            if (!taskCollection || !taskCollection[taskKey]) {
                alert(`Error: Task with key "${taskKey}" not found for type "${userFriendlyTaskName}". It might have already been processed or deleted. Please refresh the list.`);
                console.warn(`Task ${taskKey} of type ${taskType} not found in local cache:`, taskCollection);
                // Optionally, directly try to remove from Firebase if local cache is stale,
                // or just rely on refresh. For now, prompt refresh.
                loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh to sync state
                return;
            }

            const taskToCancel = taskCollection[taskKey];
            const routeNameForConfirm = taskToCancel.routeName || "Unknown Route";
            const goLiveForConfirm = taskToCancel.goLiveDateTime ? new Date(taskToCancel.goLiveDateTime).toLocaleString() : "Unknown Go-Live";

            let actionVerb = "DELETE RECORD of"; // Default for already applied/cancelled tasks
            if (taskToCancel.status === 'pending' || taskToCancel.status === 'error') {
                actionVerb = "CANCEL and DELETE record of";
            }

            if (!confirm(`Are you sure you want to ${actionVerb} the ${taskDescription} for route "${routeNameForConfirm}" (Go-Live: ${goLiveForConfirm})? This action cannot be undone.`)) {
                return;
            }

            const { database, dbRemove, dbRef } = window.firebaseOMSI;
            if (!database || !dbRemove || !dbRef) {
                alert("Firebase components not available. Cannot delete task.");
                console.error("handleCancelScheduledTask_ExtraPage: Firebase components missing.");
                return;
            }

            try {
                // Attempt to remove from Firebase
                await dbRemove(dbRef(database, `${firebasePath}/${taskKey}`));
                console.log(`Successfully removed task from Firebase: ${firebasePath}/${taskKey}`);

                // Remove from the correct local cache after successful Firebase deletion
                if (taskCollection && taskCollection[taskKey]) {
                    delete taskCollection[taskKey];
                }

                // Update UI - either directly manipulate the item or just refresh the whole list
                const listItemElement = document.querySelector(`.subsection[data-schedule-key="${taskKey}"]`);
                if (listItemElement) {
                    listItemElement.style.transition = 'opacity 0.5s ease-out';
                    listItemElement.style.opacity = '0';
                    setTimeout(() => {
                        listItemElement.remove();
                        // If the list becomes empty, show "No tasks" message
                        const listContainer = document.getElementById('sru-updates-list-container-extra');
                        if (listContainer && listContainer.children.length === 0) {
                            listContainer.innerHTML = '<p style="text-align:center; opacity:0.8;">No tasks currently scheduled.</p>';
                        }
                    }, 500);
                     // Optionally, show a temporary global status message
                    if (rsgStatusMessage_el_extra) { // Using RSG status for general messages if available
                        rsgStatusMessage_el_extra.textContent = `Task record for "${routeNameForConfirm}" deleted.`;
                        rsgStatusMessage_el_extra.style.color = "#2ecc71"; // Green for success
                        setTimeout(() => { if (rsgStatusMessage_el_extra.textContent === `Task record for "${routeNameForConfirm}" deleted.`) rsgStatusMessage_el_extra.textContent = ''; }, 3000);
                    } else {
                        alert(`Task record for "${routeNameForConfirm}" deleted.`);
                    }

                } else {
                    // If the element wasn't found (e.g., list re-rendered), refresh the whole list
                    loadAndDisplayScheduledUpdates_ExtraPage();
                }
                    checkAndDisplayDueUpdatesNotification_ExtraPage();

            } catch (error) {
                console.error(`Error deleting scheduled ${taskDescription} (key: ${taskKey}):`, error);
                alert(`Error deleting task record: ${error.message}. Please try refreshing the list.`);
                // Refresh the list on error to ensure UI consistency with backend state
                loadAndDisplayScheduledUpdates_ExtraPage();
            }
        }

        async function handleApplyScheduledRouteBatch_ExtraPage(tasksInBatch) {
    if (!currentUser_extra) {
        alert("Please log in to apply batch updates.");
        return;
    }
    if (!tasksInBatch || tasksInBatch.length === 0) {
        alert("No tasks provided for batch application.");
        return;
    }

    const representativeTask = tasksInBatch[0];
    const targetRouteName = representativeTask.routeName.toUpperCase();
    const goLiveDateTimeForDisplay = new Date(representativeTask.goLiveDateTime).toLocaleString();

    let allNewEntriesForRoute = [];
    let involvedProfiles = new Set();
    let involvedDestinations = new Set();
    let taskKeysInBatch = [];

    tasksInBatch.forEach(task => {
        if ((task.taskTypeDisplay === 'applySchedule' || task.taskType === 'applySchedule') && task.routeName.toUpperCase() === targetRouteName) {
            if (task.scheduledEntries && task.scheduledEntries.length > 0) {
                allNewEntriesForRoute.push(...JSON.parse(JSON.stringify(task.scheduledEntries)));
                involvedProfiles.add(task.operatingProfile);
                involvedDestinations.add(task.destinationName);
            }
            if (task.key) {
                taskKeysInBatch.push(task.key);
            }
        }
    });

    if (allNewEntriesForRoute.length === 0) {
        alert(`No actual schedule entries found within the selected batch for Route "${targetRouteName}". Cannot apply.`);
        return;
    }

    const profileList = Array.from(involvedProfiles).join(', ') || "N/A";
    const destList = Array.from(involvedDestinations).join(', ') || "N/A";

    const confirmMessage = `Apply BATCH update for Route: ${targetRouteName}\n` +
                         `Go-Live: ${goLiveDateTimeForDisplay}\n\n` +
                         `This batch includes ${tasksInBatch.length} update(s) which will define the following for this route:\n` +
                         `Operating Profile(s): ${profileList}\n` +
                         `Destination(s): ${destList}\n\n` +
                         `WARNING: This will DELETE ALL existing schedules for the ENTIRE Route "${targetRouteName}" (across all its current profiles and destinations).\n` +
                         `Then, ${allNewEntriesForRoute.length} new entries from this batch will be added, forming the new complete schedule for this route.\n\n` +
                         `Proceed with wiping the whole route and applying this batch?`;

    if (!confirm(confirmMessage)) {
        alert("Batch application cancelled by user.");
        return;
    }

    if (rsgStatusMessage_el_extra) {
        rsgStatusMessage_el_extra.textContent = `Processing batch for Route ${targetRouteName}... This may take a moment.`;
        rsgStatusMessage_el_extra.style.color = "#3498db";
    }

    const { database, dbRef, dbUpdate } = window.firebaseOMSI; 
    let removedCount = 0;

    currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
        const matchesRouteOnly = entry.lineName && entry.lineName.toUpperCase() === targetRouteName;
        if (matchesRouteOnly) {
            removedCount++;
            return false;
        }
        return true;
    });

    const entriesToAddWithUniqueIds = allNewEntriesForRoute.map((e, idx) => ({
        ...e,
        internalId: e.internalId || `${e.stopID}_${e.lineName}_${(e.scheduledTime||"0000").replace(':','')}_batchApply_${Date.now()}_${idx}`
    }));
    currentWorkingSchedule_extra.push(...entriesToAddWithUniqueIds);

    try {
        await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);

        const appliedAtTimestamp = new Date().toISOString();
        const appliedByEmail = currentUser_extra ? currentUser_extra.email : "system (batch)";
        
        let individualUpdateSuccessCount = 0;
        let individualUpdateFailureCount = 0;
        
        for (const taskKey of taskKeysInBatch) {
            if (!taskKey || typeof taskKey !== 'string' || taskKey.trim() === "") {
                individualUpdateFailureCount++;
                continue;
            }

            const taskNodeRef = dbRef(database, `${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`);
            const updatesForThisIndividualTask = {
                status: 'applied (batch)', 
                appliedAt: appliedAtTimestamp,             
                appliedBy: appliedByEmail                  
            };

            try {
                await dbUpdate(taskNodeRef, updatesForThisIndividualTask); 
                individualUpdateSuccessCount++;
            } catch (e) {
                individualUpdateFailureCount++;
            }
        }

        loadAndDisplayScheduledUpdates_ExtraPage();
        renderUIDependentElements_ExtraPage();

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Batch update for Route ${targetRouteName} applied successfully. Live schedule updated. Status update attempts: ${individualUpdateSuccessCount} success, ${individualUpdateFailureCount} fail.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
            setTimeout(() => { if (rsgStatusMessage_el_extra.textContent && rsgStatusMessage_el_extra.textContent.includes(`Batch update for Route ${targetRouteName}`)) rsgStatusMessage_el_extra.textContent = ''; }, 7000);
        } else {
            alert(`Batch update for Route ${targetRouteName} applied successfully. Live schedule updated. Status update attempts: ${individualUpdateSuccessCount} success, ${individualUpdateFailureCount} fail.`);
        }

    } catch (error) {
        alert(`Error applying batch update for Route "${targetRouteName}": ${error.message}. The live schedule may be in an inconsistent state. Review carefully.`);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error applying batch for Route ${targetRouteName}: ${error.message}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        
        taskKeysInBatch.forEach(taskKey => {
            if (taskKey && typeof taskKey === 'string' && taskKey.trim() !== "") {
                const taskErrorPath = `${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`;
                const errorUpdatesForThisTask = {
                    status: 'error',
                    lastError: `Batch Apply Error (Main Schedule): ${error.message}`
                };
                dbUpdate(dbRef(database, taskErrorPath), errorUpdatesForThisTask)
                    .catch(err => {});
            }
        });
        loadAndDisplayScheduledUpdates_ExtraPage(); 
    }
}

function rsg_updateRsgActionButtonsState() {
    const routeName = rsgRouteNameInput_el_extra.value.trim();
    const opProfiles = rsg_getSelectedOpProfilesString_ExtraPage();
    const destName = rsgDestinationNameInput_el_extra.value.trim();
    const firstStopTimes = rsgFirstStopTimesInput_el_extra.value.trim();
    // stopSequenceHasItems is no longer part of formIsComplete for enabling Generate button
    // const stopSequenceHasItems = rsg_selectedStops_extra && rsg_selectedStops_extra.length > 0;

    const formIsComplete = routeName && opProfiles && destName && firstStopTimes; // Removed stopSequenceHasItems
    const previewExists = rsg_generatedPreviewEntries_extra && rsg_generatedPreviewEntries_extra.length > 0;

    const tickedCheckboxes = document.querySelectorAll('.rsg-saved-config-checkbox:checked');
    const tickedSavedConfigsCount = tickedCheckboxes.length;
    const disableMainFormActionsDueToBatchSelection = tickedSavedConfigsCount > 1;

    let shouldGenerateButtonBeDisabled;
    let shouldSaveButtonBeDisabled;
    let shouldScheduleThisButtonBeDisabled;
    let shouldAddPreviewButtonBeDisabled;

    if (disableMainFormActionsDueToBatchSelection) {
        shouldGenerateButtonBeDisabled = true;
        shouldSaveButtonBeDisabled = true;
        shouldScheduleThisButtonBeDisabled = true;
        shouldAddPreviewButtonBeDisabled = true;
    } else {
        shouldGenerateButtonBeDisabled = !formIsComplete;
        shouldSaveButtonBeDisabled = !formIsComplete || !previewExists;
        shouldScheduleThisButtonBeDisabled = !formIsComplete || !previewExists;
        shouldAddPreviewButtonBeDisabled = !formIsComplete || !previewExists;
    }

    if (rsgGenerateScheduleButton_el_extra) {
        rsgGenerateScheduleButton_el_extra.disabled = shouldGenerateButtonBeDisabled;
    }

    if (rsgSaveConfigurationButton_el_extra) {
        rsgSaveConfigurationButton_el_extra.disabled = shouldSaveButtonBeDisabled;
    }

    if (rsgScheduleThisConfigButton_el_extra) {
        rsgScheduleThisConfigButton_el_extra.disabled = shouldScheduleThisButtonBeDisabled;
    }

    if (rsgAddToWorkingScheduleButton_el_extra) {
        rsgAddToWorkingScheduleButton_el_extra.disabled = shouldAddPreviewButtonBeDisabled;
        if (!shouldAddPreviewButtonBeDisabled) {
            rsgAddToWorkingScheduleButton_el_extra.classList.remove('neutral');
            rsgAddToWorkingScheduleButton_el_extra.classList.add('save');
        } else {
            rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
            rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
        }
    }

    if (rsgScheduleSelectedConfigsButton_el_extra) {
        rsgScheduleSelectedConfigsButton_el_extra.disabled = (tickedSavedConfigsCount === 0);
    }
}

        // ++ RSG Copy From Another Route Modal Functions ++
        function rsg_openCopyFromModal_ExtraPage() { 
            if (!rsgCopyModal_el_extra || !rsgCopySourceRouteNameSelect_el_extra || !rsgCopySourceDestNameSelect_el_extra || !rsgCopyModalStatus_el_extra) return; const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))].filter(Boolean).sort(compareLineNames_ExtraPage); rsgCopySourceRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route --</option>'; uniqueRoutes.forEach(route => { const opt = document.createElement('option'); opt.value = route; opt.textContent = route; rsgCopySourceRouteNameSelect_el_extra.appendChild(opt); }); if(rsgCopySourceRouteNameInput_el_extra) rsgCopySourceRouteNameInput_el_extra.value = ''; if(rsgCopySourceOpProfileInput_el_extra) rsgCopySourceOpProfileInput_el_extra.value = ''; if(rsgCopySourceDestNameInput_el_extra) rsgCopySourceDestNameInput_el_extra.value = ''; rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route First --</option>'; rsgCopyModalStatus_el_extra.textContent = ''; rsgCopyModal_el_extra.style.display = 'flex';
        }

        function rsg_closeCopyFromModal_ExtraPage() { 
             if (rsgCopyModal_el_extra) rsgCopyModal_el_extra.style.display = 'none';
        }

        function rsg_populateCopySourceDestinationSelect_ExtraPage() { 
            if (!rsgCopySourceDestNameSelect_el_extra || !rsgCopySourceDestNameInput_el_extra || !rsgCopySourceRouteNameInput_el_extra) return; const selectedRoute = rsgCopySourceRouteNameInput_el_extra.value.trim().toUpperCase(); rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Destination --</option>'; if (!selectedRoute) { rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route First --</option>'; return; } const uniqueDestinations = [...new Set(currentWorkingSchedule_extra.filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName).map(e => e.destinationName))].sort(); if (uniqueDestinations.length > 0) { uniqueDestinations.forEach(dest => { const opt = document.createElement('option'); opt.value = dest; opt.textContent = dest; rsgCopySourceDestNameSelect_el_extra.appendChild(opt); }); } else { rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- No Destinations for this Route --</option>';}
        }

        async function rsg_handleCopyDataFromSource_ExtraPage() {
    if (!rsgCopySourceRouteNameInput_el_extra || !rsgCopySourceOpProfileInput_el_extra || !rsgCopySourceDestNameInput_el_extra || !rsgCopyModalStatus_el_extra || !window.firebaseOMSI) {
        if (rsgCopyModalStatus_el_extra) {
            rsgCopyModalStatus_el_extra.textContent = "Error: Required elements for copy are missing.";
            rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
        }
        return;
    }
    const sourceRouteName = rsgCopySourceRouteNameInput_el_extra.value.trim();
    const sourceOpProfile = rsgCopySourceOpProfileInput_el_extra.value.trim();
    const sourceDestName = rsgCopySourceDestNameInput_el_extra.value.trim();

    if (!sourceRouteName || !sourceOpProfile || !sourceDestName) {
        rsgCopyModalStatus_el_extra.textContent = "All source fields (Route, Operating Profile, Destination) are required.";
        rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
        return;
    }

    rsgCopyModalStatus_el_extra.textContent = "Fetching source data...";
    rsgCopyModalStatus_el_extra.style.color = "#f1c40f";

    let sourceConfigData = null;
    let sourceStopSequence = [];
    let sourceFirstStopTimes = "";

    const sourceConfigKey = rsg_createConfigKey_ExtraPage(sourceRouteName, sourceOpProfile, sourceDestName);

    if (rsg_loadedConfigs_extra && rsg_loadedConfigs_extra[sourceConfigKey]) {
        sourceConfigData = rsg_loadedConfigs_extra[sourceConfigKey];
    }

    if (sourceConfigData) {
        sourceStopSequence = sourceConfigData.stopSequence || [];
        sourceFirstStopTimes = sourceConfigData.firstStopTimes || "";
    } else {
        const sourceRouteNameUpper = sourceRouteName.toUpperCase();
        const relevantEntries = currentWorkingSchedule_extra.filter(entry =>
            entry.lineName && entry.lineName.toUpperCase() === sourceRouteNameUpper &&
            entry.OperatingProfile === sourceOpProfile &&
            entry.destinationName === sourceDestName
        );

        if (relevantEntries.length > 0) {
            relevantEntries.sort((a, b) => {
                const absA = getAbsMinutes(a.scheduledTime, parseInt(a.DayOffset || 0));
                const absB = getAbsMinutes(b.scheduledTime, parseInt(b.DayOffset || 0));
                if (absA === null && absB === null) return 0;
                if (absA === null) return 1;
                if (absB === null) return -1;
                return absA - absB;
            });
            
            const firstTripSequence = [];
            if (relevantEntries.length > 0) {
                const firstStopIDOfJourney = relevantEntries[0].stopID;
                const firstDepartureTimeOfJourneyAbs = getAbsMinutes(relevantEntries[0].scheduledTime, parseInt(relevantEntries[0].DayOffset || 0));
                let absTimeOfPrevStopInSequence = -1; 
                const MIN_STOPS_BEFORE_START_ID_REPEAT_CONSIDERED_NEW_TRIP = 5; 

                for (let i = 0; i < relevantEntries.length; i++) {
                    const entry = relevantEntries[i];
                    if (!entry.stopID || !entry.scheduledTime) {
                        continue;
                    }
                    const currentTimeAbs = getAbsMinutes(entry.scheduledTime, parseInt(entry.DayOffset || 0));
                    if (currentTimeAbs === null) {
                        continue;
                    }
                    if (firstTripSequence.length > 0 && absTimeOfPrevStopInSequence !== -1) {
                        if (currentTimeAbs < absTimeOfPrevStopInSequence) {
                            break; 
                        }
                        if (entry.stopID === firstStopIDOfJourney) {
                            if (firstDepartureTimeOfJourneyAbs !== null && 
                                currentTimeAbs > (firstDepartureTimeOfJourneyAbs + 15) &&
                                firstTripSequence.length >= MIN_STOPS_BEFORE_START_ID_REPEAT_CONSIDERED_NEW_TRIP) {
                                break;
                            }
                        }
                    }
                    let calculatedTimeAdjustment = 0;
                    if (firstTripSequence.length > 0 && absTimeOfPrevStopInSequence !== -1) {
                        calculatedTimeAdjustment = currentTimeAbs - absTimeOfPrevStopInSequence;
                        if (calculatedTimeAdjustment < 0) { 
                            calculatedTimeAdjustment = 2;
                        } else if (calculatedTimeAdjustment > 180) {
                            calculatedTimeAdjustment = 60; 
                        }
                    }
                    firstTripSequence.push({ 
                        stopID: entry.stopID, 
                        stopName: entry.stopName || entry.stopID, 
                        direction: entry.direction || "",    
                        timeAdjustment: calculatedTimeAdjustment
                    }); 
                    absTimeOfPrevStopInSequence = currentTimeAbs;
                }
            }
            sourceStopSequence = firstTripSequence;

            if (sourceStopSequence.length > 0) {
                const firstStopIdInPulledSequence = sourceStopSequence[0].stopID;
                const departuresForFirstStop = [...new Set(
                    relevantEntries
                        .filter(e => e.stopID === firstStopIdInPulledSequence && (e.DayOffset === "0" || !e.DayOffset))
                        .map(e => e.scheduledTime)
                        .filter(t => t && t.match(/^\d{2}:\d{2}$/))
                )].sort((a,b) => parseInt(a.replace(':','')) - parseInt(b.replace(':','')));
                sourceFirstStopTimes = departuresForFirstStop.join('\t'); 
            }
        }
    }

    if (sourceStopSequence.length > 0) {
        rsg_selectedStops_extra = JSON.parse(JSON.stringify(sourceStopSequence));
        if (rsgFirstStopTimesInput_el_extra) {
            rsgFirstStopTimesInput_el_extra.value = sourceFirstStopTimes;
        }
        rsg_renderStopSequence_ExtraPage();
        rsg_lastLoadedRouteName_extra = rsgRouteNameInput_el_extra.value.trim(); 
        rsg_lastLoadedDestName_extra = rsgDestinationNameInput_el_extra.value.trim();   
        rsg_lastLoadedOpProfile_extra = rsg_getSelectedOpProfilesString_ExtraPage(); 
        rsg_currentlyEditingConfigKey_extra = null; 
        rsg_currentlyEditingConfigDisplayName_extra = null;
        rsg_isDirty = true;

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Sequence and times successfully copied from source [${sourceRouteName} / ${sourceOpProfile} / ${sourceDestName}]. Please review and save if needed.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
        }
        rsg_resetPreviewState("Data copied from source. Regenerate preview if settings are complete.", "success");
        rsg_closeCopyFromModal_ExtraPage();
    } else {
        rsgCopyModalStatus_el_extra.textContent = `No sequence data found or derived for source: ${sourceRouteName} (Profile: ${sourceOpProfile}, Dest: ${sourceDestName}). Nothing copied.`;
        rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
    }
    rsg_updateRsgActionButtonsState(); // Added call
}

        function showExtraPageSection(sectionId) {
    if (!toolSectionsWrapper_el_extra) {
        return;
    }

    const allSections = toolSectionsWrapper_el_extra.querySelectorAll('.tool-content-section');
    allSections.forEach(s => {
        s.style.display = 'none';
    });

    const sectionToShow = document.getElementById(sectionId);
    if (sectionToShow) {
        sectionToShow.style.display = 'block';
        localStorage.setItem('omsiExtraToolsActiveSection', sectionId);

        if (sectionId === 'day-profile-override-section_extra') {
            loadAndDisplayOverrides_ExtraPage();
            dpo_populateProfileCheckboxes_ExtraPage();
            updateSelectedDateInfo_ExtraPage();
        } else if (sectionId === 'stop-manager-tool-section_extra') {
            populateMasterStopList_ExtraPage();
            if (inputNewStopName_el_extra && inputNewStopId_el_extra && !inputNewStopName_el_extra.value && !inputNewStopId_el_extra.value) {
                autoGenerateAndSetNewStopId_ExtraPage();
            }
            if(duplicateStopsByNameDirResults_el_extra) duplicateStopsByNameDirResults_el_extra.innerHTML = 'Click "Find Duplicates (Name/Dir)" to check.';
        } else if (sectionId === 'global-route-deletion-section_extra') {
            populateGlobalRouteToDeleteList_ExtraPage();
        } else if (sectionId === 'route-schedule-generator-section_extra') {
            rsg_populateProfileCheckboxes_ExtraPage(); 
            rsg_populateRouteSelect_ExtraPage(); 
            if (typeof rsg_renderSavedConfigsList_ExtraPage === 'function') {
                rsg_renderSavedConfigsList_ExtraPage(); 
            }
            if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') {
                 rsg_loadOrPullConfiguration_ExtraPage(null, true);
            }
            rsg_updateRsgActionButtonsState(); // Added call
        } else if (sectionId === 'route-profile-deletion-section_extra') {
            rpd_populateRouteSelect_ExtraPage();
        } else if (sectionId === "service-analyzer-section_extra") {
            onShowServiceAnalyzerSection_ExtraPage();
        } else if (sectionId === 'timetable-exporter-section_extra') {
            populateTimetableExporterRouteSelect_ExtraPage();
            if (tteRouteNameInput_el_extra) tteRouteNameInput_el_extra.value = '';
            if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = 'Select a route to download its timetable.';
        } else if (sectionId === 'scheduled-route-updates-section_extra') {
            loadAndDisplayScheduledUpdates_ExtraPage();
        } else if (sectionId === 'scheduled-route-deletion-section_extra') { 
            srd_populateRouteSelect_ExtraPage(); 
            if (srdGoLiveDateTimeInput_el_extra) srdGoLiveDateTimeInput_el_extra.value = ''; 
            if (srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = 'Select a route and future date/time for deletion.'; 
        }
    }
}

        function updateAuthUI_ExtraPage(user) { 
            currentUser_extra = user; if (user) { if(authSection_el_extra) authSection_el_extra.style.display = 'none'; if(topMenuBar_el_extra) topMenuBar_el_extra.style.display = 'block'; if(logoutContainer_el_extra) logoutContainer_el_extra.style.display = 'block'; if(loginFormContainer_el_extra) loginFormContainer_el_extra.style.display = 'none'; if(authStatus_el_extra) authStatus_el_extra.textContent = ''; if(loggedInUserEmailDisplay_el_extra) loggedInUserEmailDisplay_el_extra.textContent = user.email; if(currentProfileDisplayContainer_el) currentProfileDisplayContainer_el.style.display = 'block'; loadInitialData_ExtraPage(); const lastSection = localStorage.getItem('omsiExtraToolsActiveSection'); const firstButton = topMenuBar_el_extra.querySelector('.menu-button'); if (lastSection && document.getElementById(lastSection) && Array.from(topMenuBar_el_extra.querySelectorAll('.menu-button')).some(b => b.dataset.section === lastSection) ) showExtraPageSection(lastSection); else if (firstButton && firstButton.dataset.section) showExtraPageSection(firstButton.dataset.section); } else { if(authSection_el_extra) authSection_el_extra.style.display = 'block'; if(topMenuBar_el_extra) topMenuBar_el_extra.style.display = 'none'; if(logoutContainer_el_extra) logoutContainer_el_extra.style.display = 'none'; if(loginFormContainer_el_extra) loginFormContainer_el_extra.style.display = 'block'; if(authStatus_el_extra) authStatus_el_extra.textContent = 'Please log in.'; if(loggedInUserEmailDisplay_el_extra) loggedInUserEmailDisplay_el_extra.textContent = ''; if(currentProfileDisplayContainer_el) currentProfileDisplayContainer_el.style.display = 'none'; if(toolSectionsWrapper_el_extra) toolSectionsWrapper_el_extra.querySelectorAll('.tool-content-section').forEach(s => s.style.display = 'none'); currentWorkingSchedule_extra = []; closedStopIDs_extra = []; globalCustomRouteColours_extra = {}; stopSpecificRouteColours_extra = {}; pageSpecificSettings = {}; rsg_loadedConfigs_extra = {}; rsg_lastLoadedRouteName_extra = null; rsg_lastLoadedDestName_extra = null; rsg_lastLoadedOpProfile_extra = null; renderUIDependentElements_ExtraPage(); }
        }
        
async function loadInitialData_ExtraPage() {
            let msg = "Loading data for Extra Modules (enhanced for all stops)...";
            console.log(msg);

            currentWorkingSchedule_extra = [];
            closedStopIDs_extra = [];
            globalCustomRouteColours_extra = {};
            stopSpecificRouteColours_extra = {};
            rsg_loadedConfigs_extra = {};
            if (typeof scheduledRouteDeletions_extra === 'undefined') {
                scheduledRouteDeletions_extra = {};
            }
            if (typeof scheduledRouteUpdates_extra === 'undefined') {
                scheduledRouteUpdates_extra = {};
            }

            if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
                msg = "Firebase not connected for Extra Modules.";
                console.error(msg);
                renderUIDependentElements_ExtraPage();
                return;
            }

            const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
            try {
                const scheduleSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULES_BY_ROUTE));
                const flatScheduleFromDB = [];
                if (scheduleSnap.exists()) {
                    const schedulesByRoute = scheduleSnap.val();
                    for (const routeKey in schedulesByRoute) {
                        const routeData = schedulesByRoute[routeKey];
                        for (const profileKey in routeData) {
                            const profileData = routeData[profileKey];
                            for (const destKey in profileData) {
                                const destData = profileData[destKey];
                                if (destData && Array.isArray(destData.entries)) {
                                    destData.entries.forEach(entry => {
                                        flatScheduleFromDB.push({ ...entry });
                                    });
                                }
                            }
                        }
                    }
                }
                currentWorkingSchedule_extra = flatScheduleFromDB.map((e,i)=>({...e, internalId: e.internalId || `${(e.stopID||'s')}_${(e.lineName||'l')}_${(e.scheduledTime||"").replace(':','')}_${i}_fbloadX_flat`}));
                console.log(`Extra Tools: Loaded ${currentWorkingSchedule_extra.length} entries from structured schedule data (schedulesByRoute).`);

                const uniqueStopsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_UNIQUE_STOPS));
                const firebaseUniqueStops = uniqueStopsSnap.exists() && Array.isArray(uniqueStopsSnap.val()) ? uniqueStopsSnap.val() : [];
                console.log(`Extra Tools: Fetched ${firebaseUniqueStops.length} stops from uniqueBusStops list.`);

                const stopIDsAlreadyInScheduleFromRoutes = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase()));

                firebaseUniqueStops.forEach(fbStop => {
                    if (fbStop && fbStop.stopID && !stopIDsAlreadyInScheduleFromRoutes.has(fbStop.stopID.toUpperCase())) {
                        currentWorkingSchedule_extra.push({
                            internalId: `${fbStop.stopID}_definition_fbloadX_${Date.now()}`,
                            stopID: fbStop.stopID,
                            stopName: fbStop.stopName || "Unknown Stop Name",
                            direction: fbStop.direction || ""
                        });
                        // console.log(`Extra Tools: Added definition for stop ${fbStop.stopID} (from uniqueBusStops) to local working schedule.`); // Optional log
                    }
                });

                // --- START: Populate stopToServingRoutesMap_extra ---
                console.log("Pre-calculating stop to serving routes map...");
                stopToServingRoutesMap_extra.clear();
                currentWorkingSchedule_extra.forEach(entry => {
                    if (entry.stopID && entry.lineName && entry.lineName.trim() !== "") {
                        if (!stopToServingRoutesMap_extra.has(entry.stopID)) {
                            stopToServingRoutesMap_extra.set(entry.stopID, new Set());
                        }
                        stopToServingRoutesMap_extra.get(entry.stopID).add(entry.lineName);
                    }
                });
                console.log(`Stop to serving routes map calculated. ${stopToServingRoutesMap_extra.size} stops mapped.`);
                // --- END: Populate stopToServingRoutesMap_extra ---

                const closedSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_CLOSED_STOPS));
                if (closedSnap.exists()) {
                    const fbC = closedSnap.val();
                    closedStopIDs_extra = Object.keys(fbC).filter(id => fbC[id] === true).map(id => id.toUpperCase());
                } else {
                    closedStopIDs_extra = [];
                }

                const globalCSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS));
                globalCustomRouteColours_extra = globalCSnap.exists() ? globalCSnap.val() || {} : {};

                const stopSpecificCSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS));
                stopSpecificRouteColours_extra = stopSpecificCSnap.exists() ? stopSpecificCSnap.val() || {} : {};

                const rsgConfigsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_RSG_CONFIGS));
                rsg_loadedConfigs_extra = rsgConfigsSnap.exists() ? rsgConfigsSnap.val() || {} : {};
                
                msg = `Extra Modules: Data loaded. Working schedule has ${currentWorkingSchedule_extra.length} items. ${closedStopIDs_extra.length} closed. ${Object.keys(rsg_loadedConfigs_extra).length} RSG configs.`;
            } catch (error) {
                console.error("Firebase Load Error (Extra Tools):", error);
                msg = "Error loading data (Extra Tools): " + error.message;
                currentWorkingSchedule_extra = [];
                closedStopIDs_extra = [];
                globalCustomRouteColours_extra = {};
                stopSpecificRouteColours_extra = {};
                rsg_loadedConfigs_extra = {};
                scheduledRouteUpdates_extra = {};
                scheduledRouteDeletions_extra = {};
                stopToServingRoutesMap_extra.clear(); // Clear map on error too
            }
            
            console.log(msg);

            if (typeof fetchBankHolidays_ExtraPage === 'function') {
                await fetchBankHolidays_ExtraPage(); // Await completion
            }
            
            // updateCurrentProfileDisplay_ExtraPage is called after bank holidays are potentially fetched
            if (typeof updateCurrentProfileDisplay_ExtraPage === 'function') {
                await updateCurrentProfileDisplay_ExtraPage();
            }
            
            // renderUIDependentElements_ExtraPage is called last to update UI with all loaded data
            renderUIDependentElements_ExtraPage();
            
            // *** ADD THIS LINE ***
            checkAndDisplayDueUpdatesNotification_ExtraPage(); 
        }

        function renderUIDependentElements_ExtraPage() { 
            const activeSectionId = localStorage.getItem('omsiExtraToolsActiveSection'); 
            const activeSectionElement = activeSectionId ? document.getElementById(activeSectionId) : null; 
            if (activeSectionElement && activeSectionElement.style.display === 'block') { 
                 showExtraPageSection(activeSectionId); // Re-run the show function to refresh content
            } else if (!activeSectionId && topMenuBar_el_extra && topMenuBar_el_extra.querySelector('.menu-button')) { 
                // If no active section is stored or visible, attempt to show the first one if user is logged in
                 if(currentUser_extra) {
                    const firstButton = topMenuBar_el_extra.querySelector('.menu-button');
                    if (firstButton && firstButton.dataset.section) {
                         showExtraPageSection(firstButton.dataset.section);
                    }
                }
            } 
        }

        // --- DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', () => { 
            console.log("OMSI Tools Extra DOMContentLoaded"); updateAuthUI_ExtraPage(null); 

            function initializeExtraAppLogic() { 
                console.log("Firebase ready, Extra app logic init."); 
                const { auth, authOnAuthStateChanged, authSignInWithEmailAndPassword, authSignOut } = window.firebaseOMSI; 
                authOnAuthStateChanged(auth, user => { updateAuthUI_ExtraPage(user); if (user && selectNewStopIdFormat_el_extra && inputNewStopName_el_extra && inputNewStopId_el_extra && !inputNewStopName_el_extra.value && !inputNewStopId_el_extra.value) { autoGenerateAndSetNewStopId_ExtraPage(); } }); 
                if (adminLoginForm_el_extra && inputEmail_el_extra && inputPassword_el_extra && authStatus_el_extra) { adminLoginForm_el_extra.addEventListener('submit', (e) => { e.preventDefault(); authStatus_el_extra.textContent = 'Logging in...'; authSignInWithEmailAndPassword(auth, inputEmail_el_extra.value, inputPassword_el_extra.value) .catch(err => { authStatus_el_extra.textContent = `Login Error: ${err.message}`; }); }); } 
                const logoutButton = logoutContainer_el_extra.querySelector('button'); 
                if (logoutButton) logoutButton.addEventListener('click', () => { localStorage.removeItem('omsiExtraToolsActiveSection'); authSignOut(auth).catch(e => console.error("Sign-out error (Extra):", e)); }); 
            } 

const dpoClearProfilesBtn = document.getElementById('dpo-clear-profile-checkboxes-button-extra');
if (dpoClearProfilesBtn) {
    dpoClearProfilesBtn.addEventListener('click', dpo_clearProfileSelections_ExtraPage);
}

if (rsgFirstStopTimesInput_el_extra) {
                rsgFirstStopTimesInput_el_extra.addEventListener('input', () => { 
                    rsg_isDirty = true; 
                    console.log(`RSG User Edit: First stop times input changed. rsg_isDirty is true. Value: "${rsgFirstStopTimesInput_el_extra.value}"`);
                });
            }

const rsgPullFirstStopTimesButton = document.getElementById('rsg-pull-first-stop-times-button-extra');
            if (rsgPullFirstStopTimesButton) {
                rsgPullFirstStopTimesButton.addEventListener('click', rsg_pullCurrentFirstStopTimes_ExtraPage);
            }

const rsgScheduleSelectedBtn = document.getElementById('rsg-schedule-selected-configs-button-extra');
if (rsgScheduleSelectedBtn) {
    rsgScheduleSelectedBtn.addEventListener('click', rsg_handleScheduleSelectedConfigs_ExtraPage);
}

const rsgSelectAllGlobalCheckbox = document.getElementById('rsg-select-all-configs-checkbox-extra');
if (rsgSelectAllGlobalCheckbox) {
    rsgSelectAllGlobalCheckbox.addEventListener('change', rsg_handleSelectAllConfigsChange_ExtraPage);
}

if (sruApplyAllForTimeButton_el_extra) {
    sruApplyAllForTimeButton_el_extra.addEventListener('click', handleApplyAllBatchesForSelectedTime_ExtraPage);
}

if (sruCancelModalConfirmButton_el_extra && sruCancelModalCancelButton_el_extra && sruCancelModalSelectAllCheckbox_el_extra && sruCancelModalCheckboxesContainer_el_extra) {
        
        sruCancelModalConfirmButton_el_extra.addEventListener('click', () => {
            if (typeof sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage === 'function') {
                sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage();
            } else {
                console.error("sru_executeCancelRouteUpdatesForSelectedTimes_ExtraPage function not found");
            }
        });
        
        sruCancelModalCancelButton_el_extra.addEventListener('click', () => {
            if (typeof sru_closeCancelRouteTimeSelectModal_ExtraPage === 'function') {
                sru_closeCancelRouteTimeSelectModal_ExtraPage();
            } else {
                console.error("sru_closeCancelRouteTimeSelectModal_ExtraPage function not found");
            }
        });

        sruCancelModalSelectAllCheckbox_el_extra.addEventListener('change', (event) => {
            const isChecked = event.target.checked;
            const timeCheckboxes = sruCancelModalCheckboxesContainer_el_extra.querySelectorAll('input[type="checkbox"][name="sruCancelSelectedGoLiveTimeCheckbox_extra"]');
            timeCheckboxes.forEach(cb => {
                cb.checked = isChecked;
            });
            // Enable/disable confirm button based on whether any checkbox is checked
            const anyChecked = Array.from(timeCheckboxes).some(cb => cb.checked);
            if(sruCancelModalConfirmButton_el_extra) sruCancelModalConfirmButton_el_extra.disabled = !anyChecked;
        });
        
        // Optional: Close modal if clicking outside content (if modal element exists)
        if (sruCancelRouteTimeSelectModal_el_extra) {
            sruCancelRouteTimeSelectModal_el_extra.addEventListener('click', (event) => {
                if (event.target === sruCancelRouteTimeSelectModal_el_extra) { // Only if overlay itself is clicked
                    if (typeof sru_closeCancelRouteTimeSelectModal_ExtraPage === 'function') {
                        sru_closeCancelRouteTimeSelectModal_ExtraPage();
                    }
                }
            });
        }
    } else {
        console.warn("SRU Cancel Modal: One or more button/checkbox elements for the cancel modal were not found. Listeners not fully attached.");
    }

    // For the Global "Cancel ALL Pending Updates" Button
    if (sruCancelAllPendingUpdatesGloballyButton_el_extra) {
        sruCancelAllPendingUpdatesGloballyButton_el_extra.addEventListener('click', () => {
            if (typeof handleCancelAllUpdatesAllRoutes_Global === 'function') {
                handleCancelAllUpdatesAllRoutes_Global();
            } else {
                console.error("handleCancelAllUpdatesAllRoutes_Global function not found");
            }
        });
    } else {
        console.warn("SRU Global Cancel Button: Element not found. Listener not attached.");
    }

// ... (other listeners) ...

            // Inside DOMContentLoaded
// ...
if (rsgFirstStopTimesInput_el_extra) {
    rsgFirstStopTimesInput_el_extra.addEventListener('input', () => { 
        rsg_isDirty = true; 
        // ADD/ENSURE THIS CALL IS PRESENT:
        rsg_updateRsgActionButtonsState();
    });
    // The keydown listener for Tab should remain as it is,
    // as its 'input' event dispatch will trigger the above listener.
    rsgFirstStopTimesInput_el_extra.addEventListener('keydown', function(event) {
        if (event.key === 'Tab') {
            event.preventDefault();
            let start = this.selectionStart;
            let end = this.selectionEnd;
            this.value = this.value.substring(0, start) + '\t' + this.value.substring(end);
            this.selectionStart = this.selectionEnd = start + 1;
            const inputEvent = new Event('input', { bubbles: true, cancelable: true });
            this.dispatchEvent(inputEvent);
        }
    });
}

// Inside DOMContentLoaded, where other listeners are set up

if (srdRouteNameSelect_el_extra && srdRouteNameInput_el_extra) {
    srdRouteNameSelect_el_extra.addEventListener('change', () => {
        if (srdRouteNameInput_el_extra) {
            srdRouteNameInput_el_extra.value = srdRouteNameSelect_el_extra.value;
        }
        if (srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = '';
    });
    srdRouteNameInput_el_extra.addEventListener('input', () => {
        const typedValue = srdRouteNameInput_el_extra.value.trim().toUpperCase();
        let matchedSelectValue = "";
        if (srdRouteNameSelect_el_extra) {
            const matchedOption = Array.from(srdRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedValue);
            if (matchedOption) {
                matchedSelectValue = matchedOption.value;
            }
            if (srdRouteNameSelect_el_extra.value !== matchedSelectValue) {
                 srdRouteNameSelect_el_extra.value = matchedSelectValue;
            }
        }
        if (srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = '';
    });
}
if (srdScheduleDeletionButton_el_extra) {
    srdScheduleDeletionButton_el_extra.addEventListener('click', srd_confirmAndScheduleDeletion_ExtraPage);
}

// Scheduled Route Updates (SRU) Listeners
            const sruRefreshButton = document.getElementById('sru-refresh-list-button-extra');
            if (sruRefreshButton) {
                sruRefreshButton.addEventListener('click', loadAndDisplayScheduledUpdates_ExtraPage);
            }

// Timetable Exporter Listeners
if (tteRouteNameSelect_el_extra && tteRouteNameInput_el_extra) {
    tteRouteNameSelect_el_extra.addEventListener('change', () => {
        if (tteRouteNameInput_el_extra) { // Ensure input exists
            tteRouteNameInput_el_extra.value = tteRouteNameSelect_el_extra.value;
        }
        if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = ''; // Clear status on new selection
    });
    tteRouteNameInput_el_extra.addEventListener('input', () => {
        const typedValue = tteRouteNameInput_el_extra.value.trim().toUpperCase();
        let matchedSelectValue = "";
        if (tteRouteNameSelect_el_extra) {
            const matchedOption = Array.from(tteRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedValue);
            if (matchedOption) {
                matchedSelectValue = matchedOption.value;
            }
            // Only update if the value actually changes to avoid potential loops if 'input' also triggers 'change'
            if (tteRouteNameSelect_el_extra.value !== matchedSelectValue) {
                 tteRouteNameSelect_el_extra.value = matchedSelectValue;
            }
        }
        if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = '';
    });
}
if (tteDownloadTimetableButton_el_extra) {
    tteDownloadTimetableButton_el_extra.addEventListener('click', handleDownloadTimetable_ExtraPage);
}
            if (window.firebaseOMSI && window.firebaseOMSI.auth) { initializeExtraAppLogic(); } 
            else { document.addEventListener('firebaseReady', () => { if (window.firebaseOMSI && window.firebaseOMSI.auth) { initializeExtraAppLogic(); } else { console.error("Extra Tools: Firebase still not ready after event!"); } }, { once: true }); } 
            
            const menuButtons = topMenuBar_el_extra.querySelectorAll('.menu-button'); 
            menuButtons.forEach(button => button.addEventListener('click', () => { if (currentUser_extra) showExtraPageSection(button.dataset.section); else alert("Please log in."); })); 

// Timetable Exporter Listeners
if (tteRouteNameSelect_el_extra && tteRouteNameInput_el_extra) {
        tteRouteNameSelect_el_extra.addEventListener('change', () => {
            if (tteRouteNameInput_el_extra) {
                tteRouteNameInput_el_extra.value = tteRouteNameSelect_el_extra.value;
            }
            if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = '';
        });
        tteRouteNameInput_el_extra.addEventListener('input', () => { // Using 'input' for more responsive sync
            const typedValue = tteRouteNameInput_el_extra.value.trim().toUpperCase();
            let matchedSelectValue = "";
            if (tteRouteNameSelect_el_extra) {
                const matchedOption = Array.from(tteRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedValue);
                if (matchedOption) {
                    matchedSelectValue = matchedOption.value;
                }
                if (tteRouteNameSelect_el_extra.value !== matchedSelectValue) {
                     tteRouteNameSelect_el_extra.value = matchedSelectValue;
                }
            }
            if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = '';
        });
    }
    if (tteDownloadTimetableButton_el_extra) {
        tteDownloadTimetableButton_el_extra.addEventListener('click', handleDownloadTimetable_ExtraPage);
    }
            
            // Day Profile Override Listeners
            if(overrideDateInput_el_extra) overrideDateInput_el_extra.addEventListener('change', updateSelectedDateInfo_ExtraPage); 
            if(setOverrideButton_el_extra) setOverrideButton_el_extra.addEventListener('click', handleSetOverride_ExtraPage); 
            if(clearOverrideButton_el_extra) clearOverrideButton_el_extra.addEventListener('click', handleClearOverride_ExtraPage); 
            
            // Stop Management Listeners
            if (inputNewStopName_el_extra) inputNewStopName_el_extra.addEventListener('input', autoGenerateAndSetNewStopId_ExtraPage); 
            if (inputNewStopId_el_extra && newStopIdAvailability_el_extra) { inputNewStopId_el_extra.addEventListener('input', () => { const newStopId = inputNewStopId_el_extra.value.trim().toUpperCase(); if (!newStopId) { newStopIdAvailability_el_extra.textContent = ''; return; } if (!/^[A-Z0-9]+$/.test(newStopId)) { newStopIdAvailability_el_extra.textContent = 'ID invalid chars.'; newStopIdAvailability_el_extra.style.color = '#e74c3c'; return; } const existingStopIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase())); if (existingStopIDs.has(newStopId)) { newStopIdAvailability_el_extra.textContent = 'ID already exists!'; newStopIdAvailability_el_extra.style.color = '#e74c3c'; } else { newStopIdAvailability_el_extra.textContent = 'ID available.'; newStopIdAvailability_el_extra.style.color = '#2ecc71'; } }); } 
            if (buttonAddNewStop_el_extra) buttonAddNewStop_el_extra.addEventListener('click', handleAddStopDetails_ExtraPage); 
            if (fileInputBulkAddStops_el_extra) fileInputBulkAddStops_el_extra.addEventListener('change', handleExcelFileForBulkAdd_ExtraPage); 
            if (buttonBulkAddNewStops_el_extra) buttonBulkAddNewStops_el_extra.addEventListener('click', handleBulkAddStops_ExtraPage); 
            if(masterStopListFilterInput_el_extra) masterStopListFilterInput_el_extra.addEventListener('input', populateMasterStopList_ExtraPage); 
            if(refreshMasterStopListButton_el_extra) refreshMasterStopListButton_el_extra.addEventListener('click', ()=>{ loadInitialData_ExtraPage().then(()=>populateMasterStopList_ExtraPage()); }); 
            if(applyMasterListStopIdChangesButton_el_extra) applyMasterListStopIdChangesButton_el_extra.addEventListener('click', handleApplyMasterListStopIdChangesButton_ExtraPage); 
            if(exportUniqueStopsButton_el_extra) exportUniqueStopsButton_el_extra.addEventListener('click', () => { if (!currentUser_extra) { alert("Log in to export."); return; } const uniqueStops = getUniqueStopsFromSchedule_ExtraPage(); if (uniqueStops.length === 0) { alert("No unique stops to export."); return; } const dataToExport = uniqueStops.map(stop => { const servingLineNames = new Set(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === stop.stopID && entry.lineName && entry.lineName.trim() !== "" && entry.lineName.toUpperCase() !== "INFO_ONLY") servingLineNames.add(entry.lineName); }); return { "StopID": stop.stopID, "StopName": stop.stopName, "Direction": stop.direction, "LineName(s)": Array.from(servingLineNames).sort(compareLineNames_ExtraPage).join(', ') }; }); const headers = ["StopID", "StopName", "Direction", "LineName(s)"]; const worksheetData = [ headers, ...dataToExport.map(row => headers.map(header => row[header])) ]; const worksheet = XLSX.utils.aoa_to_sheet(worksheetData); const workbook = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(workbook, worksheet, "OMSI Bus Stops"); XLSX.writeFile(workbook, "OMSI_Bus_Stops_Extra.xlsx"); }); 
            if(findDuplicateStopsByNameDirButton_el_extra) findDuplicateStopsByNameDirButton_el_extra.addEventListener('click', findDuplicateStopsByNameAndDirection_ExtraPage); 
            
            // Global Route Deletion Listeners
            if(deleteEntireRouteButton_el_extra) deleteEntireRouteButton_el_extra.addEventListener('click', handleDeleteEntireRouteGlobally_ExtraPage); 
            
            // Route Profile Deletion (RPD) Listeners
            if (rpdRouteSelect_el_extra) rpdRouteSelect_el_extra.addEventListener('change', rpd_handleRouteNameSelectChange_ExtraPage);
            if (rpdRouteInput_el_extra) rpdRouteInput_el_extra.addEventListener('blur', rpd_handleRouteNameInputChange_ExtraPage); // Changed to blur for better UX with select sync
            if (rpdDestinationSelect_el_extra) rpdDestinationSelect_el_extra.addEventListener('change', rpd_handleDestinationNameSelectChange_ExtraPage);
            if (rpdDestinationInput_el_extra) rpdDestinationInput_el_extra.addEventListener('blur', rpd_handleDestinationNameInputChange_ExtraPage); // Changed to blur
            if (rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.addEventListener('click', rpd_handleClearDestination_ExtraPage);
            if (rpdDeleteProfilesButton_el_extra) rpdDeleteProfilesButton_el_extra.addEventListener('click', handleDeleteRouteProfiles_ExtraPage);

            // Route Schedule Generator (RSG) Listeners
            if (rsgRouteNameSelect_el_extra) rsgRouteNameSelect_el_extra.addEventListener('change', () => { rsg_handleRouteNameSelectChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgRouteNameInput_el_extra) rsgRouteNameInput_el_extra.addEventListener('blur', () => { rsg_handleRouteNameInputChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgDestinationNameSelect_el_extra) rsgDestinationNameSelect_el_extra.addEventListener('change', () => { rsg_handleDestinationNameSelectChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgDestinationNameInput_el_extra) rsgDestinationNameInput_el_extra.addEventListener('blur', () => { rsg_handleDestinationNameInputChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgStopSearchInput_el_extra) rsgStopSearchInput_el_extra.addEventListener('input', rsg_handleStopSearch_ExtraPage); 
            if (rsgGenerateScheduleButton_el_extra) rsgGenerateScheduleButton_el_extra.addEventListener('click', () => rsg_handleGenerateSchedulePreview_ExtraPage(false)); 
            if (rsgSaveConfigurationButton_el_extra) rsgSaveConfigurationButton_el_extra.addEventListener('click', rsg_handleSaveConfiguration_ExtraPage);
if (rsgAddToWorkingScheduleButton_el_extra) {
            rsgAddToWorkingScheduleButton_el_extra.addEventListener('click', rsg_handleAddGeneratedToWorkingSchedule_ExtraPage);
        } 
            
if (rsgAddToWorkingScheduleButton_el_extra) {
    rsgAddToWorkingScheduleButton_el_extra.disabled = true;
    rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
    rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
}
// --- NEW LISTENERS FOR "SCHEDULE THIS CONFIGURATION" ---
            
            if (rsgScheduleThisConfigButton_el_extra) {
                rsgScheduleThisConfigButton_el_extra.addEventListener('click', handleScheduleThisConfiguration);
            }

            if (rsgScheduleDateTimeConfirmBtn) {
                rsgScheduleDateTimeConfirmBtn.addEventListener('click', rsg_confirmScheduleGoLive_ExtraPage);
            }

            if (rsgScheduleDateTimeCancelBtn) {
                rsgScheduleDateTimeCancelBtn.addEventListener('click', rsg_closeScheduleDateTimeModal_ExtraPage);
            }
            
            // Close modal if clicking outside content for rsg-schedule-datetime-modal-extra
            if (rsgScheduleDateTimeModal) {
                rsgScheduleDateTimeModal.addEventListener('click', (event) => {
                    if (event.target === rsgScheduleDateTimeModal) { // Only if overlay itself is clicked
                        rsg_closeScheduleDateTimeModal_ExtraPage();
                    }
                });
            }

if (rsgFirstStopTimesInput_el_extra) {
                rsgFirstStopTimesInput_el_extra.addEventListener('input', () => { 
                    rsg_isDirty = true; 
                    console.log("RSG dirty: First stop times input changed.");
                });
            }
            // --- END OF NEW LISTENERS --- 
            if(rsgOpenCopyModalButton_el_extra) rsgOpenCopyModalButton_el_extra.addEventListener('click', rsg_openCopyFromModal_ExtraPage); 
            if(rsgCopyModalCancelButton_el_extra) rsgCopyModalCancelButton_el_extra.addEventListener('click', rsg_closeCopyFromModal_ExtraPage); 
            if(rsgCopyModalActionButton_el_extra) rsgCopyModalActionButton_el_extra.addEventListener('click', rsg_handleCopyDataFromSource_ExtraPage); 
            if(rsgCopySourceRouteNameSelect_el_extra) { rsgCopySourceRouteNameSelect_el_extra.addEventListener('change', () => { if(rsgCopySourceRouteNameInput_el_extra) rsgCopySourceRouteNameInput_el_extra.value = rsgCopySourceRouteNameSelect_el_extra.value; rsg_populateCopySourceDestinationSelect_ExtraPage(); }); } 
            if(rsgCopySourceRouteNameInput_el_extra) { rsgCopySourceRouteNameInput_el_extra.addEventListener('blur', () => { const typedRouteUpper = rsgCopySourceRouteNameInput_el_extra.value.trim().toUpperCase(); const matchedOption = Array.from(rsgCopySourceRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper); if (matchedOption) { rsgCopySourceRouteNameSelect_el_extra.value = matchedOption.value; if(rsgCopySourceRouteNameInput_el_extra.value !== matchedOption.value) rsgCopySourceRouteNameInput_el_extra.value = matchedOption.value; } else { rsgCopySourceRouteNameSelect_el_extra.value = ""; } rsg_populateCopySourceDestinationSelect_ExtraPage(); }); } 
            if(rsgCopySourceDestNameSelect_el_extra) { rsgCopySourceDestNameSelect_el_extra.addEventListener('change', () => { if(rsgCopySourceDestNameInput_el_extra) rsgCopySourceDestNameInput_el_extra.value = rsgCopySourceDestNameSelect_el_extra.value; }); } 
            if(rsgCopySourceDestNameInput_el_extra) { rsgCopySourceDestNameInput_el_extra.addEventListener('blur', () => { const typedDest = rsgCopySourceDestNameInput_el_extra.value.trim(); const matchedOption = Array.from(rsgCopySourceDestNameSelect_el_extra.options).find(opt => opt.value === typedDest); if (matchedOption) rsgCopySourceDestNameSelect_el_extra.value = matchedOption.value; else rsgCopySourceDestNameSelect_el_extra.value = ""; }); } 
            if (rsgCopyModal_el_extra) { rsgCopyModal_el_extra.addEventListener('click', (event) => { if (event.target === rsgCopyModal_el_extra) rsg_closeCopyFromModal_ExtraPage(); }); }
        });

const rsgClearProfilesButton_el_extra = document.getElementById('rsg-clear-profile-checkboxes-button-extra');
if (rsgClearProfilesButton_el_extra) {
    rsgClearProfilesButton_el_extra.addEventListener('click', rsg_clearProfileSelections_ExtraPage);
}

// Save Config Modal Buttons
const rsgSaveConfirmBtn = document.getElementById('rsg-save-config-confirm-button-extra');
if (rsgSaveConfirmBtn) {
    rsgSaveConfirmBtn.addEventListener('click', rsg_performSaveConfiguration_ExtraPage);
}
const rsgSaveCancelBtn = document.getElementById('rsg-save-config-cancel-button-extra');
if (rsgSaveCancelBtn) {
    rsgSaveCancelBtn.addEventListener('click', rsg_hideSaveConfigModal_ExtraPage);
}

// Clicking outside the modal content to close it
const rsgSaveModal = document.getElementById('rsg-save-config-modal-extra');
if (rsgSaveModal) {
    rsgSaveModal.addEventListener('click', (event) => {
        if (event.target === rsgSaveModal) { // Only if overlay itself is clicked
            rsg_hideSaveConfigModal_ExtraPage();
        }

        });
    }

// Event Listeners for RSG Rename Config Modal (New)
    const rsgRenameConfirmBtn = document.getElementById('rsg-rename-config-confirm-button-extra');
    if (rsgRenameConfirmBtn) {
        rsgRenameConfirmBtn.addEventListener('click', rsg_performRenameConfiguration_ExtraPage);
    }
    const rsgRenameCancelBtn = document.getElementById('rsg-rename-config-cancel-button-extra');
    if (rsgRenameCancelBtn) {
        rsgRenameCancelBtn.addEventListener('click', rsg_hideRenameConfigModal_ExtraPage);
    }
    const rsgRenameModal = document.getElementById('rsg-rename-config-modal-extra');
    if (rsgRenameModal) {
        rsgRenameModal.addEventListener('click', (event) => {
            if (event.target === rsgRenameModal) { // Only if overlay (modal background) itself is clicked
                rsg_hideRenameConfigModal_ExtraPage();
            }
        });
    }

// === SERVICE ANALYZER JS ===
const serviceAnalyzerStopSelect_el_extra = document.getElementById('service-analyzer-stop-select-extra');
const serviceAnalyzerStopInput_el_extra = document.getElementById('service-analyzer-stop-input-extra');
const serviceAnalyzerStopSummary_el_extra = document.getElementById('service-analyzer-stop-summary-extra');

function populateServiceAnalyzerDropdowns_ExtraPage() {
    if (!Array.isArray(currentWorkingSchedule_extra)) return;
    // const allRoutesSet = new Set(); // No longer needed
    const allStopsSet = new Set();
    const allStopsMap = new Map();
    currentWorkingSchedule_extra.forEach(entry => {
        // if (entry.lineName) allRoutesSet.add(entry.lineName); // Removed
        if (entry.stopID) {
            allStopsSet.add(entry.stopID);
            allStopsMap.set(entry.stopID, entry.stopName || entry.stopID);
        }
    });
    // The block for populating serviceAnalyzerRouteSelect_el_extra is removed.
    if (serviceAnalyzerStopSelect_el_extra) { // This element variable should still be defined
        serviceAnalyzerStopSelect_el_extra.innerHTML = '<option value="">-- Select Stop --</option>';
        Array.from(allStopsSet)
            .map(stopID => ({ id: stopID, name: allStopsMap.get(stopID) || stopID }))
            .sort((a,b) => {
                const nameCompare = (a.name.toLowerCase()).localeCompare(b.name.toLowerCase());
                if (nameCompare !== 0) return nameCompare;
                return (a.id.toLowerCase()).localeCompare(b.id.toLowerCase());
            })
            .forEach(stopObj => {
                serviceAnalyzerStopSelect_el_extra.innerHTML += `<option value="${stopObj.id}">${stopObj.name} (${stopObj.id})</option>`;
            });
    }
}

function triggerStopAnalysisDynamically(stopIdentifier) {
    if (stopIdentifier) {
        analyzeStop_ExtraPage(stopIdentifier); // Your existing analysis function
    } else {
        if (serviceAnalyzerStopSummary_el_extra) {
            serviceAnalyzerStopSummary_el_extra.innerHTML = 'Select or type a stop to analyze.';
        }
    }
}

// 1. Listener for the SELECT dropdown
if (serviceAnalyzerStopSelect_el_extra) {
    serviceAnalyzerStopSelect_el_extra.addEventListener('change', function() {
        const selectedStopID = this.value;
        if (serviceAnalyzerStopInput_el_extra) {
            // Update the text input to reflect the dropdown's current selection's full text
            const selectedOption = this.options[this.selectedIndex];
            if (selectedOption && selectedOption.value) { // Check if it's a real stop, not the placeholder
                serviceAnalyzerStopInput_el_extra.value = selectedOption.text; // Show "Stop Name (ID)"
            } else {
                serviceAnalyzerStopInput_el_extra.value = ""; // Clear input if "-- Select Stop --"
            }
        }
        triggerStopAnalysisDynamically(selectedStopID);
    });
}

// 2. Listener for the TEXT input
if (serviceAnalyzerStopInput_el_extra && serviceAnalyzerStopSelect_el_extra) {
    // While typing, try to sync the select dropdown (no analysis on every keystroke)
    serviceAnalyzerStopInput_el_extra.addEventListener('input', function() {
        const typedValueLower = this.value.toLowerCase().trim();
        if (typedValueLower === "") {
            if (serviceAnalyzerStopSelect_el_extra.value !== "") {
                 serviceAnalyzerStopSelect_el_extra.value = ""; // Reset select, this won't fire its change event
            }
            return;
        }

        const options = Array.from(serviceAnalyzerStopSelect_el_extra.options);
        const matchedOption = options.find(opt =>
            opt.text.toLowerCase().includes(typedValueLower) || // Prioritize matching by text content
            opt.value.toLowerCase() === typedValueLower      // Also allow matching by ID
        );

        if (matchedOption) {
            if (serviceAnalyzerStopSelect_el_extra.value !== matchedOption.value) {
                serviceAnalyzerStopSelect_el_extra.value = matchedOption.value; // Sync select
            }
        } else {
            if (serviceAnalyzerStopSelect_el_extra.value !== "") {
                serviceAnalyzerStopSelect_el_extra.value = ""; // No match, deselect
            }
        }
    });

    // Analyze when the text input loses focus (on blur)
    serviceAnalyzerStopInput_el_extra.addEventListener('blur', function() {
        const typedValue = this.value.trim();
        // Prefer the synced select value if it's valid and matches what was typed (or part of it)
        const selectedInDropdown = serviceAnalyzerStopSelect_el_extra.value;
        const selectedOptionText = serviceAnalyzerStopSelect_el_extra.options[serviceAnalyzerStopSelect_el_extra.selectedIndex]?.text;

        if (selectedInDropdown && selectedOptionText && selectedOptionText.toLowerCase().includes(typedValue.toLowerCase())) {
            triggerStopAnalysisDynamically(selectedInDropdown);
        } else if (typedValue) { // If no sync or no valid option that aligns with typed text, try analyzing the raw typed value
            triggerStopAnalysisDynamically(typedValue);
        } else { // Input is empty
             triggerStopAnalysisDynamically(null);
        }
    });
}



// Helper function to generate sequence HTML for a given set of profiles
function generateSequenceMapForProfiles(
    profilesToAnalyze,
    currentDestName,
    allEntriesForRoute // All schedule entries for the main route being analyzed
) {
    const sequencesMap = new Map(); // Key: sequenceSignature, Value: { sequence: [stopObjects], profiles: Set() }

    if (!profilesToAnalyze || profilesToAnalyze.length === 0) {
        return sequencesMap; // Return an empty map if no profiles to analyze
    }

    const sortedProfiles = [...profilesToAnalyze].sort(); // Process profiles in a consistent order

    for (const opProfile of sortedProfiles) {
        // Filter entries for the current operating profile and destination
        const specificProfileEntries = allEntriesForRoute.filter(e =>
            e.destinationName === currentDestName && e.OperatingProfile === opProfile
        );

        if (specificProfileEntries.length === 0) continue; // No entries for this specific profile/destination

        // Sort these specificProfileEntries chronologically to correctly identify the first trip
        specificProfileEntries.sort((a, b) => {
            const dayOffsetA = parseInt(a.DayOffset || 0);
            const dayOffsetB = parseInt(b.DayOffset || 0);
            if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;

            const timeA = (a.scheduledTime || "99:99").replace(':', ''); // Fallback for missing time
            const timeB = (b.scheduledTime || "99:99").replace(':', '');
            return timeA.localeCompare(timeB);
        });

        const sequenceForThisProfileTrip = [];
        if (specificProfileEntries.length > 0) {
            const firstStopIDOfThisJourneyPattern = specificProfileEntries[0].stopID;
            let previousStopTimeInAbsoluteMinutes = -1;
            // Heuristic: Minimum stops to process before considering a repeat of the first stop ID as a new trip.
            // This helps distinguish a genuine new trip from a route that might loop back to its start ID quickly.
            // Adjust if necessary. If routes are very short (e.g. 2-stop shuttles that repeat often), this might need tuning.
            const MIN_STOPS_BEFORE_FIRST_ID_REVISIT_BREAK = 3;

            for (let i = 0; i < specificProfileEntries.length; i++) {
                const entry = specificProfileEntries[i];

                if (!entry.stopID || !entry.scheduledTime) {
                    console.warn(`Service Analyzer: Skipping entry for ${opProfile} (Dest: ${currentDestName}) due to missing stopID/time:`, entry);
                    continue;
                }

                const currentStopTimeInAbsoluteMinutes =
                    (parseInt(entry.DayOffset || 0) * 1440) +
                    parseInt(entry.scheduledTime.split(':')[0]) * 60 +
                    parseInt(entry.scheduledTime.split(':')[1]);

                // These break conditions apply only after the very first stop (i > 0)
                if (i > 0) {
                    // Condition 1: Time regresses (e.g., next day's service, or data error)
                    if (currentStopTimeInAbsoluteMinutes < previousStopTimeInAbsoluteMinutes) {
                        break; // End of the current trip's sequence
                    }
                    // Condition 2: Encountered the starting stop ID again *after* a few other stops
                    if (entry.stopID === firstStopIDOfThisJourneyPattern &&
                        sequenceForThisProfileTrip.length >= MIN_STOPS_BEFORE_FIRST_ID_REVISIT_BREAK) {
                        break; // Assumed start of the next iteration of this trip pattern
                    }
                }

                sequenceForThisProfileTrip.push({
                    stopID: entry.stopID,
                    name: entry.stopName || entry.stopID,
                    direction: entry.direction || 'N/A'
                });
                previousStopTimeInAbsoluteMinutes = currentStopTimeInAbsoluteMinutes;
            }
        }

        if (sequenceForThisProfileTrip.length > 0) {
            const sequenceSignature = sequenceForThisProfileTrip.map(s => s.stopID).join('->');
            if (!sequencesMap.has(sequenceSignature)) {
                sequencesMap.set(sequenceSignature, {
                    sequence: sequenceForThisProfileTrip,
                    profiles: new Set()
                });
            }
            sequencesMap.get(sequenceSignature).profiles.add(opProfile);
        }
    } // End opProfile loop
    return sequencesMap;
}

function analyzeStop_ExtraPage(stopID) {
    if (!serviceAnalyzerStopSummary_el_extra) {
        console.error("Service Analyzer: Summary element not found!");
        return;
    }
    if (!stopID) {
        serviceAnalyzerStopSummary_el_extra.innerHTML = `<span style="color:#f1c40f;">Please select or enter a stop.</span>`;
        return;
    }

    const entries = currentWorkingSchedule_extra.filter(e => e.stopID && e.stopID.toUpperCase() === stopID.toUpperCase());

    if (entries.length === 0) {
        serviceAnalyzerStopSummary_el_extra.innerHTML = `<span style="color:#e74c3c;">No data found for stop ID: ${stopID}.</span>`;
        return;
    }

    const stopDetails = entries[0];
    const routes = new Set();
    const profilesByRoute = new Map(); 
    const destinationsByRoute = new Map(); 
    let stopHasNightRouteService = false; 

    entries.forEach(e => {
        if (e.lineName) {
            routes.add(e.lineName);
            if (typeof e.lineName === 'string' && e.lineName.toUpperCase().startsWith('N')) {
                stopHasNightRouteService = true;
            }

            if (!profilesByRoute.has(e.lineName)) {
                profilesByRoute.set(e.lineName, new Set());
            }
            if (e.OperatingProfile) {
                profilesByRoute.get(e.lineName).add(e.OperatingProfile);
            }
            
            if (!destinationsByRoute.has(e.lineName)) {
                destinationsByRoute.set(e.lineName, new Set());
            }
            if (e.destinationName) {
                destinationsByRoute.get(e.lineName).add(e.destinationName);
            }
        }
    });

    const MORNING_SERVICE_START_HOUR = 4; 

    let routeDetailsHTML = "";
    const designatedNightServiceBlue = (globalCustomRouteColours_extra["NIGHT_DEFAULT"] || NIGHT_BUS_BLUE_COLOR_extra || "#4CDBE6").toUpperCase();

    Array.from(routes).sort(compareLineNames_ExtraPage).forEach(route => {
        const bgColor = getRouteTileColour_ExtraPage(route, stopID); 
        const textColor = getTextColourForBackground_ExtraPage(bgColor);
        const tileHTML = `<span class="route-tile-tools-list" style="background-color:${bgColor}; color:${textColor}; font-size: 0.95em; padding: 0.3em 0.65em; margin-right: 0.5em; vertical-align: baseline;">${route}</span>`;

        let profilesDisplayHTML = "";
        const routeOperatingProfiles = Array.from(profilesByRoute.get(route) || []).sort();

        if (routeOperatingProfiles.length > 0) {
            profilesDisplayHTML = '<div style="margin-top: 0.3em; padding-left: 0.2em;">'; 

            const currentRouteActualTileColor = bgColor.toUpperCase();
            const isCurrentRouteAnNRoute = route.toUpperCase().startsWith('N');

            routeOperatingProfiles.forEach(profile => {
                let profileDetailText;

                if (currentRouteActualTileColor === designatedNightServiceBlue && !isCurrentRouteAnNRoute) {
                    profileDetailText = `<span style="color: ${designatedNightServiceBlue};">24 Hour Service</span>`;
                } else {
                    let firstBusTimeStr = "N/A";
                    let lastBusTimeStr = "N/A";

                    const specificEntriesForRouteProfile = entries.filter(e =>
                        e.lineName === route && 
                        e.OperatingProfile === profile &&
                        e.scheduledTime && typeof e.scheduledTime === 'string' && e.scheduledTime.includes(':')
                    );

                    if (specificEntriesForRouteProfile.length > 0) {
                        const timesForThisRouteProfile = specificEntriesForRouteProfile.map(e => ({
                            absMinutes: getAbsMinutes(e.scheduledTime, parseInt(e.DayOffset || 0, 10)),
                            displayTime: e.scheduledTime
                        })).filter(t => t.absMinutes !== null);

                        if (timesForThisRouteProfile.length > 0) {
                            timesForThisRouteProfile.sort((a, b) => a.absMinutes - b.absMinutes);

                            if (isCurrentRouteAnNRoute) {
                                // For N-routes, First Bus is the chronological start of that profile's service
                                firstBusTimeStr = timesForThisRouteProfile[0].displayTime;
                            } else {
                                // For non-N routes, apply the "Morning Start Hour" heuristic
                                let foundMorningStartForProfile = false;
                                for (const item of timesForThisRouteProfile) {
                                    const hourOfCalendarDay = Math.floor((item.absMinutes % 1440) / 60);
                                    if (hourOfCalendarDay >= MORNING_SERVICE_START_HOUR) {
                                        firstBusTimeStr = item.displayTime;
                                        foundMorningStartForProfile = true;
                                        break;
                                    }
                                }
                                if (!foundMorningStartForProfile && timesForThisRouteProfile.length > 0) { 
                                    firstBusTimeStr = timesForThisRouteProfile[0].displayTime;
                                }
                            }
                            lastBusTimeStr = timesForThisRouteProfile[timesForThisRouteProfile.length - 1].displayTime;
                        }
                    }
                    profileDetailText = `First: ${firstBusTimeStr} - Last: ${lastBusTimeStr}`;
                }
                profilesDisplayHTML += `<div style="font-size:0.85em; margin-bottom:0.25em; padding-left:0.3em;"><strong style="font-weight:normal; color: #bdc3c7;">${profile}:</strong> ${profileDetailText}</div>`;
            });
            profilesDisplayHTML += '</div>';
        } else {
            profilesDisplayHTML = '<div style="font-size:0.85em; margin-top:0.3em; padding-left:0.5em;">Profiles: N/A</div>';
        }
        
        let destinationsDisplayBlock;
        if (destinationsByRoute.has(route)) {
            const routeDestsArray = Array.from(destinationsByRoute.get(route)).sort();
            if (routeDestsArray.length === 0) {
                destinationsDisplayBlock = `<div style="font-size:0.85em; margin-top: 0.3em; padding-left:0.5em;">Destinations: N/A</div>`;
            } else if (routeDestsArray.length === 1) {
                destinationsDisplayBlock = `<div style="font-size:0.85em; margin-top: 0.3em; padding-left:0.5em;">Destinations: ${routeDestsArray[0]}</div>`;
            } else { 
                const listItems = routeDestsArray.map(d => `<li style="margin-bottom: 0.15em;">${d}</li>`).join('');
                destinationsDisplayBlock = `
                    <div style="font-size:0.85em; margin-top: 0.3em; padding-left:0.5em;">
                        Destinations:
                        <ul style="margin-top: 0.2em; margin-bottom: 0; padding-left: 1.7em; list-style-type: disc;">
                            ${listItems}
                        </ul>
                    </div>`;
            }
        } else {
            destinationsDisplayBlock = `<div style="font-size:0.85em; margin-top: 0.3em; padding-left:0.5em;">Destinations: N/A</div>`;
        }

        routeDetailsHTML += `
            <div class="subsection" style="margin-top:0.6rem; padding:0.6rem 0.6rem 0.6rem 0.8rem; font-size:0.9em; border-left: 4px solid ${bgColor};">
                ${tileHTML}
                ${profilesDisplayHTML}
                ${destinationsDisplayBlock}
            </div>`;
    });

    const nightServiceColorForIndicator = typeof NIGHT_BUS_BLUE_COLOR_extra !== 'undefined' ? NIGHT_BUS_BLUE_COLOR_extra : '#4CDBE6';
    const nightServiceIndicatorHTML = stopHasNightRouteService ? `<span style="font-size: 0.9em; color: ${nightServiceColorForIndicator}; display:block; margin-top:0.1em;">(Night service routes operate at this stop)</span><br>` : '';

    serviceAnalyzerStopSummary_el_extra.innerHTML = `
        <span style="font-size: 1.1em;">Stop: ${stopDetails.stopName || 'N/A'} (ID: ${stopID})</span><br>
        <span style="font-size: 0.9em;">Direction: ${stopDetails.direction || 'N/A'}</span><br>
        <span style="font-size: 0.9em;">Total Schedule Entries at Stop: ${entries.length}</span><br>
        ${nightServiceIndicatorHTML}
        <span style="margin-top:0.85em; margin-bottom: 0.3em; display:block; font-size: 1.05em;">Routes Serving This Stop (${routes.size}):</span>
        <div style="max-height: 400px; overflow-y: auto; padding-right:0.2em; margin-top: 0.2em;">${routeDetailsHTML || '(None listed)'}</div>
    `;
}

function onShowServiceAnalyzerSection_ExtraPage() {
    populateServiceAnalyzerDropdowns_ExtraPage();
    if (serviceAnalyzerStopSummary_el_extra) serviceAnalyzerStopSummary_el_extra.innerHTML = 'Select a stop.';
}

</script>
</body>
</html>
