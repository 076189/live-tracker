<!DOCTYPE html>
<html>
<head>
    <title>Live Bus Tracker</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* Basic Reset & Font */
        body, html { margin: 0; padding: 0; box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f9f9f9; }
        h1 { margin-bottom: 10px; text-align: center; }
         .info-container { display: flex; justify-content: space-between; flex-wrap: wrap; margin-bottom: 20px; font-size: 18px; }
         .update-time, .counter { margin-bottom: 5px; }
         table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 0.9em; }
         th, td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; white-space: nowrap; }
         /* --- Table Header Styling --- */
         thead th {
             background-color: #e9e9e9; /* Slightly darker background for main headers */
             position: sticky;
             top: 0; /* Stick the first header row */
             z-index: 2; /* Ensure it's above the filter row */
             text-align: center;
             font-weight: bold;
             height: 30px; /* Adjust based on your font/padding */
             vertical-align: middle;
         }
         thead tr.filter-row th,
         thead tr.filter-row td { /* Style the filter row cells */
             background-color: #f4f4f4;
             position: sticky;
             top: 30px; /* Stick below the first header row (matches estimated height above) */
             z-index: 1;
             padding: 4px 8px;
             vertical-align: top;
             text-align: center; /* Center filter dropdowns */
             border-top: 1px solid #ccc; /* Separator line */
         }
         thead select {
             padding: 3px 5px;
             font-size: 0.9em;
             width: 95%; /* Make dropdowns fill cell width */
             max-width: 180px; /* Optional max width */
             box-sizing: border-box; /* Include padding in width */
             margin-top: 2px;
         }
         /* --- End Table Header Styling --- */

         tr:nth-child(even) { background-color: #f9f9f9; }
         /* Style for rows representing buses seen recently but not in current feed */
         tr.ghost-bus td { color: #777; font-style: italic; }
         /* Specifically target the ETA cell for ghosts if needed */
         tr.ghost-bus td:nth-child(5) { /* font-weight: bold; */ } /* Example styling */

         td[colspan="5"] { text-align: center; font-style: italic; color: #555; padding: 15px 8px; white-space: normal; }
         td:nth-child(3), td:nth-child(4) { white-space: normal; } /* Allow destination and stop name to wrap */
         h2 { margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px; text-align: center;}
         /* Style for the initial route selector */
         #route-selector { display: none; text-align: center; padding: 30px; border: 1px solid #ccc; border-radius: 8px; margin: 30px auto; max-width: 450px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
         #route-selector h2 { margin-top: 0; margin-bottom: 20px; border: none; padding: 0; }
         #route-selector input[type="text"] { width: 80%; max-width: 250px; padding: 10px; margin-bottom: 15px; font-size: 1.1em; border: 1px solid #ccc; border-radius: 4px; text-align: center; text-transform: uppercase; }
         #route-selector button { padding: 10px 25px; font-size: 1.1em; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; transition: background-color 0.2s ease; }
         #route-selector button:hover { background-color: #0056b3; }
         #route-search-error { color: red; min-height: 1em; margin-top: 15px; font-size: 0.9em; }

         /* Styles for the top search bar */
         #top-route-search-container { text-align: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #eee; }
         #top-route-search-input { width: 60%; max-width: 200px; padding: 8px; font-size: 1em; border: 1px solid #ccc; border-radius: 4px; text-transform: uppercase; margin-right: 5px; vertical-align: middle; }
         #top-route-search-button { padding: 8px 15px; font-size: 1em; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; vertical-align: middle; transition: background-color 0.2s ease; }
         #top-route-search-button:hover { background-color: #0056b3; }
         #top-route-search-error { color: red; min-height: 1em; margin-top: 5px; font-size: 0.9em; }
         #back-to-search-link { margin-left: 15px; vertical-align: middle; font-size: 0.9em; } /* Added just in case */

         /* --- Route Sequence Styles --- */
         #route-sequences {
             margin-top: 30px;
             padding-top: 20px;
             border-top: 1px solid #eee;
             display: flex; /* Arrange side-by-side */
             flex-wrap: wrap; /* Allow wrapping on small screens */
             gap: 20px; /* Space between direction columns */
             justify-content: space-around; /* Distribute space */
         }
         .sequence-container {
             flex: 1; /* Each takes roughly half the space */
             min-width: 280px; /* Minimum width before wrapping */
             background-color: #fff;
             padding: 15px;
             border: 1px solid #e0e0e0;
             border-radius: 5px;
             box-shadow: 0 1px 3px rgba(0,0,0,0.05);
         }
         .sequence-container h2 {
              margin-top: 0;
              margin-bottom: 10px;
              font-size: 1.1em;
              text-align: left;
              border: none; /* Remove border from main h2 style */
              padding: 0; /* Remove padding from main h2 style */
         }
         /* Removed styles for manual heading edit */

         .sequence-list-container {
              max-height: 400px; /* Limit height and add scroll */
              overflow-y: auto;
              font-size: 0.85em;
              line-height: 1.5;
         }
         .sequence-list-container ol {
              padding-left: 30px; /* Adjusted padding back */
              margin: 0;
         }
         .sequence-list-container li {
              padding: 3px 0; /* Slightly more spacing */
              border-bottom: 1px dotted #f0f0f0;
         }
         .sequence-list-container li:last-child {
             border-bottom: none;
         }
         .sequence-list-container p { /* For loading/error messages */
             font-style: italic;
             color: #666;
             padding: 10px 0;
         }
         /* --- End Route Sequence Styles --- */
    </style>
</head>
<body>
    <div id="route-selector">
        <h2>Enter Route to Track</h2>
        <input type="text" id="route-search-input" placeholder="e.g., 184, N20" aria-label="Route ID Input">
        <button id="route-search-button" onclick="loadSelectedRoute()">Load Route</button>
        <p id="route-search-error"></p>
    </div>

    <div id="tracker-content" style="display: none;">

        <div id="top-route-search-container">
            <input type="text" id="top-route-search-input" placeholder="Change Route (e.g., N91)" aria-label="Change Route ID Input">
            <button id="top-route-search-button" onclick="loadTopRoute()">Go</button>
            <p id="top-route-search-error"></p>
        </div>
        <h1 id="main-heading">Live Bus Tracker</h1>
        <div class="info-container">
            <div class="update-time" id="update-time">Last Updated: --</div>
            <div class="counter" id="bus-counter">Buses on Route: 0</div>
        </div>
        <table>
            <thead>
                <tr>
                    <th>Fleet No.</th>
                    <th>Registration</th>
                    <th>Destination</th>
                    <th>Next Stop / Last Known Stop</th>
                    <th>ETA / Last Seen</th>
                </tr>
                <tr class="filter-row">
                    <td><select id="filter-fleet"><option value="">All</option></select></td>
                    <td><select id="filter-reg"><option value="">All</option></select></td>
                    <td><select id="filter-destination"><option value="">All</option></select></td>
                    <td><select id="filter-stop"><option value="">All</option></select></td>
                    <td><select id="filter-arrival"><option value="">All</option></select></td>
                </tr>
            </thead>
            <tbody id="tracker-table">
                <tr><td colspan="5">Fetching live data...</td></tr>
            </tbody>
        </table>

        <h2 id="curtailments-heading">Curtailments Today</h2>
        <table>
            <thead>
                <tr>
                    <th>Route</th>
                    <th>Fleet No.</th>
                    <th>Registration</th>
                    <th>Curtailed To</th>
                    <th>Time Logged</th>
                </tr>
            </thead>
            <tbody id="curtailed-buses-table">
                <tr><td colspan="5">Loading curtailment data...</td></tr>
            </tbody>
        </table>

        <div id="route-sequences">
             <div class="sequence-container">
                 <h2 id="outbound-sequence-heading">Route Sequence (Outbound)</h2>
                 <div id="outbound-sequence-list" class="sequence-list-container">
                     <p>Loading sequence...</p>
                 </div>
             </div>
             <div class="sequence-container">
                 <h2 id="inbound-sequence-heading">Route Sequence (Inbound)</h2>
                  <div id="inbound-sequence-list" class="sequence-list-container">
                     <p>Loading sequence...</p>
                 </div>
             </div>
        </div>
        </div>

    <script>
         console.log('--- FULL TRACKER SCRIPT STARTED (v20 - Removed Manual Heading Edit) ---'); // Updated Log Version Name

         // Get references needed for showing/hiding sections
         const routeSelectorDiv = document.getElementById('route-selector');
         const trackerContentDiv = document.getElementById('tracker-content');

         // --- Dynamic Route ID Setup ---
         const urlParams = new URLSearchParams(window.location.search);
         let dynamicRouteId = urlParams.get('route')?.trim().toUpperCase();

         // --- Function to handle loading route from INITIAL input ---
         function loadSelectedRoute() {
             const input = document.getElementById('route-search-input');
             const errorP = document.getElementById('route-search-error');
             if (!input || !errorP) return;
             const enteredRoute = input.value.trim().toUpperCase();
             errorP.textContent = '';
             if (!enteredRoute) { errorP.textContent = 'Please enter a Route ID.'; input.focus(); return; }
             if (!/^[A-Z0-9]+$/i.test(enteredRoute) || enteredRoute.length > 5) { errorP.textContent = 'Invalid Route ID format entered.'; input.focus(); return; }
             window.location.href = `tracker.html?route=${enteredRoute}`;
         }

         // --- Function to handle loading route from the TOP search bar ---
         function loadTopRoute() {
             const input = document.getElementById('top-route-search-input');
             const errorP = document.getElementById('top-route-search-error');
             if (!input || !errorP) return;
             const enteredRoute = input.value.trim().toUpperCase();
             errorP.textContent = '';
             if (!enteredRoute) { errorP.textContent = 'Please enter a Route ID.'; input.focus(); return; }
             if (!/^[A-Z0-9]+$/i.test(enteredRoute) || enteredRoute.length > 5) { errorP.textContent = 'Invalid Route ID format.'; input.focus(); return; }
             window.location.href = `tracker.html?route=${enteredRoute}`;
         }


         // Add listener for Enter key in the initial search input
         const routeSearchInput = document.getElementById('route-search-input');
         if (routeSearchInput) { routeSearchInput.addEventListener('keyup', function(event) { if (event.key === 'Enter') { event.preventDefault(); loadSelectedRoute(); } }); }

         // Add listener for Enter key in the TOP search input
         const topRouteSearchInput = document.getElementById('top-route-search-input');
         if (topRouteSearchInput) { topRouteSearchInput.addEventListener('keyup', function(event) { if (event.key === 'Enter') { event.preventDefault(); loadTopRoute(); } }); }


         // --- Main Logic Execution ---
         if (!dynamicRouteId) {
             // --- NO ROUTE IN URL ---
             document.title = "Select Route - Live Bus Tracker";
             if (routeSelectorDiv) routeSelectorDiv.style.display = 'block';
             if (trackerContentDiv) trackerContentDiv.style.display = 'none';
             console.log("No route ID in URL, showing selector.");
         } else {
             // --- ROUTE FOUND IN URL ---
              if (routeSelectorDiv) routeSelectorDiv.style.display = 'none';
              if (trackerContentDiv) trackerContentDiv.style.display = 'block';
              console.log(`Route ID found: ${dynamicRouteId}. Initializing tracker...`);

             // --- Constants ---
             const apiUrl = `https://api.tfl.gov.uk/Line/${dynamicRouteId}/Arrivals`;
             const curtailedBusesKey = `curtailedBusesArray_${dynamicRouteId}`;
             const tmpMapKey = "tmpRegistrationMap";
             const filterStateKey = `arrivalsFilterState_${dynamicRouteId}_all`;
             const busLastSeenKey = `busLastSeenWithDest_${dynamicRouteId}`;
             const settingsKey = "trackerGlobalSettings";
             const defaultSettings = { debounceMinutes: 60, timeoutMinutes: 30 }; // Default timeout is 30 mins
             const routeDestinationSettingsKey = 'routeDestinationSettings';
             const tmpGenerationInfoKey = "tmpGenerationInfo";
             const destinationOverrideKey = 'destinationOverrides';
             const sequenceHeadingOverrideKey = `sequenceHeadingOverrides_${dynamicRouteId}`; // Key for manual headings (READ ONLY HERE)
             const CACHE_DURATION_MS = 24 * 60 * 60 * 1000; // 24 hours for route sequence cache

             // --- Global Variables for Sequence Headings ---
             let autoOutboundDestinationName = null; // Name detected from live bus
             let autoInboundDestinationName = null;  // Name detected from live bus
             let manualSequenceHeadings = {}; // Store manual overrides { outbound: "...", inbound: "..." } (Loaded once)

             // --- Update Title and Headings ---
             document.title = `Live Tracker - Route ${dynamicRouteId}`;
             const mainHeading = document.getElementById('main-heading');
             if(mainHeading) mainHeading.textContent = `Live Tracker for Route ${dynamicRouteId}`;
             const busCounterElement = document.getElementById('bus-counter');
             if(busCounterElement) busCounterElement.textContent = `Buses on Route ${dynamicRouteId}: 0`;
             const curtailmentsHeading = document.getElementById('curtailments-heading');
              if(curtailmentsHeading) curtailmentsHeading.textContent = `Curtailments Today for Route ${dynamicRouteId}`;

             // --- Storage Functions ---
             function loadFromStorage(key, defaultValue = {}) { try { const data = localStorage.getItem(key); return data ? JSON.parse(data) : defaultValue; } catch (e) { console.error(`Error loading ${key}:`, e); return defaultValue; } }
             function saveToStorage(key, data) { try { localStorage.setItem(key, JSON.stringify(data)); } catch (e) { console.error(`Error saving ${key}:`, e); } }

             // --- Advanced TMP Number Generation ---
             function generateTMPNumber(registration) { const seed=12345;const combined=registration+seed.toString();let hash=0;if(combined.length===0)return"TMP0000";for(let i=0;i<combined.length;i++){const t=combined.charCodeAt(i);hash=(hash<<5)-hash+t,hash|=0}return`TMP${Math.abs(hash%1e4).toString().padStart(4,"0")}` }
             function getTMPForRegistration(registration) { if (!registration) return 'TMP????'; let tmpMap = loadFromStorage(tmpMapKey, {}); if (typeof tmpMap !== 'object' || tmpMap === null) tmpMap = {}; if (tmpMap.hasOwnProperty(registration)) { return tmpMap[registration]; } let attempt = 0; let uniqueTMP = null; let generatedTMP; const MAX_ATTEMPTS = 100; const isTMPValueUsed = (map, tmpValue, currentReg) => { for (const reg in map) { if (map.hasOwnProperty(reg) && reg !== currentReg && map[reg] === tmpValue) { return true; } } return false; }; while (uniqueTMP === null && attempt < MAX_ATTEMPTS) { const inputForHash = attempt === 0 ? registration : `${registration}_${attempt}`; generatedTMP = generateTMPNumber(inputForHash); if (!isTMPValueUsed(tmpMap, generatedTMP, registration)) { uniqueTMP = generatedTMP; } else { console.warn(`TMP collision for ${registration}: ${generatedTMP}. Retrying...`); attempt++; } } if (uniqueTMP === null) { console.error(`Could not generate unique TMP for ${registration}.`); uniqueTMP = `ERR${Math.floor(1000 + Math.random() * 9000)}`; } tmpMap[registration] = uniqueTMP; saveToStorage(tmpMapKey, tmpMap); try { let genInfo = loadFromStorage(tmpGenerationInfoKey, {}); if (typeof genInfo !== 'object' || genInfo === null) genInfo = {}; genInfo[registration] = { route: dynamicRouteId, timestamp: Date.now() }; saveToStorage(tmpGenerationInfoKey, genInfo); } catch(e) { console.error(`Failed to save TMP generation info for ${registration}:`, e); } return uniqueTMP; }


             // --- Destination Override Logic ---
             function getEffectiveDestination(busReg, busDirectionId, originalApiDest) {
                 const reg = String(busReg || '').toUpperCase(); const routeId = dynamicRouteId; const directionId = parseInt(busDirectionId, 10); const overrides = loadFromStorage(destinationOverrideKey, {}); const globalOverride = overrides['*'] || null;
                 if (overrides.hasOwnProperty(reg)) { const o = overrides[reg]; if (typeof o === 'object' && o !== null && o.dir1 !== undefined && o.dir2 !== undefined) { let d=null; if(directionId===1&&o.dir1)d=o.dir1; else if(directionId===2&&o.dir2)d=o.dir2; if(d&&(directionId===1||directionId===2)) return d;} else if (typeof o === 'string' && o.trim() !== '') {console.warn(`Legacy override ${reg}`); return o;} }
                 if (overrides.hasOwnProperty(routeId)) { const o = overrides[routeId]; if (typeof o === 'object' && o !== null && o.dir1 !== undefined && o.dir2 !== undefined) { let d=null; if(directionId===1&&o.dir1)d=o.dir1; else if(directionId===2&&o.dir2)d=o.dir2; if(d&&(directionId===1||directionId===2)) return d;} else if (typeof o === 'string' && o.trim() !== '') {console.warn(`Legacy override ${routeId}`); return o;} }
                 if (globalOverride && typeof globalOverride === 'string' && globalOverride.trim() !== '') return globalOverride;
                 return String(originalApiDest || 'N/A');
             }


             // --- Curtailment Handling ---
             function populateCurtailmentsTable() {
                  const allCurtailments = loadFromStorage(curtailedBusesKey, []); const curtailedBusesTable = document.getElementById("curtailed-buses-table"); if (!curtailedBusesTable) return; curtailedBusesTable.innerHTML = ""; if (!Array.isArray(allCurtailments)) { curtailedBusesTable.innerHTML = `<tr><td colspan="5">Error loading curtailment data.</td></tr>`; return; } const todayStart = new Date(); todayStart.setHours(0, 0, 0, 0); const todayTimestamp = todayStart.getTime(); const todaysCurtailments = allCurtailments.filter(c => c && c.route === dynamicRouteId && c.timestamp >= todayTimestamp); const sortedTodaysCurtailments = todaysCurtailments.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); if (sortedTodaysCurtailments.length > 0) { sortedTodaysCurtailments.forEach(bus => { const fleetNumber = getTMPForRegistration(bus.regNumber); let displayTime = 'N/A'; if (bus.timestamp && !isNaN(bus.timestamp)) { try { const dateObject = new Date(bus.timestamp); displayTime = dateObject.toLocaleTimeString('en-GB', { timeZone: 'Europe/London', hour: '2-digit', minute: '2-digit' }); } catch (e) { displayTime = bus.curtailmentTime || 'N/A'; } } else if (bus.curtailmentTime) { displayTime = bus.curtailmentTime; } const row = document.createElement("tr"); row.innerHTML = `<td>${bus.route || 'N/A'}</td><td>${fleetNumber}</td><td>${bus.regNumber || 'N/A'}</td><td>${bus.curtailedDestination || 'N/A'}</td><td>${displayTime}</td>`; curtailedBusesTable.appendChild(row); }); } else { curtailedBusesTable.innerHTML = `<tr><td colspan="5">No curtailments recorded for Route ${dynamicRouteId} today.</td></tr>`; }
             }

             // --- Route Sequence Fetching and Display Logic (Simplified) ---

             // Function to update heading text, prioritizing manual override from localStorage
             function updateSequenceHeading(direction, fallbackTerminus) {
                 const headingId = `${direction}-sequence-heading`;
                 const headingElement = document.getElementById(headingId);
                 if (!headingElement) return;

                 let displayName = null;
                 // 1. Check Manual Override (Loaded during initialization)
                 if (manualSequenceHeadings[direction]) {
                     displayName = manualSequenceHeadings[direction];
                     // console.log(`[Sequence Heading] Using manual override for ${direction}: ${displayName}`);
                 }
                 // 2. Check Auto-Detected Name
                 else if (direction === 'outbound' && autoOutboundDestinationName) {
                     displayName = autoOutboundDestinationName;
                     // console.log(`[Sequence Heading] Using auto-detected name for ${direction}: ${displayName}`);
                 } else if (direction === 'inbound' && autoInboundDestinationName) {
                     displayName = autoInboundDestinationName;
                     // console.log(`[Sequence Heading] Using auto-detected name for ${direction}: ${displayName}`);
                 }
                 // 3. Use Fallback (Terminus)
                 else {
                     displayName = fallbackTerminus;
                     // console.log(`[Sequence Heading] Using fallback terminus for ${direction}: ${displayName}`);
                 }

                 headingElement.textContent = `Route Sequence (${direction})${displayName ? ': Towards ' + displayName : ''}`;
             }

             function displaySequence(direction, stops, terminus) {
                 const listContainerId = `${direction}-sequence-list`;
                 const listContainer = document.getElementById(listContainerId);

                 // Call updateSequenceHeading here to set initial heading using terminus or loaded manual override
                 updateSequenceHeading(direction, terminus);

                 if (!listContainer) {
                     console.error(`[Sequence] Container not found for direction: ${direction}`);
                     return;
                 }

                 if (!Array.isArray(stops) || stops.length === 0) {
                     console.log(`[Sequence] No valid stops data to display for ${direction}. Input:`, stops);
                     listContainer.innerHTML = `<p>No stops found for ${direction} direction.</p>`;
                     return;
                 }

                 console.log(`[Sequence] Displaying ${stops.length} stops for ${direction}.`);
                 const ol = document.createElement('ol');
                 stops.forEach(stopName => {
                     const li = document.createElement('li');
                     li.textContent = stopName || 'Unknown Stop';
                     ol.appendChild(li);
                 });
                 listContainer.innerHTML = ''; // Clear previous content
                 listContainer.appendChild(ol);
             }

             async function fetchSequenceForDirection(routeId, direction) {
                 const cacheKey = `routeSequenceCache_${direction}_${routeId}`;
                 const listContainerId = `${direction}-sequence-list`;
                 const listContainer = document.getElementById(listContainerId);
                 const now = Date.now();

                 // 1. Check Cache
                 try {
                     const cachedData = loadFromStorage(cacheKey, null);
                     if (cachedData && cachedData.timestamp && (now - cachedData.timestamp < CACHE_DURATION_MS) && Array.isArray(cachedData.stops)) {
                         console.log(`[Sequence] Using valid cached sequence for ${routeId} - ${direction}`);
                         displaySequence(direction, cachedData.stops, cachedData.terminus);
                         return;
                     } else if (cachedData) {
                         console.warn(`[Sequence] Cached data for ${direction} is invalid or expired. Refetching.`);
                     }
                 } catch (e) {
                     console.error(`[Sequence] Error reading sequence cache for ${direction}:`, e);
                 }

                 // 2. Fetch Sequence from API
                 if(listContainer) listContainer.innerHTML = `<p>Loading ${direction} sequence...</p>`;
                 const apiUrlSequence = `https://api.tfl.gov.uk/Line/${routeId}/Route/Sequence/${direction}`;
                 let sequenceData;
                 let stops = []; // Array of stop names
                 try {
                     console.log(`[Sequence] Fetching sequence: ${apiUrlSequence}`);
                     const response = await fetch(apiUrlSequence);
                     console.log(`[Sequence] Response status for ${direction}: ${response.status}`);
                     if (!response.ok) {
                         if (response.status === 404) { throw new Error(`No sequence data available (404)`); }
                         else { throw new Error(`API Error ${response.status}: ${response.statusText}`); }
                     }
                     sequenceData = await response.json();
                     if (sequenceData.stopPointSequences && sequenceData.stopPointSequences.length > 0 && sequenceData.stopPointSequences[0].stopPoint) {
                         stops = sequenceData.stopPointSequences[0].stopPoint.map(stop => stop.name || 'Unknown Stop');
                         console.log(`[Sequence] Extracted ${stops.length} stop names for ${direction}.`);
                     }
                     if (!Array.isArray(stops) || stops.length === 0) {
                         if (sequenceData && sequenceData.message && sequenceData.httpStatusCode === 404) {
                             throw new Error(sequenceData.message);
                         } else {
                             throw new Error("Could not extract valid stop sequence from API response.");
                         }
                     }
                 } catch (error) {
                     console.error(`[Sequence] Error fetching sequence for ${routeId} - ${direction}:`, error);
                     if(listContainer) listContainer.innerHTML = `<p>Error loading sequence: ${error.message}</p>`;
                     return;
                 }

                 // 3. Display and Cache (only if stops is valid)
                 if (Array.isArray(stops) && stops.length > 0) {
                     const terminus = stops[stops.length - 1]; // Last stop name
                     const dataToCache = {
                         stops: stops,
                         terminus: terminus,
                         timestamp: now
                     };
                     saveToStorage(cacheKey, dataToCache);
                     console.log(`[Sequence] Displaying sequence for ${routeId} - ${direction}`);
                     displaySequence(direction, stops, terminus);
                 } else {
                     console.error(`[Sequence] Failed to create valid stops array for ${direction}.`);
                     if(listContainer) listContainer.innerHTML = `<p>Error processing stop data for ${direction}.</p>`;
                 }
             }


             async function fetchAndDisplayRouteSequence(routeId) {
                 console.log(`[Sequence] Fetching route sequences for ${routeId}...`);
                 // Fetch both directions.
                 await fetchSequenceForDirection(routeId, 'outbound');
                 await fetchSequenceForDirection(routeId, 'inbound');
                 console.log(`[Sequence] Finished fetching route sequences for ${routeId}.`);
             }
             // --- End Route Sequence Logic ---

             // --- Removed Manual Sequence Heading Functions ---

             // --- Live Data Fetching and Processing (Absolute Time for Future Arrivals) ---
             async function fetchLiveBusData() {
                  const trackerTable = document.getElementById("tracker-table"); const busCounter = document.getElementById("bus-counter"); const updateTime = document.getElementById("update-time");
                  const filterFleet = document.getElementById("filter-fleet"); const filterReg = document.getElementById("filter-reg"); const filterDestination = document.getElementById("filter-destination"); const filterStop = document.getElementById("filter-stop"); const filterArrival = document.getElementById("filter-arrival");
                  if (!trackerTable || !busCounter || !updateTime || !filterFleet || !filterReg || !filterDestination || !filterStop || !filterArrival) { console.error("Essential elements missing."); return; }

                  try {
                       const loadedSettings = loadFromStorage(settingsKey, defaultSettings); const debounceMinutes = loadedSettings.debounceMinutes || defaultSettings.debounceMinutes; const timeoutMinutes = loadedSettings.timeoutMinutes || defaultSettings.timeoutMinutes; const debounceMs = debounceMinutes * 60 * 1000; const timeoutMs = timeoutMinutes * 60 * 1000;
                       const allDestSettings = loadFromStorage(routeDestinationSettingsKey, {}); const finalDestinations = allDestSettings[dynamicRouteId] || []; // Load official termini

                       const response = await fetch(apiUrl);
                       if (!response.ok) { trackerTable.innerHTML = `<tr><td colspan="5">Error fetching API data (${response.status}). Route ${dynamicRouteId} may be invalid.</td></tr>`; throw new Error(`API error: ${response.status}`); }
                       const arrivals = await response.json();
                       const now = Date.now();

                       let busLastSeen = loadFromStorage(busLastSeenKey, {}); // Load initially
                       let tmpMap = loadFromStorage(tmpMapKey, {});
                       let allCurtailments = loadFromStorage(curtailedBusesKey, []); // Load curtailments specific to this route
                       if (!Array.isArray(allCurtailments)) { allCurtailments = []; }
                       const activeBuses = {}; let newCurtailmentDetected = false;
                       let busLastSeenModified = false; // Flag to check if we need to save busLastSeen
                       let outboundHeadingUpdated = false; // Flags to update heading only once per fetch
                       let inboundHeadingUpdated = false;

                       // Process current arrivals
                       if (arrivals && Array.isArray(arrivals) && arrivals.length > 0) {
                           arrivals.forEach(bus => {
                               const regNumber = bus.vehicleId; if (!regNumber) return;

                               const expectedArrivalTime = new Date(bus.expectedArrival).getTime();
                               const apiDestination = bus.destinationName || "Unknown";
                               const apiDirectionValue = bus.direction;
                               const currentStopName = bus.stationName || "Unknown"; // Get current stop name
                               let directionId = undefined;
                               if (apiDirectionValue === 'outbound') { directionId = 1; }
                               else if (apiDirectionValue === 'inbound') { directionId = 2; }

                               // Capture destination names for sequence headings IF NOT MANUALLY SET
                               // Only capture if the auto variable is still null
                               if (directionId === 1 && !manualSequenceHeadings.outbound && !autoOutboundDestinationName && apiDestination !== "Unknown") {
                                   autoOutboundDestinationName = apiDestination;
                                   outboundHeadingUpdated = true; // Mark for update after loop
                               }
                               if (directionId === 2 && !manualSequenceHeadings.inbound && !autoInboundDestinationName && apiDestination !== "Unknown") {
                                   autoInboundDestinationName = apiDestination;
                                   inboundHeadingUpdated = true; // Mark for update after loop
                               }

                               // *** START REVISED CURTAILMENT CHECK ***
                               const isNonFinalDestination = apiDestination && apiDestination !== "Unknown" && !finalDestinations.includes(apiDestination);

                               if (isNonFinalDestination) {
                                   const alreadyLoggedRecently = allCurtailments.some(c =>
                                       c.regNumber === regNumber &&
                                       c.curtailedDestination === apiDestination &&
                                       c.timestamp &&
                                       (now - c.timestamp) < debounceMs
                                   );

                                   if (!alreadyLoggedRecently) {
                                       const logDate = new Date();
                                       const newEntry = {
                                           route: dynamicRouteId,
                                           regNumber: regNumber,
                                           curtailedDestination: apiDestination,
                                           curtailmentTime: logDate.toLocaleString('en-GB', { timeZone: 'Europe/London', dateStyle: 'short', timeStyle: 'short'}),
                                           timestamp: logDate.getTime()
                                       };
                                       allCurtailments.push(newEntry);
                                       newCurtailmentDetected = true;
                                       console.log(`Detected curtailment for ${regNumber} to non-final destination: ${apiDestination}. Logging.`);
                                   }
                               }
                               // *** END REVISED CURTAILMENT CHECK ***

                               // --- Update last seen data ---
                               const lastSeenEntry = busLastSeen[regNumber] || {};
                               let needsUpdate = false;
                               if (lastSeenEntry.time !== now) { lastSeenEntry.time = now; needsUpdate = true; }
                               if (lastSeenEntry.destination !== apiDestination) { lastSeenEntry.destination = apiDestination; needsUpdate = true; }
                               if (lastSeenEntry.direction !== directionId) { lastSeenEntry.direction = directionId; needsUpdate = true; }
                               if (currentStopName && currentStopName !== "Unknown" && lastSeenEntry.lastStopName !== currentStopName) {
                                    lastSeenEntry.lastStopName = currentStopName;
                                    needsUpdate = true;
                               }
                               if (needsUpdate) {
                                    busLastSeen[regNumber] = lastSeenEntry;
                                    busLastSeenModified = true;
                               }


                               // Add to active list if it has a future prediction
                               const existingPredictionTime = activeBuses[regNumber]?.expectedArrivalTimeMs;
                               if (!isNaN(expectedArrivalTime) && expectedArrivalTime >= now) { // Only include future arrivals
                                   if (!existingPredictionTime || expectedArrivalTime < existingPredictionTime) {
                                       const fleetNumber = getTMPForRegistration(regNumber);
                                       const displayDestination = getEffectiveDestination(regNumber, directionId, apiDestination);
                                       const arrivalTimeString = new Date(expectedArrivalTime).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                                       activeBuses[regNumber] = {
                                           fleetNumber: fleetNumber,
                                           regNumber: regNumber,
                                           apiDestination: apiDestination,
                                           displayDestination: displayDestination,
                                           stopName: currentStopName, // Use the current stop name for live buses
                                           stopArrivalTime: arrivalTimeString,
                                           expectedArrivalTimeMs: expectedArrivalTime,
                                           isGhost: false
                                       };
                                   }
                               }
                           });
                       }

                       // --- Update Sequence Headings if Names were Captured ---
                       if (outboundHeadingUpdated) updateSequenceHeading('outbound', null); // Pass null as fallback is not needed
                       if (inboundHeadingUpdated) updateSequenceHeading('inbound', null);

                       // --- Save busLastSeen IF it was modified during arrival processing ---
                       if (busLastSeenModified) {
                           saveToStorage(busLastSeenKey, busLastSeen);
                           // console.log("[Ghost Debug] Saved updated busLastSeen object to localStorage."); // Optional debug
                       }

                       // --- Combine Active and Ghost Buses ---
                       const displayBuses = Object.values(activeBuses);
                       // Use the potentially updated busLastSeen from memory/variable, not reloading from storage here
                       for (const reg in busLastSeen) {
                           if (!activeBuses[reg]) { // If the bus is NOT in the current live feed
                               const lastSeenData = busLastSeen[reg]; // Get the whole object
                               const lastSeenTime = lastSeenData?.time || 0;
                               const timeDiff = now - lastSeenTime;
                               if (timeDiff < timeoutMs) { // Check if within timeout period
                                   const lastDest = lastSeenData?.destination || 'Unknown';
                                   const lastDirId = lastSeenData?.direction;
                                   const lastKnownStop = lastSeenData?.lastStopName || 'Unknown'; // Get from the object
                                   const lastSeenDate = new Date(lastSeenTime);
                                   const lastSeenTimeString = lastSeenDate.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

                                   // console.log(`[Ghost Debug] Creating ghost for ${reg}. Last seen data:`, lastSeenData, ` Retrieved lastKnownStop: ${lastKnownStop}`);

                                   const ghostBus = {
                                       fleetNumber: getTMPForRegistration(reg),
                                       regNumber: reg,
                                       apiDestination: lastDest,
                                       displayDestination: getEffectiveDestination(reg, lastDirId, lastDest),
                                       stopName: lastKnownStop, // <-- USE LAST KNOWN STOP HERE
                                       stopArrivalTime: `(Last seen ${lastSeenTimeString})`,
                                       expectedArrivalTimeMs: 0,
                                       isGhost: true
                                   };
                                   displayBuses.push(ghostBus);
                               }
                           }
                       }
                       // --- End Combine ---


                       // Save curtailments if new ones were detected
                       if (newCurtailmentDetected) {
                           saveToStorage(curtailedBusesKey, allCurtailments);
                           populateCurtailmentsTable(); // Update display immediately
                       }

                       // Cleanup logic for truly timed out buses from busLastSeen and tmpMap
                       tmpMap = loadFromStorage(tmpMapKey, {}); // Reload map before potential cleanup
                       let updatedTmpMap = false;
                       let busLastSeenForCleanupModified = false; // Flag if cleanup happens
                       let currentBusLastSeenForCleanup = loadFromStorage(busLastSeenKey, {});
                       for (const reg in currentBusLastSeenForCleanup) {
                           if (now - (currentBusLastSeenForCleanup[reg]?.time || 0) > timeoutMs) {
                               console.log(`Permanently removing timed out bus ${reg} from busLastSeen.`);
                               delete currentBusLastSeenForCleanup[reg]; // Remove from the object we'll save
                               busLastSeenForCleanupModified = true; // Mark that we need to save
                               if (tmpMap[reg] && (tmpMap[reg].startsWith('TMP') || tmpMap[reg].startsWith('ERR'))) {
                                   delete tmpMap[reg];
                                   updatedTmpMap = true;
                                   console.log(`Also removed auto-TMP assignment for timed out bus ${reg}.`);
                                   try {
                                       let g = loadFromStorage(tmpGenerationInfoKey,{});
                                       if(g[reg]){
                                            delete g[reg];
                                            saveToStorage(tmpGenerationInfoKey,g);
                                            console.log(`Removed generation info for ${reg}.`);
                                       }
                                   } catch(e){
                                        console.error(`Error removing generation info for ${reg}`, e);
                                   }
                               }
                           }
                       }
                       if (busLastSeenForCleanupModified) { saveToStorage(busLastSeenKey, currentBusLastSeenForCleanup); }
                       if (updatedTmpMap) { saveToStorage(tmpMapKey, tmpMap); }

                       const sortedBuses = displayBuses.sort((a, b) => (a.fleetNumber || '').localeCompare(b.fleetNumber || ''));

                       // --- Update Filter Options ---
                       const options = { fleet: new Set(), reg: new Set(), destination: new Set(), stop: new Set(), arrival: new Set() };
                       sortedBuses.forEach(bus => { options.fleet.add(bus.fleetNumber); options.reg.add(bus.regNumber); options.destination.add(bus.displayDestination); options.stop.add(bus.stopName); options.arrival.add(bus.stopArrivalTime); });
                       const filters = [filterFleet, filterReg, filterDestination, filterStop, filterArrival];
                       const currentFilterValues = { fleet: filterFleet.value, reg: filterReg.value, destination: filterDestination.value, stop: filterStop.value, arrival: filterArrival.value };
                       filters.forEach(f => { if(f) while (f.options.length > 1) f.remove(1); });
                       // Populate filters
                       [...options.fleet].sort().forEach(val => filterFleet?.add(new Option(val, val))); [...options.reg].sort().forEach(val => filterReg?.add(new Option(val, val))); [...options.destination].sort().forEach(val => filterDestination?.add(new Option(val, val))); [...options.stop].sort().forEach(val => filterStop?.add(new Option(val, val))); [...options.arrival].sort().forEach(val => filterArrival?.add(new Option(val, val)));
                       // Restore filter values
                       const restoreFilterValue = (el, val) => { if (el && val && [...el.options].some(opt => opt.value === val)) el.value = val; else if (el) el.value = ""; };
                       restoreFilterValue(filterFleet, currentFilterValues.fleet); restoreFilterValue(filterReg, currentFilterValues.reg); restoreFilterValue(filterDestination, currentFilterValues.destination); restoreFilterValue(filterStop, currentFilterValues.stop); restoreFilterValue(filterArrival, currentFilterValues.arrival);
                       // --- End Update Filters ---

                       // Populate Tracker Table
                       trackerTable.innerHTML = "";
                       if (sortedBuses.length === 0) { trackerTable.innerHTML = `<tr><td colspan="5">No buses currently tracking or recently seen on Route ${dynamicRouteId}.</td></tr>`; }
                       else {
                           sortedBuses.forEach(bus => {
                               const row = document.createElement("tr");
                               if (bus.isGhost) { row.classList.add('ghost-bus'); }
                               // Row HTML uses bus.stopName, which is now correctly set for ghosts too
                               row.innerHTML = `
                                   <td>${bus.fleetNumber || 'N/A'}</td>
                                   <td>${bus.regNumber || 'N/A'}</td>
                                   <td>${bus.displayDestination}</td>
                                   <td>${bus.stopName || 'N/A'}</td>
                                   <td>${bus.stopArrivalTime || 'N/A'}</td>`;
                               trackerTable.appendChild(row);
                           });
                       }

                       // Update counters and timestamp
                       const busCounterElem = document.getElementById('bus-counter'); if(busCounterElem) busCounterElem.textContent = `Buses on Route ${dynamicRouteId}: ${sortedBuses.length}`;
                       if(updateTime) updateTime.textContent = `Last Updated: ${new Date().toLocaleTimeString()}`;
                       filterArrivalsTable(); // Apply filters AFTER populating table

                  } catch (error) { console.error(`Error fetching/processing live data for [${dynamicRouteId}]:`, error); if (trackerTable && !trackerTable.innerHTML.includes("Error")) { trackerTable.innerHTML = `<tr><td colspan="5">Error updating data. Check console.</td></tr>`; } }
             } // --- End fetchLiveBusData ---

             // --- Filter Application Logic ---
             const filterFleet = document.getElementById("filter-fleet"); const filterReg = document.getElementById("filter-reg"); const filterDestination = document.getElementById("filter-destination"); const filterStop = document.getElementById("filter-stop"); const filterArrival = document.getElementById("filter-arrival"); const arrivalsTableBody = document.getElementById("tracker-table");
             function saveFilterState() { const filterState = { fleet: filterFleet ? filterFleet.value : "", reg: filterReg ? filterReg.value : "", destination: filterDestination ? filterDestination.value : "", stop: filterStop ? filterStop.value : "", arrival: filterArrival ? filterArrival.value : "" }; saveToStorage(filterStateKey, filterState); }
             function filterArrivalsTable() { if (!arrivalsTableBody || !filterFleet || !filterReg || !filterDestination || !filterStop || !filterArrival) return; const fleetFilter = filterFleet.value; const regFilter = filterReg.value; const destinationFilter = filterDestination.value; const stopFilter = filterStop.value; const arrivalFilter = filterArrival.value; let visibleRowCount = 0; const rows = arrivalsTableBody.querySelectorAll("tr"); rows.forEach(row => { if (row.cells.length < 5) { if (fleetFilter || regFilter || destinationFilter || stopFilter || arrivalFilter) { row.style.display = "none"; } else { row.style.display = ""; } return; } const fleet = row.cells[0].textContent; const reg = row.cells[1].textContent; const destination = row.cells[2].textContent; const stop = row.cells[3].textContent; const arrival = row.cells[4].textContent; // This now includes absolute time or "(Last seen...)"
                 const fleetMatch = !fleetFilter || fleet === fleetFilter; const regMatch = !regFilter || reg === regFilter; const destinationMatch = !destinationFilter || destination === destinationFilter; const stopMatch = !stopFilter || stop === stopFilter; const arrivalMatch = !arrivalFilter || arrival === arrivalFilter; const showRow = fleetMatch && regMatch && destinationMatch && stopMatch && arrivalMatch; row.style.display = showRow ? "" : "none"; if (showRow) { visibleRowCount++; } }); }

             // --- Attach Event Listeners ---
             if (filterFleet) filterFleet.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); }); if (filterReg) filterReg.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); }); if (filterDestination) filterDestination.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); }); if (filterStop) filterStop.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); }); if (filterArrival) filterArrival.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); });

             // --- Initial Load Logic ---
             async function initialize() { // Make initialize async
                 console.log(`Initializing full tracker for route: ${dynamicRouteId}`);
                 populateCurtailmentsTable(); // Populate curtailments first

                 // Load any saved manual heading overrides first
                 manualSequenceHeadings = loadFromStorage(sequenceHeadingOverrideKey, {}); // Load manual overrides
                 console.log('[Sequence Heading] Loaded manual overrides on init:', manualSequenceHeadings);

                 // Fetch route sequence data (uses cache where possible)
                 await fetchAndDisplayRouteSequence(dynamicRouteId);

                 // Load saved filters
                 const initialFilterState = loadFromStorage(filterStateKey, {});
                 if (initialFilterState && typeof initialFilterState === 'object' && Object.keys(initialFilterState).length > 0) {
                    if (filterFleet) filterFleet.value = initialFilterState.fleet || "";
                    if (filterReg) filterReg.value = initialFilterState.reg || "";
                    if (filterDestination) filterDestination.value = initialFilterState.destination || "";
                    if (filterStop) filterStop.value = initialFilterState.stop || "";
                    if (filterArrival) filterArrival.value = initialFilterState.arrival || "";
                 }

                 // Fetch live bus data for the first time
                 await fetchLiveBusData(); // await ensures filters are applied after first load

                 // Set interval for subsequent refreshes
                 setInterval(fetchLiveBusData, 30000); // Refresh every 30 seconds
             }

             // --- Run Initialization ---
              if (document.readyState === 'loading') {
                  document.addEventListener('DOMContentLoaded', initialize);
              } else {
                  initialize(); // Already loaded
              }

         } // End of the main 'else' block (if dynamicRouteId was valid)
     </script>
</body>
</html>