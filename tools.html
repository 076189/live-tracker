<!DOCTYPE html>
<html>
<head>
    <title>Live Tracker (Tools)</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* Basic Reset & Font */
        body, html { margin: 0; padding: 0; box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }
        body { font-family: Arial, sans-serif; padding: 20px; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; background-color: #f4f4f4; flex-direction: column; }
        /* Containers */
        .login-container, .app-container { background-color: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); text-align: center; margin: 20px auto; width: 90%; max-width: 800px; }
        .login-container { min-width: 300px; max-width: 400px; }
        /* Headings and Text */
        h1, h2, h3, h4 { margin-top: 0; color: #333; }
        h1 { margin-bottom: 20px; } h2 { margin-bottom: 20px; } h3 { margin-bottom: 15px; }
        h4 { margin-top: 25px; border-top: 1px solid #ccc; padding-top: 15px; margin-bottom: 10px; text-align: center; }
        .welcome-message { font-size: 1.2em; color: #555; margin-bottom: 20px; }
        .description-text { font-size: 0.9em; color: #666; margin-top: 5px; margin-bottom: 15px; text-align: center; } /* Default center */
        .status-message { margin-top: 10px; text-align: center; min-height: 1em; font-weight: bold; }
        .export-reminder-message { display: none; padding: 10px 15px; margin-bottom: 20px; border-radius: 4px; border: 1px solid #ffeeba; background-color: #fff3cd; color: #856404; font-weight: bold; text-align: center; }
        .security-warning { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 10px 15px; margin: 15px 0; border-radius: 4px; font-size: 0.9em; text-align: left; }
        /* Button Styles & Grouping */
        .blue-button, .reset-button, .danger-button, .secondary-button { padding: 10px 20px; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; margin-right: 10px; margin-bottom: 10px; display: inline-block; transition: background-color 0.2s ease; }
        .blue-button { background-color: #007bff; } .blue-button:hover { background-color: #0056b3; }
        .reset-button { background-color: #ffc107; color: black; border: 1px solid #d39e00; } .reset-button:hover { background-color: #e0a800; }
        .danger-button { background-color: #dc3545; } .danger-button:hover { background-color: #c82333; }
        .secondary-button { background-color: #6c757d; font-size: 0.9em; padding: 6px 12px;} .secondary-button:hover { background-color: #5a6268; }
        .blue-button:last-of-type, .reset-button:last-of-type, .danger-button:last-of-type, .secondary-button:last-of-type { margin-right: 0; }
        .main-actions-container { margin-bottom: 25px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
        .data-actions-container { /* Now treated as a section, not always visible */ margin-bottom: 20px; padding: 20px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9; }
        /* .other-actions-container { REMOVED } */
        /* Forms & Inputs */
        .form-group, .settings-group { margin-bottom: 15px; text-align: left; }
        .form-group label, .settings-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        .form-group-inline { display: flex; align-items: center; text-align: left; margin-bottom: 15px;}
        .form-group-inline input[type="checkbox"] { width: auto; margin-right: 8px; height: 1em; margin-bottom: 0;}
        .form-group-inline label { font-weight: normal; margin-bottom: 0; }
        fieldset { border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-bottom: 20px; }
        legend { font-weight: bold; padding: 0 5px; color: #555; }
        input[type="text"], input[type="password"], input[type="time"], input[type="number"], select, textarea { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; margin-bottom: 10px; font-size: 1em; font-family: inherit; }
        #add-curtailment-form > button, #manual-fleet-form > button,
        #settings-form fieldset button, .settings-group button,
        .data-actions-container .action-group button { /* Target buttons inside action-group */
             width: auto; display: inline-block; margin: 0 5px 10px 5px; /* Adjust margin for centering */
        }
        /* Section/Form Styles */
        #add-curtailment-form, #manual-fleet-form, #settings-form, #data-actions { /* Added data-actions */
            margin-top: 20px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
            text-align: left; /* Default left align for labels etc */
            margin-bottom: 20px;
        }
        #add-curtailment-form h3, #manual-fleet-form h3, #settings-form h2, #data-actions h3 { /* Added data-actions */
            margin-top: 0;
            text-align: center;
            margin-bottom: 15px;
            border: none; /* Remove border from main h2 style */
            padding: 0;
        }
        /* User Management Table */
        #user-management-table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.9em; }
        #user-management-table th, #user-management-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        #user-management-table th { background-color: #f2f2f2; }
        #user-management-table select, #user-management-table input[type="password"] { padding: 5px 8px; font-size: 0.9em; margin: 0; width: auto; max-width: 150px; }
        #user-management-table button { padding: 5px 8px; font-size: 0.9em; margin: 0 5px 0 0; width: auto; }
        #user-management-table .delete-user-btn { background-color: #dc3545; color: white; border: none; }
        #user-management-table .delete-user-btn:hover { background-color: #c82333; }
        /* Manual Fleet Specific */
        .revert-section, .reset-all-section { margin-top: 25px; border-top: 1px dashed #ccc; padding-top: 20px; text-align: center; } /* Added reset-all, centered */
        #manual-assignments-display { text-align: left; max-height: 150px; overflow-y: auto; border: 1px solid #eee; padding: 10px; background-color: white; font-size: 0.9em; line-height: 1.4; margin-bottom: 20px; }
        #manual-assignments-display div { padding: 2px 0; }
        #manual-assignments-display strong { display: inline-block; min-width: 80px; }
        /* Modal Styles */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-box { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); text-align: left; width: 90%; max-width: 800px; max-height: 80%; display: flex; flex-direction: column; overflow: hidden; }
        .modal-box h3 { margin-top: 0; text-align: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; flex-shrink: 0; }
        .modal-content { flex-grow: 1; overflow-y: auto; font-size: 0.9em; margin-bottom: 15px; }
        .modal-content div { border-bottom: 1px dotted #eee; padding: 8px 4px; display: flex; flex-wrap: wrap; align-items: center; gap: 10px; }
        .modal-content span { line-height: 1.4; }
        .modal-content strong { margin-right: 4px; color: #555; }
        .modal-content .delete-curtailment-btn { padding: 3px 8px; font-size: 0.85em; background-color: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer; margin-left: auto; transition: background-color 0.2s ease; }
        .modal-content .delete-curtailment-btn:hover { background-color: #c82333; }
        .modal-buttons { text-align: right; margin-top: auto; padding-top: 15px; border-top: 1px solid #eee; flex-shrink: 0; }
        .modal-buttons button { margin-left: 10px; }
        .modal-buttons .cancel-button { background-color: #6c757d; }
        .modal-buttons .cancel-button:hover { background-color: #5a6268; }
        /* Utility */
        .hidden { display: none; }
        /* Centering Lower Sections Fix */
        /* #data-actions, REMOVED */ #app-container > div:has(#logout-button) { text-align: center; }
        /* Description Text Margin Fix */
        #manual-fleet-form div > .description-text { margin-top: 5px; }
        /* Backup/Restore Specific Alignment */
        .action-group {
            text-align: center; /* Center content within the group */
            margin-bottom: 20px; /* Add space below each group */
        }
        .action-group p.description-text {
             margin-top: 8px; /* Add space above description */
             margin-bottom: 0; /* Remove extra bottom margin */
        }

    </style>
</head>
<body>
    <div id="login-container" class="login-container">
        <h2>Live Tracker Tools Login</h2>
        <form onsubmit="login(); return false;">
              <div class="form-group"> <label for="username">Username:</label> <input type="text" id="username" name="username" required autocomplete="username"> </div>
              <div class="form-group"> <label for="password">Password:</label> <input type="password" id="password" name="password" required autocomplete="current-password"> </div>
              <div class="form-group-inline"> <input type="checkbox" id="stayLoggedInCheckbox" name="stayLoggedIn"> <label for="stayLoggedInCheckbox">Stay logged in (disables auto-logout this session)</label> </div>
              <div class="form-group" style="text-align: center;"> <button type="submit" class="blue-button">Login</button> <p id="login-error" style="color: red; margin-top: 10px; min-height: 1em;"></p> </div>
        </form>
    </div>

    <div id="app-container" class="app-container hidden">
        <h1>Live Tracker Tools</h1>
        <p id="welcome-message" class="welcome-message"></p>
        <div id="export-reminder" class="export-reminder-message"></div>

        <div id="main-actions-container" class="main-actions-container">
            <button id="toggle-add-curtailment" onclick="showSection('add-curtailment-form')" class="blue-button hidden">Add New Curtailment</button>
            <button id="toggle-manual-fleet" onclick="showSection('manual-fleet-form')" class="blue-button hidden">Assign / View Manual Fleet</button>
            <button id="view-all-curtailments-btn" onclick="showAllCurtailmentsModal()" class="blue-button hidden">View / Manage All Curtailments</button> <button id="toggle-backup-restore" onclick="showSection('data-actions')" class="blue-button hidden">Backup & Restore</button>
            <button id="toggle-settings" onclick="showSection('settings-form')" class="blue-button hidden">Settings</button>
        </div>

        <div style="text-align: center; margin-bottom: 20px;">
             <button id="go-back-button" class="blue-button secondary-button hidden" onclick="goBackToMainView()">‚Üê Go Back to Menu</button>
        </div>

        <div id="add-curtailment-form" class="add-curtailment-form hidden">
              <h3>Add New Curtailment</h3>
              <div class="form-group"> <label for="route">Route Number:</label> <input type="text" id="route" required placeholder="e.g., 184"></div>
              <div class="form-group"> <label for="regNumber">Bus Registration:</label> <input type="text" id="regNumber" required placeholder="e.g., AB12CDE"></div>
              <div class="form-group"> <label for="curtailedDestination">Curtailed Destination:</label> <input type="text" id="curtailedDestination" required placeholder="e.g., Arnos Grove Station"></div>
              <div class="form-group"> <label for="curtailmentTimeInput">Time Logged (HH:MM):</label> <input type="time" id="curtailmentTimeInput" required></div>
              <button type="button" onclick="addCurtailment()" class="blue-button">Add Curtailment</button> <p id="add-curtailment-message" class="status-message" style="color: green;"></p>
        </div>

        <div id="manual-fleet-form" class="manual-fleet-form hidden">
              <h3>Assign Manual Fleet Number</h3>
              <div class="form-group"> <label for="manualRegNumber">Bus Registration:</label> <input type="text" id="manualRegNumber" placeholder="e.g., AB12CDE"></div>
              <div class="form-group"> <label for="manualFleetNumber">Real Fleet Number:</label> <input type="text" id="manualFleetNumber" placeholder="e.g., VH45161, 9001"></div>
              <button type="button" onclick="assignManualFleetNumber()" class="blue-button">Assign Fleet Number</button> <p id="assign-status" class="status-message" style="color: green;"></p>
              <div style="margin-top: 25px; padding-top: 15px; border-top: 1px solid #eee; text-align: center;"> <button id="view-auto-tmp-btn" type="button" onclick="showAutoTmpModal()" class="blue-button">View Auto-Generated TMPs</button>
                  <p class="description-text">View a list of registrations with system-assigned TMP/ERR numbers.</p>
              </div>
              <h4>Current Manual Assignments</h4> <div id="manual-assignments-display">Loading...</div>
              <div class="revert-section hidden"> <label for="revertRegNumber">Registration to Revert:</label>
                  <input type="text" id="revertRegNumber" placeholder="e.g., AB12CDE">
                  <button type="button" onclick="revertToTMP()" class="blue-button reset-button">Revert to Auto TMP</button>
                  <p id="revert-status" class="status-message" style="color: green;"></p>
              </div>
              <div class="reset-all-section hidden"> <h4>Reset All Assignments (Admin Only)</h4>
                  <button type="button" id="reset-tmp-button" onclick="resetTMPMap()" class="reset-button">Reset ALL TMP Assignments</button>
                  <p class="description-text">Clears the stored Registration -> TMP map. Requires password.</p>
             </div>
        </div>

        <div id="settings-form" class="settings-form hidden">
            <h2>Settings</h2>
            <fieldset> <legend>Tracker Settings</legend> <div class="settings-group"> <label for="setting-debounce">Curtailment Debounce Time (minutes):</label> <input type="number" id="setting-debounce" min="0" step="1" placeholder="e.g., 60"> <p class="description-text" style="text-align: left;">Time before logging the same curtailment again (used by auto-detect).</p> </div> <div class="settings-group"> <label for="setting-timeout">Bus Timeout Threshold (minutes):</label> <input type="number" id="setting-timeout" min="1" step="1" placeholder="e.g., 30"> <p class="description-text" style="text-align: left;">Time a bus stays listed after disappearing from API feed.</p> </div> <div class="settings-group"> <label for="setting-auto-logout">Auto Logout Time (minutes):</label> <input type="number" id="setting-auto-logout" min="0" step="1" placeholder="e.g., 30"> <p class="description-text" style="text-align: left;">Automatically log out after this many minutes from login. Set to 0 to disable.</p> </div> <button type="button" onclick="saveTrackerSettings()" class="blue-button">Save Tracker Settings</button> <p id="tracker-settings-message" class="status-message" style="color: green;"></p> </fieldset>
            <fieldset> <legend>Change My Password</legend> <div class="settings-group"> <label for="current-password">Current Password:</label> <input type="password" id="current-password" required autocomplete="current-password"> </div> <div class="settings-group"> <label for="new-password">New Password:</label> <input type="password" id="new-password" required autocomplete="new-password"> </div> <div class="settings-group"> <label for="confirm-new-password">Confirm New Password:</label> <input type="password" id="confirm-new-password" required autocomplete="new-password"> </div> <button type="button" onclick="changeMyPassword()" class="blue-button">Change Password</button> <p id="change-password-message" class="status-message" style="color: green;"></p> </fieldset>
            <fieldset id="admin-user-management" class="hidden">
                <legend>User Management (Admin)</legend>
                <h4>Add New User</h4>
                <div class="settings-group"> <label for="add-username">New Username:</label> <input type="text" id="add-username" autocomplete="username"> </div>
                <div class="settings-group"> <label for="add-user-password">Password:</label> <input type="password" id="add-user-password" autocomplete="new-password"> </div>
                <div class="settings-group"> <label for="add-user-role">Role:</label> <select id="add-user-role"><option value="user">User</option><option value="moderator">Moderator</option><option value="admin">Admin</option></select> </div>
                <button type="button" onclick="addUser()" class="blue-button">Add User</button> <p id="add-user-message" class="status-message" style="color: green;"></p>
                <h4 style="margin-top: 30px;">Manage Existing Users</h4>
                <div id="user-list-container" style="max-height: 300px; overflow-y: auto;">
                    <table id="user-management-table">
                        <thead> <tr><th>Username</th><th>Role</th><th>New Password</th><th>Actions</th></tr> </thead>
                        <tbody id="user-management-tbody"></tbody>
                    </table>
                </div>
                <p id="user-management-message" class="status-message" style="color: green;"></p>
            </fieldset>
        </div>

        <div id="data-actions" class="data-actions-container hidden">
             <h3>Backup & Restore</h3>
             <div class="action-group">
                 <button type="button" id="export-button" onclick="exportCurtailments()" class="blue-button">Export ALL Curtailments</button>
                 <button type="button" id="import-button" onclick="document.getElementById('import-file-curtailments').click()" class="blue-button">Import ALL Curtailments</button>
                 <input type="file" id="import-file-curtailments" accept=".json" class="hidden">
                 <p class="description-text">Save or load all curtailment entries to/from a JSON file.</p>
             </div>
             <div class="action-group" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
                 <button type="button" id="export-tmp-button" onclick="exportTmpMap()" class="blue-button">Export ALL Fleet/TMP</button>
                 <button type="button" id="import-tmp-button" onclick="document.getElementById('import-file-tmp').click()" class="blue-button">Import ALL Fleet/TMP</button>
                 <input type="file" id="import-file-tmp" accept=".json" class="hidden">
                 <p class="description-text">Save or load all Registration -> Fleet/TMP assignments to/from a JSON file.</p>
             </div>
        </div>

        <div style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px; text-align: center;"> <button type="button" id="logout-button" onclick="logout()" class="blue-button" style="background-color: #6c757d;">Logout</button>
        </div>
    </div>

    <div id="password-modal" class="modal-overlay hidden">
        <div class="modal-box">
            <h3>Confirm Action</h3>
            <label for="confirm-password">Please enter your password to confirm TMP reset:</label>
            <input type="password" id="confirm-password" name="confirm-password" required autocomplete="current-password">
            <p id="password-modal-error" style="color: red; min-height: 1em; margin-top: 5px;"></p>
            <div class="modal-buttons">
                <button type="button" onclick="cancelPasswordReset()" class="blue-button cancel-button">Cancel</button>
                <button type="button" onclick="handlePasswordConfirm()" class="blue-button">Confirm Reset</button>
            </div>
        </div>
    </div>

    <div id="all-curtailments-modal" class="modal-overlay hidden">
        <div class="modal-box">
            <h3>All Stored Curtailments</h3>
            <div id="all-curtailments-list" class="modal-content">
                <p>Loading...</p>
            </div>
            <div class="modal-buttons">
                <button type="button" onclick="hideAllCurtailmentsModal()" class="blue-button cancel-button">Close</button>
            </div>
        </div>
    </div>

    <div id="auto-tmp-modal" class="modal-overlay hidden">
        <div class="modal-box">
            <h3>Auto-Generated TMP Assignments</h3>
            <p class="description-text" style="text-align:left; margin-top:0;">This list shows registrations currently assigned an automatic TMP or ERR number. Use the 'Assign / View Manual Fleet' section to assign their real fleet numbers.</p>
            <div id="auto-tmp-list" class="modal-content" style="font-size: 0.95em;">
                <p>Loading...</p>
            </div>
            <div class="modal-buttons">
                <button type="button" onclick="hideAutoTmpModal()" class="blue-button cancel-button">Close</button>
            </div>
        </div>
    </div>

<script>
    console.log("DEBUG: Script execution started."); // DEBUG

    // --- User Auth, Basic Setup, Constants ---
    const usersStorageKey = 'liveTrackerUsers'; let users = {}; let isLoggedIn = false; let currentUsername = null;
    const tmpMapKey = "tmpRegistrationMap"; const settingsKey = "trackerGlobalSettings"; const defaultSettings = { debounceMinutes: 60, timeoutMinutes: 30, autoLogoutMinutes: 30 }; const lastExportKey = 'lastCurtailmentExportTimestamp'; const tmpGenerationInfoKey = "tmpGenerationInfo";


    // --- Storage Helpers ---
    function loadFromStorage(key, defaultValue = {}) {
        // console.log(`DEBUG: Attempting to load from storage - Key: ${key}`); // DEBUG
        try {
            const data = localStorage.getItem(key);
            if (data) {
                // console.log(`DEBUG: Found data for key ${key}:`, data.substring(0, 100) + (data.length > 100 ? '...' : '')); // DEBUG - Log snippet
                const parsed = JSON.parse(data);
                if (typeof parsed === 'object' && parsed !== null) {
                    // console.log(`DEBUG: Successfully parsed data for key ${key}.`); // DEBUG
                    return parsed;
                } else {
                     console.warn(`DEBUG: Parsed data for key ${key} is not an object.`); // DEBUG
                     return defaultValue;
                }
            }
            // console.log(`DEBUG: No data found for key ${key}, returning default.`); // DEBUG
            return defaultValue;
        } catch (e) {
            console.error(`DEBUG: Error loading ${key}:`, e); // DEBUG
            return defaultValue;
        }
    }
    function saveToStorage(key, data) {
        // console.log(`DEBUG: Attempting to save to storage - Key: ${key}`); // DEBUG
        try {
            const stringifiedData = JSON.stringify(data);
            // console.log(`DEBUG: Saving data for key ${key}:`, stringifiedData.substring(0, 100) + (stringifiedData.length > 100 ? '...' : '')); // DEBUG - Log snippet
            localStorage.setItem(key, stringifiedData);
            // console.log(`DEBUG: Successfully saved data for key ${key}.`); // DEBUG
        } catch (e) {
            console.error(`DEBUG: Error saving ${key}:`, e); // DEBUG
            alert(`Error saving ${key}. Storage might be full.`);
        }
    }


    // --- DOM Element Refs (Includes new navigation elements) ---
    console.log("DEBUG: Getting DOM element references."); // DEBUG
    const loginContainer = document.getElementById('login-container');
    const appContainer = document.getElementById('app-container');
    const loginError = document.getElementById('login-error');
    const mainActionsContainer = document.getElementById('main-actions-container'); // Main menu container
    const goBackButton = document.getElementById('go-back-button'); // Go Back button

    // Form Sections/Pages
    const addCurtailmentForm = document.getElementById('add-curtailment-form');
    const manualFleetForm = document.getElementById('manual-fleet-form');
    const settingsForm = document.getElementById('settings-form');
    const dataActionsSection = document.getElementById('data-actions'); // Backup/Restore Section

    // Buttons in Main Actions (needed for showApp visibility checks)
    const toggleAddCurtailmentButton = document.getElementById('toggle-add-curtailment');
    const toggleManualFleetButton = document.getElementById('toggle-manual-fleet');
    const viewAllCurtailmentsButton = document.getElementById('view-all-curtailments-btn');
    const toggleBackupRestoreButton = document.getElementById('toggle-backup-restore'); // New button
    const toggleSettingsButton = document.getElementById('toggle-settings');

    // Other elements... (keep existing refs, add resetTmpButton ref)
    const addCurtailmentMessage = document.getElementById('add-curtailment-message');
    const importCurtailmentsInput = document.getElementById('import-file-curtailments');
    const manualRegNumberInput = document.getElementById('manualRegNumber');
    const manualFleetNumberInput = document.getElementById('manualFleetNumber');
    const assignStatusElement = document.getElementById('assign-status');
    const manualAssignmentsDisplay = document.getElementById('manual-assignments-display');
    const revertRegNumberInput = document.getElementById('revertRegNumber');
    const revertStatusElement = document.getElementById('revert-status');
    const settingsDebounceInput = document.getElementById('setting-debounce');
    const settingsTimeoutInput = document.getElementById('setting-timeout');
    const settingsAutoLogoutInput = document.getElementById('setting-auto-logout');
    const trackerSettingsMessage = document.getElementById('tracker-settings-message');
    const currentPasswordInput = document.getElementById('current-password');
    const newPasswordInput = document.getElementById('new-password');
    const confirmNewPasswordInput = document.getElementById('confirm-new-password');
    const changePasswordMessage = document.getElementById('change-password-message');
    const adminUserManagementSection = document.getElementById('admin-user-management');
    const addUsernameInput = document.getElementById('add-username');
    const addUserPasswordInput = document.getElementById('add-user-password');
    const addUserRoleSelect = document.getElementById('add-user-role');
    const addUserMessage = document.getElementById('add-user-message');
    const userManagementTbody = document.getElementById('user-management-tbody');
    const userManagementMessage = document.getElementById('user-management-message');
    const welcomeMessageElement = document.getElementById('welcome-message');
    const passwordModal = document.getElementById('password-modal');
    const passwordModalInput = document.getElementById('confirm-password');
    const passwordModalError = document.getElementById('password-modal-error');
    const allCurtailmentsModal = document.getElementById('all-curtailments-modal');
    const allCurtailmentsList = document.getElementById('all-curtailments-list');
    // const dataActionsSection = document.getElementById('data-actions'); // Already defined above
    const exportButton = document.getElementById('export-button');
    const importButton = document.getElementById('import-button');
    // const otherActionsSection = document.getElementById('other-actions'); // REMOVED
    const resetTmpButton = document.getElementById('reset-tmp-button'); // Moved button ref
    const logoutButton = document.getElementById('logout-button');
    const autoTmpModal = document.getElementById('auto-tmp-modal');
    const autoTmpList = document.getElementById('auto-tmp-list');
    const viewAutoTmpBtn = document.getElementById('view-auto-tmp-btn');
    const exportTmpButton = document.getElementById('export-tmp-button');
    const importTmpButton = document.getElementById('import-tmp-button');
    const importTmpInput = document.getElementById('import-file-tmp');


    // --- Auth, Timer, Basic UI ---
    let sessionTimerId = null;
    function loadUsers() {
        console.log("DEBUG: loadUsers function called."); // DEBUG
        try{
            const d=localStorage.getItem(usersStorageKey);
            if(d){
                console.log("DEBUG: User data found in storage."); // DEBUG
                users=JSON.parse(d);
                if(!users.Ryan||!users.Ryan.pass||!users.Ryan.role){
                    console.warn("DEBUG: User data incomplete or missing 'Ryan' user, resetting."); // DEBUG
                    setDefaultUsers();
                } else {
                    console.log("DEBUG: User data loaded and seems valid."); // DEBUG
                }
            } else {
                console.log("DEBUG: No user data found in storage, setting defaults."); // DEBUG
                setDefaultUsers();
            }
        } catch(e){
            console.error("DEBUG: Error loading users, resetting:",e); // DEBUG
            setDefaultUsers();
        }
    }
    function setDefaultUsers() {
        console.log("DEBUG: setDefaultUsers function called."); // DEBUG
        users={'Ryan':{pass:'password',role:'admin'}};
        saveUsersToStorage();
    }
    function saveUsersToStorage() {
        console.log("DEBUG: saveUsersToStorage function called."); // DEBUG
        try{
            localStorage.setItem(usersStorageKey,JSON.stringify(users));
            console.log("DEBUG: Users saved to storage."); // DEBUG
        } catch(e){
            console.error("DEBUG: Error saving users:",e); // DEBUG
            alert("Error: Could not save user data.");
        }
    }
    function checkLogin() {
        console.log("DEBUG: checkLogin function called."); // DEBUG
        loadUsers();
        try{
            const storedUser = localStorage.getItem('loggedInUser');
            const storedLoggedInStatus = localStorage.getItem('isLoggedIn') === 'true';
            console.log(`DEBUG: Checking login status - Stored User: ${storedUser}, Logged In Status: ${storedLoggedInStatus}`); // DEBUG
            if(storedLoggedInStatus && storedUser && users[storedUser]){
                console.log(`DEBUG: User ${storedUser} is logged in. Showing app.`); // DEBUG
                isLoggedIn=true;
                currentUsername=storedUser;
                showApp();
            } else {
                console.log("DEBUG: User not logged in or data mismatch. Showing login."); // DEBUG
                isLoggedIn=false;
                currentUsername=null;
                localStorage.removeItem('isLoggedIn');
                localStorage.removeItem('loggedInUser');
                sessionStorage.removeItem('bypassAutoLogout');
                showLogin();
            }
        } catch(e){
            console.error("DEBUG: Error during checkLogin:",e); // DEBUG
            isLoggedIn=false;
            currentUsername=null;
            showLogin();
        }
    }
    function login() {
        console.log("DEBUG: login function called."); // DEBUG
        const u=document.getElementById('username'),p=document.getElementById('password'),c=document.getElementById('stayLoggedInCheckbox'),l=document.getElementById('login-error');
        if(!u||!p){console.error("DEBUG: Login elements missing.");if(l)l.textContent='Login form error.';return;}
        const usernameInput = u.value;
        const passwordInput = p.value;
        const stayLoggedInChecked = c ? c.checked : false;
        console.log(`DEBUG: Attempting login for user: ${usernameInput}, Stay Logged In: ${stayLoggedInChecked}`); // DEBUG
        if(l)l.textContent='';
        if(users.hasOwnProperty(usernameInput) && users[usernameInput].pass === passwordInput){
            console.log(`DEBUG: Login successful for user: ${usernameInput}`); // DEBUG
            localStorage.setItem('isLoggedIn','true');
            localStorage.setItem('loggedInUser',usernameInput);
            if(stayLoggedInChecked){
                sessionStorage.setItem('bypassAutoLogout','true');
                console.log("DEBUG: Bypassing auto-logout for this session."); // DEBUG
            } else {
                sessionStorage.removeItem('bypassAutoLogout');
                 console.log("DEBUG: Auto-logout enabled for this session."); // DEBUG
            }
            isLoggedIn=true;
            currentUsername=usernameInput;
            showApp();
        } else {
            console.log(`DEBUG: Login failed for user: ${usernameInput}`); // DEBUG
            if(l)l.textContent='Invalid username or password.';
            isLoggedIn=false;
            currentUsername=null;
            sessionStorage.removeItem('bypassAutoLogout');
        }
    }
    function logout() {
        console.log("DEBUG: logout function called."); // DEBUG
        if(sessionTimerId){
            console.log("DEBUG: Clearing session timer."); // DEBUG
            clearTimeout(sessionTimerId);
            sessionTimerId=null;
        }
        localStorage.setItem('isLoggedIn','false');
        localStorage.removeItem('loggedInUser');
        sessionStorage.removeItem('bypassAutoLogout');
        isLoggedIn=false;
        currentUsername=null;
        showLogin();
    }
    function logoutAfterSession() {
        console.log("DEBUG: logoutAfterSession function called."); // DEBUG
        if(isLoggedIn){
            const s=loadFromStorage(settingsKey,defaultSettings);
            const l=s.autoLogoutMinutes||0;
            console.log(`DEBUG: Session expired after ${l} minutes. Logging out.`); // DEBUG
            alert(`Session expired after ${l} minutes.`);
            logout();
        } else {
             console.log("DEBUG: logoutAfterSession called but user not logged in."); // DEBUG
        }
    }
    function startSessionTimer() {
        console.log("DEBUG: startSessionTimer function called."); // DEBUG
        if(sessionTimerId){
            console.log("DEBUG: Clearing existing session timer."); // DEBUG
            clearTimeout(sessionTimerId);
            sessionTimerId=null;
        }
        if(!isLoggedIn) {
            console.log("DEBUG: Not starting timer, user not logged in."); // DEBUG
            return;
        }
        const bypass = sessionStorage.getItem('bypassAutoLogout') === 'true';
        if(bypass) {
            console.log("DEBUG: Not starting timer, auto-logout bypassed for session."); // DEBUG
            return;
        }
        const s=loadFromStorage(settingsKey,defaultSettings);
        const logoutMinutes=(typeof s.autoLogoutMinutes==='number'&&s.autoLogoutMinutes>=0)?s.autoLogoutMinutes:defaultSettings.autoLogoutMinutes;
        if(logoutMinutes <= 0) {
             console.log("DEBUG: Not starting timer, auto-logout disabled (time <= 0)."); // DEBUG
             return;
        }
        const logoutMillis = logoutMinutes * 60 * 1000;
        console.log(`DEBUG: Starting session timer for ${logoutMinutes} minutes (${logoutMillis}ms).`); // DEBUG
        sessionTimerId=setTimeout(logoutAfterSession, logoutMillis);
    }


    // --- UPDATED showApp Function (Handles initial view and new structure) ---
    function showApp() {
        console.log("DEBUG: showApp function called."); // DEBUG
        try {
            if (!isLoggedIn || !currentUsername || !users[currentUsername]) {
                console.warn("DEBUG: showApp called but user not properly logged in. Logging out."); // DEBUG
                logout();
                return;
            }
            const userRole = users[currentUsername].role;
            console.log(`DEBUG: Showing app for user: ${currentUsername}, Role: ${userRole}`); // DEBUG

            if (loginContainer) loginContainer.classList.add('hidden');
            if (appContainer) appContainer.classList.remove('hidden');

            // Welcome message
            if (welcomeMessageElement) {
                if (currentUsername === 'Ryan') {
                    welcomeMessageElement.textContent = `Welcome, Ryan!`;
                } else {
                    welcomeMessageElement.textContent = `Welcome, ${currentUsername}!`;
                }
            }

            // Export reminder logic
            console.log("DEBUG: Checking export reminder."); // DEBUG
            const reminderElement = document.getElementById('export-reminder'); if (reminderElement) { try { const lastExportTimeStr = localStorage.getItem(lastExportKey); const sevenDaysInMillis = 7 * 24 * 60 * 60 * 1000; const now = Date.now(); let message = ''; let showBox = false; if (lastExportTimeStr) { const lastExportTime = parseInt(lastExportTimeStr, 10); if (!isNaN(lastExportTime)) { const diff = now - lastExportTime; if (diff > sevenDaysInMillis) { const daysSinceExport = Math.floor(diff / (1000 * 60 * 60 * 24)); message = `Reminder: It's been ${daysSinceExport} days since the last curtailment export. Consider backing up soon.`; showBox = true; } } else { message = "Reminder: Could not read last export time. Consider making a backup."; showBox = true; } } else { message = "Reminder: You haven't exported curtailment data before. Consider making an initial backup."; showBox = true; } reminderElement.textContent = message; reminderElement.style.display = showBox ? 'block' : 'none'; console.log(`DEBUG: Export reminder - Show: ${showBox}, Message: ${message}`); } catch (e) { console.error("DEBUG: Error checking last export time:", e); if(reminderElement) reminderElement.style.display = 'none'; } }


            // --- UI State Reset for Main View ---
            console.log("DEBUG: Resetting UI to main view."); // DEBUG
            if (mainActionsContainer) mainActionsContainer.classList.remove('hidden');
            if (goBackButton) goBackButton.classList.add('hidden');
            if (addCurtailmentForm) addCurtailmentForm.classList.add('hidden');
            if (manualFleetForm) manualFleetForm.classList.add('hidden');
            if (settingsForm) settingsForm.classList.add('hidden');
            if (dataActionsSection) dataActionsSection.classList.add('hidden'); // Hide Backup/Restore section

            // Reset status messages
            if(addCurtailmentMessage) addCurtailmentMessage.textContent = '';
            if(assignStatusElement) assignStatusElement.textContent = '';
            if(revertStatusElement) revertStatusElement.textContent = '';
            if(trackerSettingsMessage) trackerSettingsMessage.textContent = '';
            if(changePasswordMessage) changePasswordMessage.textContent = '';
            if(addUserMessage) addUserMessage.textContent = '';
            if(userManagementMessage) userManagementMessage.textContent = '';
            // --- End UI State Reset ---


            // Show main action buttons based on role
            console.log("DEBUG: Setting visibility of main action buttons based on role."); // DEBUG
            if (toggleAddCurtailmentButton) toggleAddCurtailmentButton.classList.toggle('hidden', !['admin', 'moderator'].includes(userRole));
            if (toggleManualFleetButton) toggleManualFleetButton.classList.toggle('hidden', !['admin', 'moderator'].includes(userRole));
            if (toggleBackupRestoreButton) toggleBackupRestoreButton.classList.toggle('hidden', !['admin', 'moderator'].includes(userRole)); // New button visibility
            if (toggleSettingsButton) toggleSettingsButton.classList.toggle('hidden', userRole !== 'admin');
            if (viewAllCurtailmentsButton) viewAllCurtailmentsButton.classList.remove('hidden'); // Available to all logged-in users

            // REMOVED: Logic for showing Data/Other Actions sections here, as they are now handled by showSection

            // Load general settings needed elsewhere (like auto-logout)
            loadTrackerSettings(); // Ensure settings are loaded for session timer etc.
            startSessionTimer(); // Start or restart the session timer

        } catch (e) {
            console.error("DEBUG: Error in showApp:", e); // DEBUG
            if (welcomeMessageElement) welcomeMessageElement.textContent = 'Error loading application.';
        }
    }

    // --- UPDATED showLogin Function ---
    function showLogin() {
        console.log("DEBUG: showLogin function called."); // DEBUG
        try {
            if (sessionTimerId) {
                 console.log("DEBUG: Clearing session timer during logout/showLogin."); // DEBUG
                 clearTimeout(sessionTimerId);
                 sessionTimerId = null;
            }
            sessionStorage.removeItem('bypassAutoLogout');
            if (loginContainer) loginContainer.classList.remove('hidden');
            if (appContainer) appContainer.classList.add('hidden');
            if (welcomeMessageElement) welcomeMessageElement.textContent = '';
            if (loginError) loginError.textContent = '';
            const u = document.getElementById('username'); if (u) u.value = '';
            const p = document.getElementById('password'); if (p) p.value = '';
            const c = document.getElementById('stayLoggedInCheckbox'); if (c) c.checked = false;

            // Ensure modals are hidden on logout
            if (passwordModal) passwordModal.classList.add('hidden');
            if (allCurtailmentsModal) allCurtailmentsModal.classList.add('hidden');
            if (autoTmpModal) autoTmpModal.classList.add('hidden');
            const r = document.getElementById('export-reminder'); if (r) r.style.display = 'none';

            // Ensure forms/sections and go back button are hidden
            if (addCurtailmentForm) addCurtailmentForm.classList.add('hidden');
            if (manualFleetForm) manualFleetForm.classList.add('hidden');
            if (settingsForm) settingsForm.classList.add('hidden');
            if (dataActionsSection) dataActionsSection.classList.add('hidden'); // Hide Backup/Restore
            if (goBackButton) goBackButton.classList.add('hidden');

        } catch (e) { console.error("DEBUG: Error in showLogin:", e); } // DEBUG
    }


    // --- NEW: Function to Show a Specific Section ---
    function showSection(sectionId) {
        console.log(`DEBUG: showSection called for sectionId: ${sectionId}`); // DEBUG
        if (!isLoggedIn || !currentUsername || !users[currentUsername]) {
            console.warn("DEBUG: showSection called but user not logged in."); // DEBUG
            alert('Not logged in.');
            return;
        }
        const userRole = users[currentUsername].role;
        const sectionElement = document.getElementById(sectionId);

        if (!sectionElement) {
            console.error(`DEBUG: Section with ID ${sectionId} not found.`); // DEBUG
            return;
        }

        // --- Permission Checks ---
        let canAccess = false;
        if (sectionId === 'add-curtailment-form' && ['admin', 'moderator'].includes(userRole)) canAccess = true;
        if (sectionId === 'manual-fleet-form' && ['admin', 'moderator'].includes(userRole)) canAccess = true;
        if (sectionId === 'data-actions' && ['admin', 'moderator'].includes(userRole)) canAccess = true; // Backup/Restore check
        if (sectionId === 'settings-form' && userRole === 'admin') canAccess = true;
        console.log(`DEBUG: Permission check for section ${sectionId} - Role: ${userRole}, Can Access: ${canAccess}`); // DEBUG

        if (!canAccess) {
            console.warn(`DEBUG: Access denied for user ${currentUsername} (Role: ${userRole}) to section ${sectionId}.`); // DEBUG
            alert('Access Denied.');
            return;
        }

        // --- Hide Menu, Show Section & Go Back Button ---
        console.log("DEBUG: Hiding main menu, showing section and back button."); // DEBUG
        if (mainActionsContainer) mainActionsContainer.classList.add('hidden');
        if (addCurtailmentForm) addCurtailmentForm.classList.add('hidden'); // Hide all sections first
        if (manualFleetForm) manualFleetForm.classList.add('hidden');
        if (settingsForm) settingsForm.classList.add('hidden');
        if (dataActionsSection) dataActionsSection.classList.add('hidden'); // Hide Backup/Restore

        sectionElement.classList.remove('hidden'); // Show the target section
        if (goBackButton) goBackButton.classList.remove('hidden'); // Show the back button

        // --- Section Specific Initialisation ---
        console.log(`DEBUG: Performing initialisation for section ${sectionId}.`); // DEBUG
        if (sectionId === 'manual-fleet-form') {
            displayManualAssignments(); // Refresh the list
            const revertSection = sectionElement.querySelector('.revert-section');
            const resetAllSection = sectionElement.querySelector('.reset-all-section'); // Get reset section
            if (revertSection) { // Show/hide revert based on role
                revertSection.classList.toggle('hidden', userRole !== 'admin');
                console.log(`DEBUG: Revert section visibility set to: ${revertSection.classList.contains('hidden') ? 'hidden' : 'visible'}`); // DEBUG
            }
            if (resetTmpButton && resetAllSection) { // Show/hide reset all based on role
                 resetAllSection.classList.toggle('hidden', userRole !== 'admin');
                 console.log(`DEBUG: Reset All TMP section visibility set to: ${resetAllSection.classList.contains('hidden') ? 'hidden' : 'visible'}`); // DEBUG
            }
            // Clear status messages within this section
            if(assignStatusElement) assignStatusElement.textContent = '';
            if(revertStatusElement) revertStatusElement.textContent = '';
        } else if (sectionId === 'settings-form') {
            loadTrackerSettings(); // Load current settings into the form
             if (adminUserManagementSection) { // Show/populate user mgmt if admin
                 adminUserManagementSection.classList.remove('hidden');
                 displayUserManagement(); // Refresh user list
             } else { console.error("DEBUG: Admin user management section element not found!"); } // DEBUG
            // Clear status messages within this section
            if(trackerSettingsMessage) trackerSettingsMessage.textContent = '';
            if(changePasswordMessage) changePasswordMessage.textContent = '';
            if(addUserMessage) addUserMessage.textContent = '';
            if(userManagementMessage) userManagementMessage.textContent = '';
        } else if (sectionId === 'add-curtailment-form') {
             // Clear status message within this section
             if(addCurtailmentMessage) addCurtailmentMessage.textContent = '';
             // Optionally focus the first input for convenience
             const routeInput = document.getElementById('route');
             if(routeInput) {
                 console.log("DEBUG: Focusing route input in Add Curtailment form."); // DEBUG
                 routeInput.focus();
             }
        } else if (sectionId === 'data-actions') {
            // No specific init needed for backup/restore section currently
            console.log("DEBUG: Initializing Backup & Restore section (no actions)."); // DEBUG
        }
    }

    // --- NEW: Function to Go Back to the Main Menu View ---
    function goBackToMainView() {
        console.log("DEBUG: goBackToMainView function called."); // DEBUG
         // Hide all sections and the go back button
        if (addCurtailmentForm) addCurtailmentForm.classList.add('hidden');
        if (manualFleetForm) manualFleetForm.classList.add('hidden');
        if (settingsForm) settingsForm.classList.add('hidden');
        if (dataActionsSection) dataActionsSection.classList.add('hidden'); // Hide Backup/Restore
        if (goBackButton) goBackButton.classList.add('hidden');

        // Show the main actions menu
        if (mainActionsContainer) mainActionsContainer.classList.remove('hidden');

         // Optional: Clear status messages when going back
        console.log("DEBUG: Clearing status messages on go back."); // DEBUG
        if(addCurtailmentMessage) addCurtailmentMessage.textContent = '';
        if(assignStatusElement) assignStatusElement.textContent = '';
        if(revertStatusElement) revertStatusElement.textContent = '';
        if(trackerSettingsMessage) trackerSettingsMessage.textContent = '';
        if(changePasswordMessage) changePasswordMessage.textContent = '';
        if(addUserMessage) addUserMessage.textContent = '';
        if(userManagementMessage) userManagementMessage.textContent = '';
    }


    // --- Curtailment Functions ---
    // (Keep addCurtailment, exportCurtailments, handleCurtailmentImport, showAllCurtailmentsModal, hideAllCurtailmentsModal, deleteCurtailmentEntry)
     function addCurtailment() {
        console.log("DEBUG: addCurtailment function called."); // DEBUG
        if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) {
            console.warn("DEBUG: addCurtailment access denied."); // DEBUG
            alert('Access Denied.'); return;
        }
        const routeInput = document.getElementById('route');
        const regNumberInput = document.getElementById('regNumber');
        const curtailedDestinationInput = document.getElementById('curtailedDestination');
        const timeInput = document.getElementById('curtailmentTimeInput');
        if (!routeInput || !regNumberInput || !curtailedDestinationInput || !timeInput || !addCurtailmentMessage) {
            console.error("DEBUG: Missing curtailment form elements."); // DEBUG
            alert("Error: Form elements missing."); return;
        }
        const route = routeInput.value.trim().toUpperCase();
        const regNumber = regNumberInput.value.trim().toUpperCase();
        const curtailedDestination = curtailedDestinationInput.value.trim();
        const timeString = timeInput.value.trim();
        console.log(`DEBUG: Attempting to add curtailment - Route: ${route}, Reg: ${regNumber}, Dest: ${curtailedDestination}, Time: ${timeString}`); // DEBUG

        if (route && regNumber && curtailedDestination && timeString) {
            const routeKey = `curtailedBusesArray_${route}`;
            let routeCurtailments = loadFromStorage(routeKey, []);
            if (!Array.isArray(routeCurtailments)) {
                console.warn(`DEBUG: Resetting non-array curtailment data for ${routeKey}`); // DEBUG
                routeCurtailments = [];
            }
            let logDate = new Date();
            const timeParts = timeString.split(':');
            if (timeParts.length === 2) {
                const hours = parseInt(timeParts[0], 10);
                const minutes = parseInt(timeParts[1], 10);
                if (!isNaN(hours) && !isNaN(minutes) && hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
                    logDate.setHours(hours, minutes, 0, 0);
                    console.log(`DEBUG: Parsed time ${timeString} to date object: ${logDate}`); // DEBUG
                } else {
                    console.warn(`DEBUG: Invalid time format entered: ${timeString}`); // DEBUG
                    alert("Invalid time format entered. Please use HH:MM (24-hour format).");
                    timeInput.focus(); return;
                }
            } else {
                 console.warn(`DEBUG: Invalid time format entered (not HH:MM): ${timeString}`); // DEBUG
                 alert("Invalid time format entered. Please use HH:MM.");
                 timeInput.focus(); return;
            }
            const newCurtailment = { route: route, regNumber: regNumber, curtailedDestination: curtailedDestination, curtailmentTime: logDate.toLocaleString('en-GB', { timeZone: 'Europe/London', dateStyle: 'short', timeStyle: 'short'}), timestamp: logDate.getTime() };
            console.log("DEBUG: New curtailment object:", newCurtailment); // DEBUG
            routeCurtailments.push(newCurtailment);
            saveToStorage(routeKey, routeCurtailments);
            routeInput.value = ""; regNumberInput.value = ""; curtailedDestinationInput.value = ""; timeInput.value = "";
            addCurtailmentMessage.textContent = `Curtailment for route ${route} at ${timeString} added successfully!`;
            addCurtailmentMessage.style.color = 'green';
            setTimeout(() => { if(addCurtailmentMessage) addCurtailmentMessage.textContent = ""; }, 3000);
            routeInput.focus();
        } else {
            console.warn("DEBUG: Add curtailment failed - missing fields."); // DEBUG
            alert("Please fill in all curtailment details (Route, Registration, Destination, Time).");
        }
    }
     function exportCurtailments() {
         console.log("DEBUG: exportCurtailments function called."); // DEBUG
         if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) {
             console.warn("DEBUG: exportCurtailments access denied."); // DEBUG
             alert('Access Denied.'); return;
         }
         const allData = {}; let keysFound = 0;
         try {
             console.log("DEBUG: Starting scan of localStorage for curtailment keys."); // DEBUG
             for (let i = 0; i < localStorage.length; i++) {
                 const key = localStorage.key(i);
                 if (key && key.startsWith("curtailedBusesArray_")) {
                     const routeNum = key.replace("curtailedBusesArray_", "");
                     console.log(`DEBUG: Found potential key: ${key}, Route: ${routeNum}`); // DEBUG
                     const routeData = loadFromStorage(key, []);
                     if (Array.isArray(routeData)) {
                         console.log(`DEBUG: Adding data for route ${routeNum} to export object.`); // DEBUG
                         allData[routeNum] = routeData;
                         keysFound++;
                     } else {
                         console.warn(`DEBUG: Data for key ${key} was not an array, skipping.`); // DEBUG
                     }
                 }
             }
             console.log(`DEBUG: Found ${keysFound} routes with curtailment data.`); // DEBUG
         } catch (e) {
             console.error("DEBUG: Error reading localStorage during export:", e); // DEBUG
             alert("An error occurred while gathering data for export."); return;
         }
         if (keysFound === 0) {
             console.log("DEBUG: No curtailment data found to export."); // DEBUG
             alert("No curtailment data found in localStorage to export."); return;
         }
         try {
             console.log("DEBUG: Stringifying and creating blob for export."); // DEBUG
             const jsonString = JSON.stringify(allData, null, 2);
             const blob = new Blob([jsonString], { type: "application/json" });
             const a = document.createElement("a");
             const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
             a.href = URL.createObjectURL(blob);
             a.download = `all_routes_curtailments_${timestamp}.json`;
             console.log(`DEBUG: Triggering download for file: ${a.download}`); // DEBUG
             document.body.appendChild(a);
             a.click();
             document.body.removeChild(a);
             URL.revokeObjectURL(a.href);
             alert("Curtailment data exported successfully!");
             try {
                 console.log("DEBUG: Updating last export timestamp."); // DEBUG
                 localStorage.setItem(lastExportKey, Date.now().toString());
                 const reminderElement = document.getElementById('export-reminder');
                 if (reminderElement) reminderElement.style.display = 'none';
             } catch (e) {
                 console.error("DEBUG: Could not save last export timestamp", e); // DEBUG
             }
         } catch (e) {
             console.error("DEBUG: Error creating export file:", e); // DEBUG
             alert("An error occurred during file creation or download.");
         }
     }
     function handleCurtailmentImport(file) {
         console.log("DEBUG: handleCurtailmentImport function called."); // DEBUG
         if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) {
             console.warn("DEBUG: handleCurtailmentImport access denied."); // DEBUG
             alert('Access Denied.'); if(importCurtailmentsInput) importCurtailmentsInput.value = ''; return;
         }
         if (!file) {
             console.warn("DEBUG: No file selected for import."); // DEBUG
             alert("No file selected."); return;
         }
         console.log(`DEBUG: File selected for import: ${file.name}, Type: ${file.type}`); // DEBUG
         if (!file.name.toLowerCase().endsWith('.json')) {
             console.warn("DEBUG: Invalid file type selected (not .json)."); // DEBUG
             alert("Please select a valid JSON file (.json)."); return;
         }
         const reader = new FileReader();
         reader.onload = function(e) {
             console.log("DEBUG: FileReader onload triggered for curtailment import."); // DEBUG
             try {
                 const importedData = JSON.parse(e.target.result);
                 if (typeof importedData !== 'object' || importedData === null) {
                     console.error("DEBUG: Imported file is not a valid JSON object."); // DEBUG
                     throw new Error("Imported file is not a valid JSON object.");
                 }
                 console.log("DEBUG: Imported JSON parsed successfully."); // DEBUG
                 if (!confirm("Importing will REPLACE existing curtailment data for the routes found in the file. Are you sure?")) {
                     console.log("DEBUG: User cancelled curtailment import."); // DEBUG
                     if(importCurtailmentsInput) importCurtailmentsInput.value = ''; return;
                 }
                 console.log("DEBUG: User confirmed curtailment import. Processing routes..."); // DEBUG
                 let importedCount = 0; let skippedRoutes = []; let skippedEntriesCount = 0;
                 for (const route in importedData) {
                     if (importedData.hasOwnProperty(route)) {
                         console.log(`DEBUG: Processing route ${route} from import file.`); // DEBUG
                         const routeKey = `curtailedBusesArray_${route}`;
                         const routeData = importedData[route];
                         if (Array.isArray(routeData)) {
                             console.log(`DEBUG: Found ${routeData.length} entries for route ${route}. Validating...`); // DEBUG
                             const validData = routeData.filter(item => item && typeof item.route === 'string' && item.route.trim() !== '' && typeof item.regNumber === 'string' && item.regNumber.trim() !== '' && typeof item.curtailedDestination === 'string' && item.curtailedDestination.trim() !== '' && (typeof item.curtailmentTime === 'string' || typeof item.timestamp === 'number'));
                             if(validData.length !== routeData.length){
                                 const skipped = routeData.length - validData.length;
                                 skippedEntriesCount += skipped;
                                 console.warn(`DEBUG: Skipped ${skipped} invalid/incomplete entries for route ${route}.`); // DEBUG
                             }
                             // Attempt to parse timestamp if missing
                             validData.forEach(item => {
                                 if (!item.timestamp && item.curtailmentTime) {
                                     try {
                                         const parts = item.curtailmentTime.match(/(\d{2})\/(\d{2})\/(\d{4}),? (\d{2}):(\d{2})/);
                                         if(parts) {
                                             item.timestamp = new Date(Date.UTC(parts[3], parts[2] - 1, parts[1], parts[4], parts[5], 0)).getTime();
                                         } else {
                                             item.timestamp = Date.parse(item.curtailmentTime) || 0;
                                         }
                                         if(isNaN(item.timestamp)) item.timestamp = 0;
                                     } catch { item.timestamp = 0; }
                                 } else if (!item.timestamp) {
                                     item.timestamp = 0; // Ensure timestamp exists
                                 }
                             });
                             // Final filter for valid timestamps
                             const finalValidData = validData.filter(item => typeof item.timestamp === 'number' && item.timestamp > 0);
                             if (validData.length !== finalValidData.length) {
                                 const skipped = validData.length - finalValidData.length;
                                 skippedEntriesCount += skipped;
                                 console.warn(`DEBUG: Skipped ${skipped} entries for route ${route} due to timestamp parsing failure.`); // DEBUG
                             }

                             if(finalValidData.length > 0) {
                                 console.log(`DEBUG: Saving ${finalValidData.length} valid entries for route ${route}.`); // DEBUG
                                 saveToStorage(routeKey, finalValidData);
                                 importedCount++;
                             } else {
                                 console.warn(`DEBUG: No valid entries with timestamps found for route ${route}. Skipping save.`); // DEBUG
                             }
                         } else {
                             skippedRoutes.push(route);
                             console.warn(`DEBUG: Skipping import for route ${route}: data is not an array.`); // DEBUG
                         }
                     }
                 }
                 let alertMessage = `${importedCount} route(s) curtailment data imported successfully! Data for these routes was replaced.\n`;
                 if (skippedRoutes.length > 0) { alertMessage += `Skipped invalid data for routes: ${skippedRoutes.join(', ')}\n`; }
                 if (skippedEntriesCount > 0) { alertMessage += `Skipped ${skippedEntriesCount} invalid/incomplete or timestamp-failed entries within imported routes.`; }
                 console.log(`DEBUG: Curtailment Import Summary: ${alertMessage}`); // DEBUG
                 alert(alertMessage);
             } catch (error) {
                 console.error("DEBUG: Error importing curtailments:", error); // DEBUG
                 alert("Error importing curtailments: " + error.message);
             } finally {
                 if(importCurtailmentsInput) importCurtailmentsInput.value = ''; // Clear file input
             }
         };
         reader.onerror = function() {
             console.error("DEBUG: Error reading the selected curtailment file."); // DEBUG
             alert("Error reading the selected file.");
             if(importCurtailmentsInput) importCurtailmentsInput.value = '';
         };
         reader.readAsText(file);
     }
     function showAllCurtailmentsModal() {
         console.log("DEBUG: showAllCurtailmentsModal function called."); // DEBUG
         if (!isLoggedIn) { alert('You must be logged in.'); return; }
         if (!allCurtailmentsModal || !allCurtailmentsList) { console.error("DEBUG: All Curtailments Modal elements missing"); return; }
         allCurtailmentsList.innerHTML = '<p>Loading...</p>';
         allCurtailmentsModal.classList.remove('hidden');
         // Use setTimeout to allow the modal to render before heavy processing
         setTimeout(() => {
             console.log("DEBUG: Processing curtailments for modal display."); // DEBUG
             try {
                 let allCurtailmentsHTML = '';
                 let foundAny = false;
                 let curtailmentEntries = [];
                 for (let i = 0; i < localStorage.length; i++) {
                     const key = localStorage.key(i);
                     if (key && key.startsWith("curtailedBusesArray_")) {
                         const routeCurtailments = loadFromStorage(key, []);
                         if (Array.isArray(routeCurtailments) && routeCurtailments.length > 0) {
                             routeCurtailments.forEach(item => {
                                 let timestamp = item.timestamp;
                                 // Ensure timestamp consistency
                                 if (!timestamp && item.curtailmentTime) {
                                     try {
                                         const parts = item.curtailmentTime.match(/(\d{2})\/(\d{2})\/(\d{4}),? (\d{2}):(\d{2})/);
                                         if(parts) { timestamp = new Date(Date.UTC(parts[3], parts[2] - 1, parts[1], parts[4], parts[5], 0)).getTime(); }
                                         else { timestamp = Date.parse(item.curtailmentTime) || 0; }
                                         if(isNaN(timestamp)) timestamp = 0;
                                     } catch { timestamp = 0; }
                                 } else if (!timestamp) { timestamp = 0; }

                                 if(timestamp > 0) { // Only include entries with a valid timestamp
                                     curtailmentEntries.push({ ...item, timestamp: timestamp, originalKey: key });
                                     foundAny = true;
                                 }
                             });
                         }
                     }
                 }
                 // Sort by timestamp descending (most recent first)
                 curtailmentEntries.sort((a, b) => b.timestamp - a.timestamp);
                 console.log(`DEBUG: Found ${curtailmentEntries.length} valid curtailment entries for modal.`); // DEBUG

                 if (!foundAny) {
                     allCurtailmentsHTML = '<p>No curtailments found.</p>';
                 } else {
                     const currentUserRole = users[currentUsername]?.role;
                     curtailmentEntries.forEach(item => {
                         const displayTime = new Date(item.timestamp).toLocaleString('en-GB', { timeZone: 'Europe/London', dateStyle: 'short', timeStyle: 'short' });
                         let deleteButtonHTML = '';
                         // Only Admins can delete
                         if (currentUserRole === 'admin') {
                             deleteButtonHTML = `<button type="button" class="delete-curtailment-btn" onclick="deleteCurtailmentEntry('${item.originalKey}', ${item.timestamp})">Delete</button>`;
                         }
                         allCurtailmentsHTML += `<div>
                             <span><strong>Route:</strong> ${item.route || 'N/A'}</span>
                             <span><strong>Reg:</strong> ${item.regNumber || 'N/A'}</span>
                             <span><strong>Destination:</strong> ${item.curtailedDestination || 'N/A'}</span>
                             <span><strong>Logged:</strong> ${displayTime}</span>
                             ${deleteButtonHTML}
                         </div>`;
                     });
                 }
                 allCurtailmentsList.innerHTML = allCurtailmentsHTML;
             } catch (e) {
                 console.error("DEBUG: Error loading curtailments modal:", e); // DEBUG
                 allCurtailmentsList.innerHTML = '<p style="color: red;">Error loading data.</p>';
             }
         }, 10); // Small delay
     }
     function hideAllCurtailmentsModal() {
         console.log("DEBUG: hideAllCurtailmentsModal function called."); // DEBUG
         if(allCurtailmentsModal) { allCurtailmentsModal.classList.add('hidden'); }
     }
     function deleteCurtailmentEntry(routeKey, timestampToDelete) {
         console.log(`DEBUG: deleteCurtailmentEntry called - Key: ${routeKey}, Timestamp: ${timestampToDelete}`); // DEBUG
         if (!isLoggedIn || users[currentUsername]?.role !== 'admin') {
             console.warn("DEBUG: deleteCurtailmentEntry access denied."); // DEBUG
             alert('Admin Access Denied.'); return;
         }
         if (!routeKey || !timestampToDelete) {
             console.error("DEBUG: Missing key/timestamp for deletion."); // DEBUG
             alert("Error: Cannot identify entry."); return;
         }
         // Try to get details for confirmation message
         let itemDetails = `Entry @ timestamp ${timestampToDelete}`;
         try {
             const allCurtailments = loadFromStorage(routeKey, []);
             const itemToDelete = allCurtailments.find(item => {
                 let itemTimestamp = item.timestamp;
                 if (!itemTimestamp && item.curtailmentTime) { try { const parts = item.curtailmentTime.match(/(\d{2})\/(\d{2})\/(\d{4}),? (\d{2}):(\d{2})/); if (parts) { itemTimestamp = new Date(Date.UTC(parts[3], parts[2] - 1, parts[1], parts[4], parts[5], 0)).getTime(); } else { itemTimestamp = Date.parse(item.curtailmentTime) || 0; } } catch { itemTimestamp = 0; } }
                 return typeof itemTimestamp === 'number' && itemTimestamp === timestampToDelete;
             });
             if (itemToDelete) { itemDetails = `Route: ${itemToDelete.route || 'N/A'}, Reg: ${itemToDelete.regNumber || 'N/A'}, Dest: ${itemToDelete.curtailedDestination || 'N/A'}, Time: ${new Date(timestampToDelete).toLocaleString('en-GB')}`; }
             console.log(`DEBUG: Confirmation details: ${itemDetails}`); // DEBUG
         } catch (e) { console.warn("DEBUG: Could not get details for confirmation", e); }

         if (confirm(`DELETE curtailment?\n\n${itemDetails}`)) {
             console.log("DEBUG: User confirmed deletion."); // DEBUG
             try {
                 let routeCurtailments = loadFromStorage(routeKey, []);
                 if (!Array.isArray(routeCurtailments)) {
                     console.error(`DEBUG: Error loading data for key ${routeKey} during delete.`); // DEBUG
                     alert("Error loading data."); return;
                 }
                 let initialLength = routeCurtailments.length;
                 // Filter out the entry to be deleted
                 const updatedCurtailments = routeCurtailments.filter(item => {
                     let itemTimestamp = item.timestamp;
                     // Ensure consistent timestamp for comparison
                     if (!itemTimestamp && item.curtailmentTime) { try { const parts = item.curtailmentTime.match(/(\d{2})\/(\d{2})\/(\d{4}),? (\d{2}):(\d{2})/); if (parts) { itemTimestamp = new Date(Date.UTC(parts[3], parts[2] - 1, parts[1], parts[4], parts[5], 0)).getTime(); } else { itemTimestamp = Date.parse(item.curtailmentTime) || 0; } } catch { itemTimestamp = 0; } }
                     return !(typeof itemTimestamp === 'number' && itemTimestamp === timestampToDelete);
                 });

                 if (updatedCurtailments.length < initialLength) {
                     console.log(`DEBUG: Saving updated curtailments for key ${routeKey}. Length reduced from ${initialLength} to ${updatedCurtailments.length}.`); // DEBUG
                     saveToStorage(routeKey, updatedCurtailments);
                     alert("Entry deleted.");
                     showAllCurtailmentsModal(); // Refresh the modal
                 } else {
                     console.warn(`DEBUG: Entry with timestamp ${timestampToDelete} not found in ${routeKey}. Refreshing modal.`); // DEBUG
                     alert("Entry not found. Refreshing.");
                     showAllCurtailmentsModal(); // Refresh anyway
                 }
             } catch (e) {
                 console.error("DEBUG: Error deleting entry:", e); // DEBUG
                 alert("Error deleting entry.");
             }
         } else {
             console.log("DEBUG: User cancelled deletion."); // DEBUG
         }
     }


    // --- Manual Fleet Functions ---
    function displayManualAssignments() {
        console.log("DEBUG: displayManualAssignments function called."); // DEBUG
        if (!isLoggedIn || !manualAssignmentsDisplay) {
            console.warn("DEBUG: Cannot display manual assignments - not logged in or element missing."); // DEBUG
            return;
        }
        const tmpMap = loadFromStorage(tmpMapKey, {});
        manualAssignmentsDisplay.innerHTML = ''; // Clear previous content
        const manualEntries = [];
        try {
            if (typeof tmpMap === 'object' && tmpMap !== null) {
                for (const reg in tmpMap) {
                    if (tmpMap.hasOwnProperty(reg)) {
                        const fleet = tmpMap[reg];
                        // Only display entries that are NOT auto-generated TMP/ERR
                        if (typeof fleet === 'string' && !fleet.startsWith('TMP') && !fleet.startsWith('ERR')) {
                            manualEntries.push({ reg: reg, fleet: fleet });
                        }
                    }
                }
                 console.log(`DEBUG: Found ${manualEntries.length} manual fleet assignments.`); // DEBUG
            } else {
                console.warn("DEBUG: TMP Map data is not a valid object."); // DEBUG
            }
        } catch (e) {
            console.error("DEBUG: Error processing TMP Map for display:", e); // DEBUG
            manualAssignmentsDisplay.innerHTML = '<em style="color: red;">Error loading assignments.</em>';
            return;
        }

        if (manualEntries.length === 0) {
            manualAssignmentsDisplay.innerHTML = '<em>No manual assignments found.</em>';
        } else {
            // Sort alphabetically by registration number
            manualEntries.sort((a, b) => a.reg.localeCompare(b.reg));
            manualEntries.forEach(entry => {
                const div = document.createElement('div');
                div.innerHTML = `<strong>${entry.reg}:</strong> ${entry.fleet}`;
                manualAssignmentsDisplay.appendChild(div);
            });
        }
    }
     function assignManualFleetNumber() {
         console.log("DEBUG: assignManualFleetNumber function called."); // DEBUG
         if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) {
             console.warn("DEBUG: assignManualFleetNumber access denied."); // DEBUG
             alert('Access Denied.'); return;
         }
         if (!manualRegNumberInput || !manualFleetNumberInput || !assignStatusElement) {
             console.error("DEBUG: Missing elements for manual assignment."); // DEBUG
             return;
         }
         const regNumber = manualRegNumberInput.value.trim().toUpperCase();
         const realFleetNumber = manualFleetNumberInput.value.trim();
         assignStatusElement.textContent = '';
         console.log(`DEBUG: Attempting assignment - Reg: ${regNumber}, Fleet: ${realFleetNumber}`); // DEBUG

         if (!regNumber || !realFleetNumber) {
             console.warn("DEBUG: Missing Reg or Fleet Number for assignment."); // DEBUG
             alert('Please enter both Registration and Fleet Number.'); return;
         }
         // Warn if assigning something that looks auto-generated
         if (realFleetNumber.startsWith('TMP') || realFleetNumber.startsWith('ERR')) {
             console.warn(`DEBUG: Attempting to assign auto-generated looking number: ${realFleetNumber}`); // DEBUG
             if (!confirm(`Fleet number "${realFleetNumber}" looks auto-generated. Assign manually anyway?`)) {
                 console.log("DEBUG: User cancelled assignment of auto-generated number."); // DEBUG
                 return;
             }
         }
         try {
             let tmpMap = loadFromStorage(tmpMapKey, {});
             if (typeof tmpMap !== 'object' || tmpMap === null) {
                 console.warn("DEBUG: tmpMap was invalid, resetting to empty object."); // DEBUG
                 tmpMap = {};
             }
             tmpMap[regNumber] = realFleetNumber;
             saveToStorage(tmpMapKey, tmpMap);
             console.log(`DEBUG: Assignment successful - ${regNumber} -> ${realFleetNumber}`); // DEBUG
             assignStatusElement.textContent = `Assigned Fleet# ${realFleetNumber} to ${regNumber}.`;
             assignStatusElement.style.color = 'green';
             manualRegNumberInput.value = ''; manualFleetNumberInput.value = '';
             displayManualAssignments(); // Refresh the list
             manualRegNumberInput.focus();
             setTimeout(() => { if(assignStatusElement) assignStatusElement.textContent = ''; }, 4000);
         } catch (error) {
             console.error("DEBUG: Error saving manual fleet assignment:", error); // DEBUG
             assignStatusElement.textContent = `Error saving assignment: ${error.message}`;
             assignStatusElement.style.color = 'red';
         }
     }
     function getTMPForRegistration(registration) {
         // This function is primarily used by the tracker page, but included here for completeness
         // console.log(`DEBUG: getTMPForRegistration called for: ${registration}`); // DEBUG - Potentially noisy
         if (!registration) return 'TMP????';
         let tmpMap = loadFromStorage(tmpMapKey, {});
         if (typeof tmpMap !== 'object' || tmpMap === null) tmpMap = {};

         if (tmpMap.hasOwnProperty(registration)) {
             // console.log(`DEBUG: Found existing entry for ${registration}: ${tmpMap[registration]}`); // DEBUG
             return tmpMap[registration];
         }

         // --- Generate new TMP if not found ---
         console.log(`DEBUG: No existing entry for ${registration}. Generating new TMP...`); // DEBUG
         let attempt = 0;
         let uniqueTMP = null;
         let generatedTMP;
         const MAX_ATTEMPTS = 100;

         // Helper to check if a TMP value is already used by *another* registration
         const isTMPValueUsed = (map, tmpValue, currentReg) => {
             for (const reg in map) {
                 if (map.hasOwnProperty(reg) && reg !== currentReg && map[reg] === tmpValue) {
                     return true; // Value used by a different registration
                 }
             }
             return false; // Value is not used by another registration
         };

         // Try to find a unique TMP
         while (uniqueTMP === null && attempt < MAX_ATTEMPTS) {
             const inputForHash = attempt === 0 ? registration : `${registration}_${attempt}`; // Vary input on collision
             generatedTMP = generateTMPNumber(inputForHash); // Use the consistent hash function
             if (!isTMPValueUsed(tmpMap, generatedTMP, registration)) {
                 uniqueTMP = generatedTMP; // Found a unique one
                 console.log(`DEBUG: Generated unique TMP ${uniqueTMP} for ${registration} on attempt ${attempt + 1}.`); // DEBUG
             } else {
                 console.warn(`DEBUG: TMP collision for ${registration}: ${generatedTMP}. Retrying...`); // DEBUG
                 attempt++;
             }
         }

         // If still no unique TMP after max attempts, assign an ERR code
         if (uniqueTMP === null) {
             console.error(`DEBUG: Could not generate unique TMP for ${registration} after ${MAX_ATTEMPTS} attempts.`); // DEBUG
             uniqueTMP = `ERR${Math.floor(1000 + Math.random() * 9000)}`; // Random ERR code
         }

         // Save the newly generated TMP/ERR to the map
         tmpMap[registration] = uniqueTMP;
         saveToStorage(tmpMapKey, tmpMap);
         console.log(`DEBUG: Saved new assignment ${registration} -> ${uniqueTMP}`); // DEBUG

         // Also save generation info (route might be unknown here)
         try {
             let genInfo = loadFromStorage(tmpGenerationInfoKey, {});
             if (typeof genInfo !== 'object' || genInfo === null) genInfo = {};
             genInfo[registration] = { route: "N/A", timestamp: Date.now() }; // Route context might not be available here
             saveToStorage(tmpGenerationInfoKey, genInfo);
             console.log(`DEBUG: Saved generation info for ${registration}.`); // DEBUG
         } catch(e) {
             console.error(`DEBUG: Failed to save TMP generation info for ${registration}:`, e); // DEBUG
         }

         return uniqueTMP;
     }
     function generateTMPNumber(registration) {
         // Consistent hash function to generate TMP numbers
         const seed = 12345; // Fixed seed for consistency
         const combined = registration + seed.toString();
         let hash = 0;
         if (combined.length === 0) return "TMP0000";
         for (let i = 0; i < combined.length; i++) {
             const charCode = combined.charCodeAt(i);
             hash = ((hash << 5) - hash) + charCode;
             hash |= 0; // Convert to 32bit integer
         }
         // Ensure positive 4-digit number, padded with zeros
         return `TMP${Math.abs(hash % 10000).toString().padStart(4, "0")}`;
     }
     function revertToTMP() {
         console.log("DEBUG: revertToTMP function called."); // DEBUG
         if (!isLoggedIn || users[currentUsername]?.role !== 'admin') {
             console.warn("DEBUG: revertToTMP access denied."); // DEBUG
             alert('Admin Access Denied.'); return;
         }
         if (!revertRegNumberInput || !revertStatusElement) {
             console.error("DEBUG: Missing elements for revert function."); // DEBUG
             return;
         }
         const regToRevert = revertRegNumberInput.value.trim().toUpperCase();
         if(revertStatusElement) revertStatusElement.textContent = '';
         console.log(`DEBUG: Attempting to revert registration: ${regToRevert}`); // DEBUG

         if (!regToRevert) {
             console.warn("DEBUG: No registration entered for revert."); // DEBUG
             alert("Please enter Registration to revert.");
             revertRegNumberInput.focus(); return;
         }

         let tmpMap = loadFromStorage(tmpMapKey, {});
         if (typeof tmpMap !== 'object' || tmpMap === null) { tmpMap = {}; }

         if (!tmpMap.hasOwnProperty(regToRevert)) {
             console.log(`DEBUG: Registration ${regToRevert} not found in tmpMap.`); // DEBUG
             if(revertStatusElement){ revertStatusElement.textContent = `Registration ${regToRevert} not found.`; revertStatusElement.style.color = 'orange'; setTimeout(() => { if(revertStatusElement) revertStatusElement.textContent = ''; }, 4000); }
             return;
         }

         const currentValue = tmpMap[regToRevert];
         // Check if it's already an auto-generated one
         if (typeof currentValue === 'string' && (currentValue.startsWith('TMP') || currentValue.startsWith('ERR'))) {
             console.log(`DEBUG: Registration ${regToRevert} already uses auto TMP/ERR (${currentValue}).`); // DEBUG
             if(revertStatusElement){ revertStatusElement.textContent = `${regToRevert} already uses auto TMP/ERR.`; revertStatusElement.style.color = 'orange'; setTimeout(() => { if(revertStatusElement) revertStatusElement.textContent = ''; }, 4000); }
             return;
         }

         // Confirm deletion of manual assignment
         if (confirm(`Remove manual fleet number for "${regToRevert}"? System will assign auto TMP later if needed.`)) {
             console.log(`DEBUG: User confirmed revert for ${regToRevert}.`); // DEBUG
             try {
                 delete tmpMap[regToRevert]; // Remove the manual assignment
                 saveToStorage(tmpMapKey, tmpMap); // Save the updated map
                 console.log(`DEBUG: Manual assignment for ${regToRevert} removed.`); // DEBUG
                 if(revertStatusElement){ revertStatusElement.textContent = `Manual assignment for ${regToRevert} removed.`; revertStatusElement.style.color = 'green'; }
                 if(revertRegNumberInput) revertRegNumberInput.value = ''; // Clear input
                 displayManualAssignments(); // Refresh the list
                 revertRegNumberInput.focus();
                 setTimeout(() => { if(revertStatusElement) revertStatusElement.textContent = ''; }, 4000);
             } catch (error) {
                 console.error("DEBUG: Error reverting TMP assignment:", error); // DEBUG
                 if(revertStatusElement){ revertStatusElement.textContent = `Error reverting: ${error.message}`; revertStatusElement.style.color = 'red';}
             }
         } else {
              console.log(`DEBUG: User cancelled revert for ${regToRevert}.`); // DEBUG
         }
     }
     function showAutoTmpModal() {
         console.log("DEBUG: showAutoTmpModal function called."); // DEBUG
         if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) {
             console.warn("DEBUG: showAutoTmpModal access denied."); // DEBUG
             alert('Access Denied.'); return;
         }
         if (!autoTmpModal || !autoTmpList) { console.error("DEBUG: Auto TMP Modal elements not found!"); return; }
         autoTmpList.innerHTML = '<p>Loading...</p>';
         autoTmpModal.classList.remove('hidden');
         try {
             const tmpMap = loadFromStorage(tmpMapKey, {});
             const genInfo = loadFromStorage(tmpGenerationInfoKey, {}); // Load generation info
             let autoTmpEntries = [];
             console.log("DEBUG: Processing tmpMap for auto-generated entries."); // DEBUG
             for (const reg in tmpMap) {
                 if (tmpMap.hasOwnProperty(reg)) {
                     const tmpValue = tmpMap[reg];
                     if (typeof tmpValue === 'string' && (tmpValue.startsWith('TMP') || tmpValue.startsWith('ERR'))) {
                         const info = genInfo[reg]; // Get corresponding info
                         autoTmpEntries.push({
                             registration: reg,
                             tmp: tmpValue,
                             route: info?.route || 'N/A', // Use info if available
                             timestamp: info?.timestamp || 0 // Use info if available
                         });
                     }
                 }
             }
             console.log(`DEBUG: Found ${autoTmpEntries.length} auto TMP entries.`); // DEBUG
             autoTmpEntries.sort((a, b) => a.registration.localeCompare(b.registration)); // Sort by registration
             let listHTML = '';
             if (autoTmpEntries.length === 0) {
                 listHTML = '<p>No auto-generated TMP/ERR assignments found.</p>';
             } else {
                 autoTmpEntries.forEach(entry => {
                     const timeString = entry.timestamp ? new Date(entry.timestamp).toLocaleString('en-GB', { timeZone: 'Europe/London', dateStyle: 'short', timeStyle: 'short' }) : 'N/A';
                     listHTML += `<div style="display: flex; justify-content: space-between; flex-wrap: wrap; gap: 5px 15px;">
                         <span><strong>Reg:</strong> ${entry.registration}</span>
                         <span><strong>Assigned:</strong> ${entry.tmp}</span>
                         <span><strong>Route Seen:</strong> ${entry.route}</span>
                         <span><strong>Time:</strong> ${timeString}</span>
                     </div>`;
                 });
             }
             autoTmpList.innerHTML = listHTML;
         } catch (e) {
             console.error("DEBUG: Error loading auto TMP data:", e); // DEBUG
             autoTmpList.innerHTML = '<p style="color: red;">Error loading data.</p>';
         }
     }
     function hideAutoTmpModal() {
         console.log("DEBUG: hideAutoTmpModal function called."); // DEBUG
         if (autoTmpModal) { autoTmpModal.classList.add('hidden'); }
     }
     function resetTMPMap() {
         console.log("DEBUG: resetTMPMap function called."); // DEBUG
         if (!isLoggedIn || users[currentUsername]?.role !== 'admin') {
             console.warn("DEBUG: resetTMPMap access denied."); // DEBUG
             alert('Admin Access Denied.'); return;
         }
         if (confirm('DANGER: Reset ALL TMP assignments? This includes both manual and auto-generated ones. Cannot undo.')) {
             console.log("DEBUG: User confirmed TMP reset. Showing password modal."); // DEBUG
             if (!passwordModal || !passwordModalInput || !passwordModalError) {
                 console.error("DEBUG: Password modal elements missing."); // DEBUG
                 alert("Error: Cannot show password dialog."); return;
             }
             passwordModalInput.value = ''; // Clear previous attempts
             passwordModalError.textContent = '';
             passwordModal.classList.remove('hidden');
             passwordModalInput.focus();
         } else {
              console.log("DEBUG: User cancelled TMP reset."); // DEBUG
         }
     }
     function handlePasswordConfirm() {
         console.log("DEBUG: handlePasswordConfirm function called."); // DEBUG
         if (!isLoggedIn || !currentUsername || !users[currentUsername]) {
             console.error("DEBUG: Cannot verify user for password confirm."); // DEBUG
             if(passwordModalError) passwordModalError.textContent = 'Error: Cannot verify user.'; return;
         }
         if (!passwordModalInput || !passwordModalError || !passwordModal) {
              console.error("DEBUG: Password modal elements missing for confirm handler."); // DEBUG
              return;
         }
         const enteredPassword = passwordModalInput.value;
         const correctPassword = users[currentUsername].pass;
         console.log("DEBUG: Checking entered password against stored password."); // DEBUG

         if (enteredPassword === correctPassword) {
             console.log("DEBUG: Password correct. Proceeding with TMP reset."); // DEBUG
             try {
                 localStorage.removeItem(tmpMapKey);
                 localStorage.removeItem(tmpGenerationInfoKey); // Also clear generation info
                 console.log("DEBUG: Removed tmpMapKey and tmpGenerationInfoKey from localStorage."); // DEBUG
                 // Verify removal (optional but good practice)
                 if (localStorage.getItem(tmpMapKey) === null && localStorage.getItem(tmpGenerationInfoKey) === null) {
                     alert('TMP assignment map and generation info cleared.');
                     console.log("DEBUG: SUCCESS: TMP Map and Gen Info cleared by user:", currentUsername); // DEBUG
                 } else {
                     console.error("DEBUG: ERROR: Failed to verify map/info clearance!"); // DEBUG
                     alert('ERROR: Failed to verify map clearance!');
                 }
                 displayManualAssignments(); // Refresh display (should be empty now)
                 passwordModal.classList.add('hidden'); // Hide modal
             } catch (e) {
                 console.error("DEBUG: Error removing TMP map/info:", e); // DEBUG
                 if(passwordModalError) passwordModalError.textContent = "Error clearing data.";
             }
         } else {
             console.warn("DEBUG: Incorrect password entered for TMP reset."); // DEBUG
             passwordModalError.textContent = 'Incorrect password.';
             passwordModalInput.focus();
             passwordModalInput.select();
         }
     }
     function cancelPasswordReset() {
         console.log("DEBUG: cancelPasswordReset function called."); // DEBUG
         if(passwordModal) passwordModal.classList.add('hidden');
     }


    // --- Settings Section Logic ---
    function loadTrackerSettings() {
        console.log("DEBUG: loadTrackerSettings function called."); // DEBUG
        const s=loadFromStorage(settingsKey,defaultSettings);
        console.log("DEBUG: Loaded settings:", s); // DEBUG
        if(settingsDebounceInput) settingsDebounceInput.value=s.debounceMinutes??defaultSettings.debounceMinutes;
        if(settingsTimeoutInput) settingsTimeoutInput.value=s.timeoutMinutes??defaultSettings.timeoutMinutes;
        if(settingsAutoLogoutInput) settingsAutoLogoutInput.value=s.autoLogoutMinutes??defaultSettings.autoLogoutMinutes;
    }
    function saveTrackerSettings() {
        console.log("DEBUG: saveTrackerSettings function called."); // DEBUG
        if (!isLoggedIn || users[currentUsername]?.role !== 'admin') {
            console.warn("DEBUG: saveTrackerSettings access denied."); // DEBUG
            alert('Admin Access Denied.'); return;
        }
        if(!settingsDebounceInput || !settingsTimeoutInput || !settingsAutoLogoutInput || !trackerSettingsMessage) {
             console.error("DEBUG: Missing settings form elements for save."); // DEBUG
             return;
        }
        const debounceVal = settingsDebounceInput.value;
        const timeoutVal = settingsTimeoutInput.value;
        const autoLogoutVal = settingsAutoLogoutInput.value;
        console.log(`DEBUG: Saving settings - Debounce: ${debounceVal}, Timeout: ${timeoutVal}, AutoLogout: ${autoLogoutVal}`); // DEBUG

        const d=parseInt(debounceVal,10);
        const t=parseInt(timeoutVal,10);
        const a=parseInt(autoLogoutVal,10);
        trackerSettingsMessage.textContent = '';

        if(isNaN(d)||d<0){console.warn("DEBUG: Invalid Debounce Time.");alert("Invalid Debounce Time.");trackerSettingsMessage.textContent="Invalid Debounce Time.";trackerSettingsMessage.style.color="red";return;}
        if(isNaN(t)||t<1){console.warn("DEBUG: Invalid Timeout Threshold.");alert("Invalid Timeout Threshold.");trackerSettingsMessage.textContent="Invalid Timeout Threshold.";trackerSettingsMessage.style.color="red";return;}
        if(isNaN(a)||a<0){console.warn("DEBUG: Invalid Auto Logout Time.");alert("Invalid Auto Logout Time.");trackerSettingsMessage.textContent="Invalid Auto Logout Time.";trackerSettingsMessage.style.color="red";return;}

        const newSettings = {debounceMinutes:d, timeoutMinutes:t, autoLogoutMinutes:a};
        console.log("DEBUG: Saving new settings object:", newSettings); // DEBUG
        saveToStorage(settingsKey, newSettings);
        trackerSettingsMessage.textContent="Settings saved!";
        trackerSettingsMessage.style.color="green";
        startSessionTimer(); // Restart timer with potentially new value
        setTimeout(() => { if(trackerSettingsMessage) trackerSettingsMessage.textContent = ""; }, 3000);
    }
     function changeMyPassword() {
         console.log("DEBUG: changeMyPassword function called."); // DEBUG
         if(!isLoggedIn||!currentUsername){console.warn("DEBUG: Not logged in for changeMyPassword.");alert("Not logged in.");return;}
         if(!currentPasswordInput||!newPasswordInput||!confirmNewPasswordInput||!changePasswordMessage){
              console.error("DEBUG: Missing password change elements."); // DEBUG
              return;
         }
         const currentPass = currentPasswordInput.value;
         const newPass = newPasswordInput.value;
         const confirmPass = confirmNewPasswordInput.value;
         changePasswordMessage.textContent='';

         if(!currentPass||!newPass||!confirmPass){console.warn("DEBUG: Missing fields for password change.");changePasswordMessage.textContent="Fill all fields.";changePasswordMessage.style.color="red";return;}
         if(newPass.length<6){console.warn("DEBUG: New password too short.");changePasswordMessage.textContent="New pass >= 6 chars.";changePasswordMessage.style.color="red";return;}
         if(newPass!==confirmPass){console.warn("DEBUG: New passwords don't match.");changePasswordMessage.textContent="New passwords don't match.";changePasswordMessage.style.color="red";return;}
         if(users[currentUsername].pass!==currentPass){console.warn("DEBUG: Incorrect current password.");changePasswordMessage.textContent="Incorrect current password.";changePasswordMessage.style.color="red";return;}
         if(newPass===currentPass){console.warn("DEBUG: New password is same as old.");changePasswordMessage.textContent="New pass same as old.";changePasswordMessage.style.color="red";return;}

         console.log(`DEBUG: Changing password for user: ${currentUsername}`); // DEBUG
         users[currentUsername].pass=newPass;
         saveUsersToStorage(); // Save updated user data
         changePasswordMessage.textContent="Password changed!";
         changePasswordMessage.style.color="green";
         currentPasswordInput.value='';newPasswordInput.value='';confirmNewPasswordInput.value='';
         setTimeout(()=>{if(changePasswordMessage)changePasswordMessage.textContent='';},4000);
     }
     function displayUserManagement() {
         console.log("DEBUG: displayUserManagement function called."); // DEBUG
         if(!isLoggedIn||users[currentUsername]?.role!=='admin'||!userManagementTbody){
             console.warn("DEBUG: Cannot display user management - conditions not met."); // DEBUG
             return;
         }
         userManagementTbody.innerHTML=''; // Clear existing rows
         userManagementMessage.textContent='';
         console.log("DEBUG: Populating user management table."); // DEBUG
         Object.keys(users).forEach(username=>{
             const userData = users[username];
             const tableRow = userManagementTbody.insertRow();
             tableRow.insertCell().textContent = username; // Username cell

             // Role Cell
             const roleCell = tableRow.insertCell();
             if(username === 'Ryan'){ // Protect Ryan user
                 roleCell.textContent = userData.role;
             } else {
                 const roleSelect = document.createElement('select');
                 roleSelect.id = `role-select-${username}`;
                 roleSelect.innerHTML = `
                     <option value="user" ${userData.role === 'user' ? 'selected' : ''}>User</option>
                     <option value="moderator" ${userData.role === 'moderator' ? 'selected' : ''}>Moderator</option>
                     <option value="admin" ${userData.role === 'admin' ? 'selected' : ''}>Admin</option>
                 `;
                 roleSelect.onchange = () => changeUserRole(username, roleSelect.value);
                 roleCell.appendChild(roleSelect);
             }

             // New Password Cell
             const passwordCell = tableRow.insertCell();
             if(username !== 'Ryan'){ // Protect Ryan user
                 const passwordInput = document.createElement('input');
                 passwordInput.type = 'password';
                 passwordInput.id = `new-pass-${username}`;
                 passwordInput.placeholder = "New password";
                 passwordInput.autocomplete = "new-password";
                 passwordCell.appendChild(passwordInput);
             } else {
                 passwordCell.textContent = 'N/A'; // No password change for Ryan here
             }

             // Actions Cell
             const actionsCell = tableRow.insertCell();
             if(username !== 'Ryan'){ // Protect Ryan user
                 // Set Password Button
                 const setPassButton = document.createElement('button');
                 setPassButton.textContent = 'Set Pass';
                 setPassButton.className = 'blue-button';
                 setPassButton.type = 'button';
                 setPassButton.onclick = () => changeOtherUserPassword(username);
                 actionsCell.appendChild(setPassButton);
                 // Delete Button
                 const deleteButton = document.createElement('button');
                 deleteButton.textContent = 'Delete';
                 deleteButton.className = 'danger-button delete-user-btn';
                 deleteButton.type = 'button';
                 deleteButton.onclick = () => deleteUser(username);
                 actionsCell.appendChild(deleteButton);
             }
         });
     }
     function addUser() {
         console.log("DEBUG: addUser function called."); // DEBUG
         if(!isLoggedIn||users[currentUsername]?.role!=='admin'||!addUsernameInput||!addUserPasswordInput||!addUserRoleSelect||!addUserMessage){
             console.warn("DEBUG: Cannot add user - conditions not met."); // DEBUG
             return;
         }
         const newUsername = addUsernameInput.value.trim();
         const newPassword = addUserPasswordInput.value;
         const newRole = addUserRoleSelect.value;
         addUserMessage.textContent='';
         console.log(`DEBUG: Attempting to add user - Username: ${newUsername}, Role: ${newRole}`); // DEBUG

         if(!newUsername||!newPassword){console.warn("DEBUG: Username/password required for add user.");addUserMessage.textContent="Username/pass required.";addUserMessage.style.color="red";return;}
         if(newPassword.length<6){console.warn("DEBUG: Add user password too short.");addUserMessage.textContent="Pass >= 6 chars.";addUserMessage.style.color="red";return;}
         if(users.hasOwnProperty(newUsername)){console.warn(`DEBUG: Username "${newUsername}" already exists.`);addUserMessage.textContent="Username exists.";addUserMessage.style.color="red";return;}
         if(!['user','admin','moderator'].includes(newRole)){console.warn(`DEBUG: Invalid role selected: ${newRole}`);addUserMessage.textContent="Invalid role.";addUserMessage.style.color="red";return;}

         console.log(`DEBUG: Adding user "${newUsername}" with role "${newRole}".`); // DEBUG
         users[newUsername]={pass:newPassword,role:newRole};
         saveUsersToStorage();
         addUserMessage.textContent=`User "${newUsername}" added.`;
         addUserMessage.style.color="green";
         addUsernameInput.value='';addUserPasswordInput.value='';addUserRoleSelect.value='user';
         displayUserManagement(); // Refresh the table
         setTimeout(()=>{if(addUserMessage)addUserMessage.textContent='';},4000);
     }
     function changeUserRole(usernameToChange, newRole){
         console.log(`DEBUG: changeUserRole called - User: ${usernameToChange}, New Role: ${newRole}`); // DEBUG
         if(!isLoggedIn||users[currentUsername]?.role!=='admin'){
             console.warn("DEBUG: changeUserRole access denied."); // DEBUG
             return;
         }
         if(usernameToChange === 'Ryan'){ // Protect Ryan
             console.warn("DEBUG: Attempted to change Ryan's role."); // DEBUG
             alert("Cannot change Ryan's role.");
             displayUserManagement(); // Reset dropdown if needed
             return;
         }
         if(!users.hasOwnProperty(usernameToChange)){console.warn(`DEBUG: User "${usernameToChange}" not found.`);alert(`User "${usernameToChange}" not found.`);return;}
         if(!['user','admin','moderator'].includes(newRole)){console.warn(`DEBUG: Invalid role "${newRole}" selected.`);alert("Invalid role.");return;}

         if(confirm(`Change role for "${usernameToChange}" to "${newRole}"?`)){
             console.log(`DEBUG: User confirmed role change for ${usernameToChange} to ${newRole}.`); // DEBUG
             users[usernameToChange].role = newRole;
             saveUsersToStorage();
             userManagementMessage.textContent=`Role for "${usernameToChange}" updated.`;
             userManagementMessage.style.color="green";
             displayUserManagement(); // Refresh table
             setTimeout(()=>{if(userManagementMessage)userManagementMessage.textContent='';},4000);
         } else {
             console.log(`DEBUG: User cancelled role change for ${usernameToChange}.`); // DEBUG
             displayUserManagement(); // Refresh to reset dropdown if cancelled
         }
     }
     function changeOtherUserPassword(usernameToChange){
         console.log(`DEBUG: changeOtherUserPassword called for user: ${usernameToChange}`); // DEBUG
         if(!isLoggedIn||users[currentUsername]?.role!=='admin'||usernameToChange === 'Ryan'){ // Protect Ryan
             console.warn("DEBUG: changeOtherUserPassword access denied or attempt on Ryan."); // DEBUG
             return;
         }
         if(!users.hasOwnProperty(usernameToChange)){console.warn(`DEBUG: User "${usernameToChange}" not found.`);alert(`User "${usernameToChange}" not found.`);return;}
         const passwordInputElement = document.getElementById(`new-pass-${usernameToChange}`);
         if(!passwordInputElement){console.error(`DEBUG: Password input element not found for user ${usernameToChange}.`);return;}
         const newPassword = passwordInputElement.value;
         userManagementMessage.textContent='';

         if(!newPassword){console.warn(`DEBUG: No password entered for ${usernameToChange}.`);userManagementMessage.textContent=`Enter password for ${usernameToChange}.`;userManagementMessage.style.color="red";return;}
         if(newPassword.length<6){console.warn(`DEBUG: Password too short for ${usernameToChange}.`);userManagementMessage.textContent="Pass >= 6 chars.";userManagementMessage.style.color="red";return;}

         if(confirm(`Set new password for "${usernameToChange}"?`)){
             console.log(`DEBUG: User confirmed password change for ${usernameToChange}.`); // DEBUG
             users[usernameToChange].pass = newPassword;
             saveUsersToStorage();
             userManagementMessage.textContent=`Password for "${usernameToChange}" updated.`;
             userManagementMessage.style.color="green";
             passwordInputElement.value=''; // Clear input after success
             setTimeout(()=>{if(userManagementMessage)userManagementMessage.textContent='';},4000);
         } else {
              console.log(`DEBUG: User cancelled password change for ${usernameToChange}.`); // DEBUG
         }
     }
     function deleteUser(usernameToDelete){
         console.log(`DEBUG: deleteUser called for user: ${usernameToDelete}`); // DEBUG
         if(!isLoggedIn||users[currentUsername]?.role!=='admin'||usernameToDelete === 'Ryan'){ // Protect Ryan
             console.warn("DEBUG: deleteUser access denied or attempt on Ryan."); // DEBUG
             return;
         }
         if(!users.hasOwnProperty(usernameToDelete)){console.warn(`DEBUG: User "${usernameToDelete}" not found.`);alert(`User "${usernameToDelete}" not found.`);return;}

         if(confirm(`DELETE user "${usernameToDelete}"? This cannot be undone.`)){
             console.log(`DEBUG: User confirmed deletion of user ${usernameToDelete}.`); // DEBUG
             delete users[usernameToDelete];
             saveUsersToStorage();
             userManagementMessage.textContent=`User "${usernameToDelete}" deleted.`;
             userManagementMessage.style.color="green";
             displayUserManagement(); // Refresh table
             setTimeout(()=>{if(userManagementMessage)userManagementMessage.textContent='';},4000);
         } else {
              console.log(`DEBUG: User cancelled deletion of user ${usernameToDelete}.`); // DEBUG
         }
     }


    // --- Fleet/TMP Import/Export Functions ---
    function exportTmpMap() {
        console.log("DEBUG: exportTmpMap function called."); // DEBUG
        if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) {
            console.warn("DEBUG: exportTmpMap access denied."); // DEBUG
            alert('Access Denied.'); return;
        }
        try {
            const tmpMap = loadFromStorage(tmpMapKey, {});
            if (typeof tmpMap !== 'object' || tmpMap === null || Object.keys(tmpMap).length === 0) {
                console.log("DEBUG: No Fleet/TMP assignment data found to export."); // DEBUG
                alert("No Fleet/TMP assignment data found in localStorage to export."); return;
            }
            console.log(`DEBUG: Exporting ${Object.keys(tmpMap).length} TMP assignments.`); // DEBUG
            const jsonString = JSON.stringify(tmpMap, null, 2);
            const blob = new Blob([jsonString], { type: "application/json" });
            const a = document.createElement("a");
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            a.href = URL.createObjectURL(blob);
            a.download = `fleet_tmp_assignments_${timestamp}.json`;
            console.log(`DEBUG: Triggering download for TMP file: ${a.download}`); // DEBUG
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
            alert("Fleet/TMP assignments exported successfully!");
        } catch (e) {
            console.error("DEBUG: Error exporting Fleet/TMP assignments:", e); // DEBUG
            alert("An error occurred during Fleet/TMP assignment export: " + e.message);
        }
    }
     function handleTmpImport(file) {
         console.log("DEBUG: handleTmpImport function called."); // DEBUG
         if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) {
             console.warn("DEBUG: handleTmpImport access denied."); // DEBUG
             alert('Access Denied.'); if(importTmpInput) importTmpInput.value = ''; return;
         }
         if (!file) {
             console.warn("DEBUG: No file selected for TMP import."); // DEBUG
             alert("No file selected for Fleet/TMP import."); return;
         }
         console.log(`DEBUG: File selected for TMP import: ${file.name}, Type: ${file.type}`); // DEBUG
         if (!file.name.toLowerCase().endsWith('.json')) {
             console.warn("DEBUG: Invalid file type for TMP import (not .json)."); // DEBUG
             alert("Please select a valid JSON file (.json) for Fleet/TMP import.");
             if(importTmpInput) importTmpInput.value = ''; return;
         }
         try {
             const reader = new FileReader();
             reader.onload = function(e) {
                 console.log("DEBUG: FileReader onload triggered for TMP import."); // DEBUG
                 try {
                     const importedData = JSON.parse(e.target.result);
                     if (typeof importedData !== 'object' || importedData === null || Array.isArray(importedData)) {
                         console.error("DEBUG: Imported TMP file is not a valid JSON object map."); // DEBUG
                         throw new Error("Imported file is not a valid JSON object map (registration -> fleet/TMP).");
                     }
                     console.log("DEBUG: Imported TMP JSON parsed successfully. Validating entries..."); // DEBUG
                     let invalidEntries = 0;
                     for (const key in importedData) {
                         if (typeof importedData[key] !== 'string') {
                             console.warn(`DEBUG: Invalid non-string value found for key "${key}" during TMP import check. Removing entry.`); // DEBUG
                             delete importedData[key];
                             invalidEntries++;
                         }
                     }
                     if (invalidEntries > 0) {
                         console.log(`DEBUG: Removed ${invalidEntries} invalid entries from TMP import.`); // DEBUG
                         alert(`Warning: Found and removed ${invalidEntries} entries with non-string values during import validation.`);
                     }
                     if (Object.keys(importedData).length === 0 && invalidEntries > 0) {
                         console.error("DEBUG: No valid entries remaining in TMP file after validation."); // DEBUG
                         throw new Error("No valid string entries found in the imported file after validation.");
                     }
                     console.log(`DEBUG: TMP import validation complete. ${Object.keys(importedData).length} valid entries remaining.`); // DEBUG

                     if (!confirm("Importing will REPLACE ALL existing Fleet/TMP assignments (Registration -> Fleet/TMP map). Are you sure? This cannot be undone.")) {
                         console.log("DEBUG: User cancelled TMP import."); // DEBUG
                         if(importTmpInput) importTmpInput.value = ''; return;
                     }
                     console.log("DEBUG: User confirmed TMP import. Saving data..."); // DEBUG
                     saveToStorage(tmpMapKey, importedData);
                     alert(`Fleet/TMP assignments imported successfully! ${Object.keys(importedData).length} assignments loaded. All previous assignments have been replaced.`);
                     // Refresh display if the manual fleet form is visible
                     if (manualFleetForm && !manualFleetForm.classList.contains('hidden')) {
                         console.log("DEBUG: Manual fleet form is visible, refreshing display."); // DEBUG
                         displayManualAssignments();
                     }
                 } catch (error) {
                     console.error("DEBUG: Error inside handleTmpImport onload:", error); // DEBUG
                     alert("Error processing Fleet/TMP assignments: " + error.message);
                 } finally {
                     if(importTmpInput) importTmpInput.value = ''; // Clear selection
                 }
             };
             reader.onerror = function(err) {
                 console.error('DEBUG: FileReader onerror triggered for TMP import:', err); // DEBUG
                 alert("Error reading the selected Fleet/TMP assignment file.");
                 if(importTmpInput) importTmpInput.value = ''; // Clear selection
             };
             reader.readAsText(file);
         } catch (readerSetupError) {
             console.error('DEBUG: Error setting up FileReader for TMP import:', readerSetupError); // DEBUG
             alert('A critical error occurred trying to read the file.');
             if (importTmpInput) importTmpInput.value = '';
         }
     }

    // --- Event Listeners ---
    console.log("DEBUG: Adding event listeners."); // DEBUG
    if(document.getElementById('import-file-curtailments')) {
        document.getElementById('import-file-curtailments').addEventListener('change', function() {
            console.log("DEBUG: Curtailment file input 'change' event."); // DEBUG
            if (this.files && this.files.length > 0) { handleCurtailmentImport(this.files[0]); }
        });
    } else { console.warn("DEBUG: Curtailment import input not found."); }

    if(importTmpInput) {
        importTmpInput.addEventListener('change', function() {
            console.log("DEBUG: TMP file input 'change' event."); // DEBUG
            if (this.files && this.files.length > 0) {
                console.log("DEBUG: TMP File selected:", this.files[0].name); // DEBUG
                handleTmpImport(this.files[0]);
            } else {
                console.log("DEBUG: TMP file input event triggered, but no files found."); // DEBUG
            }
        });
    } else {
        console.error("DEBUG: Could not find importTmpInput element to attach listener."); // DEBUG
    }

    if(document.getElementById('confirm-password')) {
        document.getElementById('confirm-password').addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                console.log("DEBUG: Enter key pressed in password modal."); // DEBUG
                event.preventDefault();
                handlePasswordConfirm();
            }
        });
    } else { console.warn("DEBUG: Password confirmation input not found."); }


    // --- Initial Load ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DEBUG: DOMContentLoaded event fired."); // DEBUG
        const loginContainerRef = document.getElementById('login-container');
        const appContainerRef = document.getElementById('app-container');
        // Check for essential elements including new navigation ones
        if (!loginContainerRef || !appContainerRef || !document.getElementById('main-actions-container') || !document.getElementById('go-back-button')) {
             console.error("DEBUG: CRITICAL ERROR: Essential containers or buttons missing on DOMContentLoaded."); // DEBUG
             document.body.innerHTML = '<p style="color: red;">Page loading error: Essential UI elements missing.</p>';
             return;
        }
        console.log("DEBUG: Essential elements found. Checking login status..."); // DEBUG
        checkLogin(); // Check login status and show appropriate view (login or app)
    });

    console.log('--- DEBUG: SCRIPT END REACHED (with SPA navigation & debugging) ---'); // DEBUG
</script>
</body>
</html>
