<!DOCTYPE html>
<html lang="en">
<head>
    <title>iBus Override & Final Destination Manager</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* Basic Reset & Font */
        body, html { margin: 0; padding: 0; box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }
        body { font-family: Arial, sans-serif; padding: 20px; background-color: #f4f4f4; }

        /* Login Container Styles */
        .login-container { background-color: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); text-align: center; margin: 20px auto; width: 90%; min-width: 300px; max-width: 400px; }
        .form-group, .settings-group { margin-bottom: 15px; text-align: left; }
        .form-group label, .settings-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        .form-group-inline { display: flex; align-items: center; text-align: left; margin-bottom: 15px;}
        .form-group-inline input[type="checkbox"] { width: auto; margin-right: 8px; height: 1em; margin-bottom: 0;}
        .form-group-inline label { font-weight: normal; margin-bottom: 0; }
        .login-container input[type="text"], .login-container input[type="password"] { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; margin-bottom: 10px; font-size: 1em; font-family: inherit; }
        /* Login button style merged below */

        /* Main App Container Styles */
        .container { background-color: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); max-width: 800px; margin: 20px auto; }
        h1, h2 { text-align: center; color: #333; }
        h1 { margin-bottom: 20px; } /* Added bottom margin to H1 */
        h2 { margin-top: 30px; border-top: 1px solid #ccc; padding-top: 20px; margin-bottom: 20px; /* Added margin-bottom */}
        h3 { margin-top: 20px; margin-bottom: 10px; color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px;}
        .form-section, .list-section { margin-bottom: 20px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; text-align: left; }

        /* Input Styles */
        input[type="text"], input[type="password"], textarea { /* Added textarea */
            width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;
            margin-bottom: 15px; font-size: 1em; font-family: inherit; /* Ensure consistent font */
        }
        textarea { line-height: 1.4; } /* Improve textarea readability */
        #filter-overrides, #dest-filter-input { /* Specific styling if needed */ }

        /* Button Styles (Merged & Includes Disabled Style) */
        button, .blue-button { /* Base button style */
            padding: 10px 20px; color: white; border: none; border-radius: 4px; cursor: pointer;
            font-size: 1em; margin-right: 10px; margin-bottom: 10px; /* Adjusted margin */
            transition: background-color 0.2s ease, opacity 0.2s ease; /* Added opacity transition */
            background-color: #007bff; display: inline-block; /* Ensure buttons align nicely */
            vertical-align: middle; /* Align buttons better with text */
        }
        button:hover, .blue-button:hover { background-color: #0056b3; }
        button.danger-button { background-color: #dc3545; /* Made default red */ }
        button.danger-button:hover { background-color: #c82333; }
        button.secondary-button { background-color: #6c757d; font-size: 0.9em; padding: 6px 12px;}
        button.secondary-button:hover { background-color: #5a6268; }
        button.clear-btn { background-color: #ffc107; color: black; } /* Style for clear buttons - now only yellow */
        button.clear-btn:hover { background-color: #e0a800; }
        .login-container button { margin-bottom: 5px; } /* Specific login button margin */

        /* --- Disabled Button Style (Copied from tools.html) --- */
        button:disabled, .blue-button:disabled, .reset-button:disabled, .danger-button:disabled, .secondary-button:disabled, .clear-btn:disabled {
             background-color: #cccccc;
             border-color: #cccccc;
             color: #666666;
             cursor: not-allowed;
             opacity: 0.7; /* Make it slightly faded */
        }
         button:disabled:hover, .blue-button:disabled:hover, .reset-button:disabled:hover, .danger-button:disabled:hover, .secondary-button:disabled:hover, .clear-btn:disabled:hover {
            background-color: #cccccc; /* Prevent hover effect */
            border-color: #cccccc;
            color: #666666;
         }
        /* --- End Disabled Button Style --- */

        /* Menu Styles */
        .main-actions-container { margin-bottom: 25px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }

        /* Override List Styles */
        #overrides-list { max-height: 300px; overflow-y: auto; border: 1px solid #eee; padding: 10px; background-color: #fff; margin-top: 10px;} /* Added max-height, border, etc */
        #overrides-list div, #active-sequence-headings-list div { /* Applied to both lists */
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 5px;
            border-bottom: 1px dotted #eee;
            flex-wrap: wrap;
            gap: 10px; /* Increased gap slightly */
        }
        #overrides-list div:last-child, #active-sequence-headings-list div:last-child { border-bottom: none; }
        #overrides-list div span, #active-sequence-headings-list div span { /* Applied to both lists */
            flex-grow: 1;
            margin-right: 10px;
            text-align: left;
            word-break: break-word;
            min-width: 150px; /* Adjusted min-width */
        }
        #overrides-list div span strong { display: inline-block; min-width: 150px; font-family: monospace; color: #17a2b8; }
        #overrides-list div span strong.global-key { color: #dc3545; font-weight: bold; }
        #overrides-list div span span.dest-dir { font-weight: bold; color: #6c757d; margin-left: 8px; }
        #overrides-list div span em { color: #999; font-style: italic; }
        #overrides-list button, #active-sequence-headings-list button { /* Applied to both lists */
            flex-shrink: 0;
            margin-left: auto; /* Push button right */
            padding: 5px 10px; /* Smaller padding for list buttons */
            font-size: 0.9em;
        }
        /* Specifics for Sequence Heading List */
        #active-sequence-headings-list div span { font-size: 0.95em; }
        #active-sequence-headings-list div span strong { color: #333; font-family: Arial, sans-serif; font-weight: bold; min-width: 60px;}
        #active-sequence-headings-list div span .heading-dir { font-style: italic; color: #555; margin-right: 5px;}
        #active-sequence-headings-list div input[type="checkbox"] { /* Style checkbox */
            margin-right: 10px;
            flex-shrink: 0; /* Prevent checkbox shrinking */
            cursor: pointer;
            vertical-align: middle; /* Align with text */
            height: 1.1em; width: 1.1em; /* Slightly larger checkbox */
        }
        /* Style for Select All Checkbox label */
        #active-sequence-headings-list .select-all-container {
             padding: 8px 5px;
             border-bottom: 1px solid #ccc; /* Separator */
             text-align: left;
             font-weight: bold;
             font-size: 0.9em;
        }
        #active-sequence-headings-list .select-all-container input[type="checkbox"] {
            margin-right: 5px;
        }
         #active-sequence-headings-list .select-all-container label {
             display: inline; /* Allow label next to checkbox */
             font-weight: bold; /* Keep label bold */
             cursor: pointer;
             vertical-align: middle;
         }

        .status-message { margin-top: 10px; text-align: center; min-height: 1em; font-weight: bold; }
        .description-text { font-size: 0.9em; color: #666; margin-bottom: 15px; text-align: left; }
        .override-section { border-top: 1px dashed #eee; padding-top: 15px; margin-top: 20px; }
        .override-group { margin-bottom: 15px; }

        /* --- Styles for Final Destinations Section --- */
        fieldset { border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-bottom: 20px; margin-top: 20px; }
        legend { font-weight: bold; padding: 0 5px; color: #555; }
        .dest-editor-controls { border-bottom: 1px solid #ddd; margin-bottom: 15px; padding-bottom: 15px; display: flex; flex-wrap: wrap; gap: 15px; align-items: flex-end; }
        .dest-editor-controls > div { flex: 1 1 200px; min-width: 180px; }
        .dest-editor-controls label { margin-bottom: 3px; font-size: 0.9em; }
        .dest-editor-controls input[type="text"] { margin-bottom: 0; width: 100%; }
        .dest-editor-controls button { margin: 0 0 0 10px; flex-shrink: 0; } /* Align button vertically */
        .dest-filter-buttons { margin-bottom: 15px; text-align: center; border-bottom: 1px solid #ddd; padding-bottom: 15px;}
        .dest-filter-buttons span { margin-right: 10px; font-weight: bold;} /* Style the "Show:" label */
        .dest-filter-buttons button { font-size: 0.9em; padding: 6px 12px; background-color: #e9ecef; color: #495057; border: 1px solid #ced4da; margin: 0 2px;} /* Added margin */
        .dest-filter-buttons button.active { background-color: #007bff; color: white; border-color: #007bff;}
        .dest-filter-buttons button:hover:not(.active) { background-color: #d7dbdf; }
        #dest-editor-routes { max-height: 400px; overflow-y: auto; border: 1px solid #eee; padding: 10px; background-color: white; margin-bottom: 15px; }
        .dest-route-section { border: 1px solid #ccc; border-radius: 4px; padding: 15px; margin-bottom: 15px; background-color: #fdfdfd; }
        .dest-route-section.filtered-out { display: none; } /* Used by JS */
        .dest-route-section h4 { margin-top: 0; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; border: none; padding: 0; flex-wrap: wrap; gap: 5px; }
        .dest-route-section h4 span { font-size: 1.1em; color: #333; flex-shrink: 0; margin-right: 10px;} /* Added shrink/margin */
        .dest-route-section .route-actions { display: flex; flex-wrap: wrap; gap: 5px; align-items: center; margin-left: auto;} /* Align actions right */
        .dest-route-section .route-actions button { margin-left: 5px; }
        .dest-route-section textarea { font-family: monospace; font-size: 0.95em; line-height: 1.4; width: 100%; box-sizing: border-box; }
        .prefill-status { font-size: 0.8em; color: #666; margin-left: 10px; font-style: italic; display: inline-block; min-height: 1em;}
        .dest-save-actions { text-align: center; margin-top: 15px;}
        .filter-placeholder { text-align: center; font-style: italic; color: #666; padding: 10px; }
        .bulk-input-section { margin-top: 20px; padding-top: 20px; border-top: 1px dashed #ccc; }
        .bulk-input-section textarea { height: 150px; font-family: monospace; }
        .bulk-input-section div { text-align: center; }
        /* --- End Final Destinations Styles --- */

        /* --- Styles for Sequence Heading Override --- */
        #sequence-heading-section .override-group { /* Adjusted selector */
            display: flex;
            flex-wrap: wrap;
            gap: 10px 20px; /* Row and column gap */
            align-items: flex-start;
        }
        #sequence-heading-section .override-group > div { /* Adjusted selector */
            flex: 1 1 200px; /* Allow wrapping, base width */
            min-width: 180px;
        }
        #sequence-heading-section .override-group > div label { /* Adjusted selector */
            margin-bottom: 3px;
        }
        #sequence-heading-section .override-group > div input[type="text"] { /* Adjusted selector */
            margin-bottom: 5px; /* Reduce margin below inputs */
        }
        #sequence-heading-section .action-buttons { /* Adjusted selector */
            text-align: center; /* Center buttons below inputs */
            width: 100%; /* Take full width */
            margin-top: 10px;
        }
        #sequence-heading-section .action-buttons button { /* Adjusted selector */
            margin-bottom: 0; /* Remove bottom margin if needed */
        }
        /* --- End Sequence Heading Override Styles --- */

        /* Utility */
        .hidden { display: none; }
        .welcome-message {
             font-size: 1.2em; color: #555; margin-bottom: 20px; text-align: center;
        }
        /* Access Denied Message Style */
        #access-denied-message {
            color: #721c24; /* Dark red */
            background-color: #f8d7da; /* Light red */
            border: 1px solid #f5c6cb; /* Medium red */
            padding: 15px 20px;
            margin: 30px auto;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            max-width: 600px;
        }

    </style>
</head>
<body>

    <div id="login-container" class="login-container">
        <h2>iBus Override & Final Destination Manager Login</h2>
        <form onsubmit="login(); return false;" autocomplete="off">
            <div class="form-group">
                <label for="username">Username:</label>
                <input type="text" id="username" name="username" required="" autocomplete="off">
            </div>
            <div class="form-group">
                <label for="password">Password:</label>
                <input type="password" id="password" name="password" required="" autocomplete="off">
            </div>
            <div class="form-group-inline">
                <input type="checkbox" id="stayLoggedInCheckbox" name="stayLoggedIn">
                <label for="stayLoggedInCheckbox">Stay logged in (disables auto-logout this session)</label>
            </div>
            <div class="form-group" style="text-align: center;">
                <button type="submit" class="blue-button">Login</button>
                <p id="login-error" style="color: red; margin-top: 10px; min-height: 1em;"></p>
            </div>
        </form>
    </div>

    <div id="access-denied-message" class="hidden">
        You do not have the required privileges (Moderator or Admin) to access this page.
    </div>


    <div id="app-container" class="container hidden">
        <h1>Manage iBus Overrides &amp; Final Destinations</h1>
        <p id="welcome-message" class="welcome-message"></p>

        <div id="main-actions-container" class="main-actions-container">
             <button id="toggle-temp-overrides" onclick="showSection('temp-overrides-section')" class="blue-button">Temporary Overrides</button>
            <button id="toggle-sequence-headings" onclick="showSection('sequence-heading-section')" class="blue-button">Sequence Headings</button>
            <button id="toggle-final-destinations" onclick="showSection('final-destinations-section')" class="blue-button">Final Destinations</button>
        </div>

        <div style="text-align: center; margin-bottom: 20px;">
             <button id="go-back-button" class="blue-button secondary-button hidden" onclick="goBackToMainView()">← Go Back to Menu</button>
        </div>

        <div id="temp-overrides-section" class="hidden">
            <h2>Temporary Destination Overrides</h2>
            <p class="description-text" data-role-text="Admin or Moderator">Overrides apply in order: Specific Bus (Directional) &gt; Route (Directional) &gt; Global.</p>

            <div class="form-section">
                <h3>1. Specific Bus Override (Directional)</h3>
                <p class="description-text" data-role-text="Admin">Set a temporary destination for a single bus registration, specific to its direction. Leave a direction blank if not needed. Requires Admin role.</p>
                <div class="override-group">
                    <label for="override-reg">Bus Registration:</label>
                    <input type="text" id="override-reg" placeholder="e.g., AB12CDE" autocomplete="off" data-role="admin">
                </div>
                <div class="override-group">
                    <label for="override-dest-dir1">New Destination for Direction 1:</label>
                    <input type="text" id="override-dest-dir1" placeholder="e.g., Towards Terminus A" autocomplete="off" data-role="admin">
                </div>
                <div class="override-group">
                    <label for="override-dest-dir2">New Destination for Direction 2:</label>
                    <input type="text" id="override-dest-dir2" placeholder="e.g., Towards Terminus B" autocomplete="off" data-role="admin">
                </div>
                <div style="text-align: center;">
                    <button type="button" onclick="setRegistrationOverride()" data-role="admin">Set / Update Specific Override</button>
                    <p id="specific-status" class="status-message" style="color: green;"></p>
                </div>
            </div>

            <div class="form-section override-section">
                <h3>2. Route-Wide Directional Override</h3>
                <p class="description-text" data-role-text="Admin">Set specific temporary iBus destination overrides for each direction of a route. Leave a direction blank if no override is needed for it. Requires Admin role.</p>
                <div class="override-group">
                    <label for="route-override-id">Route:</label>
                    <input type="text" id="route-override-id" placeholder="e.g., 92 or N263" autocomplete="off" data-role="admin">
                </div>
                <div class="override-group">
                    <label for="route-override-dest-dir1">New Destination for Direction 1:</label>
                    <input type="text" id="route-override-dest-dir1" placeholder="e.g., Ealing Hospital" autocomplete="off" data-role="admin">
                </div>
                <div class="override-group">
                    <label for="route-override-dest-dir2">New Destination for Direction 2:</label>
                    <input type="text" id="route-override-dest-dir2" placeholder="e.g., Brent Park Tesco" autocomplete="off" data-role="admin">
                </div>
                <div style="text-align: center;">
                    <button type="button" onclick="setRouteOverride()" data-role="admin">Set / Update Directional Route Override</button>
                     <p id="route-status" class="status-message" style="color: green;"></p>
                 </div>
            </div>

            <div class="form-section override-section">
                <h3>3. Global Override</h3>
                <p class="description-text" data-role-text="Moderator or Admin">Set a temporary destination override message for ALL buses on ALL routes (unless overridden above). Requires Moderator or Admin role.</p>
                <div class="override-group">
                    <label for="global-override-dest">Global Message to Display:</label>
                    <input type="text" id="global-override-dest" placeholder="e.g., Check Service Updates" autocomplete="off" data-role="mod-admin">
                </div>
                <div style="text-align: center;">
                    <button type="button" onclick="setGlobalOverride()" data-role="mod-admin">Set Global Override</button>
                    <button type="button" onclick="clearGlobalOverride()" class="danger-button" data-role="mod-admin">Clear Global Override</button>
                     <p id="global-status" class="status-message" style="color: green;"></p>
                 </div>
            </div>

            <div class="list-section override-section">
                <h3>Current Active Temporary Overrides</h3>
                <input type="text" id="filter-overrides" placeholder="Filter list by Reg, Route, or Destination..." autocomplete="off">
                <div id="overrides-list"><p>Loading overrides...</p></div>
            </div>
        </div> <div id="sequence-heading-section" class="override-section hidden">
            <h2>Set Route Sequence Headings</h2>
            <p class="description-text" data-role-text="Moderator or Admin">
                Manually set the 'Towards...' destination shown in the Route Sequence headings on the tracker page.
                This overrides the automatically detected name. Requires Moderator or Admin role to Set, Admin role to Clear or Remove Selected.
            </p>
            <div class="form-section">
                <div class="override-group">
                    <div>
                        <label for="seq-heading-route-id">Route ID:</label>
                        <input type="text" id="seq-heading-route-id" placeholder="e.g., 184" oninput="loadCurrentSequenceHeadings()" autocomplete="off" data-role="mod-admin">
                    </div>
                    <div>
                        <label for="seq-heading-outbound">Outbound Destination:</label>
                        <input type="text" id="seq-heading-outbound" placeholder="e.g., Barnet, Chesterfield Rd" autocomplete="off" data-role="mod-admin">
                    </div>
                    <div>
                        <label for="seq-heading-inbound">Inbound Destination:</label>
                        <input type="text" id="seq-heading-inbound" placeholder="e.g., Turnpike Lane Station" autocomplete="off" data-role="mod-admin">
                    </div>
                </div>
                <div class="action-buttons">
                    <button type="button" onclick="setRouteSequenceHeadings()" class="blue-button" data-role="mod-admin">Set Headings for Route</button>
                    <button type="button" onclick="clearRouteSequenceHeadings()" class="danger-button" data-role="admin">Clear Headings for Route</button> </div>
                <p id="seq-heading-status" class="status-message" style="color: green;"></p>
            </div>

            <div class="list-section override-section" style="margin-top: 30px;">
                <h3>Current Active Sequence Heading Overrides</h3>
                <div id="active-sequence-headings-list" style="max-height: 250px; overflow-y: auto; border: 1px solid #eee; padding: 10px; background-color: #fff; margin-bottom: 15px;">
                    <p>Loading...</p>
                    </div>
                <div style="text-align: center;">
                     <button type="button" id="remove-selected-headings-btn" onclick="removeSelectedSequenceHeadings()" class="danger-button hidden" data-role="admin">
                        Remove Selected Headings
                    </button> <p id="remove-headings-status" class="status-message" style="color: green;"></p>
                </div>
            </div>
             </div> <div id="final-destinations-section" class="hidden">
            <h2>Manage Final Destinations</h2>
            <fieldset id="final-destinations-fieldset">
                <legend>Official Route Termini</legend>
                <p class="description-text" data-role-text="Moderator or Admin">
                     Define official iBus terminus points for routes below to improve automatic curtailment detection on the tracker pages. Requires Moderator or Admin role to Save / Edit / Add / Remove / Suggest.
                     The list shows known TfL routes plus any you've manually added or previously saved.
                     Use the filter to find a route. Click 'Suggest Termini' to attempt to fetch suggestions from TfL (requires internet, may be blocked by browser if running locally). Add / remove routes manually if needed. Click 'Save All' when done.
                     Use the Bulk Input section below to add / update multiple routes at once.
                </p>

                 <div class="dest-editor-controls">
                     <div>
                         <label for="dest-filter-input">Filter Individual Route List:</label>
                         <input type="text" id="dest-filter-input" placeholder="Enter route number..." autocomplete="off">
                     </div>
                     <div>
                         <label for="add-dest-route">Route to Add Manually:</label>
                         <input type="text" id="add-dest-route" placeholder="e.g., 999" autocomplete="off" data-role="mod-admin">
                     </div>
                     <button type="button" onclick="addDestRouteSectionManual()" class="blue-button secondary-button" data-role="mod-admin">Add Manually</button>
                 </div>

                 <div class="dest-filter-buttons">
                     <span>Show:</span>
                     <button type="button" id="filter-btn-all" class="active" onclick="setDestFilterState('all')">All Routes</button>
                     <button type="button" id="filter-btn-edited" onclick="setDestFilterState('edited')">Edited / Saved</button>
                     <button type="button" id="filter-btn-empty" onclick="setDestFilterState('empty')">Empty</button>
                 </div>

                <div id="dest-editor-routes" style="max-height: 400px; overflow-y: auto; border: 1px solid #eee; padding: 10px; background-color: white; margin-bottom: 15px;">
                    <p>Loading routes...</p>
                </div>

                 <div class="bulk-input-section">
                     <h3>Bulk Input / Update</h3>
                     <p class="description-text" data-role-text="Moderator or Admin">Enter destinations here, one per line, using the format <code>ROUTE: Destination Text</code>. Existing destinations for a route will be replaced by the entries provided here for that route. Requires Moderator or Admin role.</p>
                     <textarea id="bulk-dest-input" placeholder="Example:&#10;184: Barnet, Chesterfield Rd&#10;184: Turnpike Lane Station&#10;92: Ealing Hospital&#10;92: Brent Park Tesco" autocomplete="off" data-role="mod-admin"></textarea>
                     <div>
                         <button type="button" id="process-bulk-dest-button" onclick="processBulkInput()" class="blue-button" data-role="mod-admin">Process Bulk Input</button>
                         <p id="bulk-dest-status" class="status-message"></p>
                     </div>
                 </div>

                <div class="dest-save-actions">
                    <button type="button" id="save-dest-button" onclick="saveAllFinalDestinations()" class="blue-button" data-role="mod-admin">Save All Final Destinations</button>
                    <p id="dest-editor-message" class="status-message" style="color: green;"></p>
                </div>

            </fieldset>
        </div> <div style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px; text-align: center;">
            <button type="button" id="logout-button" onclick="logout()" class="blue-button" style="background-color: #6c757d;">Logout</button>
        </div>

    </div> <script>
        // --- Start of JavaScript ---
console.log("DEBUG: iBusDest Script execution started.");

// --- Constants ---
const usersStorageKey = 'liveTrackerUsers';
const settingsKey = "trackerGlobalSettings";
const defaultSettings = { autoLogoutMinutes: 30 };
const destinationOverrideKey = 'destinationOverrides'; // For Temp Overrides
const routeDestinationSettingsKey = 'routeDestinationSettings'; // For Final Destinations
const sequenceHeadingOverrideBaseKey = 'sequenceHeadingOverrides_'; // <<< For Sequence Headings

// --- Global Variables ---
let users = {};
let isLoggedIn = false;
let currentUsername = null;
let sessionTimerId = null;
let currentFinalDestFilter = 'all'; // Default filter state for final dests

// --- Storage Helpers ---
function loadFromStorage(key, defaultValue = {}) {
    // console.log(`DEBUG: loadFromStorage called for key: ${key}`); // Can be verbose
    try {
        const data = localStorage.getItem(key);
        if (data) {
            const parsed = JSON.parse(data);
            // Basic type check - ensure it's an object if default is object, etc.
            // Avoids errors if localStorage has unexpected primitive values for object keys
            if (typeof parsed === typeof defaultValue && parsed !== null) {
                // console.log(`DEBUG: loadFromStorage - Successfully loaded and parsed key: ${key}`);
                return parsed;
            } else if (defaultValue === null && parsed === null) {
                 return parsed; // Allow null if default is null
             } else {
                 // Only log warning if type mismatch is significant (e.g., expected object got string)
                 if (!(Array.isArray(defaultValue) && Array.isArray(parsed))) {
                     console.warn(`DEBUG: Data type mismatch or null value for key ${key}. Expected type similar to default (${typeof defaultValue}), got ${typeof parsed}. Returning default.`);
                 }
                  return defaultValue;
             }
        }
        // console.log(`DEBUG: loadFromStorage - No data found for key: ${key}, returning default.`);
        return defaultValue;
    } catch (e) {
        console.error(`DEBUG: Error loading ${key}:`, e);
        return defaultValue;
    }
}
function saveToStorage(key, data) {
    // console.log(`DEBUG: saveToStorage called for key: ${key}`); // Can be verbose
    try {
        const stringifiedData = JSON.stringify(data);
        localStorage.setItem(key, stringifiedData);
    } catch (e) {
        console.error(`DEBUG: Error saving ${key}:`, e);
        alert(`Error saving ${key}. Storage might be full.`);
    }
}

// --- DOM Element Refs ---
console.log("DEBUG: Getting DOM refs");
// Auth & Main Containers
const loginContainer = document.getElementById('login-container');
const appContainer = document.getElementById('app-container');
const loginError = document.getElementById('login-error');
const welcomeMessageElement = document.getElementById('welcome-message');
const logoutButton = document.getElementById('logout-button');
const accessDeniedMessageDiv = document.getElementById('access-denied-message');

// Navigation
const mainActionsContainer = document.getElementById('main-actions-container');
const goBackButton = document.getElementById('go-back-button');

// Section Containers
const tempOverridesSection = document.getElementById('temp-overrides-section');
const sequenceHeadingSection = document.getElementById('sequence-heading-section');
const finalDestinationsSection = document.getElementById('final-destinations-section');

// Temp Override Elements
const regInput = document.getElementById('override-reg');
const specificDestDir1Input = document.getElementById('override-dest-dir1');
const specificDestDir2Input = document.getElementById('override-dest-dir2');
const specificStatusMsg = document.getElementById('specific-status');
const routeIdInput = document.getElementById('route-override-id');
const routeDestDir1Input = document.getElementById('route-override-dest-dir1');
const routeDestDir2Input = document.getElementById('route-override-dest-dir2');
const routeStatusMsg = document.getElementById('route-status');
const globalDestInput = document.getElementById('global-override-dest');
const globalStatusMsg = document.getElementById('global-status');
const overridesListDiv = document.getElementById('overrides-list');
const filterInput = document.getElementById('filter-overrides');

// Sequence Heading Elements
const seqHeadingRouteIdInput = document.getElementById('seq-heading-route-id');
const seqHeadingOutboundInput = document.getElementById('seq-heading-outbound');
const seqHeadingInboundInput = document.getElementById('seq-heading-inbound');
const seqHeadingStatusMsg = document.getElementById('seq-heading-status');
const activeHeadingsListDiv = document.getElementById('active-sequence-headings-list'); // <<< NEW
const removeSelectedHeadingsBtn = document.getElementById('remove-selected-headings-btn'); // <<< NEW
const removeHeadingsStatusMsg = document.getElementById('remove-headings-status'); // <<< NEW

// Final Destination Elements
const addDestRouteInput = document.getElementById('add-dest-route');
const destFilterInput = document.getElementById('dest-filter-input');
const destEditorRoutesContainer = document.getElementById('dest-editor-routes');
const destEditorMessage = document.getElementById('dest-editor-message');
const destFilterButtons = document.querySelectorAll('.dest-filter-buttons button');
const bulkDestInput = document.getElementById('bulk-dest-input');
const bulkDestStatus = document.getElementById('bulk-dest-status');
const saveDestButton = document.getElementById('save-dest-button');
const processBulkDestButton = document.getElementById('process-bulk-dest-button');
console.log("DEBUG: DOM refs obtained.");

// --- Auth, Timer, Basic UI Functions ---
function loadUsers() {
    console.log("DEBUG: loadUsers function called.");
    try {
        const d = localStorage.getItem(usersStorageKey);
        if (d) {
            users = JSON.parse(d);
            // Basic validation and default structure enforcement
            if (!users.Ryan || !users.Ryan.pass || !users.Ryan.role) {
                 console.warn("DEBUG: loadUsers - Resetting users due to incomplete 'Ryan' user.");
                 setDefaultUsers(); return; // Exit after setting defaults
             }
            let updated = false;
            Object.keys(users).forEach(username => {
                if (typeof users[username] !== 'object' || users[username] === null) {
                    console.warn(`DEBUG: loadUsers - Removing invalid user data for ${username}.`);
                    delete users[username]; updated = true;
                } else {
                     // Ensure essential properties exist - add more checks if needed in future
                     if (users[username].role === undefined) { console.log(`DEBUG: loadUsers - Adding default role for ${username}`); users[username].role = 'user'; updated = true; }
                     if (users[username].permissions === undefined) { console.log(`DEBUG: loadUsers - Adding default permissions for ${username}`); users[username].permissions = {}; updated = true; }
                     if (users[username].isSuspended === undefined) { console.log(`DEBUG: loadUsers - Adding default suspension for ${username}`); users[username].isSuspended = false; updated = true; }
                }
            });
            if (updated) { console.log("DEBUG: loadUsers - Saving updated user structure."); saveUsersToStorage(); }

        } else {
            console.log("DEBUG: loadUsers - No data found, setting defaults.");
            setDefaultUsers();
        }
    } catch (e) { console.error("DEBUG: Error loading users, resetting:", e); setDefaultUsers(); }
     console.log("DEBUG: loadUsers finished. Users object:", JSON.parse(JSON.stringify(users))); // Log a clone
}
function setDefaultUsers() {
    console.log("DEBUG: setDefaultUsers function called.");
    // Ensure Ryan always exists with admin role and defaults
    users = {'Ryan': {pass: 'password', role: 'admin', permissions: {}, isSuspended: false }};
    saveUsersToStorage();
    console.log("DEBUG: Default users set (Ryan/admin).");
}
// saveUsersToStorage - basic version is fine

function checkLogin() {
    console.log("DEBUG: --- checkLogin function called ---");
    loadUsers(); // Load/initialize users first
    try {
        const storedUser = localStorage.getItem('loggedInUser');
        const storedLoggedInStatus = localStorage.getItem('isLoggedIn') === 'true';
        console.log(`DEBUG: checkLogin - Stored User: ${storedUser}, Logged In Status: ${storedLoggedInStatus}`);

        let userIsValid = storedLoggedInStatus && storedUser && users && users[storedUser] && !users[storedUser].isSuspended;
        console.log(`DEBUG: checkLogin - Validation result (logged in, user exists, not suspended): ${userIsValid}`);

        if (userIsValid) {
            // Check if user has permission for this specific page (ibusdest.html)
            const userRole = users[storedUser].role;
            const canAccessIbusPage = userRole === 'admin' || userRole === 'moderator';
            console.log(`DEBUG: checkLogin - User Role: ${userRole}, Can Access iBusDest Page: ${canAccessIbusPage}`);

            if (canAccessIbusPage) {
                console.log("DEBUG: checkLogin - Access granted. Proceeding to showApp for stored user.");
                isLoggedIn = true; currentUsername = storedUser;
                showApp();
            } else {
                console.warn(`DEBUG: checkLogin - User ${storedUser} is valid but lacks permission for ibusdest.html. Showing access denied.`);
                isLoggedIn = false; currentUsername = null; // Log them out conceptually
                localStorage.removeItem('isLoggedIn'); localStorage.removeItem('loggedInUser'); sessionStorage.removeItem('bypassAutoLogout');
                showLogin(true); // Show login screen with access denied message
            }
        } else {
            if (storedLoggedInStatus && storedUser && (!users || !users[storedUser])) { console.warn(`DEBUG: checkLogin - User ${storedUser} was logged in but not found/invalid in loaded data. Forcing logout.`); }
            else if (storedLoggedInStatus && storedUser && users && users[storedUser] && users[storedUser].isSuspended) { console.warn(`DEBUG: checkLogin - User ${storedUser} is suspended. Forcing logout.`); }
            else { console.log("DEBUG: checkLogin - No valid stored login found. Showing login screen."); }
            isLoggedIn = false; currentUsername = null;
            localStorage.removeItem('isLoggedIn'); localStorage.removeItem('loggedInUser'); sessionStorage.removeItem('bypassAutoLogout');
            showLogin(false); // Show login screen without access denied message
        }
    } catch (e) { console.error("DEBUG: Error during checkLogin:", e); isLoggedIn = false; currentUsername = null; showLogin(false); }
    console.log("DEBUG: --- checkLogin finished ---");
}

function login() {
    console.log("DEBUG: --- login function called ---");
    const u = document.getElementById('username'), p = document.getElementById('password'), c = document.getElementById('stayLoggedInCheckbox'), l = document.getElementById('login-error');
    if (!u || !p) { console.error("DEBUG: Login elements missing."); if(l)l.textContent='Login form error.'; return; }
    const usernameInput = u.value; const passwordInput = p.value; const stayLoggedInChecked = c ? c.checked : false;
    if (l) l.textContent = '';

    if (Object.keys(users).length === 0) { console.warn("DEBUG: Login - Users not loaded. Reloading."); loadUsers(); if (Object.keys(users).length === 0) { console.error("DEBUG: Login - Failed to load users."); if(l)l.textContent='Login service error.'; return; } }

    console.log(`DEBUG: Login - Attempting login for user: ${usernameInput}`);

    if (!users.hasOwnProperty(usernameInput)) {
         console.log(`DEBUG: Login failed - User '${usernameInput}' does not exist.`);
         if (l) l.textContent = 'Invalid username or password.'; return;
    }

    if (users[usernameInput].pass === passwordInput) {
        const userData = users[usernameInput]; const userRole = userData.role;
        console.log("DEBUG: Login - Password matched.");

        if (userData.isSuspended) {
             console.warn(`Login attempt failed: User '${usernameInput}' is suspended.`);
             if (l) l.textContent = 'Account suspended. Please contact an administrator.'; return;
        }

        // Check specific page permission
        const canAccessIbusPage = userRole === 'admin' || userRole === 'moderator';
        if (!canAccessIbusPage) {
             console.warn(`DEBUG: Login - User '${usernameInput}' logged in but no privileges for ibusdest.html.`);
             if(l)l.textContent='Login successful, but you do not have privileges for this page.';
             sessionStorage.removeItem('bypassAutoLogout'); return;
        }

        console.log(`DEBUG: Login successful for user: ${usernameInput}, Role: ${userRole}. Access granted.`);
        localStorage.setItem('isLoggedIn', 'true'); localStorage.setItem('loggedInUser', usernameInput);
        if (stayLoggedInChecked) { sessionStorage.setItem('bypassAutoLogout', 'true'); } else { sessionStorage.removeItem('bypassAutoLogout'); }
        isLoggedIn = true; currentUsername = usernameInput;
        showApp();

    } else {
        console.log(`DEBUG: Login failed - Incorrect password for user: ${usernameInput}`);
        if (l) l.textContent = 'Invalid username or password.';
        isLoggedIn = false; currentUsername = null; sessionStorage.removeItem('bypassAutoLogout');
    }
    console.log("DEBUG: --- login function finished ---");
}

function logout() {
    console.log("DEBUG: --- logout function called ---");
    if (isLoggedIn && currentUsername) { console.log(`DEBUG: User ${currentUsername} logged out.`); }
    if (sessionTimerId) { console.log("DEBUG: Clearing session timer on logout."); clearTimeout(sessionTimerId); sessionTimerId = null; }
    localStorage.setItem('isLoggedIn', 'false'); localStorage.removeItem('loggedInUser'); sessionStorage.removeItem('bypassAutoLogout');
    isLoggedIn = false; currentUsername = null;
    showLogin(false); // Show login without access denied message
    console.log("DEBUG: --- logout finished ---");
}

function logoutAfterSession() {
    if (isLoggedIn) {
        const s = loadFromStorage(settingsKey, defaultSettings); const l = s.autoLogoutMinutes || 0;
        console.log(`DEBUG: Session expired after ${l} minutes. Logging out.`);
        alert(`Session expired after ${l} minutes.`);
        logout();
    }
}
function startSessionTimer() {
    if (sessionTimerId) { clearTimeout(sessionTimerId); sessionTimerId = null; }
    if (!isLoggedIn) return;
    const bypass = sessionStorage.getItem('bypassAutoLogout') === 'true';
    if (bypass) { console.log("DEBUG: Auto-logout bypassed by session setting."); return; }
    const s = loadFromStorage(settingsKey, defaultSettings); // Load settings to get timeout
    const l = (typeof s.autoLogoutMinutes === 'number' && s.autoLogoutMinutes >= 0) ? s.autoLogoutMinutes : defaultSettings.autoLogoutMinutes;
    if (l <= 0) { console.log("DEBUG: Session auto-logout disabled (time <= 0)."); return; }
    const m = l * 60 * 1000;
    console.log(`DEBUG: Starting session timer: ${l} minutes.`);
    sessionTimerId = setTimeout(logoutAfterSession, m);
}

function showApp() {
    // Corrected version: loadTrackerSettings() call removed
    console.log("DEBUG: --- showApp function called ---");
    try {
        if (!isLoggedIn || !currentUsername || !users[currentUsername] || users[currentUsername].isSuspended) {
            console.error("DEBUG: showApp - Invalid state (not logged in, user missing, or suspended). Forcing logout.");
            logout(); return;
        }
        const userRole = users[currentUsername].role;
         const isAdmin = userRole === 'admin';
         const isModOrAdmin = isAdmin || userRole === 'moderator';

        if (!isModOrAdmin) { // Double check, though checkLogin should prevent this
             console.error(`DEBUG: showApp - User '${currentUsername}' with role '${userRole}' somehow bypassed login check. Denying access.`);
             logout(); // Force logout
             showLogin(true); // Show access denied on login screen
             return;
         }

        console.log(`DEBUG: showApp - Proceeding for User: ${currentUsername}, Role: ${userRole}`);

        if(loginContainer) loginContainer.classList.add('hidden');
        if(accessDeniedMessageDiv) accessDeniedMessageDiv.classList.add('hidden'); // Hide access denied msg
        if(appContainer) appContainer.classList.remove('hidden');

        if(welcomeMessageElement) { welcomeMessageElement.textContent = `Welcome, ${currentUsername}!`; }

        // Reset UI to main menu view
        goBackToMainView(false); // Call goBack without logging action

        // Apply roles to main menu buttons
        updateElementRoles(mainActionsContainer); // Update roles for buttons inside the main menu

        // NOTE: loadTrackerSettings(); call was removed here as it's not needed

        startSessionTimer(); // Start or restart the session timer

    } catch (e) { console.error("DEBUG: Error in showApp:", e); if (welcomeMessageElement) welcomeMessageElement.textContent = 'Error loading application.'; if (!isLoggedIn) logout(); }
    console.log("DEBUG: --- showApp function finished ---");
}

function showLogin(showAccessDenied = false) {
    console.log(`DEBUG: --- showLogin function called (showAccessDenied: ${showAccessDenied}) ---`);
    try {
        if (sessionTimerId) { console.log("DEBUG: Clearing session timer during showLogin."); clearTimeout(sessionTimerId); sessionTimerId = null; }
        sessionStorage.removeItem('bypassAutoLogout');

        if(appContainer) appContainer.classList.add('hidden'); // Hide main content
        if(loginContainer) loginContainer.classList.remove('hidden');

         // Show or hide access denied message
        if(accessDeniedMessageDiv) {
             accessDeniedMessageDiv.classList.toggle('hidden', !showAccessDenied);
        } else {
             console.warn("DEBUG: showLogin - Access denied message div not found.");
         }

        if(welcomeMessageElement) welcomeMessageElement.textContent = '';
        if(loginError) loginError.textContent = '';
        const u = document.getElementById('username'); if(u) u.value = '';
        const p = document.getElementById('password'); if(p) p.value = '';
        const c = document.getElementById('stayLoggedInCheckbox'); if(c) c.checked = false;

        // Ensure sections and back button are hidden if user logs out/fails login
         goBackToMainView(false); // Hide all sections and back button

    } catch (e) { console.error("DEBUG: Error in showLogin:", e); }
    console.log("DEBUG: --- showLogin finished ---");
}

// --- Section Navigation & Role Control ---
function showSection(sectionId) {
     console.log(`DEBUG: --- showSection called for sectionId: ${sectionId} ---`);
     if (!isLoggedIn || !currentUsername || !users[currentUsername]) { console.warn("DEBUG: showSection called but user not logged in."); alert('Not logged in.'); return; }
     const userRole = users[currentUsername].role;
     const isAdmin = userRole === 'admin';
     const isModOrAdmin = isAdmin || userRole === 'moderator';
     console.log(`DEBUG: showSection - User: ${currentUsername}, Role: ${userRole}`);
     const sectionElement = document.getElementById(sectionId);
     if (!sectionElement) { console.error(`DEBUG: Section ${sectionId} not found.`); return; }

     // --- Permission Checks (Simplified - all sections require Mod/Admin on this page) ---
     if (!isModOrAdmin) {
         console.warn(`DEBUG: Access denied for user ${currentUsername} (Role: ${userRole}) to section ${sectionId}.`);
         alert('Access Denied.'); return;
     }

     // --- Hide Menu, Show Section & Go Back Button ---
     console.log("DEBUG: Hiding main menu, showing section and back button.");
     if (mainActionsContainer) mainActionsContainer.classList.add('hidden');
     if (tempOverridesSection) tempOverridesSection.classList.add('hidden');
     if (sequenceHeadingSection) sequenceHeadingSection.classList.add('hidden');
     if (finalDestinationsSection) finalDestinationsSection.classList.add('hidden');

     sectionElement.classList.remove('hidden');
     if (goBackButton) goBackButton.classList.remove('hidden');

     // --- Update Element Roles/Disabled State WITHIN the shown section ---
     updateElementRoles(sectionElement);

     // --- Section Specific Initialisation ---
     console.log(`DEBUG: Performing initialisation for section ${sectionId}.`);
     // Clear previous status messages
     [specificStatusMsg, routeStatusMsg, globalStatusMsg, seqHeadingStatusMsg, removeHeadingsStatusMsg, destEditorMessage, bulkDestStatus].forEach(el => { if(el) el.textContent = ''; });

     switch (sectionId) {
        case 'temp-overrides-section':
             displayOverrides();
             if(filterInput) filterInput.value = ''; // Clear filter
             break;
        case 'sequence-heading-section':
             if(seqHeadingRouteIdInput) seqHeadingRouteIdInput.value = ''; // Clear inputs
             if(seqHeadingOutboundInput) seqHeadingOutboundInput.value = '';
             if(seqHeadingInboundInput) seqHeadingInboundInput.value = '';
             displayActiveSequenceHeadings(); // <<< Load and display the list
             break;
        case 'final-destinations-section':
             populateDestEditor(); // Reload routes etc.
             setDestFilterState('all'); // Reset filter view
             if(destFilterInput) destFilterInput.value = '';
             if(bulkDestInput) bulkDestInput.value = ''; // Clear bulk input
             break;
     }
     console.log(`DEBUG: --- showSection for ${sectionId} finished ---`);
}

function goBackToMainView(logAction = true) { // Added flag to prevent logging during setup
     if(logAction) console.log("DEBUG: goBackToMainView called.");
     // Hide all sections and the go back button
     if (tempOverridesSection) tempOverridesSection.classList.add('hidden');
     if (sequenceHeadingSection) sequenceHeadingSection.classList.add('hidden');
     if (finalDestinationsSection) finalDestinationsSection.classList.add('hidden');
     if (goBackButton) goBackButton.classList.add('hidden');

     // Show the main actions menu
     if (mainActionsContainer) mainActionsContainer.classList.remove('hidden');

     // Clear status messages when going back
     [specificStatusMsg, routeStatusMsg, globalStatusMsg, seqHeadingStatusMsg, removeHeadingsStatusMsg, destEditorMessage, bulkDestStatus].forEach(el => { if(el) el.textContent = ''; });
}

/**
 * Updates the disabled state and appends role text for elements within a container based on current user role.
 * @param {HTMLElement} container - The parent element containing elements with data-role attributes.
 */
 function updateElementRoles(container) {
     if (!container) { console.warn("DEBUG: updateElementRoles - Container not found."); return;}
     if (!isLoggedIn || !currentUsername || !users[currentUsername]) { console.warn("DEBUG: updateElementRoles - Cannot update roles, user not logged in."); return; }
     const userRole = users[currentUsername].role;
     const isAdmin = userRole === 'admin';
     const isModOrAdmin = isAdmin || userRole === 'moderator';
     // console.log(`DEBUG: updateElementRoles - Updating roles within container: ${container.id || container.tagName}, UserRole: ${userRole}`);

     const elements = container.querySelectorAll('[data-role]');

     elements.forEach(el => {
         const requiredRole = el.dataset.role; // 'admin' or 'mod-admin'
         let hasPermission = false;

         if (requiredRole === 'admin' && isAdmin) {
             hasPermission = true;
         } else if (requiredRole === 'mod-admin' && isModOrAdmin) {
             hasPermission = true;
         }
         // Add more specific permission checks here later if needed based on users[currentUsername].permissions

         // Disable element if user lacks permission
         // Check tag type to avoid disabling non-form elements incorrectly
         if (['BUTTON', 'INPUT', 'TEXTAREA', 'SELECT'].includes(el.tagName)) {
             el.disabled = !hasPermission;
         } else {
              // For non-form elements (like p tags with data-role-text), we might just visually indicate
              // This part is less critical now as the whole page requires Mod/Admin
         }

         // Remove or add role text (this is more of an example, might not be needed if page access is strict)
        const roleTextSpan = el.querySelector('.role-text');
        if (roleTextSpan) roleTextSpan.remove(); // Remove existing text first

        // Example of adding role text - adjust as needed
        // if (hasPermission && el.dataset.roleText) {
        //     // ... logic to add (Admin Only) or (Mod/Admin Only) text ...
        // }
     });
     // console.log(`DEBUG: updateElementRoles - Finished updating roles within ${container.id || container.tagName}`);
 }


// --- Temporary Override Functions (Logic Unchanged, Relies on updateElementRoles) ---
function displayOverrides() {
    if (!overridesListDiv || !filterInput) { console.warn("Override display elements missing"); return; }
    const overrides = loadFromStorage(destinationOverrideKey, {});
    overridesListDiv.innerHTML = '';
    const filterText = filterInput.value.trim().toUpperCase();
    let itemsDisplayed = 0;

    // Display Global Override
    if (overrides.hasOwnProperty('*')) {
        const globalDest = overrides['*'];
        const globalDestUpper = globalDest.toUpperCase();
        if (!filterText || 'GLOBAL OVERRIDE'.includes(filterText) || globalDestUpper.includes(filterText)) {
             const itemDiv = document.createElement('div'); itemDiv.dataset.key = '*';
             const textSpan = document.createElement('span'); textSpan.innerHTML = `<strong class="global-key">GLOBAL OVERRIDE:</strong> ${globalDest}`;
             const removeBtn = document.createElement('button'); removeBtn.textContent = 'Remove'; removeBtn.className = 'danger-button'; removeBtn.type = 'button'; removeBtn.onclick = () => removeOverride('*'); removeBtn.setAttribute('data-role', 'mod-admin'); // Role required to remove
             itemDiv.appendChild(textSpan); itemDiv.appendChild(removeBtn); overridesListDiv.appendChild(itemDiv); itemsDisplayed++;
        }
    }

    // Display Other Overrides
    const otherKeys = Object.keys(overrides).filter(k => k !== '*').sort();
    otherKeys.forEach(key => {
        const value = overrides[key];
        let matchesFilter = false; let itemHTML = ''; const keyUpper = key.toUpperCase();
        const isReg = /^[A-Z]{1,3}\d{1,4}$|^[A-Z]{2}\d{2}[A-Z]{3}$|^[A-Z]\d{1,3}[A-Z]{3}$/i.test(key);
        const requiredRoleForRemove = isReg ? 'admin' : 'admin'; // Both need Admin to remove

         if (typeof value === 'object' && value !== null && value.hasOwnProperty('dir1') && value.hasOwnProperty('dir2')) {
              const destDir1 = value.dir1 || ''; const destDir2 = value.dir2 || '';
              const destDir1Upper = destDir1.toUpperCase(); const destDir2Upper = destDir2.toUpperCase();
              matchesFilter = !filterText || keyUpper.includes(filterText) || destDir1Upper.includes(filterText) || destDir2Upper.includes(filterText);
              if (matchesFilter) {
                  const dir1Display = destDir1 ? destDir1 : '<em>(Not Set)</em>'; const dir2Display = destDir2 ? destDir2 : '<em>(Not Set)</em>';
                  const prefix = isReg ? '' : 'Route ';
                  itemHTML = `<strong>${prefix}${key}:</strong> <span class="dest-dir">Dir 1:</span> ${dir1Display} <span class="dest-dir">Dir 2:</span> ${dir2Display}`;
              }
         } // Add legacy string support if needed

        if (matchesFilter) {
            const itemDiv = document.createElement('div'); itemDiv.dataset.key = key;
            const textSpan = document.createElement('span'); textSpan.innerHTML = itemHTML;
            const removeBtn = document.createElement('button'); removeBtn.textContent = 'Remove'; removeBtn.className = 'danger-button'; removeBtn.type = 'button'; removeBtn.onclick = () => removeOverride(key);
            removeBtn.setAttribute('data-role', requiredRoleForRemove); // Set role based on type (Admin for both now)
            itemDiv.appendChild(textSpan); itemDiv.appendChild(removeBtn); overridesListDiv.appendChild(itemDiv); itemsDisplayed++;
        }
    });

    if (itemsDisplayed === 0) { overridesListDiv.innerHTML = filterText ? '<p class="filter-placeholder">No overrides match your filter.</p>' : '<p>No destination overrides currently set.</p>'; }
    else { updateElementRoles(overridesListDiv); } // Apply roles to the dynamically added remove buttons
}
function setRegistrationOverride() {
    // Permission check done by updateElementRoles disabling the button
    const reg = regInput.value.trim().toUpperCase();
    const destDir1 = specificDestDir1Input.value.trim();
    const destDir2 = specificDestDir2Input.value.trim();
    if(specificStatusMsg) specificStatusMsg.textContent = '';
    if (!reg) { alert('Please enter the Bus Registration.'); regInput.focus(); return; }
    if (!destDir1 && !destDir2) { alert('Please enter a destination for at least one direction.'); specificDestDir1Input.focus(); return; }
    // Format check (optional) ...
    try {
        let overrides = loadFromStorage(destinationOverrideKey, {});
        overrides[reg] = { dir1: destDir1, dir2: destDir2 };
        saveToStorage(destinationOverrideKey, overrides);
        if(specificStatusMsg) { specificStatusMsg.textContent = `Directional override updated for ${reg}.`; specificStatusMsg.style.color = 'green'; setTimeout(() => { if(specificStatusMsg) specificStatusMsg.textContent = ''; }, 4000); }
        regInput.value = ''; specificDestDir1Input.value = ''; specificDestDir2Input.value = ''; regInput.focus(); displayOverrides();
    } catch (e) { console.error("Error setting registration override:", e); if(specificStatusMsg) { specificStatusMsg.textContent = "Error saving override."; specificStatusMsg.style.color = 'red'; } }
}
function setRouteOverride() {
    // Permission check done by updateElementRoles
    const routeId = routeIdInput.value.trim().toUpperCase(); const destDir1 = routeDestDir1Input.value.trim(); const destDir2 = routeDestDir2Input.value.trim(); if(routeStatusMsg) routeStatusMsg.textContent = ''; if (!routeId) { alert('Please enter the Route.'); routeIdInput.focus(); return; } if (!destDir1 && !destDir2) { alert('Please enter a destination for at least one direction.'); routeDestDir1Input.focus(); return; }
    // Format check (optional) ...
    try { let overrides = loadFromStorage(destinationOverrideKey, {}); overrides[routeId] = { dir1: destDir1, dir2: destDir2 }; saveToStorage(destinationOverrideKey, overrides); if(routeStatusMsg) { routeStatusMsg.textContent = `Directional override updated for Route ${routeId}.`; routeStatusMsg.style.color = 'green'; setTimeout(() => { if(routeStatusMsg) routeStatusMsg.textContent = ''; }, 4000); } routeIdInput.value = ''; routeDestDir1Input.value = ''; routeDestDir2Input.value = ''; routeIdInput.focus(); displayOverrides(); } catch (e) { console.error("Error setting route override:", e); if(routeStatusMsg) { routeStatusMsg.textContent = "Error saving override."; routeStatusMsg.style.color = 'red'; } }
}
function setGlobalOverride() {
    // Permission check done by updateElementRoles
    const dest = globalDestInput.value.trim(); if(globalStatusMsg) globalStatusMsg.textContent = ''; if (!dest) { alert('Please enter the Global Message/Destination.'); globalDestInput.focus(); return; } try { let overrides = loadFromStorage(destinationOverrideKey, {}); overrides['*'] = dest; saveToStorage(destinationOverrideKey, overrides); if(globalStatusMsg) { globalStatusMsg.textContent = `Global override set to "${dest}".`; globalStatusMsg.style.color = 'green'; setTimeout(() => { if(globalStatusMsg) globalStatusMsg.textContent = ''; }, 4000); } globalDestInput.value = ''; displayOverrides(); } catch (e) { console.error("Error setting global override:", e); if(globalStatusMsg) { globalStatusMsg.textContent = "Error saving override."; globalStatusMsg.style.color = 'red'; } }
}
function clearGlobalOverride() {
    // Permission check done by updateElementRoles
    if (!confirm(`Are you sure you want to remove the Global destination override?`)) { return; }
    removeOverride('*');
}
function removeOverride(keyToRemove) {
    // Permission is checked dynamically on the button itself via displayOverrides + updateElementRoles
    // Confirmation logic
    if (keyToRemove !== '*' && !confirm(`Are you sure you want to remove the override for "${keyToRemove}"?`)) { return; }

    const overrides = loadFromStorage(destinationOverrideKey, {});
    // Clear relevant status message...
    [specificStatusMsg, routeStatusMsg, globalStatusMsg].forEach(el => { if(el) el.textContent = ''; });

    try {
        if (overrides.hasOwnProperty(keyToRemove)) {
            delete overrides[keyToRemove];
            saveToStorage(destinationOverrideKey, overrides);
            console.log(`Override removed for key: ${keyToRemove}.`);
            // Show status message...
            if (keyToRemove === '*' && globalStatusMsg) { globalStatusMsg.textContent = 'Global override removed.'; globalStatusMsg.style.color = 'green'; setTimeout(() => { if(globalStatusMsg) globalStatusMsg.textContent = ''; }, 4000); }
            displayOverrides(); // Refresh list
        } else {
             console.warn(`Override key "${keyToRemove}" not found.`);
              if(keyToRemove === '*' && globalStatusMsg) { globalStatusMsg.textContent = 'No Global override was set.'; globalStatusMsg.style.color = 'orange'; setTimeout(() => { if(globalStatusMsg) globalStatusMsg.textContent = ''; }, 4000); }
        }
    } catch(e) { console.error("Error removing override:", e); alert("Error removing override.");}
}

// --- Sequence Heading Functions ---
function loadCurrentSequenceHeadings() {
    const routeId = seqHeadingRouteIdInput.value.trim().toUpperCase();
    if (!routeId) { seqHeadingOutboundInput.value = ''; seqHeadingInboundInput.value = ''; return; }
    const key = sequenceHeadingOverrideBaseKey + routeId;
    const savedHeadings = loadFromStorage(key, null);
    if (savedHeadings && typeof savedHeadings === 'object') {
         seqHeadingOutboundInput.value = savedHeadings.outbound || '';
         seqHeadingInboundInput.value = savedHeadings.inbound || '';
    } else {
         seqHeadingOutboundInput.value = '';
         seqHeadingInboundInput.value = '';
    }
}
function setRouteSequenceHeadings() {
     // Permission check done by updateElementRoles
     const routeId = seqHeadingRouteIdInput.value.trim().toUpperCase();
     const outbound = seqHeadingOutboundInput.value.trim();
     const inbound = seqHeadingInboundInput.value.trim();
     if(seqHeadingStatusMsg) seqHeadingStatusMsg.textContent = '';
     if (!routeId) { alert("Please enter a Route ID."); seqHeadingRouteIdInput.focus(); return; }
     if (!outbound && !inbound) { alert("Please enter at least one heading (Outbound or Inbound)."); seqHeadingOutboundInput.focus(); return; }
     try {
         const key = sequenceHeadingOverrideBaseKey + routeId;
         const headings = { outbound: outbound, inbound: inbound };
         saveToStorage(key, headings);
         if(seqHeadingStatusMsg) { seqHeadingStatusMsg.textContent = `Headings for Route ${routeId} saved.`; seqHeadingStatusMsg.style.color = 'green'; setTimeout(() => { if(seqHeadingStatusMsg) seqHeadingStatusMsg.textContent = ''; }, 3000); }
         // Consider NOT clearing the inputs after save, allows quick edits to same route
         // seqHeadingRouteIdInput.value = ''; seqHeadingOutboundInput.value = ''; seqHeadingInboundInput.value = ''; seqHeadingRouteIdInput.focus();
         displayActiveSequenceHeadings(); // <<< Refresh the list
     } catch (e) { console.error("Error setting sequence headings:", e); if(seqHeadingStatusMsg) { seqHeadingStatusMsg.textContent = "Error saving headings."; seqHeadingStatusMsg.style.color = 'red'; } }
}
function clearRouteSequenceHeadings() {
    // Permission check done by updateElementRoles
    const routeId = seqHeadingRouteIdInput.value.trim().toUpperCase();
    if(seqHeadingStatusMsg) seqHeadingStatusMsg.textContent = '';
    if (!routeId) { alert("Please enter a Route ID to clear headings for."); seqHeadingRouteIdInput.focus(); return; }
    const key = sequenceHeadingOverrideBaseKey + routeId;
    if (!localStorage.getItem(key)) {
        if(seqHeadingStatusMsg) { seqHeadingStatusMsg.textContent = `No saved headings found for Route ${routeId}.`; seqHeadingStatusMsg.style.color = 'orange'; setTimeout(() => { if(seqHeadingStatusMsg) seqHeadingStatusMsg.textContent = ''; }, 3000); }
        return;
    }
    if (!confirm(`Are you sure you want to clear the manually set sequence headings for Route ${routeId}?`)) { return; }
    try {
        localStorage.removeItem(key);
        if(seqHeadingStatusMsg) { seqHeadingStatusMsg.textContent = `Headings cleared for Route ${routeId}.`; seqHeadingStatusMsg.style.color = 'green'; setTimeout(() => { if(seqHeadingStatusMsg) seqHeadingStatusMsg.textContent = ''; }, 3000); }
        // Clear inputs only if they currently match the cleared route
        if (seqHeadingRouteIdInput.value.trim().toUpperCase() === routeId) {
             seqHeadingOutboundInput.value = ''; seqHeadingInboundInput.value = '';
        }
        displayActiveSequenceHeadings(); // <<< Refresh the list
    } catch (e) { console.error("Error clearing sequence headings:", e); if(seqHeadingStatusMsg) { seqHeadingStatusMsg.textContent = "Error clearing headings."; seqHeadingStatusMsg.style.color = 'red'; } }
}

/** <<< NEW: Display list of active sequence heading overrides >>> */
function displayActiveSequenceHeadings() {
    if (!activeHeadingsListDiv) { console.error("DEBUG: Active sequence headings list div not found."); return; }
    activeHeadingsListDiv.innerHTML = ''; // Clear previous list
    if(removeHeadingsStatusMsg) removeHeadingsStatusMsg.textContent = ''; // Clear status

    let activeOverrides = [];
    try {
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(sequenceHeadingOverrideBaseKey)) {
                const routeId = key.substring(sequenceHeadingOverrideBaseKey.length);
                const data = loadFromStorage(key, null);
                // Ensure data is an object and has at least one non-empty heading
                if (data && typeof data === 'object' && ( (data.outbound && data.outbound.trim()) || (data.inbound && data.inbound.trim()) )) {
                    activeOverrides.push({ routeId: routeId, data: data });
                } else if (data) {
                     // If an entry exists but both headings are empty/null, remove it silently
                     console.log(`DEBUG: Removing empty heading override entry for route ${routeId}.`);
                     localStorage.removeItem(key);
                 }
            }
        }
    } catch (e) {
         console.error("DEBUG: Error reading localStorage for sequence headings:", e);
         activeHeadingsListDiv.innerHTML = '<p style="color: red;">Error loading overrides list.</p>';
         if (removeSelectedHeadingsBtn) removeSelectedHeadingsBtn.classList.add('hidden');
         return;
    }

    activeOverrides.sort((a, b) => a.routeId.localeCompare(b.routeId, undefined, { numeric: true }));

    const isAdmin = isLoggedIn && users[currentUsername]?.role === 'admin';

    if (activeOverrides.length === 0) {
        activeHeadingsListDiv.innerHTML = '<p>No active sequence heading overrides found.</p>';
        if (removeSelectedHeadingsBtn) removeSelectedHeadingsBtn.classList.add('hidden'); // Hide remove button
    } else {
        // Add "Select All" checkbox if admin
        if (isAdmin) {
             const selectAllDiv = document.createElement('div');
             selectAllDiv.className = 'select-all-container';
             selectAllDiv.innerHTML = `
                 <input type="checkbox" id="select-all-headings-cb" onchange="handleSelectAllHeadings(this.checked)" title="Select/Deselect All">
                 <label for="select-all-headings-cb">Select All</label>`;
             activeHeadingsListDiv.appendChild(selectAllDiv);
        }

        // Add list items
        activeOverrides.forEach(item => {
            const itemDiv = document.createElement('div');
            const checkboxHTML = isAdmin ? `<input type="checkbox" class="heading-override-checkbox" data-routeid="${item.routeId}" title="Select Route ${item.routeId}">` : '';
            const outboundText = item.data.outbound ? item.data.outbound : '<em>(Not Set)</em>';
            const inboundText = item.data.inbound ? item.data.inbound : '<em>(Not Set)</em>';

            itemDiv.innerHTML = `
                ${checkboxHTML}
                <span>
                    <strong>Route ${item.routeId}:</strong>
                    <span class="heading-dir">Out:</span> ${outboundText} |
                    <span class="heading-dir">In:</span> ${inboundText}
                </span>`;
            activeHeadingsListDiv.appendChild(itemDiv);
        });

        // Show/hide the remove button based on admin role
        if (removeSelectedHeadingsBtn) {
            removeSelectedHeadingsBtn.classList.toggle('hidden', !isAdmin);
            removeSelectedHeadingsBtn.disabled = !isAdmin; // Ensure disabled if not admin
        }
    }
}

/** <<< NEW: Handle Select All Checkbox >>> */
function handleSelectAllHeadings(isChecked) {
    if (!activeHeadingsListDiv) return;
    const checkboxes = activeHeadingsListDiv.querySelectorAll('.heading-override-checkbox');
    checkboxes.forEach(cb => cb.checked = isChecked);
}

/** <<< NEW: Remove selected sequence heading overrides >>> */
function removeSelectedSequenceHeadings() {
    // Check role first
    if (!isLoggedIn || users[currentUsername]?.role !== 'admin') {
         alert("Admin privileges required to remove selected headings."); return;
    }
    if (!activeHeadingsListDiv || !removeHeadingsStatusMsg) { console.error("DEBUG: Missing elements for heading removal."); return;}

    const selectedCheckboxes = activeHeadingsListDiv.querySelectorAll('.heading-override-checkbox:checked');
    if (selectedCheckboxes.length === 0) {
        alert("Please select at least one heading override to remove."); return;
    }

    if (!confirm(`Are you sure you want to remove the selected ${selectedCheckboxes.length} sequence heading override(s)?`)) { return; }

    console.log(`DEBUG: Removing ${selectedCheckboxes.length} selected sequence heading overrides.`);
    removeHeadingsStatusMsg.textContent = 'Removing...';
    removeHeadingsStatusMsg.style.color = 'orange';
    let removedCount = 0;
    let errorOccurred = false;

    try {
        selectedCheckboxes.forEach(checkbox => {
            const routeId = checkbox.dataset.routeid;
            if (routeId) {
                const key = sequenceHeadingOverrideBaseKey + routeId;
                localStorage.removeItem(key);
                removedCount++;
                console.log(`DEBUG: Removed heading override for route ${routeId}`);
            } else {
                console.warn("DEBUG: Found selected checkbox without routeId data.");
            }
        });
    } catch (e) {
         console.error("DEBUG: Error during heading removal from localStorage:", e);
         errorOccurred = true;
    } finally {
         if (errorOccurred) {
             removeHeadingsStatusMsg.textContent = `Error occurred during removal. ${removedCount} removed.`;
             removeHeadingsStatusMsg.style.color = 'red';
         } else {
             removeHeadingsStatusMsg.textContent = `${removedCount} heading override(s) removed successfully.`;
             removeHeadingsStatusMsg.style.color = 'green';
         }
         displayActiveSequenceHeadings(); // Refresh the list
         // Clear the main form inputs if one of the removed routes was loaded there
         const currentRouteIdInForm = seqHeadingRouteIdInput.value.trim().toUpperCase();
         if (currentRouteIdInForm) {
              let formWasCleared = false;
              selectedCheckboxes.forEach(checkbox => {
                   if (checkbox.dataset.routeid === currentRouteIdInForm) {
                        seqHeadingOutboundInput.value = '';
                        seqHeadingInboundInput.value = '';
                        formWasCleared = true;
                   }
              });
              if (formWasCleared) console.log(`DEBUG: Cleared form inputs as route ${currentRouteIdInForm} override was removed.`);
         }
         // Uncheck "Select All" after removal
          const selectAllCb = document.getElementById('select-all-headings-cb');
          if (selectAllCb) selectAllCb.checked = false;

         setTimeout(() => { if(removeHeadingsStatusMsg) removeHeadingsStatusMsg.textContent = ''; }, 4000);
    }
}

// --- Final Destination Functions (Logic Unchanged, Relies on updateElementRoles) ---
// Includes: populateDestEditor, createRouteSectionElement, addDestRouteSectionManual, removeDestRouteSection,
// filterDestSections, fetchAndSuggestTermini, saveAllFinalDestinations, processBulkInput, setDestFilterState
// (Keep the implementations from the previous correct version)
function populateDestEditor() {
     if (!destEditorRoutesContainer || !destFilterInput) { console.error("Destination editor elements not found."); return; }
     destEditorRoutesContainer.innerHTML = ''; // Clear first
     const savedSettings = loadFromStorage(routeDestinationSettingsKey, {});
     // Use a simplified known routes list or fetch dynamically if preferred
     const KNOWN_TFL_BUS_ROUTES = ["1", "2", "2X", "3", "4", "5", "6", "7", "8", "9", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61", "63", "64", "65", "66", "67", "68", "69", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "80", "81", "83", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "100", "101", "102", "103", "104", "105", "106", "107", "108", "109", "110", "111", "112", "113", "114", "115", "116", "117", "118", "119", "120", "121", "122", "123", "124", "125", "126", "127", "128", "129", "130", "131", "132", "133", "134", "135", "136", "137", "138", "139", "140", "141", "142", "143", "144", "145", "146", "147", "148", "149", "150", "151", "152", "153", "154", "155", "156", "157", "158", "159", "160", "161", "162", "163", "164", "165", "166", "167", "168", "169", "170", "171", "172", "173", "174", "175", "176", "177", "178", "179", "180", "181", "182", "183", "184", "185", "186", "187", "188", "189", "190", "191", "192", "193", "194", "195", "196", "197", "198", "199", "200", "201", "202", "204", "205", "206", "207", "208", "209", "210", "211", "212", "213", "214", "215", "216", "217", "218", "219", "220", "221", "222", "223", "224", "225", "226", "227", "228", "229", "230", "231", "232", "234", "235", "236", "237", "238", "240", "241", "242", "243", "244", "245", "246", "247", "248", "249", "250", "251", "253", "254", "255", "256", "257", "258", "259", "260", "261", "262", "263", "264", "265", "266", "267", "268", "269", "270", "271", "272", "273", "274", "275", "276", "277", "278", "279", "280", "281", "283", "284", "285", "286", "287", "288", "289", "290", "291", "292", "293", "295", "296", "297", "298", "299", "300", "301", "302", "303", "304", "306", "307", "308", "309", "312", "313", "314", "315", "316", "317", "318", "319", "320", "321", "322", "323", "324", "325", "326", "327", "328", "329", "331", "332", "333", "335", "336", "337", "339", "340", "341", "343", "344", "345", "346", "347", "349", "350", "352", "353", "354", "355", "356", "357", "358", "359", "360", "362", "363", "364", "365", "366", "367", "368", "370", "371", "372", "375", "376", "377", "378", "379", "381", "382", "383", "384", "385", "386", "389", "390", "391", "393", "394", "395", "396", "397", "398", "399", "401", "403", "404", "405", "406", "407", "410", "411", "412", "413", "414", "415", "417", "418", "419", "422", "423", "425", "427", "428", "430", "432", "433", "434", "436", "439", "440", "444", "450", "452", "453", "456", "460", "462", "463", "464", "465", "466", "467", "468", "469", "470", "472", "473", "474", "476", "481", "482", "483", "484", "485", "486", "487", "488", "490", "491", "492", "493", "496", "498", "499", "507", "533", "601", "602", "603", "605", "606", "608", "612", "613", "635", "639", "641", "649", "653", "655", "661", "664", "665", "670", "677", "681", "688", "689", "690", "696", "697", "698", "969", "C1", "C3", "C10", "C11", "D3", "D6", "D7", "D8", "E1", "E2", "E3", "E5", "E6", "E7", "E8", "E9", "E10", "E11", "EL1", "EL2", "EL3", "G1", "H2", "H3", "H9", "H10", "H11", "H12", "H13", "H14", "H17", "H18", "H19", "H20", "H22", "H25", "H26", "H28", "H32", "H37", "H91", "H98", "K1", "K2", "K3", "K4", "K5", "P4", "P5", "P12", "P13", "PR2", "R1", "R2", "R3", "R4", "R5", "R6", "R7", "R8", "R9", "R10", "R11", "R68", "R70", "S1", "S2", "S3", "S4", "SL1", "SL2", "SL3", "SL5", "SL6", "SL7", "SL8", "SL9", "SL10", "U1", "U2", "U3", "U4", "U5", "U7", "U9", "U10", "W3", "W4", "W5", "W6", "W7", "W8", "W9", "W10", "W11", "W12", "W13", "W14", "W15", "W16", "W19"]; // Keep this large list or manage dynamically
     const knownRoutes = KNOWN_TFL_BUS_ROUTES;
     const routeIdsToShow = new Set([...knownRoutes, ...Object.keys(savedSettings)]);
     const sortedRouteIds = [...routeIdsToShow].sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
     if (sortedRouteIds.length === 0) { destEditorRoutesContainer.innerHTML = '<p class="filter-placeholder">No routes found or saved.</p>'; return; }
     sortedRouteIds.forEach(routeId => { const savedDestinations = savedSettings[routeId] || []; createRouteSectionElement(routeId, savedDestinations); });
     filterDestSections(); // Apply current filter state
}
function createRouteSectionElement(routeId, destinations = []) {
     if (!destEditorRoutesContainer) return; if (destEditorRoutesContainer.querySelector(`[data-routeid="${routeId}"]`)) return;
     const sectionDiv = document.createElement('div'); sectionDiv.className = 'dest-route-section'; sectionDiv.dataset.routeid = routeId;
     const heading = document.createElement('h4');
     const routeLabel = document.createElement('span'); routeLabel.textContent = `Route ${routeId}:`; heading.appendChild(routeLabel);
     const actionsDiv = document.createElement('div'); actionsDiv.className = 'route-actions';
     const prefillBtn = document.createElement('button'); prefillBtn.textContent = 'Suggest Termini'; prefillBtn.title = 'Attempt to fetch termini from TfL API'; prefillBtn.className = 'blue-button secondary-button'; prefillBtn.type = 'button'; prefillBtn.setAttribute('data-role', 'mod-admin'); const statusSpan = document.createElement('span'); statusSpan.className = 'prefill-status'; prefillBtn.onclick = (event) => { fetchAndSuggestTermini(routeId, textarea, statusSpan); }; actionsDiv.appendChild(prefillBtn); actionsDiv.appendChild(statusSpan);
     const removeBtn = document.createElement('button'); removeBtn.textContent = 'Remove'; removeBtn.title = 'Remove this route section'; removeBtn.className = 'danger-button secondary-button'; removeBtn.type = 'button'; removeBtn.setAttribute('data-role', 'mod-admin'); removeBtn.onclick = () => removeDestRouteSection(routeId); actionsDiv.appendChild(removeBtn);
     heading.appendChild(actionsDiv);
     const textarea = document.createElement('textarea'); textarea.rows = 3; textarea.value = Array.isArray(destinations) ? destinations.join('\n') : ''; textarea.placeholder = 'Enter final destinations, one per line'; textarea.setAttribute('aria-label', `Final destinations for route ${routeId}`); textarea.setAttribute('data-role', 'mod-admin'); // Textarea requires role
     sectionDiv.appendChild(heading); sectionDiv.appendChild(textarea);
     const initialMsg = destEditorRoutesContainer.querySelector('p'); if (initialMsg && initialMsg.textContent.startsWith("Loading") || initialMsg?.classList.contains("filter-placeholder")) { initialMsg.remove(); }
     destEditorRoutesContainer.appendChild(sectionDiv);
     updateElementRoles(sectionDiv); // Apply roles to buttons inside the new section
}
function addDestRouteSectionManual() {
    // Permission check done by updateElementRoles
    if (!addDestRouteInput || !destEditorRoutesContainer) return; const routeId = addDestRouteInput.value.trim().toUpperCase(); if (!routeId) { alert('Please enter a Route to add.'); addDestRouteInput.focus(); return; } if (!/^[A-Z0-9]+$/i.test(routeId) || routeId.length > 5) { alert(`Route "${routeId}" looks invalid.`); addDestRouteInput.focus(); return; } if (destEditorRoutesContainer.querySelector(`[data-routeid="${routeId}"]`)) { alert(`Section for Route ${routeId} already exists or is listed.`); destEditorRoutesContainer.querySelector(`[data-routeid="${routeId}"]`)?.scrollIntoView({behavior: "smooth"}); return; } createRouteSectionElement(routeId, []); addDestRouteInput.value = ''; const newSection = destEditorRoutesContainer.querySelector(`[data-routeid="${routeId}"]`); newSection?.scrollIntoView({behavior: "smooth"}); newSection?.querySelector('textarea')?.focus(); filterDestSections();
}
function removeDestRouteSection(routeId) {
     // Permission check done by updateElementRoles
     if (!destEditorRoutesContainer) return; if (!confirm(`Remove section for Route ${routeId}? Unsaved changes lost. This only removes it from the view until 'Save All' is clicked.`)) { return; } const section = destEditorRoutesContainer.querySelector(`[data-routeid="${routeId}"]`); if (section) { section.remove(); filterDestSections(); }
}
function filterDestSections() {
        console.log(`DEBUG: filterDestSections called. Current Button Filter: ${currentFinalDestFilter}`); // Log current filter state
        if (!destEditorRoutesContainer || !destFilterInput) { console.error("DEBUG: Filter sections - Required elements missing."); return; }

        const filterText = destFilterInput.value.trim().toUpperCase(); // Textbox filter
        const sections = destEditorRoutesContainer.querySelectorAll('.dest-route-section');
        let visibleCount = 0;
        const savedSettings = loadFromStorage(routeDestinationSettingsKey, {}); // Load saved data ONCE

        console.log("DEBUG: Loaded savedSettings:", JSON.stringify(savedSettings)); // Log loaded settings

        sections.forEach(section => {
            const routeId = section.dataset.routeid;
            const textarea = section.querySelector('textarea');
            const currentText = textarea ? textarea.value.trim() : '';
            // Get saved text, ensuring consistent line breaks (\n) and trimming
            const savedDestinationsArray = savedSettings[routeId]; // Get array for this route
            const savedText = Array.isArray(savedDestinationsArray) ? savedDestinationsArray.join('\n').trim() : '';
            let show = false;

            if (!routeId) { section.classList.add('filtered-out'); return; } // Skip if no routeId

            const routeIdUpper = routeId.toUpperCase();
            const matchesTextFilter = !filterText || routeIdUpper.includes(filterText); // Check text filter first

            // Log data for the specific route being checked
            console.log(`--- Checking Route: ${routeId} ---`);
            console.log(`   Text Filter Match: ${matchesTextFilter}`);
            console.log(`   Saved Data Array:`, savedDestinationsArray); // See the actual array
            console.log(`   Saved Text String: "${savedText}"`);

            switch (currentFinalDestFilter) { // Check the button filter state
                case 'all':
                    show = matchesTextFilter;
                    console.log(`   Filter = 'all'. Show = ${show}`);
                    break;
                case 'edited': // This is the filter we are debugging
                    const hasSavedData = savedText !== ''; // Check if there's anything saved
                    show = matchesTextFilter && hasSavedData;
                    console.log(`   Filter = 'edited'. Has Saved Data? ${hasSavedData}. Show = ${show}`);
                    break;
                case 'empty':
                    // Show if it matches text filter AND the textarea is currently empty
                    const isEmpty = currentText === '';
                    show = matchesTextFilter && isEmpty;
                     console.log(`   Filter = 'empty'. Is Empty? ${isEmpty}. Show = ${show}`);
                    break;
                default: // Default to 'all' logic
                    show = matchesTextFilter;
                    console.log(`   Filter = 'default/unknown'. Show = ${show}`);
            }

            section.classList.toggle('filtered-out', !show);
            if(show) visibleCount++;
        });

        // Placeholder logic...
        let placeholder = destEditorRoutesContainer.querySelector('p.filter-placeholder');
        if (visibleCount === 0) {
            if (!placeholder) {
                placeholder = document.createElement('p');
                placeholder.className = 'filter-placeholder';
                // Prepend placeholder so it doesn't get lost if sections are added later
                 if (destEditorRoutesContainer.firstChild) {
                      destEditorRoutesContainer.insertBefore(placeholder, destEditorRoutesContainer.firstChild);
                  } else {
                      destEditorRoutesContainer.appendChild(placeholder);
                  }
            }
            placeholder.textContent = (filterText || currentFinalDestFilter !== 'all') ? 'No routes match current filter.' : 'No routes defined.';
            placeholder.style.display = '';
             console.log("DEBUG: No visible routes, showing placeholder:", placeholder.textContent);
        } else if (placeholder) {
            placeholder.style.display = 'none'; // Hide placeholder if routes are visible
            console.log(`DEBUG: ${visibleCount} routes visible, hiding placeholder.`);
        }
    }
async function fetchAndSuggestTermini(routeId, textareaElement, statusSpanElement) {
    // Permission check done by updateElementRoles on the button
    if (!routeId || !textareaElement || !statusSpanElement) return;
    // Removed check for empty textarea - allow overwriting
    statusSpanElement.textContent = 'Fetching...'; statusSpanElement.style.color = 'orange'; textareaElement.disabled = true;
    try {
        const apiUrl = `https://api.tfl.gov.uk/Line/${routeId}/Route/Sequence/all`;
        const response = await fetch(apiUrl);
        if (!response.ok) { throw new Error(response.status === 404 ? `Route ${routeId} sequence not found` : `API Error ${response.status}`); }
        const data = await response.json();
        const termini = new Set();
        if (data.stopPointSequences && Array.isArray(data.stopPointSequences)) {
            data.stopPointSequences.forEach(seq => {
                if (seq.stopPoint && Array.isArray(seq.stopPoint) && seq.stopPoint.length > 0) {
                    // Use destinationName for potentially cleaner termini names
                    const lastStop = seq.stopPoint[seq.stopPoint.length - 1]?.name;
                    const destName = seq.destinationName || lastStop; // Prefer destinationName
                    if (destName) termini.add(destName);
                     // Optionally add first stop too if needed, but destinationName is usually better
                     // const firstStop = seq.stopPoint[0]?.name;
                     // if (firstStop) termini.add(firstStop);
                }
            });
        }
        if (termini.size > 0) {
             const suggestedText = `# Suggested termini for Route ${routeId}:\n` + [...termini].join('\n');
             // Add suggestion to current content or replace? Let's prepend.
             textareaElement.value = suggestedText + (textareaElement.value ? '\n# ---\n' + textareaElement.value : '');
             statusSpanElement.textContent = 'Suggestions loaded.'; statusSpanElement.style.color = 'green';
        } else {
             statusSpanElement.textContent = 'No suggestions found.'; statusSpanElement.style.color = 'orange';
        }
    } catch (error) { console.error(`Error fetching termini for ${routeId}:`, error); statusSpanElement.textContent = `Error: ${error.message}`; statusSpanElement.style.color = 'red'; } finally { textareaElement.disabled = false; setTimeout(() => { if(statusSpanElement) statusSpanElement.textContent = ''; }, 4000); }
}
function saveAllFinalDestinations() {
    // Permission check done by updateElementRoles
    if (!destEditorRoutesContainer || !destEditorMessage) { return; } try { const routeSections = destEditorRoutesContainer.querySelectorAll('.dest-route-section'); const newSettingsToSave = {}; routeSections.forEach(section => { const routeId = section.dataset.routeid; const textarea = section.querySelector('textarea'); if (routeId && textarea) { const destinations = textarea.value.split('\n').map(line => line.replace(/#.*$/, '').trim()).filter(line => line.length > 0); if (destinations.length > 0) { newSettingsToSave[routeId] = destinations; } } }); saveToStorage(routeDestinationSettingsKey, newSettingsToSave); destEditorMessage.textContent = "Final destinations saved!"; destEditorMessage.style.color = "green"; console.log("Final destinations saved:", newSettingsToSave); filterDestSections(); /* Refresh filter state after save */ setTimeout(() => { if(destEditorMessage) destEditorMessage.textContent = ""; }, 3000); } catch (e) { console.error("Error saving final destinations:", e); destEditorMessage.textContent = "Error saving."; destEditorMessage.style.color = "red"; }
}
function processBulkInput() {
     // Permission check done by updateElementRoles
     if (!bulkDestInput || !bulkDestStatus || !destEditorRoutesContainer) return; const lines = bulkDestInput.value.split('\n'); let processedCount = 0; let errorCount = 0; bulkDestStatus.textContent = 'Processing...'; bulkDestStatus.style.color = 'orange'; const changes = {}; lines.forEach(line => { const cleanLine = line.replace(/#.*$/, '').trim(); if (!cleanLine) return; const parts = cleanLine.match(/^([A-Z0-9]+):\s*(.*)$/i); if (parts && parts.length === 3) { const routeId = parts[1].toUpperCase(); const destination = parts[2].trim(); if (destination) { if (!changes[routeId]) { changes[routeId] = []; } changes[routeId].push(destination); processedCount++; } else { console.warn(`Bulk input: Skipping empty destination for route ${routeId}`); errorCount++; } } else { console.warn(`Bulk input: Skipping invalid line format: "${line}"`); errorCount++; } }); if (processedCount === 0 && errorCount === 0) { bulkDestStatus.textContent = 'No valid input found.'; return; } Object.keys(changes).forEach(routeId => { let section = destEditorRoutesContainer.querySelector(`[data-routeid="${routeId}"]`); if (!section) { createRouteSectionElement(routeId, changes[routeId]); } else { const textarea = section.querySelector('textarea'); if (textarea) { textarea.value = changes[routeId].join('\n'); } } }); bulkDestStatus.textContent = `Processed ${processedCount} entries. ${errorCount > 0 ? `Skipped ${errorCount} invalid lines.` : ''} Scroll to review, then click 'Save All'.`; bulkDestStatus.style.color = errorCount > 0 ? 'orange' : 'green'; filterDestSections(); // Apply filter to potentially show new/edited sections
     bulkDestInput.value = ''; // Clear bulk input after processing
}
function setDestFilterState(state) {
     currentFinalDestFilter = state; destFilterButtons.forEach(btn => { btn.classList.toggle('active', btn.id === `filter-btn-${state}`); }); filterDestSections();
}

// --- Event Listeners ---
console.log("DEBUG: Adding event listeners.");
if (filterInput) { filterInput.addEventListener('input', displayOverrides); }
if(destFilterInput) { destFilterInput.addEventListener('input', filterDestSections); }
// Event listeners for dynamically added elements (checkboxes) handled via onchange attribute in HTML string

// --- Initial Load ---
document.addEventListener('DOMContentLoaded', () => {
    console.log("DEBUG: DOMContentLoaded event fired.");
    if (!document.getElementById('login-container') || !document.getElementById('app-container') || !document.getElementById('main-actions-container') || !document.getElementById('go-back-button')) {
         console.error("DEBUG: CRITICAL ERROR: Essential page containers or nav missing.");
         document.body.innerHTML = '<p style="color: red; font-weight: bold; padding: 20px;">Page loading error: Essential UI elements missing.</p>';
         return;
    }
    console.log("DEBUG: DOMContentLoaded - Calling checkLogin...");
    checkLogin();
    console.log("DEBUG: DOMContentLoaded - checkLogin finished.");
});

console.log('--- DEBUG: SCRIPT END REACHED (iBusDest with Sequence Heading List & Remove - loadTrackerSettings Fix) ---');    
</script>

</body>
</html>
