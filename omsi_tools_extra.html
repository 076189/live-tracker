<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMSI Tools - Extra Modules</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <link rel="manifest" href="/live-tracker/manifest-omsitoolsextra.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OMSI Extra Tools">
    <meta name="theme-color" content="#2c3e50">
    <link rel="apple-touch-icon" href="/live-tracker/assets/icons/apple-touch-icon-180x180.png">
    <style>
        @font-face {
            font-family: 'NJFont Medium Web';
            src: url('fonts/NJFont-Medium.ttf') format('truetype'); /* Relative path */
            font-weight: normal;font-style: normal;font-display: swap;
        }
        body {
            font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            margin:0;
        }
        .page-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }
        #top-menu-bar_extra {
            background-color: rgba(0,0,0,0.25); padding: 0.75rem; border-radius: 0.5rem;
            margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center; display: block; /* Changed from none for display without JS */
        }
        .menu-button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin: 0.25rem;
        }
        .menu-button:hover { background-color: #2980b9; }
        .tool-content-section {
            /* display: none; */ /* Commented out for static display; JS would handle this */
            display: block; /* Ensure sections are visible by default without JS */
            background-color: rgba(0,0,0,0.15); padding: 1.5rem;
            border-radius: 0.5rem; margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        #auth-section { /* Applied .section styles to auth-section */
             margin-bottom: 1.5rem; background-color: rgba(0,0,0,0.15); padding: 1.5rem;
             border-radius: 0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #current-profile-display-container {
            text-align: center; margin-bottom: 1.5rem; padding: 0.75rem;
            background-color: rgba(255,255,255,0.05); border-radius: 0.25rem; display: block; /* Changed for display */
        }
        #current-profile-display { font-size: 0.9rem; opacity: 1; font-style: normal; color: #FFFFFF;}
        h1 { font-size: 2rem; margin-bottom: 1.5rem; font-weight: normal; text-align: center; color: #ffffff; }
        h2 { font-size: 1.5rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: normal; border-bottom: 1px solid #7f8c8d; padding-bottom: 0.25rem;}
        h3.subsection-title { font-size: 1.25rem; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: normal; color: #e0e0e0; border-bottom: 1px solid rgba(127,140,141,0.5); padding-bottom: 0.2rem;}
        .subsection {
            background-color: rgba(0,0,0,0.1); padding: 1rem; border-radius: 0.375rem;
            margin-top: 1rem; margin-bottom: 1rem; border: 1px solid rgba(127,140,141,0.2);
        }
        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;}
        .form-field-group { margin-bottom: 1rem; }
        label { display: block; margin-bottom: 0.25rem; font-size: 0.85rem; color: #bdc3c7; }
        input[type="text"], input[type="email"], input[type="password"], input[type="time"],
        input[type="color"], input[type="number"], input[type="date"], input[type="datetime-local"],
        select, textarea {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e; color: #ecf0f1; font-size:0.9rem; box-sizing: border-box;
        }
        input[type="date"]::-webkit-calendar-picker-indicator,
        input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            filter: invert(0.8); cursor:pointer;
        }
        select option { background-color: #34495e; color: #ecf0f1; }
        .button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.5rem 0.8rem;
            border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin-right: 0.5rem; margin-top:0.5rem;
            display: inline-block;
            text-align: center;
            vertical-align: middle;
            box-sizing: border-box;
        }
        .button:hover { background-color: #2980b9; }
        .button.secondary { background-color: #e74c3c; }
        .button.secondary:hover { background-color: #c0392b; }
        .button.save { background-color: #27ae60; }
        .button.save:hover { background-color: #229954; }
        .button.tertiary { background-color: #f39c12; }
        .button.tertiary:hover { background-color: #e67e22; }
        .button.neutral { background-color: #7f8c8d; }
        .button.neutral:hover { background-color: #95a5a6; color: #2c3e50; }
        .button.small-action { padding: 0.2rem 0.4rem; font-size: 0.8rem; margin: 0 0.15rem; line-height: 1; min-width: 20px; text-align:center; font-weight: bold;}

        .schedule-generator-input { /* Used by RSG and Day Profile Override */
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e; color: #ecf0f1; font-size: 0.9rem;
        }

        /* Master Stop List Styles */
        #masterStopListUL_extra li.master-stop-list-item {
            display: grid;
            grid-template-columns: 2.5fr 1.5fr 1fr; /* Adjust if needed */
            gap: 1rem; padding: 0.75rem 0.5rem;
            border-bottom: 1px solid #34495e;
            transition: background-color 0.15s ease-in-out; align-items: start;
        }
        #masterStopListUL_extra li.master-stop-list-item:last-child { border-bottom: none; }
        .master-stop-original-info .stop-name-master { font-weight: bold; color: #ecf0f1; font-size: 1.05em; }
        .master-stop-original-info .stop-direction-master { font-size: 0.85em; color: #95a5a6; margin-bottom: 0.3rem; }
        .master-stop-original-info .stop-id-master { font-weight: normal; color: #bdc3c7; font-size: 0.95em; }
        .master-stop-original-info .stop-details-grid { display: grid; grid-template-columns: auto 1fr; gap: 0.2rem 0.8rem; font-size: 0.85em; margin-top: 0.4rem; }
        .master-stop-original-info .detail-label { font-weight: normal; color: #bdc3c7; opacity: 0.8; }
        .master-stop-original-info .detail-value { color: #ecf0f1; }
        .master-stop-original-info .detail-value.status-closed { color: #e74c3c; font-weight: bold; }
        .master-stop-original-info .detail-value.status-open { color: #2ecc71; }
        .master-stop-original-info .serving-routes-container { margin-top: 0.4rem; margin-bottom: 0.2rem; display: flex; flex-wrap: wrap; gap: 0.3em; padding: 0.25rem 0;}
        .master-stop-new-id-section label { font-size: 0.8em; display: block; margin-bottom: 0.2em; color: #bdc3c7; }
        .master-list-new-id-input { margin-bottom: 0.25rem; }
        .master-list-row-warning { font-size: 0.8em; color: #f39c12; min-height: 1.2em; margin-top: 0.25rem; }
        .master-stop-actions { margin-top: 0rem; padding-top: 0rem; border-top: none; display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-start; }
        .master-stop-actions .button { width: 100%; margin: 0; }
        .route-tile-tools-list {
            display: inline-block; padding: 0.2em 0.55em; margin-right: 0.3em; margin-bottom: 0.3em;
            border-radius: 0.25rem; font-size: 0.8em; font-weight: bold; color: white;
            text-align: center; line-height: 1.3; min-width: 28px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.25); vertical-align: middle;
        }
        #newStopIdAvailability_extra { font-size: 0.8em; min-height: 1.1em; margin-top: 0.25rem; }

        /* Selectable Route Tiles for Global Deletion & RPD Profile Tiles */
        .selectable-route-tile-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
            padding: 0.25rem 0;
        }
        .selectable-route-tile {
            display: inline-block;
            padding: 0.4em 0.8em;
            border-radius: 0.25rem;
            font-size: 0.9em;
            font-weight: bold;
            text-align: center;
            line-height: 1.4;
            min-width: 40px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .selectable-route-tile:hover {
            transform: translateY(-1px);
        }
        .selectable-route-tile.selected { /* JS will toggle this class */
            border-color: #f1c40f !important; /* Yellow border for selected */
            box-shadow: 0 0 8px 1px #f1c40f !important;
        }

        /* Styles for duplicate stop name/direction results */
        #duplicateStopsByNameDirResults_extra ul { list-style: none; padding-left: 0; }
        #duplicateStopsByNameDirResults_extra li { margin-bottom: 0rem; }
        .duplicate-set-to-merge {
            border: 1px solid #4a5568;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            border-radius: 0.25rem;
            background-color: rgba(0,0,0,0.05);
        }
        .duplicate-set-to-merge p { margin-bottom: 0.35rem; }
        .duplicate-set-to-merge .stop-id-options label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.9em;
            cursor: pointer;
        }
         .duplicate-set-to-merge .stop-id-options input[type="radio"] {
            margin-right: 0.35em;
            vertical-align: middle;
        }

        /* --- START: Route Schedule Generator Styles --- */
        #rsg-stop-sequence-list-extra li {
            display: flex;
            flex-direction: column;
            padding: 0.6rem 0.5rem;
            border-bottom: 1px solid #4A5568;
            background-color: rgba(255,255,255,0.03);
            cursor: grab;
        }
        #rsg-stop-sequence-list-extra li:active {
            cursor: grabbing;
            background-color: rgba(255,255,255,0.07);
        }
        #rsg-stop-sequence-list-extra li.rsg-dragging-placeholder {
            opacity: 0.5;
            background-color: #567a9a;
            border: 1px dashed #ecf0f1;
        }
        #rsg-stop-sequence-list-extra li:last-child {
            border-bottom: none;
        }

        .rsg-li-main-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        #rsg-stop-sequence-list-extra .rsg-stop-info {
            flex-grow: 1;
            margin-right: 1rem;
        }
        #rsg-stop-sequence-list-extra .rsg-stop-name {
            font-weight: bold;
        }
        #rsg-stop-sequence-list-extra .rsg-stop-id {
            font-size: 0.85em; color: #bdc3c7; margin-left: 0.5em;
        }
        #rsg-stop-sequence-list-extra .rsg-stop-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        #rsg-stop-sequence-list-extra .rsg-stop-actions button {
            padding: 0.15rem 0.35rem;
            font-size: 0.75rem;
            line-height: 1;
        }
        #rsg-stop-sequence-list-extra .rsg-time-adjustment-input {
            width: 70px;
            padding: 0.25rem;
            font-size: 0.85em;
            text-align: center;
        }

        .rsg-copy-adjustment-buttons-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            margin-top: 0.5rem;
            align-items: center;
            width: 100%;
            padding-top: 0.3rem;
            border-top: 1px solid rgba(127,140,141,0.15);
        }
        .rsg-copy-adjustment-buttons-container .button.copy-adj-button {
            font-size: 0.7em;
            padding: 0.2em 0.5em;
            line-height: 1.3;
            white-space: nowrap;
            margin: 0;
            background-color: #546E7A;
            color: white;
        }
        .rsg-copy-adjustment-buttons-container .button.copy-adj-button:hover {
            background-color: #607D8B;
        }

        #rsg-selectable-profiles-container-extra label { /* For labels around profile checkboxes */
            color: #ecf0f1;
            font-size: 0.85em;
            cursor: pointer;
            margin-right: 0.5rem; /* Space out profile options */
        }
        #rsg-selectable-profiles-container-extra input[type="checkbox"] {
            margin-right: 5px;
            vertical-align: middle;
        }
        /* --- END: Route Schedule Generator Styles --- */

        #rsg-stop-search-results-extra {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            background-color: #34495e;
            margin-top: 0.25rem;
        }
        #rsg-stop-search-results-extra .rsg-search-result-item {
            padding: 0.5rem 0.6rem;
            cursor: pointer;
            border-bottom: 1px solid #2c3e50;
        }
        #rsg-stop-search-results-extra .rsg-search-result-item:last-child {
            border-bottom: none;
        }
        #rsg-stop-search-results-extra .rsg-search-result-item:hover {
            background-color: #4a6a80;
        }
        #rsg-stop-search-results-extra .rsg-search-stop-name {
            font-weight: bold; display: block;
        }
        #rsg-stop-search-results-extra .rsg-search-stop-details {
            font-size: 0.8em; color: #bdc3c7; display: block; margin-top:0.1em;
        }
        #rsg-stop-search-results-extra .rsg-search-serving-routes {
            margin-top: 0.3em;
        }

        .sr-only { /* For accessibility, used with checkboxes in RSG profiles */
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        .rpd-profile-tile { /* For Route Profile Deletion tiles */
            background-color: #4A5568;
            color: white;
        }

        /* Styles for RSG Modals (Save Config, DateTime, CopyFrom) */
        .rsg-modal {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 1050;
            display: flex; /* Will be controlled by JS to 'none' or 'flex' */
            justify-content: center;
            align-items: center;
        }

        .rsg-modal-content {
            background: linear-gradient(145deg, #3a506b, #2c3e50);
            color: #ecf0f1;
            padding: 20px 25px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            border: 1px solid #4a6a80;
        }

        .rsg-modal-content h4 {
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1.3em;
            color: #ffffff;
            border-bottom: 1px solid #567a9a;
            padding-bottom: 0.5rem;
        }

        .rsg-modal-content .form-field-group {
            margin-bottom: 1rem;
        }
        .rsg-modal-content label {
            font-size: 0.9em;
        }
        .rsg-modal-content input.schedule-generator-input {
            background-color: #2c3e50;
            border-color: #567a9a;
        }

        .rsg-modal-actions {
            margin-top: 1.5rem;
            text-align: right;
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
        .rsg-modal-actions .button {
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div class="page-container">
        <h1>OMSI Tools - Extra Modules</h1>
<div id="global-notification-banner" style="display: none; padding: 12px 15px; background-color: #27ae60; /* Green */ color: white; text-align: center; position: sticky; top: 0; left: 0; width: 100%; z-index: 1060; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
    </div>

        <div id="auth-section" class="section">
            <h2>Admin Login</h2>
            <div id="login-form-container_extra">
                <form id="adminLoginForm_extra">
                    <div class="form-grid" style="grid-template-columns: 1fr;">
                        <div><label for="inputEmail_extra">Email</label><input type="email" id="inputEmail_extra" autocomplete="email"></div>
                        <div><label for="inputPassword_extra">Password</label><input type="password" id="inputPassword_extra" autocomplete="current-password"></div>
                    </div>
                    <button id="loginButton_extra" type="submit" class="button">Login</button>
                </form>
                <p id="auth-status_extra" style="margin-top: 0.5em; color: #f1c40f;"></p>
            </div>
            <div id="logout-container_extra" style="display:none;">
                <p>Logged in as: <span id="loggedInUserEmail_extra"></span></p>
                <button id="logoutButton_extra" class="button secondary">Logout</button>
            </div>
        </div>

        <div id="current-profile-display-container" style="display:block;"> <p id="current-profile-display">Today's Operating Profile: (loading...)</p>
        </div>

        <div id="top-menu-bar_extra" style="display:block;"> <div id="main-menu-buttons_extra">
                <button class="menu-button" data-section="day-profile-override-section_extra">Day Profile Override</button>
                <button class="menu-button" data-section="stop-manager-tool-section_extra">Stop Management & Creation</button>
                <button class="menu-button" data-section="global-route-deletion-section_extra">Global Route Deletion</button>
                <button class="menu-button" data-section="route-schedule-generator-section_extra">Route Schedule Generator</button>
                <button class="menu-button" data-section="route-profile-deletion-section_extra">Route Profile Deletion</button>
                <button class="menu-button" data-section="service-analyzer-section_extra">Service Analyzer</button>
                <button class="menu-button" data-section="timetable-exporter-section_extra">Timetable Exporter</button>
                <button class="menu-button" data-section="scheduled-route-updates-section_extra">Scheduled Tasks</button>
                <button class="menu-button" data-section="scheduled-route-deletion-section_extra">Schedule Route Deletion</button>
            </div>
        </div>

        <div id="tool-sections-wrapper_extra">

            <div id="timetable-exporter-section_extra" class="tool-content-section section">
                <h2>Route Timetable Exporter</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Select a route to download its full timetable as a PDF file.</p>
                <div class="subsection">
                    <h3 class="subsection-title">Select Route</h3>
                    <div class="form-grid" style="grid-template-columns: 3fr 1fr; align-items: end;">
                        <div>
                            <label for="tte-routeName-select-extra">Route Name (Select or Type):</label>
                            <select id="tte-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Route --</option>
                            </select>
                            <input type="text" id="tte-routeName-input-extra" class="schedule-generator-input" placeholder="Or Type Route Name">
                        </div>
                        <div>
                            <button id="tte-downloadTimetable-button-extra" class="button save" style="width:100%;">Download Timetable</button>
                        </div>
                    </div>
                    <p id="tte-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
                </div>
            </div>

            <div id="service-analyzer-section_extra" class="tool-content-section section">
                <h2>Service Analyzer</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity:0.8;">
                    Analyze stop coverage and view all routes serving a stop.
                </p>
                <div class="form-grid" style="grid-template-columns: 2fr 1fr; align-items: end;">
                    <div>
                        <label for="service-analyzer-stop-select-extra">Stop Name/ID (Select or Type):</label>
                        <select id="service-analyzer-stop-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                            <option value="">-- Select Stop --</option>
                        </select>
                        <input type="text" id="service-analyzer-stop-input-extra" class="schedule-generator-input" placeholder="Or Type Stop Name/ID">
                    </div>
                </div>
                <div id="service-analyzer-stop-summary-extra" style="margin-top:1rem; min-height:3em; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border: 1px solid rgba(127,140,141,0.2);">Select a stop to analyze.</div>
            </div>

            <div id="day-profile-override-section_extra" class="tool-content-section section">
                <h2>Operational Day Profile Override</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Use this tool to manually set a specific operating profile for an upcoming date...
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">Select Date and Override Profile</h3>
                    <div class="form-grid" style="grid-template-columns: 1fr; gap: 1rem;">
                        <div>
                            <label for="overrideDate_extra">Date to Override:</label>
                            <input type="date" id="overrideDate_extra" class="schedule-generator-input">
                        </div>
                        <div class="form-field-group">
                            <label>Operating Profile(s) (select one or more):</label>
                            <div id="dpo-selectable-profiles-container-extra" class="selectable-route-tile-container" style="background-color: rgba(0,0,0,0.05); padding: 0.5rem; border-radius: 0.25rem; min-height:30px;">
                                <p id="dpo-profiles-placeholder-extra" style="font-size:0.85em; opacity:0.7;">Loading profiles...</p>
                            </div>
                            <div style="margin-top:0.25rem; display:flex; justify-content:space-between; align-items:center;">
                                <span style="font-size:0.8em;">Selected Override Profile: <strong id="dpo-selected-profiles-display-extra" style="color:#f1c40f;">(None selected)</strong></span>
                                <button id="dpo-clear-profile-checkboxes-button-extra" class="button small-action neutral">Clear Sel.</button>
                            </div>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem;">
                            <button id="setOverrideButton_extra" class="button save">Set Override for Date</button>
                            <button id="clearOverrideButton_extra" class="button secondary" style="display:none;">Clear Override for Date</button>
                        </div>
                        <div style="grid-column: 1 / -1; margin-top: 0.5rem; font-size: 0.85em;">
                            <p><strong>Selected Date:</strong> <span id="selectedDateDisplay_extra">(select a date)</span></p>
                            <p><strong>Auto Profile for Date:</strong> <span id="autoProfileForSelectedDate_extra">(select a date)</span></p>
                            <p><strong>Current Override for Date:</strong> <span id="currentOverrideForSelectedDate_extra" style="font-weight:bold;">(select a date)</span></p>
                            <p id="overrideStatusMessage_extra" style="min-height:1.2em; margin-top: 0.5rem; font-weight:bold;"></p>
                        </div>
                    </div>
                    </div>
                <div class="subsection" style="margin-top: 2rem;">
                    <h3 class="subsection-title">Currently Active Overrides (Next 30 Days)</h3>
                    <div id="activeOverridesList_extra" style="max-height: 200px; overflow-y: auto; background-color: rgba(0,0,0,0.05); padding: 0.5rem; border-radius: 0.25rem;">
                        <p>Loading active overrides...</p>
                    </div>
                </div>
            </div>

            <div id="stop-manager-tool-section_extra" class="tool-content-section section">
                 <h2>Stop Management & Creation (Live Updates)</h2>
                 <div class="subsection">
                    <h3 class="subsection-title">Add New Stop Definition (Placeholder)</h3>
                    <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); align-items: end;">
                        <div>
                            <label for="inputNewStopName_extra">Stop Name:</label>
                            <input type="text" id="inputNewStopName_extra" class="schedule-generator-input" placeholder="e.g., High Street / Central Avenue">
                        </div>
                        <div>
                            <label for="selectNewStopIdFormat_extra">ID Format Suggestion:</label>
                            <select id="selectNewStopIdFormat_extra" class="schedule-generator-input">
                                <option value="NUM">Numeric (e.g., 101)</option>
                                <option value="BP">Bus Point (e.g., BP123)</option>
                                <option value="LE">Location E (e.g., LE45)</option>
                                <option value="RO">Route Objective (e.g., RO67)</option>
                                <option value="Custom">Custom (type below)</option>
                            </select>
                        </div>
                        <div>
                            <label for="inputNewStopId_extra">New Stop ID (Uppercase Alphanumeric):</label>
                            <input type="text" id="inputNewStopId_extra" class="schedule-generator-input" placeholder="Auto-suggest or type custom">
                            <div id="newStopIdAvailability_extra"></div>
                        </div>
                         <div>
                            <label for="inputNewStopDirection_extra">"Towards" Text (Optional):</label>
                            <input type="text" id="inputNewStopDirection_extra" class="schedule-generator-input" placeholder="e.g., Town Centre">
                        </div>
                        <div style="padding-bottom:0.05rem;">
                            <button id="buttonAddNewStop_extra" class="button save">Add Stop Definition</button>
                        </div>
                    </div>
                    <p id="addNewStopStatus_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Bulk Add Stop Definitions (Replaces ALL Existing Stops/Schedules)</h3>
                     <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        <strong>DANGER ZONE:</strong> Uploading an Excel (.xlsx) file here will <strong>DELETE ALL current schedules and stop definitions</strong> from Firebase and replace them with placeholder entries derived from the uploaded file.
                        The Excel file should have columns (no headers needed in file): UserProvidedStopID (optional), StopName (required if ID not provided), Direction (optional), LineName(s) (comma-separated, optional, defaults to "INFO_ONLY").
                    </p>
                    <input type="file" id="fileInputBulkAddStops_extra" accept=".xlsx" style="display:none;">
                    <label for="fileInputBulkAddStops_extra" class="button neutral">Choose Excel File (.xlsx)</label>
                    <span id="fileNameBulkAddStops_extra" style="margin-left:10px; font-size:0.9em;">No file selected.</span>
                    <button id="buttonBulkAddNewStops_extra" class="button secondary" style="margin-top:0.75rem;">Bulk Replace All Data With Excel Definitions</button>
                    <p id="bulkAddNewStopsStatus_extra" style="min-height:1.2em; margin-top:0.5rem; white-space:pre-wrap;"></p>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Master Stop List & Actions (Live Data)</h3>
                    <div class="form-field-group">
                        <label for="masterStopListFilterInput_extra">Filter Stops (by ID, Name, Direction, Route, Status):</label>
                        <input type="text" id="masterStopListFilterInput_extra" class="schedule-generator-input" placeholder="Type to filter...">
                    </div>
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
                        <button id="refreshMasterStopListButton_extra" class="button neutral">Refresh List</button>
                        <button id="exportUniqueStopsButton_extra" class="button" style="background-color: #16a085;">Export Stops to Excel</button>
                    </div>
                    <p id="masterStopListStatus_extra" style="min-height:1.2em; margin-bottom:0.5rem; font-size:0.9em;"></p>
                    <ul id="masterStopListUL_extra" style="max-height: 500px; overflow-y: auto; border: 1px solid #4A5568; padding: 0; list-style:none; border-radius:0.25rem;">
                        <p style="text-align:center; padding:1rem; opacity:0.7;">Loading stops...</p>
                    </ul>
                    <button id="applyMasterListStopIdChangesButton_extra" class="button save" style="margin-top:1rem;">Apply All Proposed Stop ID Changes (Bulk)</button>
                    <p id="masterListApplyChangesStatus_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Stop Name/Direction Duplicate Management</h3>
                    <button id="findDuplicateStopsByNameDirButton_extra" class="button tertiary">Find Duplicates (Name/Dir)</button>
                    <div id="duplicateStopsByNameDirResults_extra" style="margin-top:0.75rem;">
                        <p>Click button above to scan for stops with identical names and directions but different StopIDs.</p>
                    </div>
                </div>
            </div>

            <div id="global-route-deletion-section_extra" class="tool-content-section section">
                <h2>Global Route Deletion (Live)</h2>
                <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                    Click on route tiles below to select them for deletion. This action deletes ALL data for the selected route(s) from the live schedule, including global and stop-specific color settings. This is irreversible.
                </p>
                <div class="form-field-group">
                    <label style="display:block; margin-bottom:0.5rem;">Select Route(s) to Delete Globally by clicking tiles:</label>
                    <div id="globalRouteDeletionListContainer_el_extra" class="subsection" style="max-height: 300px; overflow-y: auto; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border: 1px solid rgba(127,140,141,0.2);">
                        <p>Loading routes...</p>
                    </div>
                </div>
                <button id="deleteEntireRouteButton_el_extra" class="button secondary" style="margin-top: 0.5rem;">Delete Selected Route(s) (Live)</button>
                <p id="deleteEntireRouteStatusMessage_el_extra" style="min-height:1.2em; margin-top:0.75rem;"></p>
            </div>

            <div id="route-profile-deletion-section_extra" class="tool-content-section section">
                <h2>Selective Route Profile Deletion</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Select a route, optionally a specific destination, and then one or more operating profiles to delete all associated schedule entries from the live Firebase data.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">1. Select Route & Destination (Optional)</h3>
                    <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));">
                        <div>
                            <label for="rpd-route-name-select-extra">Route Name (Select or Type):</label>
                            <select id="rpd-route-name-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Existing Route --</option>
                            </select>
                            <input type="text" id="rpd-route-name-input-extra" class="schedule-generator-input" placeholder="e.g., 4X or type new">
                        </div>
                        <div>
                            <label for="rpd-destination-name-select-extra">Destination (Optional - Select or Type):</label>
                            <div style="display:flex; align-items: center; gap: 0.5rem;">
                                <select id="rpd-destination-name-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem; flex-grow:1;">
                                    <option value="">-- Optional: All Destinations --</option>
                                </select>
                                <button id="rpd-clear-destination-button-extra" class="button small-action neutral" title="Clear Destination Filter" style="display:none;">âœ•</button>
                            </div>
                            <input type="text" id="rpd-destination-name-input-extra" class="schedule-generator-input" placeholder="Leave blank for all destinations">
                        </div>
                    </div>
                </div>
                <div class="subsection">
                    <h3 class="subsection-title">2. Select Profile(s) to Delete for this Route/Destination</h3>
                    <div id="rpd-profile-list-container-extra" style="min-height: 50px; padding:0.5rem; background-color: rgba(0,0,0,0.05); border-radius:0.25rem; border:1px solid #4A5568;">
                        <p style="font-size:0.85em; opacity:0.7;">Select a route (and optionally destination) above.</p>
                    </div>
                </div>
                <div class="subsection">
                     <h3 class="subsection-title">3. Execute Deletion</h3>
                    <button id="rpd-delete-profiles-button-extra" class="button secondary">Delete Selected Profile(s) for Route/Destination</button>
                    <p id="rpd-status-message-extra" style="min-height:1.2em; margin-top: 0.75rem; font-weight:bold;"></p>
                </div>
            </div>

            <div id="route-schedule-generator-section_extra" class="tool-content-section section">
                <h2>Route Schedule Generator</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity:0.8;">
                    Define a route, its operating profile(s), primary destination, a sequence of stops with inter-stop timings, and departure times for the first stop. Then generate, preview, and add the full schedule to the main working schedule or schedule it for a future go-live.
                </p>

                <div>
                    <div class="subsection">
                        <h3 class="subsection-title">1. Route, Profile & Destination</h3>
                        <div class="form-field-group">
                            <label for="rsg-routeName-select-extra">Route Name (Select or Type):</label>
                            <select id="rsg-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Existing Route --</option>
                            </select>
                            <input type="text" id="rsg-routeName-input-extra" class="schedule-generator-input" placeholder="e.g., 4X or type new">
                        </div>
                        <div class="form-field-group">
                            <label>Operating Profile(s) (select one or more):</label>
                            <div id="rsg-selectable-profiles-container-extra" class="selectable-route-tile-container" style="background-color: rgba(0,0,0,0.05); padding: 0.5rem; border-radius: 0.25rem; min-height:30px;">
                                <p id="rsg-profiles-placeholder-extra" style="font-size:0.85em; opacity:0.7;">Loading profiles...</p>
                            </div>
                            <div style="margin-top:0.25rem; display:flex; justify-content:space-between; align-items:center;">
                                <span style="font-size:0.8em;">Currently Selected: <strong id="rsg-selected-profiles-display-extra" style="color:#f1c40f;">(None selected)</strong></span>
                                <button id="rsg-clear-profile-checkboxes-button-extra" class="button small-action neutral">Clear Sel.</button>
                            </div>
                        </div>
                        <div class="form-field-group">
                            <label for="rsg-destinationName-select-extra">Primary Destination (Select or Type):</label>
                            <select id="rsg-destinationName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Existing Destination --</option>
                            </select>
                            <input type="text" id="rsg-destinationName-input-extra" class="schedule-generator-input" placeholder="e.g., City Centre or type new">
                        </div>
                    </div>

                    <div class="subsection">
                        <h3 class="subsection-title">2. Stop Sequence & Timings</h3>
                        <div class="form-field-group">
                            <label for="rsg-stop-search-input-extra">Add Stop to Sequence (Search by Name/ID):</label>
                            <input type="text" id="rsg-stop-search-input-extra" class="schedule-generator-input" placeholder="Type to search stops...">
                            <div id="rsg-stop-search-results-extra"></div>
                        </div>
                        <div class="form-field-group" style="margin-top: 0.75rem; margin-bottom: 0.75rem;">
                            <button id="rsg-open-copy-modal-button-extra" class="button neutral" style="width:100%;">Copy Stop Sequence From Route</button>
                        </div>
                        <div class="form-field-group">
                            <label>Current Stop Sequence (Drag to reorder):</label>
                            <ul id="rsg-stop-sequence-list-extra" style="border: 1px solid #4A5568; padding: 0.5rem; border-radius: 0.25rem; background-color: rgba(0,0,0,0.05);">
                                <p id="rsg-stop-sequence-placeholder-extra" style="text-align:center; opacity:0.7; padding:1rem;">Search and add stops above.</p>
                            </ul>
                        </div>
                        <div id="rsg-first-stop-times-container-extra" class="form-field-group" style="display:none;">
                            <label for="rsg-first-stop-times-input-extra">Departure Times for First Stop (HH:MM, TAB separated):</label>
                            <textarea id="rsg-first-stop-times-input-extra" class="schedule-generator-input" rows="2" placeholder="e.g., 07:00	07:15	07:30 (use Tab to separate)"></textarea>
                        </div>
                    </div> <div id="rsg-schedule-preview-container-extra" class="subsection" style="margin-top:1.5rem; display:none;">
                        <h3 class="subsection-title">Schedule Preview</h3>
                        <div style="max-height: 400px; overflow-y: auto;">
                            <table id="rsg-preview-table-extra" style="width:100%; border-collapse:collapse; font-size:0.85em;">
                                <thead>
                                    <tr style="background-color:#34495e;">
                                        <th style="padding:5px; border:1px solid #4A5568;">StopID</th>
                                        <th style="padding:5px; border:1px solid #4A5568;">StopName</th>
                                        <th style="padding:5px; border:1px solid #4A5568;">Time</th>
                                        <th style="padding:5px; border:1px solid #4A5568;">Route</th>
                                        <th style="padding:5px; border:1px solid #4A5568;">Dest</th>
                                        <th style="padding:5px; border:1px solid #4A5568;">Profile</th>
                                        <th style="padding:5px; border:1px solid #4A5568;">Offset</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="subsection"> <h3 class="subsection-title">3. Actions & Configurations</h3>
                        <div class="form-field-group" style="display: flex; margin-bottom: 0.5rem;">
                            <button id="rsg-generate-schedule-button-extra" class="button" style="flex: 1; margin-right: 0.25rem;">Generate Schedule Preview</button>
                            <button id="rsg-schedule-this-config-button-extra" class="button tertiary" style="flex: 1; margin-left: 0.25rem;">Schedule This Configuration</button>
                        </div>
                        <div class="form-field-group" style="display: flex; margin-bottom: 0.5rem;">
                            <button id="rsg-save-configuration-button-extra" class="button" style="flex: 1; margin-right: 0.25rem;">Save Current Setup</button>
                            <button id="rsg-add-to-working-schedule-button-extra" class="button neutral" style="flex: 1; margin-left: 0.25rem;" disabled>Add Preview to Working Schedule (Live)</button>
                        </div>
                        <div class="form-field-group" style="margin-top: 1rem;">
                             <label>Saved Configurations (click to load):</label>
                             <div id="rsg-saved-configs-list-extra" style="border: 1px solid #4A5568; padding:0.25rem 0.5rem; border-radius: 0.25rem; background-color: rgba(0,0,0,0.05);">
                                <p id="rsg-no-saved-configs-message-extra" style="padding:0.5em; text-align:center; opacity:0.7;">Loading saved configurations...</p>
                             </div>
                             <p id="rsg-load-status-message-extra" style="font-size:0.8em; min-height:1.1em; margin-top:0.25rem;"></p>
                        </div>
                    </div>
                </div>

                <p id="rsg-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold; text-align:center;"></p>
                </div>

            <div id="scheduled-route-deletion-section_extra" class="tool-content-section section">
                <h2>Schedule Route Deletion</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Select a route and a future date/time to schedule its complete deletion from the live schedule and associated settings.
                    The deletion will need to be manually confirmed or processed from the "Scheduled Tasks" list when due.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">Select Route and Go-Live Time</h3>
                    <div class="form-grid" style="grid-template-columns: 2fr 1.5fr 1fr; align-items: end;">
                        <div>
                            <label for="srd-routeName-select-extra">Route Name (Select or Type):</label>
                            <select id="srd-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Route --</option>
                            </select>
                            <input type="text" id="srd-routeName-input-extra" class="schedule-generator-input" placeholder="Or Type Route Name">
                        </div>
                        <div>
                            <label for="srd-go-live-datetime-input-extra">Deletion Go-Live Date and Time:</label>
                            <input type="datetime-local" id="srd-go-live-datetime-input-extra" class="schedule-generator-input">
                        </div>
                        <div>
                            <button id="srd-schedule-deletion-button-extra" class="button secondary" style="width:100%;">Schedule Deletion</button>
                        </div>
                    </div>
                    <p id="srd-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
                </div>
            </div>

            <div id="scheduled-route-updates-section_extra" class="tool-content-section section">
                <h2>Scheduled Tasks</h2> <p style="font-size:0.9em; margin-bottom:1.5em; opacity:0.8;">
                    View and manage route timetables and deletions scheduled to go live automatically.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">Pending & Recent Scheduled Tasks</h3>
                    <button id="sru-refresh-list-button-extra" class="button neutral" style="margin-bottom:0.75rem;">Refresh List</button>
                    <div id="sru-updates-list-container-extra" style="background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border:1px solid rgba(127,140,141,0.2);">
                        <p>Loading scheduled tasks...</p>
                    </div>
                </div>
            </div>

        </div> </div>

        <div id="rsg-save-config-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content">
                <h4 style="margin-top:0;">Save Configuration As</h4>
                <div class="form-field-group">
                    <label for="rsg-config-name-input-extra">Configuration Name:</label>
                    <input type="text" id="rsg-config-name-input-extra" class="schedule-generator-input" placeholder="e.g., 4_Skippingdale_MFSch">
                </div>
                <div class="rsg-modal-actions">
                    <button id="rsg-save-config-confirm-button-extra" class="button save">Save</button>
                    <button id="rsg-save-config-cancel-button-extra" class="button neutral">Cancel</button>
                </div>
                <p id="rsg-save-config-modal-status-extra" style="min-height:1.2em; margin-top:0.75em; font-size:0.85em;"></p>
            </div>
        </div>

        <div id="rsg-copy-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content" style="max-width: 550px;">
                <h3 class="subsection-title" style="margin-top:0; padding-bottom: 0.5rem; border-color: #567a9a;">Copy Stops From Source</h3>
                <div class="form-field-group">
                    <label for="rsg-copy-source-routeName-select-extra">Source Route (Select or Type):</label>
                     <select id="rsg-copy-source-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                        <option value="">-- Select Source Route --</option>
                    </select>
                    <input type="text" id="rsg-copy-source-routeName-input-extra" class="schedule-generator-input" placeholder="e.g., 10 or type new">
                </div>
                <div class="form-field-group">
                    <label for="rsg-copy-source-operatingProfile-input-extra">Source Operating Profile:</label>
                    <input type="text" id="rsg-copy-source-operatingProfile-input-extra" class="schedule-generator-input" placeholder="e.g., MFSch">
                </div>
                <div class="form-field-group">
                     <label for="rsg-copy-source-destinationName-select-extra">Source Destination (Select or Type):</label>
                     <select id="rsg-copy-source-destinationName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                        <option value="">-- Select Source Destination --</option>
                    </select>
                    <input type="text" id="rsg-copy-source-destinationName-input-extra" class="schedule-generator-input" placeholder="e.g., Hospital or type new">
                </div>
                <p id="rsg-copy-modal-status-extra" style="min-height:1.2em; margin-top:0.5em; font-size:0.85em;"></p>
                <div class="rsg-modal-actions">
                    <button id="rsg-copy-modal-action-button-extra" class="button save">Copy Data</button>
                    <button id="rsg-copy-modal-cancel-button-extra" class="button neutral">Cancel</button>
                </div>
            </div>
        </div>

        <div id="rsg-schedule-datetime-modal-extra" class="rsg-modal" style="display:none;">
            <div class="rsg-modal-content">
                <h4 style="margin-top:0;">Set Go-Live Date & Time</h4>
                 <div class="form-field-group">
                    <label for="rsg-go-live-datetime-input-extra">Scheduled Go-Live Date and Time:</label>
                    <input type="datetime-local" id="rsg-go-live-datetime-input-extra" class="schedule-generator-input">
                </div>
                <div class="rsg-modal-actions">
                    <button id="rsg-schedule-datetime-confirm-button-extra" class="button save">Confirm Schedule</button>
                    <button id="rsg-schedule-datetime-cancel-button-extra" class="button neutral">Cancel</button>
                </div>
                <p id="rsg-schedule-datetime-modal-status-extra" style="min-height:1.2em; margin-top:0.75em; font-size:0.85em;"></p>
            </div>
        </div>

    </div>
<script type="module">
      // Firebase App initialization (content unchanged)
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s", // Replace with your actual Firebase API Key
        authDomain: "omsi-c5505.firebaseapp.com", // Replace with your actual Firebase Auth Domain
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app", // Replace with your actual Firebase Database URL
        projectId: "omsi-c5505", // Replace with your actual Firebase Project ID
        storageBucket: "omsi-c5505.appspot.com", // Replace with your actual Firebase Storage Bucket
        messagingSenderId: "503595375440", // Replace with your actual Firebase Messaging Sender ID
        appId: "1:503595375440:web:356be6684b77ff5909ea55", // Replace with your actual Firebase App ID
        measurementId: "G-VN7X65V3F9" // Replace with your actual Firebase Measurement ID
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);

      window.firebaseOMSI = {
          database: database, auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut
      };
      document.dispatchEvent(new CustomEvent('firebaseReady', { detail: window.firebaseOMSI }));
    </script>

<script>
// --- Global State Variables ---
        let rsg_configKeyToRename_extra = null;
        let currentUser_extra = null;
        let pageSpecificSettings = {};
        let rsg_currentlyEditingConfigKey_extra = null;
        let rsg_currentlyEditingConfigDisplayName_extra = null;
        let rsg_isDirty = false;
        let scheduledRouteDeletions_extra = {};
        let stopToServingRoutesMap_extra = new Map();
        let ukBankHolidaysData_extra = { dates: [], titles: {} };
        const schoolHolidayDateRanges_extra = [
    { start: '2025-05-24', end: '2025-06-01' }, // Summer half term 2025
    { start: '2025-07-19', end: '2025-09-02' }, // Summer holidays 2025
    { start: '2025-10-25', end: '2025-11-02' }, // Autumn half term 2025
    { start: '2025-12-20', end: '2026-01-04' }, // Christmas 2025/26
    { start: '2026-02-14', end: '2026-02-22' }, // Spring half term 2026
    { start: '2026-04-03', end: '2026-04-20' }, // Easter 2026
    { start: '2026-05-23', end: '2026-05-31' }, // Summer half term 2026
    { start: '2026-07-18', end: '2026-09-02' }, // Summer holidays 2026
    { start: '2026-10-24', end: '2026-11-01' }, // Autumn half term 2026
    { start: '2026-12-19', end: '2027-01-04' }, // Christmas 2026/27
    { start: '2027-02-13', end: '2027-02-21' }, // Spring half term 2027
    { start: '2027-03-26', end: '2027-04-13' }, // Easter 2027
    { start: '2027-05-29', end: '2027-06-06' }, // Summer half term 2027
    { start: '2027-07-22', end: '2027-08-31' }  // Summer holidays 2027 (END DATE TBC)
];
        let currentWorkingSchedule_extra = []; // This will be populated by flattening the new structure on load
        let closedStopIDs_extra = [];
        let globalCustomRouteColours_extra = {};
        let stopSpecificRouteColours_extra = {};
        let uniqueStopsMasterList_extra = [];
        let processedExcelStopsData_extra = [];
        let rsg_selectedStops_extra = [];
        let rsg_generatedPreviewEntries_extra = [];
        let rsg_loadedConfigs_extra = {};
        let rsg_lastLoadedRouteName_extra = null;
        let rsg_lastLoadedDestName_extra = null;
        let rsg_lastLoadedOpProfile_extra = null;
        let rsg_draggedItemIndex_extra = null;
        let scheduledRouteUpdates_extra = {};


        // --- Firebase Path Constants ---
        const FB_PATH_PAGE_EXTRA_SETTINGS = '/settings/extraModulesPageSettings';
        const FB_PATH_OPERATIONAL_OVERRIDES = '/operationalOverrides';
        const FB_PATH_SCHEDULED_DELETIONS = '/scheduledRouteDeletions';
        const FB_PATH_SCHEDULES_BY_ROUTE = '/liveSchedule/schedulesByRoute'; // New path for structured schedule data
        const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
        const FB_PATH_APPSTATE_LAST_UPDATED = '/appState/scheduleLastUpdated';
        const FB_PATH_APPSTATE_CLOSED_STOPS = '/appState/closedStopIDs';
        const FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS = '/settings/customRouteColours';
        const FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS = '/settings/stopSpecificRouteColours';
        const FB_PATH_RSG_CONFIGS = '/rsgConfigs';
        const FB_PATH_SCHEDULED_UPDATES = '/scheduledUpdates';
        const FB_PATH_SCHEDULED_ROUTE_UPDATES = '/scheduledRouteUpdates';
        const BANK_HOLIDAY_CACHE_DURATION_MS = 24 * 60 * 60 * 1000;


        // --- DOM Elements ---
        const tteRouteNameSelect_el_extra = document.getElementById('tte-routeName-select-extra');
        const tteRouteNameInput_el_extra = document.getElementById('tte-routeName-input-extra');
        const tteDownloadTimetableButton_el_extra = document.getElementById('tte-downloadTimetable-button-extra');
        const tteStatusMessage_el_extra = document.getElementById('tte-status-message-extra');
        const authSection_el_extra = document.getElementById('auth-section');
        const loginFormContainer_el_extra = document.getElementById('login-form-container_extra');
        const adminLoginForm_el_extra = document.getElementById('adminLoginForm_extra');
        const inputEmail_el_extra = document.getElementById('inputEmail_extra');
        const inputPassword_el_extra = document.getElementById('inputPassword_extra');
        const authStatus_el_extra = document.getElementById('auth-status_extra');
        const logoutContainer_el_extra = document.getElementById('logout-container_extra');
        const loggedInUserEmailDisplay_el_extra = document.getElementById('loggedInUserEmail_extra');
        const topMenuBar_el_extra = document.getElementById('top-menu-bar_extra');
        const toolSectionsWrapper_el_extra = document.getElementById('tool-sections-wrapper_extra');
        const currentProfileDisplayContainer_el = document.getElementById('current-profile-display-container');
        const currentProfileDisplayElement_el = document.getElementById('current-profile-display');
        // Day Profile Override
        const overrideDateInput_el_extra = document.getElementById('overrideDate_extra');
        const overrideProfileInput_el_extra = document.getElementById('overrideProfile_extra');
        const setOverrideButton_el_extra = document.getElementById('setOverrideButton_extra');
        const clearOverrideButton_el_extra = document.getElementById('clearOverrideButton_extra');
        const overrideStatusMessage_el_extra = document.getElementById('overrideStatusMessage_extra');
        const selectedDateDisplay_el_extra = document.getElementById('selectedDateDisplay_extra');
        const autoProfileForSelectedDate_el_extra = document.getElementById('autoProfileForSelectedDate_extra');
        const currentOverrideForSelectedDate_el_extra = document.getElementById('currentOverrideForSelectedDate_extra');
        const activeOverridesList_el_extra = document.getElementById('activeOverridesList_extra');
        // Stop Management & Creation
        const selectNewStopIdFormat_el_extra = document.getElementById('selectNewStopIdFormat_extra');
        const inputNewStopId_el_extra = document.getElementById('inputNewStopId_extra');
        const newStopIdAvailability_el_extra = document.getElementById('newStopIdAvailability_extra');
        const inputNewStopName_el_extra = document.getElementById('inputNewStopName_extra');
        const inputNewStopDirection_el_extra = document.getElementById('inputNewStopDirection_extra');
        const buttonAddNewStop_el_extra = document.getElementById('buttonAddNewStop_extra');
        const addNewStopStatus_el_extra = document.getElementById('addNewStopStatus_extra');
        const fileInputBulkAddStops_el_extra = document.getElementById('fileInputBulkAddStops_extra');
        const fileNameBulkAddStops_el_extra = document.getElementById('fileNameBulkAddStops_extra');
        const buttonBulkAddNewStops_el_extra = document.getElementById('buttonBulkAddNewStops_extra');
        const bulkAddNewStopsStatus_el_extra = document.getElementById('bulkAddNewStopsStatus_extra');
        const masterStopListFilterInput_el_extra = document.getElementById('masterStopListFilterInput_extra');
        const refreshMasterStopListButton_el_extra = document.getElementById('refreshMasterStopListButton_extra');
        const masterStopListUL_el_extra = document.getElementById('masterStopListUL_extra');
        const masterStopListStatus_el_extra = document.getElementById('masterStopListStatus_extra');
        const applyMasterListStopIdChangesButton_el_extra = document.getElementById('applyMasterListStopIdChangesButton_extra');
        const masterListApplyChangesStatus_el_extra = document.getElementById('masterListApplyChangesStatus_extra');
        const exportUniqueStopsButton_el_extra = document.getElementById('exportUniqueStopsButton_extra');
        const findDuplicateStopsByNameDirButton_el_extra = document.getElementById('findDuplicateStopsByNameDirButton_extra');
        const duplicateStopsByNameDirResults_el_extra = document.getElementById('duplicateStopsByNameDirResults_extra');
        // Global Route Deletion
        const globalRouteDeletionListContainer_el_extra = document.getElementById('globalRouteDeletionListContainer_el_extra');
        const deleteEntireRouteButton_el_extra = document.getElementById('deleteEntireRouteButton_el_extra');
        const deleteEntireRouteStatusMessage_el_extra = document.getElementById('deleteEntireRouteStatusMessage_el_extra');
        // Route Schedule Generator (RSG)
        const rsgRouteNameSelect_el_extra = document.getElementById('rsg-routeName-select-extra');
        const rsgRouteNameInput_el_extra = document.getElementById('rsg-routeName-input-extra');
        //const rsgOperatingProfileInput_el_extra = document.getElementById('rsg-operatingProfile-input-extra');
        const rsgDestinationNameSelect_el_extra = document.getElementById('rsg-destinationName-select-extra');
        const rsgDestinationNameInput_el_extra = document.getElementById('rsg-destinationName-input-extra');
        const rsgStopSearchInput_el_extra = document.getElementById('rsg-stop-search-input-extra');
        const rsgStopSearchResults_el_extra = document.getElementById('rsg-stop-search-results-extra');
        const rsgStopSequenceList_el_extra = document.getElementById('rsg-stop-sequence-list-extra');
        const rsgStopSequencePlaceholder_el_extra = document.getElementById('rsg-stop-sequence-placeholder-extra');
        const rsgFirstStopTimesContainer_el_extra = document.getElementById('rsg-first-stop-times-container-extra');
        const rsgFirstStopTimesInput_el_extra = document.getElementById('rsg-first-stop-times-input-extra');
        const rsgGenerateScheduleButton_el_extra = document.getElementById('rsg-generate-schedule-button-extra');
        const rsgSaveConfigurationButton_el_extra = document.getElementById('rsg-save-configuration-button-extra');
        const rsgAddToWorkingScheduleButton_el_extra = document.getElementById('rsg-add-to-working-schedule-button-extra');
        const rsgStatusMessage_el_extra = document.getElementById('rsg-status-message-extra');
        const rsgSchedulePreviewContainer_el_extra = document.getElementById('rsg-schedule-preview-container-extra');
        const rsgPreviewTableBody_el_extra = document.getElementById('rsg-preview-table-extra')?.getElementsByTagName('tbody')[0];
        const rsgOpenCopyModalButton_el_extra = document.getElementById('rsg-open-copy-modal-button-extra');
        const rsgCopyModal_el_extra = document.getElementById('rsg-copy-modal-extra');
        const rsgCopySourceRouteNameSelect_el_extra = document.getElementById('rsg-copy-source-routeName-select-extra');
        const rsgCopySourceRouteNameInput_el_extra = document.getElementById('rsg-copy-source-routeName-input-extra');
        const rsgCopySourceOpProfileInput_el_extra = document.getElementById('rsg-copy-source-operatingProfile-input-extra');
        const rsgCopySourceDestNameSelect_el_extra = document.getElementById('rsg-copy-source-destinationName-select-extra');
        const rsgCopySourceDestNameInput_el_extra = document.getElementById('rsg-copy-source-destinationName-input-extra');
        const rsgCopyModalStatus_el_extra = document.getElementById('rsg-copy-modal-status-extra');
        const rsgCopyModalCancelButton_el_extra = document.getElementById('rsg-copy-modal-cancel-button-extra');
        const rsgCopyModalActionButton_el_extra = document.getElementById('rsg-copy-modal-action-button-extra');
        // Route Profile Deletion (RPD) - NEW
        const rpdRouteSelect_el_extra = document.getElementById('rpd-route-name-select-extra');
        const rpdRouteInput_el_extra = document.getElementById('rpd-route-name-input-extra');
        const rpdDestinationSelect_el_extra = document.getElementById('rpd-destination-name-select-extra');
        const rpdDestinationInput_el_extra = document.getElementById('rpd-destination-name-input-extra');
        const rpdClearDestinationButton_el_extra = document.getElementById('rpd-clear-destination-button-extra');
        const rpdProfileListContainer_el_extra = document.getElementById('rpd-profile-list-container-extra');
        const rpdDeleteProfilesButton_el_extra = document.getElementById('rpd-delete-profiles-button-extra');
        const rpdStatusMessage_el_extra = document.getElementById('rpd-status-message-extra');
        const srdRouteNameSelect_el_extra = document.getElementById('srd-routeName-select-extra');
const srdRouteNameInput_el_extra = document.getElementById('srd-routeName-input-extra');
const srdGoLiveDateTimeInput_el_extra = document.getElementById('srd-go-live-datetime-input-extra');
const srdScheduleDeletionButton_el_extra = document.getElementById('srd-schedule-deletion-button-extra');
const srdStatusMessage_el_extra = document.getElementById('srd-status-message-extra');


        // --- Helper Functions ---
        function sanitizeFirebaseKey(text) {
            if (typeof text !== 'string') return '';
            // Replace forbidden characters with an underscore
            // Firebase forbids '.', '#', '$', '[', ']'
            return text.replace(/[.#$[\]]/g, '_');
        }

// Function to populate the route dropdown for Scheduled Route Deletion (SRD)
function srd_populateRouteSelect_ExtraPage() {
    if (!srdRouteNameSelect_el_extra || !currentWorkingSchedule_extra) {
        console.warn("SRD: Route select element or schedule data not available.");
        return;
    }
    // Get unique routes that actually have schedule entries (not just definitions)
    const uniqueRoutesWithSchedules = [...new Set(
        currentWorkingSchedule_extra
            .filter(e => e.lineName && e.scheduledTime) // Ensure it's a route with actual schedule entries
            .map(e => e.lineName)
    )].sort(compareLineNames_ExtraPage);

    const currentInputValue = srdRouteNameInput_el_extra ? srdRouteNameInput_el_extra.value.trim() : "";

    srdRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Route to Delete --</option>';
    uniqueRoutesWithSchedules.forEach(route => {
        const opt = document.createElement('option');
        opt.value = route;
        opt.textContent = route;
        srdRouteNameSelect_el_extra.appendChild(opt);
    });

    if (currentInputValue) {
        const matchedOption = uniqueRoutesWithSchedules.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
        srdRouteNameSelect_el_extra.value = matchedOption ? matchedOption : "";
    } else {
        srdRouteNameSelect_el_extra.value = "";
    }
    if(srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = '';
}

// --- START: Day Profile Override (DPO) Checkbox Logic ---

function dpo_getCanonicalProfileString_ExtraPage(profileArray) {
    if (!Array.isArray(profileArray)) return "";
    return profileArray.map(p => String(p).trim()).sort((a,b) => a.localeCompare(b)).join(',');
}

function dpo_simulateAutoGroup_ExtraPage(selectedProfilesArray) {
    let simulatedSelections = [...selectedProfilesArray]; 
    // Assuming RSG_PROFILE_GROUPS_TO_MANAGE is suitable here
    RSG_PROFILE_GROUPS_TO_MANAGE.forEach(group => {
        const allIndividualsPresent = group.individuals.every(ind => simulatedSelections.includes(ind));
        if (allIndividualsPresent) {
            simulatedSelections = simulatedSelections.filter(p => !group.individuals.includes(p)); 
            if (!simulatedSelections.includes(group.groupProfile)) {
                simulatedSelections.push(group.groupProfile); 
            }
        }
    });
    return simulatedSelections;
}

function dpo_populateProfileCheckboxes_ExtraPage() {
    const container = document.getElementById('dpo-selectable-profiles-container-extra');
    const placeholder = document.getElementById('dpo-profiles-placeholder-extra'); // Make sure this ID is in your HTML for DPO
    if (!container) {
        console.error("DPO Profile checkbox container not found!");
        return;
    }
    container.innerHTML = ''; // Clear previous content

    // Assuming RSG_OPERATING_PROFILES_LIST is suitable for DPO as well
    if (RSG_OPERATING_PROFILES_LIST.length === 0 && placeholder) {
        placeholder.textContent = "No profiles defined for selection.";
        container.appendChild(placeholder);
        return;
    }
    if (placeholder) placeholder.style.display = 'none';

    RSG_OPERATING_PROFILES_LIST.forEach(profileValue => {
        const wrapper = document.createElement('div');
        wrapper.style.display = 'inline-flex'; 
        wrapper.style.alignItems = 'center';
        wrapper.style.marginRight = '10px'; // Spacing for tiles

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        const safeProfileId = profileValue.replace(/[^a-zA-Z0-9_-]/g, '');
        checkbox.id = `dpo-profile-cb-${safeProfileId}-extra`;
        checkbox.value = profileValue;
        checkbox.name = 'dpoOperatingProfileCheckbox_extra';
        checkbox.classList.add('dpo-profile-checkbox'); 

        checkbox.addEventListener('change', dpo_handleProfileSelectionChange_ExtraPage);

        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.textContent = profileValue;
        label.style.marginLeft = "4px"; 
        label.style.cursor = "pointer";
        label.style.color = "#ecf0f1"; 

        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        container.appendChild(wrapper);
    });
    dpo_updateDisabledProfileCheckboxes_ExtraPage(); // Initial update of enabled/disabled states
}

function dpo_updateDisabledProfileCheckboxes_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox'));
    const currentSelectedValues = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

    allCheckboxes.forEach(cb => {
        if (cb.checked) { // Always enable if checked
            cb.disabled = false;
            if (cb.parentElement) {
                cb.parentElement.style.opacity = 1;
                const labelForCb = cb.parentElement.querySelector('label');
                if (labelForCb) labelForCb.style.cursor = 'pointer';
            }
            return;
        }

        // Simulate adding this checkbox's value to the current selection
        const potentialNextRawSelection = [...currentSelectedValues, cb.value];
        const finalEffectiveSelectionAfterAutoGroup = dpo_simulateAutoGroup_ExtraPage(potentialNextRawSelection);
        const finalEffectiveSortedString = dpo_getCanonicalProfileString_ExtraPage(finalEffectiveSelectionAfterAutoGroup);
        
        let canBeEnabled = false;
        // Check if this exact combination is valid
        if (VALID_PROFILE_COMBINATIONS_SET.has(finalEffectiveSortedString)) {
            canBeEnabled = true;
        }
        
        // If not exact, check if it's a valid start to a longer combination
        if (!canBeEnabled) {
            const prefixToTest = finalEffectiveSortedString + ",";
            for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                if (validCombo.startsWith(prefixToTest)) {
                    canBeEnabled = true;
                    break;
                }
            }
        }
        
        // Special case for initial selection (currentSelectedValues is empty)
        if (currentSelectedValues.length === 0) {
             const singleProfileItselfAfterPotentialGroup = dpo_simulateAutoGroup_ExtraPage([cb.value]);
             const singleCanonical = dpo_getCanonicalProfileString_ExtraPage(singleProfileItselfAfterPotentialGroup);
             if (VALID_PROFILE_COMBINATIONS_SET.has(singleCanonical)) {
                 canBeEnabled = true;
             } else {
                 const prefixToTestForSingle = singleCanonical + ",";
                 for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                     if (validCombo.startsWith(prefixToTestForSingle)) {
                         canBeEnabled = true;
                         break;
                     }
                 }
             }
        }

        cb.disabled = !canBeEnabled;
        if (cb.parentElement) {
            cb.parentElement.style.opacity = !canBeEnabled ? 0.5 : 1;
            const labelForCb = cb.parentElement.querySelector('label');
            if (labelForCb) {
                labelForCb.style.cursor = !canBeEnabled ? 'not-allowed' : 'pointer';
            }
        }
    });
}

function dpo_handleProfileSelectionChange_ExtraPage(event) {
    let currentSelectionsArray = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox:checked')).map(cb => cb.value);
    const allCheckboxes = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox'));

    // Handle auto-grouping (e.g., Mo-Fr implies individual days)
    // Assuming RSG_PROFILE_GROUPS_TO_MANAGE is suitable
    RSG_PROFILE_GROUPS_TO_MANAGE.forEach(group => {
        const groupCheckbox = allCheckboxes.find(cb => cb.value === group.groupProfile);
        if (!groupCheckbox) return; 
        currentSelectionsArray = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value); // Re-evaluate current selections
        const allIndividualsInGroupSelected = group.individuals.every(day => currentSelectionsArray.includes(day));

        if (allIndividualsInGroupSelected) {
            if (!groupCheckbox.checked) { // If individuals are all selected, but group isn't
                group.individuals.forEach(day => {
                    const cb = allCheckboxes.find(c => c.value === day);
                    if (cb && cb.checked) { cb.checked = false; }
                });
                groupCheckbox.checked = true;
            }
        } else if (groupCheckbox.checked) { // If group is selected, but not all individuals are
            // If the event target was one of the individuals and it's being unchecked, uncheck the group
            if (event && event.target && group.individuals.includes(event.target.value) && !event.target.checked) {
                 groupCheckbox.checked = false;
            }
            // Ensure individuals are unchecked if group is checked
             group.individuals.forEach(day => {
                const cb = allCheckboxes.find(c => c.value === day);
                if(cb && cb.checked) cb.checked = false;
            });
        }
    });

    // Re-get the selections after auto-grouping
    currentSelectionsArray = Array.from(document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox:checked')).map(cb => cb.value);
    
    // Sort for consistent display and storage
    currentSelectionsArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a); // Make sure this helper exists or adapt from RSG
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) return orderA - orderB;
        return a.localeCompare(b);
    });

    const finalSelectedProfilesString = currentSelectionsArray.join(', ');
    const displayElement = document.getElementById('dpo-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }

    dpo_updateDisabledProfileCheckboxes_ExtraPage();
}

function dpo_getSelectedOpProfilesString_ExtraPage() {
    const selectedProfiles = [];
    document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox:checked').forEach(checkbox => {
        selectedProfiles.push(checkbox.value);
    });
    selectedProfiles.sort((a,b) => a.localeCompare(b)); // Consistent sort
    return selectedProfiles.join(','); // Join with just comma for storage
}

function dpo_setCheckedProfiles_ExtraPage(profileString) {
    const profilesToSelect = profileString ? profileString.split(',').map(p => p.trim()).filter(Boolean) : [];
    const allCheckboxes = document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox');
    allCheckboxes.forEach(checkbox => {
        checkbox.checked = profilesToSelect.includes(checkbox.value);
    });
    // After setting, trigger the logic that handles display and disabled states
    dpo_handleProfileSelectionChange_ExtraPage(null); // Pass null as no specific event triggered this
}

function dpo_clearProfileSelections_ExtraPage() {
    const allCheckboxes = document.querySelectorAll('#dpo-selectable-profiles-container-extra .dpo-profile-checkbox');
    allCheckboxes.forEach(cb => cb.checked = false);
    dpo_handleProfileSelectionChange_ExtraPage(null); // Update display and disabled states
}

// --- END: Day Profile Override (DPO) Checkbox Logic ---

async function handleEditStopFromMasterList_ExtraPage(stopID, currentName, currentDirection) {
    if (!currentUser_extra) {
        alert("Please log in to edit stop details.");
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = "Not logged in.";
        return;
    }

    const newStopName = prompt(`Editing Stop: ${stopID}\nEnter new Stop Name (current: "${currentName || ''}"):`, currentName || '');
    if (newStopName === null) { // User cancelled the first prompt
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `Edit cancelled for stop ${stopID}.`;
        return;
    }

    const newDirection = prompt(`Editing Stop: ${stopID}\nEnter new "Towards" text (current: "${currentDirection || ''}"):`, currentDirection || '');
    if (newDirection === null) { // User cancelled the second prompt
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `Edit cancelled for stop ${stopID}.`;
        return;
    }

    // Trim inputs
    const trimmedNewStopName = newStopName.trim();
    const trimmedNewDirection = newDirection.trim();
    const trimmedCurrentName = (currentName || "").trim();
    const trimmedCurrentDirection = (currentDirection || "").trim();

    const nameChanged = trimmedNewStopName !== trimmedCurrentName;
    const directionChanged = trimmedNewDirection !== trimmedCurrentDirection;

    if (!nameChanged && !directionChanged) {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `No changes made to Stop ID "${stopID}".`;
        return;
    }

    if (masterStopListStatus_el_extra) {
        masterStopListStatus_el_extra.textContent = `Updating entries for stop ${stopID}...`;
        masterStopListStatus_el_extra.style.color = "#f1c40f";
    }

    let updatedCount = 0;
    currentWorkingSchedule_extra.forEach(entry => {
        if (entry.stopID && entry.stopID.toUpperCase() === stopID.toUpperCase()) {
            let entryModified = false;
            if (nameChanged) {
                entry.stopName = trimmedNewStopName; // Update with new name (can be blank if user cleared it)
                entryModified = true;
            }
            if (directionChanged) {
                entry.direction = trimmedNewDirection; // Update with new direction (can be blank)
                entryModified = true;
            }
            if (entryModified) {
                updatedCount++;
            }
        }
    });

    if (updatedCount > 0) {
        try {
            await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
            // Ancillary data like unique stops will be updated by rebuildAndSaveEntireScheduleToFirebase_ExtraPage
            
            if (masterStopListStatus_el_extra) {
                masterStopListStatus_el_extra.textContent = `${updatedCount} schedule entries for Stop ID "${stopID}" updated. Name set to "${trimmedNewStopName}", Direction to "${trimmedNewDirection}".`;
                masterStopListStatus_el_extra.style.color = "#2ecc71";
            }
            renderUIDependentElements_ExtraPage(); // This should re-trigger populateMasterStopList_ExtraPage if that section is active
        } catch (error) {
            console.error(`Error saving Stop ID ${stopID} changes to Firebase:`, error);
            if (masterStopListStatus_el_extra) {
                masterStopListStatus_el_extra.textContent = `Error saving changes for stop ${stopID}: ${error.message}`;
                masterStopListStatus_el_extra.style.color = "#e74c3c";
            }
            // Consider reloading initial data to revert local changes if save fails critically
            // loadInitialData_ExtraPage(); 
        }
    } else {
        if (masterStopListStatus_el_extra) masterStopListStatus_el_extra.textContent = `No schedule entries were modified for Stop ID "${stopID}". This might happen if the stop only exists as a definition.`;
    }
}

async function handleApplyScheduledRouteBatch_ExtraPage(tasksInBatch) {
    if (!currentUser_extra) {
        alert("Please log in to apply batch updates.");
        return;
    }
    if (!tasksInBatch || tasksInBatch.length === 0) {
        alert("No tasks provided for batch application.");
        return;
    }

    const representativeTask = tasksInBatch[0]; // Assuming all tasks in batch are for the same route & time
    const targetRouteName = representativeTask.routeName.toUpperCase();
    const goLiveDateTimeForDisplay = new Date(representativeTask.goLiveDateTime).toLocaleString();

    let allNewEntriesForRoute = [];
    let involvedProfiles = new Set();
    let involvedDestinations = new Set();
    let taskKeysInBatch = []; // To update status of all processed tasks

    tasksInBatch.forEach(task => {
        // Ensure we only aggregate 'applySchedule' tasks for the correct route
        if ((task.taskTypeDisplay === 'applySchedule' || task.taskType === 'applySchedule') && task.routeName.toUpperCase() === targetRouteName) {
            if (task.scheduledEntries && task.scheduledEntries.length > 0) {
                // Deep copy entries to avoid issues if the same task object is somehow reused
                allNewEntriesForRoute.push(...JSON.parse(JSON.stringify(task.scheduledEntries)));
                involvedProfiles.add(task.operatingProfile);
                involvedDestinations.add(task.destinationName);
            }
            taskKeysInBatch.push(task.key);
        }
    });

    if (allNewEntriesForRoute.length === 0) {
        alert(`No actual schedule entries found within the selected batch for Route "${targetRouteName}". Cannot apply.`);
        return;
    }

    const profileList = Array.from(involvedProfiles).join(', ') || "N/A";
    const destList = Array.from(involvedDestinations).join(', ') || "N/A";

    const confirmMessage = `Apply BATCH update for Route: ${targetRouteName}\n` +
                         `Go-Live: ${goLiveDateTimeForDisplay}\n\n` +
                         `This batch includes ${tasksInBatch.length} update(s) which will define the following for this route:\n` +
                         `Operating Profile(s): ${profileList}\n` +
                         `Destination(s): ${destList}\n\n` +
                         `WARNING: This will DELETE ALL existing schedules for the ENTIRE Route "${targetRouteName}" (across all its current profiles and destinations).\n` +
                         `Then, ${allNewEntriesForRoute.length} new entries from this batch will be added, forming the new complete schedule for this route.\n\n` +
                         `Proceed with wiping the whole route and applying this batch?`;

    if (!confirm(confirmMessage)) {
        alert("Batch application cancelled by user.");
        return;
    }

    if (rsgStatusMessage_el_extra) { // Use a general status message element if available
        rsgStatusMessage_el_extra.textContent = `Processing batch for Route ${targetRouteName}... This may take a moment.`;
        rsgStatusMessage_el_extra.style.color = "#3498db";
    }

    const { database, dbUpdate, dbRef } = window.firebaseOMSI;
    let removedCount = 0;

    // 1. Filter out ALL existing entries for this targetRouteName from the local working schedule
    currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
        const matchesRouteOnly = entry.lineName && entry.lineName.toUpperCase() === targetRouteName;
        if (matchesRouteOnly) {
            removedCount++;
            return false;
        }
        return true;
    });
    console.log(`Batch Apply: Removed <span class="math-inline">\{removedCount\} existing entries for Route "</span>{targetRouteName}".`);

    // 2. Add all new entries from the batch, ensuring unique internalIds
    const entriesToAddWithUniqueIds = allNewEntriesForRoute.map((e, idx) => ({
        ...e,
        internalId: e.internalId || `<span class="math-inline">\{e\.stopID\}\_</span>{e.lineName}_${(e.scheduledTime||"0000").replace(':','')}_batchApply_${Date.now()}_${idx}`
    }));
    currentWorkingSchedule_extra.push(...entriesToAddWithUniqueIds);
    console.log(`Batch Apply: Added <span class="math-inline">\{entriesToAddWithUniqueIds\.length\} new entries for Route "</span>{targetRouteName}".`);

    try {
        // 3. Rebuild and save the entire schedule to Firebase.
        await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
        console.log(`Batch Apply: Main schedule rebuilt and saved to Firebase for Route "${targetRouteName}".`);

        // 4. Update the status of all processed scheduled items in Firebase
        const updatesToFirebaseStatus = {};
        const appliedAtTimestamp = new Date().toISOString();
        const appliedByEmail = currentUser_extra ? currentUser_extra.email : "system (batch)";

        taskKeysInBatch.forEach(taskKey => {
            // This assumes all tasks in the batch were 'applySchedule' tasks from FB_PATH_SCHEDULED_ROUTE_UPDATES
            updatesToFirebaseStatus[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/status`] = 'applied (batch)';
            updatesToFirebaseStatus[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/appliedAt`] = appliedAtTimestamp;
            updatesToFirebaseStatus[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/appliedBy`] = appliedByEmail;
        });

        await dbUpdate(dbRef(database), updatesToFirebaseStatus);
        console.log("DEBUG: Task keys being processed:", JSON.stringify(taskKeysInBatch));
console.log("DEBUG: Data being sent to Firebase for status update:", JSON.stringify(updatesToFirebaseStatus));

        // Refresh UI
        loadAndDisplayScheduledUpdates_ExtraPage(); 
        renderUIDependentElements_ExtraPage(); 

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Batch update for Route ${targetRouteName} applied successfully. Live schedule updated.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
            setTimeout(() => { if (rsgStatusMessage_el_extra.textContent && rsgStatusMessage_el_extra.textContent.includes(`Batch update for Route ${targetRouteName}`)) rsgStatusMessage_el_extra.textContent = ''; }, 7000);
        } else {
            alert(`Batch update for Route ${targetRouteName} applied successfully. Live schedule updated.`);
        }

    } catch (error) {
        console.error("Error applying scheduled batch update:", error);
        alert(`Error applying batch update for Route "${targetRouteName}": ${error.message}. The live schedule may be in an inconsistent state. Review carefully.`);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error applying batch for Route ${targetRouteName}: ${error.message}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // Attempt to mark tasks as 'error' in Firebase
        const errorUpdates = {};
        taskKeysInBatch.forEach(taskKey => {
            errorUpdates[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/status`] = 'error';
            errorUpdates[`<span class="math-inline">\{FB\_PATH\_SCHEDULED\_ROUTE\_UPDATES\}/</span>{taskKey}/lastError`] = `Batch Apply Error: ${error.message}`;
        });
        await dbUpdate(dbRef(database), errorUpdates).catch(err => console.error("Failed to mark batch tasks as error:", err));
        loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh to show error state
    }
}

function checkAndDisplayDueUpdatesNotification_ExtraPage() {
    const banner = document.getElementById('global-notification-banner');
    if (!banner || !currentUser_extra) { // Only show if logged in and banner element exists
        if (banner) banner.style.display = 'none'; // Ensure banner is hidden if no user
        return;
    }

    let dueTasksDetails = []; // To store info about due tasks for the banner message
    const now = new Date().getTime();

    console.log("Banner Check: Function called at", new Date().toLocaleString());
    console.log("Banner Check: Current epoch time (now):", now);

    // Check 'applySchedule' tasks (typically from RSG - timetable updates)
    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.values(scheduledRouteUpdates_extra).forEach(task => {
            if (task && task.status === 'pending' && task.goLiveDateTime) {
                const goLiveTimeEpoch = new Date(task.goLiveDateTime).getTime();
                // console.log(`Banner Check (Update Task ${task.key || 'N/A'}): Status: ${task.status}, GoLiveISO: ${task.goLiveDateTime}, GoLiveEpoch: ${goLiveTimeEpoch}, Due: ${goLiveTimeEpoch <= now}`);
                if (goLiveTimeEpoch <= now) {
                    dueTasksDetails.push({
                        type: 'Timetable Update',
                        name: `Route ${task.routeName || 'N/A'} (for P: ${task.operatingProfile || 'N/A'} to D: ${task.destinationName || 'N/A'})`,
                        key: task.key,
                        goLive: new Date(task.goLiveDateTime).toLocaleString()
                    });
                }
            }
        });
    }

    // Check 'deleteEntireRoute' tasks
    if (typeof scheduledRouteDeletions_extra === 'object' && scheduledRouteDeletions_extra !== null) {
        Object.values(scheduledRouteDeletions_extra).forEach(task => {
            if (task && task.status === 'pending' && task.goLiveDateTime) {
                const goLiveTimeEpoch = new Date(task.goLiveDateTime).getTime();
                // console.log(`Banner Check (Delete Task ${task.key || 'N/A'}): Status: ${task.status}, GoLiveISO: ${task.goLiveDateTime}, GoLiveEpoch: ${goLiveTimeEpoch}, Due: ${goLiveTimeEpoch <= now}`);
                if (goLiveTimeEpoch <= now) {
                    dueTasksDetails.push({
                        type: 'Route Deletion',
                        name: `Route ${task.routeName || 'N/A'}`,
                        key: task.key,
                        goLive: new Date(task.goLiveDateTime).toLocaleString()
                    });
                }
            }
        });
    }

    console.log("Banner Check: Total dueTasksDetails found:", dueTasksDetails.length, JSON.parse(JSON.stringify(dueTasksDetails)));

    if (dueTasksDetails.length > 0) {
        // Sort by go-live time, earliest first, for display consistency if you show details
        dueTasksDetails.sort((a,b) => new Date(a.goLive).getTime() - new Date(b.goLive).getTime());
        
        let message = `${dueTasksDetails.length} scheduled task(s) are now due or overdue.`;
        // Example: Show details of the first due task in the console for easier debugging
        if (dueTasksDetails[0]) {
           console.log("Banner Check: First due task details:", dueTasksDetails[0]);
        }
        
        banner.innerHTML = `${message} 
            <button id="view-due-tasks-button" class="button small-action neutral" style="margin-left:15px; background-color: #ecf0f1; color: #2c3e50; padding: 0.3em 0.6em; font-size: 0.85em;">
                View & Manage Tasks
            </button>`;
        banner.style.backgroundColor = '#27ae60'; // Green for due tasks
        banner.style.display = 'block';

        const viewButton = document.getElementById('view-due-tasks-button');
        if (viewButton) {
            // Ensure only one listener is attached, or handle re-attachment carefully if innerHTML is used often
            if (!viewButton.dataset.listenerAttached) {
                viewButton.addEventListener('click', () => {
                    showExtraPageSection('scheduled-route-updates-section_extra'); // Navigate to the tasks page
                    // You might choose to hide the banner after click or let it persist
                    // banner.style.display = 'none'; 
                });
                viewButton.dataset.listenerAttached = 'true';
            }
        }
    } else {
        banner.style.display = 'none';
    }
}

// Function to handle confirming and saving the scheduled deletion
async function srd_confirmAndScheduleDeletion_ExtraPage() {
    if (!currentUser_extra || !window.firebaseOMSI || !window.firebaseOMSI.database || !window.firebaseOMSI.auth) { // Added auth check here
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Not logged in or Firebase (database/auth) not available.";
            srdStatusMessage_el_extra.style.color = "#e74c3c";
        }
        console.error("SRD Save: currentUser_extra, window.firebaseOMSI, or its database/auth components are missing.");
        return;
    }

    const routeName = srdRouteNameInput_el_extra.value.trim() || srdRouteNameSelect_el_extra.value;
    const goLiveDateTimeValue = srdGoLiveDateTimeInput_el_extra.value;

    if (!routeName) {
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Please select or enter a route name to schedule for deletion.";
            srdStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    if (!goLiveDateTimeValue) {
        // ... (error handling for goLiveDateTimeValue) ...
        return;
    }

    const goLiveDateObj = new Date(goLiveDateTimeValue);
    if (isNaN(goLiveDateObj.getTime())) {
        // ... (error handling for invalid date) ...
        return;
    }

    if (goLiveDateObj <= new Date()) {
        // ... (error handling for past date) ...
        return;
    }

    // Destructure auth here to ensure it's in scope for this function
    const { database, dbSet, dbRef, auth } = window.firebaseOMSI;

    // Crucial check for UID
    console.log("SRD Save: Current User from auth object:", auth.currentUser ? auth.currentUser.uid : "No user from auth object");
    console.log("SRD Save: Current User from currentUser_extra variable:", currentUser_extra ? currentUser_extra.uid : "No user from currentUser_extra");
    console.log("SRD Save: Expected Admin UID:", 'PBVTn1GvcAfIZWNLzuP1brUtJDu1');

    // Use the UID from the auth object directly for the most reliable check
    if (!auth.currentUser || auth.currentUser.uid !== 'PBVTn1GvcAfIZWNLzuP1brUtJDu1') {
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Permission Denied: You are not authorized to perform this action.";
            srdStatusMessage_el_extra.style.color = "#e74c3c";
        }
        console.error("SRD Save: Permission Denied. UID mismatch or no authenticated user. Actual UID:", auth.currentUser ? auth.currentUser.uid : "null");
        return; // Stop if not the admin user
    }


    if (!confirm(`Are you sure you want to schedule the DELETION of all data for route "${routeName}" to occur on ${goLiveDateObj.toLocaleString()}? This action, once processed, cannot be easily undone.`)) {
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Scheduled deletion cancelled by user.";
            srdStatusMessage_el_extra.style.color = "";
        }
        return;
    }

    const deletionTask = {
        taskType: "deleteEntireRoute",
        routeName: routeName,
        goLiveDateTime: goLiveDateObj.toISOString(),
        scheduledAt: new Date().toISOString(),
        status: "pending",
        userEmail: currentUser_extra.email // currentUser_extra should be the admin user here
    };

    if (srdStatusMessage_el_extra) {
        srdStatusMessage_el_extra.textContent = `Scheduling deletion for route "${routeName}"...`;
        srdStatusMessage_el_extra.style.color = "#3498db";
    }

    try {
        const deletionTaskKey = `delSched_${Date.now()}_${sanitizeFirebaseKey(routeName)}`;
        await dbSet(dbRef(database, `${FB_PATH_SCHEDULED_DELETIONS}/${deletionTaskKey}`), deletionTask);

        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = `Deletion for route "${routeName}" successfully scheduled for ${goLiveDateObj.toLocaleString()}. It will appear in the 'Scheduled Tasks' list.`;
            srdStatusMessage_el_extra.style.color = "#2ecc71";
        }
        if(srdRouteNameInput_el_extra) srdRouteNameInput_el_extra.value = '';
        if(srdRouteNameSelect_el_extra) srdRouteNameSelect_el_extra.value = '';
        if(srdGoLiveDateTimeInput_el_extra) srdGoLiveDateTimeInput_el_extra.value = '';

    } catch (error) {
        console.error("Error scheduling route deletion to Firebase:", error); // This will show the permission denied
        if (srdStatusMessage_el_extra) {
            srdStatusMessage_el_extra.textContent = "Error scheduling deletion: " + error.message;
            srdStatusMessage_el_extra.style.color = "#e74c3c";
        }
    }
}

        function getYYYYMMDD_ExtraPage(dateSource) { const d = dateSource ? new Date(dateSource) : new Date(); const year = d.getFullYear(); const month = String(d.getMonth() + 1).padStart(2, '0'); const day = String(d.getDate()).padStart(2, '0'); return `${year}-${month}-${day}`; }
        function formatDateToDDMonthYYYY_ExtraPage(dateStringYYYYMMDD) { if (!dateStringYYYYMMDD || !/^\d{4}-\d{2}-\d{2}$/.test(dateStringYYYYMMDD)) return "Invalid Date"; const [year, month, day] = dateStringYYYYMMDD.split('-'); const dateObj = new Date(year, month - 1, day); const options = { day: '2-digit', month: 'long', year: 'numeric' }; return dateObj.toLocaleDateString('en-GB', options); }
        function getUniqueStopsFromSchedule_ExtraPage() { if (!currentWorkingSchedule_extra || currentWorkingSchedule_extra.length === 0) return []; const stopsMap = new Map(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID && !stopsMap.has(entry.stopID.toUpperCase())) { stopsMap.set(entry.stopID.toUpperCase(), { stopID: entry.stopID, stopName: entry.stopName || "Unknown Name", direction: entry.direction || "No Direction" }); } }); return Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase())); }
        function parseLineName_ExtraPage(lineNameStr) { const name = String(lineNameStr || "").toUpperCase().trim(); const numericPrefixRegex = new RegExp(/^(\d+)([A-Z]*)$/); const alphaNumericRegex = new RegExp(/^([A-Z]+)(\d+)?([A-Z]*)$/); const numericPrefixMatch = name.match(numericPrefixRegex); if (numericPrefixMatch) return { type: 'numeric', number: parseInt(numericPrefixMatch[1], 10), suffix: numericPrefixMatch[2] || '', original: name }; const alphaNumericMatch = name.match(alphaNumericRegex); if (alphaNumericMatch) return { type: 'alpha', prefix: alphaNumericMatch[1], number: alphaNumericMatch[2] ? parseInt(alphaNumericMatch[2], 10) : null, suffix: alphaNumericMatch[3] || '', original: name }; return { type: 'other', original: name }; }
        function compareLineNames_ExtraPage(lineAStr, lineBStr) { const parsedA = parseLineName_ExtraPage(lineAStr); const parsedB = parseLineName_ExtraPage(lineBStr); if (parsedA.type === 'numeric' && parsedB.type === 'alpha') return -1; if (parsedA.type === 'alpha' && parsedB.type === 'numeric') return 1; if (parsedA.type === 'numeric' && parsedB.type === 'numeric') { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type === 'alpha' && parsedB.type === 'alpha') { const prefixCompare = parsedA.prefix.localeCompare(parsedB.prefix); if (prefixCompare !== 0) return prefixCompare; if (parsedA.number === null && parsedB.number !== null) return -1; if (parsedA.number !== null && parsedB.number === null) return 1; if (parsedA.number !== null && parsedB.number !== null) { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; } return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type !== 'other' && parsedB.type === 'other') return -1; if (parsedA.type === 'other' && parsedB.type !== 'other') return 1; return (parsedA.original || "").localeCompare(parsedB.original || ""); }
        const initialRouteColourMapForTools_extra = {}; const DEFAULT_ROUTE_COLOUR_TOOLS_extra = "#73809C"; const NIGHT_BUS_BLUE_COLOR_extra = (initialRouteColourMapForTools_extra["NIGHT_DEFAULT"] || "#4CDBE6").toUpperCase();
        function getRouteTileColour_ExtraPage(lineName, stopID = null) { const upName = String(lineName || "").toUpperCase(); if (stopID && stopSpecificRouteColours_extra[stopID.toUpperCase()] && stopSpecificRouteColours_extra[stopID.toUpperCase()][upName]) { return stopSpecificRouteColours_extra[stopID.toUpperCase()][upName]; } if (globalCustomRouteColours_extra[upName]) return globalCustomRouteColours_extra[upName]; if (initialRouteColourMapForTools_extra[upName]) return initialRouteColourMapForTools_extra[upName]; if (upName.startsWith("N")) return globalCustomRouteColours_extra["NIGHT_DEFAULT"] || NIGHT_BUS_BLUE_COLOR_extra; if (upName.startsWith("SL")) return globalCustomRouteColours_extra["SL_DEFAULT"] || "#D32F2F"; return DEFAULT_ROUTE_COLOUR_TOOLS_extra; }
        function getTextColourForBackground_ExtraPage(hex) { if(!hex || hex.length < 7) return '#FFFFFF'; const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16); return ((0.299*r + 0.587*g + 0.114*b)/255) > 0.5 ? '#000000' : '#FFFFFF'; }
        
async function fetchBankHolidays_ExtraPage() {
            const cacheKeyData = 'omsiToolsBankHolidaysData';
            const cacheKeyExpiry = 'omsiToolsBankHolidaysExpiry';
            const now = new Date().getTime();

            try {
                const cachedExpiryString = localStorage.getItem(cacheKeyExpiry);
                if (cachedExpiryString) {
                    const cachedExpiry = parseInt(cachedExpiryString, 10);
                    if (now < cachedExpiry) {
                        const cachedDataString = localStorage.getItem(cacheKeyData);
                        if (cachedDataString) {
                            ukBankHolidaysData_extra = JSON.parse(cachedDataString);
                            console.log("ExtraPage: Loaded UK bank holidays from cache.");
                            // The call to updateCurrentProfileDisplay_ExtraPage() was removed from here previously.
                            return; // Data loaded from cache, no need to fetch
                        }
                    } else {
                        console.log("ExtraPage: Bank holiday cache expired.");
                    }
                }
            } catch (e) {
                console.warn("ExtraPage: Error reading bank holidays from localStorage, will attempt fetch.", e);
            }

            console.log("ExtraPage: Fetching UK bank holidays from network (https://www.gov.uk/bank-holidays.json)...");
            try {
                const response = await fetch('https://www.gov.uk/bank-holidays.json');
                if (!response.ok) {
                    // Attempt to use stale cache data if fetch fails
                    const staleDataString = localStorage.getItem(cacheKeyData);
                    if (staleDataString) {
                        console.warn(`ExtraPage: HTTP error ${response.status} fetching bank holidays. Using stale cache data if available.`);
                        ukBankHolidaysData_extra = JSON.parse(staleDataString);
                    } else {
                        // No stale data, and fetch failed
                        throw new Error(`HTTP error! status: ${response.status}. No cache available.`);
                    }
                } else {
                    const data = await response.json();
                    if (data['england-and-wales'] && data['england-and-wales'].events) {
                        const events = data['england-and-wales'].events;
                        ukBankHolidaysData_extra = {
                            dates: events.map(event => event.date),
                            titles: events.reduce((acc, event) => { acc[event.date] = event.title; return acc; }, {})
                        };
                        try {
                            localStorage.setItem(cacheKeyData, JSON.stringify(ukBankHolidaysData_extra));
                            localStorage.setItem(cacheKeyExpiry, (now + BANK_HOLIDAY_CACHE_DURATION_MS).toString());
                            console.log("ExtraPage: Fetched and cached UK bank holidays for 24 hours.");
                        } catch (e) {
                            console.warn("ExtraPage: Error saving bank holidays to localStorage. Data might be very large or storage full.", e);
                        }
                    } else {
                        ukBankHolidaysData_extra = { dates: [], titles: {} }; // Fallback to empty if data structure is unexpected
                        console.warn("ExtraPage: Bank holiday data from network was in an unexpected format.");
                    }
                }
            } catch (error) {
                console.error("ExtraPage: Critical error fetching UK bank holidays:", error);
                // Attempt to use stale cache even on critical fetch error
                const staleDataString = localStorage.getItem(cacheKeyData);
                if (staleDataString) {
                    console.warn(`ExtraPage: Using stale cache data due to critical fetch error: ${error.message}`);
                    ukBankHolidaysData_extra = JSON.parse(staleDataString);
                } else {
                    ukBankHolidaysData_extra = { dates: [], titles: {} }; // Default to empty if fetch fails & no stale cache
                }
                // Only update UI to show failure if no data at all could be presented
                if(currentProfileDisplayElement_el && (!staleDataString && Object.keys(ukBankHolidaysData_extra.titles).length === 0)) {
                     currentProfileDisplayElement_el.textContent = "Today's Operating Profile: (Bank Hol. check failed)";
                }
            }
            // The call to updateCurrentProfileDisplay_ExtraPage(); was correctly removed from here.
            // loadInitialData_ExtraPage will call it after this function completes.
        }

        function isSchoolHolidayPeriod_ExtraPage(dateObject) { if (!schoolHolidayDateRanges_extra || schoolHolidayDateRanges_extra.length === 0) return false; const checkTime = dateObject.getTime(); for (const range of schoolHolidayDateRanges_extra) { try { const startTime = new Date(range.start + "T00:00:00").getTime(); const endTime = new Date(range.end + "T23:59:59").getTime(); if (checkTime >= startTime && checkTime <= endTime) return true; } catch (e) { console.error("Invalid date in schoolHolidayDateRanges_extra:", range, e); } } return false; }
      
  function getOperatingCodesForDate_ExtraPage(dateObject) {
    const n = dateObject;
    const dOW = n.getDay();
    const todayDateString = `${n.getFullYear()}-${String(n.getMonth() + 1).padStart(2, '0')}-${String(n.getDate()).padStart(2, '0')}`;
    let potentialDateCodes = new Set();
    let isBankHolidayToday = false;

    if (ukBankHolidaysData_extra && ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(todayDateString)) {
        const holidayTitle = ukBankHolidaysData_extra.titles[todayDateString] || "";
        isBankHolidayToday = true;
        if (holidayTitle.toLowerCase().includes("good friday")) {
            potentialDateCodes.add("Sa");
        } else {
            potentialDateCodes.add("Su");
        }
    }

    if (!isBankHolidayToday) {
        const isSchHol = isSchoolHolidayPeriod_ExtraPage(n);
        const schoolSuffix = isSchHol ? "NSD" : "Sch";
        let dayCode = "";
        switch (dOW) {
            case 0: dayCode = "Su"; break;
            case 1: dayCode = "Mo"; break;
            case 2: dayCode = "Tu"; break;
            case 3: dayCode = "We"; break;
            case 4: dayCode = "Th"; break;
            case 5: dayCode = "Fr"; break;
            case 6: dayCode = "Sa"; break;
        }
        potentialDateCodes.add(dayCode);
        if (dOW >= 1 && dOW <= 5) {
            potentialDateCodes.add(dayCode + schoolSuffix);
            potentialDateCodes.add("MF" + schoolSuffix);
            potentialDateCodes.add("MF");
        }
    }
    
    const finalFilteredCodes = Array.from(potentialDateCodes).filter(code => 
        typeof RSG_OPERATING_PROFILES_LIST !== 'undefined' && RSG_OPERATING_PROFILES_LIST.includes(code)
    );
    
    return finalFilteredCodes;
}

        // Inside omsi_tools_extra.html

async function updateCurrentProfileDisplay_ExtraPage() {
    const now = new Date();
    const todayDateString = getYYYYMMDD_ExtraPage(now); 
    let profileDisplayText = "";
    let serviceTypeDisplay = ""; 
    let operatingCodes = [];
    let isOverridden = false;
    let finalDisplayLabel = "Today's Operating Profile:"; 

    if (window.firebaseOMSI && window.firebaseOMSI.database && currentUser_extra) {
        const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
        try {
            const overrideSnap = await dbGet(dbChild(dbRef(database), `${FB_PATH_OPERATIONAL_OVERRIDES}/${todayDateString}`));
            if (overrideSnap.exists()) {
                const overrideProfileValue = overrideSnap.val();
                profileDisplayText = `${overrideProfileValue} (Manual Override)`;
                operatingCodes = [overrideProfileValue];
                isOverridden = true;
                finalDisplayLabel = "Today's Profile:"; 
            }
        } catch (error) {
            console.error("Error fetching today's override for profile display:", error);
        }
    }

    if (!isOverridden) {
        let isBankHol = false;
        if (ukBankHolidaysData_extra && ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(todayDateString)) {
            let holidayTitle = ukBankHolidaysData_extra.titles[todayDateString] || "Bank Holiday";
            // --- MODIFICATION HERE ---
            holidayTitle = toTitleCase_display(holidayTitle); // Apply title case
            // --- END MODIFICATION ---
            isBankHol = true;
            if (holidayTitle.toLowerCase().includes("good friday")) { // Keep toLowerCase for logic
                profileDisplayText = holidayTitle;
                serviceTypeDisplay = "(Saturday Service)";
            } else {
                profileDisplayText = holidayTitle;
                serviceTypeDisplay = "(Sunday Service)";
            }
        }

        let dayName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][now.getDay()];

        if (!isBankHol) {
            profileDisplayText = dayName;
            if (isSchoolHolidayPeriod_ExtraPage(now)) { 
                profileDisplayText += " (School Holiday)";
            }
        } else {
            profileDisplayText += ` ${serviceTypeDisplay} - Observed on a ${dayName}`;
            if (isSchoolHolidayPeriod_ExtraPage(now)) {
                profileDisplayText += " (School Holiday Period)";
            }
        }
        operatingCodes = getOperatingCodesForDate_ExtraPage(now); 
    }

    if (currentProfileDisplayElement_el) {
        if (isOverridden) {
            currentProfileDisplayElement_el.textContent = `${finalDisplayLabel} ${profileDisplayText}`;
        } else {
            const codesString = operatingCodes.length > 0 ? ` [Codes: ${operatingCodes.join(', ')}]` : " [Codes: N/A]";
            currentProfileDisplayElement_el.textContent = `${finalDisplayLabel} ${profileDisplayText}${codesString}`;
        }
    }
}

        // --- Day Profile Override Functions ---
        async function loadAndDisplayOverrides_ExtraPage() { if (!activeOverridesList_el_extra || !window.firebaseOMSI) return; activeOverridesList_el_extra.innerHTML = '<p>Loading active overrides...</p>'; const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const snapshot = await dbGet(dbChild(dbRef(database), FB_PATH_OPERATIONAL_OVERRIDES)); let html = ""; if (snapshot.exists()) { const overrides = snapshot.val(); const today = new Date(); today.setHours(0,0,0,0); const thirtyDaysLater = new Date(today); thirtyDaysLater.setDate(today.getDate() + 90); const relevantOverrides = []; for (const dateKey in overrides) { if (/^\d{4}-\d{2}-\d{2}$/.test(dateKey)) { const overrideDate = new Date(dateKey + "T00:00:00"); if (overrideDate >= today && overrideDate <= thirtyDaysLater) { relevantOverrides.push({ date: dateKey, profile: overrides[dateKey] }); } } } relevantOverrides.sort((a,b) => a.date.localeCompare(b.date)); if (relevantOverrides.length > 0) { html = "<ul>"; relevantOverrides.forEach(ov => { html += `<li><strong>${formatDateToDDMonthYYYY_ExtraPage(ov.date)}:</strong> ${ov.profile}</li>`; }); html += "</ul>"; } else { html = "<p>No overrides set for the next 30 days.</p>"; } } else { html = "<p>No overrides currently set in the system.</p>"; } activeOverridesList_el_extra.innerHTML = html; } catch (error) { console.error("Error loading overrides:", error); activeOverridesList_el_extra.innerHTML = "<p>Error loading overrides.</p>"; } }
        
async function updateSelectedDateInfo_ExtraPage() {
    if (!overrideDateInput_el_extra || !selectedDateDisplay_el_extra || !autoProfileForSelectedDate_el_extra || !currentOverrideForSelectedDate_el_extra || !clearOverrideButton_el_extra) return;
    const selectedDateStr = overrideDateInput_el_extra.value;
    clearOverrideButton_el_extra.style.display = 'none';

    // Clear DPO checkboxes before updating
    dpo_clearProfileSelections_ExtraPage(); 

    if (!selectedDateStr) {
        selectedDateDisplay_el_extra.textContent = "(select a date)";
        autoProfileForSelectedDate_el_extra.textContent = "(select a date)";
        currentOverrideForSelectedDate_el_extra.textContent = "(select a date)";
        // dpo_clearProfileSelections_ExtraPage(); // Already called above
        return;
    }
    selectedDateDisplay_el_extra.textContent = formatDateToDDMonthYYYY_ExtraPage(selectedDateStr);
    const dateObj = new Date(selectedDateStr + "T00:00:00");
    const autoCodes = getOperatingCodesForDate_ExtraPage(dateObj); // Ensure this uses RSG_OPERATING_PROFILES_LIST if DPO one isn't separate
    autoProfileForSelectedDate_el_extra.textContent = autoCodes.join(', ') || "N/A";

    if (window.firebaseOMSI) {
        const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
        try {
            const overrideSnap = await dbGet(dbChild(dbRef(database), `${FB_PATH_OPERATIONAL_OVERRIDES}/${selectedDateStr}`));
            if (overrideSnap.exists()) {
                const overrideProfileString = overrideSnap.val();
                currentOverrideForSelectedDate_el_extra.textContent = overrideProfileString;
                currentOverrideForSelectedDate_el_extra.style.color = "#f1c40f";
                clearOverrideButton_el_extra.style.display = 'inline-block';
                dpo_setCheckedProfiles_ExtraPage(overrideProfileString); // << MODIFIED: Set checkboxes
            } else {
                currentOverrideForSelectedDate_el_extra.textContent = "(none)";
                currentOverrideForSelectedDate_el_extra.style.color = "";
                // dpo_clearProfileSelections_ExtraPage(); // Already called at the top
            }
        } catch (error) {
            console.error("Error fetching override for selected date:", error);
            currentOverrideForSelectedDate_el_extra.textContent = "(error fetching)";
            // dpo_clearProfileSelections_ExtraPage(); // Already called at the top
        }
    }
}
        async function handleSetOverride_ExtraPage() {
            // --- START: Added Debugging ---
            console.log("DPO Set Action: Attempting to set override.");
            if (window.firebaseOMSI && window.firebaseOMSI.auth) {
                const authInstance = window.firebaseOMSI.auth;
                console.log("DPO Set Action: Firebase SDK auth.currentUser UID:", authInstance.currentUser ? authInstance.currentUser.uid : "SDK auth.currentUser is null");
            }
            console.log("DPO Set Action: currentUser_extra variable UID:", currentUser_extra ? currentUser_extra.uid : "currentUser_extra is null");
            console.log("DPO Set Action: Expected Admin UID for write:", 'PBVTn1GvcAfIZWNLzuP1brUtJDu1');
            // --- END: Added Debugging ---

            if (!currentUser_extra || !overrideDateInput_el_extra /* Ensure overrideProfileInput_el_extra is removed if using DPO checkboxes */ || !overrideStatusMessage_el_extra || !window.firebaseOMSI) { 
                if (overrideStatusMessage_el_extra) {
                    overrideStatusMessage_el_extra.textContent = "Error: System not ready or not logged in."; 
                    overrideStatusMessage_el_extra.style.color="#e74c3c";
                }
                console.error("DPO Set: Prerequisite check failed (currentUser_extra, DOM elements for date/status, or Firebase).");
                return; 
            }

            const dateKey = overrideDateInput_el_extra.value;
            const profile = dpo_getSelectedOpProfilesString_ExtraPage(); // Gets profile from DPO checkboxes

            if (!dateKey) { 
                overrideStatusMessage_el_extra.textContent = "Please select a date."; 
                overrideStatusMessage_el_extra.style.color="#e74c3c"; 
                return; 
            }
            if (!profile) { 
                overrideStatusMessage_el_extra.textContent = "Please select an override profile using the checkboxes."; 
                overrideStatusMessage_el_extra.style.color="#e74c3c"; 
                return; 
            }

            const { database, dbSet, dbRef } = window.firebaseOMSI; 
            try {
                console.log(`DPO Set: Attempting Firebase write to /operationalOverrides/${dateKey} with profile: "${profile}"`);
                await dbSet(dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${dateKey}`), profile);
                
                overrideStatusMessage_el_extra.textContent = `Override for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)} set to "${profile}".`;
                overrideStatusMessage_el_extra.style.color="#2ecc71";
                
                if (typeof loadAndDisplayOverrides_ExtraPage === 'function') loadAndDisplayOverrides_ExtraPage();
                if (typeof updateSelectedDateInfo_ExtraPage === 'function') updateSelectedDateInfo_ExtraPage(); 
                
                if (dateKey === getYYYYMMDD_ExtraPage(new Date())) { // If today's date was overridden
                    if (typeof updateCurrentProfileDisplay_ExtraPage === 'function') await updateCurrentProfileDisplay_ExtraPage();    
                }
            } catch (error) {
                console.error("DPO Set: Error setting override:", error); 
                overrideStatusMessage_el_extra.textContent = "Error setting override: " + error.message; // This will show Firebase permission denied
                overrideStatusMessage_el_extra.style.color="#e74c3c";
            } 
        }

async function handleClearOverride_ExtraPage() {
            // --- START: Added Debugging ---
            console.log("DPO Clear Action: Attempting to clear override.");
            if (window.firebaseOMSI && window.firebaseOMSI.auth) {
                const authInstance = window.firebaseOMSI.auth;
                console.log("DPO Clear Action: Firebase SDK auth.currentUser UID:", authInstance.currentUser ? authInstance.currentUser.uid : "SDK auth.currentUser is null");
            }
            console.log("DPO Clear Action: currentUser_extra variable UID:", currentUser_extra ? currentUser_extra.uid : "currentUser_extra is null");
            console.log("DPO Clear Action: Expected Admin UID for write:", 'PBVTn1GvcAfIZWNLzuP1brUtJDu1');
            // --- END: Added Debugging ---

            if (!currentUser_extra || !overrideDateInput_el_extra || !overrideStatusMessage_el_extra || !window.firebaseOMSI) {
                if (overrideStatusMessage_el_extra) {
                    overrideStatusMessage_el_extra.textContent = "Error: System not ready or not logged in for clear.";
                    overrideStatusMessage_el_extra.style.color="#e74c3c";
                }
                console.error("DPO Clear: Prerequisite check failed.");
                return;
            }
            const dateKey = overrideDateInput_el_extra.value;
            if (!dateKey) {
                overrideStatusMessage_el_extra.textContent = "Please select a date to clear its override.";
                overrideStatusMessage_el_extra.style.color="#e74c3c";
                return;
            }

            // Check if an override actually exists for this date before confirming deletion
            const { database, dbGet, dbRemove, dbRef, dbChild } = window.firebaseOMSI;
            const overrideRef = dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${dateKey}`);
            const currentOverrideSnap = await dbGet(overrideRef);

            if (!currentOverrideSnap.exists()) {
                overrideStatusMessage_el_extra.textContent = `No override found for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)} to clear.`;
                overrideStatusMessage_el_extra.style.color="#f1c40f";
                if (clearOverrideButton_el_extra) clearOverrideButton_el_extra.style.display = 'none'; // Hide button if nothing to clear
                dpo_clearProfileSelections_ExtraPage(); // Clear checkboxes as well
                return;
            }

            if (!confirm(`Are you sure you want to clear the override for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)}?`)) {
                overrideStatusMessage_el_extra.textContent = "Clear override cancelled.";
                overrideStatusMessage_el_extra.style.color="#7f8c8d";
                return;
            }
            
            try {
                console.log(`DPO Clear: Attempting Firebase remove for /operationalOverrides/${dateKey}`);
                await dbRemove(overrideRef); // Use the ref directly
                
                overrideStatusMessage_el_extra.textContent = `Override for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)} cleared.`;
                overrideStatusMessage_el_extra.style.color="#2ecc71";
                
                // This is the crucial call to ensure checkboxes are cleared
                dpo_clearProfileSelections_ExtraPage(); 
                
                loadAndDisplayOverrides_ExtraPage(); // Refresh the list of active overrides
                updateSelectedDateInfo_ExtraPage();  // Update the display for the selected date
                
                // If today's date was cleared, refresh the main profile display
                if (dateKey === getYYYYMMDD_ExtraPage(new Date())) {
                    await updateCurrentProfileDisplay_ExtraPage();    
                }
            } catch (error) {
                console.error("DPO Clear: Error clearing override:", error);
                overrideStatusMessage_el_extra.textContent = "Error clearing override: " + error.message; 
                overrideStatusMessage_el_extra.style.color="#e74c3c";
            }
        }

        // Make sure the second, shorter definition of handleClearOverride_ExtraPage (previously around lines 1136-1149)
        // is REMOVED from your file.


        // --- Ancillary Data Save Function ---
        async function updateAncillaryScheduleData_ExtraPage() {
            if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available for ancillary data update.");
            const { database, dbSet, dbUpdate, dbRef } = window.firebaseOMSI;

            // 1. Regenerate uniqueBusStops from the current in-memory flat schedule
            const stopsMap = new Map();
            currentWorkingSchedule_extra.forEach(row => {
                if (row.stopID && !stopsMap.has(row.stopID.toUpperCase())) {
                    stopsMap.set(row.stopID.toUpperCase(), { stopID: row.stopID, stopName: row.stopName, direction: row.direction });
                }
            });
            const finalUniqueStops = Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase()));

            try {
                console.log("Attempting to save unique bus stops (ancillary)...");
                await dbSet(dbRef(database, FB_PATH_LIVE_UNIQUE_STOPS), finalUniqueStops);
                console.log("Unique bus stops saved. Attempting to save last updated timestamp (ancillary)...");
                await dbUpdate(dbRef(database), { [FB_PATH_APPSTATE_LAST_UPDATED]: new Date().toISOString() });
                console.log("Ancillary schedule data (unique stops, timestamp) updated.");
            } catch (error) {
                console.error("Error saving ancillary schedule data:", error);
                // Decide if this error should be propagated or just logged
                throw error; // Propagate for now
            }
        }

        // --- REBUILDS ENTIRE SCHEDULE in new structured format ---
        async function rebuildAndSaveEntireScheduleToFirebase_ExtraPage(flatScheduleDataToSave) {
    if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available.");
    const { database, dbSet, dbRef } = window.firebaseOMSI;

    console.log("Rebuilding entire schedule into new nested structure (in memory)...");
    const newSchedulesByRoute = {}; // This object will be built in memory first
    flatScheduleDataToSave.forEach(entry => {
        if (!entry.lineName || !entry.OperatingProfile || !entry.destinationName) {
            console.warn("Skipping entry with missing route/profile/destination:", entry);
            return;
        }
        const saneRoute = sanitizeFirebaseKey(entry.lineName);
        const saneProfile = sanitizeFirebaseKey(entry.OperatingProfile);
        const saneDest = sanitizeFirebaseKey(entry.destinationName);

        if (!newSchedulesByRoute[saneRoute]) newSchedulesByRoute[saneRoute] = {};
        if (!newSchedulesByRoute[saneRoute][saneProfile]) newSchedulesByRoute[saneRoute][saneProfile] = {};
        if (!newSchedulesByRoute[saneRoute][saneProfile][saneDest]) newSchedulesByRoute[saneRoute][saneProfile][saneDest] = { entries: [] };
        
        const entryForStorage = { ...entry };
        // Ensure these key fields are present in the stored entry, even if they were part of the key structure
        entryForStorage.lineName = entry.lineName;
        entryForStorage.OperatingProfile = entry.OperatingProfile;
        entryForStorage.destinationName = entry.destinationName;

        newSchedulesByRoute[saneRoute][saneProfile][saneDest].entries.push(entryForStorage);
    });

    // Sort entries within each R/P/D for consistency
    for (const routeKey in newSchedulesByRoute) {
        for (const profileKey in newSchedulesByRoute[routeKey]) {
            for (const destKey in newSchedulesByRoute[routeKey][profileKey]) {
                newSchedulesByRoute[routeKey][profileKey][destKey].entries.sort((a, b) => {
                    const timeA = (a.scheduledTime || "9999").replace(':', ''); // Use a sortable time format
                    const timeB = (b.scheduledTime || "9999").replace(':', '');
                    const timeCompare = timeA.localeCompare(timeB);
                    if (timeCompare !== 0) return timeCompare;
                    // Optional: Add secondary sort criteria if needed, e.g., by stopName or internalId
                    return (a.stopName || "").localeCompare(b.stopName || "");
                });
            }
        }
    }
    
    try {
        console.log(`Attempting to save schedule to Firebase using PER-ROUTE writes. Total routes: ${Object.keys(newSchedulesByRoute).length}`);
        
        const writePromises = [];

        // Clear the entire schedulesByRoute path first to ensure a clean slate.
        // This is a single delete operation for the parent path.
        console.log(`Clearing existing data at ${FB_PATH_SCHEDULES_BY_ROUTE} before writing new data...`);
        await dbSet(dbRef(database, FB_PATH_SCHEDULES_BY_ROUTE), null);
        console.log(`Path ${FB_PATH_SCHEDULES_BY_ROUTE} cleared.`);

        // Now write each route's data individually
        for (const saneRoute in newSchedulesByRoute) {
            if (Object.hasOwnProperty.call(newSchedulesByRoute, saneRoute)) { // Ensure it's an own property
                const routeData = newSchedulesByRoute[saneRoute];
                const routePath = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}`;
                console.log(`Writing data for route: ${saneRoute} to path: ${routePath}`);
                writePromises.push(dbSet(dbRef(database, routePath), routeData));
            }
        }

        await Promise.all(writePromises);
        console.log("Entire schedule saved successfully to Firebase using per-route writes.");

        // After a full rebuild, also update ancillary data
        await updateAncillaryScheduleData_ExtraPage(); // Uses the global currentWorkingSchedule_extra

    } catch (error) {
        console.error("Error saving entire rebuilt schedule with per-route writes:", error);
        // This error will be propagated to the calling function (e.g., handleBulkAddStops_ExtraPage)
        // which should then inform the user via its status message element.
        throw error; 
    }
}


        // --- Stop Management Functions ---
        function getBaseStopName_ExtraPage(fullStopName) { if (!fullStopName) return ""; let baseName = String(fullStopName).trim(); baseName = baseName.replace(/\s*\(Stand [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\(Bay [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\(Stop [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\([A-Z0-9]\)\s*$/i, ''); baseName = baseName.replace(/\s*-\s*Bay\s*[A-Z0-9]+\s*$/i,''); baseName = baseName.replace(/\s*Stop\s*[A-Z0-9]+\s*$/i,''); return baseName.trim(); }
        function getRandomIdFormat_ExtraPage() { const formats = ["NUM", "BP", "LE", "RO"]; return formats[Math.floor(Math.random() * formats.length)]; }
        function generateUniqueStopId_ExtraPage(format, stopName = "", allExistingStopIDsSet) { const targetBaseName = getBaseStopName_ExtraPage(stopName).toUpperCase(); let prefix = ""; let numericRegex; let baseStartNumber = 1; const MAX_NUMERIC_PART = 99999; switch (format) { case "NUM": prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; case "BP": prefix = "BP"; numericRegex = /^BP(\d+)$/; baseStartNumber = 1; break; case "LE": prefix = "LE"; numericRegex = /^LE(\d+)$/; baseStartNumber = 1; break; case "RO": prefix = "RO"; numericRegex = /^RO(\d+)$/; baseStartNumber = 1; break; default: console.warn(`generateUniqueStopId_ExtraPage: Unknown format "${format}", defaulting to NUM.`); format="NUM"; prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; if (/^[A-Z]+$/.test(format)) {prefix = format.toUpperCase(); numericRegex = new RegExp(`^${prefix}(\\d+)$`); baseStartNumber = 1;} break; } let highestNumInNameSequence = 0; let nameSpecificSequenceFound = false; if (targetBaseName && currentWorkingSchedule_extra) { currentWorkingSchedule_extra.forEach(entry => { if (entry.stopName && entry.stopID) { const existingEntryBaseName = getBaseStopName_ExtraPage(entry.stopName).toUpperCase(); if (existingEntryBaseName === targetBaseName) { const match = entry.stopID.toUpperCase().match(numericRegex); if (match && match[1]) { const numPart = parseInt(match[1], 10); if (!isNaN(numPart) && numPart <= MAX_NUMERIC_PART && numPart > highestNumInNameSequence) { highestNumInNameSequence = numPart; } nameSpecificSequenceFound = true; } } } }); } let nextNumInSequence = nameSpecificSequenceFound ? highestNumInNameSequence + 1 : baseStartNumber; if (format === "NUM" && nextNumInSequence < 101) nextNumInSequence = 101; if (baseStartNumber > MAX_NUMERIC_PART) { console.warn(`Suggest ID (single): Base start ${baseStartNumber} for ${format} exceeds MAX. Fallback.`); return prefix + "MAX_S_ERR" + Math.floor(Math.random()*1000); } let attempts = 0; const maxAttempts = MAX_NUMERIC_PART + 2000; let candidateId = ""; while (attempts < maxAttempts) { if (nextNumInSequence > MAX_NUMERIC_PART) { console.warn(`Suggest ID (single): All numbers up to ${MAX_NUMERIC_PART} exhausted for ${prefix}, base ${targetBaseName}. Fallback.`); let fA = 0, fId; do { fId = prefix + "RND" + String(Date.now()).slice(-3) + (Math.floor(Math.random()*900)+100); fA++; if (fA > 50) return prefix + "FB_FAIL" + Math.floor(Math.random()*1000); } while (allExistingStopIDsSet.has(fId.toUpperCase())); return fId; } candidateId = prefix + nextNumInSequence; if (!allExistingStopIDsSet.has(candidateId.toUpperCase())) return candidateId; nextNumInSequence++; attempts++; } console.warn(`CRITICAL: Could not generate unique Stop ID for ${format}, name: "${stopName}". Final fallback.`); let fA2 = 0, fId2; do { fId2 = prefix + "ULTRA_FB" + String(Date.now()).slice(-5) + (Math.floor(Math.random()*90)+10); fA2++; if (fA2 > 50) return prefix + "ULTRA_CRIT_FAIL" + Math.floor(Math.random()*100); } while (allExistingStopIDsSet.has(fId2.toUpperCase())); return fId2; }
        function autoGenerateAndSetNewStopId_ExtraPage() { if (!currentUser_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !selectNewStopIdFormat_el_extra) return; const currentStopName = inputNewStopName_el_extra.value.trim(); if (!currentStopName) { inputNewStopId_el_extra.value = ""; selectNewStopIdFormat_el_extra.selectedIndex = 0; if(addNewStopStatus_el_extra) {addNewStopStatus_el_extra.textContent = "Enter stop name for ID suggestion."; addNewStopStatus_el_extra.style.color = "";} if (newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = ''; return; } const actualBaseName = getBaseStopName_ExtraPage(currentStopName).toUpperCase(); let formatToUse = null; if (actualBaseName && currentWorkingSchedule_extra && currentWorkingSchedule_extra.length > 0) { for (const existingEntry of currentWorkingSchedule_extra) { if (existingEntry.stopID && existingEntry.stopName) { const existingEntryBaseName = getBaseStopName_ExtraPage(existingEntry.stopName).toUpperCase(); if (existingEntryBaseName === actualBaseName) { const existingId = existingEntry.stopID.toUpperCase(); if (existingId.startsWith("BP") && /BP\d+/.test(existingId)) formatToUse = "BP"; else if (existingId.startsWith("LE") && /LE\d+/.test(existingId)) formatToUse = "LE"; else if (existingId.startsWith("RO") && /RO\d+/.test(existingId)) formatToUse = "RO"; else if (/^\d+$/.test(existingId) && parseInt(existingId, 10) >= 100) formatToUse = "NUM"; if (formatToUse) break; } } } } if (!formatToUse) formatToUse = getRandomIdFormat_ExtraPage(); selectNewStopIdFormat_el_extra.value = formatToUse; const allCurrentScheduleIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase())); const suggestedId = generateUniqueStopId_ExtraPage(formatToUse, currentStopName, allCurrentScheduleIDs); inputNewStopId_el_extra.value = suggestedId; inputNewStopId_el_extra.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })); if (addNewStopStatus_el_extra) { addNewStopStatus_el_extra.textContent = `Auto-suggested ID: ${suggestedId} (Format: "${formatToUse}").`; addNewStopStatus_el_extra.style.color = '#bdc3c7'; } }
        async function handleAddStopDetails_ExtraPage() {
            if (!currentUser_extra || !addNewStopStatus_el_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !inputNewStopDirection_el_extra) return;
            const newStopID = inputNewStopId_el_extra.value.trim().toUpperCase();
            const newStopName = inputNewStopName_el_extra.value.trim();
            const newStopDirection = inputNewStopDirection_el_extra.value.trim();
            if (!newStopID) { addNewStopStatus_el_extra.textContent = "New Stop ID is required."; addNewStopStatus_el_extra.style.color = '#e74c3c'; inputNewStopId_el_extra.focus(); return; }
            if (!/^[A-Z0-9]+$/.test(newStopID)) { addNewStopStatus_el_extra.textContent = "Stop ID: A-Z, 0-9 only."; addNewStopStatus_el_extra.style.color = '#e74c3c'; inputNewStopId_el_extra.focus(); return; }
            if (!newStopName) { addNewStopStatus_el_extra.textContent = "New Stop Name is required."; addNewStopStatus_el_extra.style.color = '#e74c3c'; inputNewStopName_el_extra.focus(); return; }
            const existingStopIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase()));
            if (existingStopIDs.has(newStopID)) { addNewStopStatus_el_extra.textContent = `Stop ID "${newStopID}" already exists.`; if(newStopIdAvailability_el_extra){ newStopIdAvailability_el_extra.textContent = 'ID already exists.'; newStopIdAvailability_el_extra.style.color = '#e74c3c'; } inputNewStopId_el_extra.focus(); return; }
            const newStopDefinitionForFlatList = {
                internalId: `${newStopID}_definition_${Date.now()}`, // Unique internal ID for processing the flat list
                stopID: newStopID,
                stopName: newStopName,
                direction: newStopDirection
                // No lineName, destinationName, scheduledTime, OperatingProfile, DayOffset
            };
            currentWorkingSchedule_extra.push(newStopDefinitionForFlatList);
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
                addNewStopStatus_el_extra.textContent = `Stop "${newStopID} - ${newStopName}" definition placeholder added. Save successful.`;
                addNewStopStatus_el_extra.style.color = '#2ecc71';
                inputNewStopId_el_extra.value = ''; inputNewStopName_el_extra.value = ''; inputNewStopDirection_el_extra.value = '';
                if(newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = '';
                if(selectNewStopIdFormat_el_extra) selectNewStopIdFormat_el_extra.selectedIndex = 0;
                autoGenerateAndSetNewStopId_ExtraPage();
                renderUIDependentElements_ExtraPage();
            } catch (error) {
                console.error("Error adding new stop definition:", error);
                addNewStopStatus_el_extra.textContent = "Error saving stop definition: " + error.message;
                addNewStopStatus_el_extra.style.color = '#e74c3c';
                // currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => entry.internalId !== placeholderEntry.internalId); // placeholderEntry was not defined here
                currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => entry.internalId !== newStopDefinitionForFlatList.internalId);

            }
        }
        function generateUniqueStopId_ExtraPage_BulkAware(format, stopName, newlyGeneratedIDsInBatchSet, baseNameAndFormatToGeneratedNumericPartsMap) { const targetBaseName = getBaseStopName_ExtraPage(stopName).toUpperCase(); let prefix = ""; let numericRegex; let baseStartNumber = 1; const MAX_NUMERIC_PART = 99999; switch (format) { case "NUM": prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; case "BP": prefix = "BP"; numericRegex = /^BP(\d+)$/; baseStartNumber = 1; break; case "LE": prefix = "LE"; numericRegex = /^LE(\d+)$/; baseStartNumber = 1; break; case "RO": prefix = "RO"; numericRegex = /^RO(\d+)$/; baseStartNumber = 1; break; default: console.warn(`generateUniqueStopId_ExtraPage_BulkAware (Replace Mode): Unknown format "${format}" for "${stopName}". Defaulting to NUM.`); format = "NUM"; prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; } const keyForMap = `${targetBaseName}_${format}`; if (!baseNameAndFormatToGeneratedNumericPartsMap.has(keyForMap)) { baseNameAndFormatToGeneratedNumericPartsMap.set(keyForMap, new Set()); } const numericPartsForThisGroup = baseNameAndFormatToGeneratedNumericPartsMap.get(keyForMap); let highestNumInGroup = 0; numericPartsForThisGroup.forEach(numStr => { const num = parseInt(numStr, 10); if (!isNaN(num) && num > highestNumInGroup) highestNumInGroup = num; }); let nextNumInSequence = highestNumInGroup > 0 ? highestNumInGroup + 1 : baseStartNumber; if (format === "NUM" && nextNumInSequence < 101) nextNumInSequence = 101; if (baseStartNumber > MAX_NUMERIC_PART) { console.warn(`BulkAware (Replace): Base start ${baseStartNumber} for ${format} exceeds MAX. Fallback.`); return prefix + "B_MAX_S_ERR" + Math.floor(Math.random()*1000); } let attempts = 0; const maxAttempts = MAX_NUMERIC_PART + 2000; let candidateId = ""; while (attempts < maxAttempts) { if (nextNumInSequence > MAX_NUMERIC_PART) { console.warn(`BulkAware (Replace): All numbers up to ${MAX_NUMERIC_PART} exhausted for ${prefix}, base ${targetBaseName}. Fallback.`); let fA = 0, fId; do { fId = prefix + "BRND" + String(Date.now()).slice(-4) + (Math.floor(Math.random()*900)+100); fA++; if (fA > 50) return prefix + "B_FB_FAIL" + Math.floor(Math.random()*1000); } while (newlyGeneratedIDsInBatchSet.has(fId.toUpperCase())); return fId; } candidateId = prefix + nextNumInSequence; if (!newlyGeneratedIDsInBatchSet.has(candidateId.toUpperCase())) { const match = candidateId.match(numericRegex); if(match && match[1]) numericPartsForThisGroup.add(match[1]); return candidateId; } nextNumInSequence++; attempts++; } console.warn(`CRITICAL_BULK (Replace): Could not generate unique Stop ID for ${format}, name: "${stopName}". Final fallback.`); let fA2 = 0, fId2; do { fId2 = prefix + "B_ULTRA_FB" + String(Date.now()).slice(-5) + (Math.floor(Math.random()*9000)+1000); fA2++; if (fA2 > 50) throw new Error("Bulk Fallback ID gen failed catastrophically."); } while (newlyGeneratedIDsInBatchSet.has(fId2.toUpperCase())); return fId2; }
        async function handleBulkAddStops_ExtraPage() {
            if (!currentUser_extra) { alert("Log in."); if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="Not logged in."; bulkAddNewStopsStatus_el_extra.style.color="#e74c3c";} return; }
            const stopsToProcessFromExcel = processedExcelStopsData_extra;
            if (!stopsToProcessFromExcel || stopsToProcessFromExcel.length === 0) { if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="No Excel data processed."; bulkAddNewStopsStatus_el_extra.style.color="#f1c40f";} return; }
            if (!confirm(`DANGER! This will DELETE ALL existing schedules and then add ${stopsToProcessFromExcel.length} stop definition(s) from Excel. This action CANNOT BE UNDONE. Proceed?`)) { if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="Bulk replace operation cancelled."; bulkAddNewStopsStatus_el_extra.style.color="#7f8c8d";} return; }
            if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = `Replacing all stops with ${stopsToProcessFromExcel.length} definitions from file...`; bulkAddNewStopsStatus_el_extra.style.color = '#f1c40f'; }
            let newFlatScheduleEntries = []; const newlyGeneratedOrUsedIDsInThisBatch = new Set(); const baseNameToFormatMapForThisBatch = new Map(); const baseNameAndFormatToGeneratedNumericPartsMap = new Map(); let errorsEncountered = 0; let totalPlaceholdersCreated = 0; let uniqueStopIDsAddedCount = 0; let statusMessages = [`Starting bulk replacement (Excel rows: ${stopsToProcessFromExcel.length})...\n`];
            for (const stopData of stopsToProcessFromExcel) {
                const excelStopName = (stopData.stopName || "").trim(); const excelDirection = (stopData.direction || "").trim(); const excelUserProvidedStopID = (stopData.userProvidedStopID || "").trim(); const excelBaseName = getBaseStopName_ExtraPage(excelStopName).toUpperCase();
                let excelLineNames = (stopData.lineNameInput && stopData.lineNameInput.trim() !== "") ? stopData.lineNameInput.split(',').map(ln => ln.trim().toUpperCase()).filter(ln => ln !== "") : ["INFO_ONLY"];
                if (excelLineNames.length === 0) excelLineNames = ["INFO_ONLY"];
                if (!excelStopName && !excelUserProvidedStopID) { statusMessages.push(`Row ${stopData.originalLineNumber}: Skipped. StopName or StopID required.`); errorsEncountered++; continue; }
                let finalStopID = ""; let idSourceMessage = ""; let chosenFormatForThisStop = "";
                if (excelUserProvidedStopID) { 
                    const providedIDUpper = excelUserProvidedStopID.toUpperCase();
                    if (!/^[A-Z0-9]+$/.test(providedIDUpper)) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Provided StopID "${excelUserProvidedStopID}" invalid chars. Skipped.`); errorsEncountered++; continue; }
                    if (newlyGeneratedOrUsedIDsInThisBatch.has(providedIDUpper)) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Provided StopID "${excelUserProvidedStopID}" is duplicated within this Excel file. Skipped.`); errorsEncountered++; continue; }
                    finalStopID = excelUserProvidedStopID; idSourceMessage = "user-provided";
                    if (finalStopID.startsWith("BP")) chosenFormatForThisStop = "BP"; else if (finalStopID.startsWith("LE")) chosenFormatForThisStop = "LE"; else if (finalStopID.startsWith("RO")) chosenFormatForThisStop = "RO"; else if (/^\d+$/.test(finalStopID)) chosenFormatForThisStop = "NUM"; else chosenFormatForThisStop = "Custom";
                } else { if (baseNameToFormatMapForThisBatch.has(excelBaseName)) { chosenFormatForThisStop = baseNameToFormatMapForThisBatch.get(excelBaseName); } else { chosenFormatForThisStop = getRandomIdFormat_ExtraPage(); baseNameToFormatMapForThisBatch.set(excelBaseName, chosenFormatForThisStop); } finalStopID = generateUniqueStopId_ExtraPage_BulkAware(chosenFormatForThisStop, excelStopName, newlyGeneratedOrUsedIDsInThisBatch, baseNameAndFormatToGeneratedNumericPartsMap); idSourceMessage = `auto-gen (${chosenFormatForThisStop})`; }
                if (!finalStopID) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Failed to obtain a final StopID. Skipped.`); errorsEncountered++; continue;}
                newlyGeneratedOrUsedIDsInThisBatch.add(finalStopID.toUpperCase()); uniqueStopIDsAddedCount++;
                excelLineNames.forEach(ln => {
                    newFlatScheduleEntries.push({
                        internalId: `${finalStopID}_${ln.replace(/[^A-Z0-9]/ig, '')}_phReplace_${Date.now()}_${newFlatScheduleEntries.length}`,
                        stopID: finalStopID, stopName: excelStopName, direction: excelDirection, lineName: ln,
                        destinationName: "To Be Defined", OperatingProfile: "AllDays", scheduledTime: "00:00", DayOffset: "0"
                    });
                    totalPlaceholdersCreated++;
                });
                statusMessages.push(`Row ${stopData.originalLineNumber}: Processed "${excelStopName}" -> ID: ${finalStopID} [${idSourceMessage}]. Routes: ${excelLineNames.join(', ')}.`);
            }
            let finalSummaryParts = []; if (totalPlaceholdersCreated > 0) finalSummaryParts.push(`Prepared ${totalPlaceholdersCreated} placeholder schedule entries for ${uniqueStopIDsAddedCount} unique StopIDs from the file.`); if (errorsEncountered > 0) finalSummaryParts.push(`${errorsEncountered} row(s) from Excel skipped due to errors.`); if (newFlatScheduleEntries.length === 0 && errorsEncountered === 0) finalSummaryParts.push("No valid stop definitions found in the file to process."); statusMessages.push("\n--- Summary ---\n" + finalSummaryParts.join('\n')); if (bulkAddNewStopsStatus_el_extra) bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n');
            if (errorsEncountered > 0 && newFlatScheduleEntries.length > 0) { if (!confirm(`There were ${errorsEncountered} error(s) processing rows. However, ${newFlatScheduleEntries.length} placeholder entries are ready to REPLACE the entire schedule. Proceed?`)) { statusMessages.push("Bulk replacement aborted by user due to errors."); if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; } return; } statusMessages.push("Attempting to save successfully processed entries..."); }
            else if (newFlatScheduleEntries.length === 0) { if (bulkAddNewStopsStatus_el_extra) bulkAddNewStopsStatus_el_extra.style.color = errorsEncountered > 0 ? '#e74c3c' : '#f1c40f'; return; }
            currentWorkingSchedule_extra = newFlatScheduleEntries; closedStopIDs_extra = []; stopSpecificRouteColours_extra = {};
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
                await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                statusMessages.push(`\nSuccessfully REPLACED all schedules. Added ${totalPlaceholdersCreated} placeholder entries for ${uniqueStopIDsAddedCount} StopIDs to Firebase in the new structure.`);
                if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#2ecc71'; }
                if (fileInputBulkAddStops_el_extra) fileInputBulkAddStops_el_extra.value = '';
                if (fileNameBulkAddStops_el_extra) fileNameBulkAddStops_el_extra.textContent = 'No file selected.';
                processedExcelStopsData_extra = []; renderUIDependentElements_ExtraPage();
            } catch (error) {
                statusMessages.push("\nDATABASE ERROR: Error saving replaced schedule to Firebase!");
                if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; }
                console.error("Error bulk replacing stops and saving to Firebase:", error);
            }
        }
        function handleExcelFileForBulkAdd_ExtraPage(event) { const file = event.target.files[0]; if (!fileInputBulkAddStops_el_extra || !fileNameBulkAddStops_el_extra || !bulkAddNewStopsStatus_el_extra) return; if (!file) { fileNameBulkAddStops_el_extra.textContent = "No file selected."; processedExcelStopsData_extra = []; return; } fileNameBulkAddStops_el_extra.textContent = `Processing ${file.name}...`; bulkAddNewStopsStatus_el_extra.textContent = ""; processedExcelStopsData_extra = []; const reader = new FileReader(); reader.onload = function(e) { try { const data = new Uint8Array(e.target.result); const workbook = XLSX.read(data, {type: 'array'}); const firstSheetName = workbook.SheetNames[0]; const worksheet = workbook.Sheets[firstSheetName]; const jsonData = XLSX.utils.sheet_to_json(worksheet, {header:1, defval:''}); if (jsonData.length === 0) { bulkAddNewStopsStatus_el_extra.textContent = "Excel file empty or no data."; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileNameBulkAddStops_el_extra.textContent = `Error: ${file.name} is empty.`; fileInputBulkAddStops_el_extra.value = ''; return; } let validEntries = 0; let tempProcessedData = []; jsonData.forEach((row, index) => { if (!Array.isArray(row) || row.every(cell => String(cell).trim() === '')) return; const userProvidedStopID = String(row[0] || "").trim(); const stopName = String(row[1] || "").trim(); const direction = String(row[2] || "").trim(); const lineNameInput = String(row[3] || "").trim(); if (!stopName && !userProvidedStopID) { console.warn(`Skipping Excel row ${index + 1}: StopName and StopID both missing.`); return; } tempProcessedData.push({ originalLineNumber: index + 1, userProvidedStopID: userProvidedStopID, stopName: stopName, direction: direction, lineNameInput: lineNameInput }); validEntries++; }); processedExcelStopsData_extra = tempProcessedData; if (validEntries > 0) { fileNameBulkAddStops_el_extra.textContent = `${file.name} (${validEntries} valid rows ready).`; bulkAddNewStopsStatus_el_extra.textContent = `${validEntries} stop definitions processed. Ready for Bulk Replace operation.`; bulkAddNewStopsStatus_el_extra.style.color = '#2ecc71'; } else { fileNameBulkAddStops_el_extra.textContent = `No valid data in ${file.name}.`; bulkAddNewStopsStatus_el_extra.textContent = "No valid definitions (StopName/StopID required)."; bulkAddNewStopsStatus_el_extra.style.color = '#f1c40f'; fileInputBulkAddStops_el_extra.value = ''; } } catch (error) { console.error("Error processing Excel:", error); fileNameBulkAddStops_el_extra.textContent = `Error processing ${file.name}.`; bulkAddNewStopsStatus_el_extra.textContent = "Error processing Excel: " + error.message; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileInputBulkAddStops_el_extra.value = ''; } }; reader.onerror = () => { fileNameBulkAddStops_el_extra.textContent = "Error reading file."; bulkAddNewStopsStatus_el_extra.textContent = "Could not read file."; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileInputBulkAddStops_el_extra.value = ''; }; reader.readAsArrayBuffer(file); }
        
function populateMasterStopList_ExtraPage() {
            if (!masterStopListUL_el_extra || !masterStopListStatus_el_extra) return;
            
            // Ensure uniqueStopsMasterList_extra is up-to-date based on currentWorkingSchedule_extra
            uniqueStopsMasterList_extra = getUniqueStopsFromSchedule_ExtraPage(); 
            
            const filterText = masterStopListFilterInput_el_extra.value.toLowerCase().trim();
            masterStopListUL_el_extra.innerHTML = '';
            let displayedCount = 0;

            if (uniqueStopsMasterList_extra.length === 0) {
                masterStopListStatus_el_extra.textContent = 'No unique stops loaded.';
                masterStopListUL_el_extra.innerHTML = '<p style="text-align:center; padding:1rem; opacity:0.7;">No stops to display.</p>'; // Clearer message
                return;
            }

            uniqueStopsMasterList_extra.forEach(stop => {
                if (!stop || !stop.stopID) return;

                // --- Get serving routes from the pre-calculated map ---
                const servingRouteNamesArray = Array.from(stopToServingRoutesMap_extra.get(stop.stopID) || new Set());
                // --- End of logic to get serving routes ---

                const stopIdLower = stop.stopID.toLowerCase();
                const stopNameLower = (stop.stopName || "").toLowerCase();
                const stopDirectionLower = (stop.direction || "").toLowerCase();
                const isClosed = closedStopIDs_extra.includes(stop.stopID.toUpperCase());
                const closureStatus = isClosed ? "Closed" : "Open";

                if (filterText) {
                    const matchesStopId = stopIdLower.includes(filterText);
                    const matchesStopName = stopNameLower.includes(filterText);
                    const matchesDirection = stopDirectionLower.includes(filterText);
                    const matchesStatus = closureStatus.toLowerCase().includes(filterText);
                    const matchesRoute = servingRouteNamesArray.some(routeName => 
                        routeName.toLowerCase().includes(filterText)
                    );
                    if (!(matchesStopId || matchesStopName || matchesDirection || matchesStatus || matchesRoute)) {
                        return; 
                    }
                }
                
                displayedCount++;
                const li = document.createElement('li');
                li.classList.add('master-stop-list-item');
                li.dataset.originalStopid = stop.stopID;

                const originalInfoDiv = document.createElement('div');
                originalInfoDiv.classList.add('master-stop-original-info');

                let originalContent = `<span class="stop-name-master">${stop.stopName || 'N/A'}</span><br>
                                   <span class="stop-direction-master">Towards: ${stop.direction || 'N/A'}</span><br>
                                   <span class="stop-id-master">Stop ID: ${stop.stopID}</span>`;
                
                // Add closure status to the details grid
                originalContent += `<div class="master-stop-original-info .stop-details-grid" style="margin-top:0.3rem;">
                                        <span class="detail-label">Status:</span>
                                        <span class="detail-value ${isClosed ? 'status-closed' : 'status-open'}">${closureStatus}</span>
                                    </div>`;


                if (servingRouteNamesArray.length > 0) {
                    const sortedRouteNamesForDisplay = [...servingRouteNamesArray].sort(compareLineNames_ExtraPage);
                    originalContent += `<div class="serving-routes-container" style="margin-top:0.3rem;">`;
                    sortedRouteNamesForDisplay.slice(0, 10).forEach(lineName => {
                        const bgColor = getRouteTileColour_ExtraPage(lineName, stop.stopID);
                        const textColor = getTextColourForBackground_ExtraPage(bgColor);
                        originalContent += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor}; font-size:0.7em; padding:0.15em 0.4em;">${lineName}</span>`;
                    });
                    if (sortedRouteNamesForDisplay.length > 10) {
                        originalContent += `<span style="font-size:0.7em; opacity:0.8;">...and ${sortedRouteNamesForDisplay.length - 10} more.</span>`;
                    }
                    originalContent += `</div>`;
                }
                originalInfoDiv.innerHTML = originalContent;

                const newIdSectionDiv = document.createElement('div');
                newIdSectionDiv.classList.add('master-stop-new-id-section');
                const newIdLabel = document.createElement('label');
                newIdLabel.textContent = 'Propose New ID (optional):';
                const newIdInput = document.createElement('input');
                newIdInput.type = 'text';
                newIdInput.classList.add('schedule-generator-input', 'master-list-new-id-input');
                newIdInput.dataset.originalId = stop.stopID;
                newIdInput.placeholder = "Enter new ID, then Apply Bulk";
                newIdInput.value = stop.stopID; 

                const warningP = document.createElement('p');
                warningP.classList.add('master-list-row-warning');

                newIdInput.addEventListener('input', () => {
                    const enteredID = newIdInput.value.trim().toUpperCase();
                    warningP.textContent = ''; 
                    warningP.style.color = '#f39c12'; 

                    if (!enteredID) return; 
                    if (enteredID === stop.stopID.toUpperCase()) return;

                    if (!/^[A-Z0-9]+$/.test(enteredID)) {
                        warningP.textContent = 'Invalid chars in ID.';
                        return;
                    }
                    const allCurrentAndProposedIDs = new Set(uniqueStopsMasterList_extra.map(s => s.stopID.toUpperCase()));
                    document.querySelectorAll('#masterStopListUL_extra .master-list-new-id-input').forEach(inp => {
                        if (inp !== newIdInput) { 
                            const otherProposed = inp.value.trim().toUpperCase();
                            if (otherProposed && otherProposed !== inp.dataset.originalId.toUpperCase()) { 
                                allCurrentAndProposedIDs.add(otherProposed);
                            }
                        }
                    });

                    if (allCurrentAndProposedIDs.has(enteredID)) {
                        warningP.textContent = 'ID taken or proposed elsewhere!';
                    } else {
                        warningP.textContent = 'New ID available.';
                        warningP.style.color = '#2ecc71'; 
                    }
                });

                newIdSectionDiv.appendChild(newIdLabel);
                newIdSectionDiv.appendChild(newIdInput);
                newIdSectionDiv.appendChild(warningP);

                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('master-stop-actions');

                const editBtn = document.createElement('button');
                editBtn.className = 'button small-action';
                editBtn.textContent = 'Edit Name / Direction';
                editBtn.addEventListener('click', () => handleEditStopFromMasterList_ExtraPage(stop.stopID, stop.stopName, stop.direction));

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'button small-action secondary';
                deleteBtn.textContent = 'Delete Stop';
                deleteBtn.addEventListener('click', () => handleDeleteStopFromMasterList_ExtraPage(stop.stopID));

                const toggleBtn = document.createElement('button');
                toggleBtn.className = `button small-action ${isClosed ? "save" : "secondary"}`; 
                toggleBtn.textContent = isClosed ? "Reopen Stop" : "Close Stop";
                toggleBtn.addEventListener('click', () => handleToggleStopStatusFromMasterList_ExtraPage(stop.stopID));

                actionsDiv.appendChild(editBtn);
                actionsDiv.appendChild(deleteBtn);
                actionsDiv.appendChild(toggleBtn);

                li.appendChild(originalInfoDiv);
                li.appendChild(newIdSectionDiv);
                li.appendChild(actionsDiv);
                masterStopListUL_el_extra.appendChild(li);
            });
            
            if (displayedCount === 0 && uniqueStopsMasterList_extra.length > 0 && filterText) {
                 masterStopListUL_el_extra.innerHTML = `<p style="text-align:center; padding:1rem; opacity:0.7;">No stops match your filter "${filterText}".</p>`;
            }


            masterStopListStatus_el_extra.textContent = `Showing ${displayedCount} of ${uniqueStopsMasterList_extra.length} unique stops. ${filterText ? `Filter active: "${filterText}"` : ''}`;
        }
        async function handleToggleStopStatusFromMasterList_ExtraPage(stopID) { if (!currentUser_extra) { alert("Log in."); return; } const stopIdUpper = stopID.toUpperCase(); const idx = closedStopIDs_extra.indexOf(stopIdUpper); if (idx === -1) closedStopIDs_extra.push(stopIdUpper); else closedStopIDs_extra.splice(idx, 1); try { await saveClosedStopsToFirebase_ExtraPage(); const status = idx === -1 ? "closed" : "reopened"; alert(`Stop "${stopID}" marked ${status}.`); populateMasterStopList_ExtraPage(); } catch (error) { alert("Error saving status: " + error.message); if (idx === -1) closedStopIDs_extra.pop(); else closedStopIDs_extra.splice(idx, 0, stopIdUpper); } }
        async function handleApplyMasterListStopIdChangesButton_ExtraPage() {
            if (!currentUser_extra || !masterStopListUL_el_extra || !masterListApplyChangesStatus_el_extra) return;
            masterListApplyChangesStatus_el_extra.textContent = "Processing ID changes..."; masterListApplyChangesStatus_el_extra.style.color = '#f1c40f';
            const idChangeProposals = []; const allInputs = masterStopListUL_el_extra.querySelectorAll('.master-list-new-id-input'); let hasErrors = false; const newProposedIDsInThisBatch = new Set();
            allInputs.forEach(input => { 
                const originalId = input.dataset.originalId; const newId = input.value.trim().toUpperCase(); const warningElement = input.parentElement.querySelector('.master-list-row-warning'); if (warningElement) warningElement.textContent = ''; if (newId && newId !== originalId.toUpperCase()) { if (!/^[A-Z0-9]+$/.test(newId)) { if(warningElement) warningElement.textContent = "Invalid chars!"; hasErrors = true; return; } if (newProposedIDsInThisBatch.has(newId)) { if(warningElement) warningElement.textContent = "Duplicate New ID!"; hasErrors = true; return; } const existingStopConflict = currentWorkingSchedule_extra.some(e => e.stopID.toUpperCase() === newId && !Array.from(allInputs).some(inp => inp.dataset.originalId.toUpperCase() === newId)); if (existingStopConflict) { if(warningElement) warningElement.textContent = "Conflicts existing ID!"; hasErrors = true; return; } idChangeProposals.push({ originalId: originalId, newId: newId }); newProposedIDsInThisBatch.add(newId); }
            });
            if (hasErrors) { masterListApplyChangesStatus_el_extra.textContent = "Errors in proposed IDs. Correct and retry."; masterListApplyChangesStatus_el_extra.style.color = '#e74c3c'; return; }
            if (idChangeProposals.length === 0) { masterListApplyChangesStatus_el_extra.textContent = "No Stop ID changes proposed."; masterListApplyChangesStatus_el_extra.style.color = '#7f8c8d'; return; }
            if (!confirm(`Apply ${idChangeProposals.length} Stop ID changes to Firebase?`)) { masterListApplyChangesStatus_el_extra.textContent = "Bulk ID change cancelled."; masterListApplyChangesStatus_el_extra.style.color = '#7f8c8d'; return; }
            let actualUpdateCount = 0; const originalToNewIdMap = new Map(idChangeProposals.map(p => [p.originalId.toUpperCase(), p.newId]));
            currentWorkingSchedule_extra.forEach(entry => { const originalEntryStopIDUpper = entry.stopID.toUpperCase(); if (originalToNewIdMap.has(originalEntryStopIDUpper)) { entry.stopID = originalToNewIdMap.get(originalEntryStopIDUpper); actualUpdateCount++; } });
            const updatedClosedStopIDs = new Set(); closedStopIDs_extra.forEach(closedId => { updatedClosedStopIDs.add(originalToNewIdMap.get(closedId.toUpperCase()) || closedId); }); closedStopIDs_extra = Array.from(updatedClosedStopIDs);
            const updatedStopSpecificColours = {}; for (const oldStopIdKey in stopSpecificRouteColours_extra) { updatedStopSpecificColours[originalToNewIdMap.get(oldStopIdKey.toUpperCase()) || oldStopIdKey] = stopSpecificRouteColours_extra[oldStopIdKey]; } stopSpecificRouteColours_extra = updatedStopSpecificColours;
            if (actualUpdateCount > 0 || idChangeProposals.some(p => closedStopIDs_extra.includes(p.newId.toUpperCase()) || stopSpecificRouteColours_extra[p.newId.toUpperCase()])) {
                try {
                    await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra); 
                    await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                    masterListApplyChangesStatus_el_extra.textContent = `Applied ${idChangeProposals.length} Stop ID change(s) (${actualUpdateCount} entries).`; masterListApplyChangesStatus_el_extra.style.color = '#2ecc71';
                    renderUIDependentElements_ExtraPage();
                } catch (error) { console.error("Error applying bulk ID changes:", error); masterListApplyChangesStatus_el_extra.textContent = "Error saving bulk ID changes: " + error.message; masterListApplyChangesStatus_el_extra.style.color = '#e74c3c'; alert("Critical error saving bulk Stop ID changes. Data inconsistent. Refresh."); }
            } else { masterListApplyChangesStatus_el_extra.textContent = "No schedule entries affected by proposed changes."; masterListApplyChangesStatus_el_extra.style.color = '#f1c40f'; }
        }
        function findDuplicateStopsByNameAndDirection_ExtraPage() { if (!currentUser_extra) { alert("Please log in."); if (duplicateStopsByNameDirResults_el_extra) duplicateStopsByNameDirResults_el_extra.textContent = "Please log in."; return; } if (!duplicateStopsByNameDirResults_el_extra) { console.error("Result display element not found."); return; } duplicateStopsByNameDirResults_el_extra.innerHTML = "<p>Checking for duplicates...</p>"; duplicateStopsByNameDirResults_el_extra.style.color = "#f1c40f"; const stopsToCheck = getUniqueStopsFromSchedule_ExtraPage(); if (!stopsToCheck || stopsToCheck.length === 0) { duplicateStopsByNameDirResults_el_extra.textContent = "No stops loaded."; return; } const signatureMap = new Map(); stopsToCheck.forEach(stop => { if (stop.stopName && stop.stopID) { const name = stop.stopName.trim().toLowerCase(); const direction = (stop.direction || "").trim().toLowerCase(); const signature = `${name}|${direction}`; if (!signatureMap.has(signature)) signatureMap.set(signature, []); signatureMap.get(signature).push({id: stop.stopID, name: stop.stopName, direction: stop.direction}); } }); let duplicateSets = []; signatureMap.forEach((stops, signature) => { if (stops.length > 1) { duplicateSets.push({ signature: signature, name: stops[0].name, direction: stops[0].direction || "", stops: stops.map(s => ({ id: s.id, entryCount: currentWorkingSchedule_extra.filter(entry => entry.stopID === s.id).length })).sort((a,b) => b.entryCount - a.id.localeCompare(b.id)) }); } }); if (duplicateSets.length === 0) { duplicateStopsByNameDirResults_el_extra.textContent = "No duplicate stops found (name & direction)."; duplicateStopsByNameDirResults_el_extra.style.color = "#2ecc71"; } else { let html = `<p>${duplicateSets.length} set(s) of duplicate stops found:</p><ul>`; duplicateSets.forEach((set, index) => { html += `<li class="duplicate-set-to-merge">`; html += `<p><strong>Name:</strong> "${set.name}", <strong>Direction:</strong> "${set.direction || '(None)'}"</p>`; html += `<p>Conflicting StopIDs (select one to keep):</p><div class="stop-id-options">`; set.stops.forEach((stop, radioIndex) => { const radioName = `master_for_set_${index}`; const isChecked = radioIndex === 0 ? "checked" : ""; html += `<label><input type="radio" name="${radioName}" value="${stop.id}" ${isChecked}> ${stop.id} (${stop.entryCount} entries)</label><br>`; }); html += `</div></li>`; }); html += `</ul><button id="mergeDuplicateStopsButton_extra" class="button save" style="margin-top:1rem;">Merge Selected Duplicates</button>`; html += `<p id="mergeDuplicateStopsStatus_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>`; duplicateStopsByNameDirResults_el_extra.innerHTML = html; duplicateStopsByNameDirResults_el_extra.style.color = "#e74c3c"; const mergeButton = document.getElementById('mergeDuplicateStopsButton_extra'); if (mergeButton) mergeButton.addEventListener('click', handleMergeDuplicateStops_ExtraPage); } }
        async function handleMergeDuplicateStops_ExtraPage() {
            if (!currentUser_extra) { alert("Log in."); return; }
            const mergeStatusEl = document.getElementById('mergeDuplicateStopsStatus_extra'); if (!mergeStatusEl) return;
            mergeStatusEl.textContent = "Processing merges..."; mergeStatusEl.style.color = "#f1c40f";
            const duplicateSetElements = duplicateStopsByNameDirResults_el_extra.querySelectorAll('.duplicate-set-to-merge'); if (duplicateSetElements.length === 0) { mergeStatusEl.textContent = "No duplicate sets found."; return; }
            let changesMade = false; let totalEntriesReassigned = 0; let stopIDsMergedAwayOverall = new Set();
            for (let i = 0; i < duplicateSetElements.length; i++) { 
                const radioName = `master_for_set_${i}`; const selectedRadio = duplicateStopsByNameDirResults_el_extra.querySelector(`input[name="${radioName}"]:checked`); if (!selectedRadio) continue; const masterStopID = selectedRadio.value; const masterStopDetails = uniqueStopsMasterList_extra.find(s => s.stopID === masterStopID) || currentWorkingSchedule_extra.find(e => e.stopID === masterStopID); if (!masterStopDetails) continue; const masterStopName = masterStopDetails.stopName; const masterStopDirection = masterStopDetails.direction; const allRadiosInSet = duplicateStopsByNameDirResults_el_extra.querySelectorAll(`input[name="${radioName}"]`); const stopIDsInThisSet = Array.from(allRadiosInSet).map(radio => radio.value); const stopIDsToMergeAway = stopIDsInThisSet.filter(id => id !== masterStopID); if (stopIDsToMergeAway.length > 0) { changesMade = true; stopIDsToMergeAway.forEach(idToMerge => { stopIDsMergedAwayOverall.add(idToMerge.toUpperCase()); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === idToMerge) { entry.stopID = masterStopID; entry.stopName = masterStopName; entry.direction = masterStopDirection; totalEntriesReassigned++; } }); }); }
            }
            if (!changesMade) { mergeStatusEl.textContent = "No merges selected."; mergeStatusEl.style.color = "#7f8c8d"; return; }
            closedStopIDs_extra = closedStopIDs_extra.filter(id => !stopIDsMergedAwayOverall.has(id.toUpperCase())); stopIDsMergedAwayOverall.forEach(idToMergeUpper => { if (stopSpecificRouteColours_extra[idToMergeUpper]) delete stopSpecificRouteColours_extra[idToMergeUpper]; });
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra); 
                await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                mergeStatusEl.textContent = `Merged duplicates. ${totalEntriesReassigned} entries reassigned.`; mergeStatusEl.style.color = "#2ecc71";
                renderUIDependentElements_ExtraPage(); findDuplicateStopsByNameAndDirection_ExtraPage();
            } catch (error) { console.error("Error saving merged stops:", error); mergeStatusEl.textContent = "Error saving merged stops: " + error.message; mergeStatusEl.style.color = "#e74c3c"; alert("CRITICAL: Error saving merged stops. Data inconsistent. Refresh."); }
        }
        async function saveClosedStopsToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; const fbClosedObject = {}; closedStopIDs_extra.forEach(id => { if (typeof id === 'string') fbClosedObject[id.toUpperCase()] = true; }); await dbSet(dbRef(database, FB_PATH_APPSTATE_CLOSED_STOPS), fbClosedObject); console.log("Closed stops saved (Extra)."); }
        async function saveGlobalColoursToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; await dbSet(dbRef(database, FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS), globalCustomRouteColours_extra); console.log("Global route colours saved (Extra)."); }
        async function saveStopSpecificColoursToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; await dbSet(dbRef(database, FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS), stopSpecificRouteColours_extra); console.log("Stop-specific colours saved (Extra)."); }

        // --- Global Route Deletion Functions ---
        function populateGlobalRouteToDeleteList_ExtraPage() { if (!globalRouteDeletionListContainer_el_extra) return; globalRouteDeletionListContainer_el_extra.innerHTML = ''; if (!currentWorkingSchedule_extra || currentWorkingSchedule_extra.length === 0) { globalRouteDeletionListContainer_el_extra.innerHTML = '<p>No routes loaded.</p>'; return; } const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName).filter(Boolean))].sort(compareLineNames_ExtraPage); if (uniqueRoutes.length === 0) { globalRouteDeletionListContainer_el_extra.innerHTML = '<p>No valid routes to list.</p>'; return; } const tileContainer = document.createElement('div'); tileContainer.className = 'selectable-route-tile-container'; uniqueRoutes.forEach(lineName => { const tile = document.createElement('span'); tile.className = 'selectable-route-tile'; tile.textContent = lineName; tile.dataset.lineName = lineName; const bgColor = getRouteTileColour_ExtraPage(lineName); tile.style.backgroundColor = bgColor; tile.style.color = getTextColourForBackground_ExtraPage(bgColor); tile.setAttribute('role', 'checkbox'); tile.setAttribute('aria-checked', 'false'); tile.tabIndex = 0; tile.addEventListener('click', () => { const isSelected = tile.classList.toggle('selected'); tile.setAttribute('aria-checked', isSelected.toString()); }); tile.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); tile.click(); }}); tileContainer.appendChild(tile); }); globalRouteDeletionListContainer_el_extra.appendChild(tileContainer); }
        async function handleDeleteEntireRouteGlobally_ExtraPage() {
            if (!currentUser_extra || !deleteEntireRouteStatusMessage_el_extra || !globalRouteDeletionListContainer_el_extra) return;
            const selectedTiles = globalRouteDeletionListContainer_el_extra.querySelectorAll('.selectable-route-tile.selected');
            if (selectedTiles.length === 0) { deleteEntireRouteStatusMessage_el_extra.textContent = "Select route(s) to delete."; deleteEntireRouteStatusMessage_el_extra.style.color = '#f1c40f'; return; }
            const routesToDelete = Array.from(selectedTiles).map(t => t.dataset.lineName);
            if (!confirm(`EXTREME CAUTION!\nDelete ALL data for route(s): ${routesToDelete.join(', ')} from Firebase? CANNOT BE UNDONE.`)) { deleteEntireRouteStatusMessage_el_extra.textContent = "Global deletion cancelled."; return; }
            deleteEntireRouteStatusMessage_el_extra.textContent = `Deleting route(s): ${routesToDelete.join(', ')}...`; deleteEntireRouteStatusMessage_el_extra.style.color = '#f1c40f';
            const { database, dbRemove, dbRef } = window.firebaseOMSI; let firebaseRemovalPromises = [];
            routesToDelete.forEach(routeNameToDelete => {
                const saneRouteName = sanitizeFirebaseKey(routeNameToDelete);
                const routePath = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRouteName}`;
                firebaseRemovalPromises.push(dbRemove(dbRef(database, routePath)));
            });
            const originalScheduleLength = currentWorkingSchedule_extra.length;
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry =>
                !(entry.lineName && routesToDelete.map(r => r.toUpperCase()).includes(entry.lineName.toUpperCase()))
            );
            const scheduleEntriesRemovedCount = originalScheduleLength - currentWorkingSchedule_extra.length;
            let globalColoursRemoved = false; routesToDelete.forEach(route => { if (globalCustomRouteColours_extra[route.toUpperCase()]) { delete globalCustomRouteColours_extra[route.toUpperCase()]; globalColoursRemoved = true; } });
            let specificColoursNeedSave = false; Object.keys(stopSpecificRouteColours_extra).forEach(stopID => { routesToDelete.forEach(route => { if (stopSpecificRouteColours_extra[stopID] && stopSpecificRouteColours_extra[stopID][route.toUpperCase()]) { delete stopSpecificRouteColours_extra[stopID][route.toUpperCase()]; if (Object.keys(stopSpecificRouteColours_extra[stopID]).length === 0) delete stopSpecificRouteColours_extra[stopID]; specificColoursNeedSave = true; } }); });
            try {
                await Promise.all(firebaseRemovalPromises); 
                if (globalColoursRemoved) await saveGlobalColoursToFirebase_ExtraPage();
                if (specificColoursNeedSave) await saveStopSpecificColoursToFirebase_ExtraPage();
                await updateAncillaryScheduleData_ExtraPage(); 
                deleteEntireRouteStatusMessage_el_extra.textContent = `Route(s) ${routesToDelete.join(', ')} deleted. ${scheduleEntriesRemovedCount} entries removed.`;
                deleteEntireRouteStatusMessage_el_extra.style.color = '#2ecc71';
                renderUIDependentElements_ExtraPage();
            } catch (error) {
                console.error("Error deleting route(s) globally:", error);
                deleteEntireRouteStatusMessage_el_extra.textContent = "Error saving deletions: " + error.message;
                deleteEntireRouteStatusMessage_el_extra.style.color = '#e74c3c';
                alert("Critical error saving global route deletions. Data inconsistent. Refresh.");
            }
        }

        // ++ Route Profile Deletion Functions (NEW SECTION) ++
        /**
         * @description Populates the route select dropdown for the Route Profile Deletion tool.
         */
        function rpd_populateRouteSelect_ExtraPage() {
            if (!rpdRouteSelect_el_extra || !rpdRouteInput_el_extra) return;
            const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))]
                .filter(Boolean)
                .sort(compareLineNames_ExtraPage);

            const currentInputValue = rpdRouteInput_el_extra.value.trim();
            rpdRouteSelect_el_extra.innerHTML = '<option value="">-- Select Route --</option>';
            uniqueRoutes.forEach(route => {
                const opt = document.createElement('option');
                opt.value = route;
                opt.textContent = route;
                rpdRouteSelect_el_extra.appendChild(opt);
            });

            const matchedRoute = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
            if (matchedRoute) {
                rpdRouteSelect_el_extra.value = matchedRoute;
            } else if (currentInputValue) {
                rpdRouteSelect_el_extra.value = ""; 
            }
            // Chain updates
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Handles changes to the route name input field for RPD.
         */
        function rpd_handleRouteNameInputChange_ExtraPage() {
            if (!rpdRouteInput_el_extra || !rpdRouteSelect_el_extra) return;
            const typedRouteUpper = rpdRouteInput_el_extra.value.trim().toUpperCase();
            const matchedOption = Array.from(rpdRouteSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper);

            if (matchedOption) {
                rpdRouteSelect_el_extra.value = matchedOption.value;
                if (rpdRouteInput_el_extra.value !== matchedOption.value) {
                    rpdRouteInput_el_extra.value = matchedOption.value;
                }
            } else {
                rpdRouteSelect_el_extra.value = ""; 
            }
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Handles changes to the route name select dropdown for RPD.
         */
        function rpd_handleRouteNameSelectChange_ExtraPage() {
            if (!rpdRouteSelect_el_extra || !rpdRouteInput_el_extra) return;
            rpdRouteInput_el_extra.value = rpdRouteSelect_el_extra.value;
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Populates the destination select dropdown for RPD based on selected route.
         */
        function rpd_populateDestinationSelect_ExtraPage() {
            if (!rpdDestinationSelect_el_extra || !rpdDestinationInput_el_extra || !rpdRouteInput_el_extra) return;

            const selectedRoute = rpdRouteInput_el_extra.value.trim().toUpperCase();
            const currentDestInputValue = rpdDestinationInput_el_extra.value.trim();

            rpdDestinationSelect_el_extra.innerHTML = '<option value="">-- Optional: All Destinations --</option>'; // Modified default text

            if (!selectedRoute) {
                rpdDestinationInput_el_extra.value = ""; 
                rpdDestinationSelect_el_extra.disabled = true;
                rpdDestinationInput_el_extra.disabled = true;
                if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = 'none';
                rpd_populateProfileList_ExtraPage(); 
                return;
            }

            rpdDestinationSelect_el_extra.disabled = false;
            rpdDestinationInput_el_extra.disabled = false;

            const uniqueDestinations = [...new Set(
                currentWorkingSchedule_extra
                    .filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName)
                    .map(e => e.destinationName)
            )].sort();

            if (uniqueDestinations.length > 0) {
                uniqueDestinations.forEach(dest => {
                    const opt = document.createElement('option');
                    opt.value = dest;
                    opt.textContent = dest;
                    rpdDestinationSelect_el_extra.appendChild(opt);
                });
                const matchedDest = uniqueDestinations.find(d => d === currentDestInputValue);
                if (matchedDest) {
                    rpdDestinationSelect_el_extra.value = matchedDest;
                } else {
                     rpdDestinationSelect_el_extra.value = ""; // Default to "All Destinations" if typed value doesn't match
                }
            } else {
                 rpdDestinationSelect_el_extra.innerHTML = '<option value="">-- No Specific Destinations --</option>';
                 rpdDestinationInput_el_extra.value = ""; // Clear input if no destinations exist
            }
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }
        
        /**
         * @description Handles changes to the destination name input field for RPD.
         */
        function rpd_handleDestinationNameInputChange_ExtraPage() {
            if (!rpdDestinationInput_el_extra || !rpdDestinationSelect_el_extra) return;
            const typedDest = rpdDestinationInput_el_extra.value.trim();
            const matchedOption = Array.from(rpdDestinationSelect_el_extra.options).find(opt => opt.value === typedDest);

            if (matchedOption) {
                rpdDestinationSelect_el_extra.value = matchedOption.value;
                if (rpdDestinationInput_el_extra.value !== matchedOption.value) {
                   rpdDestinationInput_el_extra.value = matchedOption.value;
                }
            } else {
                rpdDestinationSelect_el_extra.value = ""; // If typing something not in list, clear select to imply "All Destinations" or new
            }
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }

        /**
         * @description Handles changes to the destination name select dropdown for RPD.
         */
        function rpd_handleDestinationNameSelectChange_ExtraPage() {
            if (!rpdDestinationSelect_el_extra || !rpdDestinationInput_el_extra) return;
            rpdDestinationInput_el_extra.value = rpdDestinationSelect_el_extra.value; // Sync input with select
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }
        
        /**
         * @description Clears the destination selection for RPD.
         */
        function rpd_handleClearDestination_ExtraPage() {
            if (!rpdDestinationInput_el_extra || !rpdDestinationSelect_el_extra || !rpdClearDestinationButton_el_extra) return;
            rpdDestinationInput_el_extra.value = "";
            rpdDestinationSelect_el_extra.value = ""; // This will select "-- Optional: All Destinations --"
            rpdClearDestinationButton_el_extra.style.display = 'none';
            rpd_populateProfileList_ExtraPage(); 
        }

        /**
         * @description Fetches and displays available profiles for selection based on route and optional destination.
         */
        async function rpd_populateProfileList_ExtraPage() {
            if (!rpdProfileListContainer_el_extra || !rpdRouteInput_el_extra || !rpdDestinationInput_el_extra || !window.firebaseOMSI) {
                if (rpdProfileListContainer_el_extra) rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; opacity:0.7;">Required elements missing for profile listing.</p>';
                return;
            }

            const routeName = rpdRouteInput_el_extra.value.trim();
            const destinationName = rpdDestinationInput_el_extra.value.trim(); // This is the specific destination, if selected

            rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; opacity:0.7;">Select a route to see available profiles.</p>';

            if (!routeName) {
                return; 
            }

            rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; color:#f1c40f;">Loading profiles...</p>';

            // Use currentWorkingSchedule_extra to derive profiles to ensure original casing and relevance
            let profilesOfInterest = currentWorkingSchedule_extra.filter(entry => {
                if (entry.lineName !== routeName) return false;
                if (destinationName && entry.destinationName !== destinationName) return false; // Filter by dest if specified
                return true; // Passes if route matches, and dest matches (if dest was specified)
            });

            let availableOriginalProfileNames = [...new Set(profilesOfInterest.map(e => e.OperatingProfile))].sort();

            if (availableOriginalProfileNames.length === 0) {
                if (destinationName) {
                    rpdProfileListContainer_el_extra.innerHTML = `<p style="font-size:0.85em; color:#f1c40f;">No profiles found for route "${routeName}" with destination "${destinationName}".</p>`;
                } else {
                    rpdProfileListContainer_el_extra.innerHTML = `<p style="font-size:0.85em; color:#f1c40f;">No profiles found for route "${routeName}".</p>`;
                }
                return;
            }

            let html = '<div class="selectable-route-tile-container" style="margin-top:0.5rem;">'; 
            availableOriginalProfileNames.forEach(profileName => {
                html += `
                    <label class="selectable-route-tile rpd-profile-tile" style="background-color: #4A5568; color: white; border-color: transparent;" tabindex="0">
                        <input type="checkbox" class="rpd-profile-checkbox sr-only" value="${profileName}">
                        ${profileName}
                    </label>
                `;
            });
            html += '</div>';
            rpdProfileListContainer_el_extra.innerHTML = html;

            rpdProfileListContainer_el_extra.querySelectorAll('.rpd-profile-tile').forEach(tile => {
                const checkbox = tile.querySelector('.rpd-profile-checkbox');
                const toggleSelection = () => {
                    checkbox.checked = !checkbox.checked;
                    tile.classList.toggle('selected', checkbox.checked); 
                    tile.style.borderColor = checkbox.checked ? '#f1c40f' : 'transparent'; // Visual feedback
                    tile.setAttribute('aria-checked', checkbox.checked.toString());
                };
                tile.addEventListener('click', toggleSelection);
                tile.addEventListener('keydown', (e) => {
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        toggleSelection();
                    }
                });
            });
        }


        /**
         * @description Handles the deletion of selected route profiles.
         */
        async function handleDeleteRouteProfiles_ExtraPage() {
            if (!currentUser_extra || !window.firebaseOMSI) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Not logged in or Firebase not available."; rpdStatusMessage_el_extra.style.color = "#e74c3c";}
                return;
            }

            const routeName = rpdRouteInput_el_extra.value.trim();
            const destinationName = rpdDestinationInput_el_extra.value.trim(); // Optional, if empty means all destinations
            const selectedProfileCheckboxes = rpdProfileListContainer_el_extra.querySelectorAll('.rpd-profile-checkbox:checked');

            if (!routeName) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Please select a route."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}
                return;
            }
            if (selectedProfileCheckboxes.length === 0) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Please select at least one profile to delete."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}
                return;
            }

            const profilesToDeleteOriginalNames = Array.from(selectedProfileCheckboxes).map(cb => cb.value);
            const saneRoute = sanitizeFirebaseKey(routeName);
            const saneDest = destinationName ? sanitizeFirebaseKey(destinationName) : null;

            let confirmMessage = `ARE YOU SURE?\nThis will delete ALL schedule entries for:\nRoute: "${routeName}"`;
            if (saneDest) {
                confirmMessage += `\nDestination: "${destinationName}"`;
            } else {
                confirmMessage += ` (across ALL its destinations)`;
            }
            confirmMessage += `\nFor Operating Profile(s): ${profilesToDeleteOriginalNames.join(', ')}\n\nThis action CANNOT BE UNDONE.`;

            if (!confirm(confirmMessage)) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Profile deletion cancelled."; rpdStatusMessage_el_extra.style.color = "";}
                return;
            }

            if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Deleting profiles from Firebase..."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}

            const { database, dbRemove, dbRef } = window.firebaseOMSI;
            const removalPromises = [];

            profilesToDeleteOriginalNames.forEach(profileName => {
                const saneProfile = sanitizeFirebaseKey(profileName);
                let pathToDelete;
                if (saneDest) { // Delete specific destination under profile
                    pathToDelete = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}/${saneProfile}/${saneDest}`;
                } else { // Delete entire profile node for the route
                    pathToDelete = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}/${saneProfile}`;
                }
                console.log("Firebase path marked for deletion:", pathToDelete);
                removalPromises.push(dbRemove(dbRef(database, pathToDelete)));
            });

            try {
                await Promise.all(removalPromises);
                console.log("Firebase removal operations complete for selected profiles.");

                const originalLength = currentWorkingSchedule_extra.length;
                currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
                    const routeMatch = entry.lineName === routeName;
                    const profileMatch = profilesToDeleteOriginalNames.includes(entry.OperatingProfile);
                    // If saneDest is specified, entry must match it. If saneDest is null, destination doesn't matter for removal of whole profile.
                    const destMatch = saneDest ? (entry.destinationName === destinationName) : true;
                    
                    return !(routeMatch && profileMatch && destMatch);
                });
                const removedCount = originalLength - currentWorkingSchedule_extra.length;
                console.log(`${removedCount} entries removed from local currentWorkingSchedule_extra.`);

                await updateAncillaryScheduleData_ExtraPage();

                if(rpdStatusMessage_el_extra) {
                    rpdStatusMessage_el_extra.textContent = `Successfully deleted ${profilesToDeleteOriginalNames.length} profile(s) (${removedCount} schedule entries affected) for route "${routeName}"${saneDest ? ' and destination "' + destinationName + '"' : ' (all destinations for those profiles)'}. Ancillary data updated.`;
                    rpdStatusMessage_el_extra.style.color = "#2ecc71";
                }
                
                rpd_populateProfileList_ExtraPage(); // Refresh profile list
                renderUIDependentElements_ExtraPage(); 

            } catch (error) {
                console.error("Error deleting route profiles:", error);
                if(rpdStatusMessage_el_extra) {
                    rpdStatusMessage_el_extra.textContent = "Error deleting profiles from Firebase: " + error.message;
                    rpdStatusMessage_el_extra.style.color = "#e74c3c";
                }
                alert("Failed to delete profiles from Firebase. Data might be inconsistent. It's recommended to reload data from Firebase or review carefully.");
            }
        }
        // ++ END Route Profile Deletion Functions ++




        // ++ Route Schedule Generator Functions START ++
const RSG_OPERATING_PROFILES_LIST = [
    "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su",
    "MF",
    "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MFSch",
    "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MFNSD",
    "Christmas Day", "Boxing Day", "New Years Day"
];

const RSG_PROFILE_GROUPS_TO_MANAGE = [
    { individuals: ["Mo", "Tu", "We", "Th", "Fr"], groupProfile: "MF" },
    { individuals: ["MoSch", "TuSch", "WeSch", "ThSch", "FrSch"], groupProfile: "MFSch" },
    { individuals: ["MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"], groupProfile: "MFNSD" }
];

const RSG_PROFILE_INCOMPATIBILITY_RULES = {
    "Mo": ["MoSch", "MoNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MoSch": ["Mo", "MoNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MoNSD": ["Mo", "MoSch", "MF", "MFSch", "MFNSD", "AllDays"],
    "Tu": ["TuSch", "TuNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "TuSch": ["Tu", "TuNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "We": ["WeSch", "WeNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "Th": ["ThSch", "ThNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "Fr": ["FrSch", "FrNSD", "MF", "MFSch", "MFNSD", "AllDays"],
    "MF": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MFSch", "MFNSD", "AllDays"],
    "MFSch": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MF", "MFNSD", "AllDays"],
    "MFNSD": ["Mo", "Tu", "We", "Th", "Fr", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MF", "MFSch", "AllDays"],
    "Sa": ["SaNSD", "AllDays"],
    "SaNSD": ["Sa", "AllDays"],
    "Su": ["SuNSD", "AllDays"],
    "SuNSD": ["Su", "AllDays"],
    "AllDays": RSG_OPERATING_PROFILES_LIST.filter(p => p !== "AllDays"),
    "SchoolHoliday": ["AllDays", "MFSch", "MFNSD", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"],
    "BankHoliday": ["AllDays", "MFSch", "MFNSD", "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD"]
};

for (const keyProfile_extra in RSG_PROFILE_INCOMPATIBILITY_RULES) {
    RSG_PROFILE_INCOMPATIBILITY_RULES[keyProfile_extra].forEach(disabledProfile_extra => {
        if (!RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra]) {
            RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra] = [];
        }
        if (!RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra].includes(keyProfile_extra)) {
            RSG_PROFILE_INCOMPATIBILITY_RULES[disabledProfile_extra].push(keyProfile_extra);
        }
    });
}

const MASTER_VALID_PROFILE_COMBINATIONS_LIST_EXTRA = [
    "Mo", "Mo,Tu", "Mo,Tu,We", "Mo,Tu,We,Th", "Mo,Tu,We,Th,Sa", "Mo,Tu,We,Th,Sa,Su",
    "Mo,Tu,We,Th,Su", "Mo,Tu,We,Fr", "Mo,Tu,We,Fr,Sa", "Mo,Tu,We,Fr,Sa,Su",
    "Mo,Tu,We,Fr,Su", "Mo,Tu,We,Sa", "Mo,Tu,We,Sa,Su", "Mo,Tu,We,Su", "Mo,Tu,Th",
    "Mo,Tu,Th,Sa", "Mo,Tu,Th,Sa,Su", "Mo,Tu,Th,Su", "Mo,Tu,Fr", "Mo,Tu,Fr,Sa",
    "Mo,Tu,Fr,Sa,Su", "Mo,Tu,Fr,Su", "Mo,Tu,Sa", "Mo,Tu,Sa,Su", "Mo,Tu,Su", "Mo,We",
    "Mo,We,Th", "Mo,We,Th,Fr", "Mo,We,Th,Fr,Sa", "Mo,We,Th,Fr,Sa,Su", "Mo,We,Th,Fr,Su",
    "Mo,We,Th,Sa", "Mo,We,Th,Sa,Su", "Mo,We,Th,Su", "Mo,We,Fr", "Mo,We,Fr,Sa",
    "Mo,We,Fr,Sa,Su", "Mo,We,Fr,Su", "Mo,We,Sa", "Mo,We,Sa,Su", "Mo,We,Su", "Mo,Th",
    "Mo,Th,Fr", "Mo,Th,Fr,Sa", "Mo,Th,Fr,Sa,Su", "Mo,Th,Fr,Su", "Mo,Th,Sa",
    "Mo,Th,Sa,Su", "Mo,Th,Su", "Mo,Fr", "Mo,Fr,Sa", "Mo,Fr,Sa,Su", "Mo,Fr,Su", "Mo,Sa",
    "Mo,Sa,Su", "Mo,Su",
    "MoSch", "MoSch,TuSch", "MoSch,TuSch,WeSch", "MoSch,TuSch,WeSch,ThSch", "MoSch,TuSch,WeSch,FrSch",
    "MoSch,TuSch,ThSch", "MoSch,TuSch,ThSch,FrSch", "MoSch,TuSch,FrSch", "MoSch,WeSch",
    "MoSch,WeSch,ThSch", "MoSch,WeSch,ThSch,FrSch", "MoSch,WeSch,FrSch", "MoSch,ThSch",
    "MoSch,ThSch,FrSch", "MoSch,FrSch",
    "MoNSD", "MoNSD,TuNSD", "MoNSD,TuNSD,WeNSD", "MoNSD,TuNSD,WeNSD,ThNSD", "MoNSD,TuNSD,WeNSD,FrNSD",
    "MoNSD,TuNSD,ThNSD", "MoNSD,TuNSD,ThNSD,FrNSD", "MoNSD,TuNSD,FrNSD", "MoNSD,WeNSD",
    "MoNSD,WeNSD,ThNSD", "MoNSD,WeNSD,ThNSD,FrNSD", "MoNSD,WeNSD,FrNSD", "MoNSD,ThNSD",
    "MoNSD,ThNSD,FrNSD", "MoNSD,FrNSD",
    "Tu", "Tu,We", "Tu,We,Th", "Tu,We,Th,Fr", "Tu,We,Th,Fr,Sa", "Tu,We,Th,Fr,Sa,Su",
    "Tu,We,Th,Fr,Su", "Tu,We,Th,Sa", "Tu,We,Th,Sa,Su", "Tu,We,Th,Su", "Tu,We,Fr",
    "Tu,We,Fr,Sa", "Tu,We,Fr,Sa,Su", "Tu,We,Fr,Su", "Tu,We,Sa", "Tu,We,Sa,Su", "Tu,We,Su",
    "Tu,Th", "Tu,Th,Fr", "Tu,Th,Fr,Sa", "Tu,Th,Fr,Sa,Su", "Tu,Th,Fr,Su", "Tu,Th,Sa",
    "Tu,Th,Sa,Su", "Tu,Th,Su", "Tu,Fr", "Tu,Fr,Sa", "Tu,Fr,Sa,Su", "Tu,Fr,Su", "Tu,Sa",
    "Tu,Sa,Su", "Tu,Su",
    "TuSch", "TuSch,WeSch", "TuSch,WeSch,ThSch", "TuSch,WeSch,FrSch", "TuSch,ThSch", "TuSch,ThSch,FrSch",
    "TuSch,FrSch",
    "TuNSD", "TuNSD,WeNSD", "TuNSD,WeNSD,ThNSD", "TuNSD,WeNSD,ThNSD,FrNSD", "TuNSD,WeNSD,FrNSD",
    "TuNSD,ThNSD", "TuNSD,ThNSD,FrNSD", "TuNSD,FrNSD",
    "We", "We,Th", "We,Th,Fr", "We,Th,Fr,Sa", "We,Th,Fr,Sa,Su", "We,Th,Fr,Su", "We,Th,Sa",
    "We,Th,Sa,Su", "We,Th,Su", "We,Fr", "We,Fr,Sa", "We,Fr,Sa,Su", "We,Fr,Su", "We,Sa",
    "We,Sa,Su", "We,Su",
    "WeSch", "WeSch,ThSch", "WeSch,ThSch,FrSch", "WeSch,FrSch",
    "WeNSD", "WeNSD,ThNSD", "WeNSD,ThNSD,FrNSD", "WeNSD,FrNSD",
    "Th", "Th,Fr", "Th,Fr,Sa", "Th,Fr,Sa,Su", "Th,Fr,Su", "Th,Sa", "Th,Sa,Su", "Th,Su",
    "ThSch", "ThSch,FrSch",
    "ThNSD", "ThNSD,FrNSD",
    "Fr", "Fr,Sa", "Fr,Sa,Su", "Fr,Su",
    "FrSch", "FrNSD",
    "MF", "MF,Sa", "MF,Sa,Su", "MF,Su",
    "MFSch", "MFNSD",
    "Sa", "Sa,Su",
    "Su",
    "Christmas Day",
    "Boxing Day",
    "New Years Day"
];

// Helper function to create a canonical string (sorted, comma-separated)
function rsg_getCanonicalProfileString(profileArray) {
    if (!Array.isArray(profileArray)) return "";
    return profileArray.map(p => String(p).trim()).sort((a,b) => a.localeCompare(b)).join(',');
}

const VALID_PROFILE_COMBINATIONS_SET = new Set(
    MASTER_VALID_PROFILE_COMBINATIONS_LIST_EXTRA.map(s => rsg_getCanonicalProfileString(s.split(',')))
);

function rsg_showSaveConfigModal_ExtraPage() {
            const routeNameInput = rsgRouteNameInput_el_extra; // Assuming this element is globally available
            const destinationNameInput = rsgDestinationNameInput_el_extra; // Assuming this element is globally available
            // rsg_getSelectedOpProfilesString_ExtraPage() will be called if needed

            // These are for the modal itself
            const configNameInput = document.getElementById('rsg-config-name-input-extra');
            const modal = document.getElementById('rsg-save-config-modal-extra');
            const modalStatus = document.getElementById('rsg-save-config-modal-status-extra');

            if (!routeNameInput || !destinationNameInput || !configNameInput || !modal || !modalStatus) {
                console.error("RSG Save Modal Error: One or more essential DOM elements are missing.");
                if (rsgStatusMessage_el_extra) { // Use the main RSG status if modal elements are broken
                    rsgStatusMessage_el_extra.textContent = "Error: Save dialog components missing.";
                    rsgStatusMessage_el_extra.style.color = "#e74c3c";
                }
                return;
            }

            const currentRouteName = routeNameInput.value.trim();
            const currentDestName = destinationNameInput.value.trim();
            const currentOpProfiles = rsg_getSelectedOpProfilesString_ExtraPage();

            // Basic validation before showing the modal (these are for saving, not just naming)
            if (!currentRouteName || !currentDestName || !currentOpProfiles) {
                if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = "Route, Destination, and at least one Operating Profile must be selected to suggest a name for saving.";
                    rsgStatusMessage_el_extra.style.color = "#f1c40f";
                }
                return;
            }
            if (rsg_selectedStops_extra.length === 0 || !rsgFirstStopTimesInput_el_extra.value.trim()) {
               if (rsgStatusMessage_el_extra) {
                   rsgStatusMessage_el_extra.textContent = "Stop Sequence and First Stop Times are required to save.";
                   rsgStatusMessage_el_extra.style.color = "#f1c40f";
               }
               return;
           }

            let defaultConfigName;

            // **MODIFIED LOGIC STARTS HERE**
            // If a configuration is currently loaded (indicated by rsg_currentlyEditingConfigKey_extra)
            // and it has a display name, ALWAYS suggest its display name for saving.
            // This prioritizes overwriting the loaded configuration.
            if (rsg_currentlyEditingConfigKey_extra && rsg_currentlyEditingConfigDisplayName_extra) {
                defaultConfigName = rsg_currentlyEditingConfigDisplayName_extra;
                console.log(`LOG: rsg_showSaveConfigModal - A config ('${rsg_currentlyEditingConfigDisplayName_extra}') is loaded. Pre-filling with its display name for potential overwrite.`);
            } else {
                // No configuration is loaded, or the loaded one lacks a display name.
                // In this case, derive a new name from the current form fields for a "Save As New" scenario.
                const defaultNameRoutePart = currentRouteName.replace(/[^a-zA-Z0-9\s-]/g, '').trim() || "Route";
                const defaultNameDestPart = currentDestName.replace(/[^a-zA-Z0-9\s-]/g, '').trim() || "Dest";
                const defaultNameProfilePart = currentOpProfiles.replace(/[^a-zA-Z0-9\s,-]/g, '').trim() || "Profile";
                defaultConfigName = `${defaultNameRoutePart} to ${defaultNameDestPart} - ${defaultNameProfilePart}`;
                console.log(`LOG: rsg_showSaveConfigModal - No config loaded or display name missing. Pre-filling with name derived from current form fields: "${defaultConfigName}" for new save.`);
            }
            // **MODIFIED LOGIC ENDS HERE**

            configNameInput.value = defaultConfigName;
            modalStatus.textContent = ''; // Clear any previous modal status
            modal.style.display = 'flex';
        }

function rsg_hideSaveConfigModal_ExtraPage() {
    const modal = document.getElementById('rsg-save-config-modal-extra');
    if (modal) modal.style.display = 'none';
}

async function rsg_performSaveConfiguration_ExtraPage() {
            console.log("RSG Save Process: Triggered.");
            const configNameInput = document.getElementById('rsg-config-name-input-extra');
            const modalStatus = document.getElementById('rsg-save-config-modal-status-extra');

            if (!configNameInput || !modalStatus) { /* ... error handling ... */ return; }

            const userDefinedConfigName = configNameInput.value.trim();
            if (!userDefinedConfigName) { /* ... error handling ... */ return; }

            console.log(`RSG Save Process: Modal name: "${userDefinedConfigName}". Currently Editing Key: '${rsg_currentlyEditingConfigKey_extra}', DisplayName: '${rsg_currentlyEditingConfigDisplayName_extra}'`);

            let firebaseKey = null;
            let operationType = ""; 
            // ... (your existing logic for determining firebaseKey and operationType) ...
            if (rsg_currentlyEditingConfigKey_extra && userDefinedConfigName === rsg_currentlyEditingConfigDisplayName_extra) {
                firebaseKey = rsg_currentlyEditingConfigKey_extra;
                operationType = "overwrite_loaded_config";
            } else { /* ... logic to findMatchForKey or create new ... */ 
                let foundMatchForKey = null;
                for (const keyInCache in rsg_loadedConfigs_extra) {
                    if (Object.hasOwnProperty.call(rsg_loadedConfigs_extra, keyInCache)) {
                        const existingConfig = rsg_loadedConfigs_extra[keyInCache];
                        if (existingConfig.userDisplayName === userDefinedConfigName) {
                            foundMatchForKey = keyInCache; break;
                        }
                    }
                }
                if (foundMatchForKey) {
                    firebaseKey = foundMatchForKey; operationType = "overwrite_other_by_display_name";
                } else {
                    firebaseKey = sanitizeFirebaseKey(userDefinedConfigName); operationType = "save_new_config";
                }
            }
            console.log(`RSG Save Process: Operation determined: ${operationType}, Firebase Key: ${firebaseKey}`);
            if (!firebaseKey) { /* ... error handling ... */ return; }
            
            // Synchronization step (ensure this accurately reflects the current UI for time adjustments)
            // The 'input' listeners on timeAdjInput should have already updated rsg_selectedStops_extra items.
            // This block can serve as a final explicit sync if needed, or can be simplified if array is trusted.
            console.log("RSG Save Process: Beginning final sync of time adjustments from UI to rsg_selectedStops_extra array.");
            if (rsgStopSequenceList_el_extra && rsg_selectedStops_extra) {
                const displayedStopItems = rsgStopSequenceList_el_extra.querySelectorAll('li[data-index]');
                displayedStopItems.forEach(li => {
                    const index = parseInt(li.dataset.index);
                    if (rsg_selectedStops_extra[index]) {
                        if (index === 0) { 
                            if(rsg_selectedStops_extra[index].timeAdjustment !== 0) rsg_selectedStops_extra[index].timeAdjustment = 0;
                        } else {
                            const timeAdjInput = li.querySelector('.rsg-time-adjustment-input');
                            if (timeAdjInput) {
                                const uiValue = parseInt(timeAdjInput.value, 10);
                                const currentArrayValue = rsg_selectedStops_extra[index].timeAdjustment;
                                if (!isNaN(uiValue) && uiValue >= 0) {
                                    if (currentArrayValue !== uiValue) {
                                        console.log(`RSG Save Sync: Updating index ${index} from UI value ${uiValue} (was ${currentArrayValue})`);
                                        rsg_selectedStops_extra[index].timeAdjustment = uiValue;
                                    }
                                } else {
                                    if (currentArrayValue !== 0) {
                                        console.log(`RSG Save Sync: Invalid UI value for index ${index} ("${timeAdjInput.value}"), setting to 0 (was ${currentArrayValue})`);
                                        rsg_selectedStops_extra[index].timeAdjustment = 0;
                                    }
                                }
                            } else if (typeof rsg_selectedStops_extra[index].timeAdjustment === 'undefined' || rsg_selectedStops_extra[index].timeAdjustment === null) {
                                 console.log(`RSG Save Sync: No input or undefined adjustment for index ${index}, setting to 0.`);
                                rsg_selectedStops_extra[index].timeAdjustment = 0; 
                            }
                        }
                    }
                });
            }
            console.log("RSG Save Process: Finished final sync of time adjustments.");

            const currentRouteName = rsgRouteNameInput_el_extra.value.trim();
            const currentDestName = rsgDestinationNameInput_el_extra.value.trim();
            const currentOpProfiles = rsg_getSelectedOpProfilesString_ExtraPage();
            const stopSequenceToSave = rsg_selectedStops_extra; // This array should reflect removed stops and time edits
            const firstStopTimesToSave = rsgFirstStopTimesInput_el_extra.value.trim();

            // Detailed logging of what's about to be saved
            console.log("RSG Save Process: Data to be packaged for Firebase:");
            console.log(`  - User Display Name: "${userDefinedConfigName}"`);
            console.log(`  - Route Name: "${currentRouteName}"`);
            console.log(`  - Dest Name: "${currentDestName}"`);
            console.log(`  - Op Profiles: "${currentOpProfiles}"`);
            console.log(`  - First Stop Times: "${firstStopTimesToSave}"`);
            console.log(`  - Stop Sequence Length: ${stopSequenceToSave.length}`);
            console.log("  - Stop Sequence (sample - first 5, with ID, Name, Adjustment):", 
                stopSequenceToSave.slice(0,5).map(s => ({id:s.stopID, name:s.stopName, adj:s.timeAdjustment}))
            );

            if (!currentRouteName || !currentDestName || !currentOpProfiles || stopSequenceToSave.length === 0 || !firstStopTimesToSave) {
                modalStatus.textContent = "Cannot save: All fields (Route, Dest, Profile, Sequence, Times) are required.";
                modalStatus.style.color = "#e74c3c";
                return;
            }

            const configurationToSave = {
                userDisplayName: userDefinedConfigName, 
                routeName: currentRouteName,
                destinationName: currentDestName,
                operatingProfile: currentOpProfiles,
                stopSequence: JSON.parse(JSON.stringify(stopSequenceToSave)), 
                firstStopTimes: firstStopTimesToSave,
                lastSaved: new Date().toISOString()
            };
            
            modalStatus.textContent = `Saving configuration "${userDefinedConfigName}"...`;
            // ... (Firebase save logic as before) ...
            const { database, dbSet, dbRef } = window.firebaseOMSI;
            try {
                const fullSavePath = `${FB_PATH_RSG_CONFIGS}/${firebaseKey}`;
                await dbSet(dbRef(database, fullSavePath), configurationToSave);
                
                rsg_loadedConfigs_extra[firebaseKey] = JSON.parse(JSON.stringify(configurationToSave)); 
                rsg_renderSavedConfigsList_ExtraPage(); 

                modalStatus.textContent = `Configuration "${userDefinedConfigName}" saved successfully!`;
                // ... (status updates and context variable updates as before) ...
                rsg_currentlyEditingConfigKey_extra = firebaseKey;
                rsg_currentlyEditingConfigDisplayName_extra = userDefinedConfigName;
                rsg_lastLoadedRouteName_extra = currentRouteName;
                rsg_lastLoadedDestName_extra = currentDestName;
                rsg_lastLoadedOpProfile_extra = currentOpProfiles;
                
                rsg_isDirty = false; 
                console.log("RSG State: Configuration saved successfully, rsg_isDirty reset to false.");

                setTimeout(rsg_hideSaveConfigModal_ExtraPage, 1500);
            } catch (error) {
                // ... (error handling as before) ...
                console.error("Error saving RSG configuration to Firebase:", error);
                modalStatus.textContent = "Error saving configuration: " + error.message;
            }
        }

async function rsg_performRenameConfiguration_ExtraPage(configKeyToRename, newDisplayName) {
    const statusElement = document.getElementById('rsg-load-status-message-extra'); // Use the status message for the saved configs list

    if (!configKeyToRename) {
        if (statusElement) {
            statusElement.textContent = "Error: No configuration key provided for renaming.";
            statusElement.style.color = "#e74c3c";
        }
        console.error("rsg_performRenameConfiguration_ExtraPage: configKeyToRename is missing.");
        return;
    }

    // newDisplayName is assumed to be non-empty and trimmed by the caller
    // If it could still be empty, an additional check here would be good. For now, we assume caller handles it.

    const configToUpdate = rsg_loadedConfigs_extra[configKeyToRename];
    if (!configToUpdate) {
        if (statusElement) {
            statusElement.textContent = "Error: Original configuration data could not be found. Cannot rename.";
            statusElement.style.color = "#e74c3c";
        }
        console.error(`Failed to find config data for key: ${configKeyToRename} in rsg_loadedConfigs_extra.`);
        return;
    }

    if (statusElement) {
        statusElement.textContent = `Renaming configuration to "${newDisplayName}"...`;
        statusElement.style.color = "#f1c40f";
    }

    const updatedConfigData = {
        ...configToUpdate,
        userDisplayName: newDisplayName, // Already trimmed by caller
        lastSaved: new Date().toISOString()
    };

    const { database, dbSet, dbRef } = window.firebaseOMSI;
    try {
        await dbSet(dbRef(database, `${FB_PATH_RSG_CONFIGS}/${configKeyToRename}`), updatedConfigData);
        rsg_loadedConfigs_extra[configKeyToRename] = updatedConfigData; // Update local cache
        rsg_renderSavedConfigsList_ExtraPage(); // Refresh the displayed list

        if (statusElement) {
            statusElement.textContent = `Configuration successfully renamed to "${newDisplayName}"!`;
            statusElement.style.color = "#2ecc71";
        }
        // No modal to hide anymore for this process
    } catch (error) {
        console.error("Error renaming RSG configuration in Firebase:", error);
        if (statusElement) {
            statusElement.textContent = "Error renaming configuration: " + error.message;
            statusElement.style.color = "#e74c3c";
        }
    }
}

function toTitleCase_rsg(str) {
    if (!str || typeof str !== 'string') return "";
    // This will convert "LAKESIDE" to "Lakeside", "HIGH STREET" to "High Street", etc.
    return str.replace(/\w\S*/g, function(txt){
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
}

function rsg_renderSavedConfigsList_ExtraPage() {
    const container = document.getElementById('rsg-saved-configs-list-extra');
    if (!container) {
        console.error("RSG Saved Configs: Container element 'rsg-saved-configs-list-extra' not found.");
        return;
    }
    container.innerHTML = ''; // Clear previous list content first

    // 1. Get all unique route names from the current working schedule (these are considered "active" routes)
    const activeRouteNamesFromSchedule = [...new Set(
        currentWorkingSchedule_extra
            .map(entry => entry.lineName)
            .filter(Boolean) // Remove undefined/null/empty lineNames
    )];

    // 2. Group existing rsg_loadedConfigs_extra by their internal routeName
    const configsByRouteFromSaved = {};
    let hasAnySavedConfigs = false;
    if (rsg_loadedConfigs_extra && typeof rsg_loadedConfigs_extra === 'object') {
        Object.keys(rsg_loadedConfigs_extra).forEach(key => {
            hasAnySavedConfigs = true;
            const configData = rsg_loadedConfigs_extra[key];
            const routeNameFromConfig = configData.routeName || "Unspecified Route"; // Fallback for configs missing routeName
            if (!configsByRouteFromSaved[routeNameFromConfig]) {
                configsByRouteFromSaved[routeNameFromConfig] = [];
            }
            configsByRouteFromSaved[routeNameFromConfig].push({ key: key, data: configData });
        });
    }

    // 3. Determine the final list of all route names to display headings for.
    // This includes all routes from the current schedule AND any routes that only exist in saved configs.
    const allRouteNamesToDisplaySet = new Set([
        ...activeRouteNamesFromSchedule,
        ...Object.keys(configsByRouteFromSaved).filter(rn => rn !== "Unspecified Route") // Add routes from configs that might not be in current schedule
    ]);
    const sortedAllRouteNamesToDisplay = Array.from(allRouteNamesToDisplaySet).sort(compareLineNames_ExtraPage);


    if (sortedAllRouteNamesToDisplay.length === 0 && !(configsByRouteFromSaved["Unspecified Route"] && configsByRouteFromSaved["Unspecified Route"].length > 0)) {
        // This message appears if there are no routes in the schedule AND no saved configurations at all.
        const p = document.createElement('p');
        p.id = "rsg-no-saved-configs-message-extra"; // Keep ID for consistency if styles depend on it
        p.style.padding = "0.5em";
        p.style.textAlign = "center";
        p.style.opacity = "0.7";
        p.textContent = "No active routes in schedule and no configurations saved yet.";
        container.appendChild(p);
        return;
    }

    // Iterate through all routes that should have a heading
    sortedAllRouteNamesToDisplay.forEach(routeName => {
        const routeHeading = document.createElement('h4');
        routeHeading.textContent = `Route ${routeName}:`;
        routeHeading.style.marginTop = "0.8em";
        routeHeading.style.marginBottom = "0.4em";
        routeHeading.style.fontSize = "1.1em";
        routeHeading.style.color = "#ecf0f1"; // Ensure heading color
        routeHeading.style.borderBottom = "1px solid rgba(127,140,141,0.3)";
        routeHeading.style.paddingBottom = "0.2em";
        if (container.children.length > 0) { // Add more top margin if not the first heading
            routeHeading.style.marginTop = "1.2em";
        }
        container.appendChild(routeHeading);

        const configsForThisRoute = configsByRouteFromSaved[routeName];

        if (configsForThisRoute && configsForThisRoute.length > 0) {
            // Sort and display these saved configs as before
            configsForThisRoute.sort((a, b) => {
                const nameA = (a.data.userDisplayName || a.key).toLowerCase();
                const nameB = (b.data.userDisplayName || b.key).toLowerCase();
                const nameCompare = nameA.localeCompare(nameB);
                if (nameCompare !== 0) return nameCompare;
                const destA = a.data.destinationName || "";
                const destB = b.data.destinationName || "";
                return destA.localeCompare(destB);
            });

            configsForThisRoute.forEach(configItem => {
                const configKey = configItem.key;
                const configData = configItem.data;
                const originalUserDisplayName = configData.userDisplayName || configKey;
                const routeNameForDesc = configData.routeName || "N/A";
                let destinationNameForDesc = configData.destinationName || "N/A";
                if (destinationNameForDesc !== "N/A") {
                    destinationNameForDesc = toTitleCase_rsg(destinationNameForDesc);
                }
                let operatingProfileForDesc = configData.operatingProfile || "N/A";
                if (operatingProfileForDesc !== "N/A" && typeof operatingProfileForDesc === 'string') {
                    operatingProfileForDesc = operatingProfileForDesc.split(',')
                                                 .map(p => p.trim())
                                                 .join(', ');
                }
                const descriptiveParametersString = `${routeNameForDesc} to ${destinationNameForDesc} - ${operatingProfileForDesc}`;

                const itemDiv = document.createElement('div');
                itemDiv.style.padding = "0.4em 0.6em";
                itemDiv.style.marginBottom = "0.3em";
                itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)";
                itemDiv.style.borderRadius = "0.25rem";
                itemDiv.style.display = "flex";
                itemDiv.style.justifyContent = "space-between";
                itemDiv.style.alignItems = "center";
                itemDiv.addEventListener('mouseover', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.1)");
                itemDiv.addEventListener('mouseout', () => itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)");
                itemDiv.title = `Load: ${originalUserDisplayName}\n(Parameters: ${descriptiveParametersString})\n(Key: ${configKey})`;

                const nameSpan = document.createElement('span');
                nameSpan.textContent = originalUserDisplayName;
                nameSpan.style.flexGrow = "1";
                nameSpan.style.cursor = "pointer";
                nameSpan.addEventListener('click', () => rsg_handleLoadSelectedConfig_ExtraPage(configKey));

                const actionButtonsDiv = document.createElement('div');
                actionButtonsDiv.style.display = 'flex';
                actionButtonsDiv.style.alignItems = 'center';

                const renameBtn = document.createElement('button');
                renameBtn.textContent = 'Rename';
                renameBtn.classList.add('button', 'small-action', 'neutral');
                renameBtn.style.marginRight = "0.3em";
                renameBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const statusElement = document.getElementById('rsg-load-status-message-extra');
                    if (statusElement) statusElement.textContent = "";
                    const newNameFromPrompt = prompt(`Enter new name for configuration currently named "${originalUserDisplayName}":`, originalUserDisplayName);
                    if (newNameFromPrompt === null) { /* User cancelled */ }
                    else if (newNameFromPrompt.trim() === "") { /* Name cannot be empty */ }
                    else if (newNameFromPrompt.trim() === originalUserDisplayName) { /* Name unchanged */ }
                    else { rsg_performRenameConfiguration_ExtraPage(configKey, newNameFromPrompt.trim()); }
                });
                actionButtonsDiv.appendChild(renameBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'âœ•';
                deleteBtn.classList.add('button', 'small-action', 'secondary');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    rsg_handleDeleteSavedConfig_ExtraPage(configKey, originalUserDisplayName);
                });
                actionButtonsDiv.appendChild(deleteBtn);

                itemDiv.appendChild(nameSpan);
                itemDiv.appendChild(actionButtonsDiv);
                container.appendChild(itemDiv);
            });
        } else {
            // This route (from currentWorkingSchedule or the combined list) has no saved RSG configurations.
            const noConfigsForRouteMsg = document.createElement('p');
            noConfigsForRouteMsg.textContent = "(No saved RSG configurations for this route)";
            noConfigsForRouteMsg.style.fontSize = "0.85em";
            noConfigsForRouteMsg.style.fontStyle = "italic";
            noConfigsForRouteMsg.style.opacity = "0.7";
            noConfigsForRouteMsg.style.paddingLeft = "0.6em";
            noConfigsForRouteMsg.style.marginBottom = "0.5em";
            container.appendChild(noConfigsForRouteMsg);
        }
    });

    // Handle "Unspecified Route" configs separately at the end if they exist
    if (configsByRouteFromSaved["Unspecified Route"] && configsByRouteFromSaved["Unspecified Route"].length > 0) {
        const unspecifiedHeading = document.createElement('h4');
        unspecifiedHeading.textContent = "Route: Unspecified Route (from saved configs)";
        unspecifiedHeading.style.marginTop = "1.2em";
        unspecifiedHeading.style.marginBottom = "0.4em";
        unspecifiedHeading.style.fontSize = "1.1em";
        unspecifiedHeading.style.color = "#ecf0f1";
        unspecifiedHeading.style.borderBottom = "1px solid rgba(127,140,141,0.3)";
        unspecifiedHeading.style.paddingBottom = "0.2em";
        container.appendChild(unspecifiedHeading);

        configsByRouteFromSaved["Unspecified Route"].forEach(configItem => {
            // Re-use the same rendering logic for config items
            const configKey = configItem.key;
            const configData = configItem.data;
            const originalUserDisplayName = configData.userDisplayName || configKey;
            const descriptiveParametersString = `Unspecified Route - Profile: ${configData.operatingProfile || 'N/A'} - Dest: ${toTitleCase_rsg(configData.destinationName || 'N/A')}`;
            const itemDiv = document.createElement('div'); /* ... same style as above ... */
            itemDiv.style.padding = "0.4em 0.6em"; itemDiv.style.marginBottom = "0.3em"; itemDiv.style.backgroundColor = "rgba(255,255,255,0.05)"; itemDiv.style.borderRadius = "0.25rem"; itemDiv.style.display = "flex"; itemDiv.style.justifyContent = "space-between"; itemDiv.style.alignItems = "center";
            itemDiv.title = `Load: ${originalUserDisplayName}\n(Parameters: ${descriptiveParametersString})\n(Key: ${configKey})`;
            const nameSpan = document.createElement('span'); nameSpan.textContent = originalUserDisplayName; nameSpan.style.flexGrow = "1"; nameSpan.style.cursor = "pointer"; nameSpan.addEventListener('click', () => rsg_handleLoadSelectedConfig_ExtraPage(configKey));
            const actionButtonsDiv = document.createElement('div'); /* ... same buttons and listeners as above ... */
            const renameBtn = document.createElement('button'); renameBtn.textContent = 'Rename'; /* ... */ actionButtonsDiv.appendChild(renameBtn);
            const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'âœ•'; /* ... */ actionButtonsDiv.appendChild(deleteBtn);
            itemDiv.appendChild(nameSpan); itemDiv.appendChild(actionButtonsDiv);
            container.appendChild(itemDiv);
        });
    }
}

async function rsg_handleDeleteSavedConfig_ExtraPage(configKey, displayName) {
    if (!confirm(`Are you sure you want to delete the saved configuration: "${displayName}"? This cannot be undone.`)) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Deletion cancelled.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    if (!window.firebaseOMSI || !window.firebaseOMSI.database || !window.firebaseOMSI.dbGet) { // Added dbGet check
        alert("Firebase components not available. Cannot delete configuration.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Firebase components not available.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    // Make sure dbGet is correctly aliased as get if you use it directly like in the check below
    const { database, dbRemove, dbRef, dbGet: get } = window.firebaseOMSI; // Using alias 'get' for dbGet
    const configPath = `${FB_PATH_RSG_CONFIGS}/${configKey}`;

    if (rsgStatusMessage_el_extra) {
        rsgStatusMessage_el_extra.textContent = `Attempting to delete "${displayName}" (key: ${configKey}) from Firebase path: ${configPath}...`;
        rsgStatusMessage_el_extra.style.color = "#3498db"; // Blue for processing
    }
    console.log(`Attempting to delete from Firebase path: ${configPath}`);

    try {
        await dbRemove(dbRef(database, configPath));
        console.log(`Firebase dbRemove promise resolved for path: ${configPath}. Attempting to verify deletion from server...`);

        // VERIFICATION STEP: Try to fetch the data again immediately after deletion.
        // This helps confirm if the server actually processed the delete.
        const checkSnapshot = await get(dbRef(database, configPath)); // Using the aliased 'get'

        if (checkSnapshot.exists()) {
            // If it still exists, the delete didn't work on the server.
            console.error(`VERIFICATION FAILED: Config "${displayName}" (key: ${configKey}) still exists in Firebase at ${configPath} after dbRemove was called and resolved. This is unexpected.`);
            alert(`Error: Deletion for "${displayName}" appeared to succeed client-side, but the data is still present on the server. Please check Firebase rules for path "${FB_PATH_RSG_CONFIGS}" and its children, and network connectivity. Refreshing the list to reflect the server state.`);
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Deletion of "${displayName}" failed to persist on server. List refreshed.`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            // Force a reload of all RSG configs from Firebase to ensure UI matches the server.
            loadInitialData_ExtraPage(); // Or a more targeted reload for RSG configs if available
            return;
        } else {
            console.log(`VERIFICATION SUCCESS: Config "${displayName}" (key: ${configKey}) confirmed deleted from Firebase server path: ${configPath}.`);
        }

        // If verification passes (or if you skip verification), update local cache and UI.
        delete rsg_loadedConfigs_extra[configKey];
        rsg_renderSavedConfigsList_ExtraPage();

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Configuration "${displayName}" deleted successfully.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
        }

    } catch (error) { // This catch is for errors from dbRemove or the verification 'get'
        console.error(`Error during Firebase operation for configuration "${displayName}" (key: ${configKey}):`, error);
        alert(`Failed to delete configuration "${displayName}". Error: ${error.message}. The list may be out of sync. Please refresh.`);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error deleting configuration "${displayName}": ${error.message}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        // On error, it's good practice to reload data to ensure UI consistency.
        loadInitialData_ExtraPage(); // Or a more targeted reload for RSG configs
    }
}

function rsg_getOtherRouteAdjustmentsForStop(targetStopID, currentEditingConfigKey) {
    const adjustmentsMap = new Map(); // Key: adjustmentValue, Value: { count: N, routeNames: Set() }

    if (!rsg_loadedConfigs_extra || typeof rsg_loadedConfigs_extra !== 'object') {
        return { hasDiscrepancies: false, mostCommonValue: null, suggestionTitle: '' };
    }

    for (const configKey in rsg_loadedConfigs_extra) {
        // Skip the configuration currently being edited to avoid comparing with its own (potentially unsaved) state
        if (configKey === currentEditingConfigKey) {
            continue;
        }

        const config = rsg_loadedConfigs_extra[configKey];
        if (config && Array.isArray(config.stopSequence)) {
            for (let i = 0; i < config.stopSequence.length; i++) {
                const stopInOtherConfig = config.stopSequence[i];
                // We only care about adjustments for the same stopID,
                // and only if it's not the first stop in that other sequence (index > 0),
                // and if timeAdjustment is a valid number.
                if (stopInOtherConfig.stopID === targetStopID &&
                    i > 0 && // Not the first stop (as first stop has no preceding adjustment)
                    typeof stopInOtherConfig.timeAdjustment === 'number' &&
                    !isNaN(stopInOtherConfig.timeAdjustment)) {

                    const adjValue = stopInOtherConfig.timeAdjustment;
                    if (!adjustmentsMap.has(adjValue)) {
                        adjustmentsMap.set(adjValue, { count: 0, routeNames: new Set() });
                    }
                    const existingEntry = adjustmentsMap.get(adjValue);
                    existingEntry.count++;
                    existingEntry.routeNames.add(config.routeName || "Unknown Route");
                }
            }
        }
    }

    if (adjustmentsMap.size === 0) {
        return { hasDiscrepancies: false, mostCommonValue: null, suggestionTitle: '' }; // No other routes use this stop with an adjustment
    }

    let mostCommonValue = null;
    let maxCount = 0;
    let allUniqueAdjustmentsFromOthers = [];

    adjustmentsMap.forEach((data, adjValue) => {
        allUniqueAdjustmentsFromOthers.push(adjValue);
        if (data.count > maxCount) {
            maxCount = data.count;
            mostCommonValue = adjValue;
        } else if (data.count === maxCount) {
            // Tie-breaking rule: prefer the smaller adjustment value if counts are equal
            if (mostCommonValue === null || adjValue < mostCommonValue) {
                mostCommonValue = adjValue;
            }
        }
    });
    
    let suggestionTitle = '';
    if (mostCommonValue !== null) {
        const routesUsingMostCommon = Array.from(adjustmentsMap.get(mostCommonValue)?.routeNames || []).slice(0,3).join(', ');
        const andMore = (adjustmentsMap.get(mostCommonValue)?.routeNames.size || 0) > 3 ? ' & more' : '';
        suggestionTitle = `Commonly +${mostCommonValue} min (on routes: ${routesUsingMostCommon}${andMore}). Click to apply.`;
    }


    return {
        // hasDiscrepancies: true if there are other adjustments and the current one differs from the mostCommon
        // This will be checked in the rendering function against the current stop's actual adjustment.
        allUniqueAdjustmentsFromOthers: allUniqueAdjustmentsFromOthers.sort((a,b) => a-b),
        mostCommonValue: mostCommonValue, // The adjustment value to suggest
        suggestionTitle: suggestionTitle  // Tooltip for the warning icon
    };
}

function rsg_handleLoadSelectedConfig_ExtraPage(configKey) {
    const configData = rsg_loadedConfigs_extra[configKey];
    const loadStatusMsg = document.getElementById('rsg-load-status-message-extra');

    if (!configData) {
        if (loadStatusMsg) loadStatusMsg.textContent = "Error: Could not find configuration data for " + configKey;
        console.error("Could not find config data for key:", configKey);
        rsg_currentlyEditingConfigKey_extra = null; // Clear if load fails
        rsg_currentlyEditingConfigDisplayName_extra = null;
        return;
    }

    // Store details of the loaded config
    rsg_currentlyEditingConfigKey_extra = configKey;
    rsg_currentlyEditingConfigDisplayName_extra = configData.userDisplayName || configKey;

    rsgRouteNameInput_el_extra.value = configData.routeName || "";
    rsgDestinationNameInput_el_extra.value = configData.destinationName || "";
    rsg_setCheckedProfiles_ExtraPage(configData.operatingProfile || "");
    rsg_selectedStops_extra = JSON.parse(JSON.stringify(configData.stopSequence || []));
    rsgFirstStopTimesInput_el_extra.value = configData.firstStopTimes || "";

    rsg_lastLoadedRouteName_extra = configData.routeName || "";
    rsg_lastLoadedDestName_extra = configData.destinationName || "";
    rsg_lastLoadedOpProfile_extra = configData.operatingProfile || "";

    rsg_renderStopSequence_ExtraPage();
    rsg_resetPreviewState(`Loaded configuration: "${rsg_currentlyEditingConfigDisplayName_extra}". Adjust and save if needed.`, "success");
    if (loadStatusMsg) loadStatusMsg.textContent = `Loaded: "${rsg_currentlyEditingConfigDisplayName_extra}"`;

    rsgRouteNameInput_el_extra.dispatchEvent(new Event('blur'));
    setTimeout(() => {
         rsgDestinationNameInput_el_extra.dispatchEvent(new Event('blur'));
    },50);
}

function getDaySortOrder_ExtraPage(profile) {
    if (!profile) return 9999;
    const p = String(profile).toUpperCase().replace(/\s+/g, ''); 
    const has = (keywords) => keywords.some(kw => p.includes(kw));
    let baseScore = 9000;

    if (has(["MONDAY", "MO"])) baseScore = 100;
    else if (has(["TUESDAY", "TU"])) baseScore = 200;
    else if (has(["WEDNESDAY", "WE"])) baseScore = 300;
    else if (has(["THURSDAY", "TH"])) baseScore = 400;
    else if (has(["FRIDAY", "FR"]) && !p.includes("GOODFRIDAY")) baseScore = 500;
    else if (has(["MON-FRI", "MONTOFRI", "WEEKDAY", "MF"])) baseScore = 600; 
    else if (has(["SATURDAY", "SA"]) && !p.includes("GOODFRIDAY")) baseScore = 700; 
    else if (has(["SUNDAY", "SU"])) baseScore = 800;

    if (baseScore < 9000) { 
        if (has(["SCH"])) return baseScore + 1;    
        if (has(["NSD"])) return baseScore + 2;    
        return baseScore; 
    }
    // Specific holiday scores (ensure these match what's in RSG_OPERATING_PROFILES_LIST if they are standalone)
    if (has(["CHRISTMASDAY"])) return 9030; // Example scores
    if (has(["BOXINGDAY"])) return 9040;
    if (has(["NEWYEARSDAY"])) return 9050;
    // Removed GoodFriday, SchoolHoliday, BankHoliday, AllDays from here if they are no longer primary types

    if (String(profile).includes(',')) { // For sorting already combined strings if needed elsewhere
        const parts = String(profile).split(',');
        let minScoreForParts = 9999;
        for (const part of parts) {
            minScoreForParts = Math.min(minScoreForParts, getDaySortOrder_ExtraPage(part.trim())); 
        }
        return minScoreForParts;
    }
    return baseScore; 
}

function rsg_populateProfileCheckboxes_ExtraPage() {
    const container = document.getElementById('rsg-selectable-profiles-container-extra');
    const placeholder = document.getElementById('rsg-profiles-placeholder-extra');
    if (!container) {
        console.error("RSG Profile checkbox container not found!");
        return;
    }
    container.innerHTML = ''; 

    if (RSG_OPERATING_PROFILES_LIST.length === 0 && placeholder) {
        placeholder.textContent = "No profiles defined to display.";
        container.appendChild(placeholder);
        return;
    }

    RSG_OPERATING_PROFILES_LIST.forEach(profileValue => {
        const wrapper = document.createElement('div');
        wrapper.style.display = 'inline-flex'; 
        wrapper.style.alignItems = 'center';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        const safeProfileId = profileValue.replace(/[^a-zA-Z0-9_-]/g, '');
        checkbox.id = `rsg-profile-cb-${safeProfileId}-extra`;
        checkbox.value = profileValue;
        checkbox.name = 'rsgOperatingProfileCheckbox_extra';
        checkbox.classList.add('rsg-profile-checkbox'); 

        checkbox.addEventListener('change', rsg_handleProfileSelectionChange_ExtraPage);

        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.textContent = profileValue;
        label.style.marginLeft = "4px"; 
        label.style.cursor = "pointer";
        label.style.color = "#ecf0f1"; 

        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        container.appendChild(wrapper);
    });
    // DO NOT call rsg_handleProfileSelectionChange_ExtraPage or rsg_updateDisabledProfileCheckboxes_ExtraPage here.
    // The initial state will be set after the first call to rsg_loadOrPullConfiguration_ExtraPage from showExtraPageSection.
}

function populateTimetableExporterRouteSelect_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !currentWorkingSchedule_extra) {
        console.warn("Timetable Exporter: Route select element or schedule data not available.");
        return;
    }
    const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName).filter(Boolean))].sort(compareLineNames_ExtraPage);
    
    const currentInputValue = tteRouteNameInput_el_extra ? tteRouteNameInput_el_extra.value.trim() : "";
    
    tteRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Route --</option>';
    uniqueRoutes.forEach(route => {
        const opt = document.createElement('option');
        opt.value = route;
        opt.textContent = route;
        tteRouteNameSelect_el_extra.appendChild(opt);
    });

    if (currentInputValue) {
        const matchedOption = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
        tteRouteNameSelect_el_extra.value = matchedOption ? matchedOption : "";
    } else {
        tteRouteNameSelect_el_extra.value = "";
    }
}

// --- Helper Functions for PDF Timetable Generation ---

// Helper to convert HH:MM time string to absolute minutes from start of day
function getAbsMinutes(timeStr, dayOffset = 0) {
    // Check if timeStr is valid and in HH:MM format
    if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {
        // console.warn("getAbsMinutes: Invalid timeStr provided:", timeStr);
        return null; 
    }
    const parts = timeStr.split(':');
    if (parts.length !== 2) {
        // console.warn("getAbsMinutes: timeStr not in HH:MM format:", timeStr);
        return null;
    }

    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    
    // Ensure hours and minutes are valid numbers
    if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
        // console.warn("getAbsMinutes: Invalid hours or minutes in timeStr:", timeStr);
        return null;
    }

    // Ensure dayOffset is treated as a number, default to 0 if NaN or invalid
    const numericDayOffset = parseInt(dayOffset, 10);
    const validDayOffset = isNaN(numericDayOffset) ? 0 : numericDayOffset;
    
    return (validDayOffset * 1440) + (hours * 60) + minutes;
}

function toTitleCase_display(str) {
    if (!str || typeof str !== 'string') return "";
    return str.toLowerCase().split(' ').map(function(word) {
        if (word.length > 0) {
            // Handle special cases like "Year's" correctly
            if (word.includes("'")) {
                const parts = word.split("'");
                parts[0] = parts[0].charAt(0).toUpperCase() + parts[0].substring(1);
                return parts.join("'");
            }
            return word.charAt(0).toUpperCase() + word.substring(1);
        }
        return "";
    }).join(' ');
}

async function handleDownloadTimetable_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !tteRouteNameInput_el_extra || !tteStatusMessage_el_extra) {
        console.warn("Timetable Exporter: Essential UI elements are missing for download.");
        if(tteStatusMessage_el_extra) {
             tteStatusMessage_el_extra.textContent = "Initialization error. Try refreshing.";
             tteStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const routeName = tteRouteNameInput_el_extra.value.trim() || tteRouteNameSelect_el_extra.value;

    if (!routeName) {
        tteStatusMessage_el_extra.textContent = "Please select or enter a route name.";
        tteStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    if (!currentUser_extra || typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined' || typeof window.jspdf.jsPDF.API.autoTable === 'undefined') {
        tteStatusMessage_el_extra.textContent = "Error: PDF library not ready or not logged in.";
        tteStatusMessage_el_extra.style.color = "#e74c3c";
        console.error("jsPDF or jsPDF-AutoTable not correctly loaded. window.jspdf:", window.jspdf);
        return;
    }

    tteStatusMessage_el_extra.textContent = `Processing PDF timetable for route: ${routeName}...`;
    tteStatusMessage_el_extra.style.color = "#3498db";

    try {
        const routeEntries = currentWorkingSchedule_extra.filter(e => e.lineName === routeName);
        if (routeEntries.length === 0) {
            tteStatusMessage_el_extra.textContent = `No schedule data found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'landscape',
            unit: 'pt',
            format: 'a4'
        });
        let isFirstTableInPDF = true;

        const uniqueProfileDestPairs = new Map();
        routeEntries.forEach(e => {
            if (e.OperatingProfile && e.destinationName) {
                uniqueProfileDestPairs.set(`${e.OperatingProfile}|${e.destinationName}`, true);
            }
        });

        if (uniqueProfileDestPairs.size === 0) {
            tteStatusMessage_el_extra.textContent = `No operating profile/destination combinations found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }
        
        const sortedPairs = Array.from(uniqueProfileDestPairs.keys()).sort((a,b) => {
            const [profA, destA] = a.split('|');
            const [profB, destB] = b.split('|');
            const profCompare = profA.localeCompare(profB);
            if (profCompare !== 0) return profCompare;
            return destA.localeCompare(destB);
        });

        let tablesAddedToPDF = 0;

        for (const pair of sortedPairs) {
            const [opProfile, destName] = pair.split('|');
            let specificEntries = routeEntries.filter(e =>
                e.OperatingProfile === opProfile && e.destinationName === destName
            );

            if (specificEntries.length === 0) continue;

            specificEntries.sort((a, b) => {
                const dayOffsetA = parseInt(a.DayOffset || 0);
                const dayOffsetB = parseInt(b.DayOffset || 0);
                if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
                const timeA = (a.scheduledTime || "99:99").replace(':', '');
                const timeB = (b.scheduledTime || "99:99").replace(':', '');
                return timeA.localeCompare(timeB);
            });

            const trips = segmentEntriesIntoTrips_forTimetable(specificEntries);
            if (trips.length === 0) continue;

            const stopOrderMap = new Map();
            let globalStopIndexForOrdering = 0;
            trips.forEach(trip => { // Use all trips to define the superset of stops in order
                trip.forEach(entry => {
                    if (!entry.stopID || !entry.scheduledTime) return;
                    const currentStopTimeAbsVal = (parseInt(entry.DayOffset || 0) * 1440) +
                                             parseInt(entry.scheduledTime.split(':')[0]) * 60 +
                                             parseInt(entry.scheduledTime.split(':')[1]);
                    if (!stopOrderMap.has(entry.stopID)) {
                        stopOrderMap.set(entry.stopID, {
                            stopID: entry.stopID, name: entry.stopName, direction: entry.direction,
                            earliestTimeAbs: currentStopTimeAbsVal, 
                            firstSeenIndex: globalStopIndexForOrdering++
                        });
                    }
                });
            });
            const canonicalStopSequence = Array.from(stopOrderMap.values()).sort((a,b) => a.firstSeenIndex - b.firstSeenIndex);

            if (canonicalStopSequence.length === 0) continue;

            const tableHead = [["Stop ID", "Stop Name", "Stop Aim"]];
            trips.forEach((trip, index) => {
                tableHead[0].push(trip[0] ? `${trip[0].scheduledTime}` : `Trip ${index + 1}`);
            });

            const tableBody = [];
            canonicalStopSequence.forEach(stopInfo => {
                const row = [stopInfo.stopID || "", stopInfo.name || "", stopInfo.direction || ""];
                trips.forEach(trip => {
                    const entryForStopInTrip = trip.find(e => e.stopID === stopInfo.stopID);
                    row.push(entryForStopInTrip ? entryForStopInTrip.scheduledTime : "-");
                });
                tableBody.push(row);
            });

            if (tableBody.length > 0) {
                if (!isFirstTableInPDF) {
                    doc.addPage('a4', 'landscape');
                }
                isFirstTableInPDF = false;

                doc.setFontSize(14);
                doc.text(`Route: ${routeName}`, 40, 40);
                doc.setFontSize(11);
                doc.text(`Direction: Towards ${destName}`, 40, 55); // Adjusted Y for spacing
                doc.text(`Operating Profile: ${opProfile}`, 40, 70); // Adjusted Y for spacing

                doc.autoTable({
                    head: tableHead,
                    body: tableBody,
                    startY: 85, // Adjusted startY
                    theme: 'grid',
                    styles: { fontSize: 6, cellPadding: 1.5, overflow: 'visible' }, // 'ellipsize' or 'visible' or 'linebreak'
                    headStyles: { fillColor: [44, 62, 80], textColor: 255, fontSize: 7, fontStyle: 'bold', halign: 'center' },
                    columnStyles: {
                        0: { cellWidth: 50, fontStyle: 'bold' }, 
                        1: { cellWidth: 120 },
                        2: { cellWidth: 100 },
                        // For time columns, you might let them auto-adjust or set a small fixed width if many
                    },
                    margin: { top: 25, right: 30, bottom: 30, left: 40 }, // Adjusted top margin
                    tableWidth: 'auto',
                });
                tablesAddedToPDF++;
            }
        }

        if (tablesAddedToPDF > 0) {
            doc.save(`${sanitizeFirebaseKey(routeName)}_Timetable.pdf`);
            tteStatusMessage_el_extra.textContent = `Timetable PDF for ${routeName} generated successfully!`;
            tteStatusMessage_el_extra.style.color = "#2ecc71";
        } else {
            tteStatusMessage_el_extra.textContent = `No valid trip data found to generate PDF for route ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
        }

    } catch (error) {
        console.error("Error generating PDF timetable:", error);
        tteStatusMessage_el_extra.textContent = "Error generating PDF: " + error.message;
        tteStatusMessage_el_extra.style.color = "#e74c3c";
    }
}

// --- Helper function to segment entries into individual trips for PDF Timetable ---

function segmentEntriesIntoTrips_forTimetable(profileDestEntries, minStopsPerTripHeuristic = 1) { // <-- SET TO 200
    const allTrips = [];
    if (!profileDestEntries || profileDestEntries.length === 0) {
        return allTrips;
    }

    profileDestEntries.sort((a, b) => {
        const dayOffsetA = parseInt(a.DayOffset || 0);
        const dayOffsetB = parseInt(b.DayOffset || 0);
        if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
        const timeA = (a.scheduledTime || "99:99").replace(':', '');
        const timeB = (b.scheduledTime || "99:99").replace(':', '');
        return timeA.localeCompare(timeB);
    });

    let currentTrip = [];
    let previousStopTimeInAbsoluteMinutes = -1;
    let firstStopTimeOfCurrentLogicalTrip = -1;

    const rpdContext = profileDestEntries.length > 0 ? `(Route: ${profileDestEntries[0].lineName}, Profile: ${profileDestEntries[0].OperatingProfile}, Dest: ${profileDestEntries[0].destinationName})` : "";

    for (let i = 0; i < profileDestEntries.length; i++) {
        const entry = profileDestEntries[i];
        if (!entry.stopID || !entry.scheduledTime) continue;

        const currentStopTimeInAbsoluteMinutes =
            (parseInt(entry.DayOffset || 0) * 1440) +
            parseInt(entry.scheduledTime.split(':')[0]) * 60 +
            parseInt(entry.scheduledTime.split(':')[1]);

        if (currentTrip.length === 0) { 
            firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes;
        }
        
        if (currentTrip.length > 0) {
            // Condition 1: Time goes backward
            if (currentStopTimeInAbsoluteMinutes < previousStopTimeInAbsoluteMinutes) {
                console.log(`TRIP SPLIT (Time Regression) ${rpdContext}: Prev Stop ${currentTrip[currentTrip.length-1].stopID} (${currentTrip[currentTrip.length-1].scheduledTime} Day ${currentTrip[currentTrip.length-1].DayOffset || 0} / Abs: ${previousStopTimeInAbsoluteMinutes}), Curr Stop ${entry.stopID} (${entry.scheduledTime} Day ${entry.DayOffset || 0} / Abs: ${currentStopTimeInAbsoluteMinutes})`);
                allTrips.push([...currentTrip]); 
                currentTrip = []; 
                firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes; 
            } 
            // Condition 2: The STARTING STOP OF THE CURRENT TRIP is seen again
            // This condition is now very unlikely to be met with minStopsPerTripHeuristic = 9000
            else if (entry.stopID === currentTrip[0].stopID && 
                     currentTrip.length >= minStopsPerTripHeuristic && 
                     currentStopTimeInAbsoluteMinutes !== firstStopTimeOfCurrentLogicalTrip
                    ) {
                console.log(`TRIP SPLIT (Current Trip Start Stop Repeat) ${rpdContext}: Curr Stop ${entry.stopID} at ${entry.scheduledTime} (Abs: ${currentStopTimeInAbsoluteMinutes}), CurrentTripStartStopID: ${currentTrip[0].stopID}, TripLength: ${currentTrip.length}, minHeuristic: ${minStopsPerTripHeuristic}, FirstTimeOfCurrentTrip: ${firstStopTimeOfCurrentLogicalTrip}`);
                allTrips.push([...currentTrip]); 
                currentTrip = []; 
                firstStopTimeOfCurrentLogicalTrip = currentStopTimeInAbsoluteMinutes; 
            }
        }
        
        currentTrip.push(entry);
        previousStopTimeInAbsoluteMinutes = currentStopTimeInAbsoluteMinutes;
    }

    if (currentTrip.length > 0) {
        allTrips.push([...currentTrip]);
    }
    return allTrips;
}

// Helper to format a single time object for display
function formatTimeForDisplay(timeObject) {
    // timeObject = { absMinutes, displayTime, dayOffset }
    return timeObject.displayTime; 
}

function determineCanonicalStopSequence(specificEntriesForRPD) {
    const stopData = new Map(); // stopID -> { stopID, name, earliestAbsMinutes, firstSeenOriginalIndex }

    // The specificEntriesForRPD should already be sorted chronologically 
    // by the time this function is called in handleDownloadTimetable_ExtraPage
    specificEntriesForRPD.forEach((entry, index) => {
        if (entry.stopID && entry.scheduledTime) {
            const absMinutes = getAbsMinutes(entry.scheduledTime, parseInt(entry.DayOffset || 0));
            if (absMinutes === null) return;

            if (!stopData.has(entry.stopID)) {
                stopData.set(entry.stopID, {
                    stopID: entry.stopID,
                    name: entry.stopName,
                    earliestAbsMinutes: absMinutes, // Store the time of its first actual encountered entry
                    firstSeenOriginalIndex: index  // Store the index from the master sorted list
                });
            }
            // If you wanted to update earliestAbsMinutes for a stop if it appeared later with an even earlier time
            // (which shouldn't happen if specificEntriesForRPD is perfectly sorted), you could add logic here.
            // For now, we assume the first encounter sets its primary ordering criteria.
        }
    });

    return Array.from(stopData.values()).sort((a, b) => {
        if (a.firstSeenOriginalIndex !== b.firstSeenOriginalIndex) {
            return a.firstSeenOriginalIndex - b.firstSeenOriginalIndex;
        }
        return a.earliestAbsMinutes - b.earliestAbsMinutes; // Fallback sort
    });
}

function analyzeAndSummarizeTimes(sortedTimes) { // sortedTimes is array of { absMinutes, displayTime, dayOffset }
    // Define constants used within this function
    const MAX_INITIAL_INDIVIDUAL_TIMES = 2; 
    const MIN_TIMES_FOR_PATTERN_BLOCK = 4;  
    const MIN_INTERVALS_FOR_PATTERN = MIN_TIMES_FOR_PATTERN_BLOCK - 1;

    const n = sortedTimes.length;
    if (n === 0) return "-";

    if (n < MIN_TIMES_FOR_PATTERN_BLOCK) { 
        return sortedTimes.map(t => formatTimeForDisplay(t)).join(", ");
    }

    let resultParts = [];
    let currentIndex = 0;

    while (currentIndex < n) {
        let bestRun = {
            startIdx: -1, numIntervals: 0, interval: 0, 
            startTimeObj: null, endTimeObj: null
        };

        // Determine the limit for starting a pattern search.
        // We look for a pattern starting at currentIndex, or up to MAX_INITIAL_INDIVIDUAL_TIMES beyond it.
        // Ensure we don't search beyond where a minimal pattern could form.
        let searchStartLimit = Math.min(currentIndex + MAX_INITIAL_INDIVIDUAL_TIMES, n - MIN_INTERVALS_FOR_PATTERN);
        // If currentIndex itself is already very close to the end, adjust searchStartLimit to at least allow one check from currentIndex
        if (searchStartLimit <= currentIndex && currentIndex <= n - MIN_TIMES_FOR_PATTERN_BLOCK ) { 
            searchStartLimit = currentIndex + 1; 
        }


        for (let i = currentIndex; i < searchStartLimit; i++) {
            // Ensure there are enough elements from 'i' to form at least MIN_INTERVALS_FOR_PATTERN
            if (i + MIN_INTERVALS_FOR_PATTERN >= n) break; 

            const t1Abs = sortedTimes[i].absMinutes;
            const t2Abs = sortedTimes[i + 1].absMinutes;

            if (t1Abs === null || t2Abs === null) continue;
            let currentRunInterval = t2Abs - t1Abs;

            // Ignore intervals that are non-positive or too large for typical summaries
            if (currentRunInterval <= 0 || currentRunInterval >= 90) continue; 

            let currentRunNumIntervals = 1; // We found one interval (between sortedTimes[i] and sortedTimes[i+1])
            // Now count how many more *consecutive* intervals match currentRunInterval
            for (let k = i + 1; k < n - 1; k++) { // k is the index of the start of the next interval
                const tkAbs = sortedTimes[k].absMinutes;
                const tk1Abs = sortedTimes[k + 1].absMinutes;
                if (tkAbs === null || tk1Abs === null) break; 

                if ((tk1Abs - tkAbs) === currentRunInterval) {
                    currentRunNumIntervals++;
                } else {
                    break; 
                }
            }

            if (currentRunNumIntervals >= MIN_INTERVALS_FOR_PATTERN) {
                // Found a valid run of intervals. Check if it's better than any previously found bestRun.
                if (currentRunNumIntervals > bestRun.numIntervals || 
                    (currentRunNumIntervals === bestRun.numIntervals && i < bestRun.startIdx) || 
                    bestRun.startIdx === -1) { // Prioritize longer runs, or earlier starting runs of same length
                    bestRun = {
                        startIdx: i, // Index in sortedTimes of the first time in this pattern
                        endIdx: i + currentRunNumIntervals, // Index in sortedTimes of the last time in this pattern
                        interval: currentRunInterval,
                        numIntervals: currentRunNumIntervals, // Number of matching intervals
                        startTimeObj: sortedTimes[i],
                        endTimeObj: sortedTimes[i + currentRunNumIntervals]
                    };
                }
            }
        } 

        if (bestRun.startIdx !== -1 && bestRun.startIdx >= currentIndex) { 
            // A frequency pattern was found starting at or after currentIndex.
            // 1. Add any individual times from currentIndex UP TO the start of the identified pattern block
            for (let j = currentIndex; j < bestRun.startIdx; j++) {
                resultParts.push(formatTimeForDisplay(sortedTimes[j]));
            }

            // 2. Add the actual start time of the frequency block
            const formattedRunStartTime = formatTimeForDisplay(bestRun.startTimeObj);
            resultParts.push(formattedRunStartTime);
            
            // 3. Construct the core summary phrase (without "then" and without "from [start time]")
            let summaryCorePhrase = "";
            const formattedRunEndTime = formatTimeForDisplay(bestRun.endTimeObj);

            if (bestRun.interval < 15) {
                summaryCorePhrase = `every ${bestRun.interval} mins until ${formattedRunEndTime}`;
            } else { // Interval is 15 minutes or more
                const minutesPastHourSet = new Set();
                for (let k = bestRun.startIdx; k <= bestRun.endIdx; k++) { // Iterate through times in the actual run
                    if (sortedTimes[k].displayTime.includes(':')) {
                        minutesPastHourSet.add(sortedTimes[k].displayTime.substring(3, 5));
                    }
                }
                if (minutesPastHourSet.size >= 1 && minutesPastHourSet.size <= 4 && (bestRun.interval % 5 === 0)) {
                    let numericallySortedMinutes = Array.from(minutesPastHourSet).sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
                    
                    const startMinuteOfBlock = bestRun.startTimeObj.displayTime.substring(3,5);
                    if (numericallySortedMinutes.length > 1 && numericallySortedMinutes[0] === startMinuteOfBlock) {
                        const firstMin = numericallySortedMinutes.shift(); 
                        numericallySortedMinutes.push(firstMin);      
                    }
                    const displayMinutes = numericallySortedMinutes.join(', ');                                        
                    summaryCorePhrase = `at these mins past each hour: ${displayMinutes} until ${formattedRunEndTime}`;
                } else { 
                    summaryCorePhrase = `approx. every ${bestRun.interval} mins until ${formattedRunEndTime}`;
                }
            }
            resultParts.push("then " + summaryCorePhrase); // Add "then" before the core summary
            currentIndex = bestRun.endIdx + 1; // Advance currentIndex past this summarized block
        } else { // No suitable frequency block found from currentIndex, or remaining times are too few.
            if (currentIndex < n) {
                 resultParts.push(formatTimeForDisplay(sortedTimes[currentIndex]));
                 currentIndex++;
            } else { 
                break; // End of times
            }
        }
    } 

    // Final joining logic
    if (resultParts.length === 0) return "-";
    let finalStr = resultParts[0] || "";
    for (let i = 1; i < resultParts.length; i++) {
        const prevPartStr = resultParts[i-1] || "";
        const currentPartStr = resultParts[i] || "";
        
        if (currentPartStr.startsWith("then") && !prevPartStr.startsWith("then")) {
            // Previous was a time, current is its summary: "TIME then SUMMARY"
            finalStr += " " + currentPartStr; 
        } else {
            // All other cases (summary; summary, summary; time, time; time if it's a new segment after summary)
            finalStr += "; " + currentPartStr;
        }
    }
    return finalStr || "-";
}

async function handleDownloadTimetable_ExtraPage() {
    if (!tteRouteNameSelect_el_extra || !tteRouteNameInput_el_extra || !tteStatusMessage_el_extra) {
        console.warn("Timetable Exporter: Essential UI elements missing.");
        if(tteStatusMessage_el_extra) { tteStatusMessage_el_extra.textContent = "Init error."; tteStatusMessage_el_extra.style.color = "#e74c3c"; }
        return;
    }

    const routeName = tteRouteNameInput_el_extra.value.trim() || tteRouteNameSelect_el_extra.value;
    if (!routeName) {
        tteStatusMessage_el_extra.textContent = "Please select a route.";
        tteStatusMessage_el_extra.style.color = "#f1c40f";
        return;
    }

    if (!currentUser_extra || typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined' || typeof window.jspdf.jsPDF.API.autoTable === 'undefined') {
        tteStatusMessage_el_extra.textContent = "Error: PDF library not ready or not logged in.";
        tteStatusMessage_el_extra.style.color = "#e74c3c";
        return;
    }

    tteStatusMessage_el_extra.textContent = `Processing PDF timetable for route: ${routeName}...`;
    tteStatusMessage_el_extra.style.color = "#3498db";

    try {
        const routeEntries = currentWorkingSchedule_extra.filter(e => e.lineName === routeName);
        if (routeEntries.length === 0) {
            tteStatusMessage_el_extra.textContent = `No schedule data found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'portrait', 
            unit: 'pt',
            format: 'a4'
        });
        let isFirstTableInPDF = true;

        const uniqueProfileDestPairs = new Map();
        routeEntries.forEach(e => {
            if (e.OperatingProfile && e.destinationName) {
                uniqueProfileDestPairs.set(`${e.OperatingProfile}|${e.destinationName}`, true);
            }
        });

        if (uniqueProfileDestPairs.size === 0) {
            tteStatusMessage_el_extra.textContent = `No operating profile/destination combinations found for route: ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
            return;
        }
        
        const sortedPairs = Array.from(uniqueProfileDestPairs.keys()).sort((a,b) => {
            const [profA, destA] = a.split('|');
            const [profB, destB] = b.split('|');
            const profCompare = profA.localeCompare(profB);
            if (profCompare !== 0) return profCompare;
            return destA.localeCompare(destB);
        });

        let tablesAddedToPDF = 0;

        for (const pair of sortedPairs) {
            const [opProfile, destName] = pair.split('|');
            
            const specificEntriesForRPD = routeEntries
                .filter(e => e.OperatingProfile === opProfile && e.destinationName === destName && e.scheduledTime)
                .sort((a,b) => { 
                    const absA = getAbsMinutes(a.scheduledTime, parseInt(a.DayOffset || 0));
                    const absB = getAbsMinutes(b.scheduledTime, parseInt(b.DayOffset || 0));
                    if (absA === null && absB === null) return 0;
                    if (absA === null) return 1;
                    if (absB === null) return -1;
                    return absA - absB;
                });

            if (specificEntriesForRPD.length === 0) continue;

            const canonicalStopSequence = determineCanonicalStopSequence(specificEntriesForRPD);
            if (canonicalStopSequence.length === 0) continue;

            const tableHead = [["Stop ID", "Stop Name", "Scheduled Times"]];
            const tableBody = [];

            canonicalStopSequence.forEach(stopInfo => {
                const allTimesAtThisStop = specificEntriesForRPD
                    .filter(e => e.stopID === stopInfo.stopID) 
                    .map(e => ({ 
                        absMinutes: getAbsMinutes(e.scheduledTime, parseInt(e.DayOffset || 0)),
                        displayTime: e.scheduledTime,
                        dayOffset: parseInt(e.DayOffset || 0)
                    }));
                // This map preserves the pre-sorted order of times for this stop from specificEntriesForRPD

                const serviceDetailString = analyzeAndSummarizeTimes(allTimesAtThisStop);
                
                tableBody.push([
                    stopInfo.stopID || "",
                    stopInfo.name || "",
                    serviceDetailString
                ]);
            });

            if (tableBody.length > 0) {
                if (!isFirstTableInPDF) {
                    doc.addPage('a4', 'portrait');
                }
                isFirstTableInPDF = false;

                doc.setFontSize(14);
                doc.text(`Route: ${routeName}`, 40, 40); 
                doc.setFontSize(11);
                doc.text(`Destination: ${destName}`, 40, 55); 
                doc.text(`Operating Profile: ${opProfile}`, 40, 70);

                doc.autoTable({
                    head: tableHead,
                    body: tableBody,
                    startY: 85,
                    theme: 'grid',
                    styles: { 
                        fontSize: 7, 
                        cellPadding: 2,
                        overflow: 'linebreak' 
                    }, 
                    headStyles: { 
                        fillColor: [44, 62, 80], 
                        textColor: 255, 
                        fontSize: 8,       
                        fontStyle: 'bold', 
                        halign: 'left' 
                    },
                    columnStyles: {
                        0: { cellWidth: 55, fontStyle: 'bold' }, 
                        1: { cellWidth: 130 }, 
                        2: { cellWidth: 'auto' } 
                    },
                    margin: { top: 25, right: 30, bottom: 30, left: 40 },
                });
                tablesAddedToPDF++;
            }
        }

        if (tablesAddedToPDF > 0) {
            doc.save(`${sanitizeFirebaseKey(routeName)}_Timetable_Summary.pdf`);
            tteStatusMessage_el_extra.textContent = `Summarized Timetable PDF for ${routeName} generated successfully!`;
            tteStatusMessage_el_extra.style.color = "#2ecc71";
        } else {
            tteStatusMessage_el_extra.textContent = `No valid data to generate summarized PDF for ${routeName}.`;
            tteStatusMessage_el_extra.style.color = "#f1c40f";
        }

    } catch (error) {
        console.error("Error generating summarized PDF timetable:", error);
        tteStatusMessage_el_extra.textContent = "Error generating summarized PDF: " + error.message;
        tteStatusMessage_el_extra.style.color = "#e74c3c";
    }
}

function rsg_getSelectedOpProfilesString_ExtraPage() {
    const selectedProfiles = [];
    document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox:checked').forEach(checkbox => {
        selectedProfiles.push(checkbox.value);
    });
    // Sorts alphabetically, e.g., ["Fr", "MF", "Sa"]
    selectedProfiles.sort((a,b) => a.localeCompare(b)); 
    
    // Joins with a comma AND a space
    return selectedProfiles.join(', '); // Changed from .join(',')
}

function rsg_updateDisabledProfileCheckboxes_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));
    const currentSelectedValues = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

    allCheckboxes.forEach(cb => {
        if (cb.checked) {
            cb.disabled = false;
            if (cb.parentElement) {
                cb.parentElement.style.opacity = 1;
                cb.parentElement.style.pointerEvents = 'auto';
                const labelForCb = cb.parentElement.querySelector('label');
                if (labelForCb) labelForCb.style.cursor = 'pointer';
            }
            return;
        }

        const potentialNextRawSelection = [...currentSelectedValues, cb.value];
        const finalEffectiveSelectionAfterAutoGroup = rsg_simulateAutoGroup(potentialNextRawSelection);
        const finalEffectiveSortedString = rsg_getCanonicalProfileString(finalEffectiveSelectionAfterAutoGroup);

        let canBeEnabled = false;

        if (VALID_PROFILE_COMBINATIONS_SET.has(finalEffectiveSortedString)) {
            canBeEnabled = true;
        }

        if (!canBeEnabled) {
            const prefixToTest = finalEffectiveSortedString + ",";
            for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                if (validCombo.startsWith(prefixToTest)) {
                    canBeEnabled = true;
                    break;
                }
            }
        }

        if (currentSelectedValues.length === 0) {
             const singleProfileItselfAfterPotentialGroup = rsg_simulateAutoGroup([cb.value]);
             const singleCanonical = rsg_getCanonicalProfileString(singleProfileItselfAfterPotentialGroup);
             if (VALID_PROFILE_COMBINATIONS_SET.has(singleCanonical)) {
                 canBeEnabled = true;
             } else {
                 const prefixToTestForSingle = singleCanonical + ",";
                 for (const validCombo of VALID_PROFILE_COMBINATIONS_SET) {
                     if (validCombo.startsWith(prefixToTestForSingle)) {
                         canBeEnabled = true;
                         break;
                     }
                 }
             }
        }

        cb.disabled = !canBeEnabled;
        if (cb.parentElement) {
            cb.parentElement.style.opacity = !canBeEnabled ? 0.5 : 1;
            cb.parentElement.style.pointerEvents = !canBeEnabled ? 'none' : 'auto';
            const labelForCb = cb.parentElement.querySelector('label');
            if (labelForCb) {
                labelForCb.style.cursor = !canBeEnabled ? 'not-allowed' : 'pointer';
            }
        }
    });
}

function rsg_simulateAutoGroup(selectedProfilesArray) {
    let simulatedSelections = [...selectedProfilesArray]; 

    for (const group of RSG_PROFILE_GROUPS_TO_MANAGE) {
        const allIndividualsPresent = group.individuals.every(ind => simulatedSelections.includes(ind));

        if (allIndividualsPresent) {
            simulatedSelections = simulatedSelections.filter(p => !group.individuals.includes(p)); 
            if (!simulatedSelections.includes(group.groupProfile)) {
                simulatedSelections.push(group.groupProfile); 
            }
        }
    }
    return simulatedSelections;
}

function rsg_handleProfileSelectionChange_ExtraPage(event) {
    let currentSelectionsArray = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox:checked')).map(cb => cb.value);
    let selectionChangedByAutoGroup = false;

    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));

    // Use RSG_PROFILE_GROUPS_TO_MANAGE which should be globally defined
    RSG_PROFILE_GROUPS_TO_MANAGE.forEach(group => {
        const groupCheckbox = allCheckboxes.find(cb => cb.value === group.groupProfile);
        if (!groupCheckbox) return; 

        // Re-fetch currentSelectionsArray in case a previous group changed it
        currentSelectionsArray = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);
        const allIndividualsInGroupSelected = group.individuals.every(day => currentSelectionsArray.includes(day));

        if (allIndividualsInGroupSelected) {
            if (!groupCheckbox.checked) {
                group.individuals.forEach(day => {
                    const cb = allCheckboxes.find(c => c.value === day);
                    if (cb && cb.checked) { cb.checked = false; }
                });
                groupCheckbox.checked = true;
                selectionChangedByAutoGroup = true;
            }
        } else if (groupCheckbox.checked) {
            // If group is checked, ensure its individuals are unchecked.
            let anIndividualWasAlsoCheckedAndUnchecked = false;
            group.individuals.forEach(day => {
                const cb = allCheckboxes.find(c => c.value === day);
                if (cb && cb.checked) {
                    cb.checked = false;
                    anIndividualWasAlsoCheckedAndUnchecked = true;
                }
            });
            if (anIndividualWasAlsoCheckedAndUnchecked) selectionChangedByAutoGroup = true;
        }
    });

    if (selectionChangedByAutoGroup) {
        currentSelectionsArray = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox:checked')).map(cb => cb.value);
    }

    currentSelectionsArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a);
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) {
            return orderA - orderB;
        }
        return a.localeCompare(b); 
    });

    const finalSelectedProfilesString = currentSelectionsArray.join(', '); 

    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }

    rsg_updateDisabledProfileCheckboxes_ExtraPage(); 

    if (event || selectionChangedByAutoGroup) {
        if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') {
             rsg_loadOrPullConfiguration_ExtraPage();
        }
    }
}

function rsg_setCheckedProfiles_ExtraPage(profileString) {
    // Determine which profiles to select based on the input string
    const profilesToSelect = profileString ? profileString.split(',').map(p => p.trim()).filter(Boolean) : [];

    // Get all profile checkboxes
    const allProfileCheckboxes = document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox');

    // Set the checked state for each checkbox
    allProfileCheckboxes.forEach(checkbox => {
        checkbox.checked = profilesToSelect.includes(checkbox.value);
    });

    // --- MODIFICATION START ---
    // After programmatically setting checkbox states,
    // directly update the "Currently Selected & Active" display string.

    // Use the 'profilesToSelect' array as the source of truth for what should be displayed,
    // as this is what the checkboxes were just set to.
    // Create a mutable copy if further manipulation of this array specific to display is needed,
    // otherwise, direct use is fine for sorting and joining.
    const currentDisplayProfilesArray = [...profilesToSelect];

    // Sort them for consistent display order using your existing sorting logic
    currentDisplayProfilesArray.sort((a, b) => {
        const orderA = getDaySortOrder_ExtraPage(a); // Ensure getDaySortOrder_ExtraPage is robust
        const orderB = getDaySortOrder_ExtraPage(b);
        if (orderA !== orderB) {
            return orderA - orderB;
        }
        return a.localeCompare(b); // Default alphabetical sort if order is the same
    });

    // Join the sorted profiles into a string for display
    const finalSelectedProfilesString = currentDisplayProfilesArray.join(', ');

    // Get the display element
    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');

    // Update the text content of the display element
    if (displayElement) {
        displayElement.textContent = finalSelectedProfilesString || '(None selected)';
    }
    // --- MODIFICATION END ---

    // This function correctly updates which checkboxes are enabled/disabled
    // based on your incompatibility rules and the newly set checkbox states.
    // This should always be called after checkbox states are modified.
    if (typeof rsg_updateDisabledProfileCheckboxes_ExtraPage === 'function') {
        rsg_updateDisabledProfileCheckboxes_ExtraPage();
    }
}

function rsg_clearProfileSelections_ExtraPage() {
    const allCheckboxes = Array.from(document.querySelectorAll('#rsg-selectable-profiles-container-extra .rsg-profile-checkbox'));
    let selectionActuallyChanged = false;

    allCheckboxes.forEach(cb => {
        if (cb.checked) {
            cb.checked = false;
            selectionActuallyChanged = true;
        }
    });

    // Update the display string to show none selected
    const displayElement = document.getElementById('rsg-selected-profiles-display-extra');
    if (displayElement) {
        displayElement.textContent = '(None selected)';
    }

    // Update the enabled/disabled state of all checkboxes
    // After clearing, most (if not all) should become enabled depending on VALID_PROFILE_COMBINATIONS_SET
    if (typeof rsg_updateDisabledProfileCheckboxes_ExtraPage === 'function') {
        rsg_updateDisabledProfileCheckboxes_ExtraPage();
    }

    // Now that selections are cleared (empty string),
    // trigger the configuration load/pull logic.
    // This will typically try to load defaults or an empty state.
    if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') {
        rsg_loadOrPullConfiguration_ExtraPage();
    }
}

        function rsg_createConfigKey_ExtraPage(routeName, opProfile, destName) { if (!routeName || !opProfile || !destName) return null; const normRoute = sanitizeFirebaseKey(String(routeName).toUpperCase()); const normProfile = sanitizeFirebaseKey(String(opProfile).toUpperCase()); const normDest = sanitizeFirebaseKey(String(destName).toUpperCase()); return `${normRoute}|${normProfile}|${normDest}`; } 

        async function rsg_loadOrPullConfiguration_ExtraPage() {
    // Initial checks for early exit or missing elements (as previously provided)
    const routeNameFromFormForEarlyCheck = rsgRouteNameInput_el_extra ? rsgRouteNameInput_el_extra.value.trim() : "";
    const opProfileFromFormForEarlyCheck = rsg_getSelectedOpProfilesString_ExtraPage ? rsg_getSelectedOpProfilesString_ExtraPage() : "";
    const destNameFromFormForEarlyCheck = rsgDestinationNameInput_el_extra ? rsgDestinationNameInput_el_extra.value.trim() : "";

    if (
        rsg_currentlyEditingConfigKey_extra &&
        !rsg_isDirty &&
        routeNameFromFormForEarlyCheck.toUpperCase() === (rsg_lastLoadedRouteName_extra || "").toUpperCase() &&
        destNameFromFormForEarlyCheck === (rsg_lastLoadedDestName_extra || "") &&
        opProfileFromFormForEarlyCheck === (rsg_lastLoadedOpProfile_extra || "")
    ) {
        console.log("RSG Load/Pull (EARLY EXIT): Trusting 'currentlyEditing' context.");
        if (typeof rsg_renderStopSequence_ExtraPage === 'function') rsg_renderStopSequence_ExtraPage();
        // If a config was just loaded, rsg_resetPreviewState was already called.
        // If it's an immediate follow-up, the button state should persist from the last preview generation or reset.
        return;
    }

    if (!rsgRouteNameInput_el_extra || !rsgDestinationNameInput_el_extra || !rsgFirstStopTimesInput_el_extra || !rsgStatusMessage_el_extra || !window.firebaseOMSI) {
        console.warn("RSG Load/Pull: Aborted - Required element or Firebase missing.");
        return;
    }

    const routeNameFromInput = rsgRouteNameInput_el_extra.value.trim();
    const opProfileFromInput = rsg_getSelectedOpProfilesString_ExtraPage();
    const destNameFromInput = rsgDestinationNameInput_el_extra.value.trim();

    let identityHasChanged =
        (routeNameFromInput.toUpperCase() !== (rsg_lastLoadedRouteName_extra || "").toUpperCase()) ||
        (destNameFromInput !== (rsg_lastLoadedDestName_extra || "")) ||
        (opProfileFromInput !== (rsg_lastLoadedOpProfile_extra || ""));

    if (identityHasChanged) {
        if (rsg_currentlyEditingConfigKey_extra) {
            rsg_currentlyEditingConfigKey_extra = null;
            rsg_currentlyEditingConfigDisplayName_extra = null;
            rsg_isDirty = true;
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Route/Dest/Profile changed from loaded. Current sequence (with edits) is now for a new, unsaved configuration.";
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }
            rsg_lastLoadedRouteName_extra = routeNameFromInput;
            rsg_lastLoadedDestName_extra = destNameFromInput;
            rsg_lastLoadedOpProfile_extra = opProfileFromInput;
            rsg_renderStopSequence_ExtraPage();
            rsg_resetPreviewState("Config identity changed. Current edits kept. Regenerate preview or save.", "info"); // This will grey out the button
            return;
        } else {
            rsg_selectedStops_extra = [];
            if (rsgFirstStopTimesInput_el_extra) rsgFirstStopTimesInput_el_extra.value = '';
            rsg_isDirty = false;
        }
    } else {
        if (rsg_isDirty) {
            console.log("RSG Load/Pull: Identity matches, form dirty. SKIPPING reload to preserve edits.");
            rsg_lastLoadedRouteName_extra = routeNameFromInput;
            rsg_lastLoadedDestName_extra = destNameFromInput;
            rsg_lastLoadedOpProfile_extra = opProfileFromInput;
            rsg_renderStopSequence_ExtraPage();
            // If form is dirty, preview is invalid, button should be reset if it was active.
            // rsg_resetPreviewState is typically called when parameters that affect the preview change.
            // If the user dirties the form after generating a preview, the "Generate Preview" button should be used again.
            // The button state would have been set by the last call to rsg_handleGenerateSchedulePreview_ExtraPage or rsg_resetPreviewState.
            return;
        }
    }

    // Call rsg_resetPreviewState to clear old preview data and set button to initial inactive state (visible, grey, disabled)
    rsg_resetPreviewState("Loading configuration...", "info");
    rsg_renderStopSequence_ExtraPage();

    if (!routeNameFromInput || !destNameFromInput) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route Name and Destination Name are required to load or pull configuration.";
            rsgStatusMessage_el_extra.style.color = ""; // Default or neutral color
        }
        if (!opProfileFromInput) rsg_setCheckedProfiles_ExtraPage(""); // Clear profile checkboxes if appropriate
        rsg_lastLoadedRouteName_extra = null;
        rsg_lastLoadedDestName_extra = null;
        rsg_lastLoadedOpProfile_extra = null;
        rsg_currentlyEditingConfigKey_extra = null;
        rsg_currentlyEditingConfigDisplayName_extra = null;
        rsg_isDirty = false;
        return;
    }

    let profileToAttemptLoadWith = opProfileFromInput;
    let wasProfileAssumed = false;
    // ... (rest of the logic for profileToAttemptLoadWith, same as previously provided)
    if (!profileToAttemptLoadWith) {
        wasProfileAssumed = true;
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Op Profile blank. Trying default profiles for ${routeNameFromInput}/${destNameFromInput}...`;
            rsgStatusMessage_el_extra.style.color = "#3498db";
        }
        const preferredDefaultProfiles = RSG_OPERATING_PROFILES_LIST; 
        let foundDefault = false;
        for (const prefProfile of preferredDefaultProfiles) { 
            const tempConfigKey = rsg_createConfigKey_ExtraPage(routeNameFromInput, prefProfile, destNameFromInput);
            if (tempConfigKey && rsg_loadedConfigs_extra[tempConfigKey]) { 
                profileToAttemptLoadWith = prefProfile; foundDefault = true; break;
            }
        }
        if (!foundDefault) { 
            for (const prefProfile of preferredDefaultProfiles) {
                 const hasLiveEntries = currentWorkingSchedule_extra.some(entry =>
                    entry.lineName && entry.lineName.toUpperCase() === routeNameFromInput.toUpperCase() &&
                    entry.destinationName === destNameFromInput && entry.OperatingProfile === prefProfile);
                if (hasLiveEntries) { profileToAttemptLoadWith = prefProfile; foundDefault = true; break; }
            }
        }
        if (!foundDefault) { 
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Op Profile blank. No default config or live data found for ${routeNameFromInput}/${destNameFromInput}. Sequence cleared.`;
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }
            rsg_selectedStops_extra = []; 
            if (rsgFirstStopTimesInput_el_extra) rsgFirstStopTimesInput_el_extra.value = '';
            rsg_renderStopSequence_ExtraPage();
            rsg_setCheckedProfiles_ExtraPage("");
            rsg_lastLoadedRouteName_extra = routeNameFromInput; 
            rsg_lastLoadedDestName_extra = destNameFromInput;
            rsg_lastLoadedOpProfile_extra = ""; 
            rsg_currentlyEditingConfigKey_extra = null;
            rsg_currentlyEditingConfigDisplayName_extra = null;
            rsg_isDirty = false; 
            return;
        }
        if (rsgStatusMessage_el_extra && foundDefault) { 
            rsgStatusMessage_el_extra.textContent = `Op Profile was blank. Using assumed default: ${profileToAttemptLoadWith} for load/pull.`;
        }
    }
    
    if (!profileToAttemptLoadWith) { 
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "No valid Operating Profile to load. Please select or clear.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        rsg_isDirty = false; 
        return;
    }


    const finalConfigKey = rsg_createConfigKey_ExtraPage(routeNameFromInput, profileToAttemptLoadWith, destNameFromInput);
    // ... (rest of the Firebase fetching logic, exactly as previously provided) ...
    // This includes the try/catch block and updates to rsg_selectedStops_extra, etc.
    // The key is that NO `rsgAddToWorkingScheduleButton_el_extra.style.display = 'none';`
    // should exist in this function.
    if (!finalConfigKey) { 
        if (rsgStatusMessage_el_extra) { 
            rsgStatusMessage_el_extra.textContent = "Error: Could not form a valid key with the selected profile(s).";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        rsg_isDirty = false;
        return;
    }

    if (rsgStatusMessage_el_extra && !wasProfileAssumed) { 
        rsgStatusMessage_el_extra.textContent = `Checking for configuration: ${routeNameFromInput} / ${profileToAttemptLoadWith} / ${destNameFromInput}...`;
        rsgStatusMessage_el_extra.style.color = "#3498db";
    }

    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
    let configDataUsed = null;

    try {
        if (rsg_loadedConfigs_extra[finalConfigKey]) {
            configDataUsed = rsg_loadedConfigs_extra[finalConfigKey];
        } else {
            const snapshot = await dbGet(dbChild(dbRef(database), `${FB_PATH_RSG_CONFIGS}/${finalConfigKey}`));
            if (snapshot.exists()) {
                configDataUsed = snapshot.val();
                if (configDataUsed) rsg_loadedConfigs_extra[finalConfigKey] = configDataUsed; 
            }
        }

        if (configDataUsed) {
            rsgRouteNameInput_el_extra.value = configDataUsed.routeName || routeNameFromInput;
            rsgDestinationNameInput_el_extra.value = configDataUsed.destinationName || destNameFromInput;
            rsg_setCheckedProfiles_ExtraPage(configDataUsed.operatingProfile || profileToAttemptLoadWith); 
            rsg_populateRouteSelect_ExtraPage();
            rsg_populateDestinationSelect_ExtraPage();
            rsg_selectedStops_extra = JSON.parse(JSON.stringify(configDataUsed.stopSequence || []));
            if(rsgFirstStopTimesInput_el_extra) rsgFirstStopTimesInput_el_extra.value = configDataUsed.firstStopTimes || '';
            rsg_lastLoadedRouteName_extra = rsgRouteNameInput_el_extra.value.trim();
            rsg_lastLoadedDestName_extra = rsgDestinationNameInput_el_extra.value.trim();
            rsg_lastLoadedOpProfile_extra = configDataUsed.operatingProfile || profileToAttemptLoadWith;
            rsg_currentlyEditingConfigKey_extra = finalConfigKey;
            rsg_currentlyEditingConfigDisplayName_extra = configDataUsed.userDisplayName || finalConfigKey;
            rsg_isDirty = false; 
            if (rsgStatusMessage_el_extra) { 
                rsgStatusMessage_el_extra.textContent = `Loaded config: "${rsg_currentlyEditingConfigDisplayName_extra}".`;
                rsgStatusMessage_el_extra.style.color = "#2ecc71";
            }
        } else { 
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `No saved config for '${profileToAttemptLoadWith}'. Pulling live data for ${routeNameFromInput}/${destNameFromInput}...`;
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }
            const routeNameUpperForPull = routeNameFromInput.toUpperCase();
            const relevantEntries = currentWorkingSchedule_extra.filter(entry =>
                entry.lineName && entry.lineName.toUpperCase() === routeNameUpperForPull &&
                entry.OperatingProfile === profileToAttemptLoadWith &&
                entry.destinationName === destNameFromInput
            );

            if (relevantEntries.length === 0) {
                if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = `No live data found for ${routeNameFromInput} (${profileToAttemptLoadWith}) / ${destNameFromInput}. Sequence cleared.`;
                }
                rsg_selectedStops_extra = []; 
                if(rsgFirstStopTimesInput_el_extra) rsgFirstStopTimesInput_el_extra.value = '';
                rsg_setCheckedProfiles_ExtraPage(wasProfileAssumed ? "" : profileToAttemptLoadWith);
                rsg_lastLoadedRouteName_extra = routeNameFromInput;
                rsg_lastLoadedDestName_extra = destNameFromInput;
                rsg_lastLoadedOpProfile_extra = profileToAttemptLoadWith; 
                rsg_currentlyEditingConfigKey_extra = null; 
                rsg_currentlyEditingConfigDisplayName_extra = null;
                rsg_isDirty = false; 
            } else { 
                relevantEntries.sort((a, b) => { 
                    const dayOffsetA = parseInt(a.DayOffset || 0); const dayOffsetB = parseInt(b.DayOffset || 0);
                    if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
                    const timeA = (a.scheduledTime || "99:99").replace(':', ''); const timeB = (b.scheduledTime || "99:99").replace(':', '');
                    return timeA.localeCompare(timeB);
                });
                const firstTripSequence = [];
                if (relevantEntries.length > 0) {
                    const firstStopIDOfJourney = relevantEntries[0].stopID;
                    let previousStopTimeAbs = -1;
                    const MIN_STOPS_HEURISTIC_FOR_BREAK = 3; 
                    for (let i = 0; i < relevantEntries.length; i++) {
                        const entry = relevantEntries[i];
                        if (!entry.stopID || !entry.scheduledTime) continue;
                        const currentTimeAbs = (parseInt(entry.DayOffset || 0) * 1440) + parseInt(entry.scheduledTime.split(':')[0]) * 60 + parseInt(entry.scheduledTime.split(':')[1]);
                        if (i > 0) {
                            if (currentTimeAbs < previousStopTimeAbs) break;
                            if (entry.stopID === firstStopIDOfJourney && firstTripSequence.length >= MIN_STOPS_HEURISTIC_FOR_BREAK) break;
                        }
                        firstTripSequence.push({ stopID: entry.stopID, stopName: entry.stopName, direction: entry.direction, timeAdjustment: (i > 0 ? 2 : 0) });
                        previousStopTimeAbs = currentTimeAbs;
                    }
                }
                rsg_selectedStops_extra = firstTripSequence;
                if (rsg_selectedStops_extra.length > 0 && rsgFirstStopTimesInput_el_extra) {
                     const firstStopIdInPulledSequence = rsg_selectedStops_extra[0].stopID;
                     const departuresForFirstStop = [...new Set(
                         relevantEntries.filter(e => e.stopID === firstStopIdInPulledSequence).map(e => e.scheduledTime)
                     )].sort();
                     rsgFirstStopTimesInput_el_extra.value = departuresForFirstStop.join(', ');
                } else if (rsgFirstStopTimesInput_el_extra) {
                    rsgFirstStopTimesInput_el_extra.value = '';
                }
                rsg_setCheckedProfiles_ExtraPage(profileToAttemptLoadWith); 
                rsg_lastLoadedRouteName_extra = routeNameFromInput;
                rsg_lastLoadedDestName_extra = destNameFromInput;
                rsg_lastLoadedOpProfile_extra = profileToAttemptLoadWith;
                rsg_currentlyEditingConfigKey_extra = null; 
                rsg_currentlyEditingConfigDisplayName_extra = null;
                rsg_isDirty = false; 
                if (rsgStatusMessage_el_extra) { 
                    rsgStatusMessage_el_extra.textContent = `Pulled live data for: ${routeNameFromInput} (${profileToAttemptLoadWith}) / ${destNameFromInput}. Review adjustments.`;
                    rsgStatusMessage_el_extra.style.color = "#2ecc71";
                }
            }
        }
        rsg_renderStopSequence_ExtraPage(); 
    } catch (error) {
        console.error("Error in rsg_loadOrPullConfiguration_ExtraPage (final catch):", error);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Error loading/pulling configuration: " + error.message;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        rsg_selectedStops_extra = []; 
        if(rsgFirstStopTimesInput_el_extra) rsgFirstStopTimesInput_el_extra.value = '';
        rsg_setCheckedProfiles_ExtraPage(""); 
        rsg_renderStopSequence_ExtraPage();
        rsg_lastLoadedRouteName_extra = routeNameFromInput; 
        rsg_lastLoadedDestName_extra = destNameFromInput;
        rsg_lastLoadedOpProfile_extra = opProfileFromInput; 
        rsg_currentlyEditingConfigKey_extra = null;
        rsg_currentlyEditingConfigDisplayName_extra = null;
        rsg_isDirty = false; 
    }
}

        function rsg_handleSaveConfiguration_ExtraPage() {
    if (!currentUser_extra) {
        alert("Please log in to save configurations.");
        return;
    }
    // Basic check: ensure essential fields for naming are present before opening modal
    const routeName = rsgRouteNameInput_el_extra.value.trim();
    const destName = rsgDestinationNameInput_el_extra.value.trim();
    const opProfiles = rsg_getSelectedOpProfilesString_ExtraPage();

    if (!routeName || !destName || !opProfiles) {
         if(rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route, Destination, and Operating Profile(s) must be selected to save.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    if (rsg_selectedStops_extra.length === 0 || !rsgFirstStopTimesInput_el_extra.value.trim()) {
         if(rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Stop Sequence and First Stop Times are required to save.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }
    rsg_showSaveConfigModal_ExtraPage();
}

        function rsg_populateRouteSelect_ExtraPage() { 
            if (!rsgRouteNameSelect_el_extra || !rsgRouteNameInput_el_extra) return; const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))].filter(Boolean).sort(compareLineNames_ExtraPage); const currentInputValue = rsgRouteNameInput_el_extra.value.trim(); rsgRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Existing Route --</option>'; uniqueRoutes.forEach(route => { const opt = document.createElement('option'); opt.value = route; opt.textContent = route; rsgRouteNameSelect_el_extra.appendChild(opt); }); const matchedRoute = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase()); if (matchedRoute) rsgRouteNameSelect_el_extra.value = matchedRoute; else if (currentInputValue) rsgRouteNameSelect_el_extra.value = ""; rsg_populateDestinationSelect_ExtraPage();
        }
        function rsg_handleRouteNameInputChange_ExtraPage() {
    if (!rsgRouteNameInput_el_extra || !rsgRouteNameSelect_el_extra) return;

    const typedRouteValue = rsgRouteNameInput_el_extra.value.trim();
    const typedRouteUpper = typedRouteValue.toUpperCase();

    // If the new route name differs from the last loaded one (and a config was loaded),
    // it's effectively a new/different configuration context.
    if (rsg_lastLoadedRouteName_extra && typedRouteUpper !== rsg_lastLoadedRouteName_extra.toUpperCase()) {
        console.log("RSG Context Cleared: Route name input changed from last loaded context.");
        rsg_currentlyEditingConfigKey_extra = null;
        rsg_currentlyEditingConfigDisplayName_extra = null;
        // rsg_lastLoadedOpProfile_extra might also need to be considered if it should be cleared here,
        // or if rsg_loadOrPullConfiguration will handle it. For now, focus on edit context.
    }

    const matchedOption = Array.from(rsgRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper);

    if (matchedOption) {
        rsgRouteNameSelect_el_extra.value = matchedOption.value;
        // Ensure the input reflects the exact casing from the select if a match is found
        if (rsgRouteNameInput_el_extra.value !== matchedOption.value) {
            rsgRouteNameInput_el_extra.value = matchedOption.value;
        }
    } else {
        rsgRouteNameSelect_el_extra.value = ""; // No match in select, deselect
    }

    rsg_populateDestinationSelect_ExtraPage(); // This will also trigger rsg_loadOrPullConfiguration via its chain
    // If rsg_loadOrPullConfiguration is not called by the chain above, you might need to call it here.
    // However, your existing structure seems to chain it through rsg_populateDestinationSelect -> rsg_loadOrPullConfiguration.
}
        function rsg_handleRouteNameSelectChange_ExtraPage() { 
            if (!rsgRouteNameSelect_el_extra || !rsgRouteNameInput_el_extra) return; rsgRouteNameInput_el_extra.value = rsgRouteNameSelect_el_extra.value; rsg_populateDestinationSelect_ExtraPage();
        }
        function rsg_populateDestinationSelect_ExtraPage() { 
            if (!rsgDestinationNameSelect_el_extra || !rsgDestinationNameInput_el_extra || !rsgRouteNameInput_el_extra) return; const selectedRoute = rsgRouteNameInput_el_extra.value.trim().toUpperCase(); const currentDestInputValue = rsgDestinationNameInput_el_extra.value.trim(); rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- Select Existing Destination --</option>'; if (!selectedRoute) { rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- Select Route First --</option>'; return; } const uniqueDestinations = [...new Set( currentWorkingSchedule_extra.filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName).map(e => e.destinationName) )].sort(); uniqueDestinations.forEach(dest => { const opt = document.createElement('option'); opt.value = dest; opt.textContent = dest; rsgDestinationNameSelect_el_extra.appendChild(opt); }); const matchedDest = uniqueDestinations.find(d => d === currentDestInputValue); if (matchedDest) rsgDestinationNameSelect_el_extra.value = matchedDest; else if (uniqueDestinations.length === 0 && selectedRoute) rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- No Destinations for Route --</option>'; else rsgDestinationNameSelect_el_extra.value = "";
        }
        function rsg_handleDestinationNameInputChange_ExtraPage() { 
            if (!rsgDestinationNameInput_el_extra || !rsgDestinationNameSelect_el_extra) return; const typedDest = rsgDestinationNameInput_el_extra.value.trim(); const matchedOption = Array.from(rsgDestinationNameSelect_el_extra.options).find(opt => opt.value === typedDest); if (matchedOption) { rsgDestinationNameSelect_el_extra.value = matchedOption.value; if (rsgDestinationNameInput_el_extra.value !== matchedOption.value) rsgDestinationNameInput_el_extra.value = matchedOption.value; } else rsgDestinationNameSelect_el_extra.value = "";
        }
        function rsg_handleDestinationNameSelectChange_ExtraPage() { 
            if (!rsgDestinationNameSelect_el_extra || !rsgDestinationNameInput_el_extra) return; rsgDestinationNameInput_el_extra.value = rsgDestinationNameSelect_el_extra.value;
        }

        // ++ RSG Helper Function to create 'Copy Time Adjustment' buttons (sorted) ++
        function rsg_createCopyAdjustmentButtons_ExtraPage(currentStopInSequence, stopIndexInCurrentSequence, buttonsContainer) {
            if (!currentStopInSequence || !buttonsContainer || !rsg_loadedConfigs_extra || typeof rsg_loadedConfigs_extra !== 'object') {
                return;
            }

            buttonsContainer.innerHTML = ''; // Clear any existing buttons or placeholder text

            const currentRsgRouteName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
            const targetStopID = currentStopInSequence.stopID;
            
            const potentialButtonsData = [];
            const addedButtonSignatures = new Set(); // To track added "RouteName|Adjustment" for uniqueness

            for (const configKey in rsg_loadedConfigs_extra) {
                const sourceConfig = rsg_loadedConfigs_extra[configKey];

                if (!sourceConfig.routeName || sourceConfig.routeName.toUpperCase() === currentRsgRouteName || !Array.isArray(sourceConfig.stopSequence)) {
                    continue;
                }

                let sourceStopData = null;
                let sourceStopIndexInItsConfig = -1;

                for (let i = 0; i < sourceConfig.stopSequence.length; i++) {
                    if (sourceConfig.stopSequence[i].stopID === targetStopID) {
                        sourceStopData = sourceConfig.stopSequence[i];
                        sourceStopIndexInItsConfig = i;
                        break; 
                    }
                }

                if (sourceStopData && sourceStopIndexInItsConfig > 0) { // Must exist and not be the first stop in its own sequence
                    const timeAdjustmentToCopy = sourceConfig.stopSequence[sourceStopIndexInItsConfig].timeAdjustment;

                    if (typeof timeAdjustmentToCopy === 'number') {
                        const buttonSignature = `${sourceConfig.routeName}|${timeAdjustmentToCopy}`;

                        if (!addedButtonSignatures.has(buttonSignature)) {
                            potentialButtonsData.push({
                                routeName: sourceConfig.routeName,
                                timeAdjustment: timeAdjustmentToCopy,
                                operatingProfile: sourceConfig.operatingProfile || 'N/A',
                                destinationName: sourceConfig.destinationName || 'N/A'
                            });
                            addedButtonSignatures.add(buttonSignature);
                        }
                    }
                }
            }

            if (potentialButtonsData.length > 0) {
                // Sort the collected button data by routeName
                potentialButtonsData.sort((a, b) => compareLineNames_ExtraPage(a.routeName, b.routeName));

                // Now create and append buttons in sorted order
                potentialButtonsData.forEach(data => {
                    const button = document.createElement('button');
                    button.classList.add('button', 'small-action', 'neutral', 'copy-adj-button');
                    button.textContent = `Copy From ${data.routeName} (+${data.timeAdjustment} min)`;
                    button.title = `Copy ${data.timeAdjustment} min from ${data.routeName} (Profile: ${data.operatingProfile}, Dest: ${data.destinationName})`;

                    button.addEventListener('click', () => {
                        rsg_selectedStops_extra[stopIndexInCurrentSequence].timeAdjustment = data.timeAdjustment;
                        const listItem = rsgStopSequenceList_el_extra.querySelector(`li[data-index="${stopIndexInCurrentSequence}"]`);
                        if (listItem) {
                            const timeAdjInput = listItem.querySelector('.rsg-time-adjustment-input');
                            if (timeAdjInput) {
                                timeAdjInput.value = data.timeAdjustment;
                            }
                        }
                        rsg_resetPreviewState(`Time adjustment (${data.timeAdjustment} min) copied from Route ${data.routeName}. Regenerate preview.`, "info");
                    });
                    buttonsContainer.appendChild(button);
                });
            } else {
                 buttonsContainer.innerHTML = `<span style="font-size:0.75em; opacity:0.7; display:block; margin-top:0.3rem; width:100%;">No other routes serve this stop to copy adjustment from.</span>`;
            }
        }

        // In omsi_tools_extra.html

function rsg_renderStopSequence_ExtraPage() {
    if (!rsgStopSequenceList_el_extra || !rsgStopSequencePlaceholder_el_extra || !rsgFirstStopTimesContainer_el_extra) {
        console.error("RSG Render: Critical elements missing.");
        return;
    }
    
    console.log(`RSG Render: Starting. Stop count: ${rsg_selectedStops_extra.length}. Dirty: ${rsg_isDirty}.`);

    rsgStopSequenceList_el_extra.innerHTML = ''; 

    if (rsg_selectedStops_extra.length === 0) {
        rsgStopSequencePlaceholder_el_extra.style.display = 'block';
        rsgFirstStopTimesContainer_el_extra.style.display = 'none';
        console.log("RSG Render: No stops to render, showing placeholder.");
    } else {
        rsgStopSequencePlaceholder_el_extra.style.display = 'none';
        rsgFirstStopTimesContainer_el_extra.style.display = 'block';

        rsg_selectedStops_extra.forEach((stop, loopIndex) => {
            console.log(`RSG Render: LOOP START for index ${loopIndex}, stopID: ${stop.stopID}`);

            const li = document.createElement('li');
            li.dataset.index = loopIndex;
            li.draggable = true;

            const mainContentDiv = document.createElement('div');
            mainContentDiv.classList.add('rsg-li-main-content');

            const stopInfoDiv = document.createElement('div');
            stopInfoDiv.classList.add('rsg-stop-info');
            stopInfoDiv.innerHTML = `<span class="rsg-stop-name">${stop.stopName}</span> <span class="rsg-stop-id">(${stop.stopID})</span>`;
            if (stop.direction) stopInfoDiv.innerHTML += `<br><small style="opacity:0.7;">Towards: ${stop.direction}</small>`;

            const actionsDiv = document.createElement('div');
            actionsDiv.classList.add('rsg-stop-actions');

            let timeAdjInput = null;

            // --- Define renderOrUpdateWarningIcon at the start of the loop iteration ---
            // It will be in scope for all subsequent conditional blocks within this iteration.
            const renderOrUpdateWarningIcon = (currentIndex, currentStopData, inputElement, parentActionsDiv) => {
                if (!inputElement || !parentActionsDiv) {
                    // This guard is important if this function were to be called when inputElement is null (e.g. for first stop)
                    // However, our calls to it are always within loopIndex > 0 context.
                    console.warn("renderOrUpdateWarningIcon called with invalid inputElement or parentActionsDiv for index:", currentIndex);
                    return;
                }
                const existingWarning = parentActionsDiv.querySelector('.rsg-time-adj-warning');
                if (existingWarning) {
                    existingWarning.remove();
                }

                const otherAdjustmentsInfo = rsg_getOtherRouteAdjustmentsForStop(currentStopData.stopID, rsg_currentlyEditingConfigKey_extra);
                // Use rsg_selectedStops_extra to get the most up-to-date adjustment value for comparison
                const currentStopActualAdjustment = (typeof rsg_selectedStops_extra[currentIndex]?.timeAdjustment === 'number' && !isNaN(rsg_selectedStops_extra[currentIndex].timeAdjustment))
                    ? rsg_selectedStops_extra[currentIndex].timeAdjustment
                    : 0;

                if (otherAdjustmentsInfo.mostCommonValue !== null &&
                    currentStopActualAdjustment !== otherAdjustmentsInfo.mostCommonValue) {

                    const warningIcon = document.createElement('span');
                    warningIcon.className = 'rsg-time-adj-warning';
                    warningIcon.textContent = ' âš ï¸';
                    warningIcon.style.cursor = 'pointer';
                    warningIcon.style.color = '#f39c12';
                    warningIcon.style.fontSize = '1.1em';
                    warningIcon.style.marginLeft = '5px';
                    warningIcon.title = otherAdjustmentsInfo.suggestionTitle || `Commonly +${otherAdjustmentsInfo.mostCommonValue} min. Click to apply.`;

                    warningIcon.addEventListener('click', () => {
                        const targetAdjustment = otherAdjustmentsInfo.mostCommonValue;
                        if (targetAdjustment !== null) {
                            rsg_selectedStops_extra[currentIndex].timeAdjustment = targetAdjustment;
                            if (inputElement) inputElement.value = targetAdjustment;
                            warningIcon.remove(); 
                            rsg_isDirty = true;
                            if (rsgStatusMessage_el_extra) {
                                rsgStatusMessage_el_extra.textContent = `Time adjustment for '${currentStopData.stopName}' changed to +${targetAdjustment} min. Regenerate preview.`;
                                rsgStatusMessage_el_extra.style.color = '#2ecc71';
                            }
                            rsg_resetPreviewState("Time adjustment updated. Regenerate preview.", "info");
                        }
                    });
                    const removeBtnInActions = parentActionsDiv.querySelector('button.secondary');
                    if (removeBtnInActions) {
                        parentActionsDiv.insertBefore(warningIcon, removeBtnInActions);
                    } else {
                        parentActionsDiv.appendChild(warningIcon);
                    }
                }
            };
            // --- End of renderOrUpdateWarningIcon definition for this iteration ---

            if (loopIndex > 0) {
                timeAdjInput = document.createElement('input');
                timeAdjInput.type = 'number';
                timeAdjInput.classList.add('schedule-generator-input', 'rsg-time-adjustment-input');
                timeAdjInput.min = '0';
                timeAdjInput.title = 'Minutes from previous stop';
                timeAdjInput.value = (typeof stop.timeAdjustment === 'number' && !isNaN(stop.timeAdjustment)) ? stop.timeAdjustment : 0;
                
                actionsDiv.appendChild(timeAdjInput); // Add input first

                // Initial call to render/update its warning icon
                renderOrUpdateWarningIcon(loopIndex, stop, timeAdjInput, actionsDiv);

                // Event listener for dynamic updates on this input
                timeAdjInput.addEventListener('input', () => { 
                    rsg_isDirty = true;
                    const currentLiElement = timeAdjInput.closest('li');
                    const changedIndex = parseInt(currentLiElement.dataset.index);
                    const stopDataForListener = rsg_selectedStops_extra[changedIndex];
                    
                    let newValueFromInput = parseInt(timeAdjInput.value, 10);

                    if (rsg_selectedStops_extra[changedIndex]) {
                        if (!isNaN(newValueFromInput) && newValueFromInput >= 0) {
                            rsg_selectedStops_extra[changedIndex].timeAdjustment = newValueFromInput;
                        } else { 
                            rsg_selectedStops_extra[changedIndex].timeAdjustment = 0;
                            if (isNaN(newValueFromInput) || newValueFromInput < 0) timeAdjInput.value = 0; 
                        }
                    }
                    if (stopDataForListener) { // Ensure data is valid before updating warning
                         renderOrUpdateWarningIcon(changedIndex, stopDataForListener, timeAdjInput, actionsDiv);
                    }
                });
            } 

            const removeButton = document.createElement('button');
            removeButton.textContent = 'âœ•';
            removeButton.classList.add('button', 'small-action', 'secondary');
            removeButton.title = 'Remove Stop';
            removeButton.addEventListener('click', () => rsg_removeStopFromSequence_ExtraPage(parseInt(li.dataset.index)));
            actionsDiv.appendChild(removeButton);

            mainContentDiv.appendChild(stopInfoDiv);
            mainContentDiv.appendChild(actionsDiv);
            li.appendChild(mainContentDiv);

            if (loopIndex > 0) {
                const copyButtonsContainer = document.createElement('div');
                copyButtonsContainer.classList.add('rsg-copy-adjustment-buttons-container');
                // 'renderOrUpdateWarningIcon' is now in scope for this entire iteration
                rsg_createCopyAdjustmentButtons_ExtraPage(stop, loopIndex, copyButtonsContainer, timeAdjInput, actionsDiv, renderOrUpdateWarningIcon);
                li.appendChild(copyButtonsContainer);
            }
            
            console.log(`RSG Render: PRE-APPEND for index ${loopIndex}, stopID: ${stop.stopID}`);
            rsgStopSequenceList_el_extra.appendChild(li);
            console.log(`RSG Render: POST-APPEND for index ${loopIndex}, stopID: ${stop.stopID}`);

            li.addEventListener('dragstart', rsg_handleDragStart_ExtraPage);
            li.addEventListener('dragover', rsg_handleDragOver_ExtraPage);
            li.addEventListener('dragleave', rsg_handleDragLeave_ExtraPage);
            li.addEventListener('drop', rsg_handleDrop_ExtraPage);
            li.addEventListener('dragend', rsg_handleDragEnd_ExtraPage);
        });
        console.log("RSG Render: Loop finished.");
    }
}

        function rsg_handleDragStart_ExtraPage(event) {  
            rsg_draggedItemIndex_extra = parseInt(event.target.closest('li').dataset.index); event.dataTransfer.effectAllowed = 'move'; event.dataTransfer.setData('text/plain', rsg_draggedItemIndex_extra); setTimeout(() => { event.target.closest('li').classList.add('rsg-dragging-item'); }, 0); if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = "Dragging stop..."; rsgStatusMessage_el_extra.style.color = "#3498db"; }
        }
        function rsg_handleDragOver_ExtraPage(event) { 
            event.preventDefault(); event.dataTransfer.dropEffect = 'move'; const targetLi = event.target.closest('li'); if (targetLi && parseInt(targetLi.dataset.index) !== rsg_draggedItemIndex_extra) { Array.from(rsgStopSequenceList_el_extra.children).forEach(child => child.classList.remove('rsg-dragover-target')); targetLi.classList.add('rsg-dragover-target'); }
        }
        function rsg_handleDragLeave_ExtraPage(event) { 
            const targetLi = event.target.closest('li'); if (targetLi) { targetLi.classList.remove('rsg-dragover-target');}
        }
        function rsg_handleDrop_ExtraPage(event) { 
            event.preventDefault(); const targetLi = event.target.closest('li'); if (!targetLi) return; const droppedOnItemIndex = parseInt(targetLi.dataset.index); Array.from(rsgStopSequenceList_el_extra.children).forEach(child => child.classList.remove('rsg-dragover-target')); if (rsg_draggedItemIndex_extra !== null && rsg_draggedItemIndex_extra !== droppedOnItemIndex) { const itemToMove = rsg_selectedStops_extra.splice(rsg_draggedItemIndex_extra, 1)[0]; rsg_selectedStops_extra.splice(droppedOnItemIndex, 0, itemToMove); rsg_renderStopSequence_ExtraPage(); rsg_resetPreviewState("Stop order changed. Regenerate preview.", "info"); }
        }
        function rsg_handleDragEnd_ExtraPage(event) { 
             Array.from(rsgStopSequenceList_el_extra.children).forEach(childLi => { childLi.classList.remove('rsg-dragging-item'); childLi.classList.remove('rsg-dragover-target'); }); rsg_draggedItemIndex_extra = null;
        }
        function rsg_handleStopSearch_ExtraPage(event) { 
            if (!rsgStopSearchInput_el_extra || !rsgStopSearchResults_el_extra) return; const searchTerm = rsgStopSearchInput_el_extra.value.toLowerCase(); rsgStopSearchResults_el_extra.innerHTML = ''; if (searchTerm.length < 2) { return; } const uniqueStops = getUniqueStopsFromSchedule_ExtraPage(); const filteredStops = uniqueStops.filter(stop => stop.stopName.toLowerCase().includes(searchTerm) || stop.stopID.toLowerCase().includes(searchTerm)).slice(0, 10); if (filteredStops.length > 0) { filteredStops.forEach(stop => { const itemDiv = document.createElement('div'); itemDiv.classList.add('rsg-search-result-item'); let content = `<span class="rsg-search-stop-name">${stop.stopName} (${stop.stopID})</span>`; content += `<span class="rsg-search-stop-details">Towards: ${stop.direction || 'N/A'}</span>`; const servingRoutes = new Set(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === stop.stopID && entry.lineName && entry.lineName !== "INFO_ONLY") { servingRoutes.add(entry.lineName); } }); if (servingRoutes.size > 0) { content += `<div class="rsg-search-serving-routes">`; Array.from(servingRoutes).sort(compareLineNames_ExtraPage).slice(0, 5).forEach(line => { const bgColor = getRouteTileColour_ExtraPage(line, stop.stopID); const textColor = getTextColourForBackground_ExtraPage(bgColor); content += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor};font-size:0.7em;padding:0.1em 0.3em;">${line}</span>`; }); if (servingRoutes.size > 5) content += `<span style="font-size:0.7em;opacity:0.8;"> +${servingRoutes.size - 5} more</span>`; content += `</div>`; } itemDiv.innerHTML = content; itemDiv.addEventListener('click', () => { rsg_addStopToSequence_ExtraPage(stop.stopID, stop.stopName, stop.direction); rsgStopSearchInput_el_extra.value = ''; rsgStopSearchResults_el_extra.innerHTML = ''; rsgStopSearchInput_el_extra.focus(); }); rsgStopSearchResults_el_extra.appendChild(itemDiv); }); } else { rsgStopSearchResults_el_extra.innerHTML = '<div class="rsg-search-result-item">No stops found.</div>'; }
        }

        function rsg_addStopToSequence_ExtraPage(stopID, stopName, direction) { 
            if (rsg_selectedStops_extra.length > 0 && rsg_selectedStops_extra[rsg_selectedStops_extra.length -1].stopID === stopID) { if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = "Stop already last in sequence."; rsgStatusMessage_el_extra.style.color = "#f1c40f"; } return; } rsg_selectedStops_extra.push({ stopID: stopID, stopName: stopName, direction: direction, timeAdjustment: rsg_selectedStops_extra.length > 0 ? 2 : 0 }); rsg_renderStopSequence_ExtraPage(); rsg_resetPreviewState("Stop added. Regenerate preview if needed.", "info");
        }

        function rsg_removeStopFromSequence_ExtraPage(index) {
            if (rsg_selectedStops_extra && rsg_selectedStops_extra.length > index) {
                const removedStop = rsg_selectedStops_extra.splice(index, 1);
                console.log("RSG User Edit: Stop removed from sequence - ", removedStop[0] ? removedStop[0].stopID : 'N/A');
            } else {
                console.warn("RSG User Edit: Attempted to remove stop from sequence at invalid index or empty sequence.");
            }
            rsg_isDirty = true;
            console.log(`RSG State: rsg_isDirty set to true (stop removed). Current sequence length: ${rsg_selectedStops_extra.length}`);
            rsg_renderStopSequence_ExtraPage();
            rsg_resetPreviewState("Stop removed. Regenerate preview if needed.", "info");
        }

        function rsg_handleGenerateSchedulePreview_ExtraPage(isPreCheck = false) {
    console.log("RSG_HANDLE_GENERATE_SCHEDULE_PREVIEW_EXTRA_PAGE CALLED. isPreCheck:", isPreCheck);

    if (!rsgRouteNameInput_el_extra ||
        !rsgDestinationNameInput_el_extra ||
        !rsgFirstStopTimesInput_el_extra ||
        !rsgStatusMessage_el_extra) {
        console.error("RSG Preview Error: Essential DOM elements missing.");
        if (!isPreCheck && rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Critical Error: RSG form components missing.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }

    const routeName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
    let opProfileForGeneration = rsg_getSelectedOpProfilesString_ExtraPage();
    const destName = rsgDestinationNameInput_el_extra.value.trim();
    const firstStopTimesStr = rsgFirstStopTimesInput_el_extra.value.trim();

    // --- VALIDATION CHECKS ---
    if (!routeName) {
        if (!isPreCheck) {
            rsgStatusMessage_el_extra.textContent = "Route Name is required.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
    if (!opProfileForGeneration && rsg_lastLoadedOpProfile_extra &&
        routeName.toUpperCase() === (rsg_lastLoadedRouteName_extra || "").toUpperCase() &&
        destName === (rsg_lastLoadedDestName_extra || "")) {
        opProfileForGeneration = rsg_lastLoadedOpProfile_extra;
        if (!isPreCheck && rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.dataset.profileAssumed = 'true';
        }
    } else if (!opProfileForGeneration) {
        if (!isPreCheck) {
            rsgStatusMessage_el_extra.textContent = "Operating Profile is required.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
    if (!destName) {
        if (!isPreCheck) {
            rsgStatusMessage_el_extra.textContent = "Destination Name is required.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
    if (rsg_selectedStops_extra.length === 0) {
        if (!isPreCheck) {
            rsgStatusMessage_el_extra.textContent = "Please add at least one stop to the sequence.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
    const firstStopTimes = firstStopTimesStr.split(/\t/).map(t => t.trim()).filter(t => t.match(/^\d{2}:\d{2}$/));
    if (firstStopTimes.length === 0) {
        if (!isPreCheck) {
            rsgStatusMessage_el_extra.textContent = "Invalid format for first stop times (HH:MM, comma/semicolon/tab separated).";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return false;
    }
    // --- END VALIDATION ---

    console.log(`RSG Preview: Validation passed. Profile: '${opProfileForGeneration}', Route: '${routeName}', Dest: '${destName}'.`);
    rsg_generatedPreviewEntries_extra = [];

    firstStopTimes.forEach(startTimeHHMM => {
        const startParts = startTimeHHMM.split(':');
        let currentMinutesFromMidnight = parseInt(startParts[0], 10) * 60 + parseInt(startParts[1], 10);
        let currentDayOffset = 0;

        rsg_selectedStops_extra.forEach((stop, index) => {
            if (!stop || typeof stop.stopID === 'undefined') return;
            if (index > 0) {
                const adjustment = (typeof stop.timeAdjustment === 'number' && !isNaN(stop.timeAdjustment)) ? stop.timeAdjustment : 0;
                currentMinutesFromMidnight += adjustment;
            }
            while (currentMinutesFromMidnight >= 1440) {
                currentMinutesFromMidnight -= 1440; currentDayOffset++;
            }
            while (currentMinutesFromMidnight < 0) {
                currentMinutesFromMidnight += 1440; currentDayOffset--;
            }
            const hours = Math.floor(currentMinutesFromMidnight / 60);
            const minutes = currentMinutesFromMidnight % 60;
            const scheduledTimeOutput = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            rsg_generatedPreviewEntries_extra.push({
                internalId: `${stop.stopID}_${routeName}_${scheduledTimeOutput.replace(':', '')}_${opProfileForGeneration.replace(/[^a-zA-Z0-9]/g, '')}_rsg${Date.now()}${index}`,
                stopID: stop.stopID, stopName: stop.stopName, direction: stop.direction,
                lineName: routeName, destinationName: destName, scheduledTime: scheduledTimeOutput,
                OperatingProfile: opProfileForGeneration, DayOffset: String(currentDayOffset)
            });
        });
    });
    console.log("RSG Preview: Generated entries count:", rsg_generatedPreviewEntries_extra.length);

    if (!isPreCheck) {
        rsg_renderPreviewTable_ExtraPage();

        if (rsgAddToWorkingScheduleButton_el_extra) {
            if (rsg_generatedPreviewEntries_extra.length > 0) {
                rsgAddToWorkingScheduleButton_el_extra.disabled = false;
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.add('save'); // Green and active
            } else {
                rsgAddToWorkingScheduleButton_el_extra.disabled = true;
                rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
                rsgAddToWorkingScheduleButton_el_extra.classList.remove('save'); // Grey and inactive
            }
        }

        if (rsgSchedulePreviewContainer_el_extra) {
            rsgSchedulePreviewContainer_el_extra.style.display = rsg_generatedPreviewEntries_extra.length > 0 ? 'block' : 'none';
        }

        let statusMsg = "";
        let statusColor = "";
        if (rsgStatusMessage_el_extra.dataset.profileAssumed === 'true') { // Check if profile was assumed
             statusMsg = `Preview with assumed profile '${opProfileForGeneration}' `;
             statusMsg += rsg_generatedPreviewEntries_extra.length > 0 ? `generated ${rsg_generatedPreviewEntries_extra.length} entries.` : `generated 0 entries. Check inputs.`;
             statusColor = rsg_generatedPreviewEntries_extra.length > 0 ? '#2ecc71' : '#f1c40f';
             statusMsg += " Save will require explicit profile selection if assumption is not desired.";
        } else {
            statusMsg = rsg_generatedPreviewEntries_extra.length > 0 ? `Preview generated for ${rsg_generatedPreviewEntries_extra.length} entries.` : `Preview generated 0 entries. Check inputs.`;
            statusColor = rsg_generatedPreviewEntries_extra.length > 0 ? '#2ecc71' : '#f1c40f';
        }
        rsgStatusMessage_el_extra.textContent = statusMsg;
        rsgStatusMessage_el_extra.style.color = statusColor;
        delete rsgStatusMessage_el_extra.dataset.profileAssumed; // Clear the flag
    }
    return rsg_generatedPreviewEntries_extra.length > 0;
}
        function rsg_renderPreviewTable_ExtraPage() { 
            if (!rsgPreviewTableBody_el_extra || !rsgSchedulePreviewContainer_el_extra) return; rsgPreviewTableBody_el_extra.innerHTML = ''; if (rsg_generatedPreviewEntries_extra.length === 0) { return; } rsg_generatedPreviewEntries_extra.forEach(entry => { const row = rsgPreviewTableBody_el_extra.insertRow(); row.insertCell().textContent = entry.stopID; row.insertCell().textContent = entry.stopName; row.insertCell().textContent = entry.scheduledTime; row.insertCell().textContent = entry.lineName; row.insertCell().textContent = entry.destinationName; row.insertCell().textContent = entry.OperatingProfile; row.insertCell().textContent = entry.DayOffset; });
        }
        
        function rsg_resetPreviewState(message = "Configuration changed. Please (re)generate preview or add short workings.", messageType = "info") {
    rsg_generatedPreviewEntries_extra = [];

    if(rsgPreviewTableBody_el_extra) {
        rsgPreviewTableBody_el_extra.innerHTML = '';
    }
    if(rsgSchedulePreviewContainer_el_extra) {
        rsgSchedulePreviewContainer_el_extra.style.display = 'none';
    }

    if(rsgAddToWorkingScheduleButton_el_extra) {
        // Ensure button is visible, but disabled and styled as neutral
        // No style.display change here
        rsgAddToWorkingScheduleButton_el_extra.disabled = true;
        rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
        rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
    }

    if(rsgStatusMessage_el_extra) {
        const isCurrentMessageError = rsgStatusMessage_el_extra.style.color === 'rgb(231, 76, 60)' || rsgStatusMessage_el_extra.style.color === '#e74c3c';
        if (!isCurrentMessageError || messageType !== "info" ) {
            rsgStatusMessage_el_extra.textContent = message;
            if (messageType === "info") {
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            } else if (messageType === "success") {
                rsgStatusMessage_el_extra.style.color = "#2ecc71";
            } else if (messageType === "error") {
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            } else {
                rsgStatusMessage_el_extra.style.color = "";
            }
        }
    }
}

async function rsg_handleAddGeneratedToWorkingSchedule_ExtraPage() {
    if (!currentUser_extra) {
        alert("Please log in to modify the working schedule.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Not logged in.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    if (!rsg_generatedPreviewEntries_extra || rsg_generatedPreviewEntries_extra.length === 0) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "No schedule entries generated in the preview to add.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    const targetRouteName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
    // --- MODIFICATION START ---
    let targetOpProfile = rsg_getSelectedOpProfilesString_ExtraPage(); // Get from checkboxes first
    // --- MODIFICATION END ---
    const targetDestName = rsgDestinationNameInput_el_extra.value.trim();

    const previewSample = rsg_generatedPreviewEntries_extra[0];

    // If checkboxes were empty, but preview was generated (e.g. from a loaded config or assumed profile),
    // use the profile from the preview sample for consistency.
    if (!targetOpProfile && previewSample.OperatingProfile) {
        targetOpProfile = previewSample.OperatingProfile;
        console.log("rsg_handleAddGeneratedToWorkingSchedule: Using Operating Profile from preview sample as checkboxes were empty:", targetOpProfile);
    }


    if (previewSample.lineName.toUpperCase() !== targetRouteName ||
        previewSample.destinationName !== targetDestName ||
        previewSample.OperatingProfile !== targetOpProfile // Compare with the now definitively set targetOpProfile
       ) {
        if (previewSample.OperatingProfile !== targetOpProfile && 
            previewSample.lineName.toUpperCase() === targetRouteName && 
            previewSample.destinationName === targetDestName) {
             if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Profile mismatch: Preview used '${previewSample.OperatingProfile}', but current form/context indicates '${targetOpProfile}'. Please ensure Operating Profile selection is clear or re-generate preview.`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
             }
             return;
        } else if (previewSample.lineName.toUpperCase() !== targetRouteName || previewSample.destinationName !== targetDestName) {
             if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Route/Destination in form does not match generated preview. Please re-generate if settings changed.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
             }
             return;
        }
    }
    // At this point, targetOpProfile should be what was actually used for generation or reconciled.
    
    if (!targetRouteName || !targetOpProfile || !targetDestName) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route Name, Operating Profile, and Destination Name must be effectively defined (from Section 1) to update the schedule.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const actionChoice = prompt(
        `Choose action for the ${rsg_generatedPreviewEntries_extra.length} previewed entries for:\n` +
        `Route: ${targetRouteName}\nProfile: ${targetOpProfile}\nDestination: ${targetDestName}\n\n` +
        `1. OVERWRITE existing entries for this specific Route, Profile, and Destination.\n` +
        `2. ADD these new entries (will append if R/P/D exists, or create if new).\n\n` +
        `Enter 1 or 2 (or Cancel):`
    );

    let newEntriesCount = rsg_generatedPreviewEntries_extra.length;
    let operationPerformed = false;
    const entriesToAdd = JSON.parse(JSON.stringify(rsg_generatedPreviewEntries_extra));

    if (actionChoice === "1") { 
        if (confirm(`ARE YOU SURE you want to REMOVE all existing entries for Route "${targetRouteName}", Profile "${targetOpProfile}", Destination "${targetDestName}" AND THEN ADD these ${newEntriesCount} new entries?`)) {
            
            let removedCount = 0;
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
                const matchesRPD = entry.lineName && entry.lineName.toUpperCase() === targetRouteName &&
                                   entry.OperatingProfile === targetOpProfile &&
                                   entry.destinationName === targetDestName;
                if (matchesRPD) {
                    removedCount++;
                    return false; 
                }
                return true; 
            });
            
            currentWorkingSchedule_extra.push(...entriesToAdd);
            
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Removed ${removedCount} existing entries. Working schedule will be updated with ${newEntriesCount} new entries for ${targetRouteName}/${targetOpProfile}/${targetDestName}. Saving...`;
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }
            operationPerformed = true;
        } else {
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Overwrite operation cancelled by user.";
                rsgStatusMessage_el_extra.style.color = "";
            }
            return;
        }
    } else if (actionChoice === "2") { 
        currentWorkingSchedule_extra.push(...entriesToAdd);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `${newEntriesCount} entries will be ADDED to the working schedule (for ${targetRouteName}/${targetOpProfile}/${targetDestName} if applicable). Saving...`;
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        operationPerformed = true;
    } else {
        if (actionChoice !== null && rsgStatusMessage_el_extra) { 
            rsgStatusMessage_el_extra.textContent = "Invalid choice. Operation cancelled.";
        } else if (rsgStatusMessage_el_extra) { 
             rsgStatusMessage_el_extra.textContent = "Add to working schedule cancelled.";
        }
        if (rsgStatusMessage_el_extra) rsgStatusMessage_el_extra.style.color = "";
        return;
    }

    if (operationPerformed) {
        try {
            await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
            
            if (rsgStatusMessage_el_extra) {
                const messageAction = actionChoice === "1" ? `Overwrote entries for R/P/D and added ${newEntriesCount} new ones.` : `Added ${newEntriesCount} entries.`;
                rsgStatusMessage_el_extra.textContent = `Successfully saved. ${messageAction} Working schedule now has ${currentWorkingSchedule_extra.length} total entries.`;
                rsgStatusMessage_el_extra.style.color = "#2ecc71";
            }
            
            rsg_resetPreviewState("Successfully added to working schedule. Ready for new generation.", "success");
            renderUIDependentElements_ExtraPage(); 

        } catch (error) {
            console.error("Error in rsg_handleAddGeneratedToWorkingSchedule_ExtraPage (saving to Firebase):", error);
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Error saving to Firebase: " + error.message + ". Local changes might not be live. Please review.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
        }
    }
}
        // ++ END Route Schedule Generator Functions ++

// ++ Functions for "Schedule This Configuration" -- START ++
        function rsg_closeScheduleDateTimeModal_ExtraPage() {
            const modal = document.getElementById('rsg-schedule-datetime-modal-extra');
            if (modal) modal.style.display = 'none';
        }

        async function rsg_confirmScheduleGoLive_ExtraPage() {
            const goLiveInput = document.getElementById('rsg-go-live-datetime-input-extra');
            const modalStatus = document.getElementById('rsg-schedule-datetime-modal-status-extra');

            if (!goLiveInput || !modalStatus) {
                console.error("RSG Schedule Modal Error: DateTime input or status element not found.");
                return;
            }

            const goLiveDateTime = goLiveInput.value;
            if (!goLiveDateTime) {
                modalStatus.textContent = "Please select a go-live date and time.";
                modalStatus.style.color = "#e74c3c";
                return;
            }

            const goLiveDateObj = new Date(goLiveDateTime);
            if (isNaN(goLiveDateObj.getTime())) {
                modalStatus.textContent = "Invalid date/time format.";
                modalStatus.style.color = "#e74c3c";
                return;
            }

            if (goLiveDateObj <= new Date()) {
                modalStatus.textContent = "Go-live date/time must be in the future.";
                modalStatus.style.color = "#e74c3c";
                return;
            }

            // Gather current RSG state for the configuration to schedule
            const routeName = rsgRouteNameInput_el_extra.value.trim();
            let operatingProfile = rsg_getSelectedOpProfilesString_ExtraPage(); // From checkboxes
            const destinationName = rsgDestinationNameInput_el_extra.value.trim();
            const stopSequence = rsg_selectedStops_extra;
            const firstStopTimes = rsgFirstStopTimesInput_el_extra.value.trim();

            // Fallback for operating profile if checkboxes are empty but context exists
            if (!operatingProfile && rsg_lastLoadedOpProfile_extra &&
                routeName.toUpperCase() === (rsg_lastLoadedRouteName_extra || "").toUpperCase() &&
                destinationName === (rsg_lastLoadedDestName_extra || "")) {
                operatingProfile = rsg_lastLoadedOpProfile_extra;
            }
            
            if (!routeName || !operatingProfile || !destinationName || stopSequence.length === 0 || !firstStopTimes) {
                 modalStatus.textContent = "Cannot schedule: Route, Profile, Destination, Sequence, and Times are required from RSG form.";
                 modalStatus.style.color = "#e74c3c";
                 return;
            }

            // Ensure the preview is valid for what's being scheduled
            if (!rsg_handleGenerateSchedulePreview_ExtraPage(true)) { // isPreCheck = true
                modalStatus.textContent = "The current RSG configuration is invalid. Please correct and re-generate preview before scheduling.";
                modalStatus.style.color = "#e74c3c";
                if (rsgStatusMessage_el_extra){
                     rsgStatusMessage_el_extra.textContent = "The current RSG configuration is invalid. Please correct and re-generate preview before scheduling.";
                     rsgStatusMessage_el_extra.style.color = "#e74c3c";
                }
                rsg_closeScheduleDateTimeModal_ExtraPage();
                return;
            }
            
            // Use the generated preview entries as the source of truth for what to schedule
            const configurationToSchedule = {
                taskType: "applySchedule",
                routeName: routeName,
                destinationName: destinationName,
                operatingProfile: operatingProfile, // This should match what was used for the preview
                stopSequence: JSON.parse(JSON.stringify(rsg_selectedStops_extra)), // Current sequence from RSG
                firstStopTimes: firstStopTimes, // Current times from RSG
                scheduledEntries: JSON.parse(JSON.stringify(rsg_generatedPreviewEntries_extra)), // The actual entries
                goLiveDateTime: goLiveDateObj.toISOString(),
                scheduledAt: new Date().toISOString(),
                status: "pending", // e.g., pending, applied, cancelled
                userEmail: currentUser_extra ? currentUser_extra.email : "unknown"
            };

            modalStatus.textContent = "Scheduling configuration...";
            modalStatus.style.color = "#f1c40f";

            const { database, dbSet, dbRef } = window.firebaseOMSI;
            try {
                // Create a unique key for this scheduled update (e.g., using timestamp + route)
                const scheduleKey = `sched_${Date.now()}_${sanitizeFirebaseKey(routeName)}`;
                await dbSet(dbRef(database, `${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${scheduleKey}`), configurationToSchedule);

                modalStatus.textContent = "Configuration scheduled successfully!";
                modalStatus.style.color = "#2ecc71";
                if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = `Configuration for ${routeName} to ${destinationName} (${operatingProfile}) scheduled for ${goLiveDateObj.toLocaleString()}.`;
                    rsgStatusMessage_el_extra.style.color = "#2ecc71";
                }
                setTimeout(rsg_closeScheduleDateTimeModal_ExtraPage, 2000);

            } catch (error) {
                console.error("Error scheduling RSG configuration to Firebase:", error);
                modalStatus.textContent = "Error scheduling: " + error.message;
                modalStatus.style.color = "#e74c3c";
                 if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = "Error scheduling configuration.";
                    rsgStatusMessage_el_extra.style.color = "#e74c3c";
                }
            }
        }

        function handleScheduleThisConfiguration() {
            console.log("Schedule This Configuration button clicked!");
            const scheduleModal = document.getElementById('rsg-schedule-datetime-modal-extra');
            
            if (!currentUser_extra) {
                alert("Please log in to schedule configurations.");
                if (rsgStatusMessage_el_extra) {
                    rsgStatusMessage_el_extra.textContent = "Please log in.";
                    rsgStatusMessage_el_extra.style.color = "#e74c3c";
                }
                return;
            }

            if (scheduleModal) {
                // Perform a pre-check to ensure the current RSG form state can generate a valid preview.
                // The rsg_handleGenerateSchedulePreview_ExtraPage(true) function itself will set status messages if validation fails.
                if (!rsg_handleGenerateSchedulePreview_ExtraPage(true)) { // Pass true for isPreCheck
                    // rsg_handleGenerateSchedulePreview_ExtraPage(true) will already set rsgStatusMessage_el_extra on failure.
                    // We could add an additional, more direct message here if desired, but it might be redundant.
                    // e.g., if(rsgStatusMessage_el_extra) rsgStatusMessage_el_extra.textContent = "Cannot schedule: current RSG form is invalid. Please correct and generate a preview.";
                    return; 
                }
                
                // If pre-check passes (meaning a valid schedule *could* be generated), then proceed to show modal.
                const modalStatus = document.getElementById('rsg-schedule-datetime-modal-status-extra');
                if (modalStatus) modalStatus.textContent = ''; // Clear previous modal status

                const goLiveInput = document.getElementById('rsg-go-live-datetime-input-extra');
                if (goLiveInput) {
                    const tomorrow = new Date();
                    tomorrow.setDate(tomorrow.getDate() + 1); // Default to tomorrow
                    tomorrow.setHours(5, 0, 0, 0); // Default to 05:00 AM (typical service change time)
                    
                    const year = tomorrow.getFullYear();
                    const month = String(tomorrow.getMonth() + 1).padStart(2, '0');
                    const day = String(tomorrow.getDate()).padStart(2, '0');
                    const hours = String(tomorrow.getHours()).padStart(2, '0');
                    const minutes = String(tomorrow.getMinutes()).padStart(2, '0');
                    goLiveInput.value = `${year}-${month}-${day}T${hours}:${minutes}`;
                }
                scheduleModal.style.display = 'flex';
            } else {
                console.error("Schedule DateTime modal (rsg-schedule-datetime-modal-extra) not found!");
                if (rsgStatusMessage_el_extra) {
                     rsgStatusMessage_el_extra.textContent = "Error: Scheduling modal component is missing.";
                     rsgStatusMessage_el_extra.style.color = "#e74c3c";
                }
            }
        }
        // ++ Functions for "Schedule This Configuration" -- END ++

// ++ Scheduled Route Updates (SRU) Functions -- START ++

        async function loadAndDisplayScheduledUpdates_ExtraPage() {
    const listContainer = document.getElementById('sru-updates-list-container-extra');
    if (!listContainer || !window.firebaseOMSI) {
        if (listContainer) listContainer.innerHTML = '<p>Error: Firebase not available.</p>';
        console.error("SRU/SRD Load: Firebase or list container not available.");
        return;
    }
    listContainer.innerHTML = '<p>Loading all scheduled tasks...</p>';
    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;

    // Initialize with empty objects
    scheduledRouteUpdates_extra = {};
    scheduledRouteDeletions_extra = {};

    try {
        // Fetch timetable application updates
        console.log("SRU Load: Attempting to fetch schedule application tasks...");
        const updatesSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULED_ROUTE_UPDATES));
        if (updatesSnap.exists()) {
            scheduledRouteUpdates_extra = updatesSnap.val() || {}; // Ensure it's an object
        }
        console.log(`SRU Load: Fetched ${Object.keys(scheduledRouteUpdates_extra).length} schedule application tasks.`);

        // Fetch route deletion tasks
        console.log("SRU Load: Attempting to fetch route deletion tasks...");
        const deletionsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULED_DELETIONS));
        if (deletionsSnap.exists()) {
            scheduledRouteDeletions_extra = deletionsSnap.val() || {}; // Ensure it's an object
        } else {
            scheduledRouteDeletions_extra = {}; // Path doesn't exist or is null
        }
        // --- THIS IS THE DETAILED LOG YOU WERE ASKING FOR ---
        console.log(`SRU Load: Fetched ${Object.keys(scheduledRouteDeletions_extra).length} route deletion tasks. Content:`, JSON.parse(JSON.stringify(scheduledRouteDeletions_extra)));
        // --- END OF DETAILED LOG ---

        renderScheduledUpdatesList_ExtraPage();
        
        // *** ADD THIS LINE ***
        checkAndDisplayDueUpdatesNotification_ExtraPage();

    } catch (error) {
        console.error("Error loading scheduled tasks (updates and/or deletions):", error);
        listContainer.innerHTML = `<p style="color:#e74c3c;">Error loading tasks: ${error.message}</p>`;
        // Ensure they are reset on error too
        scheduledRouteUpdates_extra = {};
        scheduledRouteDeletions_extra = {};
    }
}

        function renderScheduledUpdatesList_ExtraPage() {
    const listContainer = document.getElementById('sru-updates-list-container-extra');
    if (!listContainer) {
        console.error("SRU Render: List container 'sru-updates-list-container-extra' not found.");
        return;
    }
    listContainer.innerHTML = '<p>Processing scheduled tasks list...</p>';

    let allApplyScheduleTasks = [];
    let allDeleteTasks = [];

    if (typeof scheduledRouteUpdates_extra === 'object' && scheduledRouteUpdates_extra !== null) {
        Object.entries(scheduledRouteUpdates_extra).forEach(([key, value]) => {
            if (value && typeof value === 'object' && (value.taskType === 'applySchedule' || value.taskTypeDisplay === 'applySchedule')) {
                allApplyScheduleTasks.push({ key, ...value, taskTypeDisplay: 'applySchedule' });
            }
        });
    }
    if (typeof scheduledRouteDeletions_extra === 'object' && scheduledRouteDeletions_extra !== null) {
        Object.entries(scheduledRouteDeletions_extra).forEach(([key, value]) => {
            if (value && typeof value === 'object' && (value.taskType === 'deleteEntireRoute' || value.taskTypeDisplay === 'deleteEntireRoute')) {
                allDeleteTasks.push({ key, ...value, taskTypeDisplay: 'deleteEntireRoute' });
            }
        });
    }
    console.log("SRU Render Debug: Initial allApplyScheduleTasks", JSON.parse(JSON.stringify(allApplyScheduleTasks)));
    console.log("SRU Render Debug: Initial allDeleteTasks", JSON.parse(JSON.stringify(allDeleteTasks)));

    const allKnownRouteNamesFromSchedule = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName).filter(Boolean))];

    const applyTasksGroupedByRouteThenTime = {};
    allApplyScheduleTasks.forEach(task => {
        const routeNameForGrouping = task.routeName || "UnspecifiedRoute";
        const goLiveISO = task.goLiveDateTime;
        if (!goLiveISO) {
            console.warn("SRU Render: Task has no goLiveDateTime, cannot group:", task.key, task);
            // Optionally group these under a special "InvalidGoLiveTime" key if you want to see them
            if (!applyTasksGroupedByRouteThenTime["InvalidGoLiveTime"]) {
                applyTasksGroupedByRouteThenTime["InvalidGoLiveTime"] = { "UnknownTime": [] };
            }
            applyTasksGroupedByRouteThenTime["InvalidGoLiveTime"]["UnknownTime"].push(task);
            return; // Skip normal grouping if goLiveISO is missing
        }
        if (!applyTasksGroupedByRouteThenTime[routeNameForGrouping]) {
            applyTasksGroupedByRouteThenTime[routeNameForGrouping] = {};
        }
        if (!applyTasksGroupedByRouteThenTime[routeNameForGrouping][goLiveISO]) {
            applyTasksGroupedByRouteThenTime[routeNameForGrouping][goLiveISO] = [];
        }
        applyTasksGroupedByRouteThenTime[routeNameForGrouping][goLiveISO].push(task);
    });
    console.log("SRU Render Debug: Grouped applyTasksGroupedByRouteThenTime", JSON.parse(JSON.stringify(applyTasksGroupedByRouteThenTime)));

    listContainer.innerHTML = '';
    let anyContentRenderedOverall = false;

    const allRoutesToDisplaySet = new Set([
        ...allKnownRouteNamesFromSchedule,
        ...Object.keys(applyTasksGroupedByRouteThenTime).filter(rn => rn !== "UnspecifiedRoute" && rn !== "InvalidGoLiveTime"), // Exclude special keys for main loop
        ...allDeleteTasks.map(t => t.routeName).filter(Boolean).filter(rn => rn !== "UnspecifiedRoute")
    ]);
    const sortedRoutesToDisplay = Array.from(allRoutesToDisplaySet).sort(compareLineNames_ExtraPage);
    console.log("SRU Render Debug: Final sortedRoutesToDisplay for iteration (excluding Unspecified/Invalid):", sortedRoutesToDisplay);

    if (sortedRoutesToDisplay.length > 0 ) {
        const sectionTitle = document.createElement('h3');
        sectionTitle.className = 'subsection-title';
        sectionTitle.textContent = 'Scheduled Tasks (Grouped by Route)';
        sectionTitle.style.color = '#B2DFDB';
        sectionTitle.style.marginBottom = '1em';
        listContainer.appendChild(sectionTitle);
    }

    sortedRoutesToDisplay.forEach(routeName => {
        anyContentRenderedOverall = true;
        const routeGroupDiv = document.createElement('div');
        routeGroupDiv.className = 'sru-route-group subsection';
        routeGroupDiv.style.marginBottom = '2rem'; routeGroupDiv.style.paddingTop = '0.5rem';
        routeGroupDiv.style.borderLeft = '3px solid #607D8B';

        const routeHeading = document.createElement('h4');
        routeHeading.style.marginTop = '0.2em'; routeHeading.style.marginBottom = '1em';
        routeHeading.style.fontSize = '1.2em'; routeHeading.style.borderBottom = '1px solid #555';
        routeHeading.style.paddingBottom = '0.4em'; routeHeading.textContent = `Route: ${routeName}`;
        routeGroupDiv.appendChild(routeHeading);

        let contentAddedForThisRouteSection = false;

        // Part 1: Display 'applySchedule' task batches for this route
        const tasksByTimeForThisRoute = applyTasksGroupedByRouteThenTime[routeName];
        if (tasksByTimeForThisRoute && Object.keys(tasksByTimeForThisRoute).length > 0) {
            contentAddedForThisRouteSection = true;
            // ... (The existing detailed rendering logic for applySchedule batches for a route)
            // This includes creating applyUpdatesSubheading, iterating sortedGoLiveTimes,
            // creating batchContainerDiv, batchDetailsHTML, batchActionsDiv, applyBatchButton,
            // and individual cancel/delete record buttons for tasks within the batch.
            // --- Start of copied applySchedule rendering for a specific route ---
            const applyUpdatesSubheading = document.createElement('h5');
            applyUpdatesSubheading.textContent = "Timetable Updates:";
            applyUpdatesSubheading.style.color = "#DAF7A6";
            applyUpdatesSubheading.style.fontSize = "1em";
            applyUpdatesSubheading.style.marginBottom = "0.5em";
            routeGroupDiv.appendChild(applyUpdatesSubheading);

            const sortedGoLiveTimes = Object.keys(tasksByTimeForThisRoute).sort((a,b) => new Date(a).getTime() - new Date(b).getTime());
            sortedGoLiveTimes.forEach(goLiveISO => {
                const batchOfTasks = tasksByTimeForThisRoute[goLiveISO];
                batchOfTasks.sort((a, b) => {
                     const opA = a.operatingProfile || ""; const opB = b.operatingProfile || "";
                     const destA = a.destinationName || ""; const destB = b.destinationName || "";
                     if (opA.localeCompare(opB) !== 0) return opA.localeCompare(opB);
                     return destA.localeCompare(destB);
                });

                const batchContainerDiv = document.createElement('div');
                batchContainerDiv.className = 'sru-batch-container subsection';
                batchContainerDiv.style.marginLeft = "1em"; batchContainerDiv.style.marginBottom = "1rem";
                batchContainerDiv.style.padding = "0.8rem"; batchContainerDiv.style.borderLeft = "4px solid #3498db";

                let batchStatusSummary = 'pending';
                const allAppliedInBatch = batchOfTasks.every(t => t.status && t.status.startsWith('applied'));
                const anyErrorInBatch = batchOfTasks.some(t => t.status === 'error');

                if (allAppliedInBatch) batchStatusSummary = 'applied (batch)';
                else if (anyErrorInBatch) batchStatusSummary = 'error (in batch)';
                else if (batchOfTasks.some(t => t.status === 'pending')) batchStatusSummary = 'pending';

                let batchDetailsHTML = `<h6 style="margin-top:0; margin-bottom:0.6em; font-size:1.0em; color: #ecf0f1;">Batch Go-Live: ${new Date(goLiveISO).toLocaleString()} <span style="font-weight:bold; color:${batchStatusSummary === 'pending' ? '#f39c12' : (batchStatusSummary.startsWith('applied') ? '#2ecc71' : '#e74c3c')}">(${batchStatusSummary})</span></h6>`;
                batchDetailsHTML += `<p style="font-size:0.85em; margin-bottom:0.5em;">Contains ${batchOfTasks.length} update(s). Applying replaces <strong>entire Route ${routeName}</strong>.</p>`;
                batchDetailsHTML += '<ul style="font-size:0.8em; padding-left:1.5em; margin-bottom:0.75em;">';
                batchOfTasks.forEach(task => {
                    let taskStatusColor = task.status === 'pending' ? '#f1c40f' : (task.status && task.status.startsWith('applied') ? '#2ecc71' : (task.status === 'error' ? '#e74c3c' : '#bdc3c7'));
                    batchDetailsHTML += `<li style="margin-bottom:0.2em;">Target: (P: ${task.operatingProfile || 'N/A'}, D: ${task.destinationName || 'N/A'}) - ${task.scheduledEntries ? task.scheduledEntries.length : 0} entries. Status: <span style="color:${taskStatusColor}; font-weight:bold;">${task.status || 'N/A'}</span></li>`;
                });
                batchDetailsHTML += '</ul>';

                const batchActionsDiv = document.createElement('div');
                batchActionsDiv.style.marginTop = "0.5em";
                
                if (batchOfTasks.some(t => t.status === 'pending' || t.status === 'error')) {
                    const applyBatchButton = document.createElement('button');
                    applyBatchButton.className = 'button save sru-apply-batch-btn';
                    applyBatchButton.textContent = `Apply Batch Now`;
                    applyBatchButton.title = `Delete all for Route ${routeName}, apply ${batchOfTasks.length} updates.`;
                    applyBatchButton.addEventListener('click', () => handleApplyScheduledRouteBatch_ExtraPage(batchOfTasks));
                    batchActionsDiv.appendChild(applyBatchButton);
                } else if (allAppliedInBatch) {
                     batchActionsDiv.innerHTML = `<p style="font-size:0.9em; color:#2ecc71;">This batch has been applied.</p>`;
                }

                batchOfTasks.forEach(task => {
                    if (task.status === 'pending' || task.status === 'error') {
                        const cancelTaskButton = document.createElement('button');
                        cancelTaskButton.className = 'button small-action neutral sru-cancel-task-btn';
                        cancelTaskButton.textContent = `Cancel Upd: (P: ${task.operatingProfile || 'N/A'}, D: ${task.destinationName || 'N/A'})`;
                        cancelTaskButton.style.marginLeft = "8px"; cancelTaskButton.style.fontSize = "0.75em";
                        cancelTaskButton.title = `Cancel only this specific update task: ${task.key}`;
                        cancelTaskButton.dataset.key = task.key; cancelTaskButton.dataset.taskType = 'applySchedule';
                        batchActionsDiv.appendChild(cancelTaskButton);
                    } else if (task.status && !task.status.startsWith('applied (batch)')) { 
                        const deleteTaskRecordButton = document.createElement('button');
                        deleteTaskRecordButton.className = 'button small-action neutral sru-cancel-task-btn';
                        deleteTaskRecordButton.textContent = `Del.Rec: (P: ${task.operatingProfile || 'N/A'}, D: ${task.destinationName || 'N/A'})`;
                        deleteTaskRecordButton.style.marginLeft = "8px"; deleteTaskRecordButton.style.fontSize = "0.75em";
                        deleteTaskRecordButton.title = `Delete this task record: ${task.key}`;
                        deleteTaskRecordButton.dataset.key = task.key; deleteTaskRecordButton.dataset.taskType = 'applySchedule';
                        batchActionsDiv.appendChild(deleteTaskRecordButton);
                    }
                });
                batchContainerDiv.innerHTML = batchDetailsHTML;
                batchContainerDiv.appendChild(batchActionsDiv);
                routeGroupDiv.appendChild(batchContainerDiv);
            });
             // --- End of copied applySchedule rendering ---
        }

        // Part 2: Display 'deleteEntireRoute' tasks for THIS route
        const deleteTasksForThisRoute = allDeleteTasks.filter(task => task.routeName === routeName);
        if (deleteTasksForThisRoute.length > 0) {
            contentAddedForThisRouteSection = true;
            // ... (The existing detailed rendering logic for deleteEntireRoute tasks for a specific route)
            // This includes creating routeDeletionsSubheading, and for each task, itemDiv, status, actions.
            // --- Start of copied deleteEntireRoute rendering ---
            const routeDeletionsSubheading = document.createElement('h5');
            routeDeletionsSubheading.textContent = "Scheduled Withdrawal for this Route:";
            routeDeletionsSubheading.style.color = "#E74C3C";
            routeDeletionsSubheading.style.marginTop = (tasksByTimeForThisRoute && Object.keys(tasksByTimeForThisRoute).length > 0) ? "1.5em" : "0.5em";
            routeDeletionsSubheading.style.fontSize = "1em";
            routeDeletionsSubheading.style.borderTop = (tasksByTimeForThisRoute && Object.keys(tasksByTimeForThisRoute).length > 0) ? "1px dashed #555" : "none";
            routeDeletionsSubheading.style.paddingTop = (tasksByTimeForThisRoute && Object.keys(tasksByTimeForThisRoute).length > 0) ? "0.75em" : "0";
            routeGroupDiv.appendChild(routeDeletionsSubheading);

            deleteTasksForThisRoute.sort((a,b) => new Date(a.goLiveDateTime).getTime() - new Date(b.goLiveDateTime).getTime());
            deleteTasksForThisRoute.forEach(task => {
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('subsection');
                itemDiv.style.marginBottom = '0.75rem'; itemDiv.style.padding = '0.75rem';
                itemDiv.style.marginLeft = "1em"; itemDiv.style.borderLeft = "4px solid #c0392b";
                itemDiv.dataset.scheduleKey = task.key; itemDiv.dataset.taskType = 'deleteEntireRoute';

                let statusColor;
                switch (task.status) {
                    case 'pending': statusColor = '#f39c12'; break;
                    case 'applied': case 'applied (manual)': statusColor = '#2ecc71'; break;
                    case 'error': statusColor = '#e74c3c'; break;
                    case 'cancelled': statusColor = '#95a5a6'; break;
                    default: statusColor = '#ecf0f1';
                }
                let actionsHTML = '';
                if (task.status === 'pending') {
                    actionsHTML = `<button class="button small-action tertiary sru-execute-deletion-btn" data-key="${task.key}" style="background-color:#e67e22;">Execute Deletion Now</button> `;
                } else if (task.status === 'error') {
                    actionsHTML = `<button class="button small-action tertiary sru-execute-deletion-btn" data-key="${task.key}" style="background-color:#d35400;">Retry Deletion</button> `;
                }
                actionsHTML += `<button class="button small-action neutral sru-cancel-task-btn" data-key="${task.key}" data-task-type="deleteEntireRoute" style="margin-left:8px;">${(task.status === 'pending' || task.status === 'error') ? 'Cancel Task' : 'Delete Record'}</button>`;

                itemDiv.innerHTML = `
                    <h6 style="margin-top:0; margin-bottom:0.4em; font-size:1.0em; color: #e74c3c;">ROUTE WITHDRAWN (Go-Live: ${new Date(task.goLiveDateTime).toLocaleString()})</h6>
                    <p style="font-size:0.9em;">Status: <span style="font-weight:bold; color:${statusColor};">${task.status || 'N/A'}</span></p>
                    <p style="font-size:0.8em; opacity:0.8;">By: ${task.userEmail || 'System'} (ID: ${task.key ? task.key.substring(0,10) : 'N/A'}...)</p>
                    ${task.lastError ? `<p style="font-size:0.8em; color:#e74c3c;">Error: ${task.lastError}</p>` : ''}
                    <div class="scheduled-update-actions" style="margin-top:0.75em;">${actionsHTML}</div>`;
                routeGroupDiv.appendChild(itemDiv);
            });
            // --- End of copied deleteEntireRoute rendering ---
        }

        if (!contentAddedForThisRouteSection) {
            const noTasksMsg = document.createElement('p');
            noTasksMsg.textContent = `(No bus stop, route or timetable updates currently scheduled for Route ${routeName})`;
            noTasksMsg.style.fontSize = '0.85em'; noTasksMsg.style.opacity = '0.7';
            noTasksMsg.style.paddingLeft = '1em'; noTasksMsg.style.fontStyle = 'italic';
            routeGroupDiv.appendChild(noTasksMsg);
        }
        listContainer.appendChild(routeGroupDiv);
    });

    // --- Handle tasks under "UnspecifiedRoute" and "InvalidGoLiveTime" ---
    function renderSpecialCategoryTasks(categoryName, categoryKey, tasksByTime, deleteTasks, headingColor = "#f1c40f") {
        const categoryApplyTasksByTime = tasksByTime ? tasksByTime[categoryKey] : null;
        const categoryDeleteTasksFiltered = deleteTasks ? deleteTasks.filter(task => (task.routeName || "UnspecifiedRoute") === categoryKey) : [];

        if ((categoryApplyTasksByTime && Object.keys(categoryApplyTasksByTime).length > 0) || categoryDeleteTasksFiltered.length > 0) {
            anyContentRenderedOverall = true;
            const specialRouteGroupDiv = document.createElement('div');
            specialRouteGroupDiv.className = 'sru-route-group subsection';
            specialRouteGroupDiv.style.marginBottom = '2rem'; specialRouteGroupDiv.style.paddingTop = '0.5rem';
            specialRouteGroupDiv.style.borderLeft = `3px solid ${headingColor}`;

            const specialRouteHeading = document.createElement('h4');
            specialRouteHeading.style.marginTop = '0.2em'; specialRouteHeading.style.marginBottom = '1em';
            specialRouteHeading.style.fontSize = '1.2em'; specialRouteHeading.style.borderBottom = '1px solid #555';
            specialRouteHeading.style.paddingBottom = '0.4em'; specialRouteHeading.style.color = headingColor;
            specialRouteHeading.textContent = `Category: ${categoryName}`;
            specialRouteGroupDiv.appendChild(specialRouteHeading);

            let contentAddedForThisSpecialCategory = false;

            // Render 'applySchedule' tasks for this special category
            if (categoryApplyTasksByTime && Object.keys(categoryApplyTasksByTime).length > 0) {
                contentAddedForThisSpecialCategory = true;
                const applyUpdatesSubheading = document.createElement('h5'); /* ... */
                applyUpdatesSubheading.textContent = "Timetable Updates in this category:";
                applyUpdatesSubheading.style.color = "#DAF7A6"; applyUpdatesSubheading.style.fontSize = "1em"; applyUpdatesSubheading.style.marginBottom = "0.5em";
                specialRouteGroupDiv.appendChild(applyUpdatesSubheading);
                // ... (reuse batch rendering logic here, similar to above, passing categoryKey as routeName for display in messages)
                // For brevity, this detailed loop is omitted but would mirror the one for named routes.
                // Make sure to pass the correct tasks: categoryApplyTasksByTime[goLiveISO]
                 Object.keys(categoryApplyTasksByTime).sort((a,b) => new Date(a).getTime() - new Date(b).getTime()).forEach(goLiveISO => {
                    const batchOfTasks = categoryApplyTasksByTime[goLiveISO]; // These are tasks for UnspecifiedRoute/InvalidGoLiveTime for a specific goLiveISO
                    // ... The full batch rendering logic from above, adapted for these tasks ...
                    // You'll create batchContainerDiv, batchDetailsHTML, etc.
                    // The "Apply Batch" button might need to be re-thought for "Unspecified" or "Invalid" tasks,
                    // or it could try to apply them if they are otherwise valid.
                    // For now, let's just list them with their individual cancel buttons.

                    const batchContainerDiv = document.createElement('div');
                    batchContainerDiv.className = 'sru-batch-container subsection';
                    batchContainerDiv.style.marginLeft = "1em"; batchContainerDiv.style.marginBottom = "1rem";
                    batchContainerDiv.style.padding = "0.8rem"; batchContainerDiv.style.borderLeft = "4px solid #aaa"; // Greyer border

                    let batchDetailsHTML = `<h6 style="margin-top:0; margin-bottom:0.6em; font-size:1.0em; color: #ecf0f1;">Batch Go-Live: ${goLiveISO === "UnknownTime" ? "Unknown" : new Date(goLiveISO).toLocaleString()}</h6>`;
                    batchDetailsHTML += `<p style="font-size:0.85em; margin-bottom:0.5em;">Contains ${batchOfTasks.length} update(s). Review route names if "Unspecified".</p>`;
                    batchDetailsHTML += '<ul style="font-size:0.8em; padding-left:1.5em; margin-bottom:0.75em;">';
                    batchOfTasks.forEach(task => {
                        let taskStatusColor = task.status === 'pending' ? '#f1c40f' : (task.status && task.status.startsWith('applied') ? '#2ecc71' : (task.status === 'error' ? '#e74c3c' : '#bdc3c7'));
                        batchDetailsHTML += `<li style="margin-bottom:0.2em;">Route: ${task.routeName || 'N/A'}, P: ${task.operatingProfile || 'N/A'}, D: ${task.destinationName || 'N/A'} - ${task.scheduledEntries ? task.scheduledEntries.length : 0} entries. Status: <span style="color:${taskStatusColor}; font-weight:bold;">${task.status || 'N/A'}</span></li>`;
                    });
                    batchDetailsHTML += '</ul>';
                     batchContainerDiv.innerHTML = batchDetailsHTML; // Render details

                    const batchActionsDiv = document.createElement('div');
                    batchActionsDiv.style.marginTop = "0.5em";
                     batchOfTasks.forEach(task => { // Add cancel/delete record for individual tasks
                        if (task.status === 'pending' || task.status === 'error') {
                            const cancelTaskButton = document.createElement('button');
                            cancelTaskButton.className = 'button small-action neutral sru-cancel-task-btn';
                            cancelTaskButton.textContent = `Cancel Upd: (P: ${task.operatingProfile || 'N/A'}, D: ${task.destinationName || 'N/A'})`;
                            cancelTaskButton.style.marginLeft = "8px"; cancelTaskButton.style.fontSize = "0.75em";
                            cancelTaskButton.title = `Cancel only this specific update task: ${task.key}`;
                            cancelTaskButton.dataset.key = task.key; cancelTaskButton.dataset.taskType = 'applySchedule';
                            batchActionsDiv.appendChild(cancelTaskButton);
                        } else if (task.status && !task.status.startsWith('applied (batch)')) {
                            const deleteTaskRecordButton = document.createElement('button'); /* ... */
                            deleteTaskRecordButton.className = 'button small-action neutral sru-cancel-task-btn';
                            deleteTaskRecordButton.textContent = `Del.Rec: (P: ${task.operatingProfile || 'N/A'}, D: ${task.destinationName || 'N/A'})`;
                            deleteTaskRecordButton.style.marginLeft = "8px"; deleteTaskRecordButton.style.fontSize = "0.75em";
                            deleteTaskRecordButton.title = `Delete this task record: ${task.key}`;
                            deleteTaskRecordButton.dataset.key = task.key; deleteTaskRecordButton.dataset.taskType = 'applySchedule';
                            batchActionsDiv.appendChild(deleteTaskRecordButton);
                        }
                    });
                    batchContainerDiv.appendChild(batchActionsDiv); // Append actions
                    specialRouteGroupDiv.appendChild(batchContainerDiv);
                });
            }

            // Render 'deleteEntireRoute' tasks for this special category
            if (categoryDeleteTasksFiltered.length > 0) {
                contentAddedForThisSpecialCategory = true;
                const routeDeletionsSubheading = document.createElement('h5'); /* ... */
                routeDeletionsSubheading.textContent = "Scheduled Deletions in this category:";
                routeDeletionsSubheading.style.color = "#E74C3C";
                routeDeletionsSubheading.style.marginTop = (categoryApplyTasksByTime && Object.keys(categoryApplyTasksByTime).length > 0) ? "1.5em" : "0.5em";
                routeDeletionsSubheading.style.fontSize = "1em";
                specialRouteGroupDiv.appendChild(routeDeletionsSubheading);
                // ... (reuse delete task rendering logic here, similar to above)
                categoryDeleteTasksFiltered.forEach(task => {
                    // ... (create itemDiv, set details, add buttons for execute/cancel)
                    // Similar to the delete task rendering in the main loop
                    const itemDiv = document.createElement('div'); /* ... */
                    itemDiv.classList.add('subsection');
                    itemDiv.style.marginBottom = '0.75rem'; itemDiv.style.padding = '0.75rem';
                    itemDiv.style.marginLeft = "1em"; itemDiv.style.borderLeft = "4px solid #c0392b";
                    itemDiv.dataset.scheduleKey = task.key; itemDiv.dataset.taskType = 'deleteEntireRoute';
                     let statusColor; switch(task.status){ /*...*/ 
                        case 'pending': statusColor = '#f39c12'; break;
                        case 'applied': case 'applied (manual)': statusColor = '#2ecc71'; break;
                        case 'error': statusColor = '#e74c3c'; break;
                        case 'cancelled': statusColor = '#95a5a6'; break;
                        default: statusColor = '#ecf0f1';
                     }
                    let actionsHTML = ''; if(task.status === 'pending'){/*...*/} else if(task.status === 'error'){/*...*/} actionsHTML += `<button class="button small-action neutral sru-cancel-task-btn" data-key="${task.key}" data-task-type="deleteEntireRoute" style="margin-left:8px;">${(task.status === 'pending' || task.status === 'error') ? 'Cancel Task' : 'Delete Record'}</button>`;
                    itemDiv.innerHTML = `<h6 style="margin-top:0; margin-bottom:0.4em; font-size:1.0em; color: #e74c3c;">DELETE ENTIRE ROUTE (Go-Live: ${new Date(task.goLiveDateTime).toLocaleString()})</h6> ... (rest of details) ... <div class="scheduled-update-actions" style="margin-top:0.75em;">${actionsHTML}</div>`;
                    specialRouteGroupDiv.appendChild(itemDiv);
                });
            }
             if (!contentAddedForThisSpecialCategory) {
                const noTasksMsg = document.createElement('p');
                noTasksMsg.textContent = `(No tasks found in category: ${categoryName})`;
                noTasksMsg.style.fontSize = '0.85em'; noTasksMsg.style.opacity = '0.7';
                noTasksMsg.style.paddingLeft = '1em'; noTasksMsg.style.fontStyle = 'italic';
                specialRouteGroupDiv.appendChild(noTasksMsg);
            }
            listContainer.appendChild(specialRouteGroupDiv);
        }
    }
    renderSpecialCategoryTasks("Unspecified Route Name", "UnspecifiedRoute", applyTasksGroupedByRouteThenTime, allDeleteTasks, "#f39c12");
    renderSpecialCategoryTasks("Invalid Go-Live Time", "InvalidGoLiveTime", applyTasksGroupedByRouteThenTime, [], "#e74c3c");


    if (!anyContentRenderedOverall) {
        // This check is if after ALL processing (including specified and unspecified routes) nothing was rendered.
        listContainer.innerHTML = '<p style="text-align:center; opacity:0.8;">No scheduled tasks found to display.</p>';
    }

    // Re-attach all necessary event listeners
    listContainer.querySelectorAll('.sru-cancel-task-btn').forEach(btn => btn.addEventListener('click', (e) => {
        const taskKey = e.target.dataset.key;
        const taskType = e.target.dataset.taskType;
        if (taskKey && taskType) {
            handleCancelScheduledTask_ExtraPage(taskKey, taskType);
        } else {
             console.error("SRU Render: Missing taskKey or taskType for cancel button.", e.target);
             alert("Error: Could not determine task details for cancellation.");
        }
    }));
    
    listContainer.querySelectorAll('.sru-execute-deletion-btn').forEach(btn => btn.addEventListener('click', (e) => {
         const taskKey = e.target.dataset.key;
         if (typeof handleExecuteScheduledDeletion_ExtraPage === 'function') {
             handleExecuteScheduledDeletion_ExtraPage(taskKey);
         } else {
            alert("Error: Deletion execution function not found.");
         }
    }));
    // Listeners for '.sru-apply-batch-btn' are added when buttons are created.
}

        async function handleCancelScheduledTask_ExtraPage(taskKey, taskType) {
            if (!taskKey || !taskType) {
                alert("Error: Invalid task key or type for cancellation/deletion.");
                console.error("handleCancelScheduledTask_ExtraPage: Missing taskKey or taskType.");
                return;
            }

            let taskCollection;
            let firebasePath;
            let taskDescription = "";
            let userFriendlyTaskName = "";

            if (taskType === 'deleteEntireRoute') {
                taskCollection = scheduledRouteDeletions_extra;
                firebasePath = FB_PATH_SCHEDULED_DELETIONS;
                taskDescription = "route deletion task";
                userFriendlyTaskName = "Scheduled Route Deletion";
            } else if (taskType === 'applySchedule') { // Assuming 'applySchedule' is the other type
                taskCollection = scheduledRouteUpdates_extra;
                firebasePath = FB_PATH_SCHEDULED_ROUTE_UPDATES;
                taskDescription = "schedule application task";
                userFriendlyTaskName = "Scheduled Timetable Update";
            } else {
                alert(`Error: Unknown task type "${taskType}" for cancellation/deletion.`);
                console.error(`handleCancelScheduledTask_ExtraPage: Unknown task type "${taskType}".`);
                return;
            }

            if (!taskCollection || !taskCollection[taskKey]) {
                alert(`Error: Task with key "${taskKey}" not found for type "${userFriendlyTaskName}". It might have already been processed or deleted. Please refresh the list.`);
                console.warn(`Task ${taskKey} of type ${taskType} not found in local cache:`, taskCollection);
                // Optionally, directly try to remove from Firebase if local cache is stale,
                // or just rely on refresh. For now, prompt refresh.
                loadAndDisplayScheduledUpdates_ExtraPage(); // Refresh to sync state
                return;
            }

            const taskToCancel = taskCollection[taskKey];
            const routeNameForConfirm = taskToCancel.routeName || "Unknown Route";
            const goLiveForConfirm = taskToCancel.goLiveDateTime ? new Date(taskToCancel.goLiveDateTime).toLocaleString() : "Unknown Go-Live";

            let actionVerb = "DELETE RECORD of"; // Default for already applied/cancelled tasks
            if (taskToCancel.status === 'pending' || taskToCancel.status === 'error') {
                actionVerb = "CANCEL and DELETE record of";
            }

            if (!confirm(`Are you sure you want to ${actionVerb} the ${taskDescription} for route "${routeNameForConfirm}" (Go-Live: ${goLiveForConfirm})? This action cannot be undone.`)) {
                return;
            }

            const { database, dbRemove, dbRef } = window.firebaseOMSI;
            if (!database || !dbRemove || !dbRef) {
                alert("Firebase components not available. Cannot delete task.");
                console.error("handleCancelScheduledTask_ExtraPage: Firebase components missing.");
                return;
            }

            try {
                // Attempt to remove from Firebase
                await dbRemove(dbRef(database, `${firebasePath}/${taskKey}`));
                console.log(`Successfully removed task from Firebase: ${firebasePath}/${taskKey}`);

                // Remove from the correct local cache after successful Firebase deletion
                if (taskCollection && taskCollection[taskKey]) {
                    delete taskCollection[taskKey];
                }

                // Update UI - either directly manipulate the item or just refresh the whole list
                const listItemElement = document.querySelector(`.subsection[data-schedule-key="${taskKey}"]`);
                if (listItemElement) {
                    listItemElement.style.transition = 'opacity 0.5s ease-out';
                    listItemElement.style.opacity = '0';
                    setTimeout(() => {
                        listItemElement.remove();
                        // If the list becomes empty, show "No tasks" message
                        const listContainer = document.getElementById('sru-updates-list-container-extra');
                        if (listContainer && listContainer.children.length === 0) {
                            listContainer.innerHTML = '<p style="text-align:center; opacity:0.8;">No tasks currently scheduled.</p>';
                        }
                    }, 500);
                     // Optionally, show a temporary global status message
                    if (rsgStatusMessage_el_extra) { // Using RSG status for general messages if available
                        rsgStatusMessage_el_extra.textContent = `Task record for "${routeNameForConfirm}" deleted.`;
                        rsgStatusMessage_el_extra.style.color = "#2ecc71"; // Green for success
                        setTimeout(() => { if (rsgStatusMessage_el_extra.textContent === `Task record for "${routeNameForConfirm}" deleted.`) rsgStatusMessage_el_extra.textContent = ''; }, 3000);
                    } else {
                        alert(`Task record for "${routeNameForConfirm}" deleted.`);
                    }

                } else {
                    // If the element wasn't found (e.g., list re-rendered), refresh the whole list
                    loadAndDisplayScheduledUpdates_ExtraPage();
                }
                    checkAndDisplayDueUpdatesNotification_ExtraPage();

            } catch (error) {
                console.error(`Error deleting scheduled ${taskDescription} (key: ${taskKey}):`, error);
                alert(`Error deleting task record: ${error.message}. Please try refreshing the list.`);
                // Refresh the list on error to ensure UI consistency with backend state
                loadAndDisplayScheduledUpdates_ExtraPage();
            }
        }

        async function handleApplyScheduledRouteBatch_ExtraPage(tasksInBatch) {
    if (!currentUser_extra) {
        alert("Please log in to apply batch updates.");
        return;
    }
    if (!tasksInBatch || tasksInBatch.length === 0) {
        alert("No tasks provided for batch application.");
        return;
    }

    const representativeTask = tasksInBatch[0];
    const targetRouteName = representativeTask.routeName.toUpperCase();
    const goLiveDateTimeForDisplay = new Date(representativeTask.goLiveDateTime).toLocaleString();

    let allNewEntriesForRoute = [];
    let involvedProfiles = new Set();
    let involvedDestinations = new Set();
    let taskKeysInBatch = [];

    tasksInBatch.forEach(task => {
        if ((task.taskTypeDisplay === 'applySchedule' || task.taskType === 'applySchedule') && task.routeName.toUpperCase() === targetRouteName) {
            if (task.scheduledEntries && task.scheduledEntries.length > 0) {
                allNewEntriesForRoute.push(...JSON.parse(JSON.stringify(task.scheduledEntries)));
                involvedProfiles.add(task.operatingProfile);
                involvedDestinations.add(task.destinationName);
            }
            if (task.key) {
                taskKeysInBatch.push(task.key);
            } else {
                console.warn("DEBUG: A task in tasksInBatch is missing a 'key' property:", task);
            }
        }
    });

    if (allNewEntriesForRoute.length === 0) {
        alert(`No actual schedule entries found within the selected batch for Route "${targetRouteName}". Cannot apply.`);
        return;
    }

    const profileList = Array.from(involvedProfiles).join(', ') || "N/A";
    const destList = Array.from(involvedDestinations).join(', ') || "N/A";

    const confirmMessage = `Apply BATCH update for Route: ${targetRouteName}\n` +
                         `Go-Live: ${goLiveDateTimeForDisplay}\n\n` +
                         `This batch includes ${tasksInBatch.length} update(s) which will define the following for this route:\n` +
                         `Operating Profile(s): ${profileList}\n` +
                         `Destination(s): ${destList}\n\n` +
                         `WARNING: This will DELETE ALL existing schedules for the ENTIRE Route "${targetRouteName}" (across all its current profiles and destinations).\n` +
                         `Then, ${allNewEntriesForRoute.length} new entries from this batch will be added, forming the new complete schedule for this route.\n\n` +
                         `Proceed with wiping the whole route and applying this batch?`;

    if (!confirm(confirmMessage)) {
        alert("Batch application cancelled by user.");
        return;
    }

    if (rsgStatusMessage_el_extra) {
        rsgStatusMessage_el_extra.textContent = `Processing batch for Route ${targetRouteName}... This may take a moment.`;
        rsgStatusMessage_el_extra.style.color = "#3498db";
    }

    // Ensure 'dbUpdate' is correctly destructured if it's the alias for SDK's 'update'
    const { database, dbRef, dbUpdate } = window.firebaseOMSI; 
    let removedCount = 0;

    currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
        const matchesRouteOnly = entry.lineName && entry.lineName.toUpperCase() === targetRouteName;
        if (matchesRouteOnly) {
            removedCount++;
            return false;
        }
        return true;
    });
    console.log(`Batch Apply: Removed ${removedCount} existing entries for Route "${targetRouteName}".`);

    const entriesToAddWithUniqueIds = allNewEntriesForRoute.map((e, idx) => ({
        ...e,
        internalId: e.internalId || `${e.stopID}_${e.lineName}_${(e.scheduledTime||"0000").replace(':','')}_batchApply_${Date.now()}_${idx}`
    }));
    currentWorkingSchedule_extra.push(...entriesToAddWithUniqueIds);
    console.log(`Batch Apply: Added ${entriesToAddWithUniqueIds.length} new entries for Route "${targetRouteName}".`);

    try {
        await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
        console.log(`Batch Apply: Main schedule rebuilt and saved to Firebase for Route "${targetRouteName}".`);

        const appliedAtTimestamp = new Date().toISOString();
        const appliedByEmail = currentUser_extra ? currentUser_extra.email : "system (batch)";

        console.log("DEBUG: Attempting INDIVIDUAL updates to task statuses...");
        let individualUpdateSuccessCount = 0;
        let individualUpdateFailureCount = 0;

        if (taskKeysInBatch.length > 0) {
            console.log("DEBUG: Task keys being processed for status update:", JSON.stringify(taskKeysInBatch));
        } else {
            console.warn("DEBUG: taskKeysInBatch is empty. No statuses to update.");
        }
        
        for (const taskKey of taskKeysInBatch) {
            if (!taskKey || typeof taskKey !== 'string' || taskKey.trim() === "") {
                console.error("DEBUG: Invalid or empty taskKey found in taskKeysInBatch, skipping update for this key:", taskKey);
                individualUpdateFailureCount++;
                continue;
            }

            const taskNodeRef = dbRef(database, `${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`);
            const updatesForThisIndividualTask = {
                status: 'applied (batch)__DEBUG_INDIVIDUAL', 
                appliedAt: appliedAtTimestamp,             
                appliedBy: appliedByEmail                  
            };

            console.log(`DEBUG: Attempting to update task ${taskKey} at path ${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey} with:`, JSON.stringify(updatesForThisIndividualTask));

            try {
                // ***** THIS IS THE CORRECTED LINE *****
                await dbUpdate(taskNodeRef, updatesForThisIndividualTask); 
                // ***** END OF CORRECTION *****
                console.log(`DEBUG: Successfully sent update for task: ${taskKey}`);
                individualUpdateSuccessCount++;
            } catch (e) {
                console.error(`DEBUG: Error updating status for task ${taskKey} individually:`, e); // This will now catch actual Firebase errors
                individualUpdateFailureCount++;
            }
        }
        console.log(`DEBUG: Individual updates attempted. Successes: ${individualUpdateSuccessCount}, Failures: ${individualUpdateFailureCount} out of ${taskKeysInBatch.length} tasks.`);

        loadAndDisplayScheduledUpdates_ExtraPage();
        renderUIDependentElements_ExtraPage();

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Batch update for Route ${targetRouteName} applied successfully. Live schedule updated. Status update attempts: ${individualUpdateSuccessCount} success, ${individualUpdateFailureCount} fail.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
            setTimeout(() => { if (rsgStatusMessage_el_extra.textContent && rsgStatusMessage_el_extra.textContent.includes(`Batch update for Route ${targetRouteName}`)) rsgStatusMessage_el_extra.textContent = ''; }, 7000);
        } else {
            alert(`Batch update for Route ${targetRouteName} applied successfully. Live schedule updated. Status update attempts: ${individualUpdateSuccessCount} success, ${individualUpdateFailureCount} fail.`);
        }

    } catch (error) {
        console.error("Error applying scheduled batch update (main schedule part):", error);
        alert(`Error applying batch update for Route "${targetRouteName}": ${error.message}. The live schedule may be in an inconsistent state. Review carefully.`);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Error applying batch for Route ${targetRouteName}: ${error.message}`;
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        
        taskKeysInBatch.forEach(taskKey => {
            if (taskKey && typeof taskKey === 'string' && taskKey.trim() !== "") {
                const taskErrorPath = `${FB_PATH_SCHEDULED_ROUTE_UPDATES}/${taskKey}`;
                const errorUpdatesForThisTask = {
                    status: 'error',
                    lastError: `Batch Apply Error (Main Schedule): ${error.message}` // Updated error source
                };
                dbUpdate(dbRef(database, taskErrorPath), errorUpdatesForThisTask) // Using dbUpdate here as well
                    .then(() => console.log(`DEBUG: Marked task ${taskKey} as error in Firebase due to main schedule failure.`))
                    .catch(err => console.error(`DEBUG: Failed to mark task ${taskKey} as error:`, err));
            }
        });
        loadAndDisplayScheduledUpdates_ExtraPage(); 
    }
}

        // ++ RSG Copy From Another Route Modal Functions ++
        function rsg_openCopyFromModal_ExtraPage() { 
            if (!rsgCopyModal_el_extra || !rsgCopySourceRouteNameSelect_el_extra || !rsgCopySourceDestNameSelect_el_extra || !rsgCopyModalStatus_el_extra) return; const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))].filter(Boolean).sort(compareLineNames_ExtraPage); rsgCopySourceRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route --</option>'; uniqueRoutes.forEach(route => { const opt = document.createElement('option'); opt.value = route; opt.textContent = route; rsgCopySourceRouteNameSelect_el_extra.appendChild(opt); }); if(rsgCopySourceRouteNameInput_el_extra) rsgCopySourceRouteNameInput_el_extra.value = ''; if(rsgCopySourceOpProfileInput_el_extra) rsgCopySourceOpProfileInput_el_extra.value = ''; if(rsgCopySourceDestNameInput_el_extra) rsgCopySourceDestNameInput_el_extra.value = ''; rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route First --</option>'; rsgCopyModalStatus_el_extra.textContent = ''; rsgCopyModal_el_extra.style.display = 'flex';
        }
        function rsg_closeCopyFromModal_ExtraPage() { 
             if (rsgCopyModal_el_extra) rsgCopyModal_el_extra.style.display = 'none';
        }
        function rsg_populateCopySourceDestinationSelect_ExtraPage() { 
            if (!rsgCopySourceDestNameSelect_el_extra || !rsgCopySourceDestNameInput_el_extra || !rsgCopySourceRouteNameInput_el_extra) return; const selectedRoute = rsgCopySourceRouteNameInput_el_extra.value.trim().toUpperCase(); rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Destination --</option>'; if (!selectedRoute) { rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route First --</option>'; return; } const uniqueDestinations = [...new Set(currentWorkingSchedule_extra.filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName).map(e => e.destinationName))].sort(); if (uniqueDestinations.length > 0) { uniqueDestinations.forEach(dest => { const opt = document.createElement('option'); opt.value = dest; opt.textContent = dest; rsgCopySourceDestNameSelect_el_extra.appendChild(opt); }); } else { rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- No Destinations for this Route --</option>';}
        }
        async function rsg_handleCopyDataFromSource_ExtraPage() {
    if (!rsgCopySourceRouteNameInput_el_extra || !rsgCopySourceOpProfileInput_el_extra || !rsgCopySourceDestNameInput_el_extra || !rsgCopyModalStatus_el_extra || !window.firebaseOMSI) {
        if (rsgCopyModalStatus_el_extra) {
            rsgCopyModalStatus_el_extra.textContent = "Error: Required elements for copy are missing.";
            rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
        }
        return;
    }
    const sourceRouteName = rsgCopySourceRouteNameInput_el_extra.value.trim();
    const sourceOpProfile = rsgCopySourceOpProfileInput_el_extra.value.trim();
    const sourceDestName = rsgCopySourceDestNameInput_el_extra.value.trim();

    if (!sourceRouteName || !sourceOpProfile || !sourceDestName) {
        rsgCopyModalStatus_el_extra.textContent = "All source fields (Route, Operating Profile, Destination) are required.";
        rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
        return;
    }

    rsgCopyModalStatus_el_extra.textContent = "Fetching source data...";
    rsgCopyModalStatus_el_extra.style.color = "#f1c40f";

    let sourceConfigData = null;
    let sourceStopSequence = [];
    let sourceFirstStopTimes = "";

    const sourceConfigKey = rsg_createConfigKey_ExtraPage(sourceRouteName, sourceOpProfile, sourceDestName);

    if (rsg_loadedConfigs_extra && rsg_loadedConfigs_extra[sourceConfigKey]) {
        sourceConfigData = rsg_loadedConfigs_extra[sourceConfigKey];
    } else {
        const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
        try {
            const snapshot = await dbGet(dbChild(dbRef(database), `${FB_PATH_RSG_CONFIGS}/${sourceConfigKey}`));
            if (snapshot.exists()) {
                sourceConfigData = snapshot.val();
            }
        } catch (error) {
            console.error("Error fetching source RSG configuration for copy:", error);
            rsgCopyModalStatus_el_extra.textContent = "Error fetching source configuration: " + error.message;
            rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
            return;
        }
    }

    if (sourceConfigData) {
        sourceStopSequence = sourceConfigData.stopSequence || [];
        sourceFirstStopTimes = sourceConfigData.firstStopTimes || "";
    } else {
        const sourceRouteNameUpper = sourceRouteName.toUpperCase();
        const relevantEntries = currentWorkingSchedule_extra.filter(entry =>
            entry.lineName && entry.lineName.toUpperCase() === sourceRouteNameUpper &&
            entry.OperatingProfile === sourceOpProfile &&
            entry.destinationName === sourceDestName
        );

        if (relevantEntries.length > 0) {
            relevantEntries.sort((a, b) => {
                const dayOffsetA = parseInt(a.DayOffset || 0);
                const dayOffsetB = parseInt(b.DayOffset || 0);
                if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;
                const timeA = (a.scheduledTime || "99:99").replace(':', '');
                const timeB = (b.scheduledTime || "99:99").replace(':', '');
                return timeA.localeCompare(timeB);
            });
            
            const firstTripSequence = [];
            if (relevantEntries.length > 0) {
                const firstStopIDOfJourney = relevantEntries[0].stopID;
                let previousStopTimeAbs = -1;
                const MIN_STOPS_HEURISTIC_FOR_COPY_BREAK = 3;

                for (let i = 0; i < relevantEntries.length; i++) {
                    const entry = relevantEntries[i];
                    if (!entry.stopID || !entry.scheduledTime) continue;
                    const currentTimeAbs = (parseInt(entry.DayOffset || 0) * 1440) + parseInt(entry.scheduledTime.split(':')[0]) * 60 + parseInt(entry.scheduledTime.split(':')[1]);

                    if (i > 0) {
                        if (currentTimeAbs < previousStopTimeAbs) break; 
                        if (entry.stopID === firstStopIDOfJourney && firstTripSequence.length >= MIN_STOPS_HEURISTIC_FOR_COPY_BREAK) break; 
                    }
                    firstTripSequence.push({ stopID: entry.stopID, stopName: entry.stopName, direction: entry.direction, timeAdjustment: (i > 0 ? 2 : 0) }); 
                    previousStopTimeAbs = currentTimeAbs;
                }
            }
            sourceStopSequence = firstTripSequence;

            if (sourceStopSequence.length > 0) {
                const firstStopIdInPulledSequence = sourceStopSequence[0].stopID;
                const departuresForFirstStop = [...new Set(
                    relevantEntries
                        .filter(e => e.stopID === firstStopIdInPulledSequence)
                        .map(e => e.scheduledTime)
                )].sort();
                sourceFirstStopTimes = departuresForFirstStop.join(', ');
            }
        }
    }

    if (sourceStopSequence.length > 0) {
        rsg_selectedStops_extra = JSON.parse(JSON.stringify(sourceStopSequence));
        if (rsgFirstStopTimesInput_el_extra) rsgFirstStopTimesInput_el_extra.value = sourceFirstStopTimes;
        
        rsg_renderStopSequence_ExtraPage();

        rsg_lastLoadedRouteName_extra = rsgRouteNameInput_el_extra.value.trim();
        rsg_lastLoadedDestName_extra = rsgDestinationNameInput_el_extra.value.trim();   
        rsg_lastLoadedOpProfile_extra = rsg_getSelectedOpProfilesString_ExtraPage() || sourceOpProfile;

        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `Stops and timings copied from ${sourceRouteName} (Profile: ${sourceOpProfile}, Dest: ${sourceDestName}). Main form context updated.`;
            rsgStatusMessage_el_extra.style.color = "#2ecc71";
        }
        rsg_resetPreviewState("Data copied. Regenerate preview if needed.", "info");
        rsg_closeCopyFromModal_ExtraPage();
    } else {
        rsgCopyModalStatus_el_extra.textContent = `No sequence data found for source: ${sourceRouteName} (Profile: ${sourceOpProfile}, Dest: ${sourceDestName}).`;
        rsgCopyModalStatus_el_extra.style.color = "#e74c3c";
    }
}

        function showExtraPageSection(sectionId) {
            console.log('[MENU] Button clicked. Attempting to show section:', sectionId);

            if (!toolSectionsWrapper_el_extra) {
                console.error('[MENU] ERROR: toolSectionsWrapper_el_extra is null or undefined!');
                return;
            }

            const allSections = toolSectionsWrapper_el_extra.querySelectorAll('.tool-content-section');
            allSections.forEach(s => {
                s.style.display = 'none';
            });

            const sectionToShow = document.getElementById(sectionId);
            if (sectionToShow) {
                sectionToShow.style.display = 'block';
                localStorage.setItem('omsiExtraToolsActiveSection', sectionId);

                // --- Section Specific Load/Refresh Logic ---
                if (sectionId === 'day-profile-override-section_extra') {
                    loadAndDisplayOverrides_ExtraPage();
                    dpo_populateProfileCheckboxes_ExtraPage();
                    updateSelectedDateInfo_ExtraPage();
                } else if (sectionId === 'stop-manager-tool-section_extra') {
                    populateMasterStopList_ExtraPage();
                    if (inputNewStopName_el_extra && inputNewStopId_el_extra && !inputNewStopName_el_extra.value && !inputNewStopId_el_extra.value) {
                        autoGenerateAndSetNewStopId_ExtraPage();
                    }
                    if(duplicateStopsByNameDirResults_el_extra) duplicateStopsByNameDirResults_el_extra.innerHTML = 'Click "Find Duplicates (Name/Dir)" to check.';
                } else if (sectionId === 'global-route-deletion-section_extra') {
                    populateGlobalRouteToDeleteList_ExtraPage();
                } else if (sectionId === 'route-schedule-generator-section_extra') {
                    rsg_populateProfileCheckboxes_ExtraPage(); 
                    rsg_populateRouteSelect_ExtraPage(); 
                    
                    // *** ADD THIS LINE START ***
                    if (typeof rsg_renderSavedConfigsList_ExtraPage === 'function') {
                        rsg_renderSavedConfigsList_ExtraPage(); 
                    }
                    // *** ADD THIS LINE END ***

                    if (typeof rsg_loadOrPullConfiguration_ExtraPage === 'function') {
                         rsg_loadOrPullConfiguration_ExtraPage();
                    }
                } else if (sectionId === 'route-profile-deletion-section_extra') {
                    rpd_populateRouteSelect_ExtraPage();
                } else if (sectionId === "service-analyzer-section_extra") {
                    onShowServiceAnalyzerSection_ExtraPage();
                } else if (sectionId === 'timetable-exporter-section_extra') {
                    populateTimetableExporterRouteSelect_ExtraPage();
                    if (tteRouteNameInput_el_extra) tteRouteNameInput_el_extra.value = '';
                    if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = 'Select a route to download its timetable.';
                } else if (sectionId === 'scheduled-route-updates-section_extra') {
                    loadAndDisplayScheduledUpdates_ExtraPage();
                } else if (sectionId === 'scheduled-route-deletion-section_extra') { 
                    srd_populateRouteSelect_ExtraPage(); 
                    if (srdGoLiveDateTimeInput_el_extra) srdGoLiveDateTimeInput_el_extra.value = ''; 
                    if (srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = 'Select a route and future date/time for deletion.'; 
                }
                // --- End Section Specific Load/Refresh Logic ---

            } else {
                console.warn("[MENU] showExtraPageSection: Could not find section with ID:", sectionId);
            }
        }

        function updateAuthUI_ExtraPage(user) { 
            currentUser_extra = user; if (user) { if(authSection_el_extra) authSection_el_extra.style.display = 'none'; if(topMenuBar_el_extra) topMenuBar_el_extra.style.display = 'block'; if(logoutContainer_el_extra) logoutContainer_el_extra.style.display = 'block'; if(loginFormContainer_el_extra) loginFormContainer_el_extra.style.display = 'none'; if(authStatus_el_extra) authStatus_el_extra.textContent = ''; if(loggedInUserEmailDisplay_el_extra) loggedInUserEmailDisplay_el_extra.textContent = user.email; if(currentProfileDisplayContainer_el) currentProfileDisplayContainer_el.style.display = 'block'; loadInitialData_ExtraPage(); const lastSection = localStorage.getItem('omsiExtraToolsActiveSection'); const firstButton = topMenuBar_el_extra.querySelector('.menu-button'); if (lastSection && document.getElementById(lastSection) && Array.from(topMenuBar_el_extra.querySelectorAll('.menu-button')).some(b => b.dataset.section === lastSection) ) showExtraPageSection(lastSection); else if (firstButton && firstButton.dataset.section) showExtraPageSection(firstButton.dataset.section); } else { if(authSection_el_extra) authSection_el_extra.style.display = 'block'; if(topMenuBar_el_extra) topMenuBar_el_extra.style.display = 'none'; if(logoutContainer_el_extra) logoutContainer_el_extra.style.display = 'none'; if(loginFormContainer_el_extra) loginFormContainer_el_extra.style.display = 'block'; if(authStatus_el_extra) authStatus_el_extra.textContent = 'Please log in.'; if(loggedInUserEmailDisplay_el_extra) loggedInUserEmailDisplay_el_extra.textContent = ''; if(currentProfileDisplayContainer_el) currentProfileDisplayContainer_el.style.display = 'none'; if(toolSectionsWrapper_el_extra) toolSectionsWrapper_el_extra.querySelectorAll('.tool-content-section').forEach(s => s.style.display = 'none'); currentWorkingSchedule_extra = []; closedStopIDs_extra = []; globalCustomRouteColours_extra = {}; stopSpecificRouteColours_extra = {}; pageSpecificSettings = {}; rsg_loadedConfigs_extra = {}; rsg_lastLoadedRouteName_extra = null; rsg_lastLoadedDestName_extra = null; rsg_lastLoadedOpProfile_extra = null; renderUIDependentElements_ExtraPage(); }
        }
        
async function loadInitialData_ExtraPage() {
            let msg = "Loading data for Extra Modules (enhanced for all stops)...";
            console.log(msg);

            currentWorkingSchedule_extra = [];
            closedStopIDs_extra = [];
            globalCustomRouteColours_extra = {};
            stopSpecificRouteColours_extra = {};
            rsg_loadedConfigs_extra = {};
            if (typeof scheduledRouteDeletions_extra === 'undefined') {
                scheduledRouteDeletions_extra = {};
            }
            if (typeof scheduledRouteUpdates_extra === 'undefined') {
                scheduledRouteUpdates_extra = {};
            }

            if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
                msg = "Firebase not connected for Extra Modules.";
                console.error(msg);
                renderUIDependentElements_ExtraPage();
                return;
            }

            const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
            try {
                const scheduleSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULES_BY_ROUTE));
                const flatScheduleFromDB = [];
                if (scheduleSnap.exists()) {
                    const schedulesByRoute = scheduleSnap.val();
                    for (const routeKey in schedulesByRoute) {
                        const routeData = schedulesByRoute[routeKey];
                        for (const profileKey in routeData) {
                            const profileData = routeData[profileKey];
                            for (const destKey in profileData) {
                                const destData = profileData[destKey];
                                if (destData && Array.isArray(destData.entries)) {
                                    destData.entries.forEach(entry => {
                                        flatScheduleFromDB.push({ ...entry });
                                    });
                                }
                            }
                        }
                    }
                }
                currentWorkingSchedule_extra = flatScheduleFromDB.map((e,i)=>({...e, internalId: e.internalId || `${(e.stopID||'s')}_${(e.lineName||'l')}_${(e.scheduledTime||"").replace(':','')}_${i}_fbloadX_flat`}));
                console.log(`Extra Tools: Loaded ${currentWorkingSchedule_extra.length} entries from structured schedule data (schedulesByRoute).`);

                const uniqueStopsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_UNIQUE_STOPS));
                const firebaseUniqueStops = uniqueStopsSnap.exists() && Array.isArray(uniqueStopsSnap.val()) ? uniqueStopsSnap.val() : [];
                console.log(`Extra Tools: Fetched ${firebaseUniqueStops.length} stops from uniqueBusStops list.`);

                const stopIDsAlreadyInScheduleFromRoutes = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase()));

                firebaseUniqueStops.forEach(fbStop => {
                    if (fbStop && fbStop.stopID && !stopIDsAlreadyInScheduleFromRoutes.has(fbStop.stopID.toUpperCase())) {
                        currentWorkingSchedule_extra.push({
                            internalId: `${fbStop.stopID}_definition_fbloadX_${Date.now()}`,
                            stopID: fbStop.stopID,
                            stopName: fbStop.stopName || "Unknown Stop Name",
                            direction: fbStop.direction || ""
                        });
                        // console.log(`Extra Tools: Added definition for stop ${fbStop.stopID} (from uniqueBusStops) to local working schedule.`); // Optional log
                    }
                });

                // --- START: Populate stopToServingRoutesMap_extra ---
                console.log("Pre-calculating stop to serving routes map...");
                stopToServingRoutesMap_extra.clear();
                currentWorkingSchedule_extra.forEach(entry => {
                    if (entry.stopID && entry.lineName && entry.lineName.trim() !== "") {
                        if (!stopToServingRoutesMap_extra.has(entry.stopID)) {
                            stopToServingRoutesMap_extra.set(entry.stopID, new Set());
                        }
                        stopToServingRoutesMap_extra.get(entry.stopID).add(entry.lineName);
                    }
                });
                console.log(`Stop to serving routes map calculated. ${stopToServingRoutesMap_extra.size} stops mapped.`);
                // --- END: Populate stopToServingRoutesMap_extra ---

                const closedSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_CLOSED_STOPS));
                if (closedSnap.exists()) {
                    const fbC = closedSnap.val();
                    closedStopIDs_extra = Object.keys(fbC).filter(id => fbC[id] === true).map(id => id.toUpperCase());
                } else {
                    closedStopIDs_extra = [];
                }

                const globalCSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS));
                globalCustomRouteColours_extra = globalCSnap.exists() ? globalCSnap.val() || {} : {};

                const stopSpecificCSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS));
                stopSpecificRouteColours_extra = stopSpecificCSnap.exists() ? stopSpecificCSnap.val() || {} : {};

                const rsgConfigsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_RSG_CONFIGS));
                rsg_loadedConfigs_extra = rsgConfigsSnap.exists() ? rsgConfigsSnap.val() || {} : {};
                
                msg = `Extra Modules: Data loaded. Working schedule has ${currentWorkingSchedule_extra.length} items. ${closedStopIDs_extra.length} closed. ${Object.keys(rsg_loadedConfigs_extra).length} RSG configs.`;
            } catch (error) {
                console.error("Firebase Load Error (Extra Tools):", error);
                msg = "Error loading data (Extra Tools): " + error.message;
                currentWorkingSchedule_extra = [];
                closedStopIDs_extra = [];
                globalCustomRouteColours_extra = {};
                stopSpecificRouteColours_extra = {};
                rsg_loadedConfigs_extra = {};
                scheduledRouteUpdates_extra = {};
                scheduledRouteDeletions_extra = {};
                stopToServingRoutesMap_extra.clear(); // Clear map on error too
            }
            
            console.log(msg);

            if (typeof fetchBankHolidays_ExtraPage === 'function') {
                await fetchBankHolidays_ExtraPage(); // Await completion
            }
            
            // updateCurrentProfileDisplay_ExtraPage is called after bank holidays are potentially fetched
            if (typeof updateCurrentProfileDisplay_ExtraPage === 'function') {
                await updateCurrentProfileDisplay_ExtraPage();
            }
            
            // renderUIDependentElements_ExtraPage is called last to update UI with all loaded data
            renderUIDependentElements_ExtraPage();
            
            // *** ADD THIS LINE ***
            checkAndDisplayDueUpdatesNotification_ExtraPage(); 
        }

        function renderUIDependentElements_ExtraPage() { 
            const activeSectionId = localStorage.getItem('omsiExtraToolsActiveSection'); 
            const activeSectionElement = activeSectionId ? document.getElementById(activeSectionId) : null; 
            if (activeSectionElement && activeSectionElement.style.display === 'block') { 
                 showExtraPageSection(activeSectionId); // Re-run the show function to refresh content
            } else if (!activeSectionId && topMenuBar_el_extra && topMenuBar_el_extra.querySelector('.menu-button')) { 
                // If no active section is stored or visible, attempt to show the first one if user is logged in
                 if(currentUser_extra) {
                    const firstButton = topMenuBar_el_extra.querySelector('.menu-button');
                    if (firstButton && firstButton.dataset.section) {
                         showExtraPageSection(firstButton.dataset.section);
                    }
                }
            } 
        }

        // --- DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', () => { 
            console.log("OMSI Tools Extra DOMContentLoaded"); updateAuthUI_ExtraPage(null); 

            function initializeExtraAppLogic() { 
                console.log("Firebase ready, Extra app logic init."); 
                const { auth, authOnAuthStateChanged, authSignInWithEmailAndPassword, authSignOut } = window.firebaseOMSI; 
                authOnAuthStateChanged(auth, user => { updateAuthUI_ExtraPage(user); if (user && selectNewStopIdFormat_el_extra && inputNewStopName_el_extra && inputNewStopId_el_extra && !inputNewStopName_el_extra.value && !inputNewStopId_el_extra.value) { autoGenerateAndSetNewStopId_ExtraPage(); } }); 
                if (adminLoginForm_el_extra && inputEmail_el_extra && inputPassword_el_extra && authStatus_el_extra) { adminLoginForm_el_extra.addEventListener('submit', (e) => { e.preventDefault(); authStatus_el_extra.textContent = 'Logging in...'; authSignInWithEmailAndPassword(auth, inputEmail_el_extra.value, inputPassword_el_extra.value) .catch(err => { authStatus_el_extra.textContent = `Login Error: ${err.message}`; }); }); } 
                const logoutButton = logoutContainer_el_extra.querySelector('button'); 
                if (logoutButton) logoutButton.addEventListener('click', () => { localStorage.removeItem('omsiExtraToolsActiveSection'); authSignOut(auth).catch(e => console.error("Sign-out error (Extra):", e)); }); 
            } 

const dpoClearProfilesBtn = document.getElementById('dpo-clear-profile-checkboxes-button-extra');
if (dpoClearProfilesBtn) {
    dpoClearProfilesBtn.addEventListener('click', dpo_clearProfileSelections_ExtraPage);
}

if (rsgFirstStopTimesInput_el_extra) {
                rsgFirstStopTimesInput_el_extra.addEventListener('input', () => { 
                    rsg_isDirty = true; 
                    console.log(`RSG User Edit: First stop times input changed. rsg_isDirty is true. Value: "${rsgFirstStopTimesInput_el_extra.value}"`);
                });
            }

// ... (other listeners) ...

            if (rsgFirstStopTimesInput_el_extra) {
                rsgFirstStopTimesInput_el_extra.addEventListener('input', () => { 
                    rsg_isDirty = true; 
                    console.log(`RSG User Edit: First stop times input changed. rsg_isDirty is true. Value: "${rsgFirstStopTimesInput_el_extra.value}"`);
                });

                // <<< ADD THE NEW 'keydown' LISTENER HERE >>>
                rsgFirstStopTimesInput_el_extra.addEventListener('keydown', function(event) {
                    if (event.key === 'Tab') {
                        event.preventDefault(); // Prevent focusing the next element

                        // Get current cursor position
                        let start = this.selectionStart;
                        let end = this.selectionEnd;

                        // Insert tab character
                        this.value = this.value.substring(0, start) + '\t' + this.value.substring(end);

                        // Put cursor back in the right position
                        this.selectionStart = this.selectionEnd = start + 1;
                        
                        // Manually trigger the input event
                        const inputEvent = new Event('input', { bubbles: true, cancelable: true });
                        this.dispatchEvent(inputEvent);
                        
                        console.log(`RSG User Edit: Tab key pressed in first stop times. rsg_isDirty should be true via input event.`);
                    }
                });
            }

            // ... (rest of the DOMContentLoaded listeners) ...

// Inside DOMContentLoaded, where other listeners are set up

if (srdRouteNameSelect_el_extra && srdRouteNameInput_el_extra) {
    srdRouteNameSelect_el_extra.addEventListener('change', () => {
        if (srdRouteNameInput_el_extra) {
            srdRouteNameInput_el_extra.value = srdRouteNameSelect_el_extra.value;
        }
        if (srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = '';
    });
    srdRouteNameInput_el_extra.addEventListener('input', () => {
        const typedValue = srdRouteNameInput_el_extra.value.trim().toUpperCase();
        let matchedSelectValue = "";
        if (srdRouteNameSelect_el_extra) {
            const matchedOption = Array.from(srdRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedValue);
            if (matchedOption) {
                matchedSelectValue = matchedOption.value;
            }
            if (srdRouteNameSelect_el_extra.value !== matchedSelectValue) {
                 srdRouteNameSelect_el_extra.value = matchedSelectValue;
            }
        }
        if (srdStatusMessage_el_extra) srdStatusMessage_el_extra.textContent = '';
    });
}
if (srdScheduleDeletionButton_el_extra) {
    srdScheduleDeletionButton_el_extra.addEventListener('click', srd_confirmAndScheduleDeletion_ExtraPage);
}

// Scheduled Route Updates (SRU) Listeners
            const sruRefreshButton = document.getElementById('sru-refresh-list-button-extra');
            if (sruRefreshButton) {
                sruRefreshButton.addEventListener('click', loadAndDisplayScheduledUpdates_ExtraPage);
            }

// Timetable Exporter Listeners
if (tteRouteNameSelect_el_extra && tteRouteNameInput_el_extra) {
    tteRouteNameSelect_el_extra.addEventListener('change', () => {
        if (tteRouteNameInput_el_extra) { // Ensure input exists
            tteRouteNameInput_el_extra.value = tteRouteNameSelect_el_extra.value;
        }
        if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = ''; // Clear status on new selection
    });
    tteRouteNameInput_el_extra.addEventListener('input', () => {
        const typedValue = tteRouteNameInput_el_extra.value.trim().toUpperCase();
        let matchedSelectValue = "";
        if (tteRouteNameSelect_el_extra) {
            const matchedOption = Array.from(tteRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedValue);
            if (matchedOption) {
                matchedSelectValue = matchedOption.value;
            }
            // Only update if the value actually changes to avoid potential loops if 'input' also triggers 'change'
            if (tteRouteNameSelect_el_extra.value !== matchedSelectValue) {
                 tteRouteNameSelect_el_extra.value = matchedSelectValue;
            }
        }
        if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = '';
    });
}
if (tteDownloadTimetableButton_el_extra) {
    tteDownloadTimetableButton_el_extra.addEventListener('click', handleDownloadTimetable_ExtraPage);
}
            if (window.firebaseOMSI && window.firebaseOMSI.auth) { initializeExtraAppLogic(); } 
            else { document.addEventListener('firebaseReady', () => { if (window.firebaseOMSI && window.firebaseOMSI.auth) { initializeExtraAppLogic(); } else { console.error("Extra Tools: Firebase still not ready after event!"); } }, { once: true }); } 
            
            const menuButtons = topMenuBar_el_extra.querySelectorAll('.menu-button'); 
            menuButtons.forEach(button => button.addEventListener('click', () => { if (currentUser_extra) showExtraPageSection(button.dataset.section); else alert("Please log in."); })); 

// Timetable Exporter Listeners
if (tteRouteNameSelect_el_extra && tteRouteNameInput_el_extra) {
        tteRouteNameSelect_el_extra.addEventListener('change', () => {
            if (tteRouteNameInput_el_extra) {
                tteRouteNameInput_el_extra.value = tteRouteNameSelect_el_extra.value;
            }
            if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = '';
        });
        tteRouteNameInput_el_extra.addEventListener('input', () => { // Using 'input' for more responsive sync
            const typedValue = tteRouteNameInput_el_extra.value.trim().toUpperCase();
            let matchedSelectValue = "";
            if (tteRouteNameSelect_el_extra) {
                const matchedOption = Array.from(tteRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedValue);
                if (matchedOption) {
                    matchedSelectValue = matchedOption.value;
                }
                if (tteRouteNameSelect_el_extra.value !== matchedSelectValue) {
                     tteRouteNameSelect_el_extra.value = matchedSelectValue;
                }
            }
            if (tteStatusMessage_el_extra) tteStatusMessage_el_extra.textContent = '';
        });
    }
    if (tteDownloadTimetableButton_el_extra) {
        tteDownloadTimetableButton_el_extra.addEventListener('click', handleDownloadTimetable_ExtraPage);
    }
            
            // Day Profile Override Listeners
            if(overrideDateInput_el_extra) overrideDateInput_el_extra.addEventListener('change', updateSelectedDateInfo_ExtraPage); 
            if(setOverrideButton_el_extra) setOverrideButton_el_extra.addEventListener('click', handleSetOverride_ExtraPage); 
            if(clearOverrideButton_el_extra) clearOverrideButton_el_extra.addEventListener('click', handleClearOverride_ExtraPage); 
            
            // Stop Management Listeners
            if (inputNewStopName_el_extra) inputNewStopName_el_extra.addEventListener('input', autoGenerateAndSetNewStopId_ExtraPage); 
            if (inputNewStopId_el_extra && newStopIdAvailability_el_extra) { inputNewStopId_el_extra.addEventListener('input', () => { const newStopId = inputNewStopId_el_extra.value.trim().toUpperCase(); if (!newStopId) { newStopIdAvailability_el_extra.textContent = ''; return; } if (!/^[A-Z0-9]+$/.test(newStopId)) { newStopIdAvailability_el_extra.textContent = 'ID invalid chars.'; newStopIdAvailability_el_extra.style.color = '#e74c3c'; return; } const existingStopIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase())); if (existingStopIDs.has(newStopId)) { newStopIdAvailability_el_extra.textContent = 'ID already exists!'; newStopIdAvailability_el_extra.style.color = '#e74c3c'; } else { newStopIdAvailability_el_extra.textContent = 'ID available.'; newStopIdAvailability_el_extra.style.color = '#2ecc71'; } }); } 
            if (buttonAddNewStop_el_extra) buttonAddNewStop_el_extra.addEventListener('click', handleAddStopDetails_ExtraPage); 
            if (fileInputBulkAddStops_el_extra) fileInputBulkAddStops_el_extra.addEventListener('change', handleExcelFileForBulkAdd_ExtraPage); 
            if (buttonBulkAddNewStops_el_extra) buttonBulkAddNewStops_el_extra.addEventListener('click', handleBulkAddStops_ExtraPage); 
            if(masterStopListFilterInput_el_extra) masterStopListFilterInput_el_extra.addEventListener('input', populateMasterStopList_ExtraPage); 
            if(refreshMasterStopListButton_el_extra) refreshMasterStopListButton_el_extra.addEventListener('click', ()=>{ loadInitialData_ExtraPage().then(()=>populateMasterStopList_ExtraPage()); }); 
            if(applyMasterListStopIdChangesButton_el_extra) applyMasterListStopIdChangesButton_el_extra.addEventListener('click', handleApplyMasterListStopIdChangesButton_ExtraPage); 
            if(exportUniqueStopsButton_el_extra) exportUniqueStopsButton_el_extra.addEventListener('click', () => { if (!currentUser_extra) { alert("Log in to export."); return; } const uniqueStops = getUniqueStopsFromSchedule_ExtraPage(); if (uniqueStops.length === 0) { alert("No unique stops to export."); return; } const dataToExport = uniqueStops.map(stop => { const servingLineNames = new Set(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === stop.stopID && entry.lineName && entry.lineName.trim() !== "" && entry.lineName.toUpperCase() !== "INFO_ONLY") servingLineNames.add(entry.lineName); }); return { "StopID": stop.stopID, "StopName": stop.stopName, "Direction": stop.direction, "LineName(s)": Array.from(servingLineNames).sort(compareLineNames_ExtraPage).join(', ') }; }); const headers = ["StopID", "StopName", "Direction", "LineName(s)"]; const worksheetData = [ headers, ...dataToExport.map(row => headers.map(header => row[header])) ]; const worksheet = XLSX.utils.aoa_to_sheet(worksheetData); const workbook = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(workbook, worksheet, "OMSI Bus Stops"); XLSX.writeFile(workbook, "OMSI_Bus_Stops_Extra.xlsx"); }); 
            if(findDuplicateStopsByNameDirButton_el_extra) findDuplicateStopsByNameDirButton_el_extra.addEventListener('click', findDuplicateStopsByNameAndDirection_ExtraPage); 
            
            // Global Route Deletion Listeners
            if(deleteEntireRouteButton_el_extra) deleteEntireRouteButton_el_extra.addEventListener('click', handleDeleteEntireRouteGlobally_ExtraPage); 
            
            // Route Profile Deletion (RPD) Listeners
            if (rpdRouteSelect_el_extra) rpdRouteSelect_el_extra.addEventListener('change', rpd_handleRouteNameSelectChange_ExtraPage);
            if (rpdRouteInput_el_extra) rpdRouteInput_el_extra.addEventListener('blur', rpd_handleRouteNameInputChange_ExtraPage); // Changed to blur for better UX with select sync
            if (rpdDestinationSelect_el_extra) rpdDestinationSelect_el_extra.addEventListener('change', rpd_handleDestinationNameSelectChange_ExtraPage);
            if (rpdDestinationInput_el_extra) rpdDestinationInput_el_extra.addEventListener('blur', rpd_handleDestinationNameInputChange_ExtraPage); // Changed to blur
            if (rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.addEventListener('click', rpd_handleClearDestination_ExtraPage);
            if (rpdDeleteProfilesButton_el_extra) rpdDeleteProfilesButton_el_extra.addEventListener('click', handleDeleteRouteProfiles_ExtraPage);

            // Route Schedule Generator (RSG) Listeners
            if (rsgRouteNameSelect_el_extra) rsgRouteNameSelect_el_extra.addEventListener('change', () => { rsg_handleRouteNameSelectChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgRouteNameInput_el_extra) rsgRouteNameInput_el_extra.addEventListener('blur', () => { rsg_handleRouteNameInputChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgDestinationNameSelect_el_extra) rsgDestinationNameSelect_el_extra.addEventListener('change', () => { rsg_handleDestinationNameSelectChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgDestinationNameInput_el_extra) rsgDestinationNameInput_el_extra.addEventListener('blur', () => { rsg_handleDestinationNameInputChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgStopSearchInput_el_extra) rsgStopSearchInput_el_extra.addEventListener('input', rsg_handleStopSearch_ExtraPage); 
            if (rsgGenerateScheduleButton_el_extra) rsgGenerateScheduleButton_el_extra.addEventListener('click', () => rsg_handleGenerateSchedulePreview_ExtraPage(false)); 
            if (rsgSaveConfigurationButton_el_extra) rsgSaveConfigurationButton_el_extra.addEventListener('click', rsg_handleSaveConfiguration_ExtraPage);
if (rsgAddToWorkingScheduleButton_el_extra) {
            rsgAddToWorkingScheduleButton_el_extra.addEventListener('click', rsg_handleAddGeneratedToWorkingSchedule_ExtraPage);
        } 
            
if (rsgAddToWorkingScheduleButton_el_extra) {
    rsgAddToWorkingScheduleButton_el_extra.disabled = true;
    rsgAddToWorkingScheduleButton_el_extra.classList.add('neutral');
    rsgAddToWorkingScheduleButton_el_extra.classList.remove('save');
}
// --- NEW LISTENERS FOR "SCHEDULE THIS CONFIGURATION" ---
            
            const rsgScheduleThisConfigButton_el_extra = document.getElementById('rsg-schedule-this-config-button-extra');
            if (rsgScheduleThisConfigButton_el_extra) {
                rsgScheduleThisConfigButton_el_extra.addEventListener('click', handleScheduleThisConfiguration);
            }

            const rsgScheduleDateTimeConfirmBtn = document.getElementById('rsg-schedule-datetime-confirm-button-extra');
            if (rsgScheduleDateTimeConfirmBtn) {
                rsgScheduleDateTimeConfirmBtn.addEventListener('click', rsg_confirmScheduleGoLive_ExtraPage);
            }

            const rsgScheduleDateTimeCancelBtn = document.getElementById('rsg-schedule-datetime-cancel-button-extra');
            if (rsgScheduleDateTimeCancelBtn) {
                rsgScheduleDateTimeCancelBtn.addEventListener('click', rsg_closeScheduleDateTimeModal_ExtraPage);
            }
            
            // Close modal if clicking outside content for rsg-schedule-datetime-modal-extra
            const rsgScheduleDateTimeModal = document.getElementById('rsg-schedule-datetime-modal-extra');
            if (rsgScheduleDateTimeModal) {
                rsgScheduleDateTimeModal.addEventListener('click', (event) => {
                    if (event.target === rsgScheduleDateTimeModal) { // Only if overlay itself is clicked
                        rsg_closeScheduleDateTimeModal_ExtraPage();
                    }
                });
            }

if (rsgFirstStopTimesInput_el_extra) {
                rsgFirstStopTimesInput_el_extra.addEventListener('input', () => { 
                    rsg_isDirty = true; 
                    console.log("RSG dirty: First stop times input changed.");
                });
            }
            // --- END OF NEW LISTENERS --- 
            if(rsgOpenCopyModalButton_el_extra) rsgOpenCopyModalButton_el_extra.addEventListener('click', rsg_openCopyFromModal_ExtraPage); 
            if(rsgCopyModalCancelButton_el_extra) rsgCopyModalCancelButton_el_extra.addEventListener('click', rsg_closeCopyFromModal_ExtraPage); 
            if(rsgCopyModalActionButton_el_extra) rsgCopyModalActionButton_el_extra.addEventListener('click', rsg_handleCopyDataFromSource_ExtraPage); 
            if(rsgCopySourceRouteNameSelect_el_extra) { rsgCopySourceRouteNameSelect_el_extra.addEventListener('change', () => { if(rsgCopySourceRouteNameInput_el_extra) rsgCopySourceRouteNameInput_el_extra.value = rsgCopySourceRouteNameSelect_el_extra.value; rsg_populateCopySourceDestinationSelect_ExtraPage(); }); } 
            if(rsgCopySourceRouteNameInput_el_extra) { rsgCopySourceRouteNameInput_el_extra.addEventListener('blur', () => { const typedRouteUpper = rsgCopySourceRouteNameInput_el_extra.value.trim().toUpperCase(); const matchedOption = Array.from(rsgCopySourceRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper); if (matchedOption) { rsgCopySourceRouteNameSelect_el_extra.value = matchedOption.value; if(rsgCopySourceRouteNameInput_el_extra.value !== matchedOption.value) rsgCopySourceRouteNameInput_el_extra.value = matchedOption.value; } else { rsgCopySourceRouteNameSelect_el_extra.value = ""; } rsg_populateCopySourceDestinationSelect_ExtraPage(); }); } 
            if(rsgCopySourceDestNameSelect_el_extra) { rsgCopySourceDestNameSelect_el_extra.addEventListener('change', () => { if(rsgCopySourceDestNameInput_el_extra) rsgCopySourceDestNameInput_el_extra.value = rsgCopySourceDestNameSelect_el_extra.value; }); } 
            if(rsgCopySourceDestNameInput_el_extra) { rsgCopySourceDestNameInput_el_extra.addEventListener('blur', () => { const typedDest = rsgCopySourceDestNameInput_el_extra.value.trim(); const matchedOption = Array.from(rsgCopySourceDestNameSelect_el_extra.options).find(opt => opt.value === typedDest); if (matchedOption) rsgCopySourceDestNameSelect_el_extra.value = matchedOption.value; else rsgCopySourceDestNameSelect_el_extra.value = ""; }); } 
            if (rsgCopyModal_el_extra) { rsgCopyModal_el_extra.addEventListener('click', (event) => { if (event.target === rsgCopyModal_el_extra) rsg_closeCopyFromModal_ExtraPage(); }); }
        });

const rsgClearProfilesButton_el_extra = document.getElementById('rsg-clear-profile-checkboxes-button-extra');
if (rsgClearProfilesButton_el_extra) {
    rsgClearProfilesButton_el_extra.addEventListener('click', rsg_clearProfileSelections_ExtraPage);
}

// Save Config Modal Buttons
const rsgSaveConfirmBtn = document.getElementById('rsg-save-config-confirm-button-extra');
if (rsgSaveConfirmBtn) {
    rsgSaveConfirmBtn.addEventListener('click', rsg_performSaveConfiguration_ExtraPage);
}
const rsgSaveCancelBtn = document.getElementById('rsg-save-config-cancel-button-extra');
if (rsgSaveCancelBtn) {
    rsgSaveCancelBtn.addEventListener('click', rsg_hideSaveConfigModal_ExtraPage);
}

// Clicking outside the modal content to close it
const rsgSaveModal = document.getElementById('rsg-save-config-modal-extra');
if (rsgSaveModal) {
    rsgSaveModal.addEventListener('click', (event) => {
        if (event.target === rsgSaveModal) { // Only if overlay itself is clicked
            rsg_hideSaveConfigModal_ExtraPage();
        }

        });
    }

// Event Listeners for RSG Rename Config Modal (New)
    const rsgRenameConfirmBtn = document.getElementById('rsg-rename-config-confirm-button-extra');
    if (rsgRenameConfirmBtn) {
        rsgRenameConfirmBtn.addEventListener('click', rsg_performRenameConfiguration_ExtraPage);
    }
    const rsgRenameCancelBtn = document.getElementById('rsg-rename-config-cancel-button-extra');
    if (rsgRenameCancelBtn) {
        rsgRenameCancelBtn.addEventListener('click', rsg_hideRenameConfigModal_ExtraPage);
    }
    const rsgRenameModal = document.getElementById('rsg-rename-config-modal-extra');
    if (rsgRenameModal) {
        rsgRenameModal.addEventListener('click', (event) => {
            if (event.target === rsgRenameModal) { // Only if overlay (modal background) itself is clicked
                rsg_hideRenameConfigModal_ExtraPage();
            }
        });
    }

// === SERVICE ANALYZER JS ===
const serviceAnalyzerStopSelect_el_extra = document.getElementById('service-analyzer-stop-select-extra');
const serviceAnalyzerStopInput_el_extra = document.getElementById('service-analyzer-stop-input-extra');
const serviceAnalyzerStopSummary_el_extra = document.getElementById('service-analyzer-stop-summary-extra');

function populateServiceAnalyzerDropdowns_ExtraPage() {
    if (!Array.isArray(currentWorkingSchedule_extra)) return;
    // const allRoutesSet = new Set(); // No longer needed
    const allStopsSet = new Set();
    const allStopsMap = new Map();
    currentWorkingSchedule_extra.forEach(entry => {
        // if (entry.lineName) allRoutesSet.add(entry.lineName); // Removed
        if (entry.stopID) {
            allStopsSet.add(entry.stopID);
            allStopsMap.set(entry.stopID, entry.stopName || entry.stopID);
        }
    });
    // The block for populating serviceAnalyzerRouteSelect_el_extra is removed.
    if (serviceAnalyzerStopSelect_el_extra) { // This element variable should still be defined
        serviceAnalyzerStopSelect_el_extra.innerHTML = '<option value="">-- Select Stop --</option>';
        Array.from(allStopsSet)
            .map(stopID => ({ id: stopID, name: allStopsMap.get(stopID) || stopID }))
            .sort((a,b) => {
                const nameCompare = (a.name.toLowerCase()).localeCompare(b.name.toLowerCase());
                if (nameCompare !== 0) return nameCompare;
                return (a.id.toLowerCase()).localeCompare(b.id.toLowerCase());
            })
            .forEach(stopObj => {
                serviceAnalyzerStopSelect_el_extra.innerHTML += `<option value="${stopObj.id}">${stopObj.name} (${stopObj.id})</option>`;
            });
    }
}

function triggerStopAnalysisDynamically(stopIdentifier) {
    if (stopIdentifier) {
        analyzeStop_ExtraPage(stopIdentifier); // Your existing analysis function
    } else {
        if (serviceAnalyzerStopSummary_el_extra) {
            serviceAnalyzerStopSummary_el_extra.innerHTML = 'Select or type a stop to analyze.';
        }
    }
}

// 1. Listener for the SELECT dropdown
if (serviceAnalyzerStopSelect_el_extra) {
    serviceAnalyzerStopSelect_el_extra.addEventListener('change', function() {
        const selectedStopID = this.value;
        if (serviceAnalyzerStopInput_el_extra) {
            // Update the text input to reflect the dropdown's current selection's full text
            const selectedOption = this.options[this.selectedIndex];
            if (selectedOption && selectedOption.value) { // Check if it's a real stop, not the placeholder
                serviceAnalyzerStopInput_el_extra.value = selectedOption.text; // Show "Stop Name (ID)"
            } else {
                serviceAnalyzerStopInput_el_extra.value = ""; // Clear input if "-- Select Stop --"
            }
        }
        triggerStopAnalysisDynamically(selectedStopID);
    });
}

// 2. Listener for the TEXT input
if (serviceAnalyzerStopInput_el_extra && serviceAnalyzerStopSelect_el_extra) {
    // While typing, try to sync the select dropdown (no analysis on every keystroke)
    serviceAnalyzerStopInput_el_extra.addEventListener('input', function() {
        const typedValueLower = this.value.toLowerCase().trim();
        if (typedValueLower === "") {
            if (serviceAnalyzerStopSelect_el_extra.value !== "") {
                 serviceAnalyzerStopSelect_el_extra.value = ""; // Reset select, this won't fire its change event
            }
            return;
        }

        const options = Array.from(serviceAnalyzerStopSelect_el_extra.options);
        const matchedOption = options.find(opt =>
            opt.text.toLowerCase().includes(typedValueLower) || // Prioritize matching by text content
            opt.value.toLowerCase() === typedValueLower      // Also allow matching by ID
        );

        if (matchedOption) {
            if (serviceAnalyzerStopSelect_el_extra.value !== matchedOption.value) {
                serviceAnalyzerStopSelect_el_extra.value = matchedOption.value; // Sync select
            }
        } else {
            if (serviceAnalyzerStopSelect_el_extra.value !== "") {
                serviceAnalyzerStopSelect_el_extra.value = ""; // No match, deselect
            }
        }
    });

    // Analyze when the text input loses focus (on blur)
    serviceAnalyzerStopInput_el_extra.addEventListener('blur', function() {
        const typedValue = this.value.trim();
        // Prefer the synced select value if it's valid and matches what was typed (or part of it)
        const selectedInDropdown = serviceAnalyzerStopSelect_el_extra.value;
        const selectedOptionText = serviceAnalyzerStopSelect_el_extra.options[serviceAnalyzerStopSelect_el_extra.selectedIndex]?.text;

        if (selectedInDropdown && selectedOptionText && selectedOptionText.toLowerCase().includes(typedValue.toLowerCase())) {
            triggerStopAnalysisDynamically(selectedInDropdown);
        } else if (typedValue) { // If no sync or no valid option that aligns with typed text, try analyzing the raw typed value
            triggerStopAnalysisDynamically(typedValue);
        } else { // Input is empty
             triggerStopAnalysisDynamically(null);
        }
    });
}



// Helper function to generate sequence HTML for a given set of profiles
function generateSequenceMapForProfiles(
    profilesToAnalyze,
    currentDestName,
    allEntriesForRoute // All schedule entries for the main route being analyzed
) {
    const sequencesMap = new Map(); // Key: sequenceSignature, Value: { sequence: [stopObjects], profiles: Set() }

    if (!profilesToAnalyze || profilesToAnalyze.length === 0) {
        return sequencesMap; // Return an empty map if no profiles to analyze
    }

    const sortedProfiles = [...profilesToAnalyze].sort(); // Process profiles in a consistent order

    for (const opProfile of sortedProfiles) {
        // Filter entries for the current operating profile and destination
        const specificProfileEntries = allEntriesForRoute.filter(e =>
            e.destinationName === currentDestName && e.OperatingProfile === opProfile
        );

        if (specificProfileEntries.length === 0) continue; // No entries for this specific profile/destination

        // Sort these specificProfileEntries chronologically to correctly identify the first trip
        specificProfileEntries.sort((a, b) => {
            const dayOffsetA = parseInt(a.DayOffset || 0);
            const dayOffsetB = parseInt(b.DayOffset || 0);
            if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;

            const timeA = (a.scheduledTime || "99:99").replace(':', ''); // Fallback for missing time
            const timeB = (b.scheduledTime || "99:99").replace(':', '');
            return timeA.localeCompare(timeB);
        });

        const sequenceForThisProfileTrip = [];
        if (specificProfileEntries.length > 0) {
            const firstStopIDOfThisJourneyPattern = specificProfileEntries[0].stopID;
            let previousStopTimeInAbsoluteMinutes = -1;
            // Heuristic: Minimum stops to process before considering a repeat of the first stop ID as a new trip.
            // This helps distinguish a genuine new trip from a route that might loop back to its start ID quickly.
            // Adjust if necessary. If routes are very short (e.g. 2-stop shuttles that repeat often), this might need tuning.
            const MIN_STOPS_BEFORE_FIRST_ID_REVISIT_BREAK = 3;

            for (let i = 0; i < specificProfileEntries.length; i++) {
                const entry = specificProfileEntries[i];

                if (!entry.stopID || !entry.scheduledTime) {
                    console.warn(`Service Analyzer: Skipping entry for ${opProfile} (Dest: ${currentDestName}) due to missing stopID/time:`, entry);
                    continue;
                }

                const currentStopTimeInAbsoluteMinutes =
                    (parseInt(entry.DayOffset || 0) * 1440) +
                    parseInt(entry.scheduledTime.split(':')[0]) * 60 +
                    parseInt(entry.scheduledTime.split(':')[1]);

                // These break conditions apply only after the very first stop (i > 0)
                if (i > 0) {
                    // Condition 1: Time regresses (e.g., next day's service, or data error)
                    if (currentStopTimeInAbsoluteMinutes < previousStopTimeInAbsoluteMinutes) {
                        break; // End of the current trip's sequence
                    }
                    // Condition 2: Encountered the starting stop ID again *after* a few other stops
                    if (entry.stopID === firstStopIDOfThisJourneyPattern &&
                        sequenceForThisProfileTrip.length >= MIN_STOPS_BEFORE_FIRST_ID_REVISIT_BREAK) {
                        break; // Assumed start of the next iteration of this trip pattern
                    }
                }

                sequenceForThisProfileTrip.push({
                    stopID: entry.stopID,
                    name: entry.stopName || entry.stopID,
                    direction: entry.direction || 'N/A'
                });
                previousStopTimeInAbsoluteMinutes = currentStopTimeInAbsoluteMinutes;
            }
        }

        if (sequenceForThisProfileTrip.length > 0) {
            const sequenceSignature = sequenceForThisProfileTrip.map(s => s.stopID).join('->');
            if (!sequencesMap.has(sequenceSignature)) {
                sequencesMap.set(sequenceSignature, {
                    sequence: sequenceForThisProfileTrip,
                    profiles: new Set()
                });
            }
            sequencesMap.get(sequenceSignature).profiles.add(opProfile);
        }
    } // End opProfile loop
    return sequencesMap;
}

function analyzeStop_ExtraPage(stopID) {
    if (!serviceAnalyzerStopSummary_el_extra) {
        console.error("Service Analyzer: Summary element not found!");
        return;
    }
    if (!stopID) {
        serviceAnalyzerStopSummary_el_extra.innerHTML = `<span style="color:#f1c40f;">Please select or enter a stop.</span>`;
        return;
    }

    const entries = currentWorkingSchedule_extra.filter(e => e.stopID && e.stopID.toUpperCase() === stopID.toUpperCase());

    if (entries.length === 0) {
        serviceAnalyzerStopSummary_el_extra.innerHTML = `<span style="color:#e74c3c;">No data found for stop ID: ${stopID}.</span>`;
        return;
    }

    const stopDetails = entries[0];
    const routes = new Set();
    const profilesByRoute = new Map(); 
    const destinationsByRoute = new Map(); 
    let stopHasNightRouteService = false; 

    entries.forEach(e => {
        if (e.lineName) {
            routes.add(e.lineName);
            if (typeof e.lineName === 'string' && e.lineName.toUpperCase().startsWith('N')) {
                stopHasNightRouteService = true;
            }

            if (!profilesByRoute.has(e.lineName)) {
                profilesByRoute.set(e.lineName, new Set());
            }
            if (e.OperatingProfile) {
                profilesByRoute.get(e.lineName).add(e.OperatingProfile);
            }
            
            if (!destinationsByRoute.has(e.lineName)) {
                destinationsByRoute.set(e.lineName, new Set());
            }
            if (e.destinationName) {
                destinationsByRoute.get(e.lineName).add(e.destinationName);
            }
        }
    });

    const MORNING_SERVICE_START_HOUR = 4; 

    let routeDetailsHTML = "";
    const designatedNightServiceBlue = (globalCustomRouteColours_extra["NIGHT_DEFAULT"] || NIGHT_BUS_BLUE_COLOR_extra || "#4CDBE6").toUpperCase();

    Array.from(routes).sort(compareLineNames_ExtraPage).forEach(route => {
        const bgColor = getRouteTileColour_ExtraPage(route, stopID); 
        const textColor = getTextColourForBackground_ExtraPage(bgColor);
        const tileHTML = `<span class="route-tile-tools-list" style="background-color:${bgColor}; color:${textColor}; font-size: 0.95em; padding: 0.3em 0.65em; margin-right: 0.5em; vertical-align: baseline;">${route}</span>`;

        let profilesDisplayHTML = "";
        const routeOperatingProfiles = Array.from(profilesByRoute.get(route) || []).sort();

        if (routeOperatingProfiles.length > 0) {
            profilesDisplayHTML = '<div style="margin-top: 0.3em; padding-left: 0.2em;">'; 

            const currentRouteActualTileColor = bgColor.toUpperCase();
            const isCurrentRouteAnNRoute = route.toUpperCase().startsWith('N');

            routeOperatingProfiles.forEach(profile => {
                let profileDetailText;

                if (currentRouteActualTileColor === designatedNightServiceBlue && !isCurrentRouteAnNRoute) {
                    profileDetailText = `<span style="color: ${designatedNightServiceBlue};">24 Hour Service</span>`;
                } else {
                    let firstBusTimeStr = "N/A";
                    let lastBusTimeStr = "N/A";

                    const specificEntriesForRouteProfile = entries.filter(e =>
                        e.lineName === route && 
                        e.OperatingProfile === profile &&
                        e.scheduledTime && typeof e.scheduledTime === 'string' && e.scheduledTime.includes(':')
                    );

                    if (specificEntriesForRouteProfile.length > 0) {
                        const timesForThisRouteProfile = specificEntriesForRouteProfile.map(e => ({
                            absMinutes: getAbsMinutes(e.scheduledTime, parseInt(e.DayOffset || 0, 10)),
                            displayTime: e.scheduledTime
                        })).filter(t => t.absMinutes !== null);

                        if (timesForThisRouteProfile.length > 0) {
                            timesForThisRouteProfile.sort((a, b) => a.absMinutes - b.absMinutes);

                            if (isCurrentRouteAnNRoute) {
                                // For N-routes, First Bus is the chronological start of that profile's service
                                firstBusTimeStr = timesForThisRouteProfile[0].displayTime;
                            } else {
                                // For non-N routes, apply the "Morning Start Hour" heuristic
                                let foundMorningStartForProfile = false;
                                for (const item of timesForThisRouteProfile) {
                                    const hourOfCalendarDay = Math.floor((item.absMinutes % 1440) / 60);
                                    if (hourOfCalendarDay >= MORNING_SERVICE_START_HOUR) {
                                        firstBusTimeStr = item.displayTime;
                                        foundMorningStartForProfile = true;
                                        break;
                                    }
                                }
                                if (!foundMorningStartForProfile && timesForThisRouteProfile.length > 0) { 
                                    firstBusTimeStr = timesForThisRouteProfile[0].displayTime;
                                }
                            }
                            lastBusTimeStr = timesForThisRouteProfile[timesForThisRouteProfile.length - 1].displayTime;
                        }
                    }
                    profileDetailText = `First: ${firstBusTimeStr} - Last: ${lastBusTimeStr}`;
                }
                profilesDisplayHTML += `<div style="font-size:0.85em; margin-bottom:0.25em; padding-left:0.3em;"><strong style="font-weight:normal; color: #bdc3c7;">${profile}:</strong> ${profileDetailText}</div>`;
            });
            profilesDisplayHTML += '</div>';
        } else {
            profilesDisplayHTML = '<div style="font-size:0.85em; margin-top:0.3em; padding-left:0.5em;">Profiles: N/A</div>';
        }
        
        let destinationsDisplayBlock;
        if (destinationsByRoute.has(route)) {
            const routeDestsArray = Array.from(destinationsByRoute.get(route)).sort();
            if (routeDestsArray.length === 0) {
                destinationsDisplayBlock = `<div style="font-size:0.85em; margin-top: 0.3em; padding-left:0.5em;">Destinations: N/A</div>`;
            } else if (routeDestsArray.length === 1) {
                destinationsDisplayBlock = `<div style="font-size:0.85em; margin-top: 0.3em; padding-left:0.5em;">Destinations: ${routeDestsArray[0]}</div>`;
            } else { 
                const listItems = routeDestsArray.map(d => `<li style="margin-bottom: 0.15em;">${d}</li>`).join('');
                destinationsDisplayBlock = `
                    <div style="font-size:0.85em; margin-top: 0.3em; padding-left:0.5em;">
                        Destinations:
                        <ul style="margin-top: 0.2em; margin-bottom: 0; padding-left: 1.7em; list-style-type: disc;">
                            ${listItems}
                        </ul>
                    </div>`;
            }
        } else {
            destinationsDisplayBlock = `<div style="font-size:0.85em; margin-top: 0.3em; padding-left:0.5em;">Destinations: N/A</div>`;
        }

        routeDetailsHTML += `
            <div class="subsection" style="margin-top:0.6rem; padding:0.6rem 0.6rem 0.6rem 0.8rem; font-size:0.9em; border-left: 4px solid ${bgColor};">
                ${tileHTML}
                ${profilesDisplayHTML}
                ${destinationsDisplayBlock}
            </div>`;
    });

    const nightServiceColorForIndicator = typeof NIGHT_BUS_BLUE_COLOR_extra !== 'undefined' ? NIGHT_BUS_BLUE_COLOR_extra : '#4CDBE6';
    const nightServiceIndicatorHTML = stopHasNightRouteService ? `<span style="font-size: 0.9em; color: ${nightServiceColorForIndicator}; display:block; margin-top:0.1em;">(Night service routes operate at this stop)</span><br>` : '';

    serviceAnalyzerStopSummary_el_extra.innerHTML = `
        <span style="font-size: 1.1em;">Stop: ${stopDetails.stopName || 'N/A'} (ID: ${stopID})</span><br>
        <span style="font-size: 0.9em;">Direction: ${stopDetails.direction || 'N/A'}</span><br>
        <span style="font-size: 0.9em;">Total Schedule Entries at Stop: ${entries.length}</span><br>
        ${nightServiceIndicatorHTML}
        <span style="margin-top:0.85em; margin-bottom: 0.3em; display:block; font-size: 1.05em;">Routes Serving This Stop (${routes.size}):</span>
        <div style="max-height: 400px; overflow-y: auto; padding-right:0.2em; margin-top: 0.2em;">${routeDetailsHTML || '(None listed)'}</div>
    `;
}

function onShowServiceAnalyzerSection_ExtraPage() {
    populateServiceAnalyzerDropdowns_ExtraPage();
    if (serviceAnalyzerStopSummary_el_extra) serviceAnalyzerStopSummary_el_extra.innerHTML = 'Select a stop.';
}

</script>
</body>
</html>
