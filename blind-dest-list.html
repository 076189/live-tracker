<!DOCTYPE html>
<html lang="en">
<head>
    <title>Blind Destination List</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="manifest" href="./manifest-blind.json">
    
    <meta name="theme-color" content="#007bff">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.1/jspdf.plugin.autotable.min.js"></script>
    <style>
        /* --- Basic Page Setup --- */
        body, html { margin: 0; padding: 0; box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }
        body { font-family: Arial, sans-serif; padding: 20px; background-color: #f4f4f4; color: #333; }
        .page-container { background-color: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin: 20px auto; width: 95%; max-width: 900px; }
        h1 { text-align: center; color: #333; margin-top: 0; margin-bottom: 10px;}
        h2 { text-align: center; color: #555; margin-top: 20px; margin-bottom: 10px; font-size: 1.2em; }
        h3.inserts-title { text-align: center; color: #444; margin-top:15px; margin-bottom:5px; font-size: 1.1em; }

        /* --- Controls Area --- */
        .top-controls-container {
            padding: 15px; background-color: #f0f0f0; border-radius: 6px; margin-bottom: 25px; border: 1px solid #e0e0e0;
            display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 15px;
        }
        .list-name-section { display: flex; align-items: center; gap: 10px; flex-grow: 1; flex-basis: 250px; }
        .list-name-section label { font-weight: bold; font-size: 0.95em; white-space: nowrap; }
        .list-name-section input[type="text"] { padding: 8px; border: 1px solid #ccc; border-radius: 4px; flex-grow: 1; min-width: 180px; font-size: 0.95em; }

        .blind-mode-section { display: flex; align-items: center; gap: 8px; padding: 10px 0; flex-basis: auto; justify-content: center;}
        .blind-mode-section label { margin-right: 3px; font-size: 0.9em;}
        .blind-mode-section input[type="radio"] { margin-right: 2px; vertical-align: middle; }
        
        .mode-specific-controls { 
            width: 100%; 
            margin-top: 10px; 
            padding: 10px; 
            border-radius: 4px;
        }
        .three-track-controls-section { 
            display: none; /* JS will control visibility */
            flex-direction: column; 
            align-items: flex-start; 
            gap: 8px;
            background-color: #e9f5ff; 
            border: 1px solid #cce0ff;
        }
        .three-track-controls-section div { display: flex; align-items: center; gap: 5px;}
        
        .manual-blind-specific-controls { /* MODIFIED for new color and structure */
            display: none; /* JS will control visibility */
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            background-color: #e9f5ff; /* Matching three-track style */
            border: 1px solid #cce0ff; /* Matching three-track style */
            font-size: 0.9em;
        }
        .manual-blind-specific-controls div { display: flex; align-items: center; gap: 5px; margin-bottom: 5px;}
        .manual-blind-specific-controls div:last-child { margin-bottom: 0; }


        .table-visibility-controls { 
            display: none; /* JS will control visibility */
            flex-wrap: wrap; 
            gap: 10px; 
            align-items: center;
            background-color: #e6ffed; 
            border: 1px solid #c3e6cb; 
            font-size: 0.9em;
        }
        .table-visibility-controls strong { font-size: 0.95em; margin-right: 5px; }
        .table-visibility-controls label { margin-right: 3px; white-space: nowrap; }
        .table-visibility-controls input[type="checkbox"] { margin-right: 2px; vertical-align: middle; }
        .table-visibility-controls span { /* NEW for D and E toggles */
            display: inline-flex; 
            align-items: center;
            gap: 2px; 
            margin-right: 8px; 
        }


        .actions-group { display: flex; gap: 10px; flex-shrink: 0; } 
        .actions-group button { width: auto; padding: 8px 12px; }
        .help-button { background-color: #17a2b8; } .help-button:hover { background-color: #138496; }
        .text-export-button { background-color: #28a745; } .text-export-button:hover { background-color: #218838; }
        .pdf-export-button { background-color: #28a745; } .pdf-export-button:hover { background-color: #218838; } /* MODIFIED color */
        
        .import-section { display: flex; align-items: center; gap: 10px; flex-grow: 1; flex-basis: 100%; margin-top:10px; }
        .import-section label { font-weight: bold; font-size: 0.95em; white-space: nowrap; margin-right: 5px; }
        .import-section input[type="file"] { 
            padding: 6px; 
            border: 1px solid #ccc; 
            border-radius: 4px; 
            flex-grow: 1;
            font-size: 0.9em;
            min-width: 150px; 
            max-width: 100%;
        }

        /* --- Tables --- */
        .tables-wrapper { }
        .table-container { margin-bottom: 30px; border: 1px solid #ccc; border-radius: 6px; padding: 15px; background-color: #fdfdfd; }
        .table-container:last-child { margin-bottom: 0; }
        .inserts-options-section { margin-top: 10px; padding: 8px; background-color: #eef; border-radius: 4px;}
        .inserts-options-section label { font-size: 0.9em; margin-right: 5px;}
        .inserts-table-sub-container { margin-top: 15px; padding:10px; border: 1px dashed #bbb; border-radius: 4px; background-color: #fafcff; }
        
        table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 0.9em; table-layout: fixed; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; vertical-align: middle; word-wrap: break-word; }
        th { background-color: #e9ecef; font-weight: bold; text-align: center; }
        
        tbody tr:not(.fixed-row):not(.insert-row):nth-child(even) { background-color: #f0f0f0; }
        tbody tr:not(.fixed-row):not(.insert-row):nth-child(odd) { background-color: #ffffff; }
        
        tbody tr.insert-row { background-color: #e6f2ff; } 
        tbody tr.insert-row:nth-child(odd) { background-color: #f0f8ff; } 
        
        tbody input[type="text"] {
            width: 95%;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-sizing: border-box;
            font-family: inherit;
            font-size: inherit;
        }
        tbody textarea { /* NEW for multi-line input */
            width: 95%; 
            padding: 4px; 
            border: 1px solid #ccc; 
            border-radius: 3px; 
            box-sizing: border-box; 
            font-family: inherit; 
            font-size: inherit; 
            line-height: 1.4; 
            vertical-align: middle; 
            resize: vertical; 
            min-height: 30px; 
            display: block; 
            margin: 0 auto; 
        }
        
        col.col-drag-common { width: 10%; }
        col.col-num-common { width: 15%; }
        col.col-data-wide    { width: 55%; } 
        col.col-action-narrow { width: 20%; } 

        .drag-handle { cursor: grab; font-size: 1.2em; user-select: none; } 
        .drag-handle:active { cursor: grabbing; }
        td.col-drag-cell { text-align: center; vertical-align: middle; } 
        th.col-drag-header { text-align: center; }
        .sortable-ghost { opacity: 0.4; background: #c8ebfb !important; }
        
        .fixed-row td { background-color: #d8d8d8; color: #333; font-weight: bold; }
        .fixed-row .fixed-text-cell { text-align: center !important; } 
        .fixed-row-num-cell, .fixed-row-action-cell, .fixed-row-drag-cell { text-align: center; }
        
        button { padding: 8px 15px; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; margin: 2px; background-color: #007bff; transition: background-color 0.2s ease; flex-shrink: 0; }
        button:hover { background-color: #0056b3; }
        
        .small-danger-button { padding: 3px 8px; font-size: 0.85em; background-color: #dc3545; width: auto; }
        .small-danger-button:hover { background-color: #c82333; }
        .clear-table-button { margin-left: auto; }
        
        .small-add-insert-button { padding: 3px 8px; font-size: 0.85em; background-color: #17a2b8; width: auto; } 
        .small-add-insert-button:hover { background-color: #138496; }
        
        .add-top-insert-button { background-color: #6f42c1; } 
        .add-top-insert-button:hover { background-color: #5a2f9e; }
        
        .copy-track-button { background-color: #fd7e14; } 
        .copy-track-button:hover { background-color: #e66b00; }

        td.col-action-cell { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 3px;}
        .controls { margin-top: 15px; display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 10px; }
        .controls > button:not(.clear-table-button) { flex-grow: 1; min-width: 120px; width: auto; }
        .controls .copy-track-button { flex-grow: 0; min-width: fit-content; }
        .controls .add-top-insert-button { flex-grow: 0; min-width: fit-content; } 
        
        .multiple-add-control { display: flex; align-items: center; gap: 8px; flex-grow: 1; justify-content: flex-end;}
        .multiple-rows-input { width: 75px; padding: 7px; font-size: 0.9em; border: 1px solid #ccc; border-radius: 4px; text-align: center;}
        .add-multiple-button { padding: 7px 10px; width: auto;}
        th.col-action-header { text-align: center; vertical-align: middle; }

        /* --- Modal Styles (for Help Dialog) --- */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 10% auto; padding: 25px; border: 1px solid #888; width: 80%; max-width: 700px; border-radius: 8px; position: relative; box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19); animation-name: animatetop; animation-duration: 0.4s }
        @keyframes animatetop { from {top: -300px; opacity: 0} to {top: 0; opacity: 1} }
        .modal-close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; line-height: 1; }
        .modal-close-button:hover, .modal-close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        #helpModalBody h4 { margin-top: 15px; margin-bottom: 5px; color: #333; }
        #helpModalBody p, #helpModalBody ul { font-size: 0.95em; line-height: 1.6; color: #555; }
        #helpModalBody ul { margin-left: 20px; padding-left: 10px; }
        #helpModalBody li { margin-bottom: 8px; }

        /* --- Orientation Prompt Styles --- */
        .orientation-prompt-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); color: white; z-index: 2000; justify-content: center; align-items: center; text-align: center; padding: 20px; box-sizing: border-box; }
        .orientation-prompt-message { font-size: 1.2em; line-height: 1.6; }
        .orientation-prompt-icon { font-size: 3em; margin-bottom: 15px; transform: rotate(90deg); }
        @media screen and (max-width: 768px) and (orientation: portrait) { .orientation-prompt-overlay { display: flex; flex-direction: column; } }
    </style>
</head>
<body>
    <div class="page-container">
        <h1>Blind Destination List</h1>

        <div class="top-controls-container">
            <div class="list-name-section">
                <label for="listNameInput">List Name:</label>
                <input type="text" id="listNameInput" placeholder="Enter list name for export">
            </div>
            <div class="blind-mode-section">
                <input type="radio" id="smartBlindMode" name="blindMode" value="smart" checked>
                <label for="smartBlindMode">Smartblind</label>
                <input type="radio" id="manualBlindMode" name="blindMode" value="manual">
                <label for="manualBlindMode">Manual Blind</label>
                <input type="radio" id="threeTrackMode" name="blindMode" value="threeTrack">
                <label for="threeTrackMode">3 Track</label>
            </div>
            <div class="actions-group"> 
                <button id="helpButton" class="help-button">Help</button>
                <button onclick="exportToBLIND()" class="text-export-button">Export to .blind</button>
                <button onclick="exportCurrentDataToPDF()" class="pdf-export-button">Export to PDF</button>
            </div>

            <div class="mode-specific-controls three-track-controls-section" id="threeTrackGlobalControls" style="display: none;">
                <div>
                    <input type="checkbox" id="threeTrackIdentical" checked>
                    <label for="threeTrackIdentical">Are all 3 tracks identical?</label>
                </div>
            </div>

            <div class="mode-specific-controls manual-blind-specific-controls" id="manualBlindSpecificControlsContainer" style="display: none;">
                <div>
                    <input type="checkbox" id="isSideBlindSplitCheckbox">
                    <label for="isSideBlindSplitCheckbox">Is Side Blind Split?</label>
                </div>
                <div>
                    <input type="checkbox" id="isFrontRearSeparateCheckbox">
                    <label for="isFrontRearSeparateCheckbox">Is Front & Rear Number Separate? (e.g, Trident)</label>
                </div>
            </div>

            <div class="mode-specific-controls table-visibility-controls" id="tableVisibilityControls" style="display: none;">
                <strong>Show Tables:</strong>
                <input type="checkbox" id="showTableA" data-table-id="A" checked> <label for="showTableA" id="showTableALabel">Front / Rear Number</label>
                <input type="checkbox" id="showTableB" data-table-id="B" checked> <label for="showTableB" id="showTableBLabel">Front Destination</label>
                <input type="checkbox" id="showTableC" data-table-id="C" checked> <label for="showTableC" id="showTableCLabel">Side Ultimate / Via</label>
                <span id="showTableDSpan" style="display:none;">
                    <input type="checkbox" id="showTableD" data-table-id="D" checked> <label for="showTableD" id="showTableDLabel">Side Intermediate</label>
                </span>
                <span id="showTableESpan" style="display:none;">
                    <input type="checkbox" id="showTableE" data-table-id="E" checked> <label for="showTableE" id="showTableELabel">Rear Number</label>
                </span>
            </div>

            <div class="import-section">
                <label for="blindFileInput">Import .blind File:</label>
                <input type="file" id="blindFileInput" accept=".blind"> 
            </div>
        </div>

        <div class="tables-wrapper">
            <div class="table-container" id="table-container-A">
                <h2 id="table-title-A">Front / Rear Number</h2>
                <div class="inserts-options-section">
                    <input type="checkbox" id="hasInsertsA" data-table-id="A">
                    <label for="hasInsertsA">Enable Inserts</label> 
                </div>
                <table id="table-A">
                    <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                    <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-data-A">Route</th><th class="col-action-header">Action</th></tr></thead>
                    <tbody id="table-body-A"></tbody>
                </table>
                <div class="controls">
                    <button onclick="addTopInsert('A')" id="addTopInsertA" class="add-top-insert-button" style="display:none;">Add Top Insert</button>
                    <button onclick="addDataRow('A')" id="addDataRowBtnA">Add Number</button>
                    <div class="multiple-add-control">
                        <input type="number" id="qty-A" class="multiple-rows-input" min="1" placeholder="Qty">
                        <button onclick="handleAddMultiple('A')" class="add-multiple-button">Add Qty</button>
                    </div>
                    <button onclick="clearTableData('A')" class="small-danger-button clear-table-button">Clear Table</button>
                </div>
                <div id="inserts-table-sub-container-A" style="display: none;">
                    <h3 class="inserts-title" id="inserts-title-A">Inserts for Front / Rear Number</h3>
                    <table id="table-inserts-A">
                        <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                        <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-inserts-data-A">Route (Insert)</th><th class="col-action-header">Action</th></tr></thead>
                        <tbody id="table-body-inserts-A"></tbody>
                    </table>
                    <div class="controls">
                        <button onclick="addInsertDataRow('A')" id="addSmartInsertBtnA">Add Smart Insert</button>
                         <div class="multiple-add-control">
                            <input type="number" id="qty-inserts-A" class="multiple-rows-input" min="1" placeholder="Qty">
                            <button onclick="handleAddMultipleInserts('A')" class="add-multiple-button">Add Qty Smart Inserts</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="table-container" id="table-container-B">
                <h2 id="table-title-B">Front Destination</h2>
                <div class="inserts-options-section">
                    <input type="checkbox" id="hasInsertsB" data-table-id="B">
                    <label for="hasInsertsB">Enable Inserts</label>
                </div>
                <table id="table-B">
                    <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                    <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-data-B">Destination</th><th class="col-action-header">Action</th></tr></thead>
                    <tbody id="table-body-B"></tbody>
                </table>
                <div class="controls">
                     <button id="copyToBBtn" class="copy-track-button" style="display:none;">Copy Track 1 to this Track</button>
                    <button onclick="addTopInsert('B')" id="addTopInsertB" class="add-top-insert-button" style="display:none;">Add Top Insert</button>
                    <button onclick="addDataRow('B')" id="addDataRowBtnB">Add Destination</button>
                    <div class="multiple-add-control">
                        <input type="number" id="qty-B" class="multiple-rows-input" min="1" placeholder="Qty">
                        <button onclick="handleAddMultiple('B')" class="add-multiple-button">Add Qty</button>
                    </div>
                    <button onclick="clearTableData('B')" class="small-danger-button clear-table-button">Clear Table</button>
                </div>
                <div id="inserts-table-sub-container-B" style="display: none;">
                    <h3 class="inserts-title" id="inserts-title-B">Inserts for Front Destination</h3>
                    <table id="table-inserts-B">
                        <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                        <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-inserts-data-B">Destination (Insert)</th><th class="col-action-header">Action</th></tr></thead>
                        <tbody id="table-body-inserts-B"></tbody>
                    </table>
                     <div class="controls">
                        <button onclick="addInsertDataRow('B')" id="addSmartInsertBtnB">Add Smart Insert</button>
                         <div class="multiple-add-control">
                            <input type="number" id="qty-inserts-B" class="multiple-rows-input" min="1" placeholder="Qty">
                            <button onclick="handleAddMultipleInserts('B')" class="add-multiple-button">Add Qty Smart Inserts</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="table-container" id="table-container-C">
                <h2 id="table-title-C">Side Ultimate / Via</h2> 
                <div class="inserts-options-section">
                    <input type="checkbox" id="hasInsertsC" data-table-id="C">
                    <label for="hasInsertsC">Enable Inserts</label>
                </div>
                <table id="table-C">
                    <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                    <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-data-C">Side Blind</th><th class="col-action-header">Action</th></tr></thead>
                    <tbody id="table-body-C"></tbody>
                </table>
                <div class="controls">
                    <button id="copyToCBtn" class="copy-track-button" style="display:none;">Copy Track 1 to this Track</button>
                    <button onclick="addTopInsert('C')" id="addTopInsertC" class="add-top-insert-button" style="display:none;">Add Top Insert</button>
                    <button onclick="addDataRow('C')" id="addDataRowBtnC">Add Via</button> 
                    <div class="multiple-add-control">
                        <input type="number" id="qty-C" class="multiple-rows-input" min="1" placeholder="Qty">
                        <button onclick="handleAddMultiple('C')" class="add-multiple-button">Add Qty</button>
                    </div>
                    <button onclick="clearTableData('C')" class="small-danger-button clear-table-button">Clear Table</button>
                </div>
                <div id="inserts-table-sub-container-C" style="display: none;">
                    <h3 class="inserts-title" id="inserts-title-C">Inserts for Side Ultimate / Via</h3>
                    <table id="table-inserts-C">
                        <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                        <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-inserts-data-C">Side Blind (Insert)</th><th class="col-action-header">Action</th></tr></thead>
                        <tbody id="table-body-inserts-C"></tbody>
                    </table>
                     <div class="controls">
                        <button onclick="addInsertDataRow('C')" id="addSmartInsertBtnC">Add Smart Insert</button>
                        <div class="multiple-add-control">
                            <input type="number" id="qty-inserts-C" class="multiple-rows-input" min="1" placeholder="Qty">
                            <button onclick="handleAddMultipleInserts('C')" class="add-multiple-button">Add Qty Smart Inserts</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="table-container" id="table-container-D" style="display: none;"> 
                <h2 id="table-title-D">Side Intermediate</h2>
                <div class="inserts-options-section">
                    <input type="checkbox" id="hasInsertsD" data-table-id="D">
                    <label for="hasInsertsD">Enable Inserts</label>
                </div>
                <table id="table-D">
                    <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                    <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-data-D">Intermediate Blind</th><th class="col-action-header">Action</th></tr></thead>
                    <tbody id="table-body-D"></tbody>
                </table>
                <div class="controls">
                    <button onclick="addTopInsert('D')" id="addTopInsertD" class="add-top-insert-button" style="display:none;">Add Top Insert</button>
                    <button onclick="addDataRow('D')" id="addDataRowBtnD">Add Intermediate</button>
                    <div class="multiple-add-control">
                        <input type="number" id="qty-D" class="multiple-rows-input" min="1" placeholder="Qty">
                        <button onclick="handleAddMultiple('D')" class="add-multiple-button">Add Qty</button>
                    </div>
                    <button onclick="clearTableData('D')" class="small-danger-button clear-table-button">Clear Table</button>
                </div>
                <div id="inserts-table-sub-container-D" style="display: none;">
                    <h3 class="inserts-title" id="inserts-title-D">Inserts for Side Intermediate</h3>
                    <table id="table-inserts-D">
                        <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                        <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-inserts-data-D">Intermediate (Insert)</th><th class="col-action-header">Action</th></tr></thead>
                        <tbody id="table-body-inserts-D"></tbody>
                    </table>
                     <div class="controls">
                        <button onclick="addInsertDataRow('D')" id="addSmartInsertBtnD">Add Smart Insert</button>
                        <div class="multiple-add-control">
                            <input type="number" id="qty-inserts-D" class="multiple-rows-input" min="1" placeholder="Qty">
                            <button onclick="handleAddMultipleInserts('D')" class="add-multiple-button">Add Qty Smart Inserts</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="table-container" id="table-container-E" style="display: none;">
                <h2 id="table-title-E">Rear Number</h2>
                <div class="inserts-options-section">
                    <input type="checkbox" id="hasInsertsE" data-table-id="E">
                    <label for="hasInsertsE">Enable Inserts</label>
                </div>
                <table id="table-E">
                    <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                    <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-data-E">Rear Number</th><th class="col-action-header">Action</th></tr></thead>
                    <tbody id="table-body-E"></tbody>
                </table>
                <div class="controls">
                    <button onclick="addTopInsert('E')" id="addTopInsertE" class="add-top-insert-button" style="display:none;">Add Top Insert</button>
                    <button onclick="addDataRow('E')" id="addDataRowBtnE">Add Rear No.</button>
                    <div class="multiple-add-control">
                        <input type="number" id="qty-E" class="multiple-rows-input" min="1" placeholder="Qty">
                        <button onclick="handleAddMultiple('E')" class="add-multiple-button">Add Qty</button>
                    </div>
                    <button onclick="clearTableData('E')" class="small-danger-button clear-table-button">Clear Table</button>
                </div>
                <div id="inserts-table-sub-container-E" style="display: none;">
                    <h3 class="inserts-title" id="inserts-title-E">Inserts for Rear Number</h3>
                    <table id="table-inserts-E">
                        <colgroup><col class="col-drag-common"><col class="col-num-common"><col class="col-data-wide"><col class="col-action-narrow"></colgroup>
                        <thead><tr><th class="col-drag-header" title="Drag to reorder">↕</th><th>No.</th><th id="table-header-inserts-data-E">Rear Number (Insert)</th><th class="col-action-header">Action</th></tr></thead>
                        <tbody id="table-body-inserts-E"></tbody>
                    </table>
                     <div class="controls">
                        <button onclick="addInsertDataRow('E')" id="addSmartInsertBtnE">Add Smart Insert</button>
                        <div class="multiple-add-control">
                            <input type="number" id="qty-inserts-E" class="multiple-rows-input" min="1" placeholder="Qty">
                            <button onclick="handleAddMultipleInserts('E')" class="add-multiple-button">Add Qty Smart Inserts</button>
                        </div>
                    </div>
                </div>
            </div>
        </div> 
        
        <div class="orientation-prompt-overlay" id="orientationPrompt">
            <div> 
                <div class="orientation-prompt-icon">&#x21BB;</div>
                <p class="orientation-prompt-message">
                    For the best experience, please rotate your device to landscape mode.
                </p>
            </div>
        </div>

    </div> 
    
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="modal-close-button" id="closeHelpModalBtn">&times;</span>
            <h2>Help & Instructions</h2>
            <div id="helpModalBody">
                 <h4>General Usage:</h4>
                <p>This tool helps you create and manage blind destination lists for different types of blinds.</p>
                <ul>
                    <li><strong>List Name:</strong> Enter a name for your list. Used in exports. Avoid invalid characters (<code>/ \ : * ? " &lt; &gt; |</code>).</li>
                    <li><strong>Add / Delete Rows:</strong> Use "Add..." buttons or "Delete" button on each row.</li>
                    <li><strong>Drag & Drop:</strong> Use ↕ to reorder rows.</li>
                    <li><strong>Clear Table:</strong> Removes all data and inserts for that table.</li>
                    <li><strong>Import/Export:</strong> Use buttons to save/load <code>.blind</code> files. Import overwrites current data. Session Persistence: Data is saved across page refreshes, but cleared when tab/browser is closed.</li>
                </ul>

                <h4>Blind Modes:</h4>
                <ul>
                    <li><strong>Smartblind:</strong> Sequential numbering (0 & 511 are fixed). Max 255 user rows (incl. inserts). Separate insert table.</li>
                    <li><strong>Manual Blind:</strong> Sequential main numbers. Lettered top inserts (A,B..), numbered middle inserts (17A..).
                        <ul>
                            <li><strong>Front & Rear Separate:</strong> If "Is Front & Rear Number Separate?" is checked (below mode selection), "Front / Rear Number" table becomes "Front Number / Via", and a new "Rear Number" table appears. "Front Number / Via" data cells allow multi-line input.</li>
                            <li><strong>Side Blind Split:</strong> If "Is Side Blind Split?" is checked, "Side Ultimate / Via" table becomes "Side Number", and a new "Side Intermediate" table appears.</li>
                        </ul>
                    </li>
                    <li><strong>3 Track:</strong> "All 3 tracks identical?" option. If not, 3 separate tracks appear (Track 1, Track 2, Track 3). Inserts are like Manual mode.</li>
                </ul>
                <h4>Table Visibility (Smartblind/Manual):</h4>
                <p>In "Smartblind" and "Manual Blind" modes, use "Show Tables:" checkboxes to toggle visibility and inclusion in exports. Additional tables created via Manual mode options ("Rear Number", "Side Intermediate") will also have their visibility toggles appear here.</p>
                <p><em>Close this dialog by clicking the &times; or pressing Esc.</em></p>
            </div>
        </div>
    </div>

    <script>
    // --- PART 1: Setup, State, UI Logic, Session Storage ---

    // --- PWA Service Worker Registration ---
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js') // Ensure this path points to your actual sw.js file
                .then((registration) => {
                    console.log('PWA Service Worker registered successfully with scope:', registration.scope);
                })
                .catch((error) => {
                    console.error('PWA Service Worker registration failed:', error);
                });
        });
    }

    // --- Constants for Smartblind Mode ---
    const BLACK_BLANK_TEXT = "BLACK BLANK";
    const SMART_DELIMITER_0_NUM = "0";
    const SMART_DELIMITER_0_DISPLAY_TEXT = "BLACK BLANK";
    const SMART_DELIMITER_511_NUM = "511";
    const SMART_DELIMITER_511_DISPLAY_TEXT = "END CODE";
    const MAX_EDITABLE_ROWS_SMART = 255;
    const SMART_INSERT_SEPARATOR_TEXT = "--- INSERT ---";

    // --- Global State Variables ---
    let currentBlindMode = 'smart';
    let threeTrackIsIdentical = true;
    let isSideBlindSplit = false;
    let isFrontRearSeparate = false;

    // --- Configuration for Table Appearances ---
    const originalTableAppearances = {
        A: {
            title: "Front / Rear Number", altTitle: "Front Number / Via",
            header: "Route", altHeader: "Front Route/Via",
            addBtn: "Add Number", altAddBtn: "Add Front Rte/Via",
            insertsTitle: "Inserts for Front / Rear Number", altInsertsTitle: "Inserts for Front Number / Via"
        },
        B: { title: "Front Destination", header: "Destination", addBtn: "Add Destination", insertsTitle: "Inserts for Front Destination" },
        C: {
            title: "Side Ultimate / Via", altTitle: "Side Number",
            header: "Side Blind", altHeader: "Number",
            addBtn: "Add Via", altAddBtn: "Add Number",
            insertsTitle: "Inserts for Side Ultimate / Via", altInsertsTitle: "Inserts for Side Number"
        },
        D: { title: "Side Intermediate", header: "Intermediate Blind", addBtn: "Add Intermediate", insertsTitle: "Inserts for Side Intermediate" },
        E: { title: "Rear Number", header: "Rear Number", addBtn: "Add Rear No.", insertsTitle: "Inserts for Rear Number" }
    };

    const threeTrackAppearances = {
        A: { title: "Track 1", header: "Number", addBtn: "Add Row", insertsTitle: "Inserts for Track 1" },
        B: { title: "Track 2", header: "Number", addBtn: "Add Row", insertsTitle: "Inserts for Track 2" },
        C: { title: "Track 3", header: "Number", addBtn: "Add Row", insertsTitle: "Inserts for Track 3" }
    };
    const threeTrackIdenticalAppearance = {
        title: "All Three Track Blinds", header: "Number", addBtn: "Add Row", insertsTitle: "Inserts for All Three Track Blinds"
    };

    // --- Data Storage for Tables ---
    let tableSettings = {
        A: { data: [], insertsData: [], hasInserts: false, manual_insert_location: 'bottom', manual_insert_after_display_row_number: 0, isVisibleInSmartManual: true, sortableInstance: null, sortableInsertsInstance: null },
        B: { data: [], insertsData: [], hasInserts: false, manual_insert_location: 'bottom', manual_insert_after_display_row_number: 0, isVisibleInSmartManual: true, sortableInstance: null, sortableInsertsInstance: null },
        C: { data: [], insertsData: [], hasInserts: false, manual_insert_location: 'bottom', manual_insert_after_display_row_number: 0, isVisibleInSmartManual: true, sortableInstance: null, sortableInsertsInstance: null },
        D: { data: [], insertsData: [], hasInserts: false, manual_insert_location: 'bottom', manual_insert_after_display_row_number: 0, isVisibleInSmartManual: false, sortableInstance: null, sortableInsertsInstance: null },
        E: { data: [], insertsData: [], hasInserts: false, manual_insert_location: 'bottom', manual_insert_after_display_row_number: 0, isVisibleInSmartManual: false, sortableInstance: null, sortableInsertsInstance: null }
    };

    // --- Utility Functions ---
    function generateUUID() { return crypto.randomUUID(); }

    function getThreeTrackPrefillData() {
        const prefillValues = [
            BLACK_BLANK_TEXT, ...Array.from({ length: 10 }, (_, i) => String(i)), BLACK_BLANK_TEXT,
            ...Array.from({ length: 26 }, (_, i) => String.fromCharCode(65 + i)), BLACK_BLANK_TEXT
        ];
        return prefillValues.map(val => ({ id: generateUUID(), value: val, type: 'main' }));
    }

    // --- Session Storage Functions ---
    function saveStateToSessionStorage() {
        try {
            const tableSettingsToStore = {};
            for (const key in tableSettings) {
                if (tableSettings.hasOwnProperty(key) && tableSettings[key]) {
                    tableSettingsToStore[key] = {
                        data: tableSettings[key].data,
                        insertsData: tableSettings[key].insertsData,
                        hasInserts: tableSettings[key].hasInserts,
                        isVisibleInSmartManual: tableSettings[key].isVisibleInSmartManual,
                        manual_insert_location: tableSettings[key].manual_insert_location,
                        manual_insert_after_display_row_number: tableSettings[key].manual_insert_after_display_row_number
                    };
                }
            }
            const stateToSave = {
                listName: document.getElementById('listNameInput').value,
                currentBlindMode: currentBlindMode,
                threeTrackIsIdentical: threeTrackIsIdentical,
                isSideBlindSplit: isSideBlindSplit,
                isFrontRearSeparate: isFrontRearSeparate,
                tableSettings: tableSettingsToStore
            };
            sessionStorage.setItem('blindListAppState', JSON.stringify(stateToSave));
        } catch (error) {
            console.error("Error saving state to sessionStorage:", error);
        }
    }

    function loadStateFromSessionStorage() {
        try {
            const savedStateJSON = sessionStorage.getItem('blindListAppState');
            if (!savedStateJSON) return false;

            const savedState = JSON.parse(savedStateJSON);

            document.getElementById('listNameInput').value = savedState.listName || '';
            currentBlindMode = savedState.currentBlindMode || 'smart'; // Set global var
            threeTrackIsIdentical = savedState.threeTrackIsIdentical === undefined ? true : savedState.threeTrackIsIdentical; // Set global var
            isSideBlindSplit = savedState.isSideBlindSplit || false; // Set global var
            isFrontRearSeparate = savedState.isFrontRearSeparate || false; // Set global var

            const loadedTableSettings = savedState.tableSettings || {};
            ['A', 'B', 'C', 'D', 'E'].forEach(key => {
                if (!tableSettings[key]) { // Should not happen if tableSettings is pre-initialized
                    tableSettings[key] = { data: [], insertsData: [], hasInserts: false, isVisibleInSmartManual: (key !== 'D' && key !== 'E'), sortableInstance: null, sortableInsertsInstance: null, manual_insert_location: 'bottom', manual_insert_after_display_row_number: 0 };
                }
                if (loadedTableSettings[key]) {
                    tableSettings[key].data = loadedTableSettings[key].data || [];
                    tableSettings[key].insertsData = loadedTableSettings[key].insertsData || [];
                    tableSettings[key].hasInserts = loadedTableSettings[key].hasInserts || false;
                    tableSettings[key].isVisibleInSmartManual = loadedTableSettings[key].isVisibleInSmartManual === undefined ? (key !== 'D' && key !== 'E') : !!loadedTableSettings[key].isVisibleInSmartManual;
                    tableSettings[key].manual_insert_location = loadedTableSettings[key].manual_insert_location || 'bottom';
                    tableSettings[key].manual_insert_after_display_row_number = loadedTableSettings[key].manual_insert_after_display_row_number || 0;
                }
                tableSettings[key].sortableInstance = null; // These are not persisted
                tableSettings[key].sortableInsertsInstance = null;
            });

            // Update UI for the mode itself (radio button)
            const modeRadio = document.querySelector(`input[name="blindMode"][value="${currentBlindMode}"]`);
            if (modeRadio) modeRadio.checked = true;

            // Call updateBlindMode to set up general mode containers
            // Pass 'true' to skip its internal rendering/data init logic
            updateBlindMode(currentBlindMode, true);

            // Now, explicitly set the state of specific control checkboxes based on loaded global vars
            if (currentBlindMode === 'threeTrack') {
                const tiCheckbox = document.getElementById('threeTrackIdentical');
                if (tiCheckbox) tiCheckbox.checked = threeTrackIsIdentical;
                handleThreeTrackIdenticalToggle(threeTrackIsIdentical); // Update UI based on this state
            }
            if (currentBlindMode === 'manual') {
                const sbsCheckbox = document.getElementById('isSideBlindSplitCheckbox');
                if (sbsCheckbox) sbsCheckbox.checked = isSideBlindSplit;
                handleSideBlindSplitToggle(isSideBlindSplit, true); // Pass true for isProgrammaticCall

                const frsCheckbox = document.getElementById('isFrontRearSeparateCheckbox');
                if (frsCheckbox) frsCheckbox.checked = isFrontRearSeparate;
                handleFrontRearSeparateToggle(isFrontRearSeparate, true); // Pass true for isProgrammaticCall
            }

            // Set "hasInserts" checkboxes and table visibility checkboxes from loaded tableSettings
            // And then call their respective handlers to update UI
            ['A', 'B', 'C', 'D', 'E'].forEach(setId => {
                if (tableSettings[setId]) {
                    const hiChk = document.getElementById(`hasInserts${setId}`);
                    if (hiChk) hiChk.checked = tableSettings[setId].hasInserts;
                    handleInsertToggle(setId, tableSettings[setId].hasInserts, true); // true for calledDuringSync

                    const stChk = document.getElementById(`showTable${setId}`);
                    if (stChk) stChk.checked = tableSettings[setId].isVisibleInSmartManual;
                    // handleTableVisibilityToggle will be called by handleSideBlindSplitToggle etc. for D, E
                    // and by the final rendering loop for A, B, C if needed.
                }
            });
            
            // Final pass to update all appearances and render visible tables
            updateTableAppearances();
             ['A', 'B', 'C', 'D', 'E'].forEach(setId => {
                if (tableSettings[setId]) {
                    const tableContainer = document.getElementById(`table-container-${setId}`);
                    let shouldBeVisible = false;
                    // Determine visibility based on current mode and states
                    if (currentBlindMode === 'threeTrack') {
                        if (setId === 'A') shouldBeVisible = true;
                        else if (setId === 'B' || setId === 'C') shouldBeVisible = !threeTrackIsIdentical;
                        // D & E are not used in 3-track
                    } else if (currentBlindMode === 'manual') {
                        if (setId === 'D') shouldBeVisible = isSideBlindSplit && tableSettings.D.isVisibleInSmartManual;
                        else if (setId === 'E') shouldBeVisible = isFrontRearSeparate && tableSettings.E.isVisibleInSmartManual;
                        else shouldBeVisible = tableSettings[setId].isVisibleInSmartManual; // For A, B, C
                    } else { // Smart Mode
                         shouldBeVisible = (setId !== 'D' && setId !== 'E') && tableSettings[setId].isVisibleInSmartManual;
                    }

                    if (tableContainer) tableContainer.style.display = shouldBeVisible ? 'block' : 'none';
                    if (shouldBeVisible) renderTable(setId);
                }
            });

            return true;
        } catch (error) {
            console.error("Error loading state from sessionStorage:", error);
            sessionStorage.removeItem('blindListAppState'); // Clear corrupted state
            return false;
        }
    }


    // --- Help Modal Variables & Functions ---
    let helpModalElement;
    let closeHelpModalBtnElement;
    function showHelpModal() { if (helpModalElement) helpModalElement.style.display = "block"; }
    function closeHelpModal() { if (helpModalElement) helpModalElement.style.display = "none"; }

    // --- DOMContentLoaded: Main Setup ---
    document.addEventListener('DOMContentLoaded', () => {
        // Mode Change Listeners
        document.getElementById('smartBlindMode').addEventListener('change', () => { updateBlindMode('smart'); saveStateToSessionStorage(); });
        document.getElementById('manualBlindMode').addEventListener('change', () => { updateBlindMode('manual'); saveStateToSessionStorage(); });
        document.getElementById('threeTrackMode').addEventListener('change', () => {
            document.getElementById('threeTrackMode').justSwitchedTo = true; // Flag for prefill
            updateBlindMode('threeTrack');
            saveStateToSessionStorage();
        });

        // Specific Control Listeners
        document.getElementById('threeTrackIdentical').addEventListener('change', (event) => { handleThreeTrackIdenticalToggle(event.target.checked); saveStateToSessionStorage(); });
        document.getElementById('isSideBlindSplitCheckbox').addEventListener('change', (event) => {
            handleSideBlindSplitToggle(event.target.checked, false); // isProgrammaticCall = false for user interaction
            saveStateToSessionStorage();
        });
        document.getElementById('isFrontRearSeparateCheckbox').addEventListener('change', (event) => {
            handleFrontRearSeparateToggle(event.target.checked, false); // isProgrammaticCall = false for user interaction
            saveStateToSessionStorage();
        });


        // Action Button Listeners
        document.getElementById('copyToBBtn').addEventListener('click', () => { copyFromFirstTrackTo('B'); });
        document.getElementById('copyToCBtn').addEventListener('click', () => { copyFromFirstTrackTo('C'); });

        const fileInput = document.getElementById('blindFileInput');
        if (fileInput) fileInput.addEventListener('change', importFromBLIND);

        helpModalElement = document.getElementById("helpModal");
        closeHelpModalBtnElement = document.getElementById("closeHelpModalBtn");
        const helpButton = document.getElementById("helpButton");
        if (helpButton) helpButton.addEventListener('click', showHelpModal);
        if (closeHelpModalBtnElement) closeHelpModalBtnElement.addEventListener('click', closeHelpModal);
        window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && helpModalElement && helpModalElement.style.display === "block") closeHelpModal(); });
        if (helpModalElement) helpModalElement.addEventListener('click', (e) => { if (e.target === helpModalElement) closeHelpModal(); });

        const listNameInput = document.getElementById('listNameInput');
        if (listNameInput) listNameInput.addEventListener('input', saveStateToSessionStorage);

        ['A', 'B', 'C', 'D', 'E'].forEach(setId => {
            const hasInsertsCheckbox = document.getElementById(`hasInserts${setId}`);
            if (hasInsertsCheckbox && tableSettings[setId]) {
                hasInsertsCheckbox.addEventListener('change', (event) => { handleInsertToggle(setId, event.target.checked); saveStateToSessionStorage(); });
            }
            const showTableCheckbox = document.getElementById(`showTable${setId}`);
            if (showTableCheckbox && tableSettings[setId]) {
                showTableCheckbox.addEventListener('change', (event) => { handleTableVisibilityToggle(setId, event.target.checked); saveStateToSessionStorage(); });
            }
        });

        // Initialize visibility of specific control sections
        const manualSpecificControls = document.getElementById('manualBlindSpecificControlsContainer'); if (manualSpecificControls) manualSpecificControls.style.display = 'none';
        const showTableDSpan = document.getElementById('showTableDSpan'); if (showTableDSpan) showTableDSpan.style.display = 'none';
        const showTableESpan = document.getElementById('showTableESpan'); if (showTableESpan) showTableESpan.style.display = 'none';


        const stateLoaded = loadStateFromSessionStorage();

        if (!stateLoaded) { // If no saved state, initialize with defaults
            updateBlindMode('smart'); // Default to smart mode, this will also call saveState eventually
            saveStateToSessionStorage(); // Ensure a clean state is saved if nothing was loaded
        }
        // If stateLoaded is true, loadStateFromSessionStorage has already called updateBlindMode,
        // set checkboxes, called handlers, and rendered.
    });


    // --- UI Update & State Handler Functions ---

    // MODIFIED updateBlindMode
    function updateBlindMode(newMode, skipRenderOrInitialLoad = false) {
        const previousMode = currentBlindMode;
        currentBlindMode = newMode; // Set global currentBlindMode

        const threeTrackGlobalControlsDiv = document.getElementById('threeTrackGlobalControls');
        const tableVisibilityControlsDiv = document.getElementById('tableVisibilityControls');
        const manualBlindSpecificControlsContainer = document.getElementById('manualBlindSpecificControlsContainer');
        const copyToBBtn = document.getElementById('copyToBBtn');
        const copyToCBtn = document.getElementById('copyToCBtn');

        // Hide all mode-specific controls and optional tables initially
        if (threeTrackGlobalControlsDiv) threeTrackGlobalControlsDiv.style.display = 'none';
        if (tableVisibilityControlsDiv) tableVisibilityControlsDiv.style.display = 'none'; // This will be shown by mode logic if needed
        if (manualBlindSpecificControlsContainer) manualBlindSpecificControlsContainer.style.display = 'none';
        if (copyToBBtn) copyToBBtn.style.display = 'none';
        if (copyToCBtn) copyToCBtn.style.display = 'none';

        // Default table visibility (some will be overridden by specific mode logic or toggles)
        // Main tables A, B, C usually visible by default unless in 3-track identical.
        // D & E start hidden.
        document.getElementById('table-container-A').style.display = 'block';
        document.getElementById('table-container-B').style.display = (newMode === 'threeTrack' && threeTrackIsIdentical) ? 'none' : 'block';
        document.getElementById('table-container-C').style.display = (newMode === 'threeTrack' && threeTrackIsIdentical) ? 'none' : 'block';
        document.getElementById('table-container-D').style.display = 'none';
        document.getElementById('table-container-E').style.display = 'none';


        if (newMode === 'manual') {
            if (manualBlindSpecificControlsContainer) manualBlindSpecificControlsContainer.style.display = 'flex';
            if (tableVisibilityControlsDiv) tableVisibilityControlsDiv.style.display = 'flex';
            // Visibility of D and E containers will be handled by handleSideBlindSplitToggle / handleFrontRearSeparateToggle
        } else if (newMode === 'threeTrack') {
            if (threeTrackGlobalControlsDiv) threeTrackGlobalControlsDiv.style.display = 'flex';
            // tableVisibilityControlsDiv is not typically shown for 3-track
        } else { // Smart Mode
            if (tableVisibilityControlsDiv) tableVisibilityControlsDiv.style.display = 'flex';
        }

        // If switching AWAY from manual mode, ensure its specific states are reset.
        if (previousMode === 'manual' && newMode !== 'manual') {
            const sbsChk = document.getElementById('isSideBlindSplitCheckbox');
            if (sbsChk) sbsChk.checked = false;
            isSideBlindSplit = false; // Update global state

            const frsChk = document.getElementById('isFrontRearSeparateCheckbox');
            if (frsChk) frsChk.checked = false;
            isFrontRearSeparate = false; // Update global state

            // Explicitly call handlers to update UI for these states now being false.
            if (typeof handleSideBlindSplitToggle === "function") handleSideBlindSplitToggle(false, true); // isProgrammaticCall = true
            if (typeof handleFrontRearSeparateToggle === "function") handleFrontRearSeparateToggle(false, true); // isProgrammaticCall = true
        }

        // Logic for 3-track prefill if just switched to it
        if (newMode === 'threeTrack' && document.getElementById('threeTrackMode').justSwitchedTo && !skipRenderOrInitialLoad) {
            if (tableSettings.A) tableSettings.A.data = getThreeTrackPrefillData(); else console.error("tableSettings.A is undefined in 3-track prefill");
            ['B', 'C', 'D', 'E'].forEach(id => { if (tableSettings[id]) tableSettings[id].data = []; });
            const tiChk = document.getElementById('threeTrackIdentical');
            if (tiChk) tiChk.checked = true;
            threeTrackIsIdentical = true; // Set global state
            if (typeof handleThreeTrackIdenticalToggle === "function") handleThreeTrackIdenticalToggle(true); // Update UI for identical tracks
        }
        if (document.getElementById('threeTrackMode')) document.getElementById('threeTrackMode').justSwitchedTo = false;


        // Handle insert UI consistently across modes
        ['A', 'B', 'C', 'D', 'E'].forEach(setId => {
            if (tableSettings[setId]) {
                // Reset hasInserts if mode changes in a way that affects insert behavior (e.g., from manual to smart)
                if (!skipRenderOrInitialLoad && (currentBlindMode === 'smart' || currentBlindMode === 'manual') && !(previousMode === currentBlindMode && previousMode !== 'threeTrack')) {
                    const hasInsertsChk = document.getElementById(`hasInserts${setId}`);
                    if (hasInsertsChk) { // Only if checkbox exists for this table
                        hasInsertsChk.checked = false; // Uncheck it
                        tableSettings[setId].hasInserts = false; // Update underlying setting
                        if (typeof handleInsertToggle === "function") handleInsertToggle(setId, false, true); // Update UI, calledDuringSync=true
                    }
                } else if (tableSettings[setId].hasInserts) { // If inserts are enabled, ensure UI reflects it
                     if (typeof handleInsertToggle === "function") handleInsertToggle(setId, tableSettings[setId].hasInserts, true);
                }


                const insertsSubContainer = document.getElementById(`inserts-table-sub-container-${setId}`);
                if (insertsSubContainer) insertsSubContainer.style.display = (currentBlindMode === 'smart' && tableSettings[setId].hasInserts) ? 'block' : 'none';

                const addTopInsertBtn = document.getElementById(`addTopInsert${setId}`);
                if (addTopInsertBtn) addTopInsertBtn.style.display = ((currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') && tableSettings[setId].hasInserts) ? 'inline-block' : 'none';
            }
        });

        updateTableAppearances(); // Update titles, button texts etc.

        // General rendering calls after mode switch, if not skipped
        // More specific rendering is handled by load/import or individual toggle handlers
        if (!skipRenderOrInitialLoad) {
            if (currentBlindMode === 'threeTrack') {
                // handleThreeTrackIdenticalToggle (called above if justSwitchedTo) will manage rendering A, B, C
            } else { // Smart or Manual
                // For a direct mode switch by user, re-evaluate visibility of A, B, C based on their checkboxes
                ['A', 'B', 'C'].forEach(setId => {
                    if (tableSettings[setId]) {
                        const showCheckbox = document.getElementById(`showTable${setId}`);
                        const isChecked = showCheckbox ? showCheckbox.checked : tableSettings[setId].isVisibleInSmartManual;
                        handleTableVisibilityToggle(setId, isChecked); // This will also render if visible
                    }
                });
                // D and E visibility is handled by their respective split toggles if in manual mode
                if (currentBlindMode === 'manual') {
                    if (typeof handleSideBlindSplitToggle === "function") handleSideBlindSplitToggle(isSideBlindSplit, true);
                    if (typeof handleFrontRearSeparateToggle === "function") handleFrontRearSeparateToggle(isFrontRearSeparate, true);
                }
            }
        }
    }


    function handleTableVisibilityToggle(setId, isVisible) {
        if (!tableSettings[setId]) return;

        if (currentBlindMode === 'smart' || currentBlindMode === 'manual') {
            tableSettings[setId].isVisibleInSmartManual = isVisible;
            const tableContainer = document.getElementById(`table-container-${setId}`);
            if (tableContainer) {
                let actualDisplay = false;
                if (setId === 'D') {
                    actualDisplay = currentBlindMode === 'manual' && isSideBlindSplit && isVisible;
                } else if (setId === 'E') {
                    actualDisplay = currentBlindMode === 'manual' && isFrontRearSeparate && isVisible;
                } else { // For A, B, C in Smart/Manual
                    actualDisplay = isVisible;
                }

                tableContainer.style.display = actualDisplay ? 'block' : 'none';

                if (actualDisplay && typeof renderTable === "function") {
                    renderTable(setId);
                } else if (!actualDisplay) { // Clear table if hidden
                    const tableBodyClear = document.getElementById(`table-body-${setId}`); if (tableBodyClear) tableBodyClear.innerHTML = '';
                    const insertsTableBodyClear = document.getElementById(`table-body-inserts-${setId}`); if (insertsTableBodyClear) insertsTableBodyClear.innerHTML = '';
                }
            }
        }
        // For 3-track, visibility of B & C is handled by handleThreeTrackIdenticalToggle directly.
        // Table A in 3-track is generally always 'block' conceptually, then rendered.
    }


    function updateTableAppearances() {
        ['A', 'B', 'C', 'D', 'E'].forEach(setId => {
            const titleEl = document.getElementById(`table-title-${setId}`);
            const headerEl = document.getElementById(`table-header-data-${setId}`);
            const addBtnEl = document.getElementById(`addDataRowBtn${setId}`);
            const insertTitleEl = document.getElementById(`inserts-title-${setId}`);
            const smartInsertHeaderEl = document.getElementById(`table-header-inserts-data-${setId}`);
            const showTableLabelEl = document.getElementById(`showTable${setId}Label`);

            let appearance = originalTableAppearances[setId];
            let currentTitleForLabel = appearance ? appearance.title : `Table ${setId}`; // Fallback

            if (currentBlindMode === 'manual') {
                if (setId === 'A' && isFrontRearSeparate && appearance) {
                    currentTitleForLabel = appearance.altTitle || appearance.title;
                    appearance = { ...originalTableAppearances.A, title: originalTableAppearances.A.altTitle, header: originalTableAppearances.A.altHeader, addBtn: originalTableAppearances.A.altAddBtn, insertsTitle: originalTableAppearances.A.altInsertsTitle };
                } else if (setId === 'C' && isSideBlindSplit && appearance) {
                    currentTitleForLabel = appearance.altTitle || appearance.title;
                    appearance = { ...originalTableAppearances.C, title: originalTableAppearances.C.altTitle, header: originalTableAppearances.C.altHeader, addBtn: originalTableAppearances.C.altAddBtn, insertsTitle: originalTableAppearances.C.altInsertsTitle };
                } else if (originalTableAppearances[setId]) { // Ensure we use original for D, E if no specific override
                     currentTitleForLabel = originalTableAppearances[setId].title;
                     appearance = originalTableAppearances[setId];
                }
            } else if (currentBlindMode === 'threeTrack') {
                if (setId === 'D' || setId === 'E') { // D & E not used in 3-track, set default titles and return
                    if(titleEl && originalTableAppearances[setId]) titleEl.textContent = originalTableAppearances[setId].title;
                    if(showTableLabelEl && originalTableAppearances[setId]) showTableLabelEl.textContent = originalTableAppearances[setId].title;
                    return;
                }
                if (threeTrackIsIdentical) {
                    if (setId === 'A') appearance = threeTrackIdenticalAppearance;
                    else if (threeTrackAppearances[setId]) appearance = threeTrackAppearances[setId]; // B, C would use their individual if somehow visible
                } else {
                    if (threeTrackAppearances[setId]) appearance = threeTrackAppearances[setId];
                }
                currentTitleForLabel = appearance ? appearance.title : `Track ${setId}`;
            } else { // Smart Mode
                 if (originalTableAppearances[setId]) {
                     currentTitleForLabel = originalTableAppearances[setId].title;
                     appearance = originalTableAppearances[setId];
                 }
            }

            if (showTableLabelEl && currentTitleForLabel) showTableLabelEl.textContent = currentTitleForLabel;
            if (titleEl && appearance) titleEl.textContent = appearance.title;
            if (headerEl && appearance) headerEl.textContent = appearance.header;
            if (addBtnEl && appearance) addBtnEl.textContent = appearance.addBtn;
            if (insertTitleEl && appearance) insertTitleEl.textContent = appearance.insertsTitle;
            if (smartInsertHeaderEl && appearance && appearance.header) smartInsertHeaderEl.textContent = `${appearance.header} (Insert)`;
        });
    }

    function handleThreeTrackIdenticalToggle(isIdentical) {
        threeTrackIsIdentical = isIdentical; // Update global state
        const copyToBBtn = document.getElementById('copyToBBtn');
        const copyToCBtn = document.getElementById('copyToCBtn');
        const tableAContainer = document.getElementById('table-container-A');
        const tableBContainer = document.getElementById('table-container-B');
        const tableCContainer = document.getElementById('table-container-C');

        if (tableAContainer) tableAContainer.style.display = 'block'; // A is always shown conceptually

        if (isIdentical) {
            if (tableBContainer) tableBContainer.style.display = 'none';
            if (tableCContainer) tableCContainer.style.display = 'none';
            if (copyToBBtn) copyToBBtn.style.display = 'none';
            if (copyToCBtn) copyToCBtn.style.display = 'none';
        } else {
            if (tableBContainer) tableBContainer.style.display = 'block';
            if (tableCContainer) tableCContainer.style.display = 'block';
            if (copyToBBtn) copyToBBtn.style.display = 'inline-block';
            if (copyToCBtn) copyToCBtn.style.display = 'inline-block';
        }
        updateTableAppearances();
        if (typeof renderTable === "function") {
            renderTable('A');
            if (!isIdentical) {
                if (tableBContainer && tableBContainer.style.display === 'block') renderTable('B'); else { const bBody = document.getElementById('table-body-B'); if(bBody) bBody.innerHTML = '';}
                if (tableCContainer && tableCContainer.style.display === 'block') renderTable('C'); else { const cBody = document.getElementById('table-body-C'); if(cBody) cBody.innerHTML = '';}
            } else { // Clear B and C if now identical
                const bBody = document.getElementById('table-body-B'); if(bBody) bBody.innerHTML = '';
                const cBody = document.getElementById('table-body-C'); if(cBody) cBody.innerHTML = '';
            }
        }
    }

    function copyFromFirstTrackTo(targetSetId) {
        if (currentBlindMode !== 'threeTrack' || threeTrackIsIdentical || (targetSetId !== 'B' && targetSetId !== 'C')) return;
        const sourceTitle = document.getElementById('table-title-A') ? document.getElementById('table-title-A').textContent : "Track 1";
        const targetTitle = document.getElementById(`table-title-${targetSetId}`) ? document.getElementById(`table-title-${targetSetId}`).textContent : `Track ${targetSetId}`;

        if (!confirm(`Overwrite ${targetTitle} with contents of ${sourceTitle}?`)) return;

        if (tableSettings.A && tableSettings[targetSetId]) {
            tableSettings[targetSetId].data = JSON.parse(JSON.stringify(tableSettings.A.data)).map(item => ({ ...item, id: generateUUID() }));
            tableSettings[targetSetId].hasInserts = tableSettings.A.hasInserts;
            const targetHasInsertsCheckbox = document.getElementById(`hasInserts${targetSetId}`);
            if (targetHasInsertsCheckbox) targetHasInsertsCheckbox.checked = tableSettings.A.hasInserts;
            
            handleInsertToggle(targetSetId, tableSettings.A.hasInserts, true); // true for calledDuringSync

            if (typeof renderTable === "function") renderTable(targetSetId);
            saveStateToSessionStorage();
        }
    }

    // REFINED handleSideBlindSplitToggle
    function handleSideBlindSplitToggle(isSplit, isProgrammaticCall = false) {
        isSideBlindSplit = isSplit; // Update global state

        const showTableDSpan = document.getElementById('showTableDSpan'); // The span containing "Show Table D" checkbox
        if (showTableDSpan) {
            showTableDSpan.style.display = (currentBlindMode === 'manual' && isSplit) ? 'inline-flex' : 'none';
        }

        updateTableAppearances(); // Update table titles etc.

        // Update visibility of Table C based on its own checkbox
        const showTableCCheckbox = document.getElementById('showTableC');
        if (showTableCCheckbox && tableSettings.C && typeof handleTableVisibilityToggle === "function") {
            handleTableVisibilityToggle('C', showTableCCheckbox.checked);
        }

        const showTableDCheckbox = document.getElementById('showTableD'); // The "Show Table D" checkbox itself

        if (currentBlindMode === 'manual' && isSplit) { // If enabling side split in manual mode
            if (showTableDCheckbox && tableSettings.D) {
                // If this function was called due to a direct user click on "Is Side Blind Split?"
                // (i.e., not a programmatic call during import or session load),
                // then we default "Show Table D" to be checked.
                if (!isProgrammaticCall) {
                    showTableDCheckbox.checked = true;
                    tableSettings.D.isVisibleInSmartManual = true; // Reflect this in the setting
                }
                // Ensure Table D's visibility is updated based on the (possibly just changed) "Show Table D" checkbox state
                if (typeof handleTableVisibilityToggle === "function") {
                    handleTableVisibilityToggle('D', showTableDCheckbox.checked);
                }
            }
        } else { // Not manual mode OR isSplit is false (disabling side split)
            if (typeof handleTableVisibilityToggle === "function") {
                handleTableVisibilityToggle('D', false); // Hide Table D container
            }
            if (showTableDCheckbox) {
                showTableDCheckbox.checked = false; // Uncheck "Show Table D"
            }
            if (tableSettings.D) {
                tableSettings.D.isVisibleInSmartManual = false; // Update the setting
            }
        }
    }

    // REFINED handleFrontRearSeparateToggle (similar pattern to side split)
    function handleFrontRearSeparateToggle(isSeparate, isProgrammaticCall = false) {
        isFrontRearSeparate = isSeparate; // Update global state

        const showTableESpan = document.getElementById('showTableESpan'); // The span for "Show Table E"
        if (showTableESpan) {
            showTableESpan.style.display = (currentBlindMode === 'manual' && isSeparate) ? 'inline-flex' : 'none';
        }

        updateTableAppearances();

        // Update visibility of Table A based on its own checkbox
        const showTableACheckbox = document.getElementById('showTableA');
        if (showTableACheckbox && tableSettings.A && typeof handleTableVisibilityToggle === "function") {
            handleTableVisibilityToggle('A', showTableACheckbox.checked);
        }

        const showTableECheckbox = document.getElementById('showTableE'); // The "Show Table E" checkbox

        if (currentBlindMode === 'manual' && isSeparate) { // If enabling front/rear separate in manual mode
            if (showTableECheckbox && tableSettings.E) {
                if (!isProgrammaticCall) { // User manually clicked "Is Front & Rear Separate?"
                    showTableECheckbox.checked = true;
                    tableSettings.E.isVisibleInSmartManual = true;
                }
                if (typeof handleTableVisibilityToggle === "function") {
                    handleTableVisibilityToggle('E', showTableECheckbox.checked);
                }
            }
        } else { // Not manual mode OR isSeparate is false
            if (typeof handleTableVisibilityToggle === "function") {
                handleTableVisibilityToggle('E', false); // Hide Table E
            }
            if (showTableECheckbox) {
                showTableECheckbox.checked = false;
            }
            if (tableSettings.E) {
                tableSettings.E.isVisibleInSmartManual = false;
            }
        }
    }


    function clearTableData(setId) {
        if (!tableSettings[setId]) return;
        const tableName = document.getElementById(`table-title-${setId}`)?.textContent || `Table ${setId}`;
        if (!confirm(`Are you sure you want to clear all data and inserts for ${tableName}?`)) return;

        tableSettings[setId].data = [];
        tableSettings[setId].insertsData = [];
        const hasInsertsCheckbox = document.getElementById(`hasInserts${setId}`);
        if (hasInsertsCheckbox) {
            tableSettings[setId].hasInserts = false;
            hasInsertsCheckbox.checked = false;
        }
        handleInsertToggle(setId, false, true); // Update UI, calledDuringSync = true

        if (typeof renderTable === "function") renderTable(setId);
        saveStateToSessionStorage();
    }

    function handleInsertToggle(setId, isChecked, calledDuringSync = false) {
        if (!tableSettings[setId]) return;
        tableSettings[setId].hasInserts = isChecked;

        const insertsSubContainer = document.getElementById(`inserts-table-sub-container-${setId}`);
        const addTopInsertButton = document.getElementById(`addTopInsert${setId}`);
        const addSmartInsertButton = document.getElementById(`addSmartInsertBtn${setId}`); // For Smartblind inserts table
        const addQtySmartInsertParent = insertsSubContainer ? insertsSubContainer.querySelector('.multiple-add-control') : null;


        if (currentBlindMode === 'smart') {
            if (insertsSubContainer) insertsSubContainer.style.display = isChecked ? 'block' : 'none';
            if (addTopInsertButton) addTopInsertButton.style.display = 'none'; // Not used in smart mode

            // Controls for the separate smart inserts table
            if (addSmartInsertButton) addSmartInsertButton.style.visibility = isChecked ? 'visible' : 'hidden';
            if (addQtySmartInsertParent) addQtySmartInsertParent.style.visibility = isChecked ? 'visible' : 'hidden';


            const smartInsertsTableBody = document.getElementById(`table-body-inserts-${setId}`);
            if (isChecked && !tableSettings[setId].sortableInsertsInstance && smartInsertsTableBody && typeof initializeSortableForTable === "function") {
                initializeSortableForTable(setId, true); // true for inserts table
            } else if (!isChecked && tableSettings[setId].sortableInsertsInstance) {
                tableSettings[setId].sortableInsertsInstance.destroy();
                tableSettings[setId].sortableInsertsInstance = null;
                if (!calledDuringSync) tableSettings[setId].insertsData = []; // Clear data if unchecked manually
            }
            if (isChecked && !calledDuringSync) renderTable(setId); // Re-render main table to show insert separator and fixed rows correctly
            else if (!isChecked && !calledDuringSync) renderTable(setId);


        } else { // Manual or 3-Track
            if (insertsSubContainer) insertsSubContainer.style.display = 'none'; // No separate inserts table
            if (addSmartInsertButton) addSmartInsertButton.style.visibility = 'hidden';
            if (addQtySmartInsertParent) addQtySmartInsertParent.style.visibility = 'hidden';

            if (addTopInsertButton) addTopInsertButton.style.display = isChecked ? 'inline-block' : 'none';
            if (!calledDuringSync) { // Only re-render if not part of a sync operation (like mode switch)
                // If inserts are disabled, remove existing insert-type rows
                if (!isChecked && tableSettings[setId].data.some(item => item.type === 'insert')) {
                    tableSettings[setId].data = tableSettings[setId].data.filter(item => item.type !== 'insert');
                }
                renderTable(setId);
            }
        }
        if (!calledDuringSync && (currentBlindMode === 'smart')) { // For smart mode, rendering might need to happen in both cases
             renderTable(setId); // Render to update smartblind table structure (0/511 rows, separator)
        }
    }


    function getPlaceholderText(setId, isInsert = false, itemType = 'main') {
        let baseText = 'Value';
        let currentAppearance = originalTableAppearances[setId];

        if (currentBlindMode === 'manual') {
            if (setId === 'A' && isFrontRearSeparate && originalTableAppearances.A) currentAppearance = { ...originalTableAppearances.A, header: originalTableAppearances.A.altHeader || originalTableAppearances.A.header };
            else if (setId === 'C' && isSideBlindSplit && originalTableAppearances.C) currentAppearance = { ...originalTableAppearances.C, header: originalTableAppearances.C.altHeader || originalTableAppearances.C.header };
        } else if (currentBlindMode === 'threeTrack') {
            if (setId === 'D' || setId === 'E') return "N/A";
            if (threeTrackIsIdentical && setId === 'A') currentAppearance = threeTrackIdenticalAppearance;
            else if (threeTrackAppearances[setId]) currentAppearance = threeTrackAppearances[setId];
        }
        baseText = currentAppearance && currentAppearance.header ? currentAppearance.header : 'Value';

        if (isInsert || itemType === 'insert') {
            if (currentBlindMode === 'smart') return `Enter ${baseText} (Smart Insert)`;
            return `Enter ${baseText} (Insert)`;
        }
        return `Enter ${baseText}`;
    }


    // --- PART 2: Detailed Table Operations, Rendering, Import/Export --- (Continued)
    function renderTable(setId) {
        const tableContainer = document.getElementById(`table-container-${setId}`);
        if (!tableContainer || tableContainer.style.display === 'none') {
            const tableBodyClear = document.getElementById(`table-body-${setId}`); if (tableBodyClear) tableBodyClear.innerHTML = '';
            const insertsTableBodyClear = document.getElementById(`table-body-inserts-${setId}`); if (insertsTableBodyClear) insertsTableBodyClear.innerHTML = '';
            return;
        }

        const tableBody = document.getElementById(`table-body-${setId}`);
        const settings = tableSettings[setId];
        if (!settings) { if (tableBody) tableBody.innerHTML = ''; console.warn(`renderTable for non-existent settings: ${setId}`); return; }

        const mainDataArray = settings.data;
        if (!tableBody) { console.error(`Table body not found for ${setId}`); return; }
        tableBody.innerHTML = '';

        const smartInsertsTableBody = document.getElementById(`table-body-inserts-${setId}`);
        if (smartInsertsTableBody) smartInsertsTableBody.innerHTML = '';


        const addTopInsertButton = document.getElementById(`addTopInsert${setId}`);
        if (addTopInsertButton) {
            addTopInsertButton.style.display = ((currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') && settings.hasInserts) ? 'inline-block' : 'none';
        }

        if (currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') {
            mainDataArray.forEach(item => {
                if (!item.type) item.type = 'main';
                delete item.actualMainNumber; delete item.potentialParentMainNumber;
                if (item.insertSubtype === 'top' || item.insertSubtype === 'continuous_end') delete item.parentMainItemNumber;
            });
            let lastMainItemActualNum = 0; let currentOverallMainSeqNum = 0;
            for (let i = 0; i < mainDataArray.length; i++) {
                const item = mainDataArray[i];
                if (item.type === 'main') { currentOverallMainSeqNum++; item.actualMainNumber = currentOverallMainSeqNum; lastMainItemActualNum = item.actualMainNumber; }
                else if (item.type === 'insert' && item.insertSubtype !== 'top') item.potentialParentMainNumber = lastMainItemActualNum;
            }
            for (let i = 0; i < mainDataArray.length; i++) {
                const item = mainDataArray[i];
                if (item.type === 'insert') {
                    if (item.insertSubtype === 'continuous_end') {
                        let mainItemFollows = false; for (let j = i + 1; j < mainDataArray.length; j++) if (mainDataArray[j].type === 'main') { mainItemFollows = true; break; }
                        if (mainItemFollows) { item.insertSubtype = 'middle'; item.parentMainItemNumber = item.potentialParentMainNumber > 0 ? item.potentialParentMainNumber : undefined; if (item.parentMainItemNumber === undefined) { item.insertSubtype = 'top'; delete item.parentMainItemNumber; } }
                    }
                    if (item.insertSubtype === 'middle') { if (item.parentMainItemNumber === undefined || item.parentMainItemNumber === 0) { item.parentMainItemNumber = item.potentialParentMainNumber > 0 ? item.potentialParentMainNumber : undefined; if (item.parentMainItemNumber === undefined) item.insertSubtype = 'top'; } }
                    if (item.insertSubtype === 'middle' || item.insertSubtype === 'top') delete item.actualMainNumber;
                }
            }
            currentOverallMainSeqNum = 0; mainDataArray.forEach(item => {
                if (item.type === 'main') { currentOverallMainSeqNum++; item.actualMainNumber = currentOverallMainSeqNum; }
                else if (item.type === 'insert' && item.insertSubtype === 'continuous_end') { currentOverallMainSeqNum++; item.actualMainNumber = currentOverallMainSeqNum; }
            });
        }

        if (currentBlindMode === 'smart' && (setId === 'A' || setId === 'B' || setId === 'C')) {
            tableBody.appendChild(createFixedRowElement(SMART_DELIMITER_0_DISPLAY_TEXT, SMART_DELIMITER_0_NUM, setId));
            mainDataArray.forEach((item, index) => {
                item.actualMainNumber = index + 1;
                tableBody.appendChild(createEditableRowElement(item, item.actualMainNumber, setId, false, false, index === mainDataArray.length - 1));
            });

            const insertsSubContainer = document.getElementById(`inserts-table-sub-container-${setId}`);
            const smartInsertsDataArray = settings.insertsData;
            if (settings.hasInserts && insertsSubContainer) { // insertsSubContainer check is important
                insertsSubContainer.style.display = 'block'; // Ensure visible if hasInserts
                if (smartInsertsTableBody) { // Only proceed if the body element exists
                    let insertNumberBase = mainDataArray.length + 1;
                    smartInsertsDataArray.forEach((item, index) => {
                        smartInsertsTableBody.appendChild(createEditableRowElement(item, insertNumberBase + index, setId, true, false, index === smartInsertsDataArray.length - 1));
                    });
                     // The 511 delimiter is added to the smartInsertsTableBody if inserts are active
                    smartInsertsTableBody.appendChild(createFixedRowElement(SMART_DELIMITER_511_DISPLAY_TEXT, SMART_DELIMITER_511_NUM, setId));

                    if (!settings.sortableInsertsInstance && smartInsertsTableBody.children.length > 1) { // Check children.length > 1 to avoid sortable on only fixed row
                        initializeSortableForTable(setId, true);
                    }
                }
            } else { // No inserts or container missing
                if(insertsSubContainer) insertsSubContainer.style.display = 'none';
                // If no smart inserts, the 511 delimiter is added to the main tableBody
                tableBody.appendChild(createFixedRowElement(SMART_DELIMITER_511_DISPLAY_TEXT, SMART_DELIMITER_511_NUM, setId));
            }
        } else if (currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') {
            if (currentBlindMode === 'threeTrack' && (setId === 'D' || setId === 'E')) return;

            const insertsSubContainer = document.getElementById(`inserts-table-sub-container-${setId}`);
            if (insertsSubContainer) insertsSubContainer.style.display = 'none'; // No separate table for these modes

            let topInsertCounter = 0;
            let tempMiddleInsertLetterMap = {};
            mainDataArray.forEach((item, index) => {
                let displayNumber = "";
                let isManualInsertStyled = item.type === 'insert';
                if (item.type === 'insert' && item.insertSubtype === 'top') displayNumber = String.fromCharCode(65 + topInsertCounter++);
                else if (item.type === 'main' || (item.type === 'insert' && item.insertSubtype === 'continuous_end')) { displayNumber = item.actualMainNumber; if (item.actualMainNumber !== undefined) tempMiddleInsertLetterMap[item.actualMainNumber] = 0; }
                else if (item.type === 'insert' && item.insertSubtype === 'middle') { const pNum = item.parentMainItemNumber; if (pNum !== undefined && pNum > 0 && tempMiddleInsertLetterMap.hasOwnProperty(pNum)) { const lIdx = tempMiddleInsertLetterMap[pNum]; displayNumber = `${pNum}${String.fromCharCode(65 + lIdx)}`; tempMiddleInsertLetterMap[pNum]++; } else displayNumber = `Ins(ErrP:${pNum})`; }

                if (displayNumber !== undefined && String(displayNumber).length > 0) tableBody.appendChild(createEditableRowElement(item, displayNumber, setId, false, isManualInsertStyled, index === mainDataArray.length - 1));
                else if (item.type === 'main') tableBody.appendChild(createEditableRowElement(item, `M?${mainDataArray.indexOf(item) + 1}`, setId, false, false, index === mainDataArray.length - 1)); // Fallback if numbering fails
                else tableBody.appendChild(createEditableRowElement(item, "??", setId, false, isManualInsertStyled, index === mainDataArray.length - 1)); // Fallback
            });
        }
        // Initialize sortable for the main table body if not already done and has children
        if (settings && !settings.sortableInstance && tableBody.children.length > 0 && !Array.from(tableBody.children).every(c => c.classList.contains('fixed-row'))) {
            initializeSortableForTable(setId, false);
        }
    }


    function createFixedRowElement(textDisplay, numberCellText, setId) {
        const fixedRow = document.createElement('tr'); fixedRow.className = 'fixed-row';
        fixedRow.insertCell().innerHTML = '&nbsp;'; fixedRow.cells[0].className = 'col-drag-cell fixed-row-drag-cell';
        fixedRow.insertCell().textContent = numberCellText; fixedRow.cells[1].className = 'col-num-cell fixed-row-num-cell';
        fixedRow.insertCell().textContent = textDisplay; fixedRow.cells[2].className = 'col-data-wide fixed-text-cell';
        fixedRow.insertCell().innerHTML = '&nbsp;'; fixedRow.cells[3].className = 'col-action-narrow col-action-cell fixed-row-action-cell';
        return fixedRow;
    }

    function createEditableRowElement(itemData, displayNumber, setId, isSmartInsertTable, isManualInsertStyled = false, isLastRow = false) {
        const tr = document.createElement('tr'); tr.dataset.id = itemData.id;
        if (isManualInsertStyled || (isSmartInsertTable && currentBlindMode === 'smart')) tr.classList.add('insert-row');

        const dragCell = tr.insertCell(); dragCell.className = 'col-drag-cell';
        const dragHandle = document.createElement('span'); dragHandle.className = 'drag-handle'; dragHandle.innerHTML = '&#9776;'; dragHandle.title = 'Drag to reorder';
        dragCell.appendChild(dragHandle);

        const numCell = tr.insertCell(); numCell.textContent = displayNumber; numCell.style.textAlign = 'center'; numCell.className = 'col-num-cell';
        const dataCell = tr.insertCell(); dataCell.className = 'col-data-wide';

        let inputElement;
        const commonPlaceholder = getPlaceholderText(setId, isSmartInsertTable || itemData.type === 'insert', itemData.type);
        const commonValue = itemData.value || '';
        const commonOnInput = () => { itemData.value = inputElement.value; saveStateToSessionStorage(); };

        if (setId === 'A' && currentBlindMode === 'manual' && isFrontRearSeparate && !isSmartInsertTable && itemData.type !== 'insert') {
            inputElement = document.createElement('textarea');
            inputElement.rows = 2;
        } else {
            inputElement = document.createElement('input');
            inputElement.type = 'text';
        }
        inputElement.placeholder = commonPlaceholder;
        inputElement.value = commonValue;
        inputElement.oninput = commonOnInput;
        dataCell.appendChild(inputElement);

        if (isLastRow) inputElement.addEventListener('keydown', (event) => handleTabOnLastInput(event, setId, isSmartInsertTable));

        const actionCell = tr.insertCell(); actionCell.className = 'col-action-narrow col-action-cell';
        if ((currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') && tableSettings[setId] && tableSettings[setId].hasInserts && (itemData.type === 'main' || (itemData.type === 'insert' && itemData.insertSubtype === 'continuous_end'))) {
            const addInsertButton = document.createElement('button'); addInsertButton.textContent = '+ Insert';
            addInsertButton.title = 'Add an insert item after this row'; addInsertButton.classList.add('small-add-insert-button');
            const parentNumForInsert = itemData.actualMainNumber !== undefined ? itemData.actualMainNumber : displayNumber; // Use actualMainNumber if available
            addInsertButton.onclick = () => addInsertAfterRow(setId, itemData.id, parentNumForInsert);
            actionCell.appendChild(addInsertButton);
        }
        const deleteButton = document.createElement('button'); deleteButton.textContent = 'Delete';
        deleteButton.classList.add('small-danger-button');
        deleteButton.onclick = () => {
            if (!tableSettings[setId]) return;
            let arrayToModify = (currentBlindMode === 'smart' && isSmartInsertTable) ? tableSettings[setId].insertsData : tableSettings[setId].data;
            const itemIndex = arrayToModify.findIndex(d => d.id === itemData.id);
            if (itemIndex > -1) {
                if ((currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') && !isSmartInsertTable && (itemData.type === 'main' || (itemData.type === 'insert' && itemData.insertSubtype === 'continuous_end'))) {
                    const mainNumToDelete = itemData.actualMainNumber; // Use the calculated actualMainNumber
                    tableSettings[setId].data = tableSettings[setId].data.filter(item =>
                        item.id !== itemData.id && !(item.type === 'insert' && item.insertSubtype === 'middle' && item.parentMainItemNumber === mainNumToDelete)
                    );
                } else {
                    arrayToModify.splice(itemIndex, 1);
                }
            }
            if (typeof renderTable === "function") renderTable(setId);
            saveStateToSessionStorage();
        };
        actionCell.appendChild(deleteButton);
        return tr;
    }

    function handleTabOnLastInput(event, setId, isSmartInsertTable) {
        if (event.key === 'Tab' && !event.shiftKey) {
            event.preventDefault(); let newRowAdded = false;
            if (isSmartInsertTable) { if (currentBlindMode === 'smart' && tableSettings[setId] && tableSettings[setId].hasInserts) { addInsertDataRow(setId); newRowAdded = true; } }
            else { if (tableSettings[setId]) { addDataRow(setId); newRowAdded = true; } }

            if (newRowAdded) {
                setTimeout(() => {
                    const tableBodyId = isSmartInsertTable ? `table-body-inserts-${setId}` : `table-body-${setId}`;
                    const tableBody = document.getElementById(tableBodyId);
                    if (tableBody && tableBody.lastElementChild) {
                        let targetRowForFocus = tableBody.lastElementChild;
                        // Skip any fixed rows at the end (like smartblind's 511)
                        while (targetRowForFocus && targetRowForFocus.classList.contains('fixed-row')) {
                            targetRowForFocus = targetRowForFocus.previousElementSibling;
                        }
                        if (targetRowForFocus && !targetRowForFocus.classList.contains('fixed-row') && targetRowForFocus.cells.length > 2) {
                            const lastRowInput = targetRowForFocus.cells[2].querySelector('input, textarea');
                            if (lastRowInput) lastRowInput.focus();
                        }
                    }
                }, 0);
            }
        }
    }

    function addTopInsert(setId) {
        if (!tableSettings[setId] || !((currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') && tableSettings[setId].hasInserts)) {
            alert("Top inserts can only be added in Manual or 3-Track mode when inserts are enabled for the table."); return;
        }
        tableSettings[setId].data.unshift({ id: generateUUID(), value: '', type: 'insert', insertSubtype: 'top' });
        if (typeof renderTable === "function") renderTable(setId); saveStateToSessionStorage();
    }

    function addInsertAfterRow(setId, parentItemId, parentActualNumberForInsert) {
        if (!tableSettings[setId] || !((currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') && tableSettings[setId].hasInserts)) return;
        const dataArray = tableSettings[setId].data;
        const parentItemIndex = dataArray.findIndex(item => item.id === parentItemId); if (parentItemIndex === -1) return;

        const parentItem = dataArray[parentItemIndex];
        let initialSubtype = 'middle';
        let mainItemsFollow = false;
        for (let i = parentItemIndex + 1; i < dataArray.length; i++) { if (dataArray[i].type === 'main') { mainItemsFollow = true; break; } }

        if (!mainItemsFollow && (parentItem.type === 'main' || (parentItem.type === 'insert' && parentItem.insertSubtype === 'continuous_end'))) {
            initialSubtype = 'continuous_end';
        }

        const newInsert = {
            id: generateUUID(), value: '', type: 'insert', insertSubtype: initialSubtype,
            parentMainItemNumber: (initialSubtype === 'middle' && typeof parentActualNumberForInsert === 'number' && parentActualNumberForInsert > 0) ? parentActualNumberForInsert : undefined
        };
        // If it's 'middle' but parentMainItemNumber ended up undefined, it should arguably be a 'top' or handled as an error.
        // For now, this logic matches previous behavior.
        if (initialSubtype === 'middle' && newInsert.parentMainItemNumber === undefined) {
            // This case should ideally not happen if parentActualNumberForInsert is correctly passed.
            // Reverting to a 'top' insert if parent linkage fails.
            newInsert.insertSubtype = 'top';
            console.warn("Insert designated as 'middle' but lacked valid parent number, converted to 'top'. ParentID:", parentItemId);
        }


        let insertionIndex = parentItemIndex + 1;
        // For middle inserts, find the correct place among other middle inserts for the same parent
        if (newInsert.insertSubtype === 'middle' && newInsert.parentMainItemNumber !== undefined) {
            while (insertionIndex < dataArray.length &&
                dataArray[insertionIndex].type === 'insert' &&
                dataArray[insertionIndex].insertSubtype === 'middle' &&
                dataArray[insertionIndex].parentMainItemNumber === newInsert.parentMainItemNumber) {
                insertionIndex++;
            }
        }
        dataArray.splice(insertionIndex, 0, newInsert);
        if (typeof renderTable === "function") renderTable(setId); saveStateToSessionStorage();
    }


    function initializeSortableForTable(setId, isInsertTable) {
        const tableBodyId = isInsertTable ? `table-body-inserts-${setId}` : `table-body-${setId}`;
        const tableBodyElement = document.getElementById(tableBodyId);
        const settings = tableSettings[setId];
        if (!settings || !tableBodyElement) { console.warn(`Sortable init failed: no settings or body for ${tableBodyId}`); return; }

        const instanceKey = isInsertTable ? 'sortableInsertsInstance' : 'sortableInstance';
        if (settings[instanceKey]) { settings[instanceKey].destroy(); settings[instanceKey] = null; }

        if (typeof Sortable !== 'undefined') {
            settings[instanceKey] = new Sortable(tableBodyElement, {
                animation: 150, handle: '.drag-handle', filter: '.fixed-row', preventOnFilter: true,
                ghostClass: 'sortable-ghost', chosenClass: 'sortable-chosen',
                onEnd: function (evt) {
                    // Prevent dragging onto fixed rows (like smartblind 0 or 511)
                    if (evt.newDraggableIndex !== undefined && evt.to.children[evt.newDraggableIndex] && evt.to.children[evt.newDraggableIndex].classList.contains('fixed-row')) {
                        // Revert the drag by re-rendering. This is a simple way to cancel.
                        // A more sophisticated cancel would involve Sortable's 'onMove' or reverting the change directly.
                        console.warn("Attempted to drag onto a fixed row. Reverting.");
                        if (typeof renderTable === "function") renderTable(setId);
                        return;
                    }

                    const currentDataArrayRef = isInsertTable ? settings.insertsData : settings.data;
                    const movedItem = currentDataArrayRef.splice(evt.oldDraggableIndex, 1)[0];
                    currentDataArrayRef.splice(evt.newDraggableIndex, 0, movedItem);
                    
                    // No need to map IDs if we directly manipulate the array based on Sortable's indices
                    // This assumes Sortable's indices for draggable items correctly map to non-fixed rows.

                    if (typeof renderTable === "function") renderTable(setId); // Re-render to update numbering
                    saveStateToSessionStorage();
                }
            });
        } else { console.warn(`SortableJS library not loaded for ${tableBodyId}.`); }
    }


    function addDataRow(setId) {
        if (!tableSettings[setId]) return;
        const targetArray = tableSettings[setId].data;
        if (currentBlindMode === 'smart' && targetArray.length >= MAX_EDITABLE_ROWS_SMART) { alert(`Max ${MAX_EDITABLE_ROWS_SMART} user-editable rows for Smartblind tables.`); return; }
        targetArray.push({ id: generateUUID(), value: '', type: 'main' });
        if (typeof renderTable === "function") renderTable(setId); saveStateToSessionStorage();
    }

    function addInsertDataRow(setId) { // For Smartblind's separate inserts table
        if (currentBlindMode !== 'smart' || !tableSettings[setId] || !tableSettings[setId].hasInserts) { alert("Smart inserts can only be added when in Smartblind mode and inserts are enabled for the table."); return; }
        // Assuming MAX_EDITABLE_ROWS_SMART applies to the total of main + smart inserts.
        if ((tableSettings[setId].data.length + tableSettings[setId].insertsData.length) >= MAX_EDITABLE_ROWS_SMART) {
             alert(`Max ${MAX_EDITABLE_ROWS_SMART} total user-editable rows (main + inserts) for Smartblind tables.`); return;
        }
        tableSettings[setId].insertsData.push({ id: generateUUID(), value: '', type: 'main' }); // type 'main' within insertsData context
        if (typeof renderTable === "function") renderTable(setId); saveStateToSessionStorage();
    }

    function handleAddMultiple(setId) {
        if (!tableSettings[setId]) return;
        const qtyInput = document.getElementById(`qty-${setId}`); const quantity = parseInt(qtyInput.value, 10);
        if (isNaN(quantity) || quantity < 1) { alert(`Please enter a valid quantity.`); qtyInput.focus(); return; }
        const targetArray = tableSettings[setId].data;
        if (currentBlindMode === 'smart' && (targetArray.length + quantity) > MAX_EDITABLE_ROWS_SMART) { alert(`Cannot add. Max ${MAX_EDITABLE_ROWS_SMART} user-editable rows.`); return; }
        for (let i = 0; i < quantity; i++) targetArray.push({ id: generateUUID(), value: '', type: 'main' });
        if (typeof renderTable === "function") renderTable(setId); qtyInput.value = ''; saveStateToSessionStorage();
    }

    function handleAddMultipleInserts(setId) { // For Smartblind's separate inserts table
        if (currentBlindMode !== 'smart' || !tableSettings[setId] || !tableSettings[setId].hasInserts) { alert("Smart inserts can only be added when in Smartblind mode and inserts are enabled."); return; }
        const qtyInput = document.getElementById(`qty-inserts-${setId}`); const quantity = parseInt(qtyInput.value, 10);
        if (isNaN(quantity) || quantity < 1) { alert(`Please enter a valid quantity.`); qtyInput.focus(); return; }
        if ((tableSettings[setId].data.length + tableSettings[setId].insertsData.length + quantity) > MAX_EDITABLE_ROWS_SMART) {
             alert(`Cannot add. Max ${MAX_EDITABLE_ROWS_SMART} total user-editable rows (main + inserts) for Smartblind tables.`); return;
        }
        for (let i = 0; i < quantity; i++) tableSettings[setId].insertsData.push({ id: generateUUID(), value: '', type: 'main' });
        if (typeof renderTable === "function") renderTable(setId); qtyInput.value = ''; saveStateToSessionStorage();
    }


    function getDisplayedRowsForExport(setId) {
        const outputRows = [];
        if (!tableSettings[setId]) return outputRows;

        // Create deep copies for manipulation to avoid altering original data
        const mainDataArray = JSON.parse(JSON.stringify(tableSettings[setId].data));
        const smartInsertsDataArray = JSON.parse(JSON.stringify(tableSettings[setId].insertsData));

        if (currentBlindMode === 'smart' && (setId === 'A' || setId === 'B' || setId === 'C')) {
            outputRows.push({ label: SMART_DELIMITER_0_NUM, text: SMART_DELIMITER_0_DISPLAY_TEXT, type: 'delimiter' });
            mainDataArray.forEach((item, index) => outputRows.push({ label: String(index + 1), text: item.value || "", type: 'data' }));

            if (tableSettings[setId].hasInserts && smartInsertsDataArray && smartInsertsDataArray.length > 0) {
                outputRows.push({ label: "", text: SMART_INSERT_SEPARATOR_TEXT, type: 'insert_separator' }); // Use a distinct type
                let insertNumberBase = mainDataArray.length + 1;
                smartInsertsDataArray.forEach((item, index) => outputRows.push({ label: String(insertNumberBase + index), text: item.value || "", type: 'insert' }));
            }
            outputRows.push({ label: SMART_DELIMITER_511_NUM, text: SMART_DELIMITER_511_DISPLAY_TEXT, type: 'delimiter' });

        } else if (currentBlindMode === 'manual' || currentBlindMode === 'threeTrack') {
             // Re-calculate numbering for export, similar to renderTable
            mainDataArray.forEach(item => { if(!item.type) item.type = 'main'; delete item.actualMainNumber; delete item.potentialParentMainNumber; if(item.insertSubtype === 'top' || item.insertSubtype === 'continuous_end') delete item.parentMainItemNumber;});
            let lastMainItemActualNum = 0; let currentOverallMainSeqNum = 0;
            for (let i = 0; i < mainDataArray.length; i++) { const item = mainDataArray[i]; if (item.type === 'main') { currentOverallMainSeqNum++; item.actualMainNumber = currentOverallMainSeqNum; lastMainItemActualNum = item.actualMainNumber; } else if (item.type === 'insert' && item.insertSubtype !== 'top') item.potentialParentMainNumber = lastMainItemActualNum; }
            for (let i = 0; i < mainDataArray.length; i++) { const item = mainDataArray[i]; if (item.type === 'insert') { if (item.insertSubtype === 'continuous_end') { let mainItemFollows = false; for (let j = i + 1; j < mainDataArray.length; j++) if (mainDataArray[j].type === 'main') { mainItemFollows = true; break; } if (mainItemFollows) { item.insertSubtype = 'middle'; item.parentMainItemNumber = item.potentialParentMainNumber > 0 ? item.potentialParentMainNumber : undefined; if (item.parentMainItemNumber === undefined) { item.insertSubtype = 'top'; delete item.parentMainItemNumber;}} } if (item.insertSubtype === 'middle') { if (item.parentMainItemNumber === undefined || item.parentMainItemNumber === 0) { item.parentMainItemNumber = item.potentialParentMainNumber > 0 ? item.potentialParentMainNumber : undefined; if(item.parentMainItemNumber === undefined) item.insertSubtype = 'top';}} if (item.insertSubtype === 'middle' || item.insertSubtype === 'top') delete item.actualMainNumber;}}
            currentOverallMainSeqNum = 0; mainDataArray.forEach(item => { if (item.type === 'main') { currentOverallMainSeqNum++; item.actualMainNumber = currentOverallMainSeqNum; } else if (item.type === 'insert' && item.insertSubtype === 'continuous_end') { currentOverallMainSeqNum++; item.actualMainNumber = currentOverallMainSeqNum; }});

            let topInsertCounter = 0;
            let tempMiddleInsertLetterMap = {};
            mainDataArray.forEach(item => {
                let displayNumber = "", value = item.value || "", isInsertType = item.type === 'insert';
                if (isInsertType && item.insertSubtype === 'top') displayNumber = String.fromCharCode(65 + topInsertCounter++);
                else if (item.type === 'main' || (isInsertType && item.insertSubtype === 'continuous_end')) { displayNumber = String(item.actualMainNumber); if (item.actualMainNumber !== undefined) tempMiddleInsertLetterMap[item.actualMainNumber] = 0; }
                else if (isInsertType && item.insertSubtype === 'middle') { const pNum = item.parentMainItemNumber; if (pNum !== undefined && pNum > 0 && tempMiddleInsertLetterMap.hasOwnProperty(pNum)) { const lIdx = tempMiddleInsertLetterMap[pNum]; displayNumber = `${pNum}${String.fromCharCode(65 + lIdx)}`; tempMiddleInsertLetterMap[pNum]++; } else displayNumber = "Ins"; } // Fallback label for middle insert with bad parent

                if (displayNumber) outputRows.push({ label: displayNumber, text: value + (isInsertType ? " (insert)" : ""), type: isInsertType ? 'insert' : 'data' });
            });
        }
        return outputRows;
    }

    function isValidFilename(filename) {
        const invalidCharsRegex = /[<>:"/\\|?*\x00-\x1F]/g;
        const filenameCore = filename.includes('.') ? filename.substring(0, filename.lastIndexOf('.')) : filename;
        const reservedNamesRegex = /^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])$/i;
        if (invalidCharsRegex.test(filename)) { alert('Filename contains invalid characters. Avoid: <>:"/\\|?* and control characters.'); return false; }
        if (reservedNamesRegex.test(filenameCore)) { alert('Filename is a reserved system name.'); return false; }
        if (filename.length === 0) { alert('Filename cannot be empty.'); return false; }
        if (filename.length > 255) { alert('Filename is too long.'); return false; }
        if (filename === "." || filename === "..") { alert('Filename cannot be "." or ".."'); return false; }
        if (/^[\s.]+$/.test(filename)) { alert('Filename consists only of dots or spaces.'); return false; }
        if (/[. ]$/.test(filename)) { alert('Filename cannot end with a dot or a space.'); return false; }
        return true;
    }

    function exportToBLIND() {
        let userInputListName = document.getElementById('listNameInput').value.trim();
        if (!userInputListName) userInputListName = "Unnamed_List"; // Default if empty
        if (!isValidFilename(userInputListName)) { document.getElementById('listNameInput').focus(); return; }

        let textContent = `List Name:${userInputListName}\n`;
        let blindTypeDisplayValue;
        switch (currentBlindMode) {
            case 'smart': blindTypeDisplayValue = "Smartblind"; break;
            case 'manual': blindTypeDisplayValue = "Manual Blind"; break;
            case 'threeTrack': blindTypeDisplayValue = "3 Track"; break;
            default: blindTypeDisplayValue = currentBlindMode;
        }
        textContent += `Blind Type:${blindTypeDisplayValue}\n`;

        if (currentBlindMode === 'threeTrack') {
            textContent += `Tracks Identical:${threeTrackIsIdentical ? 'Yes' : 'No'}\n`;
        }
        if (currentBlindMode === 'manual') {
            textContent += `SideBlindSplit:${isSideBlindSplit ? 'Yes' : 'No'}\n`;
            textContent += `FrontRearSeparate:${isFrontRearSeparate ? 'Yes' : 'No'}\n`;
        }
        textContent += "\n"; // Separator after global settings

        const tablesToActuallyExport = determineTablesToExport();
        tablesToActuallyExport.forEach(setId => {
            if (!tableSettings[setId] || isTableEffectivelyEmpty(setId)) return;

            let tableTitle, dataHeader;
            // Logic to determine actual title/header based on current mode and states
            if (currentBlindMode === 'threeTrack') {
                if (setId === 'D' || setId === 'E') return; // Should not happen if determineTablesToExport is correct
                tableTitle = (threeTrackIsIdentical && setId === 'A') ? threeTrackIdenticalAppearance.title : (threeTrackAppearances[setId]?.title || `Track ${setId}`);
                dataHeader = (threeTrackIsIdentical && setId === 'A') ? threeTrackIdenticalAppearance.header : (threeTrackAppearances[setId]?.header || "Data");
            } else if (currentBlindMode === 'manual') {
                if (setId === 'A' && isFrontRearSeparate) { tableTitle = originalTableAppearances.A.altTitle; dataHeader = originalTableAppearances.A.altHeader; }
                else if (setId === 'C' && isSideBlindSplit) { tableTitle = originalTableAppearances.C.altTitle; dataHeader = originalTableAppearances.C.altHeader; }
                else { tableTitle = originalTableAppearances[setId]?.title || `Table ${setId}`; dataHeader = originalTableAppearances[setId]?.header || "Data"; }
            } else { // Smart Mode
                tableTitle = originalTableAppearances[setId]?.title || `Table ${setId}`; dataHeader = originalTableAppearances[setId]?.header || "Data";
            }

            textContent += `${tableTitle}\n`;
            textContent += `Inserts Added:${tableSettings[setId].hasInserts ? 'Yes' : 'No'}\n`;
            // Only include TableVisible line for modes where it's relevant and for tables that have this setting
            if ((currentBlindMode === 'manual' || currentBlindMode === 'smart') && tableSettings[setId].hasOwnProperty('isVisibleInSmartManual')) {
                 textContent += `TableVisible:${tableSettings[setId].isVisibleInSmartManual ? 'Yes' : 'No'}\n`;
            }
            textContent += `No.,${dataHeader}\n`;

            const displayedRows = getDisplayedRowsForExport(setId);
            displayedRows.forEach(row => {
                if (row.type === 'insert_separator') { // Handle specific type for separator
                    textContent += `${SMART_INSERT_SEPARATOR_TEXT}\n`;
                } else {
                    // Escape newlines in text value for storage in .blind file
                    const escapedText = (row.text || "").replace(/\n/g, '\\n');
                    textContent += `${row.label},${escapedText}\n`;
                }
            });
            textContent += "\n"; // Empty line between tables
        });

        const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8;' });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `${userInputListName}.blind`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href); // Clean up blob URL
    }

    function exportCurrentDataToPDF() {
    const { jsPDF } = window.jspdf;
    if (!jsPDF || !jsPDF.API || !jsPDF.API.autoTable) {
        alert("PDF library not loaded.");
        return;
    }
    let userInputListName = document.getElementById('listNameInput').value.trim() || "Blind_List";
    if (document.getElementById('listNameInput').value.trim() && !isValidFilename(userInputListName)) {
        document.getElementById('listNameInput').focus();
        return;
    }
    const doc = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
    let currentDocY = 40;

    doc.setTextColor(0, 0, 0); // Default text color to black

    doc.setFontSize(16);
    doc.setFont("helvetica", "bold");
    doc.text(userInputListName, doc.internal.pageSize.getWidth() / 2, currentDocY, { align: 'center', maxWidth: doc.internal.pageSize.getWidth() - 80 });
    currentDocY += (doc.splitTextToSize(userInputListName, doc.internal.pageSize.getWidth() - 80).length * 16 * 1.15) + 10;

    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    let blindTypeDisplayValue;
    switch (currentBlindMode) {
        case 'smart': blindTypeDisplayValue = "Smartblind"; break;
        case 'manual': blindTypeDisplayValue = "Manual Blind"; break;
        case 'threeTrack': blindTypeDisplayValue = "3 Track"; break;
        default: blindTypeDisplayValue = currentBlindMode;
    }
    let blindTypeText = `Blind Type: ${blindTypeDisplayValue}`;
    if (currentBlindMode === 'threeTrack') blindTypeText += ` (Tracks Identical: ${threeTrackIsIdentical ? 'Yes' : 'No'})`;
    if (currentBlindMode === 'manual') blindTypeText += ` (Side Split: ${isSideBlindSplit ? 'Yes' : 'No'}, Front/Rear Separate: ${isFrontRearSeparate ? 'Yes' : 'No'})`;
    doc.text(blindTypeText, 40, currentDocY);
    currentDocY += (10 * 1.15) + 15;

    const tablesToActuallyExport = determineTablesToExport();
    let firstTable = true;

    // --- Define your placeholder for total pages ---
    const totalPagesExp = "{totalPages}";

    tablesToActuallyExport.forEach((setId) => {
        if (!tableSettings[setId] || isTableEffectivelyEmpty(setId)) return;

        let tableTitle, dataHeader;
        if (currentBlindMode === 'threeTrack') {
            if (setId === 'D' || setId === 'E') return;
            tableTitle = (threeTrackIsIdentical && setId === 'A') ? threeTrackIdenticalAppearance.title : (threeTrackAppearances[setId]?.title || `Track ${setId}`);
            dataHeader = (threeTrackIsIdentical && setId === 'A') ? threeTrackIdenticalAppearance.header : (threeTrackAppearances[setId]?.header || "Data");
        } else if (currentBlindMode === 'manual') {
            if (setId === 'A' && isFrontRearSeparate) { tableTitle = originalTableAppearances.A.altTitle; dataHeader = originalTableAppearances.A.altHeader; }
            else if (setId === 'C' && isSideBlindSplit) { tableTitle = originalTableAppearances.C.altTitle; dataHeader = originalTableAppearances.C.altHeader; }
            else { tableTitle = originalTableAppearances[setId]?.title || `Table ${setId}`; dataHeader = originalTableAppearances[setId]?.header || "Data"; }
        } else { // Smart Mode
            tableTitle = originalTableAppearances[setId]?.title || `Table ${setId}`; dataHeader = originalTableAppearances[setId]?.header || "Data";
        }

        if (!firstTable) {
            currentDocY = doc.lastAutoTable.finalY + 30;
        } else {
            firstTable = false;
        }
        if (currentDocY + 60 > doc.internal.pageSize.getHeight() - 50) {
            doc.addPage();
            currentDocY = 60;
            doc.setTextColor(0, 0, 0);
        }

        doc.setFontSize(12);
        doc.setFont("helvetica", "bold");
        doc.text(tableTitle, 40, currentDocY);
        currentDocY += (12 * 1.15);

        doc.setFontSize(9);
        doc.setFont("helvetica", "italic");
        doc.text(`Inserts Added: ${tableSettings[setId].hasInserts ? 'Yes' : 'No'}`, 40, currentDocY);
        currentDocY += (9 * 1.15) + 10;

        const pdfHeaders = [["No.", dataHeader]];
        const pdfBody = getDisplayedRowsForExport(setId).map(row => {
            if (row.type === 'insert_separator') return [{ content: '', _isInsertSeparator: true, _separatorText: SMART_INSERT_SEPARATOR_TEXT, colSpan: 2, styles: { cellPadding: { top: 6, bottom: 8, left: 2, right: 2 } } }];
            return [row.label, row.text];
        });
        if (pdfBody.length === 0 && !(currentBlindMode === 'smart' && getDisplayedRowsForExport(setId).some(r => r.type === 'delimiter'))) {
            pdfBody.push([{ content: " ", styles: { textColor: [0, 0, 0] } }, { content: " ", styles: { textColor: [0, 0, 0] } }]);
        }

        doc.autoTable({
            head: pdfHeaders,
            body: pdfBody,
            startY: currentDocY,
            theme: 'grid',
            headStyles: { textColor: [0, 0, 0], fontStyle: 'bold', halign: 'center', fillColor: [220, 220, 220] },
            bodyStyles: { textColor: [0, 0, 0] },
            columnStyles: {
                0: { halign: 'center', cellWidth: 60 },
                1: { cellWidth: doc.internal.pageSize.getWidth() - 80 - 60 - 4 }
            },
            margin: { left: 40, right: 40, bottom: 50 },
            didDrawPage: function (data) {
                doc.setFontSize(9);
                doc.setFont("helvetica", "normal");
                doc.setTextColor(0, 0, 0);
                const footerY = doc.internal.pageSize.getHeight() - 20;

                // --- MODIFIED: Use the placeholder for total pages ---
                const pageNumText = `Page ${data.pageNumber} of ${totalPagesExp}`;
                doc.text(pageNumText, doc.internal.pageSize.getWidth() - 40, footerY, { align: 'right' });

                const today = new Date();
                const day = String(today.getDate()).padStart(2, '0');
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const year = today.getFullYear();
                const formattedDate = `${day}/${month}/${year}`;
                doc.text(`Generated: ${formattedDate}`, 40, footerY);
            },
            didDrawCell: function (data) {
                // ... (your existing didDrawCell logic remains the same) ...
                if (data.cell.raw && data.cell.raw._isInsertSeparator) {
                    const cell = data.cell; const docInstance = data.doc; cell.text = ''; const text = cell.raw._separatorText || "INSERT";
                    const pLW=docInstance.getLineWidth(), pDC_raw=docInstance.getDrawColor(), pFC_raw=docInstance.getFillColor(), pFont=docInstance.getFont(), pFS=docInstance.getFontSize(), pTC_raw=docInstance.getTextColor();
                    
                    let pDC = Array.isArray(pDC_raw) ? pDC_raw : [pDC_raw,pDC_raw,pDC_raw]; 
                    let pFC = Array.isArray(pFC_raw) ? pFC_raw : [pFC_raw,pFC_raw,pFC_raw];
                    let pTC = Array.isArray(pTC_raw) ? pTC_raw : [pTC_raw,pTC_raw,pTC_raw];
                    if(typeof pDC_raw === 'string') pDC = pDC_raw; 
                    if(typeof pFC_raw === 'string') pFC = pFC_raw;
                    if(typeof pTC_raw === 'string') pTC = pTC_raw;

                    docInstance.setLineWidth(0.2); docInstance.setDrawColor(200);
                    docInstance.setFontSize(9); docInstance.setFont(pFont.fontName,'italic'); docInstance.setTextColor(0,0,0);
                    
                    let cPad = { top: 0, right: 0, bottom: 0, left: 0 };
                    const cellPaddingStyle = cell.styles.cellPadding;
                    if (typeof cellPaddingStyle === 'object') cPad = { top: cellPaddingStyle.top || 0, right: cellPaddingStyle.right || 0, bottom: cellPaddingStyle.bottom || 0, left: cellPaddingStyle.left || 0 };
                    else if (typeof cellPaddingStyle === 'number') cPad = { top: cellPaddingStyle, right: cellPaddingStyle, bottom: cellPaddingStyle, left: cellPaddingStyle };

                    const tW=docInstance.getTextWidth(text), cellContentHeight = cell.height-cPad.top-cPad.bottom, lY=cell.y+cPad.top+cellContentHeight/2, tY=lY+(docInstance.getFontSize()*0.35/docInstance.internal.scaleFactor); docInstance.text(text,cell.x+(cell.width-tW)/2,tY);
                    docInstance.setLineWidth(0.5); docInstance.setDrawColor(0); docInstance.setLineDashPattern([3,2],0); const lpft=5;
                    const l1x1=cell.x+cPad.left+2, l1x2=cell.x+(cell.width-tW)/2-lpft; if(l1x2>l1x1)docInstance.line(l1x1,lY,l1x2,lY);
                    const l2x1=cell.x+(cell.width+tW)/2+lpft, l2x2=cell.x+cell.width-cPad.right-2; if(l2x2>l2x1)docInstance.line(l2x1,lY,l2x2,lY);
                    
                    docInstance.setLineDashPattern([],0); docInstance.setLineWidth(pLW); 
                    if (Array.isArray(pDC)) docInstance.setDrawColor(pDC[0], pDC[1], pDC[2]); else docInstance.setDrawColor(pDC);
                    if (Array.isArray(pFC)) docInstance.setFillColor(pFC[0], pFC[1], pFC[2]); else docInstance.setFillColor(pFC);
                    docInstance.setFont(pFont.fontName,pFont.fontStyle); docInstance.setFontSize(pFS); 
                    if (Array.isArray(pTC)) docInstance.setTextColor(pTC[0], pTC[1], pTC[2]); else docInstance.setTextColor(pTC);
                }
            }
        });
    });

    // --- ADD THIS: Call putTotalPages AFTER all tables are drawn and BEFORE save ---
    if (typeof doc.putTotalPages === 'function') {
        doc.putTotalPages(totalPagesExp);
    } else {
        // Fallback for older jsPDF versions or if putTotalPages is not available
        // This will result in "Page X of X" for the last page, and "Page Y of Y" for previous.
        // It's better than "Page X of (running total)", but not perfect.
        // To avoid this, ensure you're using a jsPDF version that supports putTotalPages.
        // For now, the user's jsPDF 2.5.1 should support it.
        console.warn("doc.putTotalPages is not a function. Page total in footer might be incorrect.");
    }

    doc.save(`${userInputListName}.pdf`);
}


    function determineTablesToExport() {
        if (currentBlindMode === 'threeTrack') {
            return threeTrackIsIdentical ? ['A'] : ['A', 'B', 'C'].filter(setId => tableSettings[setId]);
        } else if (currentBlindMode === 'manual') {
            let tables = ['A', 'B', 'C']; // Base tables for manual
            if (isSideBlindSplit) tables.push('D');
            if (isFrontRearSeparate) tables.push('E');
            return tables.filter(setId => tableSettings[setId] && tableSettings[setId].isVisibleInSmartManual);
        } else { // Smart mode
            return ['A', 'B', 'C'].filter(setId => tableSettings[setId] && tableSettings[setId].isVisibleInSmartManual);
        }
    }

    function isTableEffectivelyEmpty(setId) {
        if (!tableSettings[setId]) return true;
        const mainDataEmpty = !tableSettings[setId].data || tableSettings[setId].data.length === 0;
        if (currentBlindMode === 'smart') {
            const insertsDataEmpty = !tableSettings[setId].insertsData || tableSettings[setId].insertsData.length === 0;
            return mainDataEmpty && (!tableSettings[setId].hasInserts || insertsDataEmpty);
        }
        return mainDataEmpty; // For manual/3-track, only main data matters for this check
    }

    function importFromBLIND(event) {
        const file = event.target.files[0];
        if (!file) return;
        if (!confirm("Importing this .blind file will overwrite current data. Proceed?")) {
            event.target.value = null; return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            const fileContent = e.target.result;
            try {
                const lines = fileContent.split(/\r\n|\n/);
                const tempImportedTableVisibility = {};

                function processImportLineAsTableTitle(line, mode, sideSplitActive, frontRearSeparateActive) {
                    let matchedSetId = null;
                    const trimmedLine = line.trim(); // Match against trimmed line

                    if (mode === 'threeTrack') {
                        if (threeTrackIdenticalAppearance.title === trimmedLine) matchedSetId = 'A';
                        else { Object.keys(threeTrackAppearances).find(k => { if (threeTrackAppearances[k].title === trimmedLine) { matchedSetId = k; return true;} return false; }); }
                    } else if (mode === 'manual') {
                        if ((frontRearSeparateActive && originalTableAppearances.A.altTitle === trimmedLine) || (!frontRearSeparateActive && originalTableAppearances.A.title === trimmedLine)) matchedSetId = 'A';
                        else if (originalTableAppearances.B.title === trimmedLine) matchedSetId = 'B';
                        else if ((sideSplitActive && originalTableAppearances.C.altTitle === trimmedLine) || (!sideSplitActive && originalTableAppearances.C.title === trimmedLine)) matchedSetId = 'C';
                        else if (sideSplitActive && originalTableAppearances.D.title === trimmedLine) matchedSetId = 'D';
                        else if (frontRearSeparateActive && originalTableAppearances.E.title === trimmedLine) matchedSetId = 'E';
                    } else { // Smart
                        Object.keys(originalTableAppearances).find(k => { if (originalTableAppearances[k].title === trimmedLine && (k==='A'||k==='B'||k==='C')) { matchedSetId = k; return true;} return false; });
                    }
                    if (matchedSetId) console.log(`Title matched: "${trimmedLine}" to setId: ${matchedSetId}`);
                    // else console.warn(`Title "${trimmedLine}" NOT matched for mode ${mode}, sideSplit ${sideSplitActive}, frontRearSeparate ${frontRearSeparateActive}`);
                    return matchedSetId;
                }


                ['A', 'B', 'C', 'D', 'E'].forEach(id => {
                    if (tableSettings[id]) {
                        tableSettings[id].data = []; tableSettings[id].insertsData = [];
                        tableSettings[id].hasInserts = false;
                        tableSettings[id].isVisibleInSmartManual = (id !== 'D' && id !== 'E');
                    }
                });

                let importedIsSideBlindSplit = false, importedIsFrontRearSeparate = false;
                let parsedListName = "", parsedBlindMode = "", parsedThreeTrackIdentical = null;
                let foundListName = false, foundBlindType = false;
                let currentParsingSetId = null;
                let parsingState = 'expectListName';
                let parsingSmartInserts = false;

                console.log("--- Starting .blind file import ---");

                lines.forEach((lineText, lineIdx) => {
                    const line = lineText.trim();
                    if (!line && lineIdx !== lines.length - 1 && parsingState !== 'expectDataRows' && parsingState !== 'expectTableTitle') return;
                    // console.log(`L${lineIdx + 1} [State: ${parsingState}] Line: "${line}" (CurrentSetId: ${currentParsingSetId}, SBS: ${importedIsSideBlindSplit})`);

                    if (parsingState === 'expectListName') {
                        if (line.startsWith("List Name:")) { parsedListName = line.substring("List Name:".length).trim(); foundListName = true; parsingState = 'expectBlindType'; }
                        // else if (line) console.warn("L" + (lineIdx+1) + " Expected 'List Name:'");
                    } else if (parsingState === 'expectBlindType') {
                        if (line.startsWith("Blind Type:")) {
                            const typeVal = line.substring("Blind Type:".length).trim().toLowerCase();
                            if (typeVal.includes("smart")) parsedBlindMode = "smart";
                            else if (typeVal.includes("manual")) parsedBlindMode = "manual";
                            else if (typeVal.includes("3 track")) parsedBlindMode = "threeTrack";
                            if (parsedBlindMode) foundBlindType = true;
                            parsingState = 'expectModeSettingsOrTableTitle';
                        } // else if (line) console.warn("L" + (lineIdx+1) + " Expected 'Blind Type:'");
                    } else if (parsingState === 'expectModeSettingsOrTableTitle') {
                        let consumedModeSetting = false;
                        if (parsedBlindMode === 'threeTrack' && line.startsWith("Tracks Identical:")) { parsedThreeTrackIdentical = line.substring("Tracks Identical:".length).trim().toLowerCase() === 'yes'; consumedModeSetting = true; parsingState = 'expectTableTitle'; }
                        else if (parsedBlindMode === 'manual') {
                            if (line.startsWith("SideBlindSplit:")) { importedIsSideBlindSplit = line.substring("SideBlindSplit:".length).trim().toLowerCase() === 'yes'; consumedModeSetting = true; /* Stay, might be FrontRearSeparate next */ }
                            else if (line.startsWith("FrontRearSeparate:")) { importedIsFrontRearSeparate = line.substring("FrontRearSeparate:".length).trim().toLowerCase() === 'yes'; consumedModeSetting = true; parsingState = 'expectTableTitle'; }
                        }
                        if (!consumedModeSetting) { // Must be a table title or empty line
                            parsingState = 'expectTableTitle'; // Fall through to next state for this line
                            const setIdFound = processImportLineAsTableTitle(line, parsedBlindMode, importedIsSideBlindSplit, importedIsFrontRearSeparate);
                            if (setIdFound) { currentParsingSetId = setIdFound; parsingState = 'expectInsertsAdded'; if (!tableSettings[currentParsingSetId]) tableSettings[currentParsingSetId] = { data: [], insertsData: [], hasInserts: false, isVisibleInSmartManual: true }; }
                            // else if (line) console.warn("L" + (lineIdx+1) + " Expected table title or mode setting:", line);
                        }
                    } else if (parsingState === 'expectTableTitle') {
                        const setIdFound = processImportLineAsTableTitle(line, parsedBlindMode, importedIsSideBlindSplit, importedIsFrontRearSeparate);
                        if (setIdFound) { currentParsingSetId = setIdFound; parsingState = 'expectInsertsAdded'; if (!tableSettings[currentParsingSetId]) tableSettings[currentParsingSetId] = { data: [], insertsData: [], hasInserts: false, isVisibleInSmartManual: true }; }
                        // else if (line) console.warn("L" + (lineIdx+1) + " Expected table title:", line);
                    } else if (currentParsingSetId && tableSettings[currentParsingSetId]) {
                        if (parsingState === 'expectInsertsAdded' && line.startsWith("Inserts Added:")) { tableSettings[currentParsingSetId].hasInserts = (line.substring("Inserts Added:".length).trim().toLowerCase() === 'yes'); parsingState = 'expectTableVisibleOrDataHeader'; }
                        else if (parsingState === 'expectTableVisibleOrDataHeader') {
                            if ((parsedBlindMode === 'manual' || parsedBlindMode === 'smart') && line.startsWith("TableVisible:")) { tempImportedTableVisibility[currentParsingSetId] = line.substring("TableVisible:".length).trim().toLowerCase() === 'yes'; parsingState = 'expectDataHeader'; }
                            else if (line.toUpperCase().startsWith("NO.,")) { parsingState = 'expectDataRows'; parsingSmartInserts = false; }
                            // else if (line) { console.warn(`L${lineIdx+1} Expected "TableVisible:" or "No.," for ${currentParsingSetId}, found: "${line}". Resetting.`); parsingState = 'expectTableTitle'; currentParsingSetId = null; }
                        } else if (parsingState === 'expectDataHeader' && line.toUpperCase().startsWith("NO.,")) { parsingState = 'expectDataRows'; parsingSmartInserts = false; }
                        else if (parsingState === 'expectDataRows') {
                            if (line === SMART_INSERT_SEPARATOR_TEXT && parsedBlindMode === 'smart' && tableSettings[currentParsingSetId].hasInserts) { parsingSmartInserts = true; }
                            else {
                                const parts = line.split(','); const noVal = parts.length > 0 ? parts[0].trim() : ""; const val = parts.length > 1 ? parts.slice(1).join(',').trim().replace(/\\n/g, '\n') : "";
                                if (parsedBlindMode === 'smart' && noVal === SMART_DELIMITER_511_NUM && val === SMART_DELIMITER_511_DISPLAY_TEXT) { parsingState = 'expectTableTitle'; currentParsingSetId = null; parsingSmartInserts = false; }
                                else if (parsedBlindMode === 'smart' && noVal === SMART_DELIMITER_0_NUM && val === SMART_DELIMITER_0_DISPLAY_TEXT) { /* Ignore */ }
                                else if (noVal !== "" || val !== "") {
                                    const newItem = { id: generateUUID(), value: val, type: 'main' };
                                    if (parsedBlindMode === 'smart') { if (parsingSmartInserts) tableSettings[currentParsingSetId].insertsData.push(newItem); else tableSettings[currentParsingSetId].data.push(newItem); }
                                    else { if (val.toLowerCase().endsWith(" (insert)")) { newItem.value = val.substring(0, val.length - " (insert)".length).trim(); newItem.type = 'insert'; if (/^[A-Z]$/.test(noVal)) newItem.insertSubtype = 'top'; else if (/^\d+[A-Z]$/.test(noVal)) { newItem.insertSubtype = 'middle'; newItem.parentMainItemNumber = parseInt(noVal.match(/\d+/)[0], 10); } else if (/^\d+$/.test(noVal)) newItem.insertSubtype = 'continuous_end'; else newItem.insertSubtype = 'middle'; } tableSettings[currentParsingSetId].data.push(newItem); }
                                    // console.log("Pushed:", currentParsingSetId, JSON.stringify(newItem));
                                } else if (line.trim() === "" && currentParsingSetId) { parsingState = 'expectTableTitle'; currentParsingSetId = null; parsingSmartInserts = false; }
                            }
                        }
                    } // else if (line) console.warn("L" + (lineIdx+1) + " Unhandled line in parsing:", line);
                });

                if (!foundListName || !foundBlindType) throw new Error("Essential metadata (List Name or Blind Type) missing or invalid.");
                document.getElementById('listNameInput').value = parsedListName;

                // Apply parsed global states
                currentBlindMode = parsedBlindMode;
                if (parsedBlindMode === 'threeTrack') threeTrackIsIdentical = parsedThreeTrackIdentical !== null ? parsedThreeTrackIdentical : true;
                if (parsedBlindMode === 'manual') { isSideBlindSplit = importedIsSideBlindSplit; isFrontRearSeparate = importedIsFrontRearSeparate; }
                else { isSideBlindSplit = false; isFrontRearSeparate = false; } // Reset if not manual

                updateBlindMode(currentBlindMode, true); // Update general mode UI, skip its internal rendering

                // Set main mode radio
                const modeRadio = document.querySelector(`input[name="blindMode"][value="${currentBlindMode}"]`);
                if (modeRadio) modeRadio.checked = true;

                // Set mode-specific control checkboxes and call their handlers
                if (currentBlindMode === 'threeTrack') {
                    const tiCheckbox = document.getElementById('threeTrackIdentical');
                    if (tiCheckbox) tiCheckbox.checked = threeTrackIsIdentical;
                    handleThreeTrackIdenticalToggle(threeTrackIsIdentical);
                }
                if (currentBlindMode === 'manual') {
                    const sbsCheckbox = document.getElementById('isSideBlindSplitCheckbox');
                    if (sbsCheckbox) sbsCheckbox.checked = isSideBlindSplit; // Set checkbox state
                    handleSideBlindSplitToggle(isSideBlindSplit, true);     // Then call handler

                    const frsCheckbox = document.getElementById('isFrontRearSeparateCheckbox');
                    if (frsCheckbox) frsCheckbox.checked = isFrontRearSeparate;
                    handleFrontRearSeparateToggle(isFrontRearSeparate, true);
                }

                // Apply table-specific settings (hasInserts, visibility)
                ['A', 'B', 'C', 'D', 'E'].forEach(setId => {
                    if (tableSettings[setId]) {
                        const hasInsertsChk = document.getElementById(`hasInserts${setId}`);
                        if (hasInsertsChk) hasInsertsChk.checked = tableSettings[setId].hasInserts;
                        handleInsertToggle(setId, tableSettings[setId].hasInserts, true);

                        // Determine isVisibleInSmartManual from file or defaults
                        if (tempImportedTableVisibility.hasOwnProperty(setId)) {
                            tableSettings[setId].isVisibleInSmartManual = tempImportedTableVisibility[setId];
                        } else {
                            if (parsedBlindMode === 'manual') {
                                if (setId === 'D') tableSettings[setId].isVisibleInSmartManual = importedIsSideBlindSplit && (tableSettings[setId].data.length > 0 || (tableSettings[setId].hasInserts && tableSettings[setId].insertsData.length > 0));
                                else if (setId === 'E') tableSettings[setId].isVisibleInSmartManual = importedIsFrontRearSeparate && (tableSettings[setId].data.length > 0 || (tableSettings[setId].hasInserts && tableSettings[setId].insertsData.length > 0));
                                else tableSettings[setId].isVisibleInSmartManual = (setId !== 'D' && setId !== 'E'); // Default A,B,C to true if they have content or are core
                            } else if (parsedBlindMode === 'smart') {
                                tableSettings[setId].isVisibleInSmartManual = (setId !== 'D' && setId !== 'E');
                            } else { // 3-track
                                tableSettings[setId].isVisibleInSmartManual = (setId !== 'D' && setId !== 'E');
                            }
                             // If table is empty and no visibility specified, default to not visible for D, E
                            if ((setId === 'D' || setId === 'E') && tableSettings[setId].data.length === 0 && !tableSettings[setId].hasInserts && !tempImportedTableVisibility.hasOwnProperty(setId)) {
                                tableSettings[setId].isVisibleInSmartManual = false;
                            }
                        }
                        const showTableChk = document.getElementById(`showTable${setId}`);
                        if (showTableChk) showTableChk.checked = tableSettings[setId].isVisibleInSmartManual;
                        // Visibility of table containers is handled by the final rendering pass below, after all states are set
                    }
                });
                
                updateTableAppearances(); // Update all text labels
                
                // Final rendering pass
                ['A', 'B', 'C', 'D', 'E'].forEach(setId => {
                    if (tableSettings[setId]) {
                        const tableContainer = document.getElementById(`table-container-${setId}`);
                        let shouldBeVisible = false;
                        if (currentBlindMode === 'threeTrack') {
                            if (setId === 'A') shouldBeVisible = true;
                            else if (setId === 'B' || setId === 'C') shouldBeVisible = !threeTrackIsIdentical;
                        } else if (currentBlindMode === 'manual') {
                            if (setId === 'D') shouldBeVisible = isSideBlindSplit && tableSettings.D.isVisibleInSmartManual;
                            else if (setId === 'E') shouldBeVisible = isFrontRearSeparate && tableSettings.E.isVisibleInSmartManual;
                            else shouldBeVisible = tableSettings[setId].isVisibleInSmartManual;
                        } else { // Smart Mode
                            shouldBeVisible = (setId !== 'D' && setId !== 'E') && tableSettings[setId].isVisibleInSmartManual;
                        }
                        if (tableContainer) tableContainer.style.display = shouldBeVisible ? 'block' : 'none';
                        if (shouldBeVisible) renderTable(setId);
                    }
                });

                alert(".blind file data imported successfully!");
                saveStateToSessionStorage();

            } catch (error) {
                console.error("Import Error:", error);
                alert("Import failed: " + error.message + "\nPlease ensure the file is valid. Application will try to revert to previous state.");
                loadStateFromSessionStorage(); // Attempt to revert
                updateBlindMode(currentBlindMode, false); // Re-render based on (reverted) state
            } finally {
                event.target.value = null;
            }
        };
        reader.onerror = function() { alert("Could not read file."); event.target.value = null; };
        reader.readAsText(file);
    }

</script>
</body>
</html>
