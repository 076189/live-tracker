<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMSI Tools - Extra Modules</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link rel="manifest" href="/live-tracker/manifest-omsi.json"> <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OMSI Extra Tools">
    <meta name="theme-color" content="#2c3e50">
    <link rel="apple-touch-icon" href="/live-tracker/assets/icons/apple-touch-icon-180x180.png">
    <style>
        @font-face {
            font-family: 'NJFont Medium Web';
            src: url('fonts/NJFont-Medium.ttf') format('truetype'); /* Relative path */
            font-weight: normal;font-style: normal;font-display: swap;
        }
        body {
            font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            margin:0;
        }
        .page-container {
            width: 100%;
            max-width: 1400px; /* Increased max-width for wider tools */
            margin: 0 auto;
        }
        #top-menu-bar_extra {
            background-color: rgba(0,0,0,0.25); padding: 0.75rem; border-radius: 0.5rem;
            margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center; display: none; /* Initially hidden, shown by JS after login */
        }
        .menu-button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin: 0.25rem;
        }
        .menu-button:hover { background-color: #2980b9; }
        .tool-content-section {
            display: none; /* Initially hidden, shown by JS */
            background-color: rgba(0,0,0,0.15); padding: 1.5rem;
            border-radius: 0.5rem; margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        #auth-section { /* Applied .section styles to auth-section */
             margin-bottom: 1.5rem; background-color: rgba(0,0,0,0.15); padding: 1.5rem;
             border-radius: 0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #current-profile-display-container {
            text-align: center; margin-bottom: 1.5rem; padding: 0.75rem;
            background-color: rgba(255,255,255,0.05); border-radius: 0.25rem; display: none; /* Initially hidden */
        }
        #current-profile-display { font-size: 0.9rem; opacity: 0.9; font-style: italic;}
        h1 { font-size: 2rem; margin-bottom: 1.5rem; font-weight: normal; text-align: center; color: #ffffff; }
        h2 { font-size: 1.5rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: normal; border-bottom: 1px solid #7f8c8d; padding-bottom: 0.25rem;}
        h3.subsection-title { font-size: 1.25rem; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: normal; color: #e0e0e0; border-bottom: 1px solid rgba(127,140,141,0.5); padding-bottom: 0.2rem;}
        .subsection {
            background-color: rgba(0,0,0,0.1); padding: 1rem; border-radius: 0.375rem;
            margin-top: 1rem; margin-bottom: 1rem; border: 1px solid rgba(127,140,141,0.2);
        }
        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;}
        .form-field-group { margin-bottom: 1rem; }
        label { display: block; margin-bottom: 0.25rem; font-size: 0.85rem; color: #bdc3c7; }
        input[type="text"], input[type="email"], input[type="password"], input[type="time"],
        input[type="color"], input[type="number"], input[type="date"], input[type="datetime-local"],
        select, textarea {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e; color: #ecf0f1; font-size:0.9rem; box-sizing: border-box;
        }
        input[type="date"]::-webkit-calendar-picker-indicator,
        input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            filter: invert(0.8); cursor:pointer;
        }
        select option { background-color: #34495e; color: #ecf0f1; }
        .button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.5rem 0.8rem;
            border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin-right: 0.5rem; margin-top:0.5rem;
        }
        .button:hover { background-color: #2980b9; }
        .button.secondary { background-color: #e74c3c; }
        .button.secondary:hover { background-color: #c0392b; }
        .button.save { background-color: #27ae60; }
        .button.save:hover { background-color: #229954; }
        .button.tertiary { background-color: #f39c12; }
        .button.tertiary:hover { background-color: #e67e22; }
        .button.neutral { background-color: #7f8c8d; }
        .button.neutral:hover { background-color: #95a5a6; color: #2c3e50; }
        .button.small-action { padding: 0.2rem 0.4rem; font-size: 0.8rem; margin: 0 0.15rem; line-height: 1; min-width: 20px; text-align:center; font-weight: bold;}

        .schedule-generator-input {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e; color: #ecf0f1; font-size: 0.9rem;
        }

        /* Master Stop List Styles */
        #masterStopListUL_extra li.master-stop-list-item {
            display: grid;
            grid-template-columns: 2.5fr 1.5fr 1fr;
            gap: 1rem; padding: 0.75rem 0.5rem;
            border-bottom: 1px solid #34495e;
            transition: background-color 0.15s ease-in-out; align-items: start;
        }
        #masterStopListUL_extra li.master-stop-list-item:last-child { border-bottom: none; }
        .master-stop-original-info .stop-name-master { font-weight: bold; color: #ecf0f1; font-size: 1.05em; }
        .master-stop-original-info .stop-direction-master { font-size: 0.85em; color: #95a5a6; margin-bottom: 0.3rem; }
        .master-stop-original-info .stop-id-master { font-weight: normal; color: #bdc3c7; font-size: 0.95em; }
        .master-stop-original-info .stop-details-grid { display: grid; grid-template-columns: auto 1fr; gap: 0.2rem 0.8rem; font-size: 0.85em; margin-top: 0.4rem; }
        .master-stop-original-info .detail-label { font-weight: normal; color: #bdc3c7; opacity: 0.8; }
        .master-stop-original-info .detail-value { color: #ecf0f1; }
        .master-stop-original-info .detail-value.status-closed { color: #e74c3c; font-weight: bold; }
        .master-stop-original-info .detail-value.status-open { color: #2ecc71; }
        .master-stop-original-info .serving-routes-container { margin-top: 0.4rem; margin-bottom: 0.2rem; display: flex; flex-wrap: wrap; gap: 0.3em; padding: 0.25rem 0;}
        .master-stop-new-id-section label { font-size: 0.8em; display: block; margin-bottom: 0.2em; color: #bdc3c7; }
        .master-list-new-id-input { margin-bottom: 0.25rem; }
        .master-list-row-warning { font-size: 0.8em; color: #f39c12; min-height: 1.2em; margin-top: 0.25rem; }
        .master-stop-actions { margin-top: 0rem; padding-top: 0rem; border-top: none; display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-start; }
        .master-stop-actions .button { width: 100%; margin: 0; }
        .route-tile-tools-list {
            display: inline-block; padding: 0.2em 0.55em; margin-right: 0.3em; margin-bottom: 0.3em;
            border-radius: 0.25rem; font-size: 0.8em; font-weight: bold; color: white;
            text-align: center; line-height: 1.3; min-width: 28px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.25); vertical-align: middle;
        }
        #newStopIdAvailability_extra { font-size: 0.8em; min-height: 1.1em; margin-top: 0.25rem; }

        /* Selectable Route Tiles for Global Deletion & RPD Profile Tiles */
        .selectable-route-tile-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
            padding: 0.25rem 0;
        }
        .selectable-route-tile { /* Base class for clickable tiles */
            display: inline-block;
            padding: 0.4em 0.8em;
            border-radius: 0.25rem;
            font-size: 0.9em;
            font-weight: bold;
            text-align: center;
            line-height: 1.4;
            min-width: 40px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            cursor: pointer;
            border: 2px solid transparent; /* Important for smooth selection transition */
            transition: border-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .selectable-route-tile:hover {
            transform: translateY(-1px);
        }
        .selectable-route-tile.selected { /* Used by Global Route Deletion & RPD */
            border-color: #f1c40f !important; /* Ensure this overrides for selection */
            box-shadow: 0 0 8px 1px #f1c40f !important;
        }

        /* Styles for duplicate stop name/direction results */
        #duplicateStopsByNameDirResults_extra ul { list-style: none; padding-left: 0; }
        #duplicateStopsByNameDirResults_extra li { margin-bottom: 0rem; }
        .duplicate-set-to-merge {
            border: 1px solid #4a5568;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            border-radius: 0.25rem;
            background-color: rgba(0,0,0,0.05);
        }
        .duplicate-set-to-merge p { margin-bottom: 0.35rem; }
        .duplicate-set-to-merge .stop-id-options label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.9em;
            cursor: pointer;
        }
         .duplicate-set-to-merge .stop-id-options input[type="radio"] {
            margin-right: 0.35em;
            vertical-align: middle;
        }

        /* --- START: Route Schedule Generator Styles --- */
        #rsg-stop-sequence-list-extra li {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            border-bottom: 1px solid #4A5568;
            background-color: rgba(255,255,255,0.03);
            cursor: grab;
        }
        #rsg-stop-sequence-list-extra li:active {
            cursor: grabbing;
            background-color: rgba(255,255,255,0.07);
        }
        #rsg-stop-sequence-list-extra li.rsg-dragging-placeholder {
            opacity: 0.5;
            background-color: #567a9a;
            border: 1px dashed #ecf0f1;
        }
        #rsg-stop-sequence-list-extra li:last-child {
            border-bottom: none;
        }
        #rsg-stop-sequence-list-extra .rsg-stop-info {
            flex-grow: 1;
        }
        #rsg-stop-sequence-list-extra .rsg-stop-name {
            font-weight: bold;
        }
        #rsg-stop-sequence-list-extra .rsg-stop-id {
            font-size: 0.85em; color: #bdc3c7; margin-left: 0.5em;
        }
        #rsg-stop-sequence-list-extra .rsg-stop-actions button {
            margin-left: 0.5rem;
            padding: 0.15rem 0.35rem;
            font-size: 0.75rem;
        }
        #rsg-stop-sequence-list-extra .rsg-time-adjustment-input {
            width: 70px;
            margin-left: 0.5em;
            padding: 0.25rem;
            font-size: 0.85em;
            text-align: center;
        }
        #rsg-stop-search-results-extra {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            background-color: #34495e;
            margin-top: 0.25rem;
        }
        #rsg-stop-search-results-extra .rsg-search-result-item {
            padding: 0.5rem 0.6rem;
            cursor: pointer;
            border-bottom: 1px solid #2c3e50;
        }
        #rsg-stop-search-results-extra .rsg-search-result-item:last-child {
            border-bottom: none;
        }
        #rsg-stop-search-results-extra .rsg-search-result-item:hover {
            background-color: #4a6a80;
        }
        #rsg-stop-search-results-extra .rsg-search-stop-name {
            font-weight: bold; display: block;
        }
        #rsg-stop-search-results-extra .rsg-search-stop-details {
            font-size: 0.8em; color: #bdc3c7; display: block; margin-top:0.1em;
        }
        #rsg-stop-search-results-extra .rsg-search-serving-routes {
            margin-top: 0.3em;
        }
         /* --- END: Route Schedule Generator Styles --- */

        /* For screen-reader only content, used by hidden checkboxes */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Styling for the profile tiles in the Route Profile Deletion tool */
        .rpd-profile-tile {
            /* Inherits from .selectable-route-tile */
            background-color: #4A5568; /* A neutral default */
            color: white;
        }
        /* .rpd-profile-tile.selected is handled by .selectable-route-tile.selected */

    </style>
</head>
<body>
    <div class="page-container">
        <h1>OMSI Tools - Extra Modules</h1>

        <div id="auth-section" class="section">
            <h2>Admin Login</h2>
            <div id="login-form-container_extra">
                <form id="adminLoginForm_extra">
                    <div class="form-grid" style="grid-template-columns: 1fr;">
                        <div><label for="inputEmail_extra">Email</label><input type="email" id="inputEmail_extra" autocomplete="email"></div>
                        <div><label for="inputPassword_extra">Password</label><input type="password" id="inputPassword_extra" autocomplete="current-password"></div>
                    </div>
                    <button id="loginButton_extra" type="submit" class="button">Login</button>
                </form>
                <p id="auth-status_extra" style="margin-top: 0.5em; color: #f1c40f;"></p>
            </div>
            <div id="logout-container_extra" style="display:none;">
                <p>Logged in as: <span id="loggedInUserEmail_extra"></span></p>
                <button id="logoutButton_extra" class="button secondary">Logout</button>
            </div>
        </div>

        <div id="current-profile-display-container" style="display:none;">
            <p id="current-profile-display">Today's Auto Profile: (determining...)</p>
        </div>

        <div id="top-menu-bar_extra" style="display:none;">
            <div id="main-menu-buttons_extra">
                <button class="menu-button" data-section="day-profile-override-section_extra">Day Profile Override</button>
                <button class="menu-button" data-section="stop-manager-tool-section_extra">Stop Management & Creation</button>
                <button class="menu-button" data-section="global-route-deletion-section_extra">Global Route Deletion</button>
                <button class="menu-button" data-section="route-schedule-generator-section_extra">Route Schedule Generator</button>
                <button class="menu-button" data-section="route-profile-deletion-section_extra">Route Profile Deletion</button>
            </div>
        </div>

        <div id="tool-sections-wrapper_extra">
            
            <div id="day-profile-override-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Operational Day Profile Override</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Use this tool to manually set a specific operating profile for an upcoming date, overriding the automatic calculation. Changes are saved immediately.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">Select Date and Override Profile</h3>
                    <div class="form-grid" style="grid-template-columns: 1fr 2fr 1fr; align-items: end; gap: 1rem;">
                        <div>
                            <label for="overrideDate_extra">Select Date:</label>
                            <input type="date" id="overrideDate_extra" class="schedule-generator-input">
                        </div>
                        <div>
                            <label for="overrideProfile_extra">Override Profile String:</label>
                            <input type="text" id="overrideProfile_extra" class="schedule-generator-input" placeholder="e.g., Su, MFSch, CustomHoliday">
                        </div>
                        <div>
                            <button id="setOverrideButton_extra" class="button save">Set Override</button>
                        </div>
                    </div>
                    <div style="margin-top: 1rem;">
                        <p style="font-size: 0.85em;">Normally for <span id="selectedDateDisplay_extra" style="font-weight:bold;">(select a date)</span>, the auto-profile would be: <strong id="autoProfileForSelectedDate_extra">(calculating...)</strong></p>
                        <p style="font-size: 0.85em;">Current override for selected date: <strong id="currentOverrideForSelectedDate_extra">(none)</strong></p>
                        <button id="clearOverrideButton_extra" class="button secondary" style="display:none; margin-top:0.5em;">Clear Override for This Date</button>
                    </div>
                    <p id="overrideStatusMessage_extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
                </div>
                <div class="subsection" style="margin-top: 2rem;">
                    <h3 class="subsection-title">Currently Active Overrides (Next 30 Days)</h3>
                    <div id="activeOverridesList_extra" style="max-height: 200px; overflow-y: auto; background-color: rgba(0,0,0,0.05); padding: 0.5rem; border-radius: 0.25rem;">
                        <p>Loading active overrides...</p> </div>
                </div>
            </div>

            <div id="stop-manager-tool-section_extra" class="tool-content-section section" style="display:none;">
                 <h2>Stop Management & Creation (Live Updates)</h2>
                <div class="subsection">
                    <h3 class="subsection-title">Add New Stop Details</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        Define a new stop. The Stop ID will be auto-suggested based on format (inferred or randomly chosen based on name) and existing stop patterns. You can edit the suggested ID.
                        A placeholder schedule entry will be added to make it available in selectors. The Stop ID must be unique. Changes are saved directly to Firebase.
                    </p>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                        <div>
                            <label for="inputNewStopName_extra">New Stop Name (influences ID suggestion)</label>
                            <input type="text" id="inputNewStopName_extra" class="schedule-generator-input" placeholder="e.g., Yaddlethorpe Crossroads" autocomplete="off">
                        </div>
                        <div>
                             <label for="selectNewStopIdFormat_extra">System-Determined ID Format</label>
                             <select id="selectNewStopIdFormat_extra" class="schedule-generator-input" disabled>
                                <option value="NUM">Numeric (e.g., 101-99999)</option>
                                <option value="BP">BP Prefix (e.g., BP1-BP99999)</option>
                                <option value="LE">LE Prefix (e.g., LE1-LE99999)</option>
                                <option value="RO">RO Prefix (e.g., RO1-RO99999)</option>
                            </select>
                        </div>
                        <div>
                            <label for="inputNewStopId_extra">New Stop ID (auto-suggested, editable)</label>
                            <input type="text" id="inputNewStopId_extra" class="schedule-generator-input" placeholder="e.g., BP101" autocomplete="off">
                            <p id="newStopIdAvailability_extra"></p>
                        </div>
                        <div>
                            <label for="inputNewStopDirection_extra">New Stop Direction (Towards)</label>
                            <input type="text" id="inputNewStopDirection_extra" class="schedule-generator-input" placeholder="e.g., Ashby" autocomplete="off">
                        </div>
                    </div>
                     <p id="addNewStopStatus_extra" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                    <div style="margin-top: 1rem;">
                        <button id="buttonAddNewStop_extra" class="button save">Add New Stop Details (Live)</button>
                    </div>
                </div>

                <div class="subsection"> <h3 class="subsection-title">Bulk Merge or Add Stops (via Excel File)</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        This tool will <strong style="color: #f1c40f;">REPLACE ALL EXISTING STOPS AND SCHEDULES</strong> with data derived from the uploaded Excel file.
                        <br>- The system will attempt to generate unique StopIDs based on StopName. If a StopID is provided in Column A, it will be used (must be unique within the file).
                        <br>- LineName(s) from Excel will be used to create placeholder schedule entries for each stop.
                        <br><b>Expected Excel columns:</b>
                        <br>Column A: <b>StopID</b> (Optional - if blank, system generates. If provided, must be unique in the file.)
                        <br>Column B: <b>StopName</b> (Required)
                        <br>Column C: <b>Direction</b> (Optional - "Towards" text)
                        <br>Column D: <b>LineName(s)</b> (Optional - comma-separated, e.g., "9, 12, 34". Defaults to "INFO_ONLY".)
                        <br><i>The first row of the sheet should contain data, not headers.</i>
                        All changes are saved directly to Firebase. <strong style="color: #e74c3c;">USE WITH EXTREME CAUTION.</strong>
                    </p>
                    <div class="form-field-group">
                        <label for="fileInputBulkAddStops_extra" class="button neutral" style="display: inline-block; margin-bottom: 0.5rem; background-color: #546E7A; cursor:pointer;">Choose Excel File (.xlsx, .xls)</label>
                        <input type="file" id="fileInputBulkAddStops_extra" accept=".xlsx, .xls" style="display: none;">
                        <p id="fileNameBulkAddStops_extra" style="font-size: 0.85em; margin-top: 0.25rem; min-height: 1.2em;">No file selected.</p>
                    </div>
                    <p id="bulkAddNewStopsStatus_extra" style="min-height:1.2em; margin-top: 0.75rem; white-space: pre-line;"></p>
                    <div style="margin-top: 1rem;">
                        <button id="buttonBulkAddNewStops_extra" class="button tertiary">Replace All Stops & Schedules from File (Live)</button> </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Master List of Unique Stops (with ID Change Capability)</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.75rem;">
                        View and edit stop details. You can also propose new Stop IDs for existing stops.
                        All proposed Stop ID changes are applied in bulk using the button at the bottom of this list.
                        Other actions (Edit Name / Direction, Delete, Open / Close) are immediate for that specific stop.
                    </p>
                    <div class="form-grid" style="grid-template-columns: 1fr auto auto auto; gap: 0.75rem; margin-bottom: 0.5rem;">
                        <input type="text" id="masterStopListFilterInput_extra" class="schedule-generator-input" placeholder="Filter by Stop ID, Name, Route, Status...">
                        <button id="refreshMasterStopListButton_extra" class="button neutral">Refresh List</button>
                        <button id="exportUniqueStopsButton_extra" class="button" style="background-color: #00796B;">Export Stops</button>
                        <button id="findDuplicateStopsByNameDirButton_extra" class="button tertiary">Find Duplicates (Name / Direction)</button>
                    </div>
                    <div id="duplicateStopsByNameDirResults_extra" style="margin-bottom: 0.75rem; padding: 0.5rem; background-color: rgba(0,0,0,0.1); border-radius: 0.25rem; min-height: 1.5em; font-size: 0.85em;">
                        Click "Find Duplicates (Name/Dir)" to check. </div>
                    <div id="masterStopListContainer_extra" class="subsection" style="padding: 0.5rem; background-color: rgba(0,0,0,0.05); margin-top:0;">
                        <ul id="masterStopListUL_extra" style="list-style: none; padding: 0;"></ul> </div>
                    <p id="masterStopListStatus_extra" style="text-align: center; margin-top: 0.5rem; min-height: 1.2em;">Click "Refresh List" to load stops.</p>

                    <div class="subsection" style="margin-top: 1.5rem; text-align: center;">
                        <button id="applyMasterListStopIdChangesButton_extra" class="button save" style="padding: 0.8rem 1.5rem;">Apply All Stop ID Changes from List (Live)</button>
                        <p id="masterListApplyChangesStatus_extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
                    </div>
                </div>
            </div>

            <div id="global-route-deletion-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Global Route Deletion (Live)</h2>
                <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                    Click on route tiles below to select them for deletion. This will remove ALL of their schedule entries from ALL stops in the live schedule.
                    It will also remove their global custom colour and any stop-specific colour overrides for the selected routes.
                    <strong>This action is highly destructive and directly modifies live data.</strong>
                </p>
                <div class="form-field-group">
                    <label>Select Route(s) to Delete Globally by clicking tiles:</label>
                    <div id="globalRouteDeletionListContainer_el_extra" class="subsection" style="max-height: 300px; overflow-y: auto; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border: 1px solid rgba(127,140,141,0.2);">
                        <p>Loading routes...</p> </div>
                </div>
                <button id="deleteEntireRouteButton_el_extra" class="button secondary" style="margin-top: 0.5rem;">Delete Selected Route(s) (Live)</button>
                <p id="deleteEntireRouteStatusMessage_el_extra" style="min-height:1.2em; margin-top:0.75rem;"></p>
            </div>

            <div id="route-profile-deletion-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Selective Route Profile Deletion</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    This tool allows you to delete specific operating profiles for a chosen route.
                    You can optionally narrow this down to a particular destination. Deleting a profile here will remove
                    all its associated schedule entries from the live data for the specified route/destination combination.
                    <strong>This action is highly destructive. Please double-check your selections.</strong>
                </p>

                <div class="subsection">
                    <h3 class="subsection-title">1. Selection Criteria</h3>
                    <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem 1.5rem; align-items: end;">
                        <div>
                            <label for="rpd-route-name-select-extra">Route Name (Select or Type):</label>
                            <select id="rpd-route-name-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Route --</option>
                                </select>
                            <input type="text" id="rpd-route-name-input-extra" class="schedule-generator-input" placeholder="Or Type Route Name">
                        </div>
                        <div>
                            <label for="rpd-destination-name-select-extra">Destination Name (Optional - Select or Type):</label>
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <select id="rpd-destination-name-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem; flex-grow:1;" disabled>
                                    <option value="">-- Optional: All Destinations --</option>
                                     </select>
                                <button id="rpd-clear-destination-button-extra" class="button small-action neutral" title="Clear Destination Filter (Show All Destinations for Route)" style="display:none; padding: 0.4rem 0.6rem; margin-bottom:0.25rem; line-height: 1.5;">✕</button>
                            </div>
                            <input type="text" id="rpd-destination-name-input-extra" class="schedule-generator-input" placeholder="Or Type Destination (Leave Blank for All)" disabled>
                        </div>
                    </div>
                </div>

                <div class="subsection" style="margin-top:1.5rem;">
                    <h3 class="subsection-title">2. Select Profile(s) to Delete</h3>
                    <div class="form-field-group">
                        <label style="margin-bottom:0.5rem; display:block;">Available Profiles for Selected Criteria (Click tiles to select for deletion):</label>
                        <div id="rpd-profile-list-container-extra" class="subsection" style="min-height: 60px; background-color: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 0.25rem; border: 1px solid rgba(127,140,141,0.2);">
                            <p style="font-size:0.85em; opacity:0.7;">Select a route to see available profiles.</p>
                            </div>
                    </div>
                </div>

                <div class="subsection" style="margin-top:1.5rem;">
                    <h3 class="subsection-title">3. Execute Deletion</h3>
                    <button id="rpd-delete-profiles-button-extra" class="button secondary" style="margin-top: 0.5rem;">Delete Selected Profile(s) (Live)</button>
                    <p id="rpd-status-message-extra" style="min-height:1.2em; margin-top:0.75rem; font-weight:bold;"></p>
                </div>
            </div>
            <div id="route-schedule-generator-section_extra" class="tool-content-section section" style="display:none;">
                <h2>Route Schedule Generator</h2>
                <p style="font-size:0.9em; margin-bottom:1.5em; opacity: 0.8;">
                    Create or modify a schedule for a route. Saved configurations can be loaded, or you can copy stops from an existing route.
                </p>
                <div class="subsection">
                    <h3 class="subsection-title">1. Route & Profile Definition</h3>
                    <p style="font-size:0.8em; margin-bottom:0.75em; opacity:0.7;">
                        Select Route, Profile, and Destination. System will try to load a saved configuration or pull from existing schedule. If Operating Profile is left blank, a default may be used for initial display.
                    </p>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                        <div>
                            <label for="rsg-routeName-select-extra">Route Name (Select or Type New):</label>
                            <select id="rsg-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Existing Route --</option>
                            </select>
                            <input type="text" id="rsg-routeName-input-extra" class="schedule-generator-input" placeholder="Or Type New Route Name">
                        </div>
                        <div>
                            <label for="rsg-operatingProfile-input-extra">Operating Profile (e.g., MF, Sa, Su):</label>
                            <input type="text" id="rsg-operatingProfile-input-extra" class="schedule-generator-input" placeholder="Enter Operating Profile (can be blank initially)">
                        </div>
                    </div>

<!--COMMENTED OUT - AWAITING FOR JAVA SCRIPT TO BE IMPLEMENTED-->
<!--
<label style="display: block; margin-bottom: 0.5rem;">Operating Profile(s) (Select all that apply):</label>
<div id="rsg-selectable-profiles-container-extra" class="subsection" style="margin-top: 0.25rem; padding: 0.75rem; background-color: rgba(0,0,0,0.07); border-radius: 0.25rem; min-height: 80px; max-height: 200px; overflow-y: auto;">
    <p style="font-size: 0.8em; opacity: 0.7;">Profiles will be listed here. Select Route and Destination first if applicable for loading saved configurations.</p>
</div>
--> 
                     
<div class="form-grid" style="grid-template-columns: 1fr;">
                         <div>
                            <label for="rsg-destinationName-select-extra">Destination Name (Select for Route or Type New):</label>
                            <select id="rsg-destinationName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                                <option value="">-- Select Route First --</option>
                            </select>
                            <input type="text" id="rsg-destinationName-input-extra" class="schedule-generator-input" placeholder="Or Type New Destination Name">
                        </div>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">2. Define Stop Sequence & Timings</h3>
                    <button id="rsg-open-copy-modal-button-extra" class="button neutral" style="margin-bottom: 0.5rem;">Copy Stops From Another Route/Profile...</button>
                    <div class="form-field-group">
                        <label for="rsg-stop-search-input-extra">Search and Add Stop to Sequence:</label>
                        <input type="text" id="rsg-stop-search-input-extra" class="schedule-generator-input" placeholder="Type to search stops by name or ID...">
                        <div id="rsg-stop-search-results-extra"></div> </div>

                    <label>Stop Sequence (Drag to reorder. First stop times, subsequent stops are adjustments in minutes from previous):</label>
                    <div id="rsg-stop-sequence-container-extra" class="subsection" style="padding:0.5rem; background-color:rgba(0,0,0,0.05); min-height: 100px;">
                        <ul id="rsg-stop-sequence-list-extra" style="list-style: none; padding: 0;">
                            </ul>
                        <p id="rsg-stop-sequence-placeholder-extra" style="text-align:center; opacity:0.7; padding:1rem;">Add stops using the search, copy from another route, or load a configuration.</p>
                    </div>
                     <div class="form-field-group" id="rsg-first-stop-times-container-extra" style="display:none;">
                        <label for="rsg-first-stop-times-input-extra">Departure Times for First Stop (HH:MM, comma/tab/semicolon separated):</label>
                        <textarea id="rsg-first-stop-times-input-extra" class="schedule-generator-input" rows="2" placeholder="07:00, 07:15; 07:30   08:00"></textarea>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">3. Generate & Add to Working Schedule</h3>
                    <button id="rsg-generate-schedule-button-extra" class="button save">Generate Schedule Preview</button>
                    <button id="rsg-save-configuration-button-extra" class="button" style="background-color: #546E7A; margin-left:0.5rem;">Save Current Configuration</button>
                    <button id="rsg-add-to-working-schedule-button-extra" class="button tertiary" style="display:none; margin-left:0.5rem;">Add Generated to Working Schedule</button>
                    <p id="rsg-status-message-extra" style="min-height:1.2em; margin-top: 1rem; font-weight:bold;"></p>
                    <div id="rsg-schedule-preview-container-extra" class="subsection" style="margin-top:1rem; max-height:300px; overflow-y:auto; display:none;">
                        <h4>Preview of Generated Schedule Entries:</h4>
                        <table id="rsg-preview-table-extra" style="width:100%; font-size:0.85em; border-collapse:collapse;">
                            <thead>
                                <tr>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Stop ID</th>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Stop Name</th>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Time</th>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Route</th>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Dest</th>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Profile</th>
                                    <th style="border:1px solid #566573; padding:0.3rem;">Offset</th>
                                </tr>
                            </thead>
                            <tbody></tbody> </table>
                    </div>
                </div>
            </div>

            </div> </div> <div id="rsg-copy-modal-extra" style="position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 1000; justify-content: center; align-items: center; display: none;">
        <div style="background: linear-gradient(135deg, #3a506b, #2c3e50); color: #ecf0f1; padding: 25px; border-radius: 8px; width: 90%; max-width: 550px; box-shadow: 0 5px 20px rgba(0,0,0,0.4); border: 1px solid #4a6a80;">
            <h3 class="subsection-title" style="margin-top:0; padding-bottom: 0.5rem; border-color: #567a9a;">Copy Stops From Source</h3>
            <p style="font-size:0.85em; margin-bottom:1.5rem; opacity:0.9;">
                Select the source Route, Operating Profile, and Destination from which to copy the stop sequence, time adjustments, and first stop departure times.
            </p>

            <div class="form-field-group">
                <label for="rsg-copy-source-routeName-select-extra">Source Route Name:</label>
                <select id="rsg-copy-source-routeName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                    <option value="">-- Select Source Route --</option>
                </select>
                <input type="text" id="rsg-copy-source-routeName-input-extra" class="schedule-generator-input" placeholder="Or Type Source Route Name">
            </div>
            <div class="form-field-group">
                <label for="rsg-copy-source-operatingProfile-input-extra">Source Operating Profile:</label>
                <input type="text" id="rsg-copy-source-operatingProfile-input-extra" class="schedule-generator-input" placeholder="Enter Source Operating Profile (e.g., MF, Sa)">
            </div>
            <div class="form-field-group">
                <label for="rsg-copy-source-destinationName-select-extra">Source Destination Name:</label>
                <select id="rsg-copy-source-destinationName-select-extra" class="schedule-generator-input" style="margin-bottom:0.25rem;">
                    <option value="">-- Select Source Route First --</option>
                </select>
                <input type="text" id="rsg-copy-source-destinationName-input-extra" class="schedule-generator-input" placeholder="Or Type Source Destination Name">
            </div>
            <p id="rsg-copy-modal-status-extra" style="min-height:1.2em; margin-top: 0.75rem; font-weight:bold;"></p>
            <div style="margin-top: 1.5rem; text-align: right; display: flex; justify-content: flex-end; gap: 0.5rem;">
                <button id="rsg-copy-modal-cancel-button-extra" class="button neutral">Cancel</button>
                <button id="rsg-copy-modal-action-button-extra" class="button save">Copy Data</button>
            </div>
        </div>
    </div>

<script type="module">
      // Firebase App initialization (content unchanged)
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s", // Replace with your actual key
        authDomain: "omsi-c5505.firebaseapp.com", // Replace
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app", // Replace
        projectId: "omsi-c5505", // Replace
        storageBucket: "omsi-c5505.appspot.com", // Replace
        messagingSenderId: "503595375440", // Replace
        appId: "1:503595375440:web:356be6684b77ff5909ea55", // Replace
        measurementId: "G-VN7X65V3F9" // Replace
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);

      window.firebaseOMSI = {
          database: database, auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut
      };
      console.log("Firebase Initialized for OMSI Tools Extra.");
      document.dispatchEvent(new CustomEvent('firebaseReady', { detail: window.firebaseOMSI }));
    </script>

<script>
// --- Global State Variables ---
        let currentUser_extra = null;
        let pageSpecificSettings = {};
        let ukBankHolidaysData_extra = { dates: [], titles: {} };
        const schoolHolidayDateRanges_extra = [];
        let currentWorkingSchedule_extra = []; // This will be populated by flattening the new structure on load
        let closedStopIDs_extra = [];
        let globalCustomRouteColours_extra = {};
        let stopSpecificRouteColours_extra = {};
        let uniqueStopsMasterList_extra = [];
        let processedExcelStopsData_extra = [];
        let rsg_selectedStops_extra = [];
        let rsg_generatedPreviewEntries_extra = [];
        let rsg_loadedConfigs_extra = {};
        let rsg_lastLoadedRouteName_extra = null;
        let rsg_lastLoadedDestName_extra = null;
        let rsg_lastLoadedOpProfile_extra = null;
        let rsg_draggedItemIndex_extra = null;


        // --- Firebase Path Constants ---
        const FB_PATH_PAGE_EXTRA_SETTINGS = '/settings/extraModulesPageSettings';
        const FB_PATH_OPERATIONAL_OVERRIDES = '/operationalOverrides';
        // Replaced FB_PATH_LIVE_SCHEDULE_DATA with FB_PATH_SCHEDULES_BY_ROUTE
        const FB_PATH_SCHEDULES_BY_ROUTE = '/liveSchedule/schedulesByRoute'; // New path for structured schedule data
        const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
        const FB_PATH_APPSTATE_LAST_UPDATED = '/appState/scheduleLastUpdated';
        const FB_PATH_APPSTATE_CLOSED_STOPS = '/appState/closedStopIDs';
        const FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS = '/settings/customRouteColours';
        const FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS = '/settings/stopSpecificRouteColours';
        const FB_PATH_RSG_CONFIGS = '/rsgConfigs';


        // --- DOM Elements ---
        const authSection_el_extra = document.getElementById('auth-section');
        const loginFormContainer_el_extra = document.getElementById('login-form-container_extra');
        const adminLoginForm_el_extra = document.getElementById('adminLoginForm_extra');
        const inputEmail_el_extra = document.getElementById('inputEmail_extra');
        const inputPassword_el_extra = document.getElementById('inputPassword_extra');
        const authStatus_el_extra = document.getElementById('auth-status_extra');
        const logoutContainer_el_extra = document.getElementById('logout-container_extra');
        const loggedInUserEmailDisplay_el_extra = document.getElementById('loggedInUserEmail_extra');
        const topMenuBar_el_extra = document.getElementById('top-menu-bar_extra');
        const toolSectionsWrapper_el_extra = document.getElementById('tool-sections-wrapper_extra');
        const currentProfileDisplayContainer_el = document.getElementById('current-profile-display-container');
        const currentProfileDisplayElement_el = document.getElementById('current-profile-display');
        // Day Profile Override
        const overrideDateInput_el_extra = document.getElementById('overrideDate_extra');
        const overrideProfileInput_el_extra = document.getElementById('overrideProfile_extra');
        const setOverrideButton_el_extra = document.getElementById('setOverrideButton_extra');
        const clearOverrideButton_el_extra = document.getElementById('clearOverrideButton_extra');
        const overrideStatusMessage_el_extra = document.getElementById('overrideStatusMessage_extra');
        const selectedDateDisplay_el_extra = document.getElementById('selectedDateDisplay_extra');
        const autoProfileForSelectedDate_el_extra = document.getElementById('autoProfileForSelectedDate_extra');
        const currentOverrideForSelectedDate_el_extra = document.getElementById('currentOverrideForSelectedDate_extra');
        const activeOverridesList_el_extra = document.getElementById('activeOverridesList_extra');
        // Stop Management & Creation
        const selectNewStopIdFormat_el_extra = document.getElementById('selectNewStopIdFormat_extra');
        const inputNewStopId_el_extra = document.getElementById('inputNewStopId_extra');
        const newStopIdAvailability_el_extra = document.getElementById('newStopIdAvailability_extra');
        const inputNewStopName_el_extra = document.getElementById('inputNewStopName_extra');
        const inputNewStopDirection_el_extra = document.getElementById('inputNewStopDirection_extra');
        const buttonAddNewStop_el_extra = document.getElementById('buttonAddNewStop_extra');
        const addNewStopStatus_el_extra = document.getElementById('addNewStopStatus_extra');
        const fileInputBulkAddStops_el_extra = document.getElementById('fileInputBulkAddStops_extra');
        const fileNameBulkAddStops_el_extra = document.getElementById('fileNameBulkAddStops_extra');
        const buttonBulkAddNewStops_el_extra = document.getElementById('buttonBulkAddNewStops_extra');
        const bulkAddNewStopsStatus_el_extra = document.getElementById('bulkAddNewStopsStatus_extra');
        const masterStopListFilterInput_el_extra = document.getElementById('masterStopListFilterInput_extra');
        const refreshMasterStopListButton_el_extra = document.getElementById('refreshMasterStopListButton_extra');
        const masterStopListUL_el_extra = document.getElementById('masterStopListUL_extra');
        const masterStopListStatus_el_extra = document.getElementById('masterStopListStatus_extra');
        const applyMasterListStopIdChangesButton_el_extra = document.getElementById('applyMasterListStopIdChangesButton_extra');
        const masterListApplyChangesStatus_el_extra = document.getElementById('masterListApplyChangesStatus_extra');
        const exportUniqueStopsButton_el_extra = document.getElementById('exportUniqueStopsButton_extra');
        const findDuplicateStopsByNameDirButton_el_extra = document.getElementById('findDuplicateStopsByNameDirButton_extra');
        const duplicateStopsByNameDirResults_el_extra = document.getElementById('duplicateStopsByNameDirResults_extra');
        // Global Route Deletion
        const globalRouteDeletionListContainer_el_extra = document.getElementById('globalRouteDeletionListContainer_el_extra');
        const deleteEntireRouteButton_el_extra = document.getElementById('deleteEntireRouteButton_el_extra');
        const deleteEntireRouteStatusMessage_el_extra = document.getElementById('deleteEntireRouteStatusMessage_el_extra');
        // Route Schedule Generator (RSG)
        const rsgRouteNameSelect_el_extra = document.getElementById('rsg-routeName-select-extra');
        const rsgRouteNameInput_el_extra = document.getElementById('rsg-routeName-input-extra');
        const rsgOperatingProfileInput_el_extra = document.getElementById('rsg-operatingProfile-input-extra');
        const rsgDestinationNameSelect_el_extra = document.getElementById('rsg-destinationName-select-extra');
        const rsgDestinationNameInput_el_extra = document.getElementById('rsg-destinationName-input-extra');
        const rsgStopSearchInput_el_extra = document.getElementById('rsg-stop-search-input-extra');
        const rsgStopSearchResults_el_extra = document.getElementById('rsg-stop-search-results-extra');
        const rsgStopSequenceList_el_extra = document.getElementById('rsg-stop-sequence-list-extra');
        const rsgStopSequencePlaceholder_el_extra = document.getElementById('rsg-stop-sequence-placeholder-extra');
        const rsgFirstStopTimesContainer_el_extra = document.getElementById('rsg-first-stop-times-container-extra');
        const rsgFirstStopTimesInput_el_extra = document.getElementById('rsg-first-stop-times-input-extra');
        const rsgGenerateScheduleButton_el_extra = document.getElementById('rsg-generate-schedule-button-extra');
        const rsgSaveConfigurationButton_el_extra = document.getElementById('rsg-save-configuration-button-extra');
        const rsgAddToWorkingScheduleButton_el_extra = document.getElementById('rsg-add-to-working-schedule-button-extra');
        const rsgStatusMessage_el_extra = document.getElementById('rsg-status-message-extra');
        const rsgSchedulePreviewContainer_el_extra = document.getElementById('rsg-schedule-preview-container-extra');
        const rsgPreviewTableBody_el_extra = document.getElementById('rsg-preview-table-extra')?.getElementsByTagName('tbody')[0];
        const rsgOpenCopyModalButton_el_extra = document.getElementById('rsg-open-copy-modal-button-extra');
        const rsgCopyModal_el_extra = document.getElementById('rsg-copy-modal-extra');
        const rsgCopySourceRouteNameSelect_el_extra = document.getElementById('rsg-copy-source-routeName-select-extra');
        const rsgCopySourceRouteNameInput_el_extra = document.getElementById('rsg-copy-source-routeName-input-extra');
        const rsgCopySourceOpProfileInput_el_extra = document.getElementById('rsg-copy-source-operatingProfile-input-extra');
        const rsgCopySourceDestNameSelect_el_extra = document.getElementById('rsg-copy-source-destinationName-select-extra');
        const rsgCopySourceDestNameInput_el_extra = document.getElementById('rsg-copy-source-destinationName-input-extra');
        const rsgCopyModalStatus_el_extra = document.getElementById('rsg-copy-modal-status-extra');
        const rsgCopyModalCancelButton_el_extra = document.getElementById('rsg-copy-modal-cancel-button-extra');
        const rsgCopyModalActionButton_el_extra = document.getElementById('rsg-copy-modal-action-button-extra');
        // Route Profile Deletion (RPD) - NEW
        const rpdRouteSelect_el_extra = document.getElementById('rpd-route-name-select-extra');
        const rpdRouteInput_el_extra = document.getElementById('rpd-route-name-input-extra');
        const rpdDestinationSelect_el_extra = document.getElementById('rpd-destination-name-select-extra');
        const rpdDestinationInput_el_extra = document.getElementById('rpd-destination-name-input-extra');
        const rpdClearDestinationButton_el_extra = document.getElementById('rpd-clear-destination-button-extra');
        const rpdProfileListContainer_el_extra = document.getElementById('rpd-profile-list-container-extra');
        const rpdDeleteProfilesButton_el_extra = document.getElementById('rpd-delete-profiles-button-extra');
        const rpdStatusMessage_el_extra = document.getElementById('rpd-status-message-extra');


        // --- Helper Functions ---
        function sanitizeFirebaseKey(text) {
            if (typeof text !== 'string') return '';
            // Replace forbidden characters with an underscore
            // Firebase forbids '.', '#', '$', '[', ']'
            return text.replace(/[.#$[\]]/g, '_');
        }

        function getYYYYMMDD_ExtraPage(dateSource) { const d = dateSource ? new Date(dateSource) : new Date(); const year = d.getFullYear(); const month = String(d.getMonth() + 1).padStart(2, '0'); const day = String(d.getDate()).padStart(2, '0'); return `${year}-${month}-${day}`; }
        function formatDateToDDMonthYYYY_ExtraPage(dateStringYYYYMMDD) { if (!dateStringYYYYMMDD || !/^\d{4}-\d{2}-\d{2}$/.test(dateStringYYYYMMDD)) return "Invalid Date"; const [year, month, day] = dateStringYYYYMMDD.split('-'); const dateObj = new Date(year, month - 1, day); const options = { day: '2-digit', month: 'long', year: 'numeric' }; return dateObj.toLocaleDateString('en-GB', options); }
        function getUniqueStopsFromSchedule_ExtraPage() { if (!currentWorkingSchedule_extra || currentWorkingSchedule_extra.length === 0) return []; const stopsMap = new Map(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID && !stopsMap.has(entry.stopID.toUpperCase())) { stopsMap.set(entry.stopID.toUpperCase(), { stopID: entry.stopID, stopName: entry.stopName || "Unknown Name", direction: entry.direction || "No Direction" }); } }); return Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase())); }
        function parseLineName_ExtraPage(lineNameStr) { const name = String(lineNameStr || "").toUpperCase().trim(); const numericPrefixRegex = new RegExp(/^(\d+)([A-Z]*)$/); const alphaNumericRegex = new RegExp(/^([A-Z]+)(\d+)?([A-Z]*)$/); const numericPrefixMatch = name.match(numericPrefixRegex); if (numericPrefixMatch) return { type: 'numeric', number: parseInt(numericPrefixMatch[1], 10), suffix: numericPrefixMatch[2] || '', original: name }; const alphaNumericMatch = name.match(alphaNumericRegex); if (alphaNumericMatch) return { type: 'alpha', prefix: alphaNumericMatch[1], number: alphaNumericMatch[2] ? parseInt(alphaNumericMatch[2], 10) : null, suffix: alphaNumericMatch[3] || '', original: name }; return { type: 'other', original: name }; }
        function compareLineNames_ExtraPage(lineAStr, lineBStr) { const parsedA = parseLineName_ExtraPage(lineAStr); const parsedB = parseLineName_ExtraPage(lineBStr); if (parsedA.type === 'numeric' && parsedB.type === 'alpha') return -1; if (parsedA.type === 'alpha' && parsedB.type === 'numeric') return 1; if (parsedA.type === 'numeric' && parsedB.type === 'numeric') { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type === 'alpha' && parsedB.type === 'alpha') { const prefixCompare = parsedA.prefix.localeCompare(parsedB.prefix); if (prefixCompare !== 0) return prefixCompare; if (parsedA.number === null && parsedB.number !== null) return -1; if (parsedA.number !== null && parsedB.number === null) return 1; if (parsedA.number !== null && parsedB.number !== null) { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; } return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type !== 'other' && parsedB.type === 'other') return -1; if (parsedA.type === 'other' && parsedB.type !== 'other') return 1; return (parsedA.original || "").localeCompare(parsedB.original || ""); }
        const initialRouteColourMapForTools_extra = {}; const DEFAULT_ROUTE_COLOUR_TOOLS_extra = "#73809C"; const NIGHT_BUS_BLUE_COLOR_extra = (initialRouteColourMapForTools_extra["NIGHT_DEFAULT"] || "#4CDBE6").toUpperCase();
        function getRouteTileColour_ExtraPage(lineName, stopID = null) { const upName = String(lineName || "").toUpperCase(); if (stopID && stopSpecificRouteColours_extra[stopID.toUpperCase()] && stopSpecificRouteColours_extra[stopID.toUpperCase()][upName]) { return stopSpecificRouteColours_extra[stopID.toUpperCase()][upName]; } if (globalCustomRouteColours_extra[upName]) return globalCustomRouteColours_extra[upName]; if (initialRouteColourMapForTools_extra[upName]) return initialRouteColourMapForTools_extra[upName]; if (upName.startsWith("N")) return globalCustomRouteColours_extra["NIGHT_DEFAULT"] || NIGHT_BUS_BLUE_COLOR_extra; if (upName.startsWith("SL")) return globalCustomRouteColours_extra["SL_DEFAULT"] || "#D32F2F"; return DEFAULT_ROUTE_COLOUR_TOOLS_extra; }
        function getTextColourForBackground_ExtraPage(hex) { if(!hex || hex.length < 7) return '#FFFFFF'; const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16); return ((0.299*r + 0.587*g + 0.114*b)/255) > 0.5 ? '#000000' : '#FFFFFF'; }
        async function fetchBankHolidays_ExtraPage() { try { const response = await fetch('https://www.gov.uk/bank-holidays.json'); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); if (data['england-and-wales'] && data['england-and-wales'].events) { const events = data['england-and-wales'].events; ukBankHolidaysData_extra = { dates: events.map(event => event.date), titles: events.reduce((acc, event) => { acc[event.date] = event.title; return acc; }, {}) }; } else { ukBankHolidaysData_extra = { dates: [], titles: {} }; } } catch (error) { console.error("ExtraPage: Failed to fetch UK bank holidays:", error); ukBankHolidaysData_extra = { dates: [], titles: {} }; if(currentProfileDisplayElement_el) currentProfileDisplayElement_el.textContent = "Today's Auto Profile: (Bank Hol. check failed)"; } updateCurrentProfileDisplay_ExtraPage(); }
        function isSchoolHolidayPeriod_ExtraPage(dateObject) { if (!schoolHolidayDateRanges_extra || schoolHolidayDateRanges_extra.length === 0) return false; const checkTime = dateObject.getTime(); for (const range of schoolHolidayDateRanges_extra) { try { const startTime = new Date(range.start + "T00:00:00").getTime(); const endTime = new Date(range.end + "T23:59:59").getTime(); if (checkTime >= startTime && checkTime <= endTime) return true; } catch (e) { console.error("Invalid date in schoolHolidayDateRanges_extra:", range, e); } } return false; }
        function getOperatingCodesForDate_ExtraPage(dateObject) { const n = dateObject; const dOW = n.getDay(); const todayDateString = `${n.getFullYear()}-${String(n.getMonth()+1).padStart(2,'0')}-${String(n.getDate()).padStart(2,'0')}`; let dateCodes = new Set(); let isBankHolidayToday = false; if (ukBankHolidaysData_extra && ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(todayDateString)) { const holidayTitle = ukBankHolidaysData_extra.titles[todayDateString] || ""; isBankHolidayToday = true; if (holidayTitle.toLowerCase().includes("good friday")) dateCodes.add("Sa"); else dateCodes.add("Su"); } if (!isBankHolidayToday) { const isSchHol = isSchoolHolidayPeriod_ExtraPage(n); const schoolSuffix = isSchHol ? "NSD" : "Sch"; let dayCode = ""; switch (dOW) { case 0: dayCode="Su"; break; case 1: dayCode="Mo"; break; case 2: dayCode="Tu"; break; case 3: dayCode="We"; break; case 4: dayCode="Th"; break; case 5: dayCode="Fr"; break; case 6: dayCode="Sa"; break; } dateCodes.add(dayCode); if (dOW >= 1 && dOW <= 5) { dateCodes.add(dayCode + schoolSuffix); dateCodes.add("MF" + schoolSuffix); dateCodes.add("MF"); } if ((dOW === 6 || dOW === 0) && isSchHol) dateCodes.add(dayCode + "NSD"); if (isSchHol) dateCodes.add("SchoolHoliday"); } else { const isSchHolOnBH = isSchoolHolidayPeriod_ExtraPage(n); if (isSchHolOnBH) { dateCodes.add("SchoolHoliday"); if(dateCodes.has("Sa")) dateCodes.add("SaNSD"); if(dateCodes.has("Su") && !dateCodes.has("Sa")) dateCodes.add("SuNSD");} } return Array.from(dateCodes); }
        function updateCurrentProfileDisplay_ExtraPage() { const now = new Date(); const dayOfWeek = now.getDay(); const todayDateString = getYYYYMMDD_ExtraPage(now); let profileDisplayText = ""; let isBankHol = false; let serviceTypeDisplay = ""; if (ukBankHolidaysData_extra.dates && ukBankHolidaysData_extra.dates.includes(todayDateString)) { const holidayTitle = ukBankHolidaysData_extra.titles[todayDateString] || "Bank Holiday"; isBankHol = true; if (holidayTitle.toLowerCase().includes("good friday")) { profileDisplayText = "Good Friday"; serviceTypeDisplay = "(Sat Service)"; } else { profileDisplayText = holidayTitle; serviceTypeDisplay = "(Sun Service)"; } } let dayName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][dayOfWeek]; if (!isBankHol) { profileDisplayText = dayName; if (isSchoolHolidayPeriod_ExtraPage(now)) profileDisplayText += " (School Hol)"; } else { profileDisplayText += ` ${serviceTypeDisplay} - Observed on a ${dayName}`; if (isSchoolHolidayPeriod_ExtraPage(now)) profileDisplayText += " (School Hol Period)"; } const operatingCodes = getOperatingCodesForDate_ExtraPage(now); if (currentProfileDisplayElement_el) currentProfileDisplayElement_el.textContent = `Today's Auto Profile (Extra): ${profileDisplayText} [Codes: ${operatingCodes.join(', ')}]`; }

        // --- Day Profile Override Functions ---
        async function loadAndDisplayOverrides_ExtraPage() { if (!activeOverridesList_el_extra || !window.firebaseOMSI) return; activeOverridesList_el_extra.innerHTML = '<p>Loading active overrides...</p>'; const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const snapshot = await dbGet(dbChild(dbRef(database), FB_PATH_OPERATIONAL_OVERRIDES)); let html = ""; if (snapshot.exists()) { const overrides = snapshot.val(); const today = new Date(); today.setHours(0,0,0,0); const thirtyDaysLater = new Date(today); thirtyDaysLater.setDate(today.getDate() + 30); const relevantOverrides = []; for (const dateKey in overrides) { if (/^\d{4}-\d{2}-\d{2}$/.test(dateKey)) { const overrideDate = new Date(dateKey + "T00:00:00"); if (overrideDate >= today && overrideDate <= thirtyDaysLater) { relevantOverrides.push({ date: dateKey, profile: overrides[dateKey] }); } } } relevantOverrides.sort((a,b) => a.date.localeCompare(b.date)); if (relevantOverrides.length > 0) { html = "<ul>"; relevantOverrides.forEach(ov => { html += `<li><strong>${formatDateToDDMonthYYYY_ExtraPage(ov.date)}:</strong> ${ov.profile}</li>`; }); html += "</ul>"; } else { html = "<p>No overrides set for the next 30 days.</p>"; } } else { html = "<p>No overrides currently set in the system.</p>"; } activeOverridesList_el_extra.innerHTML = html; } catch (error) { console.error("Error loading overrides:", error); activeOverridesList_el_extra.innerHTML = "<p>Error loading overrides.</p>"; } }
        async function updateSelectedDateInfo_ExtraPage() { if (!overrideDateInput_el_extra || !selectedDateDisplay_el_extra || !autoProfileForSelectedDate_el_extra || !currentOverrideForSelectedDate_el_extra || !clearOverrideButton_el_extra) return; const selectedDateStr = overrideDateInput_el_extra.value; clearOverrideButton_el_extra.style.display = 'none'; if (!selectedDateStr) { selectedDateDisplay_el_extra.textContent = "(select a date)"; autoProfileForSelectedDate_el_extra.textContent = "(select a date)"; currentOverrideForSelectedDate_el_extra.textContent = "(select a date)"; return; } selectedDateDisplay_el_extra.textContent = formatDateToDDMonthYYYY_ExtraPage(selectedDateStr); const dateObj = new Date(selectedDateStr + "T00:00:00"); const autoCodes = getOperatingCodesForDate_ExtraPage(dateObj); autoProfileForSelectedDate_el_extra.textContent = autoCodes.join(', ') || "N/A"; if (window.firebaseOMSI) { const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const overrideSnap = await dbGet(dbChild(dbRef(database), `${FB_PATH_OPERATIONAL_OVERRIDES}/${selectedDateStr}`)); if (overrideSnap.exists()) { currentOverrideForSelectedDate_el_extra.textContent = overrideSnap.val(); currentOverrideForSelectedDate_el_extra.style.color = "#f1c40f"; clearOverrideButton_el_extra.style.display = 'inline-block'; } else { currentOverrideForSelectedDate_el_extra.textContent = "(none)"; currentOverrideForSelectedDate_el_extra.style.color = ""; } } catch (error) { console.error("Error fetching override for selected date:", error); currentOverrideForSelectedDate_el_extra.textContent = "(error fetching)"; } } }
        async function handleSetOverride_ExtraPage() { if (!currentUser_extra || !overrideDateInput_el_extra || !overrideProfileInput_el_extra || !overrideStatusMessage_el_extra || !window.firebaseOMSI) { if (overrideStatusMessage_el_extra) overrideStatusMessage_el_extra.textContent = "Error: System not ready or not logged in."; return; } const dateKey = overrideDateInput_el_extra.value; const profile = overrideProfileInput_el_extra.value.trim(); if (!dateKey) { overrideStatusMessage_el_extra.textContent = "Please select a date."; overrideStatusMessage_el_extra.style.color="#e74c3c"; return; } if (!profile) { overrideStatusMessage_el_extra.textContent = "Please enter an override profile string."; overrideStatusMessage_el_extra.style.color="#e74c3c"; return; } const { database, dbSet, dbRef } = window.firebaseOMSI; try { await dbSet(dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${dateKey}`), profile); overrideStatusMessage_el_extra.textContent = `Override for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)} set to "${profile}".`; overrideStatusMessage_el_extra.style.color="#2ecc71"; loadAndDisplayOverrides_ExtraPage(); updateSelectedDateInfo_ExtraPage(); } catch (error) { console.error("Error setting override:", error); overrideStatusMessage_el_extra.textContent = "Error setting override: " + error.message; overrideStatusMessage_el_extra.style.color="#e74c3c"; } }
        async function handleClearOverride_ExtraPage() { if (!currentUser_extra || !overrideDateInput_el_extra || !overrideStatusMessage_el_extra || !window.firebaseOMSI) return; const dateKey = overrideDateInput_el_extra.value; if (!dateKey) { overrideStatusMessage_el_extra.textContent = "Please select a date to clear its override."; overrideStatusMessage_el_extra.style.color="#e74c3c"; return; } if (!confirm(`Are you sure you want to clear the override for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)}?`)) { overrideStatusMessage_el_extra.textContent = "Clear override cancelled."; overrideStatusMessage_el_extra.style.color="#7f8c8d"; return; } const { database, dbRemove, dbRef } = window.firebaseOMSI; try { await dbRemove(dbRef(database, `${FB_PATH_OPERATIONAL_OVERRIDES}/${dateKey}`)); overrideStatusMessage_el_extra.textContent = `Override for ${formatDateToDDMonthYYYY_ExtraPage(dateKey)} cleared.`; overrideStatusMessage_el_extra.style.color="#2ecc71"; loadAndDisplayOverrides_ExtraPage(); updateSelectedDateInfo_ExtraPage(); } catch (error) { console.error("Error clearing override:", error); overrideStatusMessage_el_extra.textContent = "Error clearing override: " + error.message; overrideStatusMessage_el_extra.style.color="#e74c3c"; } }


        // --- Ancillary Data Save Function ---
        async function updateAncillaryScheduleData_ExtraPage() {
            if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available for ancillary data update.");
            const { database, dbSet, dbUpdate, dbRef } = window.firebaseOMSI;

            // 1. Regenerate uniqueBusStops from the current in-memory flat schedule
            const stopsMap = new Map();
            currentWorkingSchedule_extra.forEach(row => {
                if (row.stopID && !stopsMap.has(row.stopID.toUpperCase())) {
                    stopsMap.set(row.stopID.toUpperCase(), { stopID: row.stopID, stopName: row.stopName, direction: row.direction });
                }
            });
            const finalUniqueStops = Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase()));

            try {
                console.log("Attempting to save unique bus stops (ancillary)...");
                await dbSet(dbRef(database, FB_PATH_LIVE_UNIQUE_STOPS), finalUniqueStops);
                console.log("Unique bus stops saved. Attempting to save last updated timestamp (ancillary)...");
                await dbUpdate(dbRef(database), { [FB_PATH_APPSTATE_LAST_UPDATED]: new Date().toISOString() });
                console.log("Ancillary schedule data (unique stops, timestamp) updated.");
            } catch (error) {
                console.error("Error saving ancillary schedule data:", error);
                // Decide if this error should be propagated or just logged
                throw error; // Propagate for now
            }
        }

        // --- REBUILDS ENTIRE SCHEDULE in new structured format ---
        async function rebuildAndSaveEntireScheduleToFirebase_ExtraPage(flatScheduleDataToSave) {
    if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available.");
    const { database, dbSet, dbRef } = window.firebaseOMSI;

    console.log("Rebuilding entire schedule into new nested structure (in memory)...");
    const newSchedulesByRoute = {}; // This object will be built in memory first
    flatScheduleDataToSave.forEach(entry => {
        if (!entry.lineName || !entry.OperatingProfile || !entry.destinationName) {
            console.warn("Skipping entry with missing route/profile/destination:", entry);
            return;
        }
        const saneRoute = sanitizeFirebaseKey(entry.lineName);
        const saneProfile = sanitizeFirebaseKey(entry.OperatingProfile);
        const saneDest = sanitizeFirebaseKey(entry.destinationName);

        if (!newSchedulesByRoute[saneRoute]) newSchedulesByRoute[saneRoute] = {};
        if (!newSchedulesByRoute[saneRoute][saneProfile]) newSchedulesByRoute[saneRoute][saneProfile] = {};
        if (!newSchedulesByRoute[saneRoute][saneProfile][saneDest]) newSchedulesByRoute[saneRoute][saneProfile][saneDest] = { entries: [] };
        
        const entryForStorage = { ...entry };
        // Ensure these key fields are present in the stored entry, even if they were part of the key structure
        entryForStorage.lineName = entry.lineName;
        entryForStorage.OperatingProfile = entry.OperatingProfile;
        entryForStorage.destinationName = entry.destinationName;

        newSchedulesByRoute[saneRoute][saneProfile][saneDest].entries.push(entryForStorage);
    });

    // Sort entries within each R/P/D for consistency
    for (const routeKey in newSchedulesByRoute) {
        for (const profileKey in newSchedulesByRoute[routeKey]) {
            for (const destKey in newSchedulesByRoute[routeKey][profileKey]) {
                newSchedulesByRoute[routeKey][profileKey][destKey].entries.sort((a, b) => {
                    const timeA = (a.scheduledTime || "9999").replace(':', ''); // Use a sortable time format
                    const timeB = (b.scheduledTime || "9999").replace(':', '');
                    const timeCompare = timeA.localeCompare(timeB);
                    if (timeCompare !== 0) return timeCompare;
                    // Optional: Add secondary sort criteria if needed, e.g., by stopName or internalId
                    return (a.stopName || "").localeCompare(b.stopName || "");
                });
            }
        }
    }
    
    try {
        console.log(`Attempting to save schedule to Firebase using PER-ROUTE writes. Total routes: ${Object.keys(newSchedulesByRoute).length}`);
        
        const writePromises = [];

        // Clear the entire schedulesByRoute path first to ensure a clean slate.
        // This is a single delete operation for the parent path.
        console.log(`Clearing existing data at ${FB_PATH_SCHEDULES_BY_ROUTE} before writing new data...`);
        await dbSet(dbRef(database, FB_PATH_SCHEDULES_BY_ROUTE), null);
        console.log(`Path ${FB_PATH_SCHEDULES_BY_ROUTE} cleared.`);

        // Now write each route's data individually
        for (const saneRoute in newSchedulesByRoute) {
            if (Object.hasOwnProperty.call(newSchedulesByRoute, saneRoute)) { // Ensure it's an own property
                const routeData = newSchedulesByRoute[saneRoute];
                const routePath = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}`;
                console.log(`Writing data for route: ${saneRoute} to path: ${routePath}`);
                writePromises.push(dbSet(dbRef(database, routePath), routeData));
            }
        }

        await Promise.all(writePromises);
        console.log("Entire schedule saved successfully to Firebase using per-route writes.");

        // After a full rebuild, also update ancillary data
        await updateAncillaryScheduleData_ExtraPage(); // Uses the global currentWorkingSchedule_extra

    } catch (error) {
        console.error("Error saving entire rebuilt schedule with per-route writes:", error);
        // This error will be propagated to the calling function (e.g., handleBulkAddStops_ExtraPage)
        // which should then inform the user via its status message element.
        throw error; 
    }
}


        // --- Stop Management Functions ---
        function getBaseStopName_ExtraPage(fullStopName) { if (!fullStopName) return ""; let baseName = String(fullStopName).trim(); baseName = baseName.replace(/\s*\(Stand [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\(Bay [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\(Stop [A-Z0-9]+\)\s*$/i, ''); baseName = baseName.replace(/\s*\([A-Z0-9]\)\s*$/i, ''); baseName = baseName.replace(/\s*-\s*Bay\s*[A-Z0-9]+\s*$/i,''); baseName = baseName.replace(/\s*Stop\s*[A-Z0-9]+\s*$/i,''); return baseName.trim(); }
        function getRandomIdFormat_ExtraPage() { const formats = ["NUM", "BP", "LE", "RO"]; return formats[Math.floor(Math.random() * formats.length)]; }
        function generateUniqueStopId_ExtraPage(format, stopName = "", allExistingStopIDsSet) { const targetBaseName = getBaseStopName_ExtraPage(stopName).toUpperCase(); let prefix = ""; let numericRegex; let baseStartNumber = 1; const MAX_NUMERIC_PART = 99999; switch (format) { case "NUM": prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; case "BP": prefix = "BP"; numericRegex = /^BP(\d+)$/; baseStartNumber = 1; break; case "LE": prefix = "LE"; numericRegex = /^LE(\d+)$/; baseStartNumber = 1; break; case "RO": prefix = "RO"; numericRegex = /^RO(\d+)$/; baseStartNumber = 1; break; default: console.warn(`generateUniqueStopId_ExtraPage: Unknown format "${format}", defaulting to NUM.`); format="NUM"; prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; if (/^[A-Z]+$/.test(format)) {prefix = format.toUpperCase(); numericRegex = new RegExp(`^${prefix}(\\d+)$`); baseStartNumber = 1;} break; } let highestNumInNameSequence = 0; let nameSpecificSequenceFound = false; if (targetBaseName && currentWorkingSchedule_extra) { currentWorkingSchedule_extra.forEach(entry => { if (entry.stopName && entry.stopID) { const existingEntryBaseName = getBaseStopName_ExtraPage(entry.stopName).toUpperCase(); if (existingEntryBaseName === targetBaseName) { const match = entry.stopID.toUpperCase().match(numericRegex); if (match && match[1]) { const numPart = parseInt(match[1], 10); if (!isNaN(numPart) && numPart <= MAX_NUMERIC_PART && numPart > highestNumInNameSequence) { highestNumInNameSequence = numPart; } nameSpecificSequenceFound = true; } } } }); } let nextNumInSequence = nameSpecificSequenceFound ? highestNumInNameSequence + 1 : baseStartNumber; if (format === "NUM" && nextNumInSequence < 101) nextNumInSequence = 101; if (baseStartNumber > MAX_NUMERIC_PART) { console.warn(`Suggest ID (single): Base start ${baseStartNumber} for ${format} exceeds MAX. Fallback.`); return prefix + "MAX_S_ERR" + Math.floor(Math.random()*1000); } let attempts = 0; const maxAttempts = MAX_NUMERIC_PART + 2000; let candidateId = ""; while (attempts < maxAttempts) { if (nextNumInSequence > MAX_NUMERIC_PART) { console.warn(`Suggest ID (single): All numbers up to ${MAX_NUMERIC_PART} exhausted for ${prefix}, base ${targetBaseName}. Fallback.`); let fA = 0, fId; do { fId = prefix + "RND" + String(Date.now()).slice(-3) + (Math.floor(Math.random()*900)+100); fA++; if (fA > 50) return prefix + "FB_FAIL" + Math.floor(Math.random()*1000); } while (allExistingStopIDsSet.has(fId.toUpperCase())); return fId; } candidateId = prefix + nextNumInSequence; if (!allExistingStopIDsSet.has(candidateId.toUpperCase())) return candidateId; nextNumInSequence++; attempts++; } console.warn(`CRITICAL: Could not generate unique Stop ID for ${format}, name: "${stopName}". Final fallback.`); let fA2 = 0, fId2; do { fId2 = prefix + "ULTRA_FB" + String(Date.now()).slice(-5) + (Math.floor(Math.random()*90)+10); fA2++; if (fA2 > 50) return prefix + "ULTRA_CRIT_FAIL" + Math.floor(Math.random()*100); } while (allExistingStopIDsSet.has(fId2.toUpperCase())); return fId2; }
        function autoGenerateAndSetNewStopId_ExtraPage() { if (!currentUser_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !selectNewStopIdFormat_el_extra) return; const currentStopName = inputNewStopName_el_extra.value.trim(); if (!currentStopName) { inputNewStopId_el_extra.value = ""; selectNewStopIdFormat_el_extra.selectedIndex = 0; if(addNewStopStatus_el_extra) {addNewStopStatus_el_extra.textContent = "Enter stop name for ID suggestion."; addNewStopStatus_el_extra.style.color = "";} if (newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = ''; return; } const actualBaseName = getBaseStopName_ExtraPage(currentStopName).toUpperCase(); let formatToUse = null; if (actualBaseName && currentWorkingSchedule_extra && currentWorkingSchedule_extra.length > 0) { for (const existingEntry of currentWorkingSchedule_extra) { if (existingEntry.stopID && existingEntry.stopName) { const existingEntryBaseName = getBaseStopName_ExtraPage(existingEntry.stopName).toUpperCase(); if (existingEntryBaseName === actualBaseName) { const existingId = existingEntry.stopID.toUpperCase(); if (existingId.startsWith("BP") && /BP\d+/.test(existingId)) formatToUse = "BP"; else if (existingId.startsWith("LE") && /LE\d+/.test(existingId)) formatToUse = "LE"; else if (existingId.startsWith("RO") && /RO\d+/.test(existingId)) formatToUse = "RO"; else if (/^\d+$/.test(existingId) && parseInt(existingId, 10) >= 100) formatToUse = "NUM"; if (formatToUse) break; } } } } if (!formatToUse) formatToUse = getRandomIdFormat_ExtraPage(); selectNewStopIdFormat_el_extra.value = formatToUse; const allCurrentScheduleIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase())); const suggestedId = generateUniqueStopId_ExtraPage(formatToUse, currentStopName, allCurrentScheduleIDs); inputNewStopId_el_extra.value = suggestedId; inputNewStopId_el_extra.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })); if (addNewStopStatus_el_extra) { addNewStopStatus_el_extra.textContent = `Auto-suggested ID: ${suggestedId} (Format: "${formatToUse}").`; addNewStopStatus_el_extra.style.color = '#bdc3c7'; } }
        async function handleAddStopDetails_ExtraPage() {
            if (!currentUser_extra || !addNewStopStatus_el_extra || !inputNewStopId_el_extra || !inputNewStopName_el_extra || !inputNewStopDirection_el_extra) return;
            const newStopID = inputNewStopId_el_extra.value.trim().toUpperCase();
            const newStopName = inputNewStopName_el_extra.value.trim();
            const newStopDirection = inputNewStopDirection_el_extra.value.trim();
            if (!newStopID) { addNewStopStatus_el_extra.textContent = "New Stop ID is required."; addNewStopStatus_el_extra.style.color = '#e74c3c'; inputNewStopId_el_extra.focus(); return; }
            if (!/^[A-Z0-9]+$/.test(newStopID)) { addNewStopStatus_el_extra.textContent = "Stop ID: A-Z, 0-9 only."; addNewStopStatus_el_extra.style.color = '#e74c3c'; inputNewStopId_el_extra.focus(); return; }
            if (!newStopName) { addNewStopStatus_el_extra.textContent = "New Stop Name is required."; addNewStopStatus_el_extra.style.color = '#e74c3c'; inputNewStopName_el_extra.focus(); return; }
            const existingStopIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase()));
            if (existingStopIDs.has(newStopID)) { addNewStopStatus_el_extra.textContent = `Stop ID "${newStopID}" already exists.`; if(newStopIdAvailability_el_extra){ newStopIdAvailability_el_extra.textContent = 'ID already exists.'; newStopIdAvailability_el_extra.style.color = '#e74c3c'; } inputNewStopId_el_extra.focus(); return; }
            const newStopDefinitionForFlatList = {
                internalId: `${newStopID}_definition_${Date.now()}`, // Unique internal ID for processing the flat list
                stopID: newStopID,
                stopName: newStopName,
                direction: newStopDirection
                // No lineName, destinationName, scheduledTime, OperatingProfile, DayOffset
            };
            currentWorkingSchedule_extra.push(newStopDefinitionForFlatList);
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
                addNewStopStatus_el_extra.textContent = `Stop "${newStopID} - ${newStopName}" definition placeholder added. Save successful.`;
                addNewStopStatus_el_extra.style.color = '#2ecc71';
                inputNewStopId_el_extra.value = ''; inputNewStopName_el_extra.value = ''; inputNewStopDirection_el_extra.value = '';
                if(newStopIdAvailability_el_extra) newStopIdAvailability_el_extra.textContent = '';
                if(selectNewStopIdFormat_el_extra) selectNewStopIdFormat_el_extra.selectedIndex = 0;
                autoGenerateAndSetNewStopId_ExtraPage();
                renderUIDependentElements_ExtraPage();
            } catch (error) {
                console.error("Error adding new stop definition:", error);
                addNewStopStatus_el_extra.textContent = "Error saving stop definition: " + error.message;
                addNewStopStatus_el_extra.style.color = '#e74c3c';
                currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => entry.internalId !== placeholderEntry.internalId);
            }
        }
        function generateUniqueStopId_ExtraPage_BulkAware(format, stopName, newlyGeneratedIDsInBatchSet, baseNameAndFormatToGeneratedNumericPartsMap) { const targetBaseName = getBaseStopName_ExtraPage(stopName).toUpperCase(); let prefix = ""; let numericRegex; let baseStartNumber = 1; const MAX_NUMERIC_PART = 99999; switch (format) { case "NUM": prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; case "BP": prefix = "BP"; numericRegex = /^BP(\d+)$/; baseStartNumber = 1; break; case "LE": prefix = "LE"; numericRegex = /^LE(\d+)$/; baseStartNumber = 1; break; case "RO": prefix = "RO"; numericRegex = /^RO(\d+)$/; baseStartNumber = 1; break; default: console.warn(`generateUniqueStopId_ExtraPage_BulkAware (Replace Mode): Unknown format "${format}" for "${stopName}". Defaulting to NUM.`); format = "NUM"; prefix = ""; numericRegex = /^(\d+)$/; baseStartNumber = 101; break; } const keyForMap = `${targetBaseName}_${format}`; if (!baseNameAndFormatToGeneratedNumericPartsMap.has(keyForMap)) { baseNameAndFormatToGeneratedNumericPartsMap.set(keyForMap, new Set()); } const numericPartsForThisGroup = baseNameAndFormatToGeneratedNumericPartsMap.get(keyForMap); let highestNumInGroup = 0; numericPartsForThisGroup.forEach(numStr => { const num = parseInt(numStr, 10); if (!isNaN(num) && num > highestNumInGroup) highestNumInGroup = num; }); let nextNumInSequence = highestNumInGroup > 0 ? highestNumInGroup + 1 : baseStartNumber; if (format === "NUM" && nextNumInSequence < 101) nextNumInSequence = 101; if (baseStartNumber > MAX_NUMERIC_PART) { console.warn(`BulkAware (Replace): Base start ${baseStartNumber} for ${format} exceeds MAX. Fallback.`); return prefix + "B_MAX_S_ERR" + Math.floor(Math.random()*1000); } let attempts = 0; const maxAttempts = MAX_NUMERIC_PART + 2000; let candidateId = ""; while (attempts < maxAttempts) { if (nextNumInSequence > MAX_NUMERIC_PART) { console.warn(`BulkAware (Replace): All numbers up to ${MAX_NUMERIC_PART} exhausted for ${prefix}, base ${targetBaseName}. Fallback.`); let fA = 0, fId; do { fId = prefix + "BRND" + String(Date.now()).slice(-4) + (Math.floor(Math.random()*900)+100); fA++; if (fA > 50) return prefix + "B_FB_FAIL" + Math.floor(Math.random()*1000); } while (newlyGeneratedIDsInBatchSet.has(fId.toUpperCase())); return fId; } candidateId = prefix + nextNumInSequence; if (!newlyGeneratedIDsInBatchSet.has(candidateId.toUpperCase())) { const match = candidateId.match(numericRegex); if(match && match[1]) numericPartsForThisGroup.add(match[1]); return candidateId; } nextNumInSequence++; attempts++; } console.warn(`CRITICAL_BULK (Replace): Could not generate unique Stop ID for ${format}, name: "${stopName}". Final fallback.`); let fA2 = 0, fId2; do { fId2 = prefix + "B_ULTRA_FB" + String(Date.now()).slice(-5) + (Math.floor(Math.random()*9000)+1000); fA2++; if (fA2 > 50) throw new Error("Bulk Fallback ID gen failed catastrophically."); } while (newlyGeneratedIDsInBatchSet.has(fId2.toUpperCase())); return fId2; }
        async function handleBulkAddStops_ExtraPage() {
            if (!currentUser_extra) { alert("Log in."); if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="Not logged in."; bulkAddNewStopsStatus_el_extra.style.color="#e74c3c";} return; }
            const stopsToProcessFromExcel = processedExcelStopsData_extra;
            if (!stopsToProcessFromExcel || stopsToProcessFromExcel.length === 0) { if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="No Excel data processed."; bulkAddNewStopsStatus_el_extra.style.color="#f1c40f";} return; }
            if (!confirm(`DANGER! This will DELETE ALL existing schedules and then add ${stopsToProcessFromExcel.length} stop definition(s) from Excel. This action CANNOT BE UNDONE. Proceed?`)) { if(bulkAddNewStopsStatus_el_extra){bulkAddNewStopsStatus_el_extra.textContent="Bulk replace operation cancelled."; bulkAddNewStopsStatus_el_extra.style.color="#7f8c8d";} return; }
            if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = `Replacing all stops with ${stopsToProcessFromExcel.length} definitions from file...`; bulkAddNewStopsStatus_el_extra.style.color = '#f1c40f'; }
            let newFlatScheduleEntries = []; const newlyGeneratedOrUsedIDsInThisBatch = new Set(); const baseNameToFormatMapForThisBatch = new Map(); const baseNameAndFormatToGeneratedNumericPartsMap = new Map(); let errorsEncountered = 0; let totalPlaceholdersCreated = 0; let uniqueStopIDsAddedCount = 0; let statusMessages = [`Starting bulk replacement (Excel rows: ${stopsToProcessFromExcel.length})...\n`];
            for (const stopData of stopsToProcessFromExcel) {
                const excelStopName = (stopData.stopName || "").trim(); const excelDirection = (stopData.direction || "").trim(); const excelUserProvidedStopID = (stopData.userProvidedStopID || "").trim(); const excelBaseName = getBaseStopName_ExtraPage(excelStopName).toUpperCase();
                let excelLineNames = (stopData.lineNameInput && stopData.lineNameInput.trim() !== "") ? stopData.lineNameInput.split(',').map(ln => ln.trim().toUpperCase()).filter(ln => ln !== "") : ["INFO_ONLY"];
                if (excelLineNames.length === 0) excelLineNames = ["INFO_ONLY"];
                if (!excelStopName && !excelUserProvidedStopID) { statusMessages.push(`Row ${stopData.originalLineNumber}: Skipped. StopName or StopID required.`); errorsEncountered++; continue; }
                let finalStopID = ""; let idSourceMessage = ""; let chosenFormatForThisStop = "";
                if (excelUserProvidedStopID) { 
                    const providedIDUpper = excelUserProvidedStopID.toUpperCase();
                    if (!/^[A-Z0-9]+$/.test(providedIDUpper)) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Provided StopID "${excelUserProvidedStopID}" invalid chars. Skipped.`); errorsEncountered++; continue; }
                    if (newlyGeneratedOrUsedIDsInThisBatch.has(providedIDUpper)) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Provided StopID "${excelUserProvidedStopID}" is duplicated within this Excel file. Skipped.`); errorsEncountered++; continue; }
                    finalStopID = excelUserProvidedStopID; idSourceMessage = "user-provided";
                    if (finalStopID.startsWith("BP")) chosenFormatForThisStop = "BP"; else if (finalStopID.startsWith("LE")) chosenFormatForThisStop = "LE"; else if (finalStopID.startsWith("RO")) chosenFormatForThisStop = "RO"; else if (/^\d+$/.test(finalStopID)) chosenFormatForThisStop = "NUM"; else chosenFormatForThisStop = "Custom";
                } else { if (baseNameToFormatMapForThisBatch.has(excelBaseName)) { chosenFormatForThisStop = baseNameToFormatMapForThisBatch.get(excelBaseName); } else { chosenFormatForThisStop = getRandomIdFormat_ExtraPage(); baseNameToFormatMapForThisBatch.set(excelBaseName, chosenFormatForThisStop); } finalStopID = generateUniqueStopId_ExtraPage_BulkAware(chosenFormatForThisStop, excelStopName, newlyGeneratedOrUsedIDsInThisBatch, baseNameAndFormatToGeneratedNumericPartsMap); idSourceMessage = `auto-gen (${chosenFormatForThisStop})`; }
                if (!finalStopID) { statusMessages.push(`Row ${stopData.originalLineNumber} ("${excelStopName}"): Failed to obtain a final StopID. Skipped.`); errorsEncountered++; continue;}
                newlyGeneratedOrUsedIDsInThisBatch.add(finalStopID.toUpperCase()); uniqueStopIDsAddedCount++;
                excelLineNames.forEach(ln => {
                    newFlatScheduleEntries.push({
                        internalId: `${finalStopID}_${ln.replace(/[^A-Z0-9]/ig, '')}_phReplace_${Date.now()}_${newFlatScheduleEntries.length}`,
                        stopID: finalStopID, stopName: excelStopName, direction: excelDirection, lineName: ln,
                        destinationName: "To Be Defined", OperatingProfile: "AllDays", scheduledTime: "00:00", DayOffset: "0"
                    });
                    totalPlaceholdersCreated++;
                });
                statusMessages.push(`Row ${stopData.originalLineNumber}: Processed "${excelStopName}" -> ID: ${finalStopID} [${idSourceMessage}]. Routes: ${excelLineNames.join(', ')}.`);
            }
            let finalSummaryParts = []; if (totalPlaceholdersCreated > 0) finalSummaryParts.push(`Prepared ${totalPlaceholdersCreated} placeholder schedule entries for ${uniqueStopIDsAddedCount} unique StopIDs from the file.`); if (errorsEncountered > 0) finalSummaryParts.push(`${errorsEncountered} row(s) from Excel skipped due to errors.`); if (newFlatScheduleEntries.length === 0 && errorsEncountered === 0) finalSummaryParts.push("No valid stop definitions found in the file to process."); statusMessages.push("\n--- Summary ---\n" + finalSummaryParts.join('\n')); if (bulkAddNewStopsStatus_el_extra) bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n');
            if (errorsEncountered > 0 && newFlatScheduleEntries.length > 0) { if (!confirm(`There were ${errorsEncountered} error(s) processing rows. However, ${newFlatScheduleEntries.length} placeholder entries are ready to REPLACE the entire schedule. Proceed?`)) { statusMessages.push("Bulk replacement aborted by user due to errors."); if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; } return; } statusMessages.push("Attempting to save successfully processed entries..."); }
            else if (newFlatScheduleEntries.length === 0) { if (bulkAddNewStopsStatus_el_extra) bulkAddNewStopsStatus_el_extra.style.color = errorsEncountered > 0 ? '#e74c3c' : '#f1c40f'; return; }
            currentWorkingSchedule_extra = newFlatScheduleEntries; closedStopIDs_extra = []; stopSpecificRouteColours_extra = {};
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
                await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                statusMessages.push(`\nSuccessfully REPLACED all schedules. Added ${totalPlaceholdersCreated} placeholder entries for ${uniqueStopIDsAddedCount} StopIDs to Firebase in the new structure.`);
                if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#2ecc71'; }
                if (fileInputBulkAddStops_el_extra) fileInputBulkAddStops_el_extra.value = '';
                if (fileNameBulkAddStops_el_extra) fileNameBulkAddStops_el_extra.textContent = 'No file selected.';
                processedExcelStopsData_extra = []; renderUIDependentElements_ExtraPage();
            } catch (error) {
                statusMessages.push("\nDATABASE ERROR: Error saving replaced schedule to Firebase!");
                if (bulkAddNewStopsStatus_el_extra) { bulkAddNewStopsStatus_el_extra.textContent = statusMessages.join('\n'); bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; }
                console.error("Error bulk replacing stops and saving to Firebase:", error);
            }
        }
        function handleExcelFileForBulkAdd_ExtraPage(event) { const file = event.target.files[0]; if (!fileInputBulkAddStops_el_extra || !fileNameBulkAddStops_el_extra || !bulkAddNewStopsStatus_el_extra) return; if (!file) { fileNameBulkAddStops_el_extra.textContent = "No file selected."; processedExcelStopsData_extra = []; return; } fileNameBulkAddStops_el_extra.textContent = `Processing ${file.name}...`; bulkAddNewStopsStatus_el_extra.textContent = ""; processedExcelStopsData_extra = []; const reader = new FileReader(); reader.onload = function(e) { try { const data = new Uint8Array(e.target.result); const workbook = XLSX.read(data, {type: 'array'}); const firstSheetName = workbook.SheetNames[0]; const worksheet = workbook.Sheets[firstSheetName]; const jsonData = XLSX.utils.sheet_to_json(worksheet, {header:1, defval:''}); if (jsonData.length === 0) { bulkAddNewStopsStatus_el_extra.textContent = "Excel file empty or no data."; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileNameBulkAddStops_el_extra.textContent = `Error: ${file.name} is empty.`; fileInputBulkAddStops_el_extra.value = ''; return; } let validEntries = 0; let tempProcessedData = []; jsonData.forEach((row, index) => { if (!Array.isArray(row) || row.every(cell => String(cell).trim() === '')) return; const userProvidedStopID = String(row[0] || "").trim(); const stopName = String(row[1] || "").trim(); const direction = String(row[2] || "").trim(); const lineNameInput = String(row[3] || "").trim(); if (!stopName && !userProvidedStopID) { console.warn(`Skipping Excel row ${index + 1}: StopName and StopID both missing.`); return; } tempProcessedData.push({ originalLineNumber: index + 1, userProvidedStopID: userProvidedStopID, stopName: stopName, direction: direction, lineNameInput: lineNameInput }); validEntries++; }); processedExcelStopsData_extra = tempProcessedData; if (validEntries > 0) { fileNameBulkAddStops_el_extra.textContent = `${file.name} (${validEntries} valid rows ready).`; bulkAddNewStopsStatus_el_extra.textContent = `${validEntries} stop definitions processed. Ready for Bulk Replace operation.`; bulkAddNewStopsStatus_el_extra.style.color = '#2ecc71'; } else { fileNameBulkAddStops_el_extra.textContent = `No valid data in ${file.name}.`; bulkAddNewStopsStatus_el_extra.textContent = "No valid definitions (StopName/StopID required)."; bulkAddNewStopsStatus_el_extra.style.color = '#f1c40f'; fileInputBulkAddStops_el_extra.value = ''; } } catch (error) { console.error("Error processing Excel:", error); fileNameBulkAddStops_el_extra.textContent = `Error processing ${file.name}.`; bulkAddNewStopsStatus_el_extra.textContent = "Error processing Excel: " + error.message; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileInputBulkAddStops_el_extra.value = ''; } }; reader.onerror = () => { fileNameBulkAddStops_el_extra.textContent = "Error reading file."; bulkAddNewStopsStatus_el_extra.textContent = "Could not read file."; bulkAddNewStopsStatus_el_extra.style.color = '#e74c3c'; fileInputBulkAddStops_el_extra.value = ''; }; reader.readAsArrayBuffer(file); }
        
function populateMasterStopList_ExtraPage() {
            if (!masterStopListUL_el_extra || !masterStopListStatus_el_extra) return;
            uniqueStopsMasterList_extra = getUniqueStopsFromSchedule_ExtraPage(); // Ensure this gets unique stops with stopID, stopName, direction
            const filterText = masterStopListFilterInput_el_extra.value.toLowerCase().trim();
            masterStopListUL_el_extra.innerHTML = '';
            let displayedCount = 0;

            if (uniqueStopsMasterList_extra.length === 0) {
                masterStopListStatus_el_extra.textContent = 'No unique stops loaded.';
                return;
            }

            uniqueStopsMasterList_extra.forEach(stop => {
                if (!stop || !stop.stopID) return;

                // --- Logic to get serving routes for the current stop (needed for filtering) ---
                const routeNamesForThisStop = new Set();
                currentWorkingSchedule_extra.forEach(entry => {
                    if (entry.stopID === stop.stopID && entry.lineName) {
                        routeNamesForThisStop.add(entry.lineName);
                    }
                });
                const servingRouteNamesArray = Array.from(routeNamesForThisStop);
                // --- End of logic to get serving routes ---

                const stopIdLower = stop.stopID.toLowerCase();
                const stopNameLower = (stop.stopName || "").toLowerCase();
                const stopDirectionLower = (stop.direction || "").toLowerCase();
                const isClosed = closedStopIDs_extra.includes(stop.stopID.toUpperCase());
                const closureStatus = isClosed ? "Closed" : "Open";

                // --- Updated Filter Logic ---
                if (filterText) {
                    const matchesStopId = stopIdLower.includes(filterText);
                    const matchesStopName = stopNameLower.includes(filterText);
                    const matchesDirection = stopDirectionLower.includes(filterText);
                    const matchesStatus = closureStatus.toLowerCase().includes(filterText);
                    const matchesRoute = servingRouteNamesArray.some(routeName => 
                        routeName.toLowerCase().includes(filterText)
                    );

                    if (!(matchesStopId || matchesStopName || matchesDirection || matchesStatus || matchesRoute)) {
                        return; // Skip this stop if it doesn't match any criteria
                    }
                }
                // --- End of Updated Filter Logic ---

                displayedCount++;
                const li = document.createElement('li');
                li.classList.add('master-stop-list-item');
                li.dataset.originalStopid = stop.stopID;

                const originalInfoDiv = document.createElement('div');
                originalInfoDiv.classList.add('master-stop-original-info');

                let originalContent = `<span class="stop-name-master">${stop.stopName}</span><br>
                                   <span class="stop-direction-master">Towards: ${stop.direction || 'N/A'}</span><br>
                                   <span class="stop-id-master">Stop ID: ${stop.stopID}</span>`;

                // For display, sort the route names (already done in original code if 'servingRoutesData' was used for display)
                const sortedRouteNamesForDisplay = [...servingRouteNamesArray].sort(compareLineNames_ExtraPage);

                if (sortedRouteNamesForDisplay.length > 0) {
                    originalContent += `<div class="serving-routes-container" style="margin-top:0.3rem;">`;
                    sortedRouteNamesForDisplay.slice(0, 10).forEach(lineName => { // Show up to 10 routes directly
                        const bgColor = getRouteTileColour_ExtraPage(lineName, stop.stopID);
                        const textColor = getTextColourForBackground_ExtraPage(bgColor);
                        originalContent += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor}; font-size:0.7em; padding:0.15em 0.4em;">${lineName}</span>`;
                    });
                    if (sortedRouteNamesForDisplay.length > 10) {
                        originalContent += `<span style="font-size:0.7em; opacity:0.8;">...and ${sortedRouteNamesForDisplay.length - 10} more.</span>`;
                    }
                    originalContent += `</div>`;
                }
                originalInfoDiv.innerHTML = originalContent;

                const newIdSectionDiv = document.createElement('div');
                newIdSectionDiv.classList.add('master-stop-new-id-section');
                const newIdLabel = document.createElement('label');
                newIdLabel.textContent = 'Propose New ID (optional):';
                const newIdInput = document.createElement('input');
                newIdInput.type = 'text';
                newIdInput.classList.add('schedule-generator-input', 'master-list-new-id-input');
                newIdInput.dataset.originalId = stop.stopID;
                newIdInput.placeholder = "Enter new ID, then Apply Bulk";
                newIdInput.value = stop.stopID; // Pre-fill with current ID

                const warningP = document.createElement('p');
                warningP.classList.add('master-list-row-warning');

                newIdInput.addEventListener('input', () => {
                    const enteredID = newIdInput.value.trim().toUpperCase();
                    warningP.textContent = ''; // Clear previous warning
                    warningP.style.color = '#f39c12'; // Default warning color

                    if (!enteredID) return; // No input, no message
                    if (enteredID === stop.stopID.toUpperCase()) return; // No change, no message

                    if (!/^[A-Z0-9]+$/.test(enteredID)) {
                        warningP.textContent = 'Invalid chars in ID.';
                        return;
                    }
                    // Check against all current stopIDs in the master list AND other proposed new IDs on the page
                    const allCurrentAndProposedIDs = new Set(uniqueStopsMasterList_extra.map(s => s.stopID.toUpperCase()));
                    document.querySelectorAll('.master-list-new-id-input').forEach(inp => {
                        if (inp !== newIdInput) { // Don't check against itself
                            const otherProposed = inp.value.trim().toUpperCase();
                            if (otherProposed && otherProposed !== inp.dataset.originalId.toUpperCase()) { // If it's a valid proposed change
                                allCurrentAndProposedIDs.add(otherProposed);
                            }
                        }
                    });

                    if (allCurrentAndProposedIDs.has(enteredID)) {
                        warningP.textContent = 'ID taken or proposed elsewhere!';
                    } else {
                        warningP.textContent = 'New ID available.';
                        warningP.style.color = '#2ecc71'; // Success color
                    }
                });

                newIdSectionDiv.appendChild(newIdLabel);
                newIdSectionDiv.appendChild(newIdInput);
                newIdSectionDiv.appendChild(warningP);

                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('master-stop-actions');

                const editBtn = document.createElement('button');
                editBtn.className = 'button small-action';
                editBtn.textContent = 'Edit Name / Direction';
                editBtn.addEventListener('click', () => handleEditStopFromMasterList_ExtraPage(stop.stopID, stop.stopName, stop.direction));

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'button small-action secondary';
                deleteBtn.textContent = 'Delete Stop';
                deleteBtn.addEventListener('click', () => handleDeleteStopFromMasterList_ExtraPage(stop.stopID));

                const toggleBtn = document.createElement('button');
                toggleBtn.className = `button small-action ${isClosed ? "save" : "secondary"}`; // 'save' (green) for Reopen
                toggleBtn.textContent = isClosed ? "Reopen Stop" : "Close Stop";
                toggleBtn.addEventListener('click', () => handleToggleStopStatusFromMasterList_ExtraPage(stop.stopID));

                actionsDiv.appendChild(editBtn);
                actionsDiv.appendChild(deleteBtn);
                actionsDiv.appendChild(toggleBtn);

                li.appendChild(originalInfoDiv);
                li.appendChild(newIdSectionDiv);
                li.appendChild(actionsDiv);
                masterStopListUL_el_extra.appendChild(li);
            });

            masterStopListStatus_el_extra.textContent = `Showing ${displayedCount} of ${uniqueStopsMasterList_extra.length} unique stops. ${filterText ? `Filter active: "${filterText}"` : ''}`;
        }
        async function handleEditStopFromMasterList_ExtraPage(stopID, currentName, currentDirection) {
            if (!currentUser_extra) { alert("Log in to edit stop details."); return; } if (!window.firebaseOMSI) { alert("Firebase not available."); return; }
            const newStopNameInput = prompt(`Editing Stop: ${stopID}\nNew Stop Name (current: "${currentName}"):`, currentName);
            if (newStopNameInput === null) { if(masterListApplyChangesStatus_el_extra) masterListApplyChangesStatus_el_extra.textContent = `Edit cancelled for ${stopID}.`; return; }
            const newStopName = newStopNameInput.trim();
            const newDirectionInput = prompt(`Editing Stop: ${stopID}\nNew "Towards" text (current: "${currentDirection}"):`, currentDirection);
            if (newDirectionInput === null) { if(masterListApplyChangesStatus_el_extra) masterListApplyChangesStatus_el_extra.textContent = `Edit cancelled for ${stopID}.`; return; }
            const newDirection = newDirectionInput.trim();
            const nameChanged = newStopName !== currentName.trim(); const directionChanged = newDirection !== currentDirection.trim();
            if (!nameChanged && !directionChanged) { alert(`No changes made to Stop ID "${stopID}".`); if(masterListApplyChangesStatus_el_extra) masterListApplyChangesStatus_el_extra.textContent = `No changes made to ${stopID}.`; return; }
            if (masterListApplyChangesStatus_el_extra) { masterListApplyChangesStatus_el_extra.textContent = `Updating details for stop ${stopID}...`; masterListApplyChangesStatus_el_extra.style.color = "#f1c40f"; }
            let affectedEntryCount = 0; const affectedRPDPathKeys = new Set(); 
            currentWorkingSchedule_extra.forEach(entry => {
                if (entry.stopID && entry.stopID.toUpperCase() === stopID.toUpperCase()) {
                    if (nameChanged) entry.stopName = newStopName;
                    if (directionChanged) entry.direction = newDirection;
                    affectedEntryCount++;
                    if (entry.lineName && entry.OperatingProfile && entry.destinationName) {
                        const saneRoute = sanitizeFirebaseKey(entry.lineName); const saneProfile = sanitizeFirebaseKey(entry.OperatingProfile); const saneDest = sanitizeFirebaseKey(entry.destinationName);
                        affectedRPDPathKeys.add(`${saneRoute}/${saneProfile}/${saneDest}`);
                    }
                }
            });
            if (affectedEntryCount === 0) { alert(`No schedule entries found for Stop ID "${stopID}" to update.`); if (masterListApplyChangesStatus_el_extra) masterListApplyChangesStatus_el_extra.textContent = ""; return; }
            const { database, dbSet, dbRef } = window.firebaseOMSI; const writePromises = [];
            try {
                console.log(`Targeted Update: Updating ${affectedRPDPathKeys.size} R/P/D paths for edited stop ${stopID}.`);
                affectedRPDPathKeys.forEach(rpdPathKey => {
                    const entriesForThisRPD = currentWorkingSchedule_extra.filter(entry => {
                        if (!entry.lineName || !entry.OperatingProfile || !entry.destinationName) return false;
                        const entrySaneRoute = sanitizeFirebaseKey(entry.lineName); const entrySaneProfile = sanitizeFirebaseKey(entry.OperatingProfile); const entrySaneDest = sanitizeFirebaseKey(entry.destinationName);
                        return `${entrySaneRoute}/${entrySaneProfile}/${entrySaneDest}` === rpdPathKey;
                    });
                    entriesForThisRPD.sort((a, b) => { const timeA = (a.scheduledTime || "99:99").replace(':', ''); const timeB = (b.scheduledTime || "99:99").replace(':', ''); const timeCompare = timeA.localeCompare(timeB); if (timeCompare !== 0) return timeCompare; return (a.internalId || "").localeCompare(b.internalId || ""); });
                    const specificFirebasePath = `${FB_PATH_SCHEDULES_BY_ROUTE}/${rpdPathKey}/entries`;
                    console.log(`Targeted Update: Pushing update for ${entriesForThisRPD.length} entries to: ${specificFirebasePath}`);
                    writePromises.push(dbSet(dbRef(database, specificFirebasePath), entriesForThisRPD));
                });
                await Promise.all(writePromises);
                console.log(`Targeted Update: Successfully updated affected R/P/D paths for stop ${stopID}.`);
                await updateAncillaryScheduleData_ExtraPage();
                alert(`Details for Stop ID "${stopID}" updated (${affectedEntryCount} entries, ${affectedRPDPathKeys.size} configs).`);
                if (masterListApplyChangesStatus_el_extra) { masterListApplyChangesStatus_el_extra.textContent = `Stop ${stopID} details updated.`; masterListApplyChangesStatus_el_extra.style.color = "#2ecc71"; }
                renderUIDependentElements_ExtraPage();
            } catch (error) {
                console.error(`Error updating stop ${stopID} details:`, error);
                alert(`Error saving edits for stop ${stopID}: ${error.message}. Refresh advised.`);
                if (masterListApplyChangesStatus_el_extra) { masterListApplyChangesStatus_el_extra.textContent = `Error updating ${stopID}: ${error.message}`; masterListApplyChangesStatus_el_extra.style.color = "#e74c3c"; }
            }
        }
        async function handleDeleteStopFromMasterList_ExtraPage(stopIdToRemove) {
            if (!currentUser_extra) { alert("Log in."); return; }
            const stopDetails = uniqueStopsMasterList_extra.find(s => s.stopID === stopIdToRemove);
            const stopNameToConfirm = stopDetails ? `${stopDetails.stopName} (${stopIdToRemove})` : stopIdToRemove;
            if (!confirm(`ARE YOU SURE?\nRemove stop "${stopNameToConfirm}" and ALL its schedule entries from Firebase?`)) return;
            const initialLength = currentWorkingSchedule_extra.length;
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(e => e.stopID.toUpperCase() !== stopIdToRemove.toUpperCase());
            const removedCount = initialLength - currentWorkingSchedule_extra.length;
            const closedIdx = closedStopIDs_extra.indexOf(stopIdToRemove.toUpperCase()); if (closedIdx > -1) closedStopIDs_extra.splice(closedIdx, 1);
            if (stopSpecificRouteColours_extra[stopIdToRemove.toUpperCase()]) delete stopSpecificRouteColours_extra[stopIdToRemove.toUpperCase()];
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
                await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                alert(`Stop "${stopNameToConfirm}" and ${removedCount} entries removed.`);
                renderUIDependentElements_ExtraPage();
            } catch (error) { alert("Error deleting stop: " + error.message); }
        }
        async function handleToggleStopStatusFromMasterList_ExtraPage(stopID) { if (!currentUser_extra) { alert("Log in."); return; } const stopIdUpper = stopID.toUpperCase(); const idx = closedStopIDs_extra.indexOf(stopIdUpper); if (idx === -1) closedStopIDs_extra.push(stopIdUpper); else closedStopIDs_extra.splice(idx, 1); try { await saveClosedStopsToFirebase_ExtraPage(); const status = idx === -1 ? "closed" : "reopened"; alert(`Stop "${stopID}" marked ${status}.`); populateMasterStopList_ExtraPage(); } catch (error) { alert("Error saving status: " + error.message); if (idx === -1) closedStopIDs_extra.pop(); else closedStopIDs_extra.splice(idx, 0, stopIdUpper); } }
        async function handleApplyMasterListStopIdChangesButton_ExtraPage() {
            if (!currentUser_extra || !masterStopListUL_el_extra || !masterListApplyChangesStatus_el_extra) return;
            masterListApplyChangesStatus_el_extra.textContent = "Processing ID changes..."; masterListApplyChangesStatus_el_extra.style.color = '#f1c40f';
            const idChangeProposals = []; const allInputs = masterStopListUL_el_extra.querySelectorAll('.master-list-new-id-input'); let hasErrors = false; const newProposedIDsInThisBatch = new Set();
            allInputs.forEach(input => { 
                const originalId = input.dataset.originalId; const newId = input.value.trim().toUpperCase(); const warningElement = input.parentElement.querySelector('.master-list-row-warning'); if (warningElement) warningElement.textContent = ''; if (newId && newId !== originalId.toUpperCase()) { if (!/^[A-Z0-9]+$/.test(newId)) { if(warningElement) warningElement.textContent = "Invalid chars!"; hasErrors = true; return; } if (newProposedIDsInThisBatch.has(newId)) { if(warningElement) warningElement.textContent = "Duplicate New ID!"; hasErrors = true; return; } const existingStopConflict = currentWorkingSchedule_extra.some(e => e.stopID.toUpperCase() === newId && !Array.from(allInputs).some(inp => inp.dataset.originalId.toUpperCase() === newId)); if (existingStopConflict) { if(warningElement) warningElement.textContent = "Conflicts existing ID!"; hasErrors = true; return; } idChangeProposals.push({ originalId: originalId, newId: newId }); newProposedIDsInThisBatch.add(newId); }
            });
            if (hasErrors) { masterListApplyChangesStatus_el_extra.textContent = "Errors in proposed IDs. Correct and retry."; masterListApplyChangesStatus_el_extra.style.color = '#e74c3c'; return; }
            if (idChangeProposals.length === 0) { masterListApplyChangesStatus_el_extra.textContent = "No Stop ID changes proposed."; masterListApplyChangesStatus_el_extra.style.color = '#7f8c8d'; return; }
            if (!confirm(`Apply ${idChangeProposals.length} Stop ID changes to Firebase?`)) { masterListApplyChangesStatus_el_extra.textContent = "Bulk ID change cancelled."; masterListApplyChangesStatus_el_extra.style.color = '#7f8c8d'; return; }
            let actualUpdateCount = 0; const originalToNewIdMap = new Map(idChangeProposals.map(p => [p.originalId.toUpperCase(), p.newId]));
            currentWorkingSchedule_extra.forEach(entry => { const originalEntryStopIDUpper = entry.stopID.toUpperCase(); if (originalToNewIdMap.has(originalEntryStopIDUpper)) { entry.stopID = originalToNewIdMap.get(originalEntryStopIDUpper); actualUpdateCount++; } });
            const updatedClosedStopIDs = new Set(); closedStopIDs_extra.forEach(closedId => { updatedClosedStopIDs.add(originalToNewIdMap.get(closedId.toUpperCase()) || closedId); }); closedStopIDs_extra = Array.from(updatedClosedStopIDs);
            const updatedStopSpecificColours = {}; for (const oldStopIdKey in stopSpecificRouteColours_extra) { updatedStopSpecificColours[originalToNewIdMap.get(oldStopIdKey.toUpperCase()) || oldStopIdKey] = stopSpecificRouteColours_extra[oldStopIdKey]; } stopSpecificRouteColours_extra = updatedStopSpecificColours;
            if (actualUpdateCount > 0 || idChangeProposals.some(p => closedStopIDs_extra.includes(p.newId.toUpperCase()) || stopSpecificRouteColours_extra[p.newId.toUpperCase()])) {
                try {
                    await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra); 
                    await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                    masterListApplyChangesStatus_el_extra.textContent = `Applied ${idChangeProposals.length} Stop ID change(s) (${actualUpdateCount} entries).`; masterListApplyChangesStatus_el_extra.style.color = '#2ecc71';
                    renderUIDependentElements_ExtraPage();
                } catch (error) { console.error("Error applying bulk ID changes:", error); masterListApplyChangesStatus_el_extra.textContent = "Error saving bulk ID changes: " + error.message; masterListApplyChangesStatus_el_extra.style.color = '#e74c3c'; alert("Critical error saving bulk Stop ID changes. Data inconsistent. Refresh."); }
            } else { masterListApplyChangesStatus_el_extra.textContent = "No schedule entries affected by proposed changes."; masterListApplyChangesStatus_el_extra.style.color = '#f1c40f'; }
        }
        function findDuplicateStopsByNameAndDirection_ExtraPage() { if (!currentUser_extra) { alert("Please log in."); if (duplicateStopsByNameDirResults_el_extra) duplicateStopsByNameDirResults_el_extra.textContent = "Please log in."; return; } if (!duplicateStopsByNameDirResults_el_extra) { console.error("Result display element not found."); return; } duplicateStopsByNameDirResults_el_extra.innerHTML = "<p>Checking for duplicates...</p>"; duplicateStopsByNameDirResults_el_extra.style.color = "#f1c40f"; const stopsToCheck = getUniqueStopsFromSchedule_ExtraPage(); if (!stopsToCheck || stopsToCheck.length === 0) { duplicateStopsByNameDirResults_el_extra.textContent = "No stops loaded."; return; } const signatureMap = new Map(); stopsToCheck.forEach(stop => { if (stop.stopName && stop.stopID) { const name = stop.stopName.trim().toLowerCase(); const direction = (stop.direction || "").trim().toLowerCase(); const signature = `${name}|${direction}`; if (!signatureMap.has(signature)) signatureMap.set(signature, []); signatureMap.get(signature).push({id: stop.stopID, name: stop.stopName, direction: stop.direction}); } }); let duplicateSets = []; signatureMap.forEach((stops, signature) => { if (stops.length > 1) { duplicateSets.push({ signature: signature, name: stops[0].name, direction: stops[0].direction || "", stops: stops.map(s => ({ id: s.id, entryCount: currentWorkingSchedule_extra.filter(entry => entry.stopID === s.id).length })).sort((a,b) => b.entryCount - a.id.localeCompare(b.id)) }); } }); if (duplicateSets.length === 0) { duplicateStopsByNameDirResults_el_extra.textContent = "No duplicate stops found (name & direction)."; duplicateStopsByNameDirResults_el_extra.style.color = "#2ecc71"; } else { let html = `<p>${duplicateSets.length} set(s) of duplicate stops found:</p><ul>`; duplicateSets.forEach((set, index) => { html += `<li class="duplicate-set-to-merge">`; html += `<p><strong>Name:</strong> "${set.name}", <strong>Direction:</strong> "${set.direction || '(None)'}"</p>`; html += `<p>Conflicting StopIDs (select one to keep):</p><div class="stop-id-options">`; set.stops.forEach((stop, radioIndex) => { const radioName = `master_for_set_${index}`; const isChecked = radioIndex === 0 ? "checked" : ""; html += `<label><input type="radio" name="${radioName}" value="${stop.id}" ${isChecked}> ${stop.id} (${stop.entryCount} entries)</label><br>`; }); html += `</div></li>`; }); html += `</ul><button id="mergeDuplicateStopsButton_extra" class="button save" style="margin-top:1rem;">Merge Selected Duplicates</button>`; html += `<p id="mergeDuplicateStopsStatus_extra" style="min-height:1.2em; margin-top:0.5rem;"></p>`; duplicateStopsByNameDirResults_el_extra.innerHTML = html; duplicateStopsByNameDirResults_el_extra.style.color = "#e74c3c"; const mergeButton = document.getElementById('mergeDuplicateStopsButton_extra'); if (mergeButton) mergeButton.addEventListener('click', handleMergeDuplicateStops_ExtraPage); } }
        async function handleMergeDuplicateStops_ExtraPage() {
            if (!currentUser_extra) { alert("Log in."); return; }
            const mergeStatusEl = document.getElementById('mergeDuplicateStopsStatus_extra'); if (!mergeStatusEl) return;
            mergeStatusEl.textContent = "Processing merges..."; mergeStatusEl.style.color = "#f1c40f";
            const duplicateSetElements = duplicateStopsByNameDirResults_el_extra.querySelectorAll('.duplicate-set-to-merge'); if (duplicateSetElements.length === 0) { mergeStatusEl.textContent = "No duplicate sets found."; return; }
            let changesMade = false; let totalEntriesReassigned = 0; let stopIDsMergedAwayOverall = new Set();
            for (let i = 0; i < duplicateSetElements.length; i++) { 
                const radioName = `master_for_set_${i}`; const selectedRadio = duplicateStopsByNameDirResults_el_extra.querySelector(`input[name="${radioName}"]:checked`); if (!selectedRadio) continue; const masterStopID = selectedRadio.value; const masterStopDetails = uniqueStopsMasterList_extra.find(s => s.stopID === masterStopID) || currentWorkingSchedule_extra.find(e => e.stopID === masterStopID); if (!masterStopDetails) continue; const masterStopName = masterStopDetails.stopName; const masterStopDirection = masterStopDetails.direction; const allRadiosInSet = duplicateStopsByNameDirResults_el_extra.querySelectorAll(`input[name="${radioName}"]`); const stopIDsInThisSet = Array.from(allRadiosInSet).map(radio => radio.value); const stopIDsToMergeAway = stopIDsInThisSet.filter(id => id !== masterStopID); if (stopIDsToMergeAway.length > 0) { changesMade = true; stopIDsToMergeAway.forEach(idToMerge => { stopIDsMergedAwayOverall.add(idToMerge.toUpperCase()); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === idToMerge) { entry.stopID = masterStopID; entry.stopName = masterStopName; entry.direction = masterStopDirection; totalEntriesReassigned++; } }); }); }
            }
            if (!changesMade) { mergeStatusEl.textContent = "No merges selected."; mergeStatusEl.style.color = "#7f8c8d"; return; }
            closedStopIDs_extra = closedStopIDs_extra.filter(id => !stopIDsMergedAwayOverall.has(id.toUpperCase())); stopIDsMergedAwayOverall.forEach(idToMergeUpper => { if (stopSpecificRouteColours_extra[idToMergeUpper]) delete stopSpecificRouteColours_extra[idToMergeUpper]; });
            try {
                await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra); 
                await saveClosedStopsToFirebase_ExtraPage(); await saveStopSpecificColoursToFirebase_ExtraPage();
                mergeStatusEl.textContent = `Merged duplicates. ${totalEntriesReassigned} entries reassigned.`; mergeStatusEl.style.color = "#2ecc71";
                renderUIDependentElements_ExtraPage(); findDuplicateStopsByNameAndDirection_ExtraPage();
            } catch (error) { console.error("Error saving merged stops:", error); mergeStatusEl.textContent = "Error saving merged stops: " + error.message; mergeStatusEl.style.color = "#e74c3c"; alert("CRITICAL: Error saving merged stops. Data inconsistent. Refresh."); }
        }
        async function saveClosedStopsToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; const fbClosedObject = {}; closedStopIDs_extra.forEach(id => { if (typeof id === 'string') fbClosedObject[id.toUpperCase()] = true; }); await dbSet(dbRef(database, FB_PATH_APPSTATE_CLOSED_STOPS), fbClosedObject); console.log("Closed stops saved (Extra)."); }
        async function saveGlobalColoursToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; await dbSet(dbRef(database, FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS), globalCustomRouteColours_extra); console.log("Global route colours saved (Extra)."); }
        async function saveStopSpecificColoursToFirebase_ExtraPage() { if (!currentUser_extra || !window.firebaseOMSI) throw new Error("Not logged in or Firebase not available."); const { database, dbSet, dbRef } = window.firebaseOMSI; await dbSet(dbRef(database, FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS), stopSpecificRouteColours_extra); console.log("Stop-specific colours saved (Extra)."); }

        // --- Global Route Deletion Functions ---
        function populateGlobalRouteToDeleteList_ExtraPage() { if (!globalRouteDeletionListContainer_el_extra) return; globalRouteDeletionListContainer_el_extra.innerHTML = ''; if (!currentWorkingSchedule_extra || currentWorkingSchedule_extra.length === 0) { globalRouteDeletionListContainer_el_extra.innerHTML = '<p>No routes loaded.</p>'; return; } const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName).filter(Boolean))].sort(compareLineNames_ExtraPage); if (uniqueRoutes.length === 0) { globalRouteDeletionListContainer_el_extra.innerHTML = '<p>No valid routes to list.</p>'; return; } const tileContainer = document.createElement('div'); tileContainer.className = 'selectable-route-tile-container'; uniqueRoutes.forEach(lineName => { const tile = document.createElement('span'); tile.className = 'selectable-route-tile'; tile.textContent = lineName; tile.dataset.lineName = lineName; const bgColor = getRouteTileColour_ExtraPage(lineName); tile.style.backgroundColor = bgColor; tile.style.color = getTextColourForBackground_ExtraPage(bgColor); tile.setAttribute('role', 'checkbox'); tile.setAttribute('aria-checked', 'false'); tile.tabIndex = 0; tile.addEventListener('click', () => { const isSelected = tile.classList.toggle('selected'); tile.setAttribute('aria-checked', isSelected.toString()); }); tile.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); tile.click(); }}); tileContainer.appendChild(tile); }); globalRouteDeletionListContainer_el_extra.appendChild(tileContainer); }
        async function handleDeleteEntireRouteGlobally_ExtraPage() {
            if (!currentUser_extra || !deleteEntireRouteStatusMessage_el_extra || !globalRouteDeletionListContainer_el_extra) return;
            const selectedTiles = globalRouteDeletionListContainer_el_extra.querySelectorAll('.selectable-route-tile.selected');
            if (selectedTiles.length === 0) { deleteEntireRouteStatusMessage_el_extra.textContent = "Select route(s) to delete."; deleteEntireRouteStatusMessage_el_extra.style.color = '#f1c40f'; return; }
            const routesToDelete = Array.from(selectedTiles).map(t => t.dataset.lineName);
            if (!confirm(`EXTREME CAUTION!\nDelete ALL data for route(s): ${routesToDelete.join(', ')} from Firebase? CANNOT BE UNDONE.`)) { deleteEntireRouteStatusMessage_el_extra.textContent = "Global deletion cancelled."; return; }
            deleteEntireRouteStatusMessage_el_extra.textContent = `Deleting route(s): ${routesToDelete.join(', ')}...`; deleteEntireRouteStatusMessage_el_extra.style.color = '#f1c40f';
            const { database, dbRemove, dbRef } = window.firebaseOMSI; let firebaseRemovalPromises = [];
            routesToDelete.forEach(routeNameToDelete => {
                const saneRouteName = sanitizeFirebaseKey(routeNameToDelete);
                const routePath = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRouteName}`;
                firebaseRemovalPromises.push(dbRemove(dbRef(database, routePath)));
            });
            const originalScheduleLength = currentWorkingSchedule_extra.length;
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry =>
                !(entry.lineName && routesToDelete.map(r => r.toUpperCase()).includes(entry.lineName.toUpperCase()))
            );
            const scheduleEntriesRemovedCount = originalScheduleLength - currentWorkingSchedule_extra.length;
            let globalColoursRemoved = false; routesToDelete.forEach(route => { if (globalCustomRouteColours_extra[route.toUpperCase()]) { delete globalCustomRouteColours_extra[route.toUpperCase()]; globalColoursRemoved = true; } });
            let specificColoursNeedSave = false; Object.keys(stopSpecificRouteColours_extra).forEach(stopID => { routesToDelete.forEach(route => { if (stopSpecificRouteColours_extra[stopID] && stopSpecificRouteColours_extra[stopID][route.toUpperCase()]) { delete stopSpecificRouteColours_extra[stopID][route.toUpperCase()]; if (Object.keys(stopSpecificRouteColours_extra[stopID]).length === 0) delete stopSpecificRouteColours_extra[stopID]; specificColoursNeedSave = true; } }); });
            try {
                await Promise.all(firebaseRemovalPromises); 
                if (globalColoursRemoved) await saveGlobalColoursToFirebase_ExtraPage();
                if (specificColoursNeedSave) await saveStopSpecificColoursToFirebase_ExtraPage();
                await updateAncillaryScheduleData_ExtraPage(); 
                deleteEntireRouteStatusMessage_el_extra.textContent = `Route(s) ${routesToDelete.join(', ')} deleted. ${scheduleEntriesRemovedCount} entries removed.`;
                deleteEntireRouteStatusMessage_el_extra.style.color = '#2ecc71';
                renderUIDependentElements_ExtraPage();
            } catch (error) {
                console.error("Error deleting route(s) globally:", error);
                deleteEntireRouteStatusMessage_el_extra.textContent = "Error saving deletions: " + error.message;
                deleteEntireRouteStatusMessage_el_extra.style.color = '#e74c3c';
                alert("Critical error saving global route deletions. Data inconsistent. Refresh.");
            }
        }

        // ++ Route Profile Deletion Functions (NEW SECTION) ++
        /**
         * @description Populates the route select dropdown for the Route Profile Deletion tool.
         */
        function rpd_populateRouteSelect_ExtraPage() {
            if (!rpdRouteSelect_el_extra || !rpdRouteInput_el_extra) return;
            const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))]
                .filter(Boolean)
                .sort(compareLineNames_ExtraPage);

            const currentInputValue = rpdRouteInput_el_extra.value.trim();
            rpdRouteSelect_el_extra.innerHTML = '<option value="">-- Select Route --</option>';
            uniqueRoutes.forEach(route => {
                const opt = document.createElement('option');
                opt.value = route;
                opt.textContent = route;
                rpdRouteSelect_el_extra.appendChild(opt);
            });

            const matchedRoute = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase());
            if (matchedRoute) {
                rpdRouteSelect_el_extra.value = matchedRoute;
            } else if (currentInputValue) {
                rpdRouteSelect_el_extra.value = ""; 
            }
            // Chain updates
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Handles changes to the route name input field for RPD.
         */
        function rpd_handleRouteNameInputChange_ExtraPage() {
            if (!rpdRouteInput_el_extra || !rpdRouteSelect_el_extra) return;
            const typedRouteUpper = rpdRouteInput_el_extra.value.trim().toUpperCase();
            const matchedOption = Array.from(rpdRouteSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper);

            if (matchedOption) {
                rpdRouteSelect_el_extra.value = matchedOption.value;
                if (rpdRouteInput_el_extra.value !== matchedOption.value) {
                    rpdRouteInput_el_extra.value = matchedOption.value;
                }
            } else {
                rpdRouteSelect_el_extra.value = ""; 
            }
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Handles changes to the route name select dropdown for RPD.
         */
        function rpd_handleRouteNameSelectChange_ExtraPage() {
            if (!rpdRouteSelect_el_extra || !rpdRouteInput_el_extra) return;
            rpdRouteInput_el_extra.value = rpdRouteSelect_el_extra.value;
            rpd_populateDestinationSelect_ExtraPage();
        }

        /**
         * @description Populates the destination select dropdown for RPD based on selected route.
         */
        function rpd_populateDestinationSelect_ExtraPage() {
            if (!rpdDestinationSelect_el_extra || !rpdDestinationInput_el_extra || !rpdRouteInput_el_extra) return;

            const selectedRoute = rpdRouteInput_el_extra.value.trim().toUpperCase();
            const currentDestInputValue = rpdDestinationInput_el_extra.value.trim();

            rpdDestinationSelect_el_extra.innerHTML = '<option value="">-- Optional: All Destinations --</option>'; // Modified default text

            if (!selectedRoute) {
                rpdDestinationInput_el_extra.value = ""; 
                rpdDestinationSelect_el_extra.disabled = true;
                rpdDestinationInput_el_extra.disabled = true;
                if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = 'none';
                rpd_populateProfileList_ExtraPage(); 
                return;
            }

            rpdDestinationSelect_el_extra.disabled = false;
            rpdDestinationInput_el_extra.disabled = false;

            const uniqueDestinations = [...new Set(
                currentWorkingSchedule_extra
                    .filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName)
                    .map(e => e.destinationName)
            )].sort();

            if (uniqueDestinations.length > 0) {
                uniqueDestinations.forEach(dest => {
                    const opt = document.createElement('option');
                    opt.value = dest;
                    opt.textContent = dest;
                    rpdDestinationSelect_el_extra.appendChild(opt);
                });
                const matchedDest = uniqueDestinations.find(d => d === currentDestInputValue);
                if (matchedDest) {
                    rpdDestinationSelect_el_extra.value = matchedDest;
                } else {
                     rpdDestinationSelect_el_extra.value = ""; // Default to "All Destinations" if typed value doesn't match
                }
            } else {
                 rpdDestinationSelect_el_extra.innerHTML = '<option value="">-- No Specific Destinations --</option>';
                 rpdDestinationInput_el_extra.value = ""; // Clear input if no destinations exist
            }
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }
        
        /**
         * @description Handles changes to the destination name input field for RPD.
         */
        function rpd_handleDestinationNameInputChange_ExtraPage() {
            if (!rpdDestinationInput_el_extra || !rpdDestinationSelect_el_extra) return;
            const typedDest = rpdDestinationInput_el_extra.value.trim();
            const matchedOption = Array.from(rpdDestinationSelect_el_extra.options).find(opt => opt.value === typedDest);

            if (matchedOption) {
                rpdDestinationSelect_el_extra.value = matchedOption.value;
                if (rpdDestinationInput_el_extra.value !== matchedOption.value) {
                   rpdDestinationInput_el_extra.value = matchedOption.value;
                }
            } else {
                rpdDestinationSelect_el_extra.value = ""; // If typing something not in list, clear select to imply "All Destinations" or new
            }
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }

        /**
         * @description Handles changes to the destination name select dropdown for RPD.
         */
        function rpd_handleDestinationNameSelectChange_ExtraPage() {
            if (!rpdDestinationSelect_el_extra || !rpdDestinationInput_el_extra) return;
            rpdDestinationInput_el_extra.value = rpdDestinationSelect_el_extra.value; // Sync input with select
            if(rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.style.display = rpdDestinationInput_el_extra.value ? 'inline-block' : 'none';
            rpd_populateProfileList_ExtraPage();
        }
        
        /**
         * @description Clears the destination selection for RPD.
         */
        function rpd_handleClearDestination_ExtraPage() {
            if (!rpdDestinationInput_el_extra || !rpdDestinationSelect_el_extra || !rpdClearDestinationButton_el_extra) return;
            rpdDestinationInput_el_extra.value = "";
            rpdDestinationSelect_el_extra.value = ""; // This will select "-- Optional: All Destinations --"
            rpdClearDestinationButton_el_extra.style.display = 'none';
            rpd_populateProfileList_ExtraPage(); 
        }

        /**
         * @description Fetches and displays available profiles for selection based on route and optional destination.
         */
        async function rpd_populateProfileList_ExtraPage() {
            if (!rpdProfileListContainer_el_extra || !rpdRouteInput_el_extra || !rpdDestinationInput_el_extra || !window.firebaseOMSI) {
                if (rpdProfileListContainer_el_extra) rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; opacity:0.7;">Required elements missing for profile listing.</p>';
                return;
            }

            const routeName = rpdRouteInput_el_extra.value.trim();
            const destinationName = rpdDestinationInput_el_extra.value.trim(); // This is the specific destination, if selected

            rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; opacity:0.7;">Select a route to see available profiles.</p>';

            if (!routeName) {
                return; 
            }

            rpdProfileListContainer_el_extra.innerHTML = '<p style="font-size:0.85em; color:#f1c40f;">Loading profiles...</p>';

            // Use currentWorkingSchedule_extra to derive profiles to ensure original casing and relevance
            let profilesOfInterest = currentWorkingSchedule_extra.filter(entry => {
                if (entry.lineName !== routeName) return false;
                if (destinationName && entry.destinationName !== destinationName) return false; // Filter by dest if specified
                return true; // Passes if route matches, and dest matches (if dest was specified)
            });

            let availableOriginalProfileNames = [...new Set(profilesOfInterest.map(e => e.OperatingProfile))].sort();

            if (availableOriginalProfileNames.length === 0) {
                if (destinationName) {
                    rpdProfileListContainer_el_extra.innerHTML = `<p style="font-size:0.85em; color:#f1c40f;">No profiles found for route "${routeName}" with destination "${destinationName}".</p>`;
                } else {
                    rpdProfileListContainer_el_extra.innerHTML = `<p style="font-size:0.85em; color:#f1c40f;">No profiles found for route "${routeName}".</p>`;
                }
                return;
            }

            let html = '<div class="selectable-route-tile-container" style="margin-top:0.5rem;">'; 
            availableOriginalProfileNames.forEach(profileName => {
                html += `
                    <label class="selectable-route-tile rpd-profile-tile" style="background-color: #4A5568; color: white; border-color: transparent;" tabindex="0">
                        <input type="checkbox" class="rpd-profile-checkbox sr-only" value="${profileName}">
                        ${profileName}
                    </label>
                `;
            });
            html += '</div>';
            rpdProfileListContainer_el_extra.innerHTML = html;

            rpdProfileListContainer_el_extra.querySelectorAll('.rpd-profile-tile').forEach(tile => {
                const checkbox = tile.querySelector('.rpd-profile-checkbox');
                const toggleSelection = () => {
                    checkbox.checked = !checkbox.checked;
                    tile.classList.toggle('selected', checkbox.checked); 
                    tile.style.borderColor = checkbox.checked ? '#f1c40f' : 'transparent'; // Visual feedback
                    tile.setAttribute('aria-checked', checkbox.checked.toString());
                };
                tile.addEventListener('click', toggleSelection);
                tile.addEventListener('keydown', (e) => {
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        toggleSelection();
                    }
                });
            });
        }


        /**
         * @description Handles the deletion of selected route profiles.
         */
        async function handleDeleteRouteProfiles_ExtraPage() {
            if (!currentUser_extra || !window.firebaseOMSI) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Not logged in or Firebase not available."; rpdStatusMessage_el_extra.style.color = "#e74c3c";}
                return;
            }

            const routeName = rpdRouteInput_el_extra.value.trim();
            const destinationName = rpdDestinationInput_el_extra.value.trim(); // Optional, if empty means all destinations
            const selectedProfileCheckboxes = rpdProfileListContainer_el_extra.querySelectorAll('.rpd-profile-checkbox:checked');

            if (!routeName) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Please select a route."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}
                return;
            }
            if (selectedProfileCheckboxes.length === 0) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Please select at least one profile to delete."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}
                return;
            }

            const profilesToDeleteOriginalNames = Array.from(selectedProfileCheckboxes).map(cb => cb.value);
            const saneRoute = sanitizeFirebaseKey(routeName);
            const saneDest = destinationName ? sanitizeFirebaseKey(destinationName) : null;

            let confirmMessage = `ARE YOU SURE?\nThis will delete ALL schedule entries for:\nRoute: "${routeName}"`;
            if (saneDest) {
                confirmMessage += `\nDestination: "${destinationName}"`;
            } else {
                confirmMessage += ` (across ALL its destinations)`;
            }
            confirmMessage += `\nFor Operating Profile(s): ${profilesToDeleteOriginalNames.join(', ')}\n\nThis action CANNOT BE UNDONE.`;

            if (!confirm(confirmMessage)) {
                if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Profile deletion cancelled."; rpdStatusMessage_el_extra.style.color = "";}
                return;
            }

            if(rpdStatusMessage_el_extra) {rpdStatusMessage_el_extra.textContent = "Deleting profiles from Firebase..."; rpdStatusMessage_el_extra.style.color = "#f1c40f";}

            const { database, dbRemove, dbRef } = window.firebaseOMSI;
            const removalPromises = [];

            profilesToDeleteOriginalNames.forEach(profileName => {
                const saneProfile = sanitizeFirebaseKey(profileName);
                let pathToDelete;
                if (saneDest) { // Delete specific destination under profile
                    pathToDelete = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}/${saneProfile}/${saneDest}`;
                } else { // Delete entire profile node for the route
                    pathToDelete = `${FB_PATH_SCHEDULES_BY_ROUTE}/${saneRoute}/${saneProfile}`;
                }
                console.log("Firebase path marked for deletion:", pathToDelete);
                removalPromises.push(dbRemove(dbRef(database, pathToDelete)));
            });

            try {
                await Promise.all(removalPromises);
                console.log("Firebase removal operations complete for selected profiles.");

                const originalLength = currentWorkingSchedule_extra.length;
                currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
                    const routeMatch = entry.lineName === routeName;
                    const profileMatch = profilesToDeleteOriginalNames.includes(entry.OperatingProfile);
                    // If saneDest is specified, entry must match it. If saneDest is null, destination doesn't matter for removal of whole profile.
                    const destMatch = saneDest ? (entry.destinationName === destinationName) : true;
                    
                    return !(routeMatch && profileMatch && destMatch);
                });
                const removedCount = originalLength - currentWorkingSchedule_extra.length;
                console.log(`${removedCount} entries removed from local currentWorkingSchedule_extra.`);

                await updateAncillaryScheduleData_ExtraPage();

                if(rpdStatusMessage_el_extra) {
                    rpdStatusMessage_el_extra.textContent = `Successfully deleted ${profilesToDeleteOriginalNames.length} profile(s) (${removedCount} schedule entries affected) for route "${routeName}"${saneDest ? ' and destination "' + destinationName + '"' : ' (all destinations for those profiles)'}. Ancillary data updated.`;
                    rpdStatusMessage_el_extra.style.color = "#2ecc71";
                }
                
                rpd_populateProfileList_ExtraPage(); // Refresh profile list
                // Potentially refresh destination list if a profile was deleted entirely affecting destination availability
                // rpd_populateDestinationSelect_ExtraPage(); // This is already called by rpd_populateProfileList_ExtraPage if logic is chained. Let's ensure it is.
                renderUIDependentElements_ExtraPage(); 

            } catch (error) {
                console.error("Error deleting route profiles:", error);
                if(rpdStatusMessage_el_extra) {
                    rpdStatusMessage_el_extra.textContent = "Error deleting profiles from Firebase: " + error.message;
                    rpdStatusMessage_el_extra.style.color = "#e74c3c";
                }
                alert("Failed to delete profiles from Firebase. Data might be inconsistent. It's recommended to reload data from Firebase or review carefully.");
            }
        }
        // ++ END Route Profile Deletion Functions ++


        // ++ Route Schedule Generator Functions START ++
        function rsg_createConfigKey_ExtraPage(routeName, opProfile, destName) { if (!routeName || !opProfile || !destName) return null; const normRoute = sanitizeFirebaseKey(String(routeName).toUpperCase()); const normProfile = sanitizeFirebaseKey(String(opProfile).toUpperCase()); const normDest = sanitizeFirebaseKey(String(destName).toUpperCase()); return `${normRoute}|${normProfile}|${normDest}`; } 

        async function rsg_loadOrPullConfiguration_ExtraPage() { 
            if (!rsgRouteNameInput_el_extra || !rsgOperatingProfileInput_el_extra || !rsgDestinationNameInput_el_extra || !rsgFirstStopTimesInput_el_extra || !rsgStatusMessage_el_extra || !window.firebaseOMSI) { console.warn("RSG Load/Pull: Required element or Firebase missing."); return; }
            const routeNameFromInput = rsgRouteNameInput_el_extra.value.trim(); const opProfileFromInput = rsgOperatingProfileInput_el_extra.value.trim(); const destNameFromInput = rsgDestinationNameInput_el_extra.value.trim();
            let hasRouteOrDestChanged = ( routeNameFromInput.toUpperCase() !== (rsg_lastLoadedRouteName_extra || "").toUpperCase() || destNameFromInput !== (rsg_lastLoadedDestName_extra || "") );
            if (hasRouteOrDestChanged) { rsg_selectedStops_extra = []; if(rsgFirstStopTimesInput_el_extra) rsgFirstStopTimesInput_el_extra.value = ''; rsg_lastLoadedRouteName_extra = null; rsg_lastLoadedDestName_extra = null; rsg_lastLoadedOpProfile_extra = null; }
            rsg_generatedPreviewEntries_extra = []; rsg_renderPreviewTable_ExtraPage(); if (rsgAddToWorkingScheduleButton_el_extra) rsgAddToWorkingScheduleButton_el_extra.style.display = 'none'; if (rsgSchedulePreviewContainer_el_extra && rsg_generatedPreviewEntries_extra.length === 0) { rsgSchedulePreviewContainer_el_extra.style.display = 'none'; }
            rsg_renderStopSequence_ExtraPage(); if (!routeNameFromInput || !destNameFromInput) { rsgStatusMessage_el_extra.textContent = "Route Name and Destination Name are required."; rsgStatusMessage_el_extra.style.color = ""; return; }
            let profileToAttemptLoad = opProfileFromInput; let isUsingAssumedProfile = false; const preferredDefaultProfiles = ["MF", "MFSch", "MFNSD", "Sa", "Su", "Mo", "Tu", "We", "Th", "Fr", "AllDays"];
            if (!opProfileFromInput) {  
                isUsingAssumedProfile = true; if (hasRouteOrDestChanged || !rsg_lastLoadedOpProfile_extra) { rsgStatusMessage_el_extra.textContent = `Op Profile blank. Trying default for ${routeNameFromInput}/${destNameFromInput}...`; profileToAttemptLoad = ""; for (const prefProfile of preferredDefaultProfiles) { const tempConfigKey = rsg_createConfigKey_ExtraPage(routeNameFromInput, prefProfile, destNameFromInput); if (rsg_loadedConfigs_extra[tempConfigKey]) { profileToAttemptLoad = prefProfile; break; } } if (!profileToAttemptLoad) { for (const prefProfile of preferredDefaultProfiles) { const hasLiveEntries = currentWorkingSchedule_extra.some(entry => entry.lineName && entry.lineName.toUpperCase() === routeNameFromInput.toUpperCase() && entry.destinationName === destNameFromInput && entry.OperatingProfile === prefProfile ); if (hasLiveEntries) { profileToAttemptLoad = prefProfile; break; } } } if (!profileToAttemptLoad) { rsgStatusMessage_el_extra.textContent = `Op Profile blank. No default data (e.g., MF, Sa) found for ${routeNameFromInput}/${destNameFromInput}.`; rsgStatusMessage_el_extra.style.color = "#f1c40f"; return; } rsgStatusMessage_el_extra.textContent = `Op Profile blank. Using default: ${profileToAttemptLoad} for ${routeNameFromInput}/${destNameFromInput}.`; rsgStatusMessage_el_extra.style.color = "#3498db"; } else { rsgStatusMessage_el_extra.textContent = `Op Profile blank. Current sequence (for profile '${rsg_lastLoadedOpProfile_extra || "unknown"}') shown. Enter profile to load or save.`; rsgStatusMessage_el_extra.style.color = "#f1c40f"; return; }
            }
            if (!profileToAttemptLoad) { rsgStatusMessage_el_extra.textContent = "Please specify an Operating Profile or one will be assumed."; rsgStatusMessage_el_extra.style.color = "#f1c40f"; return; }
            const finalConfigKey = rsg_createConfigKey_ExtraPage(routeNameFromInput, profileToAttemptLoad, destNameFromInput);
            if (!finalConfigKey) { rsgStatusMessage_el_extra.textContent = "Error creating configuration key with profile: " + profileToAttemptLoad; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; }
            const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; if(!isUsingAssumedProfile) rsgStatusMessage_el_extra.textContent = `Checking for ${profileToAttemptLoad} configuration...`;
            try {
                let configDataUsed = null; if (rsg_loadedConfigs_extra[finalConfigKey]) { configDataUsed = rsg_loadedConfigs_extra[finalConfigKey]; rsgStatusMessage_el_extra.textContent = `Loaded cached: ${configDataUsed.routeName || routeNameFromInput} (${configDataUsed.operatingProfile || profileToAttemptLoad}) / ${configDataUsed.destinationName || destNameFromInput}.`; } else { const snapshot = await dbGet(dbChild(dbRef(database), `${FB_PATH_RSG_CONFIGS}/${finalConfigKey}`)); if (snapshot.exists()) { configDataUsed = snapshot.val(); rsg_loadedConfigs_extra[finalConfigKey] = configDataUsed; rsgStatusMessage_el_extra.textContent = `Loaded Firebase: ${configDataUsed.routeName || routeNameFromInput} (${configDataUsed.operatingProfile || profileToAttemptLoad}) / ${configDataUsed.destinationName || destNameFromInput}.`; } }
                if (configDataUsed) { 
                    rsgRouteNameInput_el_extra.value = configDataUsed.routeName || routeNameFromInput; if (!isUsingAssumedProfile) rsgOperatingProfileInput_el_extra.value = configDataUsed.operatingProfile || profileToAttemptLoad; rsgDestinationNameInput_el_extra.value = configDataUsed.destinationName || destNameFromInput; rsg_populateRouteSelect_ExtraPage(); rsg_populateDestinationSelect_ExtraPage(); rsg_selectedStops_extra = JSON.parse(JSON.stringify(configDataUsed.stopSequence || [])); rsgFirstStopTimesInput_el_extra.value = configDataUsed.firstStopTimes || ''; rsg_lastLoadedRouteName_extra = rsgRouteNameInput_el_extra.value.trim(); rsg_lastLoadedDestName_extra = rsgDestinationNameInput_el_extra.value.trim(); rsg_lastLoadedOpProfile_extra = profileToAttemptLoad; rsgStatusMessage_el_extra.style.color = "#2ecc71";
                } else { if(!isUsingAssumedProfile || (isUsingAssumedProfile && profileToAttemptLoad)) {  
                    if (isUsingAssumedProfile) rsgStatusMessage_el_extra.textContent = `No saved config for default '${profileToAttemptLoad}'. Pulling live data...`; else rsgStatusMessage_el_extra.textContent = `No saved config for '${profileToAttemptLoad}'. Pulling live data...`; rsgStatusMessage_el_extra.style.color = "#f1c40f"; const routeNameUpperForPull = routeNameFromInput.toUpperCase(); const relevantEntries = currentWorkingSchedule_extra.filter(entry => entry.lineName && entry.lineName.toUpperCase() === routeNameUpperForPull && entry.OperatingProfile === profileToAttemptLoad && entry.destinationName === destNameFromInput ); if (relevantEntries.length === 0) { if (isUsingAssumedProfile) rsgStatusMessage_el_extra.textContent = `Op Profile blank: No default live data for '${profileToAttemptLoad}' found for ${routeNameFromInput}/${destNameFromInput}.`; else if (!hasRouteOrDestChanged && rsg_selectedStops_extra.length > 0) rsgStatusMessage_el_extra.textContent = `No live data for '${profileToAttemptLoad}'. Previous sequence (for '${rsg_lastLoadedOpProfile_extra}') shown.`; else rsgStatusMessage_el_extra.textContent = `No live data found for ${routeNameFromInput} (${profileToAttemptLoad}) / ${destNameFromInput}.`; rsgStatusMessage_el_extra.style.color = "#f1c40f"; } else { const stopTimings = new Map(); relevantEntries.forEach(entry => { const entryTimeMinutes = (parseInt(entry.DayOffset || 0) * 1440) + (parseInt(entry.scheduledTime.split(':')[0]) * 60) + parseInt(entry.scheduledTime.split(':')[1]); if (!stopTimings.has(entry.stopID) || entryTimeMinutes < stopTimings.get(entry.stopID).earliestTime) { stopTimings.set(entry.stopID, { stopInfo: { stopID: entry.stopID, stopName: entry.stopName, direction: entry.direction }, earliestTime: entryTimeMinutes }); } }); const orderedStopInfosFromData = Array.from(stopTimings.values()).sort((a, b) => a.earliestTime - b.earliestTime).map(item => item.stopInfo); if (orderedStopInfosFromData.length === 0) { rsgStatusMessage_el_extra.textContent = `Error: Could not derive stop sequence for ${routeNameFromInput} (${profileToAttemptLoad}).`; rsgStatusMessage_el_extra.style.color = "#e74c3c"; } else { let bestExemplarTimes = null; const firstStopIdOfSequence = orderedStopInfosFromData[0].stopID; const firstStopDeparturesRaw = [...new Set(relevantEntries.filter(e => e.stopID === firstStopIdOfSequence).map(e => ({ time: e.scheduledTime, dayOffset: parseInt(e.DayOffset || 0), minutes: (parseInt(e.DayOffset || 0) * 1440) + (parseInt(e.scheduledTime.split(':')[0]) * 60) + parseInt(e.scheduledTime.split(':')[1]) })) )].sort((a, b) => a.minutes - b.minutes); for (const departure of firstStopDeparturesRaw) { const currentJourneyStopTimes = new Map(); currentJourneyStopTimes.set(firstStopIdOfSequence, departure.minutes); let lastStopAbsoluteTimeInJourney = departure.minutes; let journeyLooksGood = true; for (let i = 1; i < orderedStopInfosFromData.length; i++) { const targetStopID = orderedStopInfosFromData[i].stopID; const entryForThisStopInJourney = relevantEntries.filter(e => e.stopID === targetStopID).map(e => ({...e, absoluteMinutes: (parseInt(e.DayOffset || 0) * 1440) + (parseInt(e.scheduledTime.split(':')[0]) * 60) + parseInt(e.scheduledTime.split(':')[1]) })).filter(e => e.absoluteMinutes >= lastStopAbsoluteTimeInJourney).sort((a,b) => a.absoluteMinutes - b.absoluteMinutes)[0]; if (entryForThisStopInJourney) { currentJourneyStopTimes.set(targetStopID, entryForThisStopInJourney.absoluteMinutes); lastStopAbsoluteTimeInJourney = entryForThisStopInJourney.absoluteMinutes; } else { journeyLooksGood = false; break; } } if (journeyLooksGood && currentJourneyStopTimes.size === orderedStopInfosFromData.length) { bestExemplarTimes = currentJourneyStopTimes; break; } } rsg_selectedStops_extra = orderedStopInfosFromData.map((stopInfo, index) => { let timeAdjustment = (index > 0) ? 2 : 0; if (bestExemplarTimes && index > 0) { const currentTime = bestExemplarTimes.get(stopInfo.stopID); const prevTime = bestExemplarTimes.get(orderedStopInfosFromData[index - 1].stopID); if (typeof currentTime === 'number' && typeof prevTime === 'number' && currentTime >= prevTime) { timeAdjustment = currentTime - prevTime; } } return { stopID: stopInfo.stopID, stopName: stopInfo.stopName, direction: stopInfo.direction, timeAdjustment: timeAdjustment }; }); if (firstStopDeparturesRaw.length > 0) { rsgFirstStopTimesInput_el_extra.value = firstStopDeparturesRaw.map(d => d.time).join(', '); } rsg_lastLoadedRouteName_extra = routeNameFromInput; rsg_lastLoadedDestName_extra = destNameFromInput; rsg_lastLoadedOpProfile_extra = profileToAttemptLoad; rsgStatusMessage_el_extra.textContent = `Pulled live data for: ${routeNameFromInput} (${profileToAttemptLoad}) / ${destNameFromInput}. Review adjustments.`; rsgStatusMessage_el_extra.style.color = "#2ecc71"; } }
                } else { console.warn("profileToAttemptLoad was not set when expected during config/live pull."); } }
                rsg_renderStopSequence_ExtraPage();
            } catch (error) { console.error("Error in rsg_loadOrPullConfiguration_ExtraPage:", error); rsgStatusMessage_el_extra.textContent = "Error loading/pulling configuration: " + error.message; rsgStatusMessage_el_extra.style.color = "#e74c3c"; rsg_renderStopSequence_ExtraPage(); }
        }
        async function rsg_handleSaveConfiguration_ExtraPage() { 
            if (!currentUser_extra) { alert("Please log in to save the configuration."); return; } if (!rsgRouteNameInput_el_extra || !rsgOperatingProfileInput_el_extra || !rsgDestinationNameInput_el_extra || !rsgFirstStopTimesInput_el_extra || !rsgStatusMessage_el_extra || !window.firebaseOMSI) return; const routeName = rsgRouteNameInput_el_extra.value.trim(); const opProfile = rsgOperatingProfileInput_el_extra.value.trim(); const destName = rsgDestinationNameInput_el_extra.value.trim(); const firstStopTimes = rsgFirstStopTimesInput_el_extra.value.trim(); if (!routeName || !destName) { rsgStatusMessage_el_extra.textContent = "Route Name and Destination Name are required to save configuration."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } if (!opProfile) { rsgStatusMessage_el_extra.textContent = "Operating Profile must be specified to save a configuration."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; rsgOperatingProfileInput_el_extra.focus(); return; } if (rsg_selectedStops_extra.length === 0) { rsgStatusMessage_el_extra.textContent = "At least one stop in the sequence is required to save the configuration."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } if (!firstStopTimes) { rsgStatusMessage_el_extra.textContent = "Departure Times for First Stop are required to save the configuration."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } const configKey = rsg_createConfigKey_ExtraPage(routeName, opProfile, destName); if (!configKey) { rsgStatusMessage_el_extra.textContent = "Could not create a valid key for saving the configuration."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } const configurationToSave = { routeName: routeName, operatingProfile: opProfile, destinationName: destName, firstStopTimes: firstStopTimes, stopSequence: JSON.parse(JSON.stringify(rsg_selectedStops_extra)), lastSaved: new Date().toISOString() }; if (!confirm(`Save this configuration for Route: ${routeName}, Profile: ${opProfile}, Destination: ${destName}?\nThis will overwrite any existing saved configuration for this exact combination.`)) { rsgStatusMessage_el_extra.textContent = "Save configuration cancelled."; rsgStatusMessage_el_extra.style.color = ""; return; } const { database, dbSet, dbRef } = window.firebaseOMSI; rsgStatusMessage_el_extra.textContent = "Saving configuration to Firebase..."; rsgStatusMessage_el_extra.style.color = "#f1c40f"; try { await dbSet(dbRef(database, `${FB_PATH_RSG_CONFIGS}/${configKey}`), configurationToSave); rsg_loadedConfigs_extra[configKey] = configurationToSave; rsg_lastLoadedRouteName_extra = routeName; rsg_lastLoadedDestName_extra = destName; rsg_lastLoadedOpProfile_extra = opProfile; rsgStatusMessage_el_extra.textContent = `Configuration saved successfully for ${routeName} (${opProfile}) to ${destName}.`; rsgStatusMessage_el_extra.style.color = "#2ecc71"; } catch (error) { console.error("Error saving RSG configuration to Firebase:", error); rsgStatusMessage_el_extra.textContent = "Error saving configuration: " + error.message; rsgStatusMessage_el_extra.style.color = "#e74c3c"; }
        }
        function rsg_populateRouteSelect_ExtraPage() { 
            if (!rsgRouteNameSelect_el_extra || !rsgRouteNameInput_el_extra) return; const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))].filter(Boolean).sort(compareLineNames_ExtraPage); const currentInputValue = rsgRouteNameInput_el_extra.value.trim(); rsgRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Existing Route --</option>'; uniqueRoutes.forEach(route => { const opt = document.createElement('option'); opt.value = route; opt.textContent = route; rsgRouteNameSelect_el_extra.appendChild(opt); }); const matchedRoute = uniqueRoutes.find(r => r.toUpperCase() === currentInputValue.toUpperCase()); if (matchedRoute) rsgRouteNameSelect_el_extra.value = matchedRoute; else if (currentInputValue) rsgRouteNameSelect_el_extra.value = ""; rsg_populateDestinationSelect_ExtraPage();
        }
        function rsg_handleRouteNameInputChange_ExtraPage() { 
             if (!rsgRouteNameInput_el_extra || !rsgRouteNameSelect_el_extra) return; const typedRouteUpper = rsgRouteNameInput_el_extra.value.trim().toUpperCase(); const matchedOption = Array.from(rsgRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper); if (matchedOption) { rsgRouteNameSelect_el_extra.value = matchedOption.value; if (rsgRouteNameInput_el_extra.value !== matchedOption.value) rsgRouteNameInput_el_extra.value = matchedOption.value; } else rsgRouteNameSelect_el_extra.value = ""; rsg_populateDestinationSelect_ExtraPage();
        }
        function rsg_handleRouteNameSelectChange_ExtraPage() { 
            if (!rsgRouteNameSelect_el_extra || !rsgRouteNameInput_el_extra) return; rsgRouteNameInput_el_extra.value = rsgRouteNameSelect_el_extra.value; rsg_populateDestinationSelect_ExtraPage();
        }
        function rsg_populateDestinationSelect_ExtraPage() { 
            if (!rsgDestinationNameSelect_el_extra || !rsgDestinationNameInput_el_extra || !rsgRouteNameInput_el_extra) return; const selectedRoute = rsgRouteNameInput_el_extra.value.trim().toUpperCase(); const currentDestInputValue = rsgDestinationNameInput_el_extra.value.trim(); rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- Select Existing Destination --</option>'; if (!selectedRoute) { rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- Select Route First --</option>'; return; } const uniqueDestinations = [...new Set( currentWorkingSchedule_extra.filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName).map(e => e.destinationName) )].sort(); uniqueDestinations.forEach(dest => { const opt = document.createElement('option'); opt.value = dest; opt.textContent = dest; rsgDestinationNameSelect_el_extra.appendChild(opt); }); const matchedDest = uniqueDestinations.find(d => d === currentDestInputValue); if (matchedDest) rsgDestinationNameSelect_el_extra.value = matchedDest; else if (uniqueDestinations.length === 0 && selectedRoute) rsgDestinationNameSelect_el_extra.innerHTML = '<option value="">-- No Destinations for Route --</option>'; else rsgDestinationNameSelect_el_extra.value = "";
        }
        function rsg_handleDestinationNameInputChange_ExtraPage() { 
            if (!rsgDestinationNameInput_el_extra || !rsgDestinationNameSelect_el_extra) return; const typedDest = rsgDestinationNameInput_el_extra.value.trim(); const matchedOption = Array.from(rsgDestinationNameSelect_el_extra.options).find(opt => opt.value === typedDest); if (matchedOption) { rsgDestinationNameSelect_el_extra.value = matchedOption.value; if (rsgDestinationNameInput_el_extra.value !== matchedOption.value) rsgDestinationNameInput_el_extra.value = matchedOption.value; } else rsgDestinationNameSelect_el_extra.value = "";
        }
        function rsg_handleDestinationNameSelectChange_ExtraPage() { 
            if (!rsgDestinationNameSelect_el_extra || !rsgDestinationNameInput_el_extra) return; rsgDestinationNameInput_el_extra.value = rsgDestinationNameSelect_el_extra.value;
        }
        function rsg_renderStopSequence_ExtraPage() {  
            if (!rsgStopSequenceList_el_extra || !rsgStopSequencePlaceholder_el_extra || !rsgFirstStopTimesContainer_el_extra) return; rsgStopSequenceList_el_extra.innerHTML = ''; if (rsg_selectedStops_extra.length === 0) { rsgStopSequencePlaceholder_el_extra.style.display = 'block'; rsgFirstStopTimesContainer_el_extra.style.display = 'none'; if (rsgAddToWorkingScheduleButton_el_extra) rsgAddToWorkingScheduleButton_el_extra.style.display = 'none'; } else { rsgStopSequencePlaceholder_el_extra.style.display = 'none'; rsgFirstStopTimesContainer_el_extra.style.display = 'block'; rsg_selectedStops_extra.forEach((stop, index) => { const li = document.createElement('li'); li.dataset.index = index; li.draggable = true; const stopInfoDiv = document.createElement('div'); stopInfoDiv.classList.add('rsg-stop-info'); stopInfoDiv.innerHTML = `<span class="rsg-stop-name">${stop.stopName}</span> <span class="rsg-stop-id">(${stop.stopID})</span>`; if (stop.direction) stopInfoDiv.innerHTML += `<br><small style="opacity:0.7;">Towards: ${stop.direction}</small>`; const actionsDiv = document.createElement('div'); actionsDiv.classList.add('rsg-stop-actions'); if (index > 0) { const timeAdjInput = document.createElement('input'); timeAdjInput.type = 'number'; timeAdjInput.classList.add('schedule-generator-input', 'rsg-time-adjustment-input'); timeAdjInput.value = stop.timeAdjustment || '2'; timeAdjInput.min = '0'; timeAdjInput.title = 'Minutes from previous stop'; timeAdjInput.addEventListener('change', (e) => { rsg_selectedStops_extra[index].timeAdjustment = parseInt(e.target.value, 10) || 0; rsg_generatedPreviewEntries_extra = []; rsg_renderPreviewTable_ExtraPage(); if(rsgAddToWorkingScheduleButton_el_extra) rsgAddToWorkingScheduleButton_el_extra.style.display = 'none'; if(rsgSchedulePreviewContainer_el_extra && rsg_generatedPreviewEntries_extra.length === 0) rsgSchedulePreviewContainer_el_extra.style.display = 'none'; if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = "Time adjustment changed. Regenerate preview."; rsgStatusMessage_el_extra.style.color = "#f1c40f"; } }); actionsDiv.appendChild(timeAdjInput); } const removeButton = document.createElement('button'); removeButton.textContent = '✕'; removeButton.classList.add('button', 'small-action', 'secondary'); removeButton.title = 'Remove Stop'; removeButton.addEventListener('click', () => rsg_removeStopFromSequence_ExtraPage(index)); actionsDiv.appendChild(removeButton); li.appendChild(stopInfoDiv); li.appendChild(actionsDiv); rsgStopSequenceList_el_extra.appendChild(li); li.addEventListener('dragstart', rsg_handleDragStart_ExtraPage); li.addEventListener('dragover', rsg_handleDragOver_ExtraPage); li.addEventListener('dragleave', rsg_handleDragLeave_ExtraPage); li.addEventListener('drop', rsg_handleDrop_ExtraPage); li.addEventListener('dragend', rsg_handleDragEnd_ExtraPage); }); }
        }
        function rsg_handleDragStart_ExtraPage(event) {  
            rsg_draggedItemIndex_extra = parseInt(event.target.closest('li').dataset.index); event.dataTransfer.effectAllowed = 'move'; event.dataTransfer.setData('text/plain', rsg_draggedItemIndex_extra); setTimeout(() => { event.target.closest('li').classList.add('rsg-dragging-item'); }, 0); if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = "Dragging stop..."; rsgStatusMessage_el_extra.style.color = "#3498db"; }
        }
        function rsg_handleDragOver_ExtraPage(event) { 
            event.preventDefault(); event.dataTransfer.dropEffect = 'move'; const targetLi = event.target.closest('li'); if (targetLi && parseInt(targetLi.dataset.index) !== rsg_draggedItemIndex_extra) { Array.from(rsgStopSequenceList_el_extra.children).forEach(child => child.classList.remove('rsg-dragover-target')); targetLi.classList.add('rsg-dragover-target'); }
        }
        function rsg_handleDragLeave_ExtraPage(event) { 
            const targetLi = event.target.closest('li'); if (targetLi) { targetLi.classList.remove('rsg-dragover-target');}
        }
        function rsg_handleDrop_ExtraPage(event) { 
            event.preventDefault(); const targetLi = event.target.closest('li'); if (!targetLi) return; const droppedOnItemIndex = parseInt(targetLi.dataset.index); Array.from(rsgStopSequenceList_el_extra.children).forEach(child => child.classList.remove('rsg-dragover-target')); if (rsg_draggedItemIndex_extra !== null && rsg_draggedItemIndex_extra !== droppedOnItemIndex) { const itemToMove = rsg_selectedStops_extra.splice(rsg_draggedItemIndex_extra, 1)[0]; rsg_selectedStops_extra.splice(droppedOnItemIndex, 0, itemToMove); rsg_renderStopSequence_ExtraPage(); rsg_generatedPreviewEntries_extra = []; rsg_renderPreviewTable_ExtraPage(); if (rsgAddToWorkingScheduleButton_el_extra) rsgAddToWorkingScheduleButton_el_extra.style.display = 'none'; if(rsgSchedulePreviewContainer_el_extra && rsg_generatedPreviewEntries_extra.length === 0) rsgSchedulePreviewContainer_el_extra.style.display = 'none'; if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = "Stop order changed. Regenerate preview."; rsgStatusMessage_el_extra.style.color = "#f1c40f"; } }
        }
        function rsg_handleDragEnd_ExtraPage(event) { 
             Array.from(rsgStopSequenceList_el_extra.children).forEach(childLi => { childLi.classList.remove('rsg-dragging-item'); childLi.classList.remove('rsg-dragover-target'); }); rsg_draggedItemIndex_extra = null;
        }
        function rsg_handleStopSearch_ExtraPage(event) { 
            if (!rsgStopSearchInput_el_extra || !rsgStopSearchResults_el_extra) return; const searchTerm = rsgStopSearchInput_el_extra.value.toLowerCase(); rsgStopSearchResults_el_extra.innerHTML = ''; if (searchTerm.length < 2) { return; } const uniqueStops = getUniqueStopsFromSchedule_ExtraPage(); const filteredStops = uniqueStops.filter(stop => stop.stopName.toLowerCase().includes(searchTerm) || stop.stopID.toLowerCase().includes(searchTerm)).slice(0, 10); if (filteredStops.length > 0) { filteredStops.forEach(stop => { const itemDiv = document.createElement('div'); itemDiv.classList.add('rsg-search-result-item'); let content = `<span class="rsg-search-stop-name">${stop.stopName} (${stop.stopID})</span>`; content += `<span class="rsg-search-stop-details">Towards: ${stop.direction || 'N/A'}</span>`; const servingRoutes = new Set(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === stop.stopID && entry.lineName && entry.lineName !== "INFO_ONLY") { servingRoutes.add(entry.lineName); } }); if (servingRoutes.size > 0) { content += `<div class="rsg-search-serving-routes">`; Array.from(servingRoutes).sort(compareLineNames_ExtraPage).slice(0, 5).forEach(line => { const bgColor = getRouteTileColour_ExtraPage(line, stop.stopID); const textColor = getTextColourForBackground_ExtraPage(bgColor); content += `<span class="route-tile-tools-list" style="background-color:${bgColor};color:${textColor};font-size:0.7em;padding:0.1em 0.3em;">${line}</span>`; }); if (servingRoutes.size > 5) content += `<span style="font-size:0.7em;opacity:0.8;"> +${servingRoutes.size - 5} more</span>`; content += `</div>`; } itemDiv.innerHTML = content; itemDiv.addEventListener('click', () => { rsg_addStopToSequence_ExtraPage(stop.stopID, stop.stopName, stop.direction); rsgStopSearchInput_el_extra.value = ''; rsgStopSearchResults_el_extra.innerHTML = ''; rsgStopSearchInput_el_extra.focus(); }); rsgStopSearchResults_el_extra.appendChild(itemDiv); }); } else { rsgStopSearchResults_el_extra.innerHTML = '<div class="rsg-search-result-item">No stops found.</div>'; }
        }
        function rsg_addStopToSequence_ExtraPage(stopID, stopName, direction) { 
            if (rsg_selectedStops_extra.length > 0 && rsg_selectedStops_extra[rsg_selectedStops_extra.length -1].stopID === stopID) { if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = "Stop already last in sequence."; rsgStatusMessage_el_extra.style.color = "#f1c40f"; } return; } rsg_selectedStops_extra.push({ stopID: stopID, stopName: stopName, direction: direction, timeAdjustment: rsg_selectedStops_extra.length > 0 ? 2 : 0 }); rsg_renderStopSequence_ExtraPage(); rsg_generatedPreviewEntries_extra = []; rsg_renderPreviewTable_ExtraPage(); if (rsgAddToWorkingScheduleButton_el_extra) rsgAddToWorkingScheduleButton_el_extra.style.display = 'none'; if(rsgSchedulePreviewContainer_el_extra && rsg_generatedPreviewEntries_extra.length === 0) rsgSchedulePreviewContainer_el_extra.style.display = 'none'; if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = "Stop added. Regenerate preview if needed."; rsgStatusMessage_el_extra.style.color = ""; }
        }
        function rsg_removeStopFromSequence_ExtraPage(index) { 
            rsg_selectedStops_extra.splice(index, 1); rsg_renderStopSequence_ExtraPage(); rsg_generatedPreviewEntries_extra = []; rsg_renderPreviewTable_ExtraPage(); if (rsgAddToWorkingScheduleButton_el_extra) rsgAddToWorkingScheduleButton_el_extra.style.display = 'none'; if(rsgSchedulePreviewContainer_el_extra && rsg_generatedPreviewEntries_extra.length === 0) rsgSchedulePreviewContainer_el_extra.style.display = 'none'; if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = "Stop removed. Regenerate preview if needed."; rsgStatusMessage_el_extra.style.color = "#f1c40f"; }
        }
        function rsg_handleGenerateSchedulePreview_ExtraPage() { 
            if (!rsgRouteNameInput_el_extra || !rsgOperatingProfileInput_el_extra || !rsgDestinationNameInput_el_extra || !rsgFirstStopTimesInput_el_extra || !rsgStatusMessage_el_extra) return; const routeName = rsgRouteNameInput_el_extra.value.trim().toUpperCase(); let opProfileForGeneration = rsgOperatingProfileInput_el_extra.value.trim(); const destName = rsgDestinationNameInput_el_extra.value.trim(); const firstStopTimesStr = rsgFirstStopTimesInput_el_extra.value.trim(); if (!routeName) { rsgStatusMessage_el_extra.textContent = "Route Name is required."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } if (!opProfileForGeneration && rsg_lastLoadedOpProfile_extra && routeName.toUpperCase() === (rsg_lastLoadedRouteName_extra || "").toUpperCase() && destName === (rsg_lastLoadedDestName_extra || "")) { opProfileForGeneration = rsg_lastLoadedOpProfile_extra; if (rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = `Generating preview using assumed profile: ${opProfileForGeneration}. Save will require explicit profile.`; rsgStatusMessage_el_extra.style.color = "#3498db"; } } else if (!opProfileForGeneration) { rsgStatusMessage_el_extra.textContent = "Operating Profile is required (type one in its field)."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } if (!destName) { rsgStatusMessage_el_extra.textContent = "Destination Name is required."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } if (rsg_selectedStops_extra.length === 0) { rsgStatusMessage_el_extra.textContent = "Please add at least one stop to the sequence."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } if (!firstStopTimesStr) { rsgStatusMessage_el_extra.textContent = "Departure Times for First Stop are required."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } const firstStopTimes = firstStopTimesStr.split(/\s*[,;\t]\s*/).map(t => t.trim()).filter(t => t.match(/^\d{2}:\d{2}$/)); if (firstStopTimes.length === 0) { rsgStatusMessage_el_extra.textContent = "Invalid format for first stop times (HH:MM, separated by comma/semicolon/tab)."; rsgStatusMessage_el_extra.style.color = "#e74c3c"; return; } rsg_generatedPreviewEntries_extra = []; firstStopTimes.forEach(startTimeHHMM => { const startParts = startTimeHHMM.split(':'); let currentMinutesFromMidnight = parseInt(startParts[0], 10) * 60 + parseInt(startParts[1], 10); let currentDayOffset = 0; rsg_selectedStops_extra.forEach((stop, index) => { if (index > 0) { const adjustment = stop.timeAdjustment || 0; currentMinutesFromMidnight += adjustment; } while (currentMinutesFromMidnight >= 1440) { currentMinutesFromMidnight -= 1440; currentDayOffset++; } while (currentMinutesFromMidnight < 0) { currentMinutesFromMidnight += 1440; currentDayOffset--; } const hours = Math.floor(currentMinutesFromMidnight / 60); const minutes = currentMinutesFromMidnight % 60; const scheduledTimeOutput = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`; rsg_generatedPreviewEntries_extra.push({ internalId: `${stop.stopID}_${routeName}_${scheduledTimeOutput.replace(':', '')}_${opProfileForGeneration.replace(/[^a-zA-Z0-9]/g, '')}_rsg${Date.now()}${index}`, stopID: stop.stopID, stopName: stop.stopName, direction: stop.direction, lineName: routeName, destinationName: destName, scheduledTime: scheduledTimeOutput, OperatingProfile: opProfileForGeneration, DayOffset: String(currentDayOffset) }); }); }); rsg_renderPreviewTable_ExtraPage(); if(rsgAddToWorkingScheduleButton_el_extra) rsgAddToWorkingScheduleButton_el_extra.style.display = 'inline-block'; if(rsgSchedulePreviewContainer_el_extra) rsgSchedulePreviewContainer_el_extra.style.display = 'block'; if(!rsgStatusMessage_el_extra.textContent.includes("assumed profile")) { rsgStatusMessage_el_extra.textContent = `Preview generated for ${rsg_generatedPreviewEntries_extra.length} entries using profile '${opProfileForGeneration}'.`; } rsgStatusMessage_el_extra.style.color = '#2ecc71';
        }
        function rsg_renderPreviewTable_ExtraPage() { 
            if (!rsgPreviewTableBody_el_extra || !rsgSchedulePreviewContainer_el_extra) return; rsgPreviewTableBody_el_extra.innerHTML = ''; if (rsg_generatedPreviewEntries_extra.length === 0) { return; } rsg_generatedPreviewEntries_extra.forEach(entry => { const row = rsgPreviewTableBody_el_extra.insertRow(); row.insertCell().textContent = entry.stopID; row.insertCell().textContent = entry.stopName; row.insertCell().textContent = entry.scheduledTime; row.insertCell().textContent = entry.lineName; row.insertCell().textContent = entry.destinationName; row.insertCell().textContent = entry.OperatingProfile; row.insertCell().textContent = entry.DayOffset; });
        }
        // In omsi_tools_extra.html <script> block

// ++ Route Schedule Generator Helper Functions ++

function rsg_resetPreviewState(message = "Configuration changed. Please (re)generate preview or add short workings.", messageType = "info") {
    rsg_generatedPreviewEntries_extra = []; // Clear the global array holding preview entries

    if(rsgPreviewTableBody_el_extra) {
        rsgPreviewTableBody_el_extra.innerHTML = ''; // Clear the preview table
    }
    if(rsgSchedulePreviewContainer_el_extra) {
        rsgSchedulePreviewContainer_el_extra.style.display = 'none'; // Hide the preview container
    }
    if(rsgAddToWorkingScheduleButton_el_extra) {
        rsgAddToWorkingScheduleButton_el_extra.style.display = 'none'; // Hide the "Add to Working Schedule" button
    }

    if(rsgStatusMessage_el_extra) {
        // Only update if not already showing a more severe error (like a red error color),
        // or if the new message is specifically an error/success type.
        const isCurrentMessageError = rsgStatusMessage_el_extra.style.color === 'rgb(231, 76, 60)' || rsgStatusMessage_el_extra.style.color === '#e74c3c';
        if (!isCurrentMessageError || messageType !== "info" ) {
            rsgStatusMessage_el_extra.textContent = message;
            if (messageType === "info") {
                rsgStatusMessage_el_extra.style.color = "#f1c40f"; // Yellow for info/warning
            } else if (messageType === "success") {
                rsgStatusMessage_el_extra.style.color = "#2ecc71"; // Green for success
            } else if (messageType === "error") {
                rsgStatusMessage_el_extra.style.color = "#e74c3c"; // Red for error
            } else {
                rsgStatusMessage_el_extra.style.color = ""; // Default text color
            }
        }
    }
    /*if(rsgShortWorkingStatus_el_extra) {
        rsgShortWorkingStatus_el_extra.textContent = ""; // Clear status for short workings too
    }*/
}

// ... (rest of your existing RSG functions like rsg_createConfigKey_ExtraPage, rsg_loadOrPullConfiguration_ExtraPage, etc.) ...
// ... ensure this new rsg_resetPreviewState function is defined before it's called by other RSG functions.

async function rsg_handleAddGeneratedToWorkingSchedule_ExtraPage() {
    if (!currentUser_extra) {
        alert("Please log in to modify the working schedule.");
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Not logged in.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    if (!rsg_generatedPreviewEntries_extra || rsg_generatedPreviewEntries_extra.length === 0) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "No schedule entries generated in the preview to add.";
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        return;
    }

    // Get the target Route, Profile, and Destination from the RSG's main input fields
    // These define the scope of what we're potentially overwriting or adding to.
    const targetRouteName = rsgRouteNameInput_el_extra.value.trim().toUpperCase();
    let targetOpProfile = rsgOperatingProfileInput_el_extra.value.trim(); // May be initially blank if an assumed profile was used for generation
    const targetDestName = rsgDestinationNameInput_el_extra.value.trim();

    // Ensure the preview entries match what's currently in the RSG input fields,
    // especially for Operating Profile if it was assumed during generation.
    const previewSample = rsg_generatedPreviewEntries_extra[0];
    if (previewSample.lineName.toUpperCase() !== targetRouteName ||
        previewSample.destinationName !== targetDestName ||
        (targetOpProfile !== "" && previewSample.OperatingProfile !== targetOpProfile) // If user typed a profile, it must match
       ) {
        // If user typed a profile but it doesn't match preview, or if R/D don't match
        if (targetOpProfile !== "" && previewSample.OperatingProfile !== targetOpProfile && previewSample.lineName.toUpperCase() === targetRouteName && previewSample.destinationName === targetDestName) {
             // This case means user might have changed op profile input AFTER generating with an assumed one.
             // Re-confirm which profile to use.
             if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Profile mismatch: Preview used '${previewSample.OperatingProfile}', input is '${targetOpProfile}'. Please ensure Op Profile input matches intended generation.`;
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
             }
             return;
        } else if (previewSample.lineName.toUpperCase() !== targetRouteName || previewSample.destinationName !== targetDestName) {
             if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Route/Destination in form does not match generated preview. Please re-generate if settings changed.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
             }
             return;
        }
    }
    // If targetOpProfile was blank in the form, but the preview has one (assumed profile), use the preview's profile.
    if (targetOpProfile === "" && previewSample.OperatingProfile) {
        targetOpProfile = previewSample.OperatingProfile;
    }
    
    if (!targetRouteName || !targetOpProfile || !targetDestName) {
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = "Route Name, Operating Profile, and Destination Name must be effectively defined (from Section 1) to update the schedule.";
            rsgStatusMessage_el_extra.style.color = "#e74c3c";
        }
        return;
    }

    const actionChoice = prompt(
        `Choose action for the ${rsg_generatedPreviewEntries_extra.length} previewed entries for:\n` +
        `Route: ${targetRouteName}\nProfile: ${targetOpProfile}\nDestination: ${targetDestName}\n\n` +
        `1. OVERWRITE existing entries for this specific Route, Profile, and Destination.\n` +
        `2. ADD these new entries (will append if R/P/D exists, or create if new).\n\n` +
        `Enter 1 or 2 (or Cancel):`
    );

    let newEntriesCount = rsg_generatedPreviewEntries_extra.length;
    let operationPerformed = false;
    // Create a deep copy of the preview entries to add to the main schedule
    const entriesToAdd = JSON.parse(JSON.stringify(rsg_generatedPreviewEntries_extra));

    if (actionChoice === "1") { // OVERWRITE specific R/P/D
        if (confirm(`ARE YOU SURE you want to REMOVE all existing entries for Route "${targetRouteName}", Profile "${targetOpProfile}", Destination "${targetDestName}" AND THEN ADD these ${newEntriesCount} new entries?`)) {
            
            let removedCount = 0;
            const originalLength = currentWorkingSchedule_extra.length;

            // Filter out existing entries for the target R/P/D
            currentWorkingSchedule_extra = currentWorkingSchedule_extra.filter(entry => {
                const matchesRPD = entry.lineName && entry.lineName.toUpperCase() === targetRouteName &&
                                   entry.OperatingProfile === targetOpProfile &&
                                   entry.destinationName === targetDestName;
                if (matchesRPD) {
                    removedCount++;
                    return false; // Remove this entry
                }
                return true; // Keep other entries
            });
            
            // Then add the new (previewed) entries
            currentWorkingSchedule_extra.push(...entriesToAdd);
            
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = `Removed ${removedCount} existing entries. Working schedule will be updated with ${newEntriesCount} new entries for ${targetRouteName}/${targetOpProfile}/${targetDestName}. Saving...`;
                rsgStatusMessage_el_extra.style.color = "#f1c40f";
            }
            operationPerformed = true;
        } else {
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Overwrite operation cancelled by user.";
                rsgStatusMessage_el_extra.style.color = "";
            }
            return;
        }
    } else if (actionChoice === "2") { // ADD to R/P/D scope (effectively append if exists, or new if not)
        // No filtering needed, just add the new entries.
        // The rebuildAndSaveEntireScheduleToFirebase_ExtraPage will handle structuring.
        currentWorkingSchedule_extra.push(...entriesToAdd);
        if (rsgStatusMessage_el_extra) {
            rsgStatusMessage_el_extra.textContent = `${newEntriesCount} entries will be ADDED to the working schedule (for ${targetRouteName}/${targetOpProfile}/${targetDestName} if applicable). Saving...`;
            rsgStatusMessage_el_extra.style.color = "#f1c40f";
        }
        operationPerformed = true;
    } else {
        if (actionChoice !== null && rsgStatusMessage_el_extra) { 
            rsgStatusMessage_el_extra.textContent = "Invalid choice. Operation cancelled.";
        } else if (rsgStatusMessage_el_extra) { 
             rsgStatusMessage_el_extra.textContent = "Add to working schedule cancelled.";
        }
        if (rsgStatusMessage_el_extra) rsgStatusMessage_el_extra.style.color = "";
        return;
    }

    if (operationPerformed) {
        try {
            // Save the ENTIRE modified currentWorkingSchedule_extra to Firebase.
            // This function will handle the correct structured saving.
            await rebuildAndSaveEntireScheduleToFirebase_ExtraPage(currentWorkingSchedule_extra);
            // updateAncillaryScheduleData_ExtraPage is called within rebuildAndSave...

            if (rsgStatusMessage_el_extra) {
                const messageAction = actionChoice === "1" ? `Overwrote entries for R/P/D and added ${newEntriesCount} new ones.` : `Added ${newEntriesCount} entries.`;
                rsgStatusMessage_el_extra.textContent = `Successfully saved. ${messageAction} Working schedule now has ${currentWorkingSchedule_extra.length} total entries.`;
                rsgStatusMessage_el_extra.style.color = "#2ecc71";
            }
            
            // Reset RSG preview state after successful save
            rsg_resetPreviewState("Successfully added to working schedule. Ready for new generation.", "success");
            // rsg_generatedPreviewEntries_extra is cleared by rsg_resetPreviewState

            renderUIDependentElements_ExtraPage(); // Refresh UI lists across the tools page

        } catch (error) {
            console.error("Error in rsg_handleAddGeneratedToWorkingSchedule_ExtraPage (saving to Firebase):", error);
            if (rsgStatusMessage_el_extra) {
                rsgStatusMessage_el_extra.textContent = "Error saving to Firebase: " + error.message + ". Local changes might not be live. Please review.";
                rsgStatusMessage_el_extra.style.color = "#e74c3c";
            }
            // Note: currentWorkingSchedule_extra currently holds the unpersisted changes.
            // A more robust solution might offer to revert local changes or retry, but that's more complex.
        }
    }
}
        // ++ END Route Schedule Generator Functions ++

        // ++ RSG Copy From Another Route Modal Functions ++
        function rsg_openCopyFromModal_ExtraPage() { 
            if (!rsgCopyModal_el_extra || !rsgCopySourceRouteNameSelect_el_extra || !rsgCopySourceDestNameSelect_el_extra || !rsgCopyModalStatus_el_extra) return; const uniqueRoutes = [...new Set(currentWorkingSchedule_extra.map(e => e.lineName))].filter(Boolean).sort(compareLineNames_ExtraPage); rsgCopySourceRouteNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route --</option>'; uniqueRoutes.forEach(route => { const opt = document.createElement('option'); opt.value = route; opt.textContent = route; rsgCopySourceRouteNameSelect_el_extra.appendChild(opt); }); if(rsgCopySourceRouteNameInput_el_extra) rsgCopySourceRouteNameInput_el_extra.value = ''; if(rsgCopySourceOpProfileInput_el_extra) rsgCopySourceOpProfileInput_el_extra.value = ''; if(rsgCopySourceDestNameInput_el_extra) rsgCopySourceDestNameInput_el_extra.value = ''; rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route First --</option>'; rsgCopyModalStatus_el_extra.textContent = ''; rsgCopyModal_el_extra.style.display = 'flex';
        }
        function rsg_closeCopyFromModal_ExtraPage() { 
             if (rsgCopyModal_el_extra) rsgCopyModal_el_extra.style.display = 'none';
        }
        function rsg_populateCopySourceDestinationSelect_ExtraPage() { 
            if (!rsgCopySourceDestNameSelect_el_extra || !rsgCopySourceDestNameInput_el_extra || !rsgCopySourceRouteNameInput_el_extra) return; const selectedRoute = rsgCopySourceRouteNameInput_el_extra.value.trim().toUpperCase(); rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Destination --</option>'; if (!selectedRoute) { rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- Select Source Route First --</option>'; return; } const uniqueDestinations = [...new Set(currentWorkingSchedule_extra.filter(e => e.lineName && e.lineName.toUpperCase() === selectedRoute && e.destinationName).map(e => e.destinationName))].sort(); if (uniqueDestinations.length > 0) { uniqueDestinations.forEach(dest => { const opt = document.createElement('option'); opt.value = dest; opt.textContent = dest; rsgCopySourceDestNameSelect_el_extra.appendChild(opt); }); } else { rsgCopySourceDestNameSelect_el_extra.innerHTML = '<option value="">-- No Destinations for this Route --</option>';}
        }
        async function rsg_handleCopyDataFromSource_ExtraPage() { 
            if (!rsgCopySourceRouteNameInput_el_extra || !rsgCopySourceOpProfileInput_el_extra || !rsgCopySourceDestNameInput_el_extra || !rsgCopyModalStatus_el_extra || !window.firebaseOMSI) return; const sourceRouteName = rsgCopySourceRouteNameInput_el_extra.value.trim(); const sourceOpProfile = rsgCopySourceOpProfileInput_el_extra.value.trim(); const sourceDestName = rsgCopySourceDestNameInput_el_extra.value.trim(); if (!sourceRouteName || !sourceOpProfile || !sourceDestName) { rsgCopyModalStatus_el_extra.textContent = "All source fields are required."; rsgCopyModalStatus_el_extra.style.color = "#e74c3c"; return; } rsgCopyModalStatus_el_extra.textContent = "Fetching source data..."; rsgCopyModalStatus_el_extra.style.color = "#f1c40f"; let sourceConfigData = null; let sourceStopSequence = []; let sourceFirstStopTimes = ""; const sourceConfigKey = rsg_createConfigKey_ExtraPage(sourceRouteName, sourceOpProfile, sourceDestName); if (rsg_loadedConfigs_extra[sourceConfigKey]) { sourceConfigData = rsg_loadedConfigs_extra[sourceConfigKey]; } else { const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const snapshot = await dbGet(dbChild(dbRef(database), `${FB_PATH_RSG_CONFIGS}/${sourceConfigKey}`)); if (snapshot.exists()) sourceConfigData = snapshot.val(); } catch (error) { console.error("Error fetching source config for copy:", error); rsgCopyModalStatus_el_extra.textContent = "Error fetching source config: " + error.message; rsgCopyModalStatus_el_extra.style.color = "#e74c3c"; return; } } if (sourceConfigData) { sourceStopSequence = sourceConfigData.stopSequence || []; sourceFirstStopTimes = sourceConfigData.firstStopTimes || ""; } else { const sourceRouteNameUpper = sourceRouteName.toUpperCase(); const relevantEntries = currentWorkingSchedule_extra.filter(entry => entry.lineName && entry.lineName.toUpperCase() === sourceRouteNameUpper && entry.OperatingProfile === sourceOpProfile && entry.destinationName === sourceDestName); if (relevantEntries.length > 0) { const stopTimings = new Map(); relevantEntries.forEach(entry => { const entryTimeMinutes = (parseInt(entry.DayOffset || 0) * 1440) + (parseInt(entry.scheduledTime.split(':')[0]) * 60) + parseInt(entry.scheduledTime.split(':')[1]); if (!stopTimings.has(entry.stopID) || entryTimeMinutes < stopTimings.get(entry.stopID).earliestTime) { stopTimings.set(entry.stopID, { stopInfo: { stopID: entry.stopID, stopName: entry.stopName, direction: entry.direction }, earliestTime: entryTimeMinutes }); } }); const orderedStopInfosFromData = Array.from(stopTimings.values()).sort((a, b) => a.earliestTime - b.earliestTime).map(item => item.stopInfo); if (orderedStopInfosFromData.length > 0) { let bestExemplarTimes = null; const firstStopIdOfSequence = orderedStopInfosFromData[0].stopID; const firstStopDeparturesRaw = [...new Set( relevantEntries.filter(e => e.stopID === firstStopIdOfSequence).map(e => ({ time: e.scheduledTime, dayOffset: parseInt(e.DayOffset || 0), minutes: (parseInt(e.DayOffset || 0) * 1440) + (parseInt(e.scheduledTime.split(':')[0]) * 60) + parseInt(e.scheduledTime.split(':')[1]) })) )].sort((a, b) => a.minutes - b.minutes); for (const departure of firstStopDeparturesRaw) { const currentJourneyStopTimes = new Map(); currentJourneyStopTimes.set(firstStopIdOfSequence, departure.minutes); let lastStopAbsoluteTimeInJourney = departure.minutes; let journeyLooksGood = true; for (let i = 1; i < orderedStopInfosFromData.length; i++) { const targetStopID = orderedStopInfosFromData[i].stopID; const entryForThisStopInJourney = relevantEntries.filter(e => e.stopID === targetStopID).map(e => ({...e, absoluteMinutes: (parseInt(e.DayOffset || 0) * 1440) + (parseInt(e.scheduledTime.split(':')[0]) * 60) + parseInt(e.scheduledTime.split(':')[1]) })).filter(e => e.absoluteMinutes >= lastStopAbsoluteTimeInJourney).sort((a,b) => a.absoluteMinutes - b.absoluteMinutes)[0]; if (entryForThisStopInJourney) { currentJourneyStopTimes.set(targetStopID, entryForThisStopInJourney.absoluteMinutes); lastStopAbsoluteTimeInJourney = entryForThisStopInJourney.absoluteMinutes; } else { journeyLooksGood = false; break; } } if (journeyLooksGood && currentJourneyStopTimes.size === orderedStopInfosFromData.length) { bestExemplarTimes = currentJourneyStopTimes; break; } } sourceStopSequence = orderedStopInfosFromData.map((stopInfo, index) => { let timeAdjustment = (index > 0) ? 2 : 0; if (bestExemplarTimes && index > 0) { const currentTime = bestExemplarTimes.get(stopInfo.stopID); const prevTime = bestExemplarTimes.get(orderedStopInfosFromData[index - 1].stopID); if (typeof currentTime === 'number' && typeof prevTime === 'number' && currentTime >= prevTime) { timeAdjustment = currentTime - prevTime; } } return { stopID: stopInfo.stopID, stopName: stopInfo.stopName, direction: stopInfo.direction, timeAdjustment: timeAdjustment }; }); if (firstStopDeparturesRaw.length > 0) sourceFirstStopTimes = firstStopDeparturesRaw.map(d => d.time).join(', '); } } } if (sourceStopSequence.length > 0) { rsg_selectedStops_extra = JSON.parse(JSON.stringify(sourceStopSequence)); if(rsgFirstStopTimesInput_el_extra) rsgFirstStopTimesInput_el_extra.value = sourceFirstStopTimes; rsg_renderStopSequence_ExtraPage(); rsg_lastLoadedRouteName_extra = rsgRouteNameInput_el_extra.value.trim(); rsg_lastLoadedDestName_extra = rsgDestinationNameInput_el_extra.value.trim(); rsg_lastLoadedOpProfile_extra = rsgOperatingProfileInput_el_extra.value.trim() || sourceOpProfile; if(rsgStatusMessage_el_extra) { rsgStatusMessage_el_extra.textContent = `Stops and timings copied from ${sourceRouteName} (${sourceOpProfile}) / ${sourceDestName}.`; rsgStatusMessage_el_extra.style.color = "#2ecc71"; } rsg_closeCopyFromModal_ExtraPage(); } else { rsgCopyModalStatus_el_extra.textContent = `No data found for source: ${sourceRouteName} (${sourceOpProfile}) / ${sourceDestName}.`; rsgCopyModalStatus_el_extra.style.color = "#e74c3c"; }
        }

        // --- Page Setup ---
        function showExtraPageSection(sectionId) { 
            const allSections = toolSectionsWrapper_el_extra.querySelectorAll('.tool-content-section'); allSections.forEach(s => s.style.display = 'none'); const sectionToShow = document.getElementById(sectionId); if (sectionToShow) { sectionToShow.style.display = 'block'; localStorage.setItem('omsiExtraToolsActiveSection', sectionId); 
                if (sectionId === 'day-profile-override-section_extra') { loadAndDisplayOverrides_ExtraPage(); updateSelectedDateInfo_ExtraPage(); } 
                else if (sectionId === 'stop-manager-tool-section_extra') { populateMasterStopList_ExtraPage(); if (inputNewStopName_el_extra && inputNewStopId_el_extra && !inputNewStopName_el_extra.value && !inputNewStopId_el_extra.value) autoGenerateAndSetNewStopId_ExtraPage(); if(duplicateStopsByNameDirResults_el_extra) duplicateStopsByNameDirResults_el_extra.innerHTML = 'Click "Find Duplicates (Name/Dir)" to check.'; } 
                else if (sectionId === 'global-route-deletion-section_extra') { populateGlobalRouteToDeleteList_ExtraPage(); } 
                else if (sectionId === 'route-schedule-generator-section_extra') { rsg_populateRouteSelect_ExtraPage(); rsg_renderStopSequence_ExtraPage(); }
                else if (sectionId === 'route-profile-deletion-section_extra') { // NEW SECTION
                    rpd_populateRouteSelect_ExtraPage(); 
                    // rpd_populateDestinationSelect_ExtraPage(); // Called by rpd_populateRouteSelect_ExtraPage
                    // rpd_populateProfileList_ExtraPage(); // Called by rpd_populateDestinationSelect_ExtraPage
                }
            } else { console.warn("showExtraPageSection: Could not find section ID:", sectionId); }
        }
        function updateAuthUI_ExtraPage(user) { 
            currentUser_extra = user; if (user) { if(authSection_el_extra) authSection_el_extra.style.display = 'none'; if(topMenuBar_el_extra) topMenuBar_el_extra.style.display = 'block'; if(logoutContainer_el_extra) logoutContainer_el_extra.style.display = 'block'; if(loginFormContainer_el_extra) loginFormContainer_el_extra.style.display = 'none'; if(authStatus_el_extra) authStatus_el_extra.textContent = ''; if(loggedInUserEmailDisplay_el_extra) loggedInUserEmailDisplay_el_extra.textContent = user.email; if(currentProfileDisplayContainer_el) currentProfileDisplayContainer_el.style.display = 'block'; loadInitialData_ExtraPage(); const lastSection = localStorage.getItem('omsiExtraToolsActiveSection'); const firstButton = topMenuBar_el_extra.querySelector('.menu-button'); if (lastSection && document.getElementById(lastSection) && Array.from(topMenuBar_el_extra.querySelectorAll('.menu-button')).some(b => b.dataset.section === lastSection) ) showExtraPageSection(lastSection); else if (firstButton && firstButton.dataset.section) showExtraPageSection(firstButton.dataset.section); } else { if(authSection_el_extra) authSection_el_extra.style.display = 'block'; if(topMenuBar_el_extra) topMenuBar_el_extra.style.display = 'none'; if(logoutContainer_el_extra) logoutContainer_el_extra.style.display = 'none'; if(loginFormContainer_el_extra) loginFormContainer_el_extra.style.display = 'block'; if(authStatus_el_extra) authStatus_el_extra.textContent = 'Please log in.'; if(loggedInUserEmailDisplay_el_extra) loggedInUserEmailDisplay_el_extra.textContent = ''; if(currentProfileDisplayContainer_el) currentProfileDisplayContainer_el.style.display = 'none'; if(toolSectionsWrapper_el_extra) toolSectionsWrapper_el_extra.querySelectorAll('.tool-content-section').forEach(s => s.style.display = 'none'); currentWorkingSchedule_extra = []; closedStopIDs_extra = []; globalCustomRouteColours_extra = {}; stopSpecificRouteColours_extra = {}; pageSpecificSettings = {}; rsg_loadedConfigs_extra = {}; rsg_lastLoadedRouteName_extra = null; rsg_lastLoadedDestName_extra = null; rsg_lastLoadedOpProfile_extra = null; renderUIDependentElements_ExtraPage(); }
        }
        // In omsi_tools_extra.html, within the main <script> block

async function loadInitialData_ExtraPage() {
    let msg = "Loading data for Extra Modules (enhanced for all stops)...";
    console.log(msg);

    // Reset global states relevant to this page
    currentWorkingSchedule_extra = [];
    closedStopIDs_extra = [];
    globalCustomRouteColours_extra = {}; // Assuming it's used/loaded
    stopSpecificRouteColours_extra = {}; // Assuming it's used/loaded
    rsg_loadedConfigs_extra = {}; // For Route Schedule Generator
    // uniqueStopsMasterList_extra is typically populated by getUniqueStopsFromSchedule_ExtraPage later

    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        msg = "Firebase not connected for Extra Modules.";
        console.error(msg);
        // Update a status element on the page if one exists for general load status
        renderUIDependentElements_ExtraPage(); // Attempt to render with empty/reset data
        return;
    }

    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
    try {
        // 1. Fetch structured schedule data (stops that have active routes)
        // FB_PATH_SCHEDULES_BY_ROUTE is '/liveSchedule/schedulesByRoute'
        const scheduleSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SCHEDULES_BY_ROUTE));
        const flatScheduleFromDB = []; // Temporary local array for flattening
        if (scheduleSnap.exists()) {
            const schedulesByRoute = scheduleSnap.val();
            for (const routeKey in schedulesByRoute) {
                const routeData = schedulesByRoute[routeKey];
                for (const profileKey in routeData) {
                    const profileData = routeData[profileKey];
                    for (const destKey in profileData) {
                        const destData = profileData[destKey];
                        if (destData && Array.isArray(destData.entries)) {
                            destData.entries.forEach(entry => {
                                flatScheduleFromDB.push({ ...entry });
                            });
                        }
                    }
                }
            }
        }
        // Assign to global currentWorkingSchedule_extra after processing
        currentWorkingSchedule_extra = flatScheduleFromDB.map((e,i)=>({...e, internalId: e.internalId || `${(e.stopID||'s')}_${(e.lineName||'l')}_${(e.scheduledTime||"").replace(':','')}_${i}_fbloadX_flat`}));
        console.log(`Extra Tools: Loaded ${currentWorkingSchedule_extra.length} entries from structured schedule data (schedulesByRoute).`);

        // 2. Fetch all unique stop definitions from Firebase
        // FB_PATH_LIVE_UNIQUE_STOPS is '/liveSchedule/uniqueBusStops'
        const uniqueStopsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_UNIQUE_STOPS));
        const firebaseUniqueStops = uniqueStopsSnap.exists() && Array.isArray(uniqueStopsSnap.val()) ? uniqueStopsSnap.val() : [];
        console.log(`Extra Tools: Fetched ${firebaseUniqueStops.length} stops from uniqueBusStops list.`);

        // 3. Merge: Add definition-only stops from uniqueBusStops if not already in currentWorkingSchedule_extra
        const stopIDsAlreadyInScheduleFromRoutes = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase()));

        firebaseUniqueStops.forEach(fbStop => {
            if (fbStop && fbStop.stopID && !stopIDsAlreadyInScheduleFromRoutes.has(fbStop.stopID.toUpperCase())) {
                // This stop is defined in uniqueBusStops but was not found in any active schedule entries.
                // Add it as a definition-only entry to currentWorkingSchedule_extra.
                currentWorkingSchedule_extra.push({
                    internalId: `${fbStop.stopID}_definition_fbloadX_${Date.now()}`, // Ensure unique internalId
                    stopID: fbStop.stopID,
                    stopName: fbStop.stopName || "Unknown Stop Name", // Provide default if missing
                    direction: fbStop.direction || "" // Default to empty string if no direction (no "towards")
                    // No LineName, ScheduledTime etc. as it's a definition for a stop without current routes
                });
                console.log(`Extra Tools: Added definition for stop ${fbStop.stopID} (from uniqueBusStops) to local working schedule.`);
            }
        });

        // 4. Fetch other necessary data for omsi_tools_extra.html
        const closedSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_CLOSED_STOPS));
        if (closedSnap.exists()) {
            const fbC = closedSnap.val();
            // Ensure closedStopIDs_extra is an array as expected by some functions
            closedStopIDs_extra = Object.keys(fbC).filter(id => fbC[id] === true).map(id => id.toUpperCase());
        }

        const globalCSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS));
        if (globalCSnap.exists()) globalCustomRouteColours_extra = globalCSnap.val() || {};

        const stopSpecificCSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS));
        if (stopSpecificCSnap.exists()) stopSpecificRouteColours_extra = stopSpecificCSnap.val() || {};

        const rsgConfigsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_RSG_CONFIGS));
        if (rsgConfigsSnap.exists()) {
            rsg_loadedConfigs_extra = rsgConfigsSnap.val() || {};
        }

        msg = `Extra Modules: Data loaded. Working schedule has ${currentWorkingSchedule_extra.length} items. ${closedStopIDs_extra.length} closed. ${Object.keys(rsg_loadedConfigs_extra).length} RSG configs.`;
    } catch (error) {
        console.error("Firebase Load Error (Extra Tools with merge logic):", error);
        msg = "Error loading data (Extra Tools): " + error.message;
        currentWorkingSchedule_extra = []; // Ensure empty on error to prevent using stale data
    }
    
    console.log(msg); // Log to console for debugging

    // Ensure bank holiday data is fetched (assuming this function exists and is needed for this page)
    if (typeof fetchBankHolidays_ExtraPage === 'function') {
        await fetchBankHolidays_ExtraPage();
    }
    
    renderUIDependentElements_ExtraPage(); // This will use the augmented currentWorkingSchedule_extra
}
        function renderUIDependentElements_ExtraPage() { 
            const activeSectionId = localStorage.getItem('omsiExtraToolsActiveSection'); const activeSectionElement = activeSectionId ? document.getElementById(activeSectionId) : null; if (activeSectionElement && activeSectionElement.style.display === 'block') { 
                if (activeSectionId === 'day-profile-override-section_extra') { loadAndDisplayOverrides_ExtraPage(); updateSelectedDateInfo_ExtraPage(); } 
                else if (activeSectionId === 'stop-manager-tool-section_extra') { populateMasterStopList_ExtraPage(); if(duplicateStopsByNameDirResults_el_extra) duplicateStopsByNameDirResults_el_extra.innerHTML = 'Click "Find Duplicates (Name/Dir)" to check.'; } 
                else if (activeSectionId === 'global-route-deletion-section_extra') { populateGlobalRouteToDeleteList_ExtraPage(); } 
                else if (activeSectionId === 'route-schedule-generator-section_extra') { rsg_populateRouteSelect_ExtraPage(); rsg_renderStopSequence_ExtraPage(); }
                else if (activeSectionId === 'route-profile-deletion-section_extra') { // NEW SECTION
                    rpd_populateRouteSelect_ExtraPage(); 
                }
            } else if (!activeSectionId && topMenuBar_el_extra && topMenuBar_el_extra.querySelector('.menu-button')) { 
                // This part can be simplified or removed if first section auto-load is desired
                // const firstButton = topMenuBar_el_extra.querySelector('.menu-button'); 
                // if (firstButton && firstButton.dataset.section) { /* showExtraPageSection(firstButton.dataset.section); */ } 
            } 
        }

        // --- DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', () => { 
            console.log("OMSI Tools Extra DOMContentLoaded"); updateAuthUI_ExtraPage(null); 
            function initializeExtraAppLogic() { 
                console.log("Firebase ready, Extra app logic init."); 
                const { auth, authOnAuthStateChanged, authSignInWithEmailAndPassword, authSignOut } = window.firebaseOMSI; 
                authOnAuthStateChanged(auth, user => { updateAuthUI_ExtraPage(user); if (user && selectNewStopIdFormat_el_extra && inputNewStopName_el_extra && inputNewStopId_el_extra && !inputNewStopName_el_extra.value && !inputNewStopId_el_extra.value) { autoGenerateAndSetNewStopId_ExtraPage(); } }); 
                if (adminLoginForm_el_extra && inputEmail_el_extra && inputPassword_el_extra && authStatus_el_extra) { adminLoginForm_el_extra.addEventListener('submit', (e) => { e.preventDefault(); authStatus_el_extra.textContent = 'Logging in...'; authSignInWithEmailAndPassword(auth, inputEmail_el_extra.value, inputPassword_el_extra.value) .catch(err => { authStatus_el_extra.textContent = `Login Error: ${err.message}`; }); }); } 
                const logoutButton = logoutContainer_el_extra.querySelector('button'); 
                if (logoutButton) logoutButton.addEventListener('click', () => { localStorage.removeItem('omsiExtraToolsActiveSection'); authSignOut(auth).catch(e => console.error("Sign-out error (Extra):", e)); }); 
            } 
            if (window.firebaseOMSI && window.firebaseOMSI.auth) { initializeExtraAppLogic(); } 
            else { document.addEventListener('firebaseReady', () => { if (window.firebaseOMSI && window.firebaseOMSI.auth) { initializeExtraAppLogic(); } else { console.error("Extra Tools: Firebase still not ready after event!"); } }, { once: true }); } 
            
            const menuButtons = topMenuBar_el_extra.querySelectorAll('.menu-button'); 
            menuButtons.forEach(button => button.addEventListener('click', () => { if (currentUser_extra) showExtraPageSection(button.dataset.section); else alert("Please log in."); })); 
            
            // Day Profile Override Listeners
            if(overrideDateInput_el_extra) overrideDateInput_el_extra.addEventListener('change', updateSelectedDateInfo_ExtraPage); 
            if(setOverrideButton_el_extra) setOverrideButton_el_extra.addEventListener('click', handleSetOverride_ExtraPage); 
            if(clearOverrideButton_el_extra) clearOverrideButton_el_extra.addEventListener('click', handleClearOverride_ExtraPage); 
            
            // Stop Management Listeners
            if (inputNewStopName_el_extra) inputNewStopName_el_extra.addEventListener('input', autoGenerateAndSetNewStopId_ExtraPage); 
            if (inputNewStopId_el_extra && newStopIdAvailability_el_extra) { inputNewStopId_el_extra.addEventListener('input', () => { const newStopId = inputNewStopId_el_extra.value.trim().toUpperCase(); if (!newStopId) { newStopIdAvailability_el_extra.textContent = ''; return; } if (!/^[A-Z0-9]+$/.test(newStopId)) { newStopIdAvailability_el_extra.textContent = 'ID invalid chars.'; newStopIdAvailability_el_extra.style.color = '#e74c3c'; return; } const existingStopIDs = new Set(currentWorkingSchedule_extra.map(e => e.stopID.toUpperCase())); if (existingStopIDs.has(newStopId)) { newStopIdAvailability_el_extra.textContent = 'ID already exists!'; newStopIdAvailability_el_extra.style.color = '#e74c3c'; } else { newStopIdAvailability_el_extra.textContent = 'ID available.'; newStopIdAvailability_el_extra.style.color = '#2ecc71'; } }); } 
            if (buttonAddNewStop_el_extra) buttonAddNewStop_el_extra.addEventListener('click', handleAddStopDetails_ExtraPage); 
            if (fileInputBulkAddStops_el_extra) fileInputBulkAddStops_el_extra.addEventListener('change', handleExcelFileForBulkAdd_ExtraPage); 
            if (buttonBulkAddNewStops_el_extra) buttonBulkAddNewStops_el_extra.addEventListener('click', handleBulkAddStops_ExtraPage); 
            if(masterStopListFilterInput_el_extra) masterStopListFilterInput_el_extra.addEventListener('input', populateMasterStopList_ExtraPage); 
            if(refreshMasterStopListButton_el_extra) refreshMasterStopListButton_el_extra.addEventListener('click', ()=>{ loadInitialData_ExtraPage().then(()=>populateMasterStopList_ExtraPage()); }); 
            if(applyMasterListStopIdChangesButton_el_extra) applyMasterListStopIdChangesButton_el_extra.addEventListener('click', handleApplyMasterListStopIdChangesButton_ExtraPage); 
            if(exportUniqueStopsButton_el_extra) exportUniqueStopsButton_el_extra.addEventListener('click', () => { if (!currentUser_extra) { alert("Log in to export."); return; } const uniqueStops = getUniqueStopsFromSchedule_ExtraPage(); if (uniqueStops.length === 0) { alert("No unique stops to export."); return; } const dataToExport = uniqueStops.map(stop => { const servingLineNames = new Set(); currentWorkingSchedule_extra.forEach(entry => { if (entry.stopID === stop.stopID && entry.lineName && entry.lineName.trim() !== "" && entry.lineName.toUpperCase() !== "INFO_ONLY") servingLineNames.add(entry.lineName); }); return { "StopID": stop.stopID, "StopName": stop.stopName, "Direction": stop.direction, "LineName(s)": Array.from(servingLineNames).sort(compareLineNames_ExtraPage).join(', ') }; }); const headers = ["StopID", "StopName", "Direction", "LineName(s)"]; const worksheetData = [ headers, ...dataToExport.map(row => headers.map(header => row[header])) ]; const worksheet = XLSX.utils.aoa_to_sheet(worksheetData); const workbook = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(workbook, worksheet, "OMSI Bus Stops"); XLSX.writeFile(workbook, "OMSI_Bus_Stops_Extra.xlsx"); }); 
            if(findDuplicateStopsByNameDirButton_el_extra) findDuplicateStopsByNameDirButton_el_extra.addEventListener('click', findDuplicateStopsByNameAndDirection_ExtraPage); 
            
            // Global Route Deletion Listeners
            if(deleteEntireRouteButton_el_extra) deleteEntireRouteButton_el_extra.addEventListener('click', handleDeleteEntireRouteGlobally_ExtraPage); 
            
            // Route Profile Deletion (RPD) Listeners - NEW
            if (rpdRouteSelect_el_extra) rpdRouteSelect_el_extra.addEventListener('change', rpd_handleRouteNameSelectChange_ExtraPage);
            if (rpdRouteInput_el_extra) rpdRouteInput_el_extra.addEventListener('blur', rpd_handleRouteNameInputChange_ExtraPage);
            if (rpdDestinationSelect_el_extra) rpdDestinationSelect_el_extra.addEventListener('change', rpd_handleDestinationNameSelectChange_ExtraPage);
            if (rpdDestinationInput_el_extra) rpdDestinationInput_el_extra.addEventListener('blur', rpd_handleDestinationNameInputChange_ExtraPage);
            if (rpdClearDestinationButton_el_extra) rpdClearDestinationButton_el_extra.addEventListener('click', rpd_handleClearDestination_ExtraPage);
            if (rpdDeleteProfilesButton_el_extra) rpdDeleteProfilesButton_el_extra.addEventListener('click', handleDeleteRouteProfiles_ExtraPage);

            // Route Schedule Generator (RSG) Listeners
            if (rsgRouteNameSelect_el_extra) rsgRouteNameSelect_el_extra.addEventListener('change', () => { rsg_handleRouteNameSelectChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgRouteNameInput_el_extra) rsgRouteNameInput_el_extra.addEventListener('blur', () => { rsg_handleRouteNameInputChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgOperatingProfileInput_el_extra) rsgOperatingProfileInput_el_extra.addEventListener('change', rsg_loadOrPullConfiguration_ExtraPage); 
            if (rsgDestinationNameSelect_el_extra) rsgDestinationNameSelect_el_extra.addEventListener('change', () => { rsg_handleDestinationNameSelectChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgDestinationNameInput_el_extra) rsgDestinationNameInput_el_extra.addEventListener('blur', () => { rsg_handleDestinationNameInputChange_ExtraPage(); rsg_loadOrPullConfiguration_ExtraPage(); }); 
            if (rsgStopSearchInput_el_extra) rsgStopSearchInput_el_extra.addEventListener('input', rsg_handleStopSearch_ExtraPage); 
            if (rsgGenerateScheduleButton_el_extra) rsgGenerateScheduleButton_el_extra.addEventListener('click', rsg_handleGenerateSchedulePreview_ExtraPage); 
            if (rsgSaveConfigurationButton_el_extra) rsgSaveConfigurationButton_el_extra.addEventListener('click', rsg_handleSaveConfiguration_ExtraPage); 
            if (rsgAddToWorkingScheduleButton_el_extra) rsgAddToWorkingScheduleButton_el_extra.addEventListener('click', rsg_handleAddGeneratedToWorkingSchedule_ExtraPage); 
            if(rsgOpenCopyModalButton_el_extra) rsgOpenCopyModalButton_el_extra.addEventListener('click', rsg_openCopyFromModal_ExtraPage); 
            if(rsgCopyModalCancelButton_el_extra) rsgCopyModalCancelButton_el_extra.addEventListener('click', rsg_closeCopyFromModal_ExtraPage); 
            if(rsgCopyModalActionButton_el_extra) rsgCopyModalActionButton_el_extra.addEventListener('click', rsg_handleCopyDataFromSource_ExtraPage); 
            if(rsgCopySourceRouteNameSelect_el_extra) { rsgCopySourceRouteNameSelect_el_extra.addEventListener('change', () => { if(rsgCopySourceRouteNameInput_el_extra) rsgCopySourceRouteNameInput_el_extra.value = rsgCopySourceRouteNameSelect_el_extra.value; rsg_populateCopySourceDestinationSelect_ExtraPage(); }); } 
            if(rsgCopySourceRouteNameInput_el_extra) { rsgCopySourceRouteNameInput_el_extra.addEventListener('blur', () => { const typedRouteUpper = rsgCopySourceRouteNameInput_el_extra.value.trim().toUpperCase(); const matchedOption = Array.from(rsgCopySourceRouteNameSelect_el_extra.options).find(opt => opt.value.toUpperCase() === typedRouteUpper); if (matchedOption) { rsgCopySourceRouteNameSelect_el_extra.value = matchedOption.value; if(rsgCopySourceRouteNameInput_el_extra.value !== matchedOption.value) rsgCopySourceRouteNameInput_el_extra.value = matchedOption.value; } else { rsgCopySourceRouteNameSelect_el_extra.value = ""; } rsg_populateCopySourceDestinationSelect_ExtraPage(); }); } 
            if(rsgCopySourceDestNameSelect_el_extra) { rsgCopySourceDestNameSelect_el_extra.addEventListener('change', () => { if(rsgCopySourceDestNameInput_el_extra) rsgCopySourceDestNameInput_el_extra.value = rsgCopySourceDestNameSelect_el_extra.value; }); } 
            if(rsgCopySourceDestNameInput_el_extra) { rsgCopySourceDestNameInput_el_extra.addEventListener('blur', () => { const typedDest = rsgCopySourceDestNameInput_el_extra.value.trim(); const matchedOption = Array.from(rsgCopySourceDestNameSelect_el_extra.options).find(opt => opt.value === typedDest); if (matchedOption) rsgCopySourceDestNameSelect_el_extra.value = matchedOption.value; else rsgCopySourceDestNameSelect_el_extra.value = ""; }); } 
            if (rsgCopyModal_el_extra) { rsgCopyModal_el_extra.addEventListener('click', (event) => { if (event.target === rsgCopyModal_el_extra) rsg_closeCopyFromModal_ExtraPage(); }); }
        });
</script>

</body>
</html>
