<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>OMSI Countdown - Display</title>
    <script src="https://cdn.tailwindcss.com"></script>


    <link rel="manifest" href="/live-tracker/manifest-omsi.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OMSI Arrivals">
    <meta name="theme-color" content="#2b5876">
    <link rel="apple-touch-icon" href="/live-tracker/assets/icons/apple-touch-icon-180x180.png">

    <style>
        /* Global and Body Styles */
        @font-face {
            font-family: 'NJFont Medium Web';
            src: url('fonts/NJFont-Medium.ttf') format('truetype'); /* Relative path, should be fine */
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        html {
            height: 100%;
        }
        body {
            font-family: 'NJFont Medium Web', sans-serif;
            background: linear-gradient(135deg, #2b5876, #4e4376);
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 1rem; /* Added some body padding for smaller screens */
            box-sizing: border-box; /* Ensure padding doesn't add to width */
            overflow-x: hidden;
            position: relative;
        }

        #clock-container {
            text-align: center;
            margin-bottom: 1rem;
            margin-top: 1rem; /* Adjusted from 13 to 1rem for consistency */
            padding-top: 1rem;
            width: 100%; /* Ensure it takes available width */
        }
        #clock-time {
            font-size: 20vmin; /* This can get very large on wider small screens if height is small */
            /* We'll adjust this in media queries */
            font-weight: normal;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.4);
            line-height: 1; /* Add line-height to prevent excessive space */
        }
        #clock-date {
            font-size: clamp(1.25rem, 5vmin, 1.75rem);
            opacity: 0.8;
            margin-top: -1rem; /* Reduced negative margin, will adjust further */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        #bus-arrivals-container {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 600px;
            text-align: left;
            position: relative;
            margin-bottom: 1rem;
            height: 370px;
            display: flex;
            flex-direction: column;
        }

        #stop-letter-display {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            z-index: 10;
        }
        #stop-letter-display .stop-letter-circle {
            display: inline-flex;
            align-items: center;     /* ADDED for vertical centering of letterSpan */
            justify-content: center; /* ADDED for horizontal centering of letterSpan */
            background-color: red;
            color: white;
            border-radius: 50%;
            font-weight: bold;
            font-size: 1.25rem; /* Base size for the circle itself */
            width: 1.6em;       /* Width of circle relative to its font-size */
            height: 1.6em;      /* Height of circle relative to its font-size */
            line-height: 1;     /* Helps if letterSpan was direct child of this for line-height */
            box-sizing: border-box;
            overflow: hidden;
        }
        #stop-letter-display .stop-letter-circle > span { /* Styling for the inner letterSpan */
            display: block;
            line-height: 1; /* Will be overridden by JS for precise centering */
            white-space: nowrap;
            text-align: center;
            padding: 0.05em; /* Minimal padding, sizing mostly by JS */
        }

        #stop-info-area {
            height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex-shrink: 0;
            margin-bottom: 0.25rem;
        }

        #bus-stop-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-bottom: 0.25rem;
            cursor: pointer;
            text-align: center;
            margin-top: -0.5rem;
        }
        #bus-stop-header:hover .main-stop-name-line,
        #bus-stop-header:hover .stop-name-qualifier {
             filter: brightness(1.2);
        }

        .main-stop-name-line {
            font-size: clamp(1.25rem, 5vmin, 1.75rem);
            font-weight: normal;
            text-align: center;
            line-height: 1.1;
        }
        .stop-name-qualifier {
            font-size: clamp(0.8rem, 3vmin, 1rem);
            font-weight: normal;
            text-align: center;
            opacity: 0.75;
            margin-top: 0.1em;
            line-height: 1;
        }

        #bus-stop-direction {
            font-size: clamp(0.8rem, 3vmin, 1rem);
            font-weight: normal;
            text-align: center;
            opacity: 0.75;
            margin-top: 0.25rem;
            min-height: 1.2em;
        }

        .route-tiles-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            align-content: center;

            border-top: 1px solid rgba(255,255,255,0.2);
            padding-top: 0.75rem;
            padding-bottom: 0.2rem;
            padding-left: 0;
            padding-right: 0;

            height: 90px;
            overflow-y: auto;
            flex-shrink: 0;

            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .route-tiles-container::-webkit-scrollbar {
            display: none !important;
        }

        .route-tile {
            display: inline-block;
            padding: 0.25em 0.6em;
            margin: 0.25em;
            border-radius: 0.25rem;
            font-size: 1rem;
            font-weight: normal;
            color: white;
            text-align: center;
            line-height: 1.3;
            min-width: 38px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.25);
            transition: background-color 0.3s, color 0.3s;
        }

        #bus-list {
            list-style-type: none !important;
            margin-block-start: 0 !important;
            margin-block-end: 0 !important;
            margin-inline-start: 0 !important;
            margin-inline-end: 0 !important;
            padding-inline-start: 0 !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
            padding-bottom: 0 !important;
            padding-top: 0.25rem !important;
            border-top: 1px solid rgba(255, 255, 255, 0.2) !important;
            height: 175px;
            overflow-y: auto;
            position: relative;
            scrollbar-width: none;
            -ms-overflow-style: none;
            flex-shrink: 0;
            margin-top: 0.5rem;
        }
        #bus-list::-webkit-scrollbar {
            display: none !important;
        }

        #bus-list li:not(.loading-message):not(.error-message):not(.no-buses-message):not(.stop-closed-message):not(.system-update-message):not(.custom-status-message-li) {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin: 0 !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
            padding-top: 0.5rem !important;
            padding-bottom: 0.5rem !important;
            /* border-bottom: 1px solid rgba(255, 255, 255, 0.1); */
            font-size: clamp(0.85rem, 3.2vmin, 1.05rem);
        }
        #bus-list li:last-child {
            /* border-bottom: none; */
        }

        .bus-item-number {
            width: 0.9em;
            text-align: right;
            margin-right: 1em;
            flex-shrink: 0;
        }
        .bus-item-linecode {
            min-width: 3.5em;
            margin-right: 0.75em;
            flex-shrink: 0;
        }
        .bus-item-destination {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 0.75em;
        }
        .bus-item-time {
            min-width: 3.5em;
            text-align: right;
            flex-shrink: 0;
        }

        .loading-message, .error-message, .no-buses-message, .stop-closed-message, .system-update-message {
            display: block;
            text-align: center;
            width: 100%;
            padding: 1rem;
            font-style: italic;
            opacity: 0.8;
        }

        body #bus-arrivals-container #bus-list li.stop-closed-message {
            display: block !important;
            width: 100% !important;
            padding: 1rem !important;
            font-style: italic !important;
            opacity: 0.8 !important;
            color: #FFD700 !important;
            font-weight: bold !important;
            font-size: 1.1em !important;
            text-align: center !important;
            background-color: transparent !important;
        }
        .system-update-message {
            color: #FFD700;
            font-weight: bold;
            font-size: 1.0em;
        }

        @keyframes itemSlideUp {
          from { opacity: 0.3; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
        }
        .bus-item-animate {
          animation: itemSlideUp 4s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        /* Custom Status Message CSS */
        .custom-status-message-li {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            padding-top: 0.5rem !important;
            padding-bottom: 0.5rem !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
            font-size: clamp(0.85rem, 3.2vmin, 1.05rem);
            overflow: hidden;
            box-sizing: border-box;
            color: #FFD700;
            font-weight: bold;
            width: 100%;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .custom-status-message-text {
            display: inline-block;
            white-space: nowrap;
            animation: scrollTextAnimation var(--scroll-duration, 15s) linear infinite;
            padding-right: 2em; /* Ensure message fully scrolls off before re-appearing if needed */
        }

        @keyframes scrollTextAnimation {
          0%   { transform: translateX(100%); }
          100% { transform: translateX(-100%); }
        }

        #bus-list li.custom-status-message-li:not(.loading-message):not(.error-message):not(.no-buses-message):not(.stop-closed-message):not(.system-update-message) {
            justify-content: flex-start;
        }


        #tfl-logo {
            position: absolute !important;
            bottom: 30px !important;
            right: 45px !important;
            width: 150px;
            opacity: 1 !important;
            transition: opacity 0.3s ease;
            z-index: 500;
        }
        #tfl-logo:hover {
            opacity: 1;
        }

        #disclaimer-button {
            position: absolute;
            bottom: 30px;
            left: 45px;
            background-color: rgba(0,0,0,0.3);
            color: rgba(255,255,255,0.7);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 0.3rem 0.6rem;
            border-radius: 0.375rem;
            font-size: 0.6rem;
            cursor: pointer;
            z-index: 1000;
            transition: background-color 0.2s, color 0.2s;
        }
        #disclaimer-button:hover {
            background-color: rgba(0,0,0,0.5);
            color: rgba(255,255,255,0.9);
        }
       .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6); backdrop-filter: blur(3px);
            display: none;
            justify-content: center; align-items: center; z-index: 1040;
        }
        .disclaimer-modal-content {
            background-color: #2d3748; color: #e2e8f0; padding: 2rem; border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5); width: 90%; max-width: 600px;
            max-height: 80vh; overflow-y: auto; position: relative;
            font-size: 0.8rem; line-height: 1.5;
        }
        .disclaimer-modal-content h3 {
            font-size: 1.1rem; font-weight: bold; color: #ffffff; margin-bottom: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 0.5rem;
        }
        .disclaimer-modal-content p { margin-bottom: 0.75rem; }
        .modal-close-button {
            position: absolute; top: 10px; right: 15px; background: none; border: none;
            color: #cbd5e1; font-size: 1.8rem; font-weight: bold; cursor: pointer; line-height: 1;
        }
        .modal-close-button:hover { color: #ffffff; }

        #stop-selection-modal-content {
            background-color: #2d3748; color: #e2e8f0; padding: 1.5rem; border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5); width: 90%; max-width: 500px;
            max-height: 80vh; display: flex; flex-direction: column; position: relative;
        }
        #stop-selection-modal-content h3 {
            font-size: 1.25rem; font-weight: bold; color: #ffffff; margin-bottom: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 0.75rem;
        }
        #stop-search-input {
            width: 100%; padding: 0.6rem; margin-bottom: 1rem; border-radius: 0.25rem;
            border: 1px solid #4A5568; background-color: #1A202C; color: #E2E8F0; font-size: 0.9rem;
        }
        #stop-search-input::placeholder { color: #A0AEC0; }
        #available-stops-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #available-stops-list li {
            padding: 0.75rem 0.5rem; border-bottom: 1px solid #4A5568; cursor: pointer;
            transition: background-color 0.15s ease-in-out; font-size: 0.9rem;
        }
        #available-stops-list li:last-child { border-bottom: none; }
        #available-stops-list li:hover { background-color: #4A5568; }
        #available-stops-list::-webkit-scrollbar { width: 8px; }
        #available-stops-list::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 10px; }
        #available-stops-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 10px; }
        #available-stops-list::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.5); }

        /* --- NEW MEDIA QUERY FOR PHONES --- */
        @media (max-width: 640px) { /* Common breakpoint for mobile phones */
            body {
                padding: 0.5rem; /* Reduce body padding */
            }

            #clock-container {
                margin-top: 0.5rem;
                margin-bottom: 0.5rem;
                padding-top: 0.5rem;
            }
            #clock-time {
                font-size: 18vw; /* Use vw for width-based scaling, can adjust value */
                /* Or a clamp for more control: clamp(3rem, 18vw, 5rem); */
            }
            #clock-date {
                font-size: clamp(1rem, 4vw, 1.25rem); /* Adjust size */
                margin-top: -0.5rem; /* Less negative margin */
            }

            #bus-arrivals-container {
                padding: 1rem; /* Reduce padding */
                height: auto; /* Allow height to adjust */
                min-height: 300px; /* Example minimum height */
            }

            .main-stop-name-line {
                font-size: clamp(1rem, 4.5vw, 1.5rem); /* Adjust size */
            }
            .stop-name-qualifier {
                font-size: clamp(0.75rem, 3.5vw, 0.9rem); /* Adjust size */
            }
             #bus-stop-direction {
                font-size: clamp(0.75rem, 3.5vw, 0.9rem);
                margin-top: 0.1rem;
             }


            .route-tiles-container {
                height: auto; /* Allow height to adjust based on content */
                min-height: 60px; /* Example minimum height */
                padding-top: 0.5rem;
                padding-bottom: 0.5rem;
            }
            .route-tile {
                font-size: 0.8rem; /* Smaller font for tiles */
                padding: 0.2em 0.4em; /* Smaller padding */
                margin: 0.15em; /* Smaller margin */
                min-width: 30px; /* Smaller min-width */
            }

            #bus-list {
                height: 150px; /* Adjust height or make it auto */
            }
             #bus-list li:not(.loading-message):not(.error-message):not(.no-buses-message):not(.stop-closed-message):not(.system-update-message):not(.custom-status-message-li) {
                font-size: clamp(0.8rem, 3vw, 0.95rem); /* Adjust list item font size */
                padding-top: 0.3rem !important;
                padding-bottom: 0.3rem !important;
            }
            .custom-status-message-li { /* Adjust for smaller screens */
                 font-size: clamp(0.8rem, 3vw, 0.95rem);
            }


            #tfl-logo {
                width: 100px;
                bottom: 10px !important; /* Ensures this overrides general !important */
                right: 10px !important;  /* Ensures this overrides general !important */
            }
            #disclaimer-button {
                bottom: 10px;
                left: 10px;
                font-size: 0.5rem; /* Smaller button text */
                padding: 0.2rem 0.4rem;
            }

            /* Make modals take more screen space if needed */
            .disclaimer-modal-content,
            #stop-selection-modal-content {
                width: 95%;
                padding: 1rem;
            }
            #stop-selection-modal-content h3 {
                font-size: 1.1rem;
            }
             #stop-letter-display .stop-letter-circle {
                font-size: 1rem; /* Adjust if needed */
             }
        }
        /* --- END OF NEW MEDIA QUERY --- */


        /* Your existing very small screen media query */
        @media (max-height: 300px), (max-width: 300px) {
            body { padding-top: 0; }
            #clock-container {
                margin-top: 0;
                padding-top: 0.5rem;
                margin-bottom: 1rem;
            }
            #clock-time { font-size: 15vmin; } /* Further reduce if needed */
            #clock-date { font-size: clamp(0.9rem, 4vmin, 1.2rem); margin-top: -0.25rem; }
            #bus-arrivals-container {
                padding: 0.75rem;
                height: auto !important;
            }
            #stop-info-area {
                height: auto;
                min-height: 50px;
            }
            .main-stop-name-line { font-size: clamp(0.9rem, 3.5vmin, 1.1rem); }
            .stop-name-qualifier { font-size: clamp(0.6rem, 2vmin, 0.7rem); margin-top: -0.1em; }
            #bus-stop-direction {
                font-size: clamp(0.6rem, 2vmin, 0.7rem);
                margin-top: -0.15rem;
                margin-bottom: 0.25rem;
                min-height: 1em;
            }
            .route-tile {
                font-size: 0.75rem;
                padding: 0.15em 0.35em;
                margin: 0.15em;
            }
            .route-tiles-container {
                height: auto;
                min-height: 0.8rem !important;
                padding-top: 0.25rem;
                border-top: 1px solid rgba(255,255,255,0.1);
            }
            #bus-list { height: 100px; }
            #bus-list li:not(.loading-message):not(.error-message):not(.no-buses-message):not(.stop-closed-message):not(.system-update-message):not(.custom-status-message-li) {
                padding-top: 0.3rem !important;
                padding-bottom: 0.3rem !important;
                font-size: clamp(0.7rem, 2.5vmin, 0.9rem);
            }
            .custom-status-message-li { /* Adjust for very small screens */
                 font-size: clamp(0.7rem, 2.5vmin, 0.9rem);
            }
            #stop-letter-display .stop-letter-circle { width: 1.4em; height: 1.4em; font-size: 0.6rem;}
            #stop-selection-modal-content { padding: 0.75rem; }
            #stop-selection-modal-content h3 { font-size: 0.9rem; }
        }
    </style>
</head>
<body>
    <img id="tfl-logo" src="assets/TfL.png" alt="Transport for London Logo">

    <button id="disclaimer-button">Copyright Disclaimer</button>
    <div id="disclaimer-modal-overlay" class="modal-overlay">
        <div class="disclaimer-modal-content">
            <button id="disclaimer-modal-close-button" class="modal-close-button">&times;</button>
            <h3>Disclaimer: Use of TfL-Inspired Assets</h3>
            <p>Please note that any Transport for London (TfL) inspired fonts, logos, or other visual elements used in this project are for <strong>personal, non-commercial, and recreational purposes only</strong>.</p>
            <p>This project is a personal endeavor created for fun and to explore design and development concepts. It is not affiliated with, endorsed by, or connected to TfL in any official capacity.</p>
            <p>The use of these elements is not intended for online distribution, public display in a commercial context, or any use that could imply an official association with TfL or cause confusion. My intention is solely for private enjoyment and learning.</p>
            <p>All TfL intellectual property, including official fonts (like New Johnston) and the TfL roundel logo, are the property of Transport for London. For any official or commercial use of TfL assets, please refer to TfL's official guidelines and obtain necessary permissions.</p>
            <p>The design of this page is © 2025 Ryan Hunter.</p>
            <p>V3 - 31/05/25</p>
        </div>
    </div>

    <div id="clock-container">
        <div id="clock-time">Loading...</div>
        <div id="clock-date"></div>
    </div>

    <div id="bus-arrivals-container">
        <div id="stop-letter-display"></div>
        <div id="stop-info-area">
            </div>
        <div id="route-tiles-container" class="route-tiles-container">
            </div>
        <ul id="bus-list">
            <li class="loading-message">Connecting to live data...</li>
        </ul>
    </div>

    <div id="stop-selection-modal-overlay" class="modal-overlay">
        <div id="stop-selection-modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h3>Select a Bus Stop</h3>
                <button id="close-stop-modal-button" class="modal-close-button">&times;</button>
            </div>
            <input type="text" id="stop-search-input" placeholder="Search stops by name or direction..." autocomplete="off">
            <ul id="available-stops-list"></ul>
        </div>
    </div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getDatabase, ref, onValue, get, child } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s", // Replace with your actual API key if this is a placeholder
        authDomain: "omsi-c5505.firebaseapp.com",
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "omsi-c5505",
        storageBucket: "omsi-c5505.appspot.com",
        messagingSenderId: "503595375440",
        appId: "1:503595375440:web:356be6684b77ff5909ea55",
        measurementId: "G-VN7X65V3F9"
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);

      window.firebaseOMSI = {
          database: database,
          dbRef: ref,
          dbOnValue: onValue,
          dbGet: get,
          dbChild: child
      };
      console.log("Firebase Initialized for OMSI Arrivals.");
    </script>

    <script>
    console.log("ARRIVALS SCRIPT ALIVE: Main script block started at " + new Date().toLocaleTimeString());

    // --- Global State Variables ---
    let clockTimeElement, clockDateElement, busListElement,
        stopLetterDisplayElement, routeTilesContainerElement,
        stopSelectionModalOverlay, closeStopModalButton,
        availableStopsList, stopSearchInput, disclaimerButton,
        disclaimerModalOverlayElement, disclaimerModalCloseButton,
        closedStopIDsGlobal = [];

    let allScheduledData = [];
    let activeMassCurtailments = {};
    let uniqueStops = [];
    let currentSelectedStopID = null;
    let ukBankHolidaysData = { dates: [], titles: {} };
    let globalOperationalOverrides = {};

    const MAX_DISPLAY_ROWS = 4;
    const CYCLING_ROWS_COUNT = 3;
    const MAX_DEPARTURES_OVERALL = 10;
    const MAX_TIME_TO_STATION_SECONDS = 1800;
    const earlyMorningThresholdHours = 5;

    const VALID_OPERATING_PROFILE_CODES_FOR_ARRIVALS = [
    "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su",
    "MF",
    "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MFSch",
    "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MFNSD",
    "Christmas Day", "Boxing Day", "New Years Day"
];

    let previousArrivalsSnapshot = new Array(MAX_DISPLAY_ROWS).fill(null);

    let liveUpdateIntervalId = null;
    let currentScheduleStatus = 'idle';

    let currentDepartureCycleStartIndex = 0;
    let allUpcomingBusesMasterList = [];

    const schoolHolidayDateRanges = [
    { start: '2025-05-24', end: '2025-06-01' }, // Summer half term 2025
    { start: '2025-07-19', end: '2025-09-02' }, // Summer holidays 2025
    { start: '2025-10-25', end: '2025-11-02' }, // Autumn half term 2025
    { start: '2025-12-20', end: '2026-01-04' }, // Christmas 2025/26
    { start: '2026-02-14', end: '2026-02-22' }, // Spring half term 2026
    { start: '2026-04-03', end: '2026-04-20' }, // Easter 2026
    { start: '2026-05-23', end: '2026-05-31' }, // Summer half term 2026
    { start: '2026-07-18', end: '2026-09-02' }, // Summer holidays 2026
    { start: '2026-10-24', end: '2026-11-01' }, // Autumn half term 2026
    { start: '2026-12-19', end: '2027-01-04' }, // Christmas 2026/27
    { start: '2027-02-13', end: '2027-02-21' }, // Spring half term 2027
    { start: '2027-03-26', end: '2027-04-13' }, // Easter 2027
    { start: '2027-05-29', end: '2027-06-06' }, // Summer half term 2027
    { start: '2027-07-22', end: '2027-08-31' }  // Summer holidays 2027 (END DATE TBC)
];

    const initialRouteColourMap = {
        "1": "#DC2626", "2": "#DC2626", "3": "#DC2626", "4": "#00783A", "5": "#00783A", "6": "#00783A",
        "7": "#FFD300", "8": "#FFD300", "9": "#FFD300", "10": "#970006", "11": "#76D0BD", "12": "#F3A9BB",
        "186": "#E32017", "32":  "#00A4A7", "N5":  "#0019A8", "C11": "#FFD300","107": "#76D0BD",
        "221": "#93002F", "240": "#C9A0DC", "251": "#F8A960","303": "#868F98", "305": "#CF7EA2",
        "SL1": "#5F259F", "SL10": "#A05A2C"
    };
    const DEFAULT_ROUTE_COLOUR = "#73809C";
    let globalCustomRouteColours = { ...initialRouteColourMap };
    let stopSpecificRouteColours = {};

    const FB_PATH_LIVE_SCHEDULE_DATA_STRUCTURED = '/liveSchedule/schedulesByRoute';
    const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
    const FB_PATH_APPSTATE = '/appState';
    const FB_PATH_SETTINGS_CUSTOM_COLOURS = '/settings/customRouteColours';
    const FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS = '/settings/stopSpecificRouteColours';
    const FB_PATH_CUSTOM_STATUS_MESSAGE = '/appState/customStatusMessage';
    const FB_PATH_OPERATIONAL_OVERRIDES = '/operationalOverrides';
    const FB_PATH_ALL_DEFINED_STOPS = '/allDefinedStops';
    const FB_PATH_MASS_CURTAILMENTS = '/liveServiceInterventions/massCurtailments';


    let customMessageSettings = {
        text: "",
        startTimeISO: null,
        endTimeISO: null,
        scrollSpeed: "medium",
        isEnabled: false
    };

    // --- Helper Functions ---
    function sanitizeFirebaseKey(text) {
        if (typeof text !== 'string') return '';
        return text.replace(/[.#$[\]]/g, '_');
    }

    function isMobileScreen() {
      return window.screen.width < 768;
    }

    async function lockToPortraitOnMobile() {
      if (isMobileScreen()) {
        try {
          if (screen.orientation && typeof screen.orientation.lock === 'function') {
            await screen.orientation.lock('portrait-primary');
            console.log('Screen orientation locked to portrait.');
          } else {
            console.warn('Screen Orientation API not available or lock function missing.');
          }
        } catch (error) {
          console.error('Could not lock screen orientation:', error);
        }
      } else {
        console.log('Not a mobile screen, orientation lock not attempted.');
      }
    }

    function updateClock() {
        const now = new Date();
        const h = String(now.getHours()).padStart(2, '0');
        const m = String(now.getMinutes()).padStart(2, '0');
        const s = String(now.getSeconds()).padStart(2, '0');
        const dn = now.toLocaleDateString(undefined, { weekday: 'long' });
        const d = now.getDate();
        const mn = now.toLocaleDateString(undefined, { month: 'long' });
        const y = now.getFullYear();

        if (clockTimeElement) clockTimeElement.textContent = `${h}:${m}:${s}`;
        if (clockDateElement) clockDateElement.textContent = `${dn} ${d} ${mn} ${y}`;
    }

    async function fetchBankHolidays(){try{const r=await fetch('https://www.gov.uk/bank-holidays.json');if(!r.ok)throw new Error(`HTTP error! ${r.status}`);const d=await r.json();if(d['england-and-wales']&&d['england-and-wales'].events){const e=d['england-and-wales'].events;ukBankHolidaysData={dates:e.map(ev=>ev.date),titles:e.reduce((a,ev)=>{a[ev.date]=ev.title;return a},{})};}else console.warn("Bank hol format error.")}catch(e){console.error("Failed to fetch bank hols:",e)}};

    function isSchoolHolidayPeriod(dateObj) {
        if (!schoolHolidayDateRanges || schoolHolidayDateRanges.length === 0) return false;
        const checkTime = dateObj.getTime();
        for (const range of schoolHolidayDateRanges) {
            try {
                const startTime = new Date(range.start + "T00:00:00").getTime();
                const endTime = new Date(range.end + "T23:59:59").getTime();
                if (checkTime >= startTime && checkTime <= endTime) return true;
            } catch (e) {
                console.error("Invalid date in schoolHolidayDateRanges:", range, e);
            }
        }
        return false;
    }

    function getCodesForCalendarDay(dateObj) {
        const dateStringYYYYMMDD = `${dateObj.getFullYear()}-${String(dateObj.getMonth() + 1).padStart(2, '0')}-${String(dateObj.getDate()).padStart(2, '0')}`;

        if (globalOperationalOverrides &&
            globalOperationalOverrides[dateStringYYYYMMDD] &&
            typeof globalOperationalOverrides[dateStringYYYYMMDD] === 'string') {

            const overriddenProfileString = globalOperationalOverrides[dateStringYYYYMMDD];
            console.log(`[ARRIVALS DEBUG] Using general string override for ${dateStringYYYYMMDD}: ${overriddenProfileString}`);
            return overriddenProfileString.split(',').map(p => p.trim()).filter(p => p);
        }

        const dOW = dateObj.getDay();
        let dCodes = new Set();
        let isBH = false;

        if (ukBankHolidaysData && ukBankHolidaysData.dates && ukBankHolidaysData.dates.includes(dateStringYYYYMMDD)) {
            const holidayTitle = ukBankHolidaysData.titles[dateStringYYYYMMDD] || "";
            isBH = true;
            if (holidayTitle.toLowerCase().includes("good friday")) {
                dCodes.add("Sa");
            } else {
                dCodes.add("Su");
            }
            if (holidayTitle.toLowerCase().includes("christmas day")) dCodes.add("Christmas Day");
            if (holidayTitle.toLowerCase().includes("boxing day")) dCodes.add("Boxing Day");
            if (holidayTitle.toLowerCase().includes("new year’s day")) dCodes.add("New Years Day");
        }

        if (!isBH) {
            const isSchHol = isSchoolHolidayPeriod(dateObj);
            const schoolSuffix = isSchHol ? "NSD" : "Sch";
            let dayCode = "";
            switch (dOW) {
                case 0: dayCode = "Su"; break;
                case 1: dayCode = "Mo"; break;
                case 2: dayCode = "Tu"; break;
                case 3: dayCode = "We"; break;
                case 4: dayCode = "Th"; break;
                case 5: dayCode = "Fr"; break;
                case 6: dayCode = "Sa"; break;
            }
            dCodes.add(dayCode);
            if (dOW >= 1 && dOW <= 5) {
                dCodes.add(dayCode + schoolSuffix);
                dCodes.add("MF" + schoolSuffix);
                dCodes.add("Mo-Fr");
                dCodes.add("MF");
            }
           if ((dOW === 6 || dOW === 0) && isSchHol) {
                dCodes.add(dayCode + "NSD");
           }
            if (isSchHol) {
                dCodes.add("SchoolHoliday");
            }
        } else {
            const isSchHolOnBH = isSchoolHolidayPeriod(dateObj);
            if (isSchHolOnBH) {
                dCodes.add("SchoolHoliday");
            }
        }
        return Array.from(dCodes).filter(code => VALID_OPERATING_PROFILE_CODES_FOR_ARRIVALS.includes(code));
    }

    function generateArrivalText(s){return s<-59?null:(s<60?'due':`${Math.round(s/60)} min`)}
    function sanitize(s){const e=document.createElement('div');e.textContent=s;return e.innerHTML}
    function getTextWidth(t,fS){const c=getTextWidth.canvas||(getTextWidth.canvas=document.createElement("canvas")),ctx=c.getContext("2d");ctx.font=fS;return ctx.measureText(t).width}
    function simpleCompareLineNames(a, b) { const numA = parseInt(a, 10); const numB = parseInt(b, 10); const isNumA = !isNaN(numA); const isNumB = !isNaN(numB); if (isNumA && isNumB) { if (numA < numB) return -1; if (numA > numB) return 1; return a.localeCompare(b); } if (isNumA && !isNumB) return -1; if (!isNumA && isNumB) return 1; return a.localeCompare(b); }

    function getRouteTileColour(lineName) {
        const upperLineName = String(lineName || "").toUpperCase();
        const currentStopId = currentSelectedStopID;

        if (currentStopId && stopSpecificRouteColours &&
            stopSpecificRouteColours[currentStopId.toUpperCase()] &&
            stopSpecificRouteColours[currentStopId.toUpperCase()][upperLineName]) {
            return stopSpecificRouteColours[currentStopId.toUpperCase()][upperLineName];
        }

        if (globalCustomRouteColours.hasOwnProperty(upperLineName)) {
            const globalColorSetting = globalCustomRouteColours[upperLineName];
            if (typeof globalColorSetting === 'object' && globalColorSetting !== null && globalColorSetting.top && globalColorSetting.bottom) {
                return globalColorSetting.top;
            } else if (typeof globalColorSetting === 'string') {
                return globalColorSetting;
            }
        }

        if (typeof initialRouteColourMap !== 'undefined' && initialRouteColourMap[upperLineName]) {
            return initialRouteColourMap[upperLineName];
        }

        if (upperLineName.startsWith("N")) {
            return globalCustomRouteColours["NIGHT_DEFAULT"] || initialRouteColourMap["N5"] || "#0019A8";
        }
        if (upperLineName.startsWith("SL")) {
            return globalCustomRouteColours["SL_DEFAULT"] || initialRouteColourMap["SL1"] || "#5F259F";
        }

        return DEFAULT_ROUTE_COLOUR;
    }

    function getTextColourForBackground(hexColour) { if (!hexColour || hexColour.length < 7) return '#FFFFFF'; const r = parseInt(hexColour.slice(1, 3), 16); const g = parseInt(hexColour.slice(3, 5), 16); const b = parseInt(hexColour.slice(5, 7), 16); const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255; return luminance > 0.5 ? '#000000' : '#FFFFFF'; }
    function displaySystemUpdateMessage() { console.log("[ARRIVALS DEBUG] Displaying system update message."); if (busListElement) { busListElement.innerHTML = `<li class="system-update-message">Live bus arrivals are not available at this time.<br>System update in progress.</li>`; } if (liveUpdateIntervalId) { clearInterval(liveUpdateIntervalId); liveUpdateIntervalId = null; } }
    function isCustomMessageActive() { if (!customMessageSettings || !customMessageSettings.isEnabled || !customMessageSettings.text) { return false; } const now = new Date(); const startTime = customMessageSettings.startTimeISO ? new Date(customMessageSettings.startTimeISO) : null; const endTime = customMessageSettings.endTimeISO ? new Date(customMessageSettings.endTimeISO) : null; if (customMessageSettings.isEnabled && customMessageSettings.text && !startTime && !endTime) { return true; } if (startTime && endTime) { return now >= startTime && now <= endTime; } else if (startTime) { return now >= startTime; } else if (endTime) { return now <= endTime; } return false; }
    
function extractDestinationNameFromRule(ruleDestination) {
        // This function is designed to extract just the destination name from a potentially
        // verbose string like "35 to Amcotts - MF, Sa" or "RouteName to Destination - Profile".
        // It should handle cases where only the destination is present, or the full string.

        if (!ruleDestination || typeof ruleDestination !== 'string') {
            return ruleDestination; // Return as is if not a string or empty/null
        }

        // Regex Explanation:
        // ^(?:[A-Z0-9]+\s+to\s+)?  - Non-capturing group: Optionally matches "ROUTE_NUMBER to " (e.g., "35 to ").
        //                           `?:` makes it non-capturing, `?` makes it optional.
        // (.*?)                   - Capturing group 1: Matches any character (`.`) zero or more times (`*?`) non-greedily.
        //                           This captures the destination name itself.
        // (?:\s+-\s+.*)?$         - Non-capturing group: Optionally matches " - " followed by any characters to the end of the string.
        //                           This handles the "- PROFILE" part if it exists.
        // `i` flag                - Makes the match case-insensitive.

        const match = ruleDestination.match(/^(?:[A-Z0-9]+\s+to\s+)?(.*?)(?:\s+-\s+.*)?$/i);

        if (match && match[1]) {
            return match[1].trim(); // Return the captured destination part, trimmed of whitespace
        }

        // If no specific pattern is matched, return the original string.
        // This handles cases where ruleDestination is already just the plain destination name.
        return ruleDestination;
    }

    function updateAndDisplayLiveArrivals() {
        if (currentScheduleStatus === 'simulating_scheduled_update_downtime') { displaySystemUpdateMessage(); return; }
        if (!currentSelectedStopID || !allScheduledData || allScheduledData.length === 0) { if (busListElement) { busListElement.innerHTML = `<li class="loading-message">${(!allScheduledData || allScheduledData.length === 0) ? 'No schedule data. <a href="setup.html" style="color:#90cdf4;">Setup</a>.' : 'Select a stop.'}</li>`;} previousArrivalsSnapshot = new Array(MAX_DISPLAY_ROWS).fill(null); return; }
        if (closedStopIDsGlobal.includes(currentSelectedStopID)) { if (busListElement && !busListElement.querySelector('.stop-closed-message')) { busListElement.innerHTML = `<li class="stop-closed-message">Bus stop closed.<br>Please use the next or previous stop.</li>`; } previousArrivalsSnapshot = new Array(MAX_DISPLAY_ROWS).fill(null); return; }

        const nowForProcessing = new Date();
        const messageActive = isCustomMessageActive();
        const busDisplaySlotsCount = messageActive ? MAX_DISPLAY_ROWS - 1 : MAX_DISPLAY_ROWS;
        const effectiveCyclingRowsCount = messageActive ? MAX_DISPLAY_ROWS - 2 : MAX_DISPLAY_ROWS - 1;

        const processedBuses = allScheduledData
            .filter(bus => bus.stopID === currentSelectedStopID)
            .map((bus, mapIndex) => {
                // --- Start of existing robust time and profile logic ---
                if (!bus || !bus.OperatingProfile || typeof bus.OperatingProfile !== 'string' || bus.OperatingProfile.trim() === "") return null;
                let tempTimeStr = String(bus.scheduledTime).trim();
                const tempNumTime = parseFloat(tempTimeStr);
                if (!isNaN(tempNumTime) && tempNumTime >= 0 && tempNumTime < 1 && !tempTimeStr.includes(':')) {
                    const totalMins = Math.round(tempNumTime * 1440);
                    tempTimeStr = `${String(Math.floor(totalMins/60)).padStart(2,'0')}:${String(totalMins%60).padStart(2,'0')}`;
                }
                const tempParts = tempTimeStr.match(/^(\d{1,2}):(\d{2})$/);
                if (!tempParts) return null;
                const hrs = parseInt(tempParts[1], 10);
                const mins = parseInt(tempParts[2], 10);
                const dayOffsetFromFile = parseInt(bus.DayOffset || "0") || 0;
                if (isNaN(hrs) || isNaN(mins) || hrs < 0 || hrs > 23 || mins < 0 || mins > 59) return null;
                let scheduleDate = new Date(nowForProcessing);
                if (nowForProcessing.getHours() < earlyMorningThresholdHours) {
                    if (hrs >= 20) {
                        scheduleDate.setDate(scheduleDate.getDate() - 1);
                    } else if (dayOffsetFromFile > 0 && hrs < earlyMorningThresholdHours) {
                        scheduleDate.setDate(scheduleDate.getDate() - dayOffsetFromFile);
                    }
                }
                let dayCodesForThisBus = getCodesForCalendarDay(scheduleDate);
                const dateStringYYYYMMDD = `${scheduleDate.getFullYear()}-${String(scheduleDate.getMonth() + 1).padStart(2, '0')}-${String(scheduleDate.getDate()).padStart(2, '0')}`;
                if (globalOperationalOverrides[dateStringYYYYMMDD] && typeof globalOperationalOverrides[dateStringYYYYMMDD] === 'object' && globalOperationalOverrides[dateStringYYYYMMDD][bus.lineName] && typeof globalOperationalOverrides[dateStringYYYYMMDD][bus.lineName] === 'string') {
                    const routeSpecificOverride = globalOperationalOverrides[dateStringYYYYMMDD][bus.lineName];
                    dayCodesForThisBus = routeSpecificOverride.split(',').map(p => p.trim()).filter(p => p);
                }
                const busOpCodesLower = bus.OperatingProfile.split(',').map(c => c.trim().toLowerCase());
                const dayCodesLower = dayCodesForThisBus.map(c => c.toLowerCase());
                if (!busOpCodesLower.some(boc => dayCodesLower.includes(boc))) { return null; }
                let adjustedSchedTime = new Date(scheduleDate.getFullYear(), scheduleDate.getMonth(), scheduleDate.getDate(), hrs, mins, 0);
                if (dayOffsetFromFile === 0 && hrs < earlyMorningThresholdHours && nowForProcessing.getHours() >= 20) {
                    adjustedSchedTime.setDate(adjustedSchedTime.getDate() + 1);
                } else if (dayOffsetFromFile > 0) {
                    adjustedSchedTime.setDate(adjustedSchedTime.getDate() + dayOffsetFromFile);
                }
                // --- End of existing robust time and profile logic ---

                let busDataForProcessing = { ...bus };

                // --- NEW LOGIC TO APPLY SERVICE-WIDE CURTAILMENTS DYNAMICALLY ---
                // This checks the rules from `/liveServiceInterventions/massCurtailments`.
                // It only applies a rule if the bus hasn't already been curtailed by a more specific single-trip intervention.
                if (!busDataForProcessing.curtailment && Object.keys(activeMassCurtailments).length > 0) {
                    for (const key in activeMassCurtailments) {
                        const rule = activeMassCurtailments[key];
                        // Check if the rule object is valid and currently active
                        if (rule && rule.startTime && rule.endTime && rule.routeName && rule.destinationName) {
                            const startTime = new Date(rule.startTime);
                            const endTime = new Date(rule.endTime);

                            // Extract the simplified destination from the rule's destinationName
                            const ruleSimpleDestination = extractDestinationNameFromRule(rule.destinationName);

                        if (nowForProcessing >= startTime && nowForProcessing <= endTime &&
                            rule.routeName === busDataForProcessing.lineName &&
                            ruleSimpleDestination ===
			    extractDestinationNameFromRule(busDataForProcessing.destinationName))
                        {
                                // This bus matches an active service-wide rule. Apply it dynamically.
                                busDataForProcessing.curtailment = {
                                    curtailAtStopID: rule.newTerminusStopId,
                                    newDestinationName: rule.newTerminusDisplayName,
                                    appliedAt: rule.startTime // Use the rule's start time for reference
                                };
                                break; // Rule applied, no need to check other rules for this bus
                            }
                        }
                    }
                }
                // --- END OF NEW LOGIC ---

                // --- EXISTING CURTAILMENT LOGIC (Now works with both single-trip and service-wide curtailments) ---
                if (busDataForProcessing.curtailment) {
                    const curtailmentInfo = busDataForProcessing.curtailment;
                    const stopSequence = busDataForProcessing.tripStopSequence || [];
                    const currentStopIndex = stopSequence.indexOf(busDataForProcessing.stopID);
                    const curtailStopIndex = stopSequence.indexOf(curtailmentInfo.curtailAtStopID);

                    // If this stop is beyond the new curtailment point, filter it out (don't display it)
                    if (curtailStopIndex !== -1 && currentStopIndex > curtailStopIndex) {
                        return null;
                    }
                    // Otherwise, update the destination for display to the new curtailed destination
                    busDataForProcessing.destinationName = curtailmentInfo.newDestinationName;
                }
                // --- END OF EXISTING CURTAILMENT LOGIC ---

                const diffSecs = Math.round((adjustedSchedTime.getTime() - nowForProcessing.getTime()) / 1000);
                const arrTxt = generateArrivalText(diffSecs);
                if (arrTxt === null) return null;

                const internalId = busDataForProcessing.internalId || `${busDataForProcessing.stopID}_${busDataForProcessing.lineName}_${busDataForProcessing.OperatingProfile}_${(busDataForProcessing.scheduledTime||"0000").replace(':', '')}_${dayOffsetFromFile}_${hrs}${mins}_mapIdx${mapIndex}`;
                return { ...busDataForProcessing, timeToStationInSeconds: diffSecs, calculatedArrivalText: arrTxt, internalId: internalId, originalMasterIndex: -1, resolvedScheduledTime: adjustedSchedTime.toISOString() };
            })
            .filter(b => b !== null && b.timeToStationInSeconds <= MAX_TIME_TO_STATION_SECONDS && b.timeToStationInSeconds >= -59)
            .sort((a,b) => a.timeToStationInSeconds - b.timeToStationInSeconds).slice(0, MAX_DEPARTURES_OVERALL).map((bus, index) => ({ ...bus, originalMasterIndex: index }));

            // --- The rest of the function (rendering logic) remains identical ---
            const newMasterInternalIdsString = processedBuses.map(b => b.internalId).join(',');
            const oldMasterInternalIdsString = allUpcomingBusesMasterList.map(b => b.internalId).join(',');
            if (newMasterInternalIdsString !== oldMasterInternalIdsString) currentDepartureCycleStartIndex = 0;
            allUpcomingBusesMasterList = processedBuses;
            const finalItemsToDisplayInSlots = new Array(MAX_DISPLAY_ROWS).fill(null);
            if (allUpcomingBusesMasterList.length > 0) {
                finalItemsToDisplayInSlots[0] = { ...allUpcomingBusesMasterList[0], displayNumber: 1, type: 'bus' };
                const cyclingCandidates = allUpcomingBusesMasterList.slice(1);
                if (cyclingCandidates.length > 0) {
                    if (currentDepartureCycleStartIndex >= cyclingCandidates.length) currentDepartureCycleStartIndex = 0;
                    const busesForThisCycle = cyclingCandidates.slice(currentDepartureCycleStartIndex, currentDepartureCycleStartIndex + effectiveCyclingRowsCount);
                    busesForThisCycle.forEach((bus, cycleIndex) => {
                        const masterListIndex = allUpcomingBusesMasterList.findIndex(masterBus => masterBus.internalId === bus.internalId);
                        const targetSlotIndex = 1 + cycleIndex;
                        if (targetSlotIndex < busDisplaySlotsCount) finalItemsToDisplayInSlots[targetSlotIndex] = { ...bus, displayNumber: masterListIndex !== -1 ? masterListIndex + 1 : bus.originalMasterIndex +1, type: 'bus'};
                    });
                    currentDepartureCycleStartIndex += effectiveCyclingRowsCount;
                    if (currentDepartureCycleStartIndex >= cyclingCandidates.length) currentDepartureCycleStartIndex = 0;
                }
            }
            if (messageActive) {
                let scrollDuration = "15s";
                switch(customMessageSettings.scrollSpeed) {
                    case "slow": scrollDuration = "25s"; break;
                    case "fast": scrollDuration = "10s"; break;
                    case "very_fast": scrollDuration = "7s"; break;
                }
                finalItemsToDisplayInSlots[MAX_DISPLAY_ROWS - 1] = { type: 'message', text: customMessageSettings.text, scrollDuration: scrollDuration, internalId: 'custom_message_slot_' + customMessageSettings.text };
            }
            if (busListElement) busListElement.innerHTML = '';
            const newSnapshotForThisUpdate = new Array(MAX_DISPLAY_ROWS).fill(null);
            for (let i = 0; i < MAX_DISPLAY_ROWS; i++) {
                const itemToDisplay = finalItemsToDisplayInSlots[i];
                const prevSnapshotForThisSlot = previousArrivalsSnapshot[i];
                if (itemToDisplay) {
                    const li = document.createElement('li');
                    if (itemToDisplay.type === 'bus') {
                        const numberSpan = document.createElement('span');
                        numberSpan.className = 'bus-item-number';
                        numberSpan.textContent = itemToDisplay.displayNumber + ".";
                        li.appendChild(numberSpan);
                        const lineCodeSpan = document.createElement('span');
                        lineCodeSpan.className = 'bus-item-linecode';
                        lineCodeSpan.textContent = itemToDisplay.lineName;
                        li.appendChild(lineCodeSpan);
                        const destinationSpan = document.createElement('span');
                        destinationSpan.className = 'bus-item-destination';
                        destinationSpan.title = sanitize(itemToDisplay.destinationName);
                        destinationSpan.textContent = itemToDisplay.destinationName;
                        li.appendChild(destinationSpan);
                        const timeSpan = document.createElement('span');
                        timeSpan.className = 'bus-item-time';
                        timeSpan.textContent = itemToDisplay.calculatedArrivalText;
                        li.appendChild(timeSpan);
                        let shouldAnimate = false;
                        if (!prevSnapshotForThisSlot || prevSnapshotForThisSlot.slot_type !== 'bus') shouldAnimate = true;
                        else if (itemToDisplay.internalId !== prevSnapshotForThisSlot.slot_internalId || itemToDisplay.calculatedArrivalText !== prevSnapshotForThisSlot.slot_calculatedArrivalText || itemToDisplay.displayNumber !== prevSnapshotForThisSlot.slot_displayNumber) shouldAnimate = true;
                        if (shouldAnimate) {
                            li.classList.remove('bus-item-animate');
                            void li.offsetWidth;
                            setTimeout(() => { li.classList.add('bus-item-animate'); }, 10);
                        }
                        newSnapshotForThisUpdate[i] = { slot_type: 'bus', slot_internalId: itemToDisplay.internalId, slot_calculatedArrivalText: itemToDisplay.calculatedArrivalText, slot_displayNumber: itemToDisplay.displayNumber };
                    } else if (itemToDisplay.type === 'message') {
                        li.classList.add('custom-status-message-li');
                        const marqueeSpan = document.createElement('span');
                        marqueeSpan.className = 'custom-status-message-text';
                        marqueeSpan.textContent = itemToDisplay.text;
                        li.style.setProperty('--scroll-duration', itemToDisplay.scrollDuration);
                        li.appendChild(marqueeSpan);
                        let shouldAnimateMessage = false;
                        if (!prevSnapshotForThisSlot || prevSnapshotForThisSlot.slot_type !== 'message' || prevSnapshotForThisSlot.slot_internalId !== itemToDisplay.internalId) shouldAnimateMessage = true;
                        if (shouldAnimateMessage) {
                            li.classList.remove('bus-item-animate');
                            void li.offsetWidth;
                            setTimeout(() => { li.classList.add('bus-item-animate'); }, 10);
                        }
                        newSnapshotForThisUpdate[i] = { slot_type: 'message', slot_internalId: itemToDisplay.internalId, };
                    }
                    busListElement.appendChild(li);
                } else newSnapshotForThisUpdate[i] = null;
            }
            previousArrivalsSnapshot = newSnapshotForThisUpdate;
            const actualBusesShownCount = finalItemsToDisplayInSlots.filter(item => item && item.type === 'bus').length;
            if (actualBusesShownCount === 0 && !messageActive && currentSelectedStopID && !closedStopIDsGlobal.includes(currentSelectedStopID)) {
                if (busListElement) busListElement.innerHTML = `<li class="no-buses-message">Live bus arrivals are not available at this time.</li>`;
            }
    }

function segmentScheduleEntriesIntoTrips(scheduleEntriesForServiceLeg) {
    const allTrips = [];
    if (!scheduleEntriesForServiceLeg || scheduleEntriesForServiceLeg.length === 0) {
        return allTrips;
    }

    const sortedEntries = [...scheduleEntriesForServiceLeg].sort((a, b) => {
        const dayOffsetA = parseInt(a.DayOffset || 0);
        const dayOffsetB = parseInt(b.DayOffset || 0);
        if (dayOffsetA !== dayOffsetB) return dayOffsetA - dayOffsetB;

        const timeA = (a.scheduledTime || "99:99").replace(':', '');
        const timeB = (b.scheduledTime || "99:99").replace(':', '');
        return timeA.localeCompare(timeB);
    });

    let currentTrip = [];
    let previousStopTimeAbs = -1;
    const MIN_STOPS_BEFORE_RESTART = 3; 

    for (let i = 0; i < sortedEntries.length; i++) {
        const entry = sortedEntries[i];
        if (!entry.stopID || !entry.scheduledTime) continue;

        const currentStopTimeAbs = (parseInt(entry.DayOffset || 0) * 1440) + (parseInt(entry.scheduledTime.split(':')[0]) * 60) + parseInt(entry.scheduledTime.split(':')[1]);

        if (currentTrip.length > 0 &&
           (currentStopTimeAbs < previousStopTimeAbs ||
           (entry.stopID === currentTrip[0].stopID && currentTrip.length >= MIN_STOPS_BEFORE_RESTART))) {
            allTrips.push([...currentTrip]); 
            currentTrip = []; 
        }
        currentTrip.push(entry);
        previousStopTimeAbs = currentStopTimeAbs;
    }

    if (currentTrip.length > 0) {
        allTrips.push([...currentTrip]);
    }
    return allTrips;
}

async function loadInitialData() {
    console.log("[ARRIVALS DEBUG] loadInitialData from Firebase called.");
    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        console.error("Firebase not initialized. Cannot load data.");
        if(busListElement) busListElement.innerHTML = `<li class="error-message">Firebase connection error.</li>`;
        return;
    }
    const { database, dbGet, dbChild, dbRef } = window.firebaseOMSI;

    try {
        const appStateSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE));
        if (appStateSnapshot.exists()) {
            const appState = appStateSnapshot.val();
            currentScheduleStatus = appState.scheduleStatus || 'idle';
            if (currentScheduleStatus === 'simulating_scheduled_update_downtime') { displaySystemUpdateMessage(); }

            const fbClosedStops = appState.closedStopIDs || {};
            closedStopIDsGlobal = [];
            for (const stopID in fbClosedStops) { if (fbClosedStops[stopID] === true) { closedStopIDsGlobal.push(stopID.toUpperCase()); } }
        } else {
            currentScheduleStatus = 'idle';
            closedStopIDsGlobal = [];
        }

        const customMessageSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_CUSTOM_STATUS_MESSAGE));
        if (customMessageSnapshot.exists()) {
            customMessageSettings = customMessageSnapshot.val();
        } else {
            customMessageSettings = { text: "", startTimeISO: null, endTimeISO: null, scrollSpeed: "medium", isEnabled: false };
        }

        const overridesSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_OPERATIONAL_OVERRIDES));
        if (overridesSnapshot.exists()) {
            globalOperationalOverrides = overridesSnapshot.val();
        } else {
            globalOperationalOverrides = {};
        }

const massCurtailmentsSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_MASS_CURTAILMENTS));
        if (massCurtailmentsSnapshot.exists()) {
            activeMassCurtailments = massCurtailmentsSnapshot.val() || {};
            console.log(`[ARRIVALS DEBUG] Loaded ${Object.keys(activeMassCurtailments).length} mass curtailment rules.`);
        } else {
            activeMassCurtailments = {};
        }

        const scheduleSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_SCHEDULE_DATA_STRUCTURED));
        const flatScheduleFromDB = [];
        if (scheduleSnapshot.exists()) {
            const schedulesByRoute = scheduleSnapshot.val();
            for (const routeKey in schedulesByRoute) {
                const routeData = schedulesByRoute[routeKey];
                for (const profileKey in routeData) {
                    const profileData = routeData[profileKey];
                    for (const destKey in profileData) {
                        const destData = profileData[destKey];
                        if (destData && Array.isArray(destData.entries)) {
                            destData.entries.forEach(entry => {
                                flatScheduleFromDB.push({ ...entry });
                            });
                        }
                    }
                }
            }
            flatScheduleFromDB.sort((a, b) => {
                const lineCompare = simpleCompareLineNames(a.lineName, b.lineName); if (lineCompare !== 0) return lineCompare;
                const profileCompare = (a.OperatingProfile || "").localeCompare(b.OperatingProfile || ""); if (profileCompare !== 0) return profileCompare;
                const destCompare = (a.destinationName || "").localeCompare(b.destinationName || ""); if (destCompare !== 0) return destCompare;
                const timeA = (a.scheduledTime || "99:99").replace(':', ''); const timeB = (b.scheduledTime || "99:99").replace(':', ''); return timeA.localeCompare(timeB);
            });
            allScheduledData = flatScheduleFromDB.map((e,i)=>({...e, internalId: e.internalId || `${(e.stopID||'s')}_${(e.lineName||'l')}_${(e.scheduledTime||"").replace(':','')}_${i}_fbload_arr_flat`}));
        } else {
             allScheduledData = [];
        }

        const allDefinedStopsSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_ALL_DEFINED_STOPS));
        uniqueStops = [];
        if (allDefinedStopsSnapshot.exists() && typeof allDefinedStopsSnapshot.val() === 'object') {
            const definedStopsObject = allDefinedStopsSnapshot.val();
            for (const keyInFirebase in definedStopsObject) {
                if (Object.hasOwnProperty.call(definedStopsObject, keyInFirebase)) {
                    const stopData = definedStopsObject[keyInFirebase];
                    let currentStopID = (stopData && stopData.stopID && typeof stopData.stopID === 'string') ? stopData.stopID.toUpperCase() : keyInFirebase.toUpperCase();
                    uniqueStops.push({
                        stopID: currentStopID,
                        stopName: stopData.stopName || "Unknown Name",
                        direction: stopData.direction || ""
                    });
                }
            }
            const seenStopIDs = new Set();
            uniqueStops = uniqueStops.filter(stop => {
                if (!stop.stopID) return false;
                if (seenStopIDs.has(stop.stopID)) return false;
                seenStopIDs.add(stop.stopID);
                return true;
            });
            uniqueStops.sort((a,b) => (a.stopName || "").toLowerCase().localeCompare((b.stopName || "").toLowerCase()));
        }

        const customColoursSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_CUSTOM_COLOURS));
        globalCustomRouteColours = { ...initialRouteColourMap };
        if (customColoursSnapshot.exists()) {
            const fbCustomColours = customColoursSnapshot.val();
            if (fbCustomColours && typeof fbCustomColours === 'object') {
                for (const route in fbCustomColours) {
                    if (Object.hasOwnProperty.call(fbCustomColours, route)) {
                        globalCustomRouteColours[route.toUpperCase()] = fbCustomColours[route];
                    }
                }
            }
        }

        const stopSpecificSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS));
        stopSpecificRouteColours = stopSpecificSnapshot.exists() ? stopSpecificSnapshot.val() || {} : {};

        if (uniqueStops.length > 0) {
            populateStopSelectionModal();
            const lastStopFromLocalStorage = localStorage.getItem('lastSelectedStopID');
            let stopToSelect = uniqueStops[0]?.stopID;
            if (lastStopFromLocalStorage && uniqueStops.find(s => s && s.stopID === lastStopFromLocalStorage)) {
                stopToSelect = lastStopFromLocalStorage;
            }
            if (stopToSelect) {
                selectStop(stopToSelect);
            } else if (uniqueStops[0] && uniqueStops[0].stopID) {
                selectStop(uniqueStops[0].stopID);
            } else {
                if(busListElement) busListElement.innerHTML = `<li class="no-buses-message">No valid stops to select.</li>`;
            }
        }
        else {
            const stopInfoArea = document.getElementById('stop-info-area');
            if (stopInfoArea) { stopInfoArea.innerHTML = '<div class="main-stop-name-line" style="text-align: center;">No Stops Available</div>'; }
            if(busListElement) busListElement.innerHTML = `<li class="no-buses-message">No schedule data or stops defined. Use <a href="setup.html" style="color:#90cdf4;">Setup tools</a>.</li>`;
        }
    } catch (error) {
        console.error("[ARRIVALS DEBUG] Error in loadInitialData:", error);
        if(busListElement) busListElement.innerHTML = `<li class="error-message">Error loading data. Error: ${error.message}</li>`;
    }
    setupFirebaseListeners();
}

function setupFirebaseListeners() {
    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        console.error("Firebase not initialized. Cannot set up listeners for arrivals page.");
        return;
    }
    const { database, dbOnValue, dbRef, dbChild } = window.firebaseOMSI;

    console.log("[ARRIVALS DEBUG] Setting up Firebase listeners...");

    const liveScheduleRef = dbRef(database, FB_PATH_LIVE_SCHEDULE_DATA_STRUCTURED);
    dbOnValue(liveScheduleRef, (snapshot) => {
        console.log("[ARRIVALS DEBUG] Live structured schedule data updated from Firebase.");
        const flatScheduleFromDBListener = [];
        if (snapshot.exists()) {
            const schedulesByRoute = snapshot.val();
            if (schedulesByRoute && typeof schedulesByRoute === 'object') {
                for (const routeKey in schedulesByRoute) {
                    if (Object.hasOwnProperty.call(schedulesByRoute, routeKey)) {
                        const routeData = schedulesByRoute[routeKey];
                        if (routeData && typeof routeData === 'object') {
                            for (const profileKey in routeData) {
                                if (Object.hasOwnProperty.call(routeData, profileKey)) {
                                    const profileData = routeData[profileKey];
                                    if (profileData && typeof profileData === 'object') {
                                        for (const destKey in profileData) {
                                            if (Object.hasOwnProperty.call(profileData, destKey)) {
                                                const destData = profileData[destKey];
                                                if (destData && Array.isArray(destData.entries)) {
                                                    destData.entries.forEach(entry => {
                                                        if (entry) flatScheduleFromDBListener.push({ ...entry });
                                                    });
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            flatScheduleFromDBListener.sort((a, b) => {
                const lineCompare = simpleCompareLineNames(a.lineName, b.lineName); if (lineCompare !== 0) return lineCompare;
                const profileCompare = (a.OperatingProfile || "").localeCompare(b.OperatingProfile || ""); if (profileCompare !== 0) return profileCompare;
                const destCompare = (a.destinationName || "").localeCompare(b.destinationName || ""); if (destCompare !== 0) return destCompare;
                const timeA = (a.scheduledTime || "99:99").replace(':', ''); const timeB = (b.scheduledTime || "99:99").replace(':', ''); return timeA.localeCompare(timeB);
            });
            allScheduledData = flatScheduleFromDBListener.map((e,i)=>({...e, internalId: e.internalId || `${(e.stopID||'s')}_${(e.lineName||'l')}_${(e.scheduledTime||"").replace(':','')}_${i}_fblistener_arr_flat`}));
        } else {
            allScheduledData = [];
        }

        if (currentSelectedStopID && currentScheduleStatus !== 'simulating_scheduled_update_downtime') {
            selectStop(currentSelectedStopID);
        } else if (currentScheduleStatus === 'simulating_scheduled_update_downtime') {
            displaySystemUpdateMessage();
        }
    });

    const allDefinedStopsListenerRef = dbRef(database, FB_PATH_ALL_DEFINED_STOPS);
    dbOnValue(allDefinedStopsListenerRef, (snapshot) => {
        console.log("[ARRIVALS DEBUG] All defined stops data updated from Firebase.");
        const newUniqueStopsArray = [];
        if (snapshot.exists() && typeof snapshot.val() === 'object') {
            const definedStopsObject = snapshot.val();
            if (definedStopsObject) {
                for (const keyInFirebase in definedStopsObject) {
                    if (Object.hasOwnProperty.call(definedStopsObject, keyInFirebase)) {
                        const stopData = definedStopsObject[keyInFirebase];
                        let stopIDFromData = (stopData && stopData.stopID && typeof stopData.stopID === 'string') ? stopData.stopID.toUpperCase() : keyInFirebase.toUpperCase();
                        newUniqueStopsArray.push({
                            stopID: stopIDFromData,
                            stopName: stopData.stopName || "Unknown Name",
                            direction: stopData.direction || ""
                        });
                    }
                }
            }
        }
        const seenStopIDs = new Set();
        const finalProcessedStops = newUniqueStopsArray.filter(stop => {
            if (!stop.stopID || seenStopIDs.has(stop.stopID)) return false;
            seenStopIDs.add(stop.stopID);
            return true;
        });
        finalProcessedStops.sort((a, b) => (a.stopName || "").toLowerCase().localeCompare((b.stopName || "").toLowerCase()));
        const oldUniqueStopsContentJSON = JSON.stringify(uniqueStops.map(s => ({id: s.stopID, name: s.stopName, dir: s.direction})).sort((a,b) => a.id.localeCompare(b.id)));
        const newUniqueStopsContentJSON = JSON.stringify(finalProcessedStops.map(s => ({id: s.stopID, name: s.stopName, dir: s.direction})).sort((a,b) => a.id.localeCompare(b.id)));
        if (oldUniqueStopsContentJSON !== newUniqueStopsContentJSON) {
            uniqueStops = finalProcessedStops;
            populateStopSelectionModal();
            const previouslySelectedStopID = currentSelectedStopID;
            let newStopToSelect = (previouslySelectedStopID && uniqueStops.find(s => s && s.stopID === previouslySelectedStopID)) ? previouslySelectedStopID : (uniqueStops.length > 0 ? uniqueStops[0]?.stopID : null);
            if (newStopToSelect) {
                selectStop(newStopToSelect);
            } else {
                currentSelectedStopID = null;
                if(busListElement) busListElement.innerHTML = `<li class="loading-message">No stops available.</li>`;
            }
        }
    });

    const appStateRef = dbRef(database, FB_PATH_APPSTATE);
    dbOnValue(appStateRef, (snapshot) => {
        if (snapshot.exists()) {
            const appState = snapshot.val();
            const newStatus = appState.scheduleStatus || 'idle';
            if (newStatus !== currentScheduleStatus) {
                currentScheduleStatus = newStatus;
                if (currentScheduleStatus === 'simulating_scheduled_update_downtime') displaySystemUpdateMessage();
                else if (currentSelectedStopID) selectStop(currentSelectedStopID);
            }

            const fbClosedStops = appState.closedStopIDs || {};
            const newClosed = [];
            for (const stopID in fbClosedStops) { if (fbClosedStops[stopID] === true) newClosed.push(stopID.toUpperCase()); }
            if (JSON.stringify(closedStopIDsGlobal.sort()) !== JSON.stringify(newClosed.sort())) {
                closedStopIDsGlobal = newClosed;
                if (currentSelectedStopID) selectStop(currentSelectedStopID);
                populateStopSelectionModal();
            }
        } else {
            currentScheduleStatus = 'idle'; closedStopIDsGlobal = [];
            if (currentSelectedStopID) selectStop(currentSelectedStopID);
        }
    });

    const globalCustomColoursRef = dbRef(database, FB_PATH_SETTINGS_CUSTOM_COLOURS);
    dbOnValue(globalCustomColoursRef, (snapshot) => {
        globalCustomRouteColours = { ...initialRouteColourMap };
        if (snapshot.exists()) {
            const fbCols = snapshot.val();
            if (fbCols && typeof fbCols === 'object') {
                for (const r in fbCols) { if (Object.hasOwnProperty.call(fbCols, r)) { globalCustomRouteColours[r.toUpperCase()] = fbCols[r]; } }
            }
        }
        if (currentSelectedStopID) selectStop(currentSelectedStopID);
    });

    const stopSpecificColoursRef = dbRef(database, FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS);
    dbOnValue(stopSpecificColoursRef, (snapshot) => {
        stopSpecificRouteColours = snapshot.exists() ? snapshot.val() || {} : {};
        if (currentSelectedStopID) selectStop(currentSelectedStopID);
    });

    const customMessageRef = dbRef(database, FB_PATH_CUSTOM_STATUS_MESSAGE);
    dbOnValue(customMessageRef, (snapshot) => {
        customMessageSettings = snapshot.exists() ? snapshot.val() : { text: "", startTimeISO: null, endTimeISO: null, scrollSpeed: "medium", isEnabled: false };
        if (currentSelectedStopID) updateAndDisplayLiveArrivals();
    });

    const operationalOverridesRef = dbRef(database, FB_PATH_OPERATIONAL_OVERRIDES);
    dbOnValue(operationalOverridesRef, (snapshot) => {
        globalOperationalOverrides = snapshot.exists() ? snapshot.val() : {};
        if (currentSelectedStopID) selectStop(currentSelectedStopID);
    });

    // --- NEW LISTENER FOR DYNAMIC CURTAILMENTS --- //
    const massCurtailmentsRef = dbRef(database, FB_PATH_MASS_CURTAILMENTS);
    dbOnValue(massCurtailmentsRef, (snapshot) => {
        console.log("[ARRIVALS DEBUG] Mass curtailment data updated from Firebase listener. Forcing arrivals re-render.");
        activeMassCurtailments = snapshot.exists() ? snapshot.val() || {} : {};
        // If a stop is currently selected, force a refresh of the arrivals board to apply the new rules
        if (currentSelectedStopID) {
            updateAndDisplayLiveArrivals(); // THIS IS THE CRUCIAL LINE ADDED/MODIFIED
        }
    });
    // --- END OF NEW LISTENER --- //

    console.log("[ARRIVALS DEBUG] All Firebase listeners set up.");
}

    function populateStopSelectionModal(searchTerm = "") { if (!availableStopsList) return; availableStopsList.innerHTML = ''; if (!uniqueStops || uniqueStops.length === 0) { availableStopsList.innerHTML = `<li style="padding: 0.75rem 0.5rem; text-align: center; opacity: 0.7;">No stops available. Use <a href="setup.html" style="color:#90cdf4;">Setup page</a>.</li>`; return; } const filteredStops = uniqueStops.filter(stop => stop && ((stop.stopName||"").toLowerCase().includes(searchTerm.toLowerCase()) || (stop.direction||"").toLowerCase().includes(searchTerm.toLowerCase()))); if (filteredStops.length === 0) { availableStopsList.innerHTML = `<li style="padding: 0.75rem 0.5rem; text-align: center; opacity: 0.7;">${searchTerm ? 'No stops match search.' : 'No stops found.'}</li>`; return; } filteredStops.forEach(stop => { if(!stop || !stop.stopID) return; const li = document.createElement('li'); let directionText = stop.direction || ""; if (directionText.trim() !== "") { directionText = `towards ${directionText.trim()}`; } const isClosed = closedStopIDsGlobal.includes(stop.stopID.toUpperCase()); li.textContent = `${stop.stopName || "Unknown Stop"} ${directionText ? `(${directionText})` : ''}${isClosed ? ' (Closed)' : ''}`; if (isClosed) { li.style.textDecoration = "line-through"; li.style.opacity = "0.7"; } li.setAttribute('data-stopid', stop.stopID); li.addEventListener('click', () => { selectStop(stop.stopID); closeStopSelectionModal(); }); availableStopsList.appendChild(li); }); }
    function filterStopList() { if (stopSearchInput) populateStopSelectionModal(stopSearchInput.value); }
    function openDisclaimerModal() { if (disclaimerModalOverlayElement) disclaimerModalOverlayElement.style.display = 'flex'; }
    function closeDisclaimerModal() { if (disclaimerModalOverlayElement) disclaimerModalOverlayElement.style.display = 'none'; }
    function openStopSelectionModal() { if (!uniqueStops || uniqueStops.length === 0) { alert("No schedule data. Use Setup Page."); return; } if (stopSearchInput) stopSearchInput.value = ""; populateStopSelectionModal(); if (stopSelectionModalOverlay) stopSelectionModalOverlay.style.display = 'flex'; }
    function closeStopSelectionModal() { if (stopSelectionModalOverlay) stopSelectionModalOverlay.style.display = 'none'; }

    function selectStop(stopID) {
        currentSelectedStopID = stopID; localStorage.setItem('lastSelectedStopID', stopID); currentDepartureCycleStartIndex = 0; allUpcomingBusesMasterList = []; previousArrivalsSnapshot = new Array(MAX_DISPLAY_ROWS).fill(null); if (currentScheduleStatus === 'simulating_scheduled_update_downtime') { displaySystemUpdateMessage(); const stopInfoAreaClear = document.getElementById('stop-info-area'); if (stopInfoAreaClear) stopInfoAreaClear.innerHTML = ''; if(stopLetterDisplayElement) { stopLetterDisplayElement.innerHTML = ''; stopLetterDisplayElement.style.display = 'none'; } if(routeTilesContainerElement) { routeTilesContainerElement.innerHTML = ''; } if(busListElement) busListElement.innerHTML = ''; return; } const selectedStopDetails = uniqueStops.find(s => s && s.stopID === stopID); const stopInfoArea = document.getElementById('stop-info-area'); if (stopInfoArea) stopInfoArea.innerHTML = ''; if(stopLetterDisplayElement) { stopLetterDisplayElement.innerHTML = ''; stopLetterDisplayElement.style.display = 'none';  } if(routeTilesContainerElement) routeTilesContainerElement.innerHTML = ''; if (!selectedStopDetails) { console.warn(`[ARRIVALS DEBUG] No details for stopID (selectStop): ${stopID}`); if (stopInfoArea) { const errorHeader = document.createElement('div'); errorHeader.className = 'main-stop-name-line'; errorHeader.style.textAlign = 'center'; errorHeader.textContent = 'Stop Info Missing'; stopInfoArea.appendChild(errorHeader); } if(busListElement) busListElement.innerHTML = `<li class="no-buses-message">Details missing for ${sanitize(stopID)}.</li>`; if (liveUpdateIntervalId) clearInterval(liveUpdateIntervalId); liveUpdateIntervalId = null; return; } const newBusStopHeader = document.createElement('div'); newBusStopHeader.id = 'bus-stop-header'; newBusStopHeader.title = 'Click to change stop'; newBusStopHeader.style.display = 'flex'; newBusStopHeader.style.flexDirection = 'column'; newBusStopHeader.style.alignItems = 'center'; newBusStopHeader.style.justifyContent = 'center'; newBusStopHeader.style.paddingBottom = '0.25rem'; newBusStopHeader.style.cursor = 'pointer'; newBusStopHeader.style.textAlign = 'center'; newBusStopHeader.style.marginTop = '-0.5rem'; let stopNameFull = selectedStopDetails.stopName || "Unknown Stop"; let mainNamePart = stopNameFull; let qualifierPart = null; let stopLetters = null; const qualifierRegex = /^(.*?)\s*\/\s*(.*)$/; const qualifierMatch = mainNamePart.match(qualifierRegex); if (qualifierMatch) { mainNamePart = qualifierMatch[1].trim(); qualifierPart = qualifierMatch[2].trim(); } const letterRegex = /\(([A-Z0-9]{1,3})\)$/; let tempLetterMatch = mainNamePart.match(letterRegex); if (tempLetterMatch) { stopLetters = tempLetterMatch[1]; mainNamePart = mainNamePart.replace(tempLetterMatch[0], "").trim(); } else if (qualifierPart) { tempLetterMatch = qualifierPart.match(letterRegex); if (tempLetterMatch) { stopLetters = tempLetterMatch[1]; qualifierPart = qualifierPart.replace(tempLetterMatch[0], "").trim(); } } const mainNameLineDiv = document.createElement('div'); mainNameLineDiv.className = 'main-stop-name-line'; mainNameLineDiv.textContent = mainNamePart; newBusStopHeader.appendChild(mainNameLineDiv); if (qualifierPart && qualifierPart !== "") { const qElem = document.createElement('div'); qElem.className = 'stop-name-qualifier'; qElem.textContent = qualifierPart; newBusStopHeader.appendChild(qElem); } const newBusStopDirection = document.createElement('p'); newBusStopDirection.id = 'bus-stop-direction'; newBusStopDirection.style.fontSize = 'clamp(0.8rem, 3vmin, 1rem)'; newBusStopDirection.style.fontWeight = 'normal'; newBusStopDirection.style.textAlign = 'center'; newBusStopDirection.style.opacity = '0.75'; newBusStopDirection.style.marginTop = '0.25rem'; newBusStopDirection.style.minHeight = '1.2em'; newBusStopDirection.textContent = selectedStopDetails.direction ? `towards ${selectedStopDetails.direction}` : ""; if(stopInfoArea) { stopInfoArea.appendChild(newBusStopHeader); stopInfoArea.appendChild(newBusStopDirection); newBusStopHeader.addEventListener('click', openStopSelectionModal); } if (selectedStopDetails && allScheduledData && allScheduledData.length > 0 && routeTilesContainerElement) { const allServingRoutesEver = new Set(); allScheduledData.forEach(bus => { if (bus && bus.stopID === currentSelectedStopID && bus.lineName) allServingRoutesEver.add(bus.lineName); }); const sortedServingRoutes = Array.from(allServingRoutesEver).sort(simpleCompareLineNames); routeTilesContainerElement.innerHTML = ''; sortedServingRoutes.forEach(lineName => { const tile = document.createElement('span'); tile.className = 'route-tile'; tile.textContent = lineName; let tileBGColour = getRouteTileColour(lineName); let tileTextColour = getTextColourForBackground(tileBGColour); tile.style.backgroundColor = tileBGColour; tile.style.color = tileTextColour; routeTilesContainerElement.appendChild(tile); }); } if (stopLetters && stopLetterDisplayElement && mainNameLineDiv) { const circleElement = document.createElement('span'); circleElement.className = 'stop-letter-circle'; const letterSpan = document.createElement('span'); letterSpan.textContent = stopLetters; circleElement.appendChild(letterSpan); circleElement.style.alignItems = 'center'; circleElement.style.justifyContent = 'center'; stopLetterDisplayElement.innerHTML = ''; stopLetterDisplayElement.appendChild(circleElement); stopLetterDisplayElement.style.display = 'inline-flex'; requestAnimationFrame(() => { if (!document.body.contains(circleElement) || !document.body.contains(letterSpan)) return; const circStyle=window.getComputedStyle(circleElement); const circDiam=parseFloat(circStyle.width); if(isNaN(circDiam) || circDiam <= 0) return; letterSpan.style.fontFamily = window.getComputedStyle(document.body).fontFamily; letterSpan.style.fontWeight="bold"; const lCount=(stopLetters || "").length; if(lCount===0) { letterSpan.textContent = ''; return; } const MIN_FS=6; let curSize, tgtWidth; if(lCount===1){curSize=circDiam*0.7; tgtWidth=circDiam*0.60;} else if(lCount===2){curSize=circDiam*0.50;tgtWidth=circDiam*0.70;} else{curSize=circDiam*0.40;tgtWidth=circDiam*0.75;} curSize=Math.max(MIN_FS,Math.min(curSize, circDiam*0.8)); let iter=0; let txtMeasW; do{ letterSpan.style.fontSize=curSize+"px"; txtMeasW=getTextWidth(stopLetters,`bold ${curSize}px "${getComputedStyle(letterSpan).fontFamily}"`); if(txtMeasW > tgtWidth && curSize > MIN_FS) curSize -= 0.5; else break; iter++; } while(iter<50 && curSize>MIN_FS); letterSpan.style.fontSize=curSize+"px"; letterSpan.style.lineHeight = circDiam + 'px'; }); } else { if (stopLetterDisplayElement) stopLetterDisplayElement.style.display = 'none'; } if (closedStopIDsGlobal.includes(stopID.toUpperCase())) { if(busListElement) { busListElement.innerHTML = `<li class="stop-closed-message">Bus stop closed.<br>Please use the next or previous stop.</li>`;} if (liveUpdateIntervalId) clearInterval(liveUpdateIntervalId); liveUpdateIntervalId = null; return; } updateAndDisplayLiveArrivals(); if (liveUpdateIntervalId) clearInterval(liveUpdateIntervalId); liveUpdateIntervalId = setInterval(updateAndDisplayLiveArrivals, 10000);
    }

    document.addEventListener('DOMContentLoaded', () => {
        console.log("ARRIVALS SCRIPT ALIVE: DOMContentLoaded, event listeners being set up at " + new Date().toLocaleTimeString());

        if (window.eruda) {
            eruda.init();
            console.log("Eruda initialized.");
        } else {
            console.warn("Eruda script not found or loaded.");
        }

        clockTimeElement = document.getElementById('clock-time');
        clockDateElement = document.getElementById('clock-date');
        busListElement = document.getElementById('bus-list');
        stopLetterDisplayElement = document.getElementById('stop-letter-display');
        routeTilesContainerElement = document.getElementById('route-tiles-container');
        stopSelectionModalOverlay = document.getElementById('stop-selection-modal-overlay');
        closeStopModalButton = document.getElementById('close-stop-modal-button');
        availableStopsList = document.getElementById('available-stops-list');
        stopSearchInput = document.getElementById('stop-search-input');
        disclaimerButton = document.getElementById('disclaimer-button');
        disclaimerModalOverlayElement = document.getElementById('disclaimer-modal-overlay');
        disclaimerModalCloseButton = document.getElementById('disclaimer-modal-close-button');

        updateClock(); setInterval(updateClock, 1000);
        previousArrivalsSnapshot = new Array(MAX_DISPLAY_ROWS).fill(null);

        lockToPortraitOnMobile();

        if (window.firebaseOMSI && window.firebaseOMSI.database) {
            fetchBankHolidays().then(() => loadInitialData()).catch((err) => {
                console.error("Error during initial data load sequence (bank holidays or main data):", err);
                loadInitialData();
            });
        } else {
            console.error("Firebase not initialized! Arrivals will not work correctly without Firebase.");
            if(busListElement) busListElement.innerHTML = `<li class="error-message">Error: Firebase not connected. Real-time data unavailable.</li>`;
        }

        const stopInfoHeader = document.getElementById('stop-info-area');
        if (stopInfoHeader) stopInfoHeader.addEventListener('click', openStopSelectionModal);

        if (closeStopModalButton) closeStopModalButton.addEventListener('click', closeStopSelectionModal);
        if (stopSelectionModalOverlay) stopSelectionModalOverlay.addEventListener('click', e => { if (e.target === stopSelectionModalOverlay) closeStopSelectionModal(); });
        if (stopSearchInput) stopSearchInput.addEventListener('input', filterStopList);
        if (disclaimerButton) disclaimerButton.addEventListener('click', openDisclaimerModal);
        if (disclaimerModalCloseButton) disclaimerModalCloseButton.addEventListener('click', closeDisclaimerModal);
        if (disclaimerModalOverlayElement) disclaimerModalOverlayElement.addEventListener('click', e => { if (e.target === disclaimerModalOverlayElement) closeDisclaimerModal(); });

        if ('serviceWorker' in navigator && (window.location.protocol === 'http:' || window.location.protocol === 'https:')) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/live-tracker/sw-omsi.js')
                .then(registration => console.log('Service Worker (sw-omsi.js) registered with scope:', registration.scope))
                .catch(error => {
                    console.error('Service Worker (sw-omsi.js) registration failed:', error);
                });
            });
        } else if ('serviceWorker' in navigator && window.location.protocol === 'file:') {
            console.warn('Service Worker registration skipped: Not supported over "file://" protocol. Please serve via HTTP/HTTPS or localhost.');
        } else {
            console.warn('Service Worker API not available in this browser environment.');
        }
    });
</script>
</body>
</html>
