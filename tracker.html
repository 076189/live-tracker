<!DOCTYPE html>
<html>
<head>
    <title>Live Bus Tracker</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/apple-icon-180.png">
<meta name="apple-mobile-web-app-capable" content="yes">
    <style>
        /* Basic Reset & Font */
        body, html { margin: 0; padding: 0; box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f9f9f9; }
        h1 { margin-bottom: 10px; text-align: center; }
        .info-container {
            display: flex;
            justify-content: space-between; /* Distribute space */
            align-items: center; /* Align items vertically */
            flex-wrap: wrap;
            margin-bottom: 20px;
            font-size: 1.0em; /* Adjusted base font size slightly */
            padding: 5px 0; /* Add some padding */
            border-bottom: 1px solid #eee; /* Optional separator */
        }
        .update-time, .counter, .next-update { /* Apply to all info items */
            margin-bottom: 5px;
            padding: 0 10px; /* Add horizontal padding */
            white-space: nowrap; /* Prevent wrapping */
        }
        .next-update { /* Specific style for countdown */
            font-size: 0.9em;
            color: #555;
            text-align: center; /* Center timer text */
            flex-grow: 1; /* Allow it to take available space */
        }
        .update-time { text-align: left; } /* Align left */
        .counter { text-align: right; } /* Align right */

        table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 0.9em; }
        th, td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; white-space: nowrap; }
        /* --- Table Header Styling --- */
        thead th {
            background-color: #e9e9e9; position: sticky; top: 0; z-index: 2; text-align: center; font-weight: bold; height: 30px; vertical-align: middle;
        }
        thead tr.filter-row th,
        thead tr.filter-row td {
            background-color: #f4f4f4; position: sticky; top: 30px; z-index: 1; padding: 4px 8px; vertical-align: top; text-align: center; border-top: 1px solid #ccc;
        }
        thead select {
            padding: 3px 5px; font-size: 0.9em; width: 95%; max-width: 180px; box-sizing: border-box; margin-top: 2px;
        }
        /* --- End Table Header Styling --- */

        tr:nth-child(even) { background-color: #f9f9f9; }
        tr.ghost-bus td { color: #777; font-style: italic; }
        tr.ghost-bus td:nth-child(5) { /* ETA styling */ }

        /* Highlight style */
         tr.watched-bus td {
             background-color: #fff3cd !important; /* Light yellow */
             border-left: 3px solid #e0a800 !important; /* Yellow border */
             border-right: 3px solid #e0a800 !important;
             font-weight: bold;
         }
         tr.watched-bus.ghost-bus td { /* Ensure ghosts are still readable */
              color: #856404; /* Darker yellow text */
              font-style: italic;
         }


        td[colspan="5"] { text-align: center; font-style: italic; color: #555; padding: 15px 8px; white-space: normal; }
        td:nth-child(3), td:nth-child(4) { white-space: normal; } /* Allow destination and stop name to wrap */
        h2 { margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px; text-align: center;}
        /* Style for the initial route selector */
        #route-selector { display: none; text-align: center; padding: 30px; border: 1px solid #ccc; border-radius: 8px; margin: 30px auto; max-width: 450px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        #route-selector h2 { margin-top: 0; margin-bottom: 20px; border: none; padding: 0; }
        #route-selector input[type="text"] { width: 80%; max-width: 250px; padding: 10px; margin-bottom: 15px; font-size: 1.1em; border: 1px solid #ccc; border-radius: 4px; text-align: center; text-transform: uppercase; }
        #route-selector button { padding: 10px 25px; font-size: 1.1em; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; transition: background-color 0.2s ease; }
        #route-selector button:hover { background-color: #0056b3; }
        #route-search-error { color: red; min-height: 1em; margin-top: 15px; font-size: 0.9em; }

        /* Styles for the top search bar */
        #top-route-search-container { display: flex; /* Use flexbox */ flex-wrap: wrap; /* Allow wrapping */ justify-content: center; /* Center items */ align-items: center; /* Align vertically */ gap: 10px; /* Space between items */ margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #eee; }
        #top-route-search-input, #vehicle-search-input, #watch-bus-input { /* Group input styles */ width: auto; max-width: 180px; padding: 8px; font-size: 1em; border: 1px solid #ccc; border-radius: 4px; flex-grow: 1; /* Allow inputs to grow */ }
        #top-route-search-button, #vehicle-search-button, #watch-bus-button { /* Group button styles */ padding: 8px 15px; font-size: 1em; cursor: pointer; color: white; border: none; border-radius: 4px; flex-shrink: 0; /* Prevent buttons shrinking */ }
        #top-route-search-button { background-color: #007bff; } #top-route-search-button:hover { background-color: #0056b3; }
        #vehicle-search-button { background-color: #28a745; } #vehicle-search-button:hover { background-color: #218838; }
        #watch-bus-button { background-color: #ffc107; color: black; } #watch-bus-button:hover { background-color: #e0a800; }
        #top-route-search-error { color: red; min-height: 1em; display: inline-block; margin: 0 5px; font-size: 0.9em; order: 99; /* Try to push error to end */ }
        #vehicle-search-results { width: 100%; /* Span full width */ text-align: center; margin-top: 10px; margin-bottom: 5px; font-weight: bold; min-height: 1em; order: 100; /* Ensure it's last */ }
        #watched-buses-display { width: 100%; text-align: center; margin-top: 10px; padding-bottom: 10px; order: 101; } /* Watched list below results */
        #watched-buses-display span { display: inline-block; background-color: #e9ecef; padding: 3px 8px; margin: 3px; border-radius: 12px; font-size: 0.9em; }
        #watched-buses-display button { margin-left: 5px; cursor: pointer; border: none; background: none; color: #dc3545; font-weight: bold; font-size: 1.1em; padding: 0 2px; vertical-align: middle; }


        /* --- Route Sequence Styles --- */
        #route-sequences { margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; display: flex; flex-wrap: wrap; gap: 20px; justify-content: space-around; }
        .sequence-container { flex: 1; min-width: 280px; background-color: #fff; padding: 15px; border: 1px solid #e0e0e0; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .sequence-container h2 { margin-top: 0; margin-bottom: 10px; font-size: 1.1em; text-align: left; border: none; padding: 0; }
        .sequence-list-container { max-height: 400px; overflow-y: auto; font-size: 0.85em; line-height: 1.5; }
        .sequence-list-container ol { padding-left: 30px; margin: 0; }
        .sequence-list-container li { padding: 3px 0; border-bottom: 1px dotted #f0f0f0; }
        .sequence-list-container li:last-child { border-bottom: none; }
        .sequence-list-container p { font-style: italic; color: #666; padding: 10px 0; }
        /* --- End Route Sequence Styles --- */

        /* --- Modal Styles --- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-box { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); text-align: left; width: 90%; max-width: 600px; max-height: 80%; display: flex; flex-direction: column; overflow: hidden; }
        .modal-box h3 { margin-top: 0; text-align: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; flex-shrink: 0; font-size: 1.1em; }
        .modal-content { flex-grow: 1; overflow-y: auto; font-size: 0.9em; margin-bottom: 15px; line-height: 1.6; }
         #vehicle-prediction-list table { width: 100%; border-collapse: collapse; margin-top: 5px;}
         #vehicle-prediction-list th { background-color: #f2f2f2; padding: 5px; border-bottom: 1px solid #ccc; text-align: center; font-size: 0.95em;}
         #vehicle-prediction-list td { padding: 4px 5px; border-bottom: 1px dotted #eee; }
         #vehicle-prediction-list td:nth-child(1) { text-align: center; width: 65px; } /* Due */
         #vehicle-prediction-list td:nth-child(2) { text-align: center; width: 80px; font-family: monospace; color: #333; } /* Stop ID */
         #vehicle-prediction-list td:nth-child(3) { white-space: normal; } /* Stop Name */
         #vehicle-prediction-list p { padding: 10px; text-align: center; font-style: italic; color: #666; } /* Loading/Error */
         /* Separator row style (Old - Deprecated by two-table approach) */
         /* #vehicle-prediction-list tr.turnaround-separator td { ... } */
        .modal-buttons { text-align: right; margin-top: auto; padding-top: 15px; border-top: 1px solid #eee; flex-shrink: 0; }
        .modal-buttons button { margin-left: 10px; padding: 8px 15px; color: white; border: none; border-radius: 4px; cursor: pointer;}
        .modal-buttons .cancel-button { background-color: #6c757d; } .modal-buttons .cancel-button:hover { background-color: #5a6268; }
        .hidden { display: none; }
        /* --- End Modal Styles --- */

        /* --- Service Alert Styles --- */
        #service-alerts-container { padding: 10px 15px; margin-bottom: 15px; border-radius: 5px; border: 1px solid #ccc; background-color: #f0f0f0; text-align: center; font-size: 0.95em; line-height: 1.4; transition: background-color 0.3s ease, border-color 0.3s ease; }
        #service-alerts-content { margin: 0; font-weight: bold; }
        #service-alerts-container.alert-good { background-color: #d4edda; border-color: #c3e6cb; color: #155724; }
        #service-alerts-container.alert-minor { background-color: #fff3cd; border-color: #ffeeba; color: #856404; }
        #service-alerts-container.alert-severe { background-color: #f8d7da; border-color: #f5c6cb; color: #721c24; }
        #service-alerts-container.alert-special { background-color: #d1ecf1; border-color: #bee5eb; color: #0c5460; }
        #service-alerts-container.alert-error { background-color: #f8d7da; border-color: #f5c6cb; color: #721c24; font-style: italic; }
        /* --- End Service Alert Styles --- */

    </style>
</head>
<body>
    <div id="route-selector">
        <h2>Enter Route to Track</h2>
        <input type="text" id="route-search-input" placeholder="e.g., 184, N20" aria-label="Route ID Input" autocomplete="off">
        <button id="route-search-button" type="button" onclick="loadSelectedRoute()">Load Route</button>
        <p id="route-search-error"></p>
    </div>

    <div id="tracker-content" style="display: none;">

        <div id="top-route-search-container">
            <input type="text" id="top-route-search-input" placeholder="Change route (e.g., N91)" aria-label="Change Route ID Input" autocomplete="off">
            <button id="top-route-search-button" type="button" onclick="loadTopRoute()">Go</button>
            <p id="top-route-search-error"></p> <input type="text" id="vehicle-search-input" placeholder="Enter Reg or Fleet No." aria-label="Vehicle Search Input" autocomplete="off">
            <button id="vehicle-search-button" type="button" onclick="searchForVehicle()">Find Vehicle</button>
            <div id="vehicle-search-results"></div> </div>

        <div id="service-alerts-container">
            <p id="service-alerts-content">Loading service status...</p>
        </div>
        <h1 id="main-heading">Live Bus Tracker</h1>
        <div class="info-container">
            <div class="update-time" id="update-time">Last Updated: --</div>
            <div class="next-update" id="next-update-timer">Next update in: --s</div>
            <div class="counter" id="bus-counter">Buses on Route: 0</div>
        </div>
        <table>
            <thead>
                <tr>
                    <th>Fleet No.</th>
                    <th>Registration</th>
                    <th>Destination</th>
                    <th>Next Stop / Last Known Stop</th>
                    <th>ETA / Last Seen</th>
                </tr>
                <tr class="filter-row">
                    <td><select id="filter-fleet"><option value="">All</option></select></td>
                    <td><select id="filter-reg"><option value="">All</option></select></td>
                    <td><select id="filter-destination"><option value="">All</option></select></td>
                    <td><select id="filter-stop"><option value="">All</option></select></td>
                    <td><select id="filter-arrival"><option value="">All</option></select></td>
                </tr>
            </thead>
            <tbody id="tracker-table">
                <tr><td colspan="5">Fetching live data...</td></tr>
            </tbody>
        </table>

        <h2 id="curtailments-heading">Curtailments Today</h2>
        <table>
            <thead>
                <tr>
                    <th>Route</th>
                    <th>Fleet No.</th>
                    <th>Registration</th>
                    <th>Curtailed To</th>
                    <th>Time Logged</th>
                </tr>
            </thead>
            <tbody id="curtailed-buses-table">
                <tr><td colspan="5">Loading curtailment data...</td></tr>
            </tbody>
        </table>

        <div id="route-sequences">
            <div class="sequence-container">
                <h2 id="outbound-sequence-heading">Route Sequence (Outbound)</h2>
                <div id="outbound-sequence-list" class="sequence-list-container">
                    <p>Loading sequence...</p>
                </div>
            </div>
            <div class="sequence-container">
                <h2 id="inbound-sequence-heading">Route Sequence (Inbound)</h2>
                 <div id="inbound-sequence-list" class="sequence-list-container">
                     <p>Loading sequence...</p>
                 </div>
            </div>
        </div>
    </div> <div id="vehicle-prediction-modal" class="modal-overlay hidden">
        <div class="modal-box">
            <h3 id="vehicle-prediction-title">Upcoming Stops</h3>
            <div id="vehicle-prediction-list" class="modal-content">
                <p>Loading predictions...</p>
            </div>
            <div class="modal-buttons">
                <button type="button" onclick="hideVehiclePredictionModal()" class="cancel-button">Close</button>
            </div>
        </div>
    </div>

    <script>
        /* jshint esversion: 11, browser: true */ // Add JSHint directives
// --- Start of JavaScript ---
console.log('--- FULL TRACKER SCRIPT STARTED (v21f - Destination Normalization) ---'); // Version updated

// Get references needed for showing/hiding sections
const routeSelectorDiv = document.getElementById('route-selector');
const trackerContentDiv = document.getElementById('tracker-content');

// --- Dynamic Route ID Setup ---
const urlParams = new URLSearchParams(window.location.search);
let dynamicRouteId = urlParams.get('route')?.trim().toUpperCase();

// --- Global Variables ---
let currentRouteBuses = []; // Holds combined live/ghost buses for the CURRENT route
let globalOutboundDestName = null; // Stores live destination name for outbound
let globalInboundDestName = null; // Stores live destination name for inbound
const REFRESH_INTERVAL_SECONDS = 30; // Refresh interval in seconds
let countdownValue = REFRESH_INTERVAL_SECONDS; // Current countdown value
let countdownTimerId = null; // To hold the interval ID for the countdown display
let manualSequenceHeadings = {}; // Store manual overrides { outbound: "...", inbound: "..." }
let watchedBuses = new Set(); // Set to store watched vehicle IDs (Reg or Fleet)

// --- Constants ---
const tmpMapKey = "tmpRegistrationMap"; // Key for Fleet/TMP lookup
const filterStateKey = `arrivalsFilterState_${dynamicRouteId}_all`; // Key for table filters
const busLastSeenKey = `busLastSeenWithDest_${dynamicRouteId}`; // Key for ghost bus data
const settingsKey = "trackerGlobalSettings"; // Key for global settings (like debounce)
const defaultSettings = { debounceMinutes: 60, timeoutMinutes: 30 }; // Default settings
const routeDestinationSettingsKey = 'routeDestinationSettings'; // Key for final destinations
const tmpGenerationInfoKey = "tmpGenerationInfo"; // Key for TMP generation info (unused here but defined in tools)
const destinationOverrideKey = 'destinationOverrides'; // Key for temporary iBus overrides
const sequenceHeadingOverrideKey = `sequenceHeadingOverrides_${dynamicRouteId}`; // Key for manual sequence headings
const watchedBusesStorageKey = `watchedBuses_${dynamicRouteId}`; // Key for watched buses
const ROUTE_SEQUENCE_CACHE_DURATION_MS = 24 * 60 * 60 * 1000; // 24 hours
const ALERT_CACHE_DURATION_MS = 15 * 60 * 1000; // 15 minutes for alerts

// --- Helper Functions ---

/**
 * Loads data from localStorage, handling potential parsing errors.
 * @param {string} key - The key to load from localStorage.
 * @param {*} defaultValue - The value to return if the key is not found or data is invalid.
 * @returns {*} The loaded data or the default value.
 */
function loadFromStorage(key, defaultValue = {}) {
    try {
        const data = localStorage.getItem(key);
        return data ? JSON.parse(data) : defaultValue;
    } catch (e) {
        console.error(`Error loading ${key}:`, e);
        return defaultValue;
    }
}

/**
 * Saves data to localStorage.
 * @param {string} key - The key to save data under.
 * @param {*} data - The data to save.
 */
function saveToStorage(key, data) {
    try {
        localStorage.setItem(key, JSON.stringify(data));
    } catch (e) {
        console.error(`Error saving ${key}:`, e);
        // Optionally alert the user if storage is full or another error occurs
        // alert(`Error saving data for ${key}. Storage might be full.`);
    }
}

/**
 * Escapes HTML special characters in a string.
 * @param {string} unsafe - The potentially unsafe string.
 * @returns {string} The escaped string.
 */
const escapeHtml = (unsafe) => {
    if (unsafe === null || typeof unsafe === 'undefined') return 'N/A';
    return String(unsafe)
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
};

/**
 * Normalizes a destination name for comparison.
 * Converts to lowercase, removes common station suffixes, punctuation, and extra whitespace.
 * @param {string} destName - The original destination name.
 * @returns {string} The normalized destination name.
 */
function normalizeDestination(destName) {
    if (!destName || typeof destName !== 'string') return ''; // Handle null/undefined/non-string input

    let normalized = destName.toLowerCase();

    // Remove common suffixes and surrounding punctuation/whitespace
    // Handles variations like ", station", " station", " bus station", etc.
    normalized = normalized.replace(/[,.\s]*(bus|rail|underground|train)?\s*station\s*$/,''); // Added train

    // Remove other common terms that might cause mismatches
    normalized = normalized.replace(/\s*(?:shopping centre|town centre|hospital|airport|heathrow terminal \d)\s*$/,'');

    // Remove remaining punctuation (commas, periods, apostrophes, hyphens within words if desired)
    normalized = normalized.replace(/[.,']/g, '');
    // Consider removing hyphens carefully: normalized = normalized.replace(/-/g, ' ');

    // Trim leading/trailing whitespace and collapse multiple spaces
    normalized = normalized.replace(/\s+/g, ' ').trim();

    return normalized;
}


// --- Function to handle loading route from INITIAL input ---
function loadSelectedRoute() {
    const input = document.getElementById('route-search-input');
    const errorP = document.getElementById('route-search-error');
    if (!input || !errorP) return;
    const enteredRoute = input.value.trim().toUpperCase();
    errorP.textContent = '';
    if (!enteredRoute) { errorP.textContent = 'Please enter a Route ID.'; input.focus(); return; }
    if (!/^[A-Z0-9]+$/i.test(enteredRoute) || enteredRoute.length > 5) { errorP.textContent = 'Invalid Route ID format entered.'; input.focus(); return; }
    if (countdownTimerId) clearInterval(countdownTimerId); // Clear timer before navigating
    window.location.href = `tracker.html?route=${enteredRoute}`;
}

// --- Function to handle loading route from the TOP search bar ---
function loadTopRoute() {
    const input = document.getElementById('top-route-search-input');
    const errorP = document.getElementById('top-route-search-error');
    if (!input || !errorP) return;
    const enteredRoute = input.value.trim().toUpperCase();
    errorP.textContent = '';
    if (!enteredRoute) { errorP.textContent = 'Please enter a Route ID.'; input.focus(); return; }
    if (!/^[A-Z0-9]+$/i.test(enteredRoute) || enteredRoute.length > 5) { errorP.textContent = 'Invalid Route ID format.'; input.focus(); return; }
    if (countdownTimerId) clearInterval(countdownTimerId); // Clear timer before navigating
    window.location.href = `tracker.html?route=${enteredRoute}`;
}


// Add listener for Enter key in the initial search input
const routeSearchInput = document.getElementById('route-search-input');
if (routeSearchInput) { routeSearchInput.addEventListener('keyup', function(event) { if (event.key === 'Enter') { event.preventDefault(); loadSelectedRoute(); } }); }

// Add listener for Enter key in the TOP search input
const topRouteSearchInput = document.getElementById('top-route-search-input');
if (topRouteSearchInput) { topRouteSearchInput.addEventListener('keyup', function(event) { if (event.key === 'Enter') { event.preventDefault(); loadTopRoute(); } }); }

// Add listener for Enter key in Vehicle Search Input
const vehicleSearchInput = document.getElementById('vehicle-search-input');
if (vehicleSearchInput) { vehicleSearchInput.addEventListener('keyup', function(event) { if (event.key === 'Enter') { event.preventDefault(); searchForVehicle(); } }); }

// Add listener for Enter key in Watch Bus Input
const watchBusInput = document.getElementById('watch-bus-input');
if (watchBusInput) { watchBusInput.addEventListener('keyup', function(event) { if (event.key === 'Enter') { event.preventDefault(); addBusToWatchlist(); } }); }


// --- Main Logic Execution ---
if (!dynamicRouteId) {
    // --- NO ROUTE IN URL ---
    document.title = "Select Route - Live Bus Tracker";
    if (routeSelectorDiv) routeSelectorDiv.style.display = 'block';
    if (trackerContentDiv) trackerContentDiv.style.display = 'none';
    console.log("No route ID in URL, showing selector.");
} else {
    // --- ROUTE FOUND IN URL ---
     if (routeSelectorDiv) routeSelectorDiv.style.display = 'none';
     if (trackerContentDiv) trackerContentDiv.style.display = 'block';
     console.log(`Route ID found: ${dynamicRouteId}. Initializing tracker...`);

     // --- Constants specific to tracker page ---
     const apiUrl = `https://api.tfl.gov.uk/Line/${dynamicRouteId}/Arrivals`;
     const curtailedBusesKey = `curtailedBusesArray_${dynamicRouteId}`; // Key for storing curtailments for THIS route

     // --- Update Title and Headings ---
     document.title = `Live Tracker - Route ${dynamicRouteId}`;
     const mainHeading = document.getElementById('main-heading');
     if(mainHeading) mainHeading.textContent = `Live Tracker for Route ${dynamicRouteId}`;
     const busCounterElement = document.getElementById('bus-counter');
     if(busCounterElement) busCounterElement.textContent = `Buses on Route ${dynamicRouteId}: 0`;
     const curtailmentsHeading = document.getElementById('curtailments-heading');
      if(curtailmentsHeading) curtailmentsHeading.textContent = `Curtailments Today for Route ${dynamicRouteId}`;

     // --- TMP Number Generation ---
     function generateTMPNumber(registration) { const seed=12345;const combined=registration+seed.toString();let hash=0;if(combined.length===0)return"TMP0000";for(let i=0;i<combined.length;i++){const t=combined.charCodeAt(i);hash=(hash<<5)-hash+t;hash|=0;} return `TMP${Math.abs(hash%1e4).toString().padStart(4,"0")}`; }
     function isTMPValueUsed(map, tmpValue, currentReg) { for (const reg in map) { if (Object.prototype.hasOwnProperty.call(map, reg) && reg !== currentReg && map[reg] === tmpValue) { return true; } } return false; }
     function getTMPForRegistration(registration) { if (!registration) return 'TMP????'; let tmpMap = loadFromStorage(tmpMapKey, {}); if (typeof tmpMap !== 'object' || tmpMap === null) tmpMap = {}; if (Object.prototype.hasOwnProperty.call(tmpMap, registration)) { return tmpMap[registration]; } let attempt = 0; let uniqueTMP = null; let generatedTMP; const MAX_ATTEMPTS = 100; while (uniqueTMP === null && attempt < MAX_ATTEMPTS) { const inputForHash = attempt === 0 ? registration : `${registration}_${attempt}`; generatedTMP = generateTMPNumber(inputForHash); if (!isTMPValueUsed(tmpMap, generatedTMP, registration)) { uniqueTMP = generatedTMP; } else { console.warn(`TMP collision for ${registration}: ${generatedTMP}. Retrying...`); attempt++; } } if (uniqueTMP === null) { console.error(`Could not generate unique TMP for ${registration}.`); uniqueTMP = `ERR${Math.floor(1000 + Math.random() * 9000)}`; } tmpMap[registration] = uniqueTMP; saveToStorage(tmpMapKey, tmpMap); try { let genInfo = loadFromStorage(tmpGenerationInfoKey, {}); if (typeof genInfo !== 'object' || genInfo === null) genInfo = {}; genInfo[registration] = { route: dynamicRouteId, timestamp: Date.now() }; saveToStorage(tmpGenerationInfoKey, genInfo); } catch(e) { console.error(`Failed to save TMP generation info for ${registration}:`, e); } return uniqueTMP; }

     // --- Destination Override Logic ---
     function getEffectiveDestination(busReg, busDirectionId, originalApiDest) { const reg = String(busReg || '').toUpperCase(); const routeId = dynamicRouteId; const directionId = parseInt(busDirectionId, 10); const overrides = loadFromStorage(destinationOverrideKey, {}); const globalOverride = overrides['*'] || null; if (Object.prototype.hasOwnProperty.call(overrides, reg)) { const o = overrides[reg]; if (typeof o === 'object' && o !== null && o.dir1 !== undefined && o.dir2 !== undefined) { let d=null; if(directionId===1&&o.dir1)d=o.dir1; else if(directionId===2&&o.dir2)d=o.dir2; if(d&&(directionId===1||directionId===2)) return d;} else if (typeof o === 'string' && o.trim() !== '') {return o;} } if (Object.prototype.hasOwnProperty.call(overrides, routeId)) { const o = overrides[routeId]; if (typeof o === 'object' && o !== null && o.dir1 !== undefined && o.dir2 !== undefined) { let d=null; if(directionId===1&&o.dir1)d=o.dir1; else if(directionId===2&&o.dir2)d=o.dir2; if(d&&(directionId===1||directionId===2)) return d;} else if (typeof o === 'string' && o.trim() !== '') {return o;} } if (globalOverride && typeof globalOverride === 'string' && globalOverride.trim() !== '') return globalOverride; return String(originalApiDest || 'N/A'); }

     // --- Curtailment Handling ---
     function populateCurtailmentsTable() { const allCurtailments = loadFromStorage(curtailedBusesKey, []); const curtailedBusesTable = document.getElementById("curtailed-buses-table"); if (!curtailedBusesTable) return; curtailedBusesTable.innerHTML = ""; if (!Array.isArray(allCurtailments)) { curtailedBusesTable.innerHTML = `<tr><td colspan="5">Error loading data.</td></tr>`; return; } const todayStart = new Date(); todayStart.setHours(0, 0, 0, 0); const todayTimestamp = todayStart.getTime(); const todaysCurtailments = allCurtailments.filter(c => c?.route === dynamicRouteId && c.timestamp >= todayTimestamp); const sortedTodaysCurtailments = todaysCurtailments.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); if (sortedTodaysCurtailments.length > 0) { sortedTodaysCurtailments.forEach(bus => { const fleet = getTMPForRegistration(bus.regNumber); let time = 'N/A'; if (bus.timestamp && !isNaN(bus.timestamp)) { try { time = new Date(bus.timestamp).toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'}); } catch(e){} } else if (bus.curtailmentTime) { time = bus.curtailmentTime; } const row = document.createElement("tr"); row.innerHTML = `<td>${escapeHtml(bus.route||'N/A')}</td><td>${escapeHtml(fleet)}</td><td>${escapeHtml(bus.regNumber||'N/A')}</td><td>${escapeHtml(bus.curtailedDestination||'N/A')}</td><td>${escapeHtml(time)}</td>`; curtailedBusesTable.appendChild(row); }); } else { curtailedBusesTable.innerHTML = `<tr><td colspan="5">No curtailments today.</td></tr>`; } }

    // --- Route Sequence Logic (with Naptan ID Caching & Global Name Update) ---
     function updateSequenceHeading(direction, fallbackTerminus) { const hId = `${direction}-sequence-heading`; const hEl = document.getElementById(hId); if (!hEl) return; let name = null; if (manualSequenceHeadings[direction]) { name = manualSequenceHeadings[direction]; } else if (direction === 'outbound' && globalOutboundDestName) { name = globalOutboundDestName; } else if (direction === 'inbound' && globalInboundDestName) { name = globalInboundDestName; } else { name = fallbackTerminus; } hEl.textContent = `Route Sequence (${direction})${name ? ': Towards ' + name : ''}`; }
     function displaySequence(direction, stopsNames, terminusName) { const listId = `${direction}-sequence-list`; const listEl = document.getElementById(listId); updateSequenceHeading(direction, terminusName); if (!listEl) return; if (!Array.isArray(stopsNames) || stopsNames.length === 0) { listEl.innerHTML = `<p>No stops found.</p>`; return; } const ol = document.createElement('ol'); stopsNames.forEach(sName => { const li = document.createElement('li'); li.textContent = sName || '?'; ol.appendChild(li); }); listEl.innerHTML = ''; listEl.appendChild(ol); }
     async function fetchSequenceForDirection(routeId, direction) { const cacheKey = `routeSequenceCache_${direction}_${routeId}`; const listId = `${direction}-sequence-list`; const listEl = document.getElementById(listId); const now = Date.now(); try { const cache = loadFromStorage(cacheKey, null); if (cache?.timestamp && (now - cache.timestamp < ROUTE_SEQUENCE_CACHE_DURATION_MS) && Array.isArray(cache.stops) && cache.terminus?.id) { console.log(`[Seq] Using cache: ${routeId}-${direction}`); displaySequence(direction, cache.stops.map(s=>s.name), cache.terminus.name); return cache; } else if (cache) { console.warn(`[Seq] Cache invalid/expired: ${direction}.`); } } catch (e) { console.error(`[Seq] Cache read error:`, e); } if(listEl) listEl.innerHTML = `<p>Loading ${direction}...</p>`; const apiUrlSeq = `https://api.tfl.gov.uk/Line/${routeId}/Route/Sequence/${direction}`; let stopsInfo = []; try { console.log(`[Seq] Fetching: ${apiUrlSeq}`); const response = await fetch(apiUrlSeq); if (!response.ok) throw new Error(response.status === 404 ? `No data (404)` : `API Error ${response.status}`); const data = await response.json(); if (data.stopPointSequences?.[0]?.stopPoint) { stopsInfo = data.stopPointSequences[0].stopPoint.map(s => ({ name: s.name||'?', id: s.id||null })); } if (!Array.isArray(stopsInfo) || stopsInfo.length === 0) throw new Error("Could not extract stops."); } catch (error) { console.error(`[Seq] Fetch Error ${routeId}-${direction}:`, error); if(listEl) listEl.innerHTML = `<p>Error: ${error.message}</p>`; updateSequenceHeading(direction, null); return null; } if (Array.isArray(stopsInfo) && stopsInfo.length > 0) { const termInfo = stopsInfo[stopsInfo.length - 1]; const dataToCache = { stops: stopsInfo, terminus: termInfo, timestamp: now }; saveToStorage(cacheKey, dataToCache); displaySequence(direction, stopsInfo.map(s => s.name), termInfo.name); return dataToCache; } else { if(listEl) listEl.innerHTML = `<p>Error processing data.</p>`; updateSequenceHeading(direction, null); return null; } }
     async function fetchAndDisplayRouteSequence(routeId) { console.log(`[Seq] Fetching sequences for ${routeId}...`); await Promise.all([fetchSequenceForDirection(routeId, 'outbound'), fetchSequenceForDirection(routeId, 'inbound')]); console.log(`[Seq] Finished sequences for ${routeId}.`); }

    // --- Service Alert Logic (with 15 min Cache) ---
     async function fetchAndDisplayServiceAlerts(routeId) {
         const alertContainer = document.getElementById('service-alerts-container'); const alertContent = document.getElementById('service-alerts-content'); if (!alertContainer || !alertContent) { console.error("[Alerts] Display elements missing."); return; }
         const cacheKey = `serviceAlertCache_${routeId}`; const now = Date.now();
         try { const cached = loadFromStorage(cacheKey, null); if (cached?.timestamp && (now - cached.timestamp < ALERT_CACHE_DURATION_MS)) { console.log(`[Alerts] Using cached status: ${routeId}`); alertContent.textContent = cached.displayText; alertContainer.className = ''; if (cached.severityClass) alertContainer.classList.add(cached.severityClass); return; } else if (cached) { console.log(`[Alerts] Cache expired: ${routeId}`); } } catch(e){}
         alertContent.textContent = 'Loading status...'; alertContainer.className = '';
         const url = `https://api.tfl.gov.uk/Line/${routeId}/Status`; console.log(`[Alerts] Fetching status: ${url}`);
         try { const response = await fetch(url); if (!response.ok) { if(response.status === 404) { alertContent.textContent = `Status N/A`; return; } throw new Error(`API Error ${response.status}`); } const data = await response.json(); if (!Array.isArray(data) || !data[0]?.lineStatuses?.length) { alertContent.textContent = `Status Unknown`; alertContainer.classList.add('alert-minor'); saveToStorage(cacheKey, { displayText:alertContent.textContent, severityClass:'alert-minor', timestamp:now }); return; } const status = data[0].lineStatuses[0]; const severity = status.statusSeverityDescription || '?'; const reason = status.reason || null; let text = `Status: ${severity}`; let sevClass = ''; if (reason) { const div = document.createElement('div'); div.innerHTML = reason; text += ` - ${div.textContent || div.innerText || ""}`.trim(); } const sevLower = severity.toLowerCase(); if (sevLower.includes('good')) sevClass = 'alert-good'; else if (sevLower.includes('minor')) sevClass = 'alert-minor'; else if (sevLower.includes('severe') || sevLower.includes('suspended') || sevLower.includes('closure')) sevClass = 'alert-severe'; else if (sevLower.includes('special')) sevClass = 'alert-special'; alertContent.textContent = text; if (sevClass) alertContainer.classList.add(sevClass); console.log(`[Alerts] Status: ${severity}`); saveToStorage(cacheKey, { displayText: text, severityClass: sevClass, timestamp: now }); }
         catch (error) { console.error(`[Alerts] Error:`, error); alertContent.textContent = `Error loading status: ${error.message}`; alertContainer.classList.add('alert-error'); }
     }

    // --- Countdown Timer Functions ---
     function updateCountdownDisplay() { const timerEl = document.getElementById('next-update-timer'); if (timerEl) { if (countdownValue <= 0) { timerEl.textContent = `Updating now...`; } else { timerEl.textContent = `Next update in: ${countdownValue}s`; } } countdownValue--; if (countdownValue < -5 && timerEl && !timerEl.textContent.startsWith('Updating')) { timerEl.textContent = `Next update in: --s`; } }
     function startCountdown() { console.log("DEBUG: Starting/Resetting countdown."); clearInterval(countdownTimerId); countdownValue = REFRESH_INTERVAL_SECONDS; updateCountdownDisplay(); countdownValue--; countdownTimerId = setInterval(updateCountdownDisplay, 1000); }

    // --- Live Data Fetching and Processing ---
     async function fetchLiveBusData() {
          const trackerTable = document.getElementById("tracker-table"); const busCounter = document.getElementById("bus-counter"); const updateTime = document.getElementById("update-time"); if (!trackerTable || !busCounter || !updateTime ) return;
          try {
              const settings = loadFromStorage(settingsKey, defaultSettings); const debounceMs = (settings.debounceMinutes || 60) * 60 * 1000; const timeoutMs = (settings.timeoutMinutes || 30) * 60 * 1000;
              const allDests = loadFromStorage(routeDestinationSettingsKey, {});
              const finalDests = Array.isArray(allDests[dynamicRouteId]) ? allDests[dynamicRouteId] : []; // Ensure it's an array
              const normalizedFinalDests = finalDests.map(normalizeDestination).filter(d => d); // Normalize ONCE

              const response = await fetch(apiUrl);
              if (!response.ok) { trackerTable.innerHTML = `<tr><td colspan="5">API Error (${response.status}). Invalid route?</td></tr>`; throw new Error(`API ${response.status}`); }
              const arrivals = await response.json(); const now = Date.now();
              let busLastSeen = loadFromStorage(busLastSeenKey, {}); let tmpMap = loadFromStorage(tmpMapKey, {}); let allCurtailments = loadFromStorage(curtailedBusesKey, []); if (!Array.isArray(allCurtailments)) allCurtailments = [];
              const activeBuses = {}; let newCurtDetected = false, busSeenMod = false, outHeadUpd = false, inHeadUpd = false;

              if (arrivals?.length > 0) {
                  arrivals.forEach(bus => {
                      const reg = bus.vehicleId; if (!reg) return;
                      const etaMs = new Date(bus.expectedArrival).getTime();
                      const apiDest = bus.destinationName || "?";
                      const apiDir = bus.direction;
                      const currStop = bus.stationName || "?";
                      let dirId; if (apiDir === 'outbound') dirId = 1; else if (apiDir === 'inbound') dirId = 2;

                      // *** CURTAILMENT CHECK USING NORMALIZATION ***
                      const normalizedApiDest = normalizeDestination(apiDest);
                      const isCurt = normalizedApiDest &&
                                     normalizedFinalDests.length > 0 &&
                                     !normalizedFinalDests.includes(normalizedApiDest);
                      // *** END OF CURTAILMENT CHECK ***

                      // Update global destination names if not curtailed
                      if (apiDest !== "?" && !isCurt) {
                          if (dirId === 1 && globalOutboundDestName !== apiDest) { globalOutboundDestName = apiDest; outHeadUpd = true; }
                          else if (dirId === 2 && globalInboundDestName !== apiDest) { globalInboundDestName = apiDest; inHeadUpd = true; }
                      }

                      // Log curtailment if detected and not recently logged
                      if (isCurt) {
                          const logged = allCurtailments.some(c => c.regNumber === reg && c.curtailedDestination === apiDest && c.timestamp && (now - c.timestamp < debounceMs));
                          if (!logged) {
                              const logD = new Date();
                              const nE = { route: dynamicRouteId, regNumber: reg, curtailedDestination: apiDest, curtailmentTime: logD.toLocaleString('en-GB',{}), timestamp: logD.getTime() };
                              allCurtailments.push(nE);
                              newCurtDetected = true;
                              console.log(`DEBUG: Curtailment detected & logged for ${reg} to ${apiDest} (Normalized: ${normalizedApiDest})`);
                          }
                      }

                      // Update last seen data
                      const lastSeen = busLastSeen[reg] || {}; let needsUpd = false;
                      if(lastSeen.time !== now){lastSeen.time=now; needsUpd=true;}
                      if(lastSeen.destination !== apiDest){lastSeen.destination=apiDest; needsUpd=true;}
                      if(lastSeen.direction !== dirId){lastSeen.direction=dirId; needsUpd=true;}
                      if(currStop!=="?"&&lastSeen.lastStopName !== currStop){lastSeen.lastStopName=currStop; needsUpd=true;}
                      if(needsUpd){busLastSeen[reg]=lastSeen; busSeenMod=true;}

                      // Add/update active bus if ETA is valid and better than existing
                      const existingPred = activeBuses[reg]?.expectedArrivalTimeMs;
                      if(!isNaN(etaMs) && etaMs >= now){
                          if(!existingPred || etaMs < existingPred){
                              const fleet=getTMPForRegistration(reg);
                              const dispDest=getEffectiveDestination(reg,dirId,apiDest);
                              const arrivalTime=new Date(etaMs).toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
                              activeBuses[reg]={fleetNumber:fleet, regNumber:reg, apiDestination:apiDest, displayDestination:dispDest, stopName:currStop, stopArrivalTime:arrivalTime, expectedArrivalTimeMs:etaMs, isGhost:false, vehicleId:bus.vehicleId, // Keep original vehicleId for modal
                                naptanId: bus.naptanId || null // Store Naptan ID for modal
                              };
                          }
                      }
                  });
              }

              // Update sequence headings if needed
              if(outHeadUpd) updateSequenceHeading('outbound', null);
              if(inHeadUpd) updateSequenceHeading('inbound', null);

              // Save updated last seen data
              if(busSeenMod) saveToStorage(busLastSeenKey, busSeenMod);

              // Add ghost buses
              const displayBuses = Object.values(activeBuses);
              for (const reg in busLastSeen) {
                  if (!activeBuses[reg]) {
                      const d = busLastSeen[reg]; const t = d?.time||0;
                      if(now-t < timeoutMs){
                          const dest=d?.destination||'?'; const dir=d?.direction; const stop=d?.lastStopName||'?';
                          const timeStr=new Date(t).toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
                          const ghost={fleetNumber:getTMPForRegistration(reg),regNumber:reg,apiDestination:dest,displayDestination:getEffectiveDestination(reg,dir,dest),stopName:stop,stopArrivalTime:`(Seen ${timeStr})`,expectedArrivalTimeMs:0,isGhost:true, vehicleId: reg, naptanId: null}; // Use reg as vehicleId for ghosts
                          displayBuses.push(ghost);
                      }
                  }
              }

              // Save curtailments if new ones were detected
              if(newCurtDetected){saveToStorage(curtailedBusesKey,allCurtailments); populateCurtailmentsTable();}

              // Clean up old ghost/TMP data
              tmpMap=loadFromStorage(tmpMapKey,{}); let updTmp=false, seenModCleanup=false; let currentSeen=loadFromStorage(busLastSeenKey,{});
              for(const r in currentSeen){if(now-(currentSeen[r]?.time||0)>timeoutMs){delete currentSeen[r]; seenModCleanup=true; if(tmpMap[r]?.startsWith('TMP')||tmpMap[r]?.startsWith('ERR')){delete tmpMap[r]; updTmp=true; try{let g=loadFromStorage(tmpGenerationInfoKey,{}); if(g[r]){delete g[r]; saveToStorage(tmpGenerationInfoKey,g);}}catch(e){}}}}
              if(seenModCleanup) saveToStorage(busLastSeenKey,currentSeen);
              if(updTmp) saveToStorage(tmpMapKey,tmpMap);

              // Sort and store final list for filtering
              const sortedBuses = displayBuses.sort((a,b)=>(a.fleetNumber||'').localeCompare(b.fleetNumber||'',undefined,{numeric:true}));
              currentRouteBuses=sortedBuses; // Store globally for filters

              // Populate filter options based on the *full* sorted list
              const opts={fleet:new Set(),reg:new Set(),destination:new Set(),stop:new Set(),arrival:new Set()};
              const fF=document.getElementById("filter-fleet"),fR=document.getElementById("filter-reg"),fD=document.getElementById("filter-destination"),fS=document.getElementById("filter-stop"),fA=document.getElementById("filter-arrival");
              sortedBuses.forEach(b=>{opts.fleet.add(b.fleetNumber); opts.reg.add(b.regNumber); opts.destination.add(b.displayDestination); opts.stop.add(b.stopName); opts.arrival.add(b.stopArrivalTime);});
              const filters=[fF,fR,fD,fS,fA];
              const curFilt={fleet:fF?.value||"",reg:fR?.value||"",destination:fD?.value||"",stop:fS?.value||"",arrival:fA?.value||""}; // Save current filter values
              filters.forEach(f=>{if(f)while(f.options.length>1)f.remove(1);}); // Clear old options
              [...opts.fleet].sort((a,b)=>(a||'').localeCompare(b||'',undefined,{numeric:true})).forEach(v=>fF?.add(new Option(v,v)));
              [...opts.reg].sort().forEach(v=>fR?.add(new Option(v,v)));
              [...opts.destination].sort().forEach(v=>fD?.add(new Option(v,v)));
              [...opts.stop].sort().forEach(v=>fS?.add(new Option(v,v)));
              [...opts.arrival].sort().forEach(v=>fA?.add(new Option(v,v)));
              const restVal=(el,v)=>{if(el&&v&&[...el.options].some(o=>o.value===v))el.value=v; else if(el)el.value="";}; // Restore filter values
              restVal(fF,curFilt.fleet); restVal(fR,curFilt.reg); restVal(fD,curFilt.destination); restVal(fS,curFilt.stop); restVal(fA,curFilt.arrival);

              // Populate table body (done by filterArrivalsTable now)
              // trackerTable.innerHTML = ""; // Clear table body
              // if (sortedBuses.length === 0) { trackerTable.innerHTML = `<tr><td colspan="5">No buses tracking on Route ${dynamicRouteId}.</td></tr>`; }
              // else { sortedBuses.forEach(bus => { /* ... create and append row ... */ }); }

              // Update counts and time
              const busCountEl = document.getElementById('bus-counter');
              if(busCountEl) busCountEl.textContent = `Buses: ${sortedBuses.length}`; // Update total count before filtering
              if(updateTime) updateTime.textContent = `Last Updated: ${new Date().toLocaleTimeString()}`;

              filterArrivalsTable(); // Apply filters and render visible rows
              updateWatchedBusHighlighting(); // Re-apply highlighting after table rebuild

              startCountdown(); // <<< Reset countdown AFTER update

          } catch (error) { console.error(`Error fetch/process:`, error); if (trackerTable && !trackerTable.innerHTML.includes("Error")) { trackerTable.innerHTML = `<tr><td colspan="5">Error updating. Check console.</td></tr>`; } startCountdown(); /* Reset countdown even on error */ }
     } // --- End fetchLiveBusData ---

     // --- Filter Application Logic ---
     const filterFleet = document.getElementById("filter-fleet"); const filterReg = document.getElementById("filter-reg"); const filterDestination = document.getElementById("filter-destination"); const filterStop = document.getElementById("filter-stop"); const filterArrival = document.getElementById("filter-arrival"); const arrivalsTableBody = document.getElementById("tracker-table");
     function saveFilterState() { const state = { fleet: filterFleet?.value || "", reg: filterReg?.value || "", destination: filterDestination?.value || "", stop: filterStop?.value || "", arrival: filterArrival?.value || "" }; saveToStorage(filterStateKey, state); }
     function filterArrivalsTable() {
         if (!arrivalsTableBody || !filterFleet || !filterReg || !filterDestination || !filterStop || !filterArrival) return;
         const filters = { fleet: filterFleet.value, reg: filterReg.value, destination: filterDestination.value, stop: filterStop.value, arrival: filterArrival.value };
         let visibleCount = 0;
         arrivalsTableBody.innerHTML = ""; // Clear previous rows before adding filtered ones

         const filteredBuses = currentRouteBuses.filter(bus => {
             const match = (!filters.fleet || bus.fleetNumber === filters.fleet) &&
                           (!filters.reg || bus.regNumber === filters.reg) &&
                           (!filters.destination || bus.displayDestination === filters.destination) &&
                           (!filters.stop || bus.stopName === filters.stop) &&
                           (!filters.arrival || bus.stopArrivalTime === filters.arrival);
             return match;
         });

         if (filteredBuses.length === 0) {
             arrivalsTableBody.innerHTML = `<tr><td colspan="5">No buses match the current filter criteria.</td></tr>`;
         } else {
             filteredBuses.forEach(bus => {
                 const row = document.createElement("tr");
                 row.dataset.vehicleId = bus.vehicleId; // Store vehicleId for modal click
                 row.dataset.naptanId = bus.naptanId || ''; // Store naptanId
                 if(bus.isGhost) row.classList.add('ghost-bus');
                 // Add click listener for modal
                 row.addEventListener('click', () => displayVehiclePredictions(bus.vehicleId, `${bus.fleetNumber} (${bus.regNumber})`));
                 row.style.cursor = 'pointer'; // Indicate clickable row

                 row.innerHTML = `<td>${escapeHtml(bus.fleetNumber)}</td><td>${escapeHtml(bus.regNumber)}</td><td>${escapeHtml(bus.displayDestination)}</td><td>${escapeHtml(bus.stopName)}</td><td>${escapeHtml(bus.stopArrivalTime)}</td>`;
                 arrivalsTableBody.appendChild(row);
                 visibleCount++;
             });
         }
         // Update counter to show filtered count / total count? Or just filtered? Let's keep total for now.
         // const busCountEl = document.getElementById('bus-counter');
         // if(busCountEl) busCountEl.textContent = `Buses: ${visibleCount} / ${currentRouteBuses.length}`;
     }

     // --- Attach Filter Event Listeners ---
     if (filterFleet) filterFleet.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); updateWatchedBusHighlighting(); });
     if (filterReg) filterReg.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); updateWatchedBusHighlighting(); });
     if (filterDestination) filterDestination.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); updateWatchedBusHighlighting(); });
     if (filterStop) filterStop.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); updateWatchedBusHighlighting(); });
     if (filterArrival) filterArrival.addEventListener("change", () => { saveFilterState(); filterArrivalsTable(); updateWatchedBusHighlighting(); });

    // --- Watchlist Functions ---
     function loadWatchedBuses() { watchedBuses = new Set(loadFromStorage(watchedBusesStorageKey, [])); displayWatchedBuses(); }
     function saveWatchedBuses() { saveToStorage(watchedBusesStorageKey, [...watchedBuses]); }
     function addBusToWatchlist() { const input = document.getElementById('watch-bus-input'); if (!input) return; const busId = input.value.trim().toUpperCase(); if (busId) { watchedBuses.add(busId); saveWatchedBuses(); displayWatchedBuses(); updateWatchedBusHighlighting(); input.value = ''; } }
     function removeBusFromWatchlist(busId) { watchedBuses.delete(busId); saveWatchedBuses(); displayWatchedBuses(); updateWatchedBusHighlighting(); }
     function displayWatchedBuses() { const displayDiv = document.getElementById('watched-buses-display'); if (!displayDiv) return; displayDiv.innerHTML = ''; if (watchedBuses.size > 0) { displayDiv.innerHTML = '<strong>Watching:</strong> '; [...watchedBuses].sort().forEach(busId => { const span = document.createElement('span'); span.textContent = busId; const removeBtn = document.createElement('button'); removeBtn.textContent = '×'; removeBtn.title = `Stop watching ${busId}`; removeBtn.onclick = () => removeBusFromWatchlist(busId); span.appendChild(removeBtn); displayDiv.appendChild(span); }); } }
     function updateWatchedBusHighlighting() { const rows = arrivalsTableBody.querySelectorAll("tr"); rows.forEach(row => { if (row.cells.length >= 2) { const fleet = row.cells[0].textContent; const reg = row.cells[1].textContent; const isWatched = watchedBuses.has(fleet) || watchedBuses.has(reg); row.classList.toggle('watched-bus', isWatched); } }); }

    // --- Vehicle Search & Prediction Modal Functions ---
     function searchForVehicle() { const sIn=document.getElementById('vehicle-search-input'); const rDiv=document.getElementById('vehicle-search-results'); if(!sIn||!rDiv)return; const sTermIn=sIn.value.trim(); const sTerm=sTermIn.toUpperCase(); rDiv.textContent=''; if(!sTerm){rDiv.textContent='Enter Reg/Fleet No.';return;} rDiv.textContent=`Looking up ${sTermIn}...`; const map=loadFromStorage(tmpMapKey,{}); let tReg=null, dTerm=sTermIn, foundF=false; for(const r in map){if(Object.prototype.hasOwnProperty.call(map,r)){const f=String(map[r]||''); if(f.toUpperCase()===sTerm){tReg=r; dTerm=`${f} (${r})`; foundF=true; break;}}} if(!foundF){const isReg = sTerm.length>=5&&/[A-Z]/.test(sTerm)&&/[0-9]/.test(sTerm); if(isReg){tReg=sTerm; const fN=map[tReg]; if(fN)dTerm=`${tReg} (${fN})`; else dTerm=tReg;}else{rDiv.textContent=`Cannot find "${sTermIn}".`; return;}} if(tReg){rDiv.textContent=`Working...`; displayVehiclePredictions(tReg,dTerm);}else{rDiv.textContent=`Cannot ID reg for "${sTermIn}".`;} }
     async function displayVehiclePredictions(registration, displayIdentifier) { const modal = document.getElementById('vehicle-prediction-modal'); const title = document.getElementById('vehicle-prediction-title'); const listDiv = document.getElementById('vehicle-prediction-list'); const resultsStatusDiv = document.getElementById('vehicle-search-results'); if (!modal || !title || !listDiv || !resultsStatusDiv) { if(resultsStatusDiv) resultsStatusDiv.textContent = "UI Error."; return; } title.textContent = `Predictions for ${displayIdentifier}`; listDiv.innerHTML = '<p>Fetching...</p>'; modal.classList.remove('hidden'); resultsStatusDiv.textContent = ''; let termId = null, termCheckName = null, returnDestName = '?', currDir = null, routeId = dynamicRouteId, isCurt = false, currDest = '?'; try { const url = `https://api.tfl.gov.uk/Vehicle/${registration}/Arrivals`; const response = await fetch(url); if (!response.ok) throw new Error(response.status === 404 ? `Vehicle ${registration} not found.` : `API Error ${response.status}`); const predictions = await response.json(); if (!Array.isArray(predictions) || predictions.length === 0) { listDiv.innerHTML = `<p>No predictions found.</p>`; return; } predictions.sort((a, b) => new Date(a.expectedArrival) - new Date(b.expectedArrival)); const firstPred = predictions[0]; currDir = firstPred.direction; currDest = firstPred.destinationName || '?'; const allDest = loadFromStorage(routeDestinationSettingsKey, {}); const finalDests = Array.isArray(allDest[routeId]) ? allDest[routeId] : []; const normalizedFinalDests = finalDests.map(normalizeDestination).filter(d => d); const normalizedApiDest = normalizeDestination(currDest); isCurt = normalizedApiDest && normalizedFinalDests.length > 0 && !normalizedFinalDests.includes(normalizedApiDest); console.log(`[Modal] Dest: "${currDest}". Dir: ${currDir}. Curtailed: ${isCurt}`); if(isCurt){ termCheckName = currDest; console.log(`[Modal] Curtailed. Turnaround check: Name = "${termCheckName}"`); } else if(currDir && routeId) { const key = `routeSequenceCache_${currDir}_${routeId}`; try { const cache = loadFromStorage(key, null); if (cache?.terminus?.id) { termId = cache.terminus.id; termCheckName = cache.terminus.name; console.log(`[Modal] Official. Turnaround check: ID=${termId} / Name=${termCheckName}`); } else { console.warn(`[Modal] No cached terminus ID/Name for ${currDir}`); } } catch(e){} } if (currDir) { const oppDir = (currDir === 'outbound') ? 'inbound' : 'outbound'; returnDestName = (oppDir === 'outbound' ? globalOutboundDestName : globalInboundDestName) || '?'; console.log(`[Modal] Return Dest Name (from global): "${returnDestName}"`); } let tbl1HTML = '', tbl2HTML = '', termReached = false; tbl1HTML += `<p style="text-align:center; font-weight:bold; margin-bottom:10px;">On route ${escapeHtml(firstPred.lineName||routeId)} to ${escapeHtml(currDest)} ${isCurt?'<span style="color:orange;">(Curtailed)</span>':''}</p>`; tbl1HTML += `<table style="width: 100%; border-collapse: collapse; margin-bottom: 15px;"><thead><tr style="background-color: #f2f2f2;"><th>Due</th><th>Stop Id</th><th>Stop Name</th></tr></thead><tbody>`; predictions.forEach(p => { const eta = new Date(p.expectedArrival).toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'}); const sId = p.naptanId || '---'; const sName = p.stationName || '?'; let isTurn = false; if (!termReached) { if(isCurt && termCheckName) { if(normalizeDestination(sName) === normalizeDestination(termCheckName)) isTurn=true; } else if (!isCurt && termId) { if(sId === termId) isTurn=true; else if (termCheckName && normalizeDestination(sName) === normalizeDestination(termCheckName)) isTurn=true; } } const rowHTML = `<tr><td style="text-align:center;">${escapeHtml(eta)}</td><td style="text-align:center;">${escapeHtml(sId)}</td><td>${escapeHtml(sName)}</td></tr>`; if(!termReached) { tbl1HTML += rowHTML; } else { if(!tbl2HTML) { tbl2HTML += `<p style="text-align:center; font-weight:bold; margin-bottom:10px; border-top:1px solid #ccc; padding-top:15px;">Returning on Route ${escapeHtml(routeId)} to ${escapeHtml(returnDestName)}</p><table style="width:100%; border-collapse:collapse;"><thead><tr style="background-color:#f2f2f2;"><th>Due</th><th>Stop Id</th><th>Stop Name</th></tr></thead><tbody>`; } tbl2HTML += rowHTML; } if(isTurn) termReached = true; }); tbl1HTML += `</tbody></table>`; if(tbl2HTML) tbl2HTML += `</tbody></table>`; listDiv.innerHTML = tbl1HTML + tbl2HTML; } catch (error) { console.error("Prediction Error:", error); title.textContent=`Error for ${displayIdentifier}`; listDiv.innerHTML=`<p style="color:red;">Error: ${error.message}</p>`; } }
     function hideVehiclePredictionModal() { const modal = document.getElementById('vehicle-prediction-modal'); if (modal) { modal.classList.add('hidden'); } }

    // --- Initial Load Logic ---
     async function initialize() {
          console.log(`Initializing full tracker for route: ${dynamicRouteId}`);
          globalOutboundDestName = null; globalInboundDestName = null; // Reset globals
          loadWatchedBuses(); // Load watchlist
          populateCurtailmentsTable();
          manualSequenceHeadings = loadFromStorage(sequenceHeadingOverrideKey, {});
          console.log('[Sequence Heading] Loaded manual overrides on init:', manualSequenceHeadings);
          // Fetch sequence and alerts concurrently
          await Promise.all([
              fetchAndDisplayRouteSequence(dynamicRouteId),
              fetchAndDisplayServiceAlerts(dynamicRouteId)
          ]);
          // Restore filters (if needed - currently filters reset on load)
          // const initialFilterState = loadFromStorage(filterStateKey, {});
          // const fF=document.getElementById("filter-fleet"),fR=document.getElementById("filter-reg"),fD=document.getElementById("filter-destination"),fS=document.getElementById("filter-stop"),fA=document.getElementById("filter-arrival");
          // if (initialFilterState && typeof initialFilterState === 'object') { if(fF)fF.value=initialFilterState.fleet||""; if(fR)fR.value=initialFilterState.reg||""; if(fD)fD.value=initialFilterState.destination||""; if(fS)fS.value=initialFilterState.stop||""; if(fA)fA.value=initialFilterState.arrival||""; }

          // Initial data fetch and start interval
          await fetchLiveBusData(); // Also starts countdown first time via call at end
          setInterval(fetchLiveBusData, REFRESH_INTERVAL_SECONDS * 1000); // Set interval for subsequent fetches
     }

     // --- Run Initialization ---
      if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initialize);
      } else {
          initialize(); // Already loaded
      }

 } // End of the main 'else' block (if dynamicRouteId was valid)

console.log('--- DEBUG: SCRIPT END REACHED (tracker.html - Destination Normalization) ---');
// --- End of JavaScript ---
    </script>

</body>
</html>
