<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMSI Tools</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <link rel="manifest" href="/live-tracker/manifest-omsitools.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OMSI Tools">
    <meta name="theme-color" content="#2c3e50">
    <link rel="apple-touch-icon" href="/live-tracker/assets/icons/apple-touch-icon-180x180.png">

    <style>
        @font-face {
            font-family: 'NJFont Medium Web';
            src: url('fonts/NJFont-Medium.ttf') format('truetype'); /* Relative path */
            font-weight: normal;font-style: normal;font-display: swap;
        }
        body {
            font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            margin:0;
        }
        .page-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        #top-menu-bar {
            background-color: rgba(0,0,0,0.25);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center;
            display: none; /* Hidden by default, shown after login */
        }
        .menu-button {
            cursor: pointer;
            background-color: #3498db;
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 0.25rem;
            font-size: 0.9rem;
            transition: background-color 0.2s;
            border: none;
            margin: 0.25rem;
        }
        .menu-button:hover {
            background-color: #2980b9;
        }

        button.menu-button[data-section="deployment-tools-section"] {
            background-color: #27ae60;
        }

        button.menu-button[data-section="deployment-tools-section"]:hover {
            background-color: #229954;
        }

        .tool-content-section {
            display: none; /* All tool sections hidden by default */
        }

        #auth-section {
             margin-bottom: 1.5rem;
        }
        #current-profile-display-container {
            text-align: center;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background-color: rgba(255,255,255,0.05);
            border-radius: 0.25rem;
            display: none; /* Hidden by default, shown after login */
        }
        #current-profile-display { font-size: 0.9rem; opacity: 1; font-style: normal; color: #FFFFFF;}

        #auth-section.auth-section-compact {
            padding: 0.75rem;
            background-color: rgba(255,255,255,0.05);
            border-radius: 0.25rem;
            text-align: center;
        }

        #logout-container p {
            font-size: 0.9rem;
            color: #FFFFFF;
            margin: 0 0 0.5rem 0;
        }


        h1 { font-size: 2rem; margin-bottom: 1.5rem; font-weight: normal; text-align: center; color: #ffffff; }
        h2 { font-size: 1.5rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: normal; border-bottom: 1px solid #7f8c8d; padding-bottom: 0.25rem;}
        h3.subsection-title { font-size: 1.25rem; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: normal; color: #e0e0e0; border-bottom: 1px solid rgba(127,140,141,0.5); padding-bottom: 0.2rem;}


        .section {
            background-color: rgba(0,0,0,0.15);
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .subsection {
            background-color: rgba(0,0,0,0.1);
            padding: 1rem;
            border-radius: 0.375rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
             border: 1px solid rgba(127,140,141,0.2);
        }


        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;}
        .form-field-group { margin-bottom: 1rem; }


        label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.85rem;
            color: #bdc3c7;
        }

        input[type="text"],
        input[type="email"],
        input[type="password"],
        input[type="time"],
        input[type="color"],
        input[type="number"],
        select,
        textarea {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size:0.9rem;
            box-sizing: border-box;
        }
        input[type="color"] { height: 2.75rem; padding: 0.25rem; }
        select option { background-color: #34495e; color: #ecf0f1; }


        #inputStopID,
        #bulkEditTargetStopID, #bulkEditTargetLineName,
        #findStopIdScheduleInput, #replaceStopIdScheduleInput,
        #inputNewStopId_ARS { /* Note: gen_stopId was removed as it's part of schedule generator */
            text-transform: uppercase;
        }
        /* Note: gen_lineName, gen_destinationName were removed */
        #consolidateNewProfileInput {
            text-transform: none;
        }


        .button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin-right: 0.5rem; margin-top:0.5rem;
            display: inline-block;
            text-align: center;
            vertical-align: middle;
        }
        .button:hover { background-color: #2980b9; }
        .button.small-action { padding: 0.2rem 0.4rem; font-size: 0.8rem; margin: 0 0.15rem; line-height: 1; min-width: 20px; text-align:center;}
        .button.secondary { background-color: #e74c3c; }
        .button.secondary:hover { background-color: #c0392b; }
        .button.tertiary { background-color: #f39c12; }
        .button.tertiary:hover { background-color: #e67e22; }
        .button.neutral { background-color: #7f8c8d; }
        .button.neutral:hover { background-color: #95a5a6; color: #2c3e50; }


        .file-upload-label { display: inline-block; cursor: pointer; background-color: #95a5a6; color: #2c3e50; padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem; transition: background-color 0.2s; margin-bottom: 0.5rem; }
        .file-upload-label:hover { background-color: #7f8c8d; }
        #file-status { font-size: 0.9rem; margin-top: 0.25rem; margin-bottom:1rem; opacity: 0.9; min-height: 1.2em; }

        .actions-section { margin-top: 1.5rem; }
        #stageScheduleButton { background-color: #27ae60; }
        #stagingStatusMessage { text-align:center; margin-bottom: 1rem; font-size: 0.9em; color: #f1c40f; min-height:1.2em; }


        .info-section { margin-top:2rem; padding:1rem; background-color: rgba(0,0,0,0.1); border-radius:0.25rem; font-size:0.8rem; }
        .info-section h3 { font-size:1rem; margin-bottom:0.5rem; color: #ffffff; }
        .info-section p { line-height:1.6; color:#bdc3c7; }

        .tooltip { position: relative; display: inline-block; cursor: help; margin-left: 4px; font-size:0.8em; background-color:#7f8c8d; color:white; border-radius:50%; width:14px; height:14px; text-align:center; line-height:14px;}
        .tooltip .tooltiptext {
            visibility: hidden; width: 280px; background-color: #34495e; color: #fff;
            text-align: left; border-radius: 6px; padding: 8px; position: absolute;
            z-index: 10; bottom: 135%; left: 50%; margin-left: -140px; opacity: 0; transition: opacity 0.3s;
            font-size: 0.75rem; line-height: 1.4; border: 1px solid #7f8c8d;
        }
        .tooltip .tooltiptext::after {
            content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px;
            border-width: 5px; border-style: solid; border-color: #34495e transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .filter-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; margin-bottom: 1rem; align-items: end;}

        .current-details-display {
            margin-top: 0.5rem;
            font-size: 0.85em;
            background-color: rgba(0,0,0,0.2);
            padding: 0.5rem;
            border-radius: 0.25rem;
            color: #bdc3c7;
        }
        .current-details-display p { margin: 0.2rem 0; }
        .current-details-display span { font-style: italic; color: #ecf0f1; }

        .event-section div, .stop-status-section div,
        .route-colour-management-subsection div,
        .stop-specific-route-colour-subsection div,
        .view-stop-departures div, .analytics-subsection div {
            margin-bottom: 0.75rem;
        }
        .event-section label, .stop-status-section label,
        .route-colour-management-subsection label,
        .stop-specific-route-colour-subsection label,
        .view-stop-departures label, .analytics-subsection label {
             margin-bottom: 0.25rem;
        }


        #currentRouteColoursListContainer,
        #currentStopSpecificColoursListContainer,
        #duplicateEntriesResults {
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            padding: 0.75rem;
            margin-top: 1rem;
            max-height: 300px;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.05);
        }
        #currentRouteColoursList li,
        #currentStopSpecificColoursList ul,
        #currentStopSpecificColoursList li,
        #duplicateEntriesResults li {
            display: block;
            padding: 0.5rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #currentRouteColoursList li:last-child,
        #currentStopSpecificColoursList li:last-child,
        #duplicateEntriesResults li:last-child { border-bottom: none; }

        #currentStopSpecificColoursList .stop-group-title {
            font-weight: bold;
            margin-top: 0.5rem;
            padding-bottom: 0.2rem;
            border-bottom: 1px dashed #566573;
        }
        #currentStopSpecificColoursList .stop-group-title:first-child {
            margin-top: 0;
        }
        #currentStopSpecificColoursList ul {
            list-style-type: none;
            padding-left: 1rem;
            margin:0;
        }


        #duplicateEntriesResults .duplicate-set { margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 1px dashed #4A5568;}
        #duplicateEntriesResults .duplicate-set:last-child { border-bottom: none; }
        #duplicateEntriesResults .entry-detail { display: block; font-size: 0.85rem; margin-left: 1rem; opacity: 0.9;}


        .colour-preview-box {
            width: 20px;
            height: 20px;
            border: 1px solid #ecf0f1;
            margin-right: 10px;
            display: inline-block;
            vertical-align: middle;
        }
        #currentRouteColoursList .route-info,
        #currentStopSpecificColoursList .route-info {
            flex-grow: 1;
            display: inline-flex;
            align-items: center;
        }


        .route-tile-tools-list {
            display: inline-block;
            padding: 0.2em 0.55em;
            margin-right: 0.3em;
            margin-bottom: 0.3em;
            border-radius: 0.25rem;
            font-size: 0.8em;
            font-weight: bold;
            color: white;
            text-align: center;
            line-height: 1.3;
            min-width: 28px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.25);
            vertical-align: middle;
        }
        #stopDeparturesList li {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.1rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #stopDeparturesList li:last-child {
            border-bottom: none;
        }

        /* Enhanced Master Stop List Styles START */
        #masterStopListUL_SM li {
            padding: 0.75rem 0.5rem;
            border-bottom: 1px solid #34495e;
            transition: background-color 0.15s ease-in-out;
        }
        #masterStopListUL_SM li:last-child {
            border-bottom: none;
        }
        #masterStopListUL_SM li .stop-id-master {
            font-weight: normal;
            color: #bdc3c7;
            font-size: 0.95em;
        }
        #masterStopListUL_SM li .stop-name-master {
            font-weight: bold;
            color: #ecf0f1;
            font-size: 1.05em;
        }
        #masterStopListUL_SM li .stop-direction-master {
            font-style: italic;
            font-size: 0.85em;
            color: #95a5a6;
            margin-bottom: 0.3rem;
        }

        #masterStopListUL_SM li .stop-details-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 0.2rem 0.5rem;
            font-size: 0.85em;
            margin-top: 0.4rem;
        }
        #masterStopListUL_SM li .detail-label {
            font-weight: normal;
            color: #bdc3c7;
            opacity: 0.8;
        }
        #masterStopListUL_SM li .detail-value {
            color: #ecf0f1;
        }
        #masterStopListUL_SM li .detail-value.status-closed {
            color: #e74c3c;
            font-weight: bold;
        }
        #masterStopListUL_SM li .detail-value.status-open {
            color: #2ecc71;
        }

        #masterStopListUL_SM li .serving-routes-container {
            margin-top: 0.4rem;
            margin-bottom: 0.2rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3em;
            padding: 0.25rem 0;
        }
        #masterStopListUL_SM li .service-times-info {
            font-size: 0.8em;
            opacity: 0.9;
            margin-top: 0.3rem;
            padding: 0.25rem;
            background-color: rgba(0,0,0,0.1);
            border-radius: 0.2rem;
        }
        #masterStopListUL_SM li .stop-actions {
            margin-top: 0.75rem;
            padding-top: 0.5rem;
            border-top: 1px dashed rgba(127,140,141,0.3);
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        /* Enhanced Master Stop List Styles END */


        #routesServingStopListContainer_SM {
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.05);
            padding:0.75rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
        }
        #routesServingStopList_SM {
            list-style: none;
            padding: 0;
            margin:0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5em;
        }
        #routesServingStopList_SM li {
            padding: 0;
            border-bottom: none;
        }

        .schedule-generator-select { /* Used by various tools, not just generator now */
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        .schedule-generator-select option {
            background-color: #34495e;
            color: #ecf0f1;
        }

        #newStopIdAvailability_ARS {
            font-size: 0.8em;
            min-height: 1.1em;
            margin-top: 0.25rem;
        }

        #specificRouteColourTilesContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5em;
            padding: 0.75rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            background-color: rgba(0,0,0,0.05);
            min-height: 40px;
            margin-bottom: 1rem;
        }
        .specific-colour-route-tile {
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out, outline 0.1s ease-in-out;
            border: 1px solid transparent;
            cursor: pointer;
        }
        .specific-colour-route-tile:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .specific-colour-route-tile.selected-for-color-edit {
            outline: 2px solid #f39c12;
            box-shadow: 0 0 0 2px #f39c12, 0 2px 5px rgba(0,0,0,0.4);
        }
        #specificRouteColourTilesPlaceholder {
             width: 100%;
            text-align: center;
            opacity: 0.7;
            padding: 0.5rem;
        }

        /* Styles for Operating Profiles Viewer (including 3-column layout for reference list) */
        #uniqueOperatingProfilesListContainer,
        #referenceOperatingProfilesListContainer { /* Shared styles for both list containers */
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            padding: 0.75rem;
            margin-top: 1rem;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.05);
        }

        #uniqueOperatingProfilesUL { /* Discovered profiles - standard list */
            list-style: disc;
            padding-left: 20px;
        }
        #uniqueOperatingProfilesUL li {
            padding-bottom: 0.2em; /* Spacing for single column list */
        }

        /* NEW: Styles for 3-column reference list */
        #referenceOperatingProfilesUL {
            list-style: disc;
            padding-left: 20px;
            margin: 0;
            column-count: 3;
            column-gap: 25px;
            -webkit-column-count: 3;
            -moz-column-count: 3;
        }
        #referenceOperatingProfilesUL li {
            padding-bottom: 0.3em;
            break-inside: avoid-column;
            page-break-inside: avoid;
            -webkit-column-break-inside: avoid;
        }
        /* END: Styles for Operating Profiles Viewer */


        /* For screen-reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    </style>
</head>
<body>
    <div class="page-container">
        <h1>OMSI Tools</h1>

        <div id="auth-section" class="section">
            <h2>Admin Login</h2>
            <div id="login-form-container">
                <form id="adminLoginForm">
                    <div class="form-grid" style="grid-template-columns: 1fr;">
                        <div><label for="inputEmail">Email</label><input type="email" id="inputEmail" autocomplete="email"></div>
                        <div><label for="inputPassword">Password</label><input type="password" id="inputPassword" autocomplete="current-password"></div>
                    </div>
                    <button id="loginButton" type="submit" class="button">Login</button>
                </form>
                <p id="auth-status" style="margin-top: 0.5em; color: #f1c40f;"></p>
            </div>
            <div id="logout-container">
                <span id="loggedInUserEmail" class="logged-in-username"></span>
                <button id="logoutButton" class="button secondary small-action">Logout</button>
            </div>
        </div>

        <div id="current-profile-display-container" class="section"> <p id="current-profile-display">Today's Operating Profile: (loading...)</p>
        </div>

        <div id="top-menu-bar">
            <div id="main-menu-buttons">
                <button class="menu-button" data-section="bulk-edit-tools-section">Bulk Edit & Colours</button>
                <button class="menu-button" data-section="view-departures-section">View Departures</button>
                <button class="menu-button" data-section="operating-profiles-section">View Operating Profiles</button>
                <button class="menu-button" data-section="analytics-validation-section">Analytics & Validation</button>
                <button class="menu-button" data-section="deployment-tools-section">Deployment & Upload</button>
            </div>
        </div>

        <div id="tool-sections-wrapper">

            <div id="operating-profiles-section" class="tool-content-section section">
                <h2>Unique Operating Profiles Viewer</h2>
                <p style="opacity:0.8; margin-bottom:1.5rem; font-size:0.9em;">
                    This tool lists all unique "OperatingProfile" strings currently found in your working schedule.
                    Below that is a reference list of all conventionally defined profile strings.
                </p>

                <div class="subsection">
                    <h3 class="subsection-title">Discovered Operating Profiles (from current data)</h3>
                    <button id="refreshOperatingProfilesButton" class="button" style="margin-bottom: 1rem;">Refresh Lists</button>
                    <p id="operatingProfilesStatusMessage" style="min-height:1.2em; margin-bottom: 0.75rem; font-style: italic;"></p>
                    <div id="uniqueOperatingProfilesListContainer"> <ul id="uniqueOperatingProfilesUL">
                        </ul>
                    </div>
                </div>

                <div class="subsection" style="margin-top: 2rem;">
                    <h3 class="subsection-title">Reference List of All Profile Strings</h3>
                    <div id="referenceOperatingProfilesListContainer"> <ul id="referenceOperatingProfilesUL">
                        </ul>
                    </div>
                </div>
            </div>

            <div id="bulk-edit-tools-section" class="tool-content-section section"> <h2 style="margin-bottom:1rem;">Bulk Edit Tools & Colour Management</h2> <div class="subsection bulk-edit-route-destination"> <h3 class="subsection-title">Update Destination for a Route</h3>
                    <div class="form-grid" style="grid-template-columns: 1fr 1.5fr 1.5fr auto; align-items:end; gap: 0.75rem;">
                        <div><label for="bulkEditTargetLineName">Target Line</label><input type="text" id="bulkEditTargetLineName" placeholder="e.g., 186" autocomplete="off"></div>
                        <div><label for="bulkEditOldDestination">Old Destination (optional)</label><input type="text" id="bulkEditOldDestination" placeholder="Blank to update all" autocomplete="off"></div>
                        <div><label for="bulkEditNewDestination">New Destination</label><input type="text" id="bulkEditNewDestination" placeholder="New destination" autocomplete="off"></div>
                        <div style="padding-bottom:0.05rem;"><button id="bulkUpdateRouteDestinationButton" class="button">Update Destination</button></div>
                    </div>
                </div>

                <div class="subsection route-colour-management-subsection">
                    <h3 class="subsection-title">Global Route Tile Colour Management</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">Define global custom colours for routes. These apply unless a stop-specific colour is set.</p>
                    <div class="flex flex-wrap items-end gap-x-3 gap-y-3 mb-4">
                        <div class="w-full sm:w-auto sm:min-w-[150px] md:flex-grow lg:flex-grow-0 lg:w-auto">
                            <label for="selectRouteNameColour">Route Name</label>
                            <select id="selectRouteNameColour" class="w-full"> <option value="">-- Select Route --</option>
                            </select>
                        </div>
                        <div class="w-full sm:w-auto sm:min-w-[120px] md:flex-grow-0 lg:w-auto">
                            <label for="inputRouteColour">Select Colour</label>
                            <input type="color" id="inputRouteColour" value="#73809C" class="w-full h-11"> </div>

                        <div><button class="button" style="padding: 0.5rem 0.8rem; background-color: #73809C; color: #FFFFFF;">Day Bus</button></div>
                        <div><button class="button" style="padding: 0.5rem 0.8rem; background-color: #4CDBE6; color: #000000;">24 Hr / Night Bus</button></div>
                        <div><button class="button" style="padding: 0.5rem 0.8rem; background-color: #AC5099; color: #FFFFFF;">School Bus</button></div>
                        <div><button class="button" style="padding: 0.5rem 0.8rem; background-color: #CBC51A; color: #000000;">Rail Replacement</button></div>

                        <div class="w-full sm:w-auto mt-2 sm:mt-0">
                            <button id="saveRouteColourButton" class="button w-full sm:w-auto">Save Global Colour</button>
                        </div>
                    </div>
                    <div id="currentRouteColoursListContainer">
                        <h3 class="subsection-title" style="font-size: 1.1rem; margin-bottom: 0.5rem;">Current Global Custom Colours</h3>
                        <ul id="currentRouteColoursList"></ul>
                        <p id="noCustomColoursMessage">No global custom colours set.</p>
                    </div>
                    <p id="routeColourStatusMessage" style="min-height:1.2em;"></p>
                </div>

                <div class="subsection stop-specific-route-colour-subsection"> <h3 class="subsection-title">Stop-Specific Route Tile Colours</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">Override global route colours for specific stops.</p>
                    <div>
                        <label for="selectStopForSpecificRouteColour">1. Select Stop:</label>
                        <select id="selectStopForSpecificRouteColour" class="schedule-generator-select">
                            <option value="">-- Select Stop --</option>
                        </select>
                    </div>
                    <div>
                        <label>2. Select Route(s) at this stop to colour (click one to enable delete option below):</label>
                        <div id="specificRouteColourTilesContainer">
                            <p id="specificRouteColourTilesPlaceholder">Select a stop to see its routes.</p>
                        </div>
                    </div>
                    <div style="margin-top: 0.5rem; margin-bottom: 1rem;">
                        <button id="deleteRouteFromStopButton" class="button secondary" style="display: none;">Delete Selected Route from This Stop</button>
                        <p id="deleteRouteFromStopStatusMessage" style="min-height:1.2em; margin-top:0.5rem; font-size:0.85em;"></p>
                    </div>

                    <div class="form-grid" style="grid-template-columns: 1fr auto auto auto auto auto; align-items:end; gap:0.75rem; margin-top:0.5rem;">
                        <div>
                            <label for="inputStopSpecificRouteColour">3. Select Colour:</label>
                            <input type="color" id="inputStopSpecificRouteColour" value="#73809C">
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #73809C; color: #FFFFFF;">Day Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #4CDBE6; color: #000000;">24 Hr / Night Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #AC5099; color: #FFFFFF;">School Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #CBC51A; color: #000000;">Rail Replacement</button>
                        </div>
                        <div style="padding-bottom:0.05rem;">
                            <button id="saveStopSpecificRouteColourButton" class="button tertiary">Save Colour for Selected Route(s) at this Stop</button>
                        </div>
                    </div>
                    <p id="stopSpecificRouteColourStatusMessage" style="min-height:1.2em; margin-top:0.5rem;"></p>

                    <div id="currentStopSpecificColoursListContainer">
                        <h3 class="subsection-title" style="font-size: 1.1rem; margin-bottom: 0.5rem;">Current Stop-Specific Colour Overrides</h3>
                        <div id="currentStopSpecificColoursList">
                            <p id="noStopSpecificColoursMessage">No stop-specific colours are currently set.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div id="view-departures-section" class="tool-content-section section"> <h2 style="margin-bottom:1rem;">View Departures</h2> <div class="subsection view-stop-departures"> <h3 class="subsection-title">Scheduled Departures by Stop</h3>
                    <div class="form-grid" style="grid-template-columns: 1fr 2fr; align-items: start; gap: 1.5rem;">
                        <div><label for="selectStopForDeparturesView">Bus Stop</label><select id="selectStopForDeparturesView"><option value="">-- Select Stop --</option></select></div>
                        <div><label>Departures (Sorted by Day Offset -> Profile Day -> Time)</label><div id="stopDeparturesListContainer" style="max-height: 400px; overflow-y: auto; border: 1px solid #4A5568; padding: 0.5rem; border-radius: 0.25rem;"><ul id="stopDeparturesList"></ul><p id="noDeparturesForStopMessage">Select stop to view.</p></div></div>
                    </div>
                </div>
            </div>

            <div id="deployment-tools-section" class="tool-content-section section"> <h2 style="margin-bottom:1rem;">Deployment & File Upload</h2> <div class="subsection count-file-upload"> <h3 class="subsection-title">Upload Full Schedule</h3>
                    <p style="font-size:0.8em; margin-bottom:0.5em;">Replaces current working schedule. Ensure file has correct headers: StopID, StopName, Direction, LineName, DestinationName, ScheduledTime, OperatingProfile, DayOffset.</p>
                    <label for="count-file-input" class="file-upload-label">Choose .COUNT or .txt File</label>
                    <input type="file" id="count-file-input" accept=".COUNT,.txt" style="display: none;">
                    <p id="file-status">No file selected.</p>
                </div>
                <div class="subsection actions-section"> <h3 class="subsection-title">Schedule Deployment Actions</h3>
                    <div id="stagingStatusMessage" style="min-height:1.2em;">Checking status...</div>
                    <button id="stageScheduleButton" class="button">Stage Working Schedule</button>
                    <button id="applyNowButton" class="button tertiary">Apply Staged Live NOW</button>
                    <hr style="margin: 1.5rem 0; border-color: rgba(255,255,255,0.1);">
                    <button id="viewArrivalsButton" class="button">View Arrivals Board</button>
                </div>
            </div>

            <div id="analytics-validation-section" class="tool-content-section section"> <h2 style="margin-bottom:1rem;">Schedule Analytics & Validation</h2> <div class="subsection analytics-subsection">
                    <h3 class="subsection-title">Duplicate Entry Detection</h3>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <button id="detectDuplicatesButton" class="button">Find Duplicate Entries</button>
                        <button id="removeDuplicateEntriesButton" class="button secondary">Remove All Duplicates (Keep First)</button>
                    </div>
                    <p id="removeDuplicatesStatusMessage" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                    <div id="duplicateEntriesResults" style="margin-top: 0.75rem;">
                        <p>Click "Find Duplicate Entries" to scan the current working schedule.</p>
                    </div>
                </div>
                <div class="subsection">
                    <h3 class="subsection-title">Consolidate Operating Days for Route at Stop</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        Select a stop and a route. This tool will find entries with the same time, destination, and day offset, and consolidate their Operating Profiles into one entry, removing the redundant ones.
                    </p>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr 1fr auto; align-items: end; gap: 0.75rem;">
                        <div>
                            <label for="consolidateStopSelect">Select Stop ID:</label>
                            <select id="consolidateStopSelect" class="schedule-generator-select"></select>
                        </div>
                        <div>
                            <label for="consolidateRouteSelect">Select Route:</label>
                            <select id="consolidateRouteSelect" class="schedule-generator-select"></select>
                        </div>
                        <div>
                            <label for="consolidateNewProfileInput">New Combined Operating Profile:</label>
                            <input type="text" id="consolidateNewProfileInput" class="schedule-generator-input" placeholder="e.g., MF,Sa,Su">
                        </div>
                        <div style="padding-bottom:0.05rem;">
                            <button id="consolidateOperatingDaysButton" class="button tertiary">Consolidate</button>
                        </div>
                    </div>
                    <p id="consolidateOpDaysStatusMessage" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                </div>
            </div>

        </div> </div> </body>
<script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s",
        authDomain: "omsi-c5505.firebaseapp.com",
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "omsi-c5505",
        storageBucket: "omsi-c5505.appspot.com",
        messagingSenderId: "503595375440",
        appId: "1:503595375440:web:356be6684b77ff5909ea55",
        measurementId: "G-VN7X65V3F9"
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);

      window.firebaseOMSI = {
          database: database, auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut
      };
      document.dispatchEvent(new CustomEvent('firebaseReady', { detail: window.firebaseOMSI }));
</script>

<script>

// --- DOM Elements ---
const countFileInput = document.getElementById('count-file-input');
const fileStatusElement = document.getElementById('file-status');
const currentProfileDisplayContainer = document.getElementById('current-profile-display-container');
const currentProfileDisplayElement = document.getElementById('current-profile-display');

const refreshOperatingProfilesButton = document.getElementById('refreshOperatingProfilesButton');
const operatingProfilesStatusMessage = document.getElementById('operatingProfilesStatusMessage');
const uniqueOperatingProfilesUL = document.getElementById('uniqueOperatingProfilesUL');

const bulkEditTargetLineNameInput = document.getElementById('bulkEditTargetLineName');
const bulkEditOldDestinationInput = document.getElementById('bulkEditOldDestination');
const bulkEditNewDestinationInput = document.getElementById('bulkEditNewDestination');
const bulkUpdateRouteDestinationButton = document.getElementById('bulkUpdateRouteDestinationButton');

const stageScheduleButton = document.getElementById('stageScheduleButton');
const applyNowButton = document.getElementById('applyNowButton');
const viewArrivalsButton = document.getElementById('viewArrivalsButton');
const stagingStatusMessage = document.getElementById('stagingStatusMessage');

const selectRouteNameColour = document.getElementById('selectRouteNameColour');
const inputRouteColour = document.getElementById('inputRouteColour');
const saveRouteColourButton = document.getElementById('saveRouteColourButton');
const currentRouteColoursList = document.getElementById('currentRouteColoursList');
const noCustomColoursMessage = document.getElementById('noCustomColoursMessage');
const routeColourStatusMessage = document.getElementById('routeColourStatusMessage');

const selectStopForSpecificRouteColour = document.getElementById('selectStopForSpecificRouteColour');
const specificRouteColourTilesContainer = document.getElementById('specificRouteColourTilesContainer');
const specificRouteColourTilesPlaceholder = document.getElementById('specificRouteColourTilesPlaceholder');
const inputStopSpecificRouteColour = document.getElementById('inputStopSpecificRouteColour');
const saveStopSpecificRouteColourButton = document.getElementById('saveStopSpecificRouteColourButton');
const stopSpecificRouteColourStatusMessage = document.getElementById('stopSpecificRouteColourStatusMessage');
const currentStopSpecificColoursListContainer = document.getElementById('currentStopSpecificColoursListContainer');
const currentStopSpecificColoursList = document.getElementById('currentStopSpecificColoursList');
const noStopSpecificColoursMessageEl = document.getElementById('currentStopSpecificColoursListContainer')?.querySelector('#noStopSpecificColoursMessage');

const deleteRouteFromStopButton = document.getElementById('deleteRouteFromStopButton');
const deleteRouteFromStopStatusMessage = document.getElementById('deleteRouteFromStopStatusMessage');

const selectStopForDeparturesView = document.getElementById('selectStopForDeparturesView');
const stopDeparturesList = document.getElementById('stopDeparturesList');
const noDeparturesForStopMessage = document.getElementById('noDeparturesForStopMessage');

const topMenuBar = document.getElementById('top-menu-bar');
const adminLoginSection = document.getElementById('auth-section');
const loginFormContainer = document.getElementById('login-form-container');
const logoutContainer = document.getElementById('logout-container');
const loginButton = document.getElementById('loginButton');
const logoutButton = document.getElementById('logoutButton');
const inputEmail = document.getElementById('inputEmail');
const inputPassword = document.getElementById('inputPassword');
const authStatus = document.getElementById('auth-status');
const loggedInUserEmailDisplay = document.getElementById('loggedInUserEmail');
const mainMenuButtons = document.querySelectorAll('#main-menu-buttons .menu-button');
const allToolContentSections = document.querySelectorAll('.tool-content-section');

const detectDuplicatesButton = document.getElementById('detectDuplicatesButton');
const duplicateEntriesResults = document.getElementById('duplicateEntriesResults');
const removeDuplicateEntriesButton = document.getElementById('removeDuplicateEntriesButton');
const removeDuplicatesStatusMessage = document.getElementById('removeDuplicatesStatusMessage');

const consolidateStopSelect = document.getElementById('consolidateStopSelect');
const consolidateRouteSelect = document.getElementById('consolidateRouteSelect');
const consolidateNewProfileInput = document.getElementById('consolidateNewProfileInput');
const consolidateOperatingDaysButton = document.getElementById('consolidateOperatingDaysButton');
const consolidateOpDaysStatusMessage = document.getElementById('consolidateOpDaysStatusMessage');

// --- Global State ---
let currentUser = null;
let currentWorkingSchedule = [];
let ukBankHolidaysData = { dates: [], titles: {} };
const schoolHolidayDateRanges = [
    { start: '2025-05-24', end: '2025-06-01' },
    { start: '2025-07-19', end: '2025-09-02' },
    { start: '2025-10-25', end: '2025-11-02' },
    { start: '2025-12-20', end: '2026-01-04' },
    { start: '2026-02-14', end: '2026-02-22' },
    { start: '2026-04-03', end: '2026-04-20' },
    { start: '2026-05-23', end: '2026-05-31' },
    { start: '2026-07-18', end: '2026-09-02' },
    { start: '2026-10-24', end: '2026-11-01' },
    { start: '2026-12-19', end: '2027-01-04' },
    { start: '2027-02-13', end: '2027-02-21' },
    { start: '2027-03-26', end: '2027-04-13' },
    { start: '2027-05-29', end: '2027-06-06' },
    { start: '2027-07-22', end: '2027-08-31' }
];
const VALID_OPERATING_PROFILE_CODES_FOR_TOOLS = [
    "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su",
    "MF",
    "MoSch", "TuSch", "WeSch", "ThSch", "FrSch", "MFSch",
    "MoNSD", "TuNSD", "WeNSD", "ThNSD", "FrNSD", "MFNSD",
    "Christmas Day", "Boxing Day", "New Years Day"
    ];
let closedStopIDs = [];
let globalCustomRouteColours = {};
let stopSpecificRouteColours = {};
let autoApplyIntervalId = null;

// --- Constants ---
const LOCAL_STORAGE_ACTIVE_SECTION_KEY = 'omsiToolsActiveSection';
const FB_PATH_LIVE_SCHEDULE_DATA = '/liveSchedule/schedulesByRoute';
const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
const FB_PATH_PENDING_SCHEDULE_DATA = '/pendingSchedule/schedulesByRoute';
const FB_PATH_PENDING_UNIQUE_STOPS = '/pendingSchedule/uniqueBusStops';
const FB_PATH_PENDING_TIMESTAMP = '/pendingSchedule/uploadTimestamp';
const FB_PATH_APPSTATE_STATUS = '/appState/scheduleStatus';
const FB_PATH_APPSTATE_LAST_UPDATED = '/appState/scheduleLastUpdated';
const FB_PATH_APPSTATE_CLOSED_STOPS = '/appState/closedStopIDs';
const FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS = '/settings/customRouteColours';
const FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS = '/settings/stopSpecificRouteColours';

const initialRouteColourMapForTools = {};
const DEFAULT_ROUTE_COLOUR_TOOLS = "#73809C";
const NIGHT_BUS_BLUE_COLOR = (initialRouteColourMapForTools["N35"] || "#4CDBE6").toUpperCase();
const DAY_BUS_GREY_COLOR = DEFAULT_ROUTE_COLOUR_TOOLS.toUpperCase();

function toTitleCase_display(str) {
    if (!str || typeof str !== 'string') return "";
    return str.toLowerCase().split(' ').map(function(word) {
        if (word.length > 0) {
            if (word.includes("'")) {
                const parts = word.split("'");
                parts[0] = parts[0].charAt(0).toUpperCase() + parts[0].substring(1);
                return parts.join("'");
            }
            return word.charAt(0).toUpperCase() + word.substring(1);
        }
        return "";
    }).join(' ');
}

function sanitizeFirebaseKey(text) {
    if (typeof text !== 'string') return '';
    return text.replace(/[.#$[\]]/g, '_');
}

function displayUniqueOperatingProfiles() {
    if (!currentUser) {
        if (operatingProfilesStatusMessage) operatingProfilesStatusMessage.textContent = "Please log in to view operating profiles.";
        if (uniqueOperatingProfilesUL) uniqueOperatingProfilesUL.innerHTML = '';
        return;
    }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        if (operatingProfilesStatusMessage) operatingProfilesStatusMessage.textContent = "Working schedule is empty. No operating profiles to display.";
        if (uniqueOperatingProfilesUL) uniqueOperatingProfilesUL.innerHTML = '<li>No schedule data loaded.</li>';
        return;
    }

    const profileStrings = new Set();
    currentWorkingSchedule.forEach(entry => {
        if (entry.OperatingProfile && typeof entry.OperatingProfile === 'string' && entry.OperatingProfile.trim() !== '') {
            profileStrings.add(entry.OperatingProfile.trim());
        }
    });

    const sortedProfiles = Array.from(profileStrings).sort((a, b) => {
        const orderA = getDaySortOrder(a);
        const orderB = getDaySortOrder(b);
        if (orderA !== orderB) {
            return orderA - orderB;
        }
        return String(a).toLowerCase().localeCompare(String(b).toLowerCase());
    });

    if (uniqueOperatingProfilesUL) {
        uniqueOperatingProfilesUL.innerHTML = '';
        if (sortedProfiles.length > 0) {
            sortedProfiles.forEach(profile => {
                const li = document.createElement('li');
                li.textContent = profile;
                uniqueOperatingProfilesUL.appendChild(li);
            });
            if (operatingProfilesStatusMessage) operatingProfilesStatusMessage.textContent = `Found ${sortedProfiles.length} unique operating profile string(s).`;
        } else {
            uniqueOperatingProfilesUL.innerHTML = '<li>No operating profiles found in the current schedule.</li>';
            if (operatingProfilesStatusMessage) operatingProfilesStatusMessage.textContent = "No operating profiles found.";
        }
    }
}

function displayReferenceOperatingProfiles() {
    const referenceProfilesUL = document.getElementById('referenceOperatingProfilesUL');
    if (!referenceProfilesUL) {
        return;
    }
    const sampleReferenceScheduleData = [
        { "OperatingProfile": "Mo" }, { "OperatingProfile": "Mo, Tu" }, { "OperatingProfile": "Mo, Tu, We" },
        { "OperatingProfile": "Mo, Tu, We, Th" }, { "OperatingProfile": "Mo, Tu, We, Th, Sa" },
        { "OperatingProfile": "Mo, Tu, We, Th, Sa, Su" }, { "OperatingProfile": "Mo, Tu, We, Th, Su" },
        { "OperatingProfile": "Mo, Tu, We, Fr" }, { "OperatingProfile": "Mo, Tu, We, Fr, Sa" },
        { "OperatingProfile": "Mo, Tu, We, Fr, Sa, Su" }, { "OperatingProfile": "Mo, Tu, We, Fr, Su" },
        { "OperatingProfile": "Mo, Tu, We, Sa" }, { "OperatingProfile": "Mo, Tu, We, Sa, Su" },
        { "OperatingProfile": "Mo, Tu, We, Su" }, { "OperatingProfile": "Mo, Tu, Th" },
        { "OperatingProfile": "Mo, Tu, Th, Sa" }, { "OperatingProfile": "Mo, Tu, Th, Sa, Su" },
        { "OperatingProfile": "Mo, Tu, Th, Su" }, { "OperatingProfile": "Mo, Tu, Fr" },
        { "OperatingProfile": "Mo, Tu, Fr, Sa" }, { "OperatingProfile": "Mo, Tu, Fr, Sa, Su" },
        { "OperatingProfile": "Mo, Tu, Fr, Su" }, { "OperatingProfile": "Mo, Tu, Sa" },
        { "OperatingProfile": "Mo, Tu, Sa, Su" }, { "OperatingProfile": "Mo, Tu, Su" },
        { "OperatingProfile": "Mo, We" }, { "OperatingProfile": "Mo, We, Th" },
        { "OperatingProfile": "Mo, We, Th, Fr" }, { "OperatingProfile": "Mo, We, Th, Fr, Sa" },
        { "OperatingProfile": "Mo, We, Th, Fr, Sa, Su" }, { "OperatingProfile": "Mo, We, Th, Fr, Su" },
        { "OperatingProfile": "Mo, We, Th, Sa" }, { "OperatingProfile": "Mo, We, Th, Sa, Su" },
        { "OperatingProfile": "Mo, We, Th, Su" }, { "OperatingProfile": "Mo, We, Fr" },
        { "OperatingProfile": "Mo, We, Fr, Sa" }, { "OperatingProfile": "Mo, We, Fr, Sa, Su" },
        { "OperatingProfile": "Mo, We, Fr, Su" }, { "OperatingProfile": "Mo, We, Sa" },
        { "OperatingProfile": "Mo, We, Sa, Su" }, { "OperatingProfile": "Mo, We, Su" },
        { "OperatingProfile": "Mo, Th" }, { "OperatingProfile": "Mo, Th, Fr" },
        { "OperatingProfile": "Mo, Th, Fr, Sa" }, { "OperatingProfile": "Mo, Th, Fr, Sa, Su" },
        { "OperatingProfile": "Mo, Th, Fr, Su" }, { "OperatingProfile": "Mo, Th, Sa" },
        { "OperatingProfile": "Mo, Th, Sa, Su" }, { "OperatingProfile": "Mo, Th, Su" },
        { "OperatingProfile": "Mo, Fr" }, { "OperatingProfile": "Mo, Fr, Sa" },
        { "OperatingProfile": "Mo, Fr, Sa, Su" }, { "OperatingProfile": "Mo, Fr, Su" },
        { "OperatingProfile": "Mo, Sa" }, { "OperatingProfile": "Mo, Sa, Su" }, { "OperatingProfile": "Mo, Su" },
        { "OperatingProfile": "MoSch" }, { "OperatingProfile": "MoSch, TuSch" },
        { "OperatingProfile": "MoSch, TuSch, WeSch" }, { "OperatingProfile": "MoSch, TuSch, WeSch, ThSch" },
        { "OperatingProfile": "MoSch, TuSch, WeSch, FrSch" }, { "OperatingProfile": "MoSch, TuSch, ThSch" },
        { "OperatingProfile": "MoSch, TuSch, ThSch, FrSch" }, { "OperatingProfile": "MoSch, TuSch, FrSch" },
        { "OperatingProfile": "MoSch, WeSch" }, { "OperatingProfile": "MoSch, WeSch, ThSch" },
        { "OperatingProfile": "MoSch, WeSch, ThSch, FrSch" }, { "OperatingProfile": "MoSch, WeSch, FrSch" },
        { "OperatingProfile": "MoSch, ThSch" }, { "OperatingProfile": "MoSch, ThSch, FrSch" },
        { "OperatingProfile": "MoSch, FrSch" },
        { "OperatingProfile": "MoNSD" }, { "OperatingProfile": "MoNSD, TuNSD" },
        { "OperatingProfile": "MoNSD, TuNSD, WeNSD" }, { "OperatingProfile": "MoNSD, TuNSD, WeNSD, ThNSD" },
        { "OperatingProfile": "MoNSD, TuNSD, WeNSD, FrNSD" }, { "OperatingProfile": "MoNSD, TuNSD, ThNSD" },
        { "OperatingProfile": "MoNSD, TuNSD, ThNSD, FrNSD" }, { "OperatingProfile": "MoNSD, TuNSD, FrNSD" },
        { "OperatingProfile": "MoNSD, WeNSD" }, { "OperatingProfile": "MoNSD, WeNSD, ThNSD" },
        { "OperatingProfile": "MoNSD, WeNSD, ThNSD, FrNSD" }, { "OperatingProfile": "MoNSD, WeNSD, FrNSD" },
        { "OperatingProfile": "MoNSD, ThNSD" }, { "OperatingProfile": "MoNSD, ThNSD, FrNSD" },
        { "OperatingProfile": "MoNSD, FrNSD" },
        { "OperatingProfile": "Tu" }, { "OperatingProfile": "Tu, We" }, { "OperatingProfile": "Tu, We, Th" },
        { "OperatingProfile": "Tu, We, Th, Fr" }, { "OperatingProfile": "Tu, We, Th, Fr, Sa" },
        { "OperatingProfile": "Tu, We, Th, Fr, Sa, Su" }, { "OperatingProfile": "Tu, We, Th, Fr, Su" },
        { "OperatingProfile": "Tu, We, Th, Sa" }, { "OperatingProfile": "Tu, We, Th, Sa, Su" },
        { "OperatingProfile": "Tu, We, Th, Su" }, { "OperatingProfile": "Tu, We, Fr" },
        { "OperatingProfile": "Tu, We, Fr, Sa" }, { "OperatingProfile": "Tu, We, Fr, Sa, Su" },
        { "OperatingProfile": "Tu, We, Fr, Su" }, { "OperatingProfile": "Tu, We, Sa" },
        { "OperatingProfile": "Tu, We, Sa, Su" }, { "OperatingProfile": "Tu, We, Su" },
        { "OperatingProfile": "Tu, Th" }, { "OperatingProfile": "Tu, Th, Fr" },
        { "OperatingProfile": "Tu, Th, Fr, Sa" }, { "OperatingProfile": "Tu, Th, Fr, Sa, Su" },
        { "OperatingProfile": "Tu, Th, Fr, Su" }, { "OperatingProfile": "Tu, Th, Sa" },
        { "OperatingProfile": "Tu, Th, Sa, Su" }, { "OperatingProfile": "Tu, Th, Su" },
        { "OperatingProfile": "Tu, Fr" }, { "OperatingProfile": "Tu, Fr, Sa" },
        { "OperatingProfile": "Tu, Fr, Sa, Su" }, { "OperatingProfile": "Tu, Fr, Su" },
        { "OperatingProfile": "Tu, Sa" }, { "OperatingProfile": "Tu, Sa, Su" }, { "OperatingProfile": "Tu, Su" },
        { "OperatingProfile": "TuSch" }, { "OperatingProfile": "TuSch, WeSch" },
        { "OperatingProfile": "TuSch, WeSch, ThSch" }, { "OperatingProfile": "TuSch, WeSch, FrSch" },
        { "OperatingProfile": "TuSch, ThSch" }, { "OperatingProfile": "TuSch, ThSch, FrSch" },
        { "OperatingProfile": "TuSch, FrSch" },
        { "OperatingProfile": "TuNSD" }, { "OperatingProfile": "TuNSD, WeNSD" },
        { "OperatingProfile": "TuNSD, WeNSD, ThNSD" }, { "OperatingProfile": "TuNSD, WeNSD, ThNSD, FrNSD" },
        { "OperatingProfile": "TuNSD, WeNSD, FrNSD" }, { "OperatingProfile": "TuNSD, ThNSD" },
        { "OperatingProfile": "TuNSD, ThNSD, FrNSD" }, { "OperatingProfile": "TuNSD, FrNSD" },
        { "OperatingProfile": "We" }, { "OperatingProfile": "We, Th" }, { "OperatingProfile": "We, Th, Fr" },
        { "OperatingProfile": "We, Th, Fr, Sa" }, { "OperatingProfile": "We, Th, Fr, Sa, Su" },
        { "OperatingProfile": "We, Th, Fr, Su" }, { "OperatingProfile": "We, Th, Sa" },
        { "OperatingProfile": "We, Th, Sa, Su" }, { "OperatingProfile": "We, Th, Su" },
        { "OperatingProfile": "We, Fr" }, { "OperatingProfile": "We, Fr, Sa" },
        { "OperatingProfile": "We, Fr, Sa, Su" }, { "OperatingProfile": "We, Fr, Su" },
        { "OperatingProfile": "We, Sa" }, { "OperatingProfile": "We, Sa, Su" }, { "OperatingProfile": "We, Su" },
        { "OperatingProfile": "WeSch" }, { "OperatingProfile": "WeSch, ThSch" },
        { "OperatingProfile": "WeSch, ThSch, FrSch" }, { "OperatingProfile": "WeSch, FrSch" },
        { "OperatingProfile": "WeNSD" }, { "OperatingProfile": "WeNSD, ThNSD" },
        { "OperatingProfile": "WeNSD, ThNSD, FrNSD" }, { "OperatingProfile": "WeNSD, FrNSD" },
        { "OperatingProfile": "Th" }, { "OperatingProfile": "Th, Fr" }, { "OperatingProfile": "Th, Fr, Sa" },
        { "OperatingProfile": "Th, Fr, Sa, Su" }, { "OperatingProfile": "Th, Fr, Su" },
        { "OperatingProfile": "Th, Sa" }, { "OperatingProfile": "Th, Sa, Su" }, { "OperatingProfile": "Th, Su" },
        { "OperatingProfile": "ThSch" }, { "OperatingProfile": "ThSch, FrSch" },
        { "OperatingProfile": "ThNSD" }, { "OperatingProfile": "ThNSD, FrNSD" },
        { "OperatingProfile": "Fr" }, { "OperatingProfile": "Fr, Sa" }, { "OperatingProfile": "Fr, Sa, Su" },
        { "OperatingProfile": "Fr, Su" }, { "OperatingProfile": "FrSch" }, { "OperatingProfile": "FrNSD" },
        { "OperatingProfile": "MF" }, { "OperatingProfile": "MF, Sa" }, { "OperatingProfile": "MF, Sa, Su" },
        { "OperatingProfile": "MF, Su" }, { "OperatingProfile": "MFSch" }, { "OperatingProfile": "MFNSD" },
        { "OperatingProfile": "Sa" }, { "OperatingProfile": "Sa, Su" }, { "OperatingProfile": "Su" },
        { "OperatingProfile": "Christmas Day" }, { "OperatingProfile": "Boxing Day" }, { "OperatingProfile": "New Years Day" }
    ];

    const profileStrings = new Set();
    sampleReferenceScheduleData.forEach(entry => {
        if (entry.OperatingProfile && typeof entry.OperatingProfile === 'string' && entry.OperatingProfile.trim() !== '') {
            profileStrings.add(entry.OperatingProfile.trim());
        }
    });

    const sortedProfiles = Array.from(profileStrings).sort((a, b) => {
        const orderA = getDaySortOrder(a);
        const orderB = getDaySortOrder(b);
        if (orderA !== orderB) return orderA - orderB;
        const partsA = a.split(',').map(p => p.trim());
        const partsB = b.split(',').map(p => p.trim());
        const lenA = partsA.length; const lenB = partsB.length; const minLen = Math.min(lenA, lenB);
        for (let i = 0; i < minLen; i++) { if (partsA[i] === partsB[i]) continue; const partOrderA = getDaySortOrder(partsA[i]); const partOrderB = getDaySortOrder(partsB[i]); if (partOrderA !== partOrderB) return partOrderA - partOrderB; return String(partsA[i]).toLowerCase().localeCompare(String(partsB[i]).toLowerCase()); }
        if (lenA !== lenB) return lenA - lenB;
        return String(a).toLowerCase().localeCompare(String(b).toLowerCase());
    });

    referenceProfilesUL.innerHTML = '';
    if (sortedProfiles.length > 0) {
        sortedProfiles.forEach(profile => {
            const li = document.createElement('li');
            li.textContent = profile;
            referenceProfilesUL.appendChild(li);
        });
    } else {
        referenceProfilesUL.innerHTML = '<li>No reference profiles defined in the sample list.</li>';
    }
}

// --- UI Navigation & State ---
function showSection(sectionId) {
    allToolContentSections.forEach(section => {
        section.style.display = 'none';
    });
    const sectionToShow = document.getElementById(sectionId);
    if (sectionToShow) {
        sectionToShow.style.display = 'block';
        const isMainButtonSection = Array.from(mainMenuButtons).some(btn => btn.getAttribute('data-section') === sectionId);
        if (isMainButtonSection) localStorage.setItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY, sectionId);

        if (sectionId === 'bulk-edit-tools-section') {
            populateRouteSelectorForColours(); renderGlobalCustomRouteColours();
            populateStopSelectorForSpecificColours(); renderStopSpecificRouteColours();
            if (selectStopForSpecificRouteColour?.value) displayRoutesForSpecificColouring();
        } else if (sectionId === 'view-departures-section') {
            populateStopSelectorForDeparturesView();
            if(selectStopForDeparturesView?.value) displayDeparturesForSelectedStop();
        } else if (sectionId === 'analytics-validation-section') {
            populateConsolidateStopSelect();
        } else if (sectionId === 'operating-profiles-section') {
            displayUniqueOperatingProfiles();
        }
    }
}


function hideAllToolSections() { allToolContentSections.forEach(s => s.style.display = 'none'); }

function updateAuthUI(user) {
    const logoutContainerElement = document.getElementById('logout-container');

    currentUser = user;
    hideAllToolSections();

    if (user) {
        if (adminLoginSection) {
            adminLoginSection.style.display = 'block';
            adminLoginSection.classList.add('auth-section-compact');
        }
        if (loginFormContainer) loginFormContainer.style.display = 'none';

        if (logoutContainerElement) {
            logoutContainerElement.style.display = 'block';
        }

        if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'block';
        if (topMenuBar) topMenuBar.style.display = 'block';

        if (authStatus) authStatus.textContent = '';
        if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = user.email;

        loadInitialData();
        initializeAutoApplyScheduler();

        const lastActiveSection = localStorage.getItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        let sectionShown = false;
        if (lastActiveSection) {
            const sectionEl = document.getElementById(lastActiveSection);
            const isKnownMenu = Array.from(mainMenuButtons).some(b => b.dataset.section === lastActiveSection);
            if (sectionEl && isKnownMenu) {
                showSection(lastActiveSection);
                sectionShown = true;
            } else {
                localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
            }
        }
        if (!sectionShown && mainMenuButtons.length > 0 && mainMenuButtons[0].dataset.section) {
            showSection(mainMenuButtons[0].dataset.section);
        }

    } else {
        if (adminLoginSection) {
            adminLoginSection.style.display = 'block';
            adminLoginSection.classList.remove('auth-section-compact');
        }
        if (loginFormContainer) loginFormContainer.style.display = 'block';

        if (logoutContainerElement) {
            logoutContainerElement.style.display = 'none';
        }

        if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'none';
        if (topMenuBar) topMenuBar.style.display = 'none';

        if (authStatus) authStatus.textContent = 'Please log in to use the tools.';
        if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = '';

        localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        stopAutoApplyScheduler();
        currentWorkingSchedule = [];
        closedStopIDs = [];
        globalCustomRouteColours = {};
        stopSpecificRouteColours = {};
        renderUIDependentElements();
    }
}


// --- Analytics Functions ---
function detectDuplicateEntries() {
    if (!currentUser || currentWorkingSchedule.length === 0) {
        if (duplicateEntriesResults) duplicateEntriesResults.innerHTML = '<p>No schedule data or not logged in.</p>'; return;
    }
    const signatures = new Map(); const duplicates = [];
    currentWorkingSchedule.forEach((entry, index) => {
        const profileString = (entry.OperatingProfile || "").toLowerCase().split(',').map(s => s.trim()).sort().join(',');
        const signature = [
            (entry.stopID || "").toUpperCase(),
            (entry.lineName || "").toUpperCase(),
            entry.scheduledTime || "00:00",
            profileString,
            entry.DayOffset || "0",
            (entry.destinationName || "").trim()
        ].join('|');

        if (signatures.has(signature)) {
            signatures.get(signature).push(index);
        } else {
            signatures.set(signature, [index]);
        }
    });

    signatures.forEach((indices, sig) => {
        if (indices.length > 1) {
            duplicates.push(indices.map(originalIndex => ({...currentWorkingSchedule[originalIndex], originalIndex})));
        }
    });

    if (duplicateEntriesResults) {
        if (duplicates.length === 0) {
            duplicateEntriesResults.innerHTML = '<p>No duplicate entries found.</p>';
        } else {
            let html = `<p>Found ${duplicates.length} set(s) of duplicates:</p><ul>`;
            duplicates.forEach((set, i) => {
                html += `<li class="duplicate-set"><strong>Set ${i + 1}:</strong> (Appears ${set.length} times)`;
                set.forEach(e => {
                    html += `<span class="entry-detail"> - Stop: ${e.stopID}, Line: ${e.lineName}, Time: ${e.scheduledTime}, Profile: ${e.OperatingProfile}, Dest: ${e.destinationName} (Original Index: ${e.originalIndex})</span>`;
                });
                html += `</li>`;
            });
            duplicateEntriesResults.innerHTML = html + `</ul>`;
        }
    }
}

function handleRemoveDuplicateEntries() {
    if (!currentUser) { alert("Please log in."); if(removeDuplicatesStatusMessage) removeDuplicatesStatusMessage.textContent = "Not logged in."; return; }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) { alert("Working schedule empty."); if(removeDuplicatesStatusMessage) removeDuplicatesStatusMessage.textContent = "Working schedule empty."; return; }

    const initialCount = currentWorkingSchedule.length;
    const signaturesEncountered = new Set();
    const deduplicatedSchedule = [];

    currentWorkingSchedule.forEach(entry => {
        const profileString = (entry.OperatingProfile || "").toLowerCase().split(',').map(s=>s.trim()).sort().join(',');
        const signature = [(entry.stopID||"").toUpperCase(), (entry.lineName||"").toUpperCase(), entry.scheduledTime||"00:00", profileString, entry.DayOffset||"0", (entry.destinationName||"").trim()].join('|');
        if (!signaturesEncountered.has(signature)) {
            signaturesEncountered.add(signature);
            deduplicatedSchedule.push(entry);
        }
    });

    const removedCount = initialCount - deduplicatedSchedule.length;
    if (removedCount === 0) {
        alert("No duplicates found based on StopID, LineName, Time, Profile, DayOffset, and Destination.");
        if(removeDuplicatesStatusMessage){ removeDuplicatesStatusMessage.textContent = "No duplicates found."; removeDuplicatesStatusMessage.style.color = ""; }
        return;
    }

    if (confirm(`Found ${removedCount} duplicate schedule entries. Are you sure you want to remove them (keeping the first occurrence of each)?`)) {
        currentWorkingSchedule = deduplicatedSchedule;
        if(removeDuplicatesStatusMessage){ removeDuplicatesStatusMessage.textContent = `${removedCount} duplicates removed.`; removeDuplicatesStatusMessage.style.color = '#2ecc71'; }
        alert(`${removedCount} duplicates removed.`);
        renderUIDependentElements();
        detectDuplicateEntries();
        updateStagingStatusDisplay();
    } else {
        if(removeDuplicatesStatusMessage){ removeDuplicatesStatusMessage.textContent = "Duplicate removal cancelled by user."; removeDuplicatesStatusMessage.style.color = '#f1c40f'; }
    }
}


// --- START: Consolidate Operating Days Functions ---
function populateConsolidateStopSelect() {
    if (!consolidateStopSelect) return;
    const currentVal = consolidateStopSelect.value;
    consolidateStopSelect.innerHTML = '<option value="">-- Select Stop --</option>';
    const uniqueStops = getUniqueStopsFromSchedule();
    if (uniqueStops.length === 0) {
        consolidateStopSelect.innerHTML = '<option value="">-- No Stops in Schedule --</option>';
        populateConsolidateRouteSelect();
        return;
    }
    uniqueStops.forEach(stop => {
        const opt=document.createElement('option');
        opt.value=stop.stopID;
        opt.textContent=`${stop.stopName} (${stop.stopID})`;
        consolidateStopSelect.appendChild(opt);
    });
    if (uniqueStops.find(s => s.stopID === currentVal)) {
        consolidateStopSelect.value = currentVal;
    }
    populateConsolidateRouteSelect();
}

function populateConsolidateRouteSelect() {
    if (!consolidateRouteSelect || !consolidateStopSelect) return;
    const selectedStopId = consolidateStopSelect.value;
    const currentRouteVal = consolidateRouteSelect.value;
    consolidateRouteSelect.innerHTML = '<option value="">-- Select Route --</option>';

    if (!selectedStopId) {
        consolidateRouteSelect.innerHTML = '<option value="">-- Select Stop First --</option>';
        return;
    }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) return;

    const routesForStop = [...new Set(
        currentWorkingSchedule
            .filter(e => e.stopID === selectedStopId && e.lineName)
            .map(e => e.lineName)
    )].sort(compareLineNames);

    if (routesForStop.length === 0) {
        consolidateRouteSelect.innerHTML = `<option value="">-- No Routes for Stop ${selectedStopId} --</option>`;
    } else {
        routesForStop.forEach(ln => {
            const opt=document.createElement('option');
            opt.value=ln; opt.textContent=ln;
            consolidateRouteSelect.appendChild(opt);
        });
        if (routesForStop.includes(currentRouteVal)) {
            consolidateRouteSelect.value = currentRouteVal;
        }
    }
}

function handleConsolidateOperatingDays() {
    if (!currentUser) { alert("Please log in."); consolidateOpDaysStatusMessage.textContent = "Not logged in."; return; }
    const stopId = consolidateStopSelect.value;
    const lineName = consolidateRouteSelect.value;
    const newProfile = consolidateNewProfileInput.value.trim();

    if (!stopId) { consolidateOpDaysStatusMessage.textContent = "Please select a Stop ID."; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return; }
    if (!lineName) { consolidateOpDaysStatusMessage.textContent = "Please select a Route."; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return; }
    if (!newProfile) { consolidateOpDaysStatusMessage.textContent = "Please enter the new combined Operating Profile."; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return; }

    const relevantEntriesForStopRoute = currentWorkingSchedule.filter(e => e.stopID === stopId && e.lineName === lineName);
    if (relevantEntriesForStopRoute.length === 0) {
        consolidateOpDaysStatusMessage.textContent = `No entries found for Stop ${stopId}, Line ${lineName}.`; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return;
    }

    const groups = new Map();
    relevantEntriesForStopRoute.forEach(e => {
        const key = `${e.scheduledTime}|${e.destinationName||""}|${e.DayOffset||"0"}`;
        if(!groups.has(key)) groups.set(key, []);
        groups.get(key).push(e);
    });

    let consolidatedGroupCount = 0;
    let entriesToRemoveInternalIds = new Set();
    let modifiedEntriesForThisContext = [];

    groups.forEach((group, key) => {
        if (group.length > 1) {
            consolidatedGroupCount++;
            const firstEntry = {...group[0]};
            firstEntry.OperatingProfile = newProfile;
            modifiedEntriesForThisContext.push(firstEntry);
            for (let i = 1; i < group.length; i++) {
                if (group[i].internalId) {
                    entriesToRemoveInternalIds.add(group[i].internalId);
                }
            }
        } else {
            modifiedEntriesForThisContext.push(group[0]);
        }
    });

    const otherEntries = currentWorkingSchedule.filter(e => e.stopID !== stopId || e.lineName !== lineName);

    if (consolidatedGroupCount === 0) {
        consolidateOpDaysStatusMessage.textContent = "No entries found that could be consolidated for the selected criteria (i.e., no multiple entries with same time/dest/dayOffset).";
        consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return;
    }

    const actualRemovedCount = entriesToRemoveInternalIds.size;
    if (!confirm(`Found ${consolidatedGroupCount} group(s) of entries for Stop ${stopId}, Route ${lineName} that can be consolidated.\nThis will update one entry per group to Operating Profile "${newProfile}" and remove ${actualRemovedCount} other redundant entries.\nProceed?`)) {
        consolidateOpDaysStatusMessage.textContent = "Consolidation cancelled by user."; consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return;
    }

    currentWorkingSchedule = [
        ...otherEntries,
        ...modifiedEntriesForThisContext.filter(mEntry => !entriesToRemoveInternalIds.has(mEntry.internalId))
    ];


    consolidateOpDaysStatusMessage.textContent = `Consolidated ${consolidatedGroupCount} group(s) for Stop ${stopId}, Route ${lineName}. ${actualRemovedCount} entries removed. Operating Profile set to "${newProfile}".`;
    consolidateOpDaysStatusMessage.style.color = '#2ecc71';
    alert(`Operating days consolidated. ${actualRemovedCount} entries removed.`);

    renderUIDependentElements();
    detectDuplicateEntries();
    updateStagingStatusDisplay();
}
// --- END: Consolidate Operating Days Functions ---

// --- Utility Functions (Date, Sorting, Parsing etc.) ---
function parseLineName(lineNameStr) { const name = String(lineNameStr || "").toUpperCase().trim(); const numericPrefixRegex = new RegExp(/^(\d+)([A-Z]*)$/); const alphaNumericRegex = new RegExp(/^([A-Z]+)(\d+)?([A-Z]*)$/); const numericPrefixMatch = name.match(numericPrefixRegex); if (numericPrefixMatch) return { type: 'numeric', number: parseInt(numericPrefixMatch[1], 10), suffix: numericPrefixMatch[2] || '', original: name }; const alphaNumericMatch = name.match(alphaNumericRegex); if (alphaNumericMatch) return { type: 'alpha', prefix: alphaNumericMatch[1], number: alphaNumericMatch[2] ? parseInt(alphaNumericMatch[2], 10) : null, suffix: alphaNumericMatch[3] || '', original: name }; return { type: 'other', original: name }; }
function compareLineNames(lineAStr, lineBStr) { const parsedA = parseLineName(lineAStr); const parsedB = parseLineName(lineBStr); if (parsedA.type === 'numeric' && parsedB.type === 'alpha') return -1; if (parsedA.type === 'alpha' && parsedB.type === 'numeric') return 1; if (parsedA.type === 'numeric' && parsedB.type === 'numeric') { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type === 'alpha' && parsedB.type === 'alpha') { const prefixCompare = parsedA.prefix.localeCompare(parsedB.prefix); if (prefixCompare !== 0) return prefixCompare; if (parsedA.number === null && parsedB.number !== null) return -1; if (parsedA.number !== null && parsedB.number === null) return 1; if (parsedA.number !== null && parsedB.number !== null) { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; } return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type !== 'other' && parsedB.type === 'other') return -1; if (parsedA.type === 'other' && parsedB.type !== 'other') return 1; return (parsedA.original || "").localeCompare(parsedB.original || ""); }

function generateUniqueStopId(format) {
    const existingStopIDs = new Set(currentWorkingSchedule.map(entry => entry.stopID.toUpperCase()));
    let nextId = ""; let currentNum = 0; let attempts = 0; const maxAttempts = 100000;
    if (format === "NUM") {
        let maxNumeric = 100;
        existingStopIDs.forEach(id => {
            if (/^\d+$/.test(id)) {
                const num = parseInt(id, 10);
                if (num >= 101 && num > maxNumeric) maxNumeric = num;
            }
        });
        currentNum = maxNumeric + 1;
        while (attempts < maxAttempts) {
            nextId = String(currentNum);
            if (!existingStopIDs.has(nextId)) return nextId;
            currentNum++; attempts++;
            if (currentNum > 99999) break;
        }
    } else if (["BP", "LE", "RO"].includes(format)) {
        const prefix = format;
        let maxPrefixNum = 0;
        existingStopIDs.forEach(id => {
            if (id.startsWith(prefix)) {
                const numPart = id.substring(prefix.length);
                if (/^\d+$/.test(numPart)) {
                    const num = parseInt(numPart, 10);
                    if (num > maxPrefixNum) maxPrefixNum = num;
                }
            }
        });
        currentNum = maxPrefixNum + 1;
        while (attempts < maxAttempts) {
            nextId = prefix + currentNum;
            if (!existingStopIDs.has(nextId.toUpperCase())) return nextId;
            currentNum++; attempts++;
            if (currentNum > 99999) break;
        }
    }
    return (format || "ID") + String(Date.now()).slice(-5) + String(Math.floor(Math.random()*90)+10);
}

function getOperatingCodesForToday_Tools() {
    const n = new Date();
    const dOW = n.getDay();
    const todayDateString = `${n.getFullYear()}-${String(n.getMonth() + 1).padStart(2, '0')}-${String(n.getDate()).padStart(2, '0')}`;

    let potentialDateCodes = new Set();
    let isBankHolidayToday = false;

    if (typeof ukBankHolidaysData !== 'undefined' && ukBankHolidaysData.dates && ukBankHolidaysData.dates.includes(todayDateString)) {
        const holidayTitle = ukBankHolidaysData.titles[todayDateString] || "";
        isBankHolidayToday = true;
        if (holidayTitle.toLowerCase().includes("good friday")) {
            potentialDateCodes.add("Sa");
        } else {
            potentialDateCodes.add("Su");
        }
    }

    if (!isBankHolidayToday) {
        const isSchHol = (typeof isSchoolHolidayPeriodForSetup === 'function' && typeof schoolHolidayDateRanges !== 'undefined') ? isSchoolHolidayPeriodForSetup(n) : false;
        const schoolSuffix = isSchHol ? "NSD" : "Sch";
        let dayCode = "";
        switch (dOW) {
            case 0: dayCode = "Su"; break;
            case 1: dayCode = "Mo"; break;
            case 2: dayCode = "Tu"; break;
            case 3: dayCode = "We"; break;
            case 4: dayCode = "Th"; break;
            case 5: dayCode = "Fr"; break;
            case 6: dayCode = "Sa"; break;
        }
        potentialDateCodes.add(dayCode);

        if (dOW >= 1 && dOW <= 5) {
            potentialDateCodes.add(dayCode + schoolSuffix);
            potentialDateCodes.add("MF" + schoolSuffix);
            potentialDateCodes.add("MF");
        }
    }

    const finalFilteredCodes = Array.from(potentialDateCodes).filter(code =>
        typeof VALID_OPERATING_PROFILE_CODES_FOR_TOOLS !== 'undefined' && VALID_OPERATING_PROFILE_CODES_FOR_TOOLS.includes(code)
    );

    return finalFilteredCodes;
}

async function fetchBankHolidaysForSetup() {
    try {
        const response = await fetch('https://www.gov.uk/bank-holidays.json');
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        if (data['england-and-wales'] && data['england-and-wales'].events) {
            const events = data['england-and-wales'].events;
            ukBankHolidaysData = {
                dates: events.map(event => event.date),
                titles: events.reduce((acc, event) => { acc[event.date] = event.title; return acc; }, {})
            };
        } else {
            ukBankHolidaysData = { dates: [], titles: {} };
        }
    } catch (error) {
        ukBankHolidaysData = { dates: [], titles: {} };
        if(currentProfileDisplayElement) currentProfileDisplayElement.textContent = "Today's Operating Profile: (Bank Hol. check failed)";
    }
    updateCurrentProfileDisplayOnSetup();
}

function isSchoolHolidayPeriodForSetup(dateObject) {
    if (!schoolHolidayDateRanges || schoolHolidayDateRanges.length === 0) return false;
    const checkTime = dateObject.getTime();
    for (const range of schoolHolidayDateRanges) {
        try {
            const startTime = new Date(range.start + "T00:00:00").getTime();
            const endTime = new Date(range.end + "T23:59:59").getTime();
            if (checkTime >= startTime && checkTime <= endTime) {
                return true;
            }
        } catch (e) {
            // error in date range
        }
    }
    return false;
}

function updateCurrentProfileDisplayOnSetup() {
    const now = new Date();
    const dayOfWeek = now.getDay();
    const todayDateString = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

    let profileDisplayText = "";
    let isBankHol = false;
    let serviceTypeDisplay = "";
    let isOverridden = false;
    let finalDisplayLabel = "Today's Operating Profile:";


    if (typeof globalOperationalOverrides !== 'undefined' && globalOperationalOverrides && globalOperationalOverrides[todayDateString] && currentUser) {
        const overrideProfileValue = globalOperationalOverrides[todayDateString];
        profileDisplayText = `${overrideProfileValue} (Manual Override)`;
        isOverridden = true;
        finalDisplayLabel = "Today's Profile:";
    }


    if (!isOverridden) {
        if (ukBankHolidaysData.dates && ukBankHolidaysData.dates.includes(todayDateString)) {
            let holidayTitle = ukBankHolidaysData.titles[todayDateString] || "Bank Holiday";
            holidayTitle = toTitleCase_display(holidayTitle);
            isBankHol = true;
            if (holidayTitle.toLowerCase().includes("good friday")) {
                profileDisplayText = holidayTitle;
                serviceTypeDisplay = "(Saturday Service)";
            } else {
                profileDisplayText = holidayTitle;
                serviceTypeDisplay = "(Sunday Service)";
            }
        }

        let dayName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][dayOfWeek];

        if (!isBankHol) {
            profileDisplayText = dayName;
            if (typeof isSchoolHolidayPeriodForSetup === 'function' && isSchoolHolidayPeriodForSetup(now)) {
                profileDisplayText += " (School Holiday)";
            }
        } else {
            profileDisplayText += ` ${serviceTypeDisplay} - Observed on a ${dayName}`;
            if (typeof isSchoolHolidayPeriodForSetup === 'function' && isSchoolHolidayPeriodForSetup(now)) {
                profileDisplayText += " (School Holiday Period)";
            }
        }
    }

    const operatingCodes = (typeof getOperatingCodesForToday_Tools === 'function' && !isOverridden) ? getOperatingCodesForToday_Tools() : (isOverridden ? [profileDisplayText.split(' (')[0]] : []);

    if (currentProfileDisplayElement) {
        const codesString = operatingCodes.length > 0 ? ` [Codes: ${operatingCodes.join(', ')}]` : "";
        currentProfileDisplayElement.textContent = `${finalDisplayLabel} ${profileDisplayText}${codesString}`;
    }
}


// --- Form & Data Handling Functions ---
function isValidScheduleDataFromText(jsonData) {
    if (!jsonData || jsonData.length === 0) return false;
    const requiredColumns = ['StopID', 'StopName', 'Direction', 'LineName', 'DestinationName', 'ScheduledTime', 'OperatingProfile'];
    const firstEntry = jsonData[0];
    const allColumnsPresent = requiredColumns.every(col => col in firstEntry);

    if (!allColumnsPresent) {
        const missingCols = requiredColumns.filter(col => !(col in firstEntry));
        alert(`Uploaded .COUNT file is missing essential headers: ${missingCols.join(', ')}.\nExpected headers are: StopID, StopName, Direction, LineName, DestinationName, ScheduledTime, OperatingProfile. The 'DayOffset' header is optional.`);
        return false;
    }
    return true;
}

function handleCountFileUpload(event) {
    const file = event.target.files[0];
    if (file) {
        if (fileStatusElement) fileStatusElement.textContent = `Processing ${file.name}...`;

        setTimeout(() => {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fileContent = e.target.result;
                    const lines = fileContent.split(/\r?\n/);

                    if (lines.length < 1) {
                        alert("File is empty.");
                        if(fileStatusElement) fileStatusElement.textContent="File processing failed: File is empty.";
                        if(countFileInput) countFileInput.value="";
                        return;
                    }

                    const headerLine = lines[0].trim();
                    const headersFromFile = headerLine.split('\t').map(h => h.trim());

                    if (!isValidHeaderStructure(headersFromFile)) {
                        if(fileStatusElement) fileStatusElement.textContent = "File processing failed: Invalid header structure.";
                        if(countFileInput) countFileInput.value = "";
                        return;
                    }

                    if (lines.length < 2 && lines[0].trim() !== "") {
                         alert("File contains headers but no data rows.");
                        if(fileStatusElement) fileStatusElement.textContent="File processing failed: No data rows.";
                        if(countFileInput) countFileInput.value="";
                        return;
                    }

                    const canonicalHeaders = {
                        STOPID: "StopID", STOPNAME: "StopName", DIRECTION: "Direction",
                        LINENAME: "LineName", DESTINATIONNAME: "DestinationName",
                        SCHEDULEDTIME: "ScheduledTime", OPERATINGPROFILE: "OperatingProfile",
                        DAYOFFSET: "DayOffset"
                    };
                    const headerMap = {};
                    headersFromFile.forEach(hFromFile => {
                        const upperHFromFile = hFromFile.toUpperCase();
                        for (const canonUpper in canonicalHeaders) {
                            if (upperHFromFile === canonUpper) {
                                headerMap[hFromFile] = canonicalHeaders[canonUpper];
                                break;
                            }
                        }
                    });

                    const newScheduleEntries = [];
                    const definedStopIDsInThisUpload = new Set();

                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (line === "") continue;

                        const values = line.split('\t').map(v => v.trim());

                        let rowObjectCanonical = {};
                        headersFromFile.forEach((headerInFile, idx) => {
                            const canonicalKey = headerMap[headerInFile];
                            if (canonicalKey) {
                                rowObjectCanonical[canonicalKey] = values[idx] !== undefined ? values[idx] : "";
                            }
                        });

                        const stopIDFromFile = String(rowObjectCanonical.StopID || "").trim().toUpperCase();
                        const stopNameFromFile = String(rowObjectCanonical.StopName || "").trim();
                        const directionFromFile = String(rowObjectCanonical.Direction || "").trim();
                        const lineNameFromFile = String(rowObjectCanonical.LineName || "").trim().toUpperCase();
                        const destinationNameFromFile = String(rowObjectCanonical.DestinationName || "").trim();
                        const operatingProfileFromFile = String(rowObjectCanonical.OperatingProfile || "").trim();
                        const dayOffsetFromFile = String(rowObjectCanonical.DayOffset || "0").trim();
                        let rawScheduledTimes = String(rowObjectCanonical.ScheduledTime || "").trim();

                        if (!stopIDFromFile) {
                            continue;
                        }

                        const isLikelyStopDefinition = stopIDFromFile &&
                                                     (stopNameFromFile || directionFromFile) &&
                                                     !lineNameFromFile &&
                                                     !rawScheduledTimes &&
                                                     !operatingProfileFromFile;

                        if (isLikelyStopDefinition) {
                            if (!definedStopIDsInThisUpload.has(stopIDFromFile)) {
                                newScheduleEntries.push({
                                    internalId: `${stopIDFromFile}_definition_row${i}_${Date.now()}`,
                                    stopID: stopIDFromFile,
                                    stopName: stopNameFromFile || "Unnamed Stop (via upload)",
                                    direction: directionFromFile || ""
                                });
                                definedStopIDsInThisUpload.add(stopIDFromFile);
                            }
                        } else if (stopIDFromFile && lineNameFromFile && rawScheduledTimes && operatingProfileFromFile) {
                            const timeStrings = rawScheduledTimes.split(',')
                                                      .map(t => t.trim())
                                                      .filter(t => t !== "");

                            timeStrings.forEach((singleTimeStr, timeIdx) => {
                                let schTime = singleTimeStr;
                                if (schTime.match(/^\d{1,2}:\d{2}(:\d{2})?$/)) {
                                    const p = schTime.split(':');
                                    schTime = `${String(p[0]).padStart(2, '0')}:${String(p[1]).padStart(2, '0')}`;
                                } else if (schTime.length === 4 && !schTime.includes(':')) {
                                    schTime = `${schTime.substring(0, 2)}:${schTime.substring(2, 4)}`;
                                } else if (schTime.length === 3 && !schTime.includes(':')) {
                                    schTime = `0${schTime.substring(0, 1)}:${schTime.substring(1, 3)}`;
                                } else {
                                    return;
                                }

                                const timeParts = schTime.split(':');
                                const h = parseInt(timeParts[0], 10);
                                const m = parseInt(timeParts[1], 10);
                                if (isNaN(h) || isNaN(m) || h < 0 || h > 23 || m < 0 || m > 59) {
                                    return;
                                }

                                newScheduleEntries.push({
                                    internalId: `${stopIDFromFile}_${lineNameFromFile}_${schTime.replace(':', '')}_row${i}_t${timeIdx}_countfile`,
                                    stopID: stopIDFromFile,
                                    stopName: stopNameFromFile,
                                    direction: directionFromFile,
                                    lineName: lineNameFromFile,
                                    destinationName: destinationNameFromFile,
                                    scheduledTime: schTime,
                                    OperatingProfile: operatingProfileFromFile,
                                    DayOffset: dayOffsetFromFile
                                });
                            });
                        }
                    }
                    if (newScheduleEntries.length === 0 && lines.length > 1 && lines[0].trim() !== "") {
                        alert("No valid schedule entries or stop definitions could be processed from the file. Please check the format and data.");
                        if(fileStatusElement) fileStatusElement.textContent="File processing failed: No valid entries found.";
                        if(countFileInput) countFileInput.value="";
                        return;
                    }
                    if (newScheduleEntries.length === 0 && (lines.length <=1 || lines[0].trim() === "")) {
                        alert("File appears to be empty or contains only headers without data.");
                        return;
                    }

                    if (currentWorkingSchedule.length > 0 && !confirm("This will REPLACE the current working schedule with the contents of this file. Are you sure?")) {
                        if(fileStatusElement) fileStatusElement.textContent="Upload cancelled by user.";
                        if(countFileInput) countFileInput.value="";
                        return;
                    }

                    currentWorkingSchedule = newScheduleEntries;
                    renderUIDependentElements();
                    updateStagingStatusDisplay();
                    if(fileStatusElement) fileStatusElement.textContent = `${file.name} processed. ${currentWorkingSchedule.length} total entries (schedule entries + stop definitions) loaded.`;


                } catch (error) {
                    alert(`An error occurred while processing the file: ${error.message}. Please check file format and content.`);
                    if(fileStatusElement) fileStatusElement.textContent = "Error loading file.";
                }
                if(countFileInput) countFileInput.value="";
            };
            reader.onerror = () => {
                alert("Could not read the selected file. Please ensure it's a valid text file.");
                if(fileStatusElement) fileStatusElement.textContent = "Error reading file.";
                if(countFileInput) countFileInput.value = "";
            };
            reader.readAsText(file);
        }, 50);
    }
}

function isValidHeaderStructure(parsedHeaders) {
    const upperParsedHeaders = parsedHeaders.map(h => h.toUpperCase());
    const requiredHeaders = ['STOPID', 'STOPNAME', 'DIRECTION', 'LINENAME', 'DESTINATIONNAME', 'SCHEDULEDTIME', 'OPERATINGPROFILE'];

    const missingHeaders = requiredHeaders.filter(rh => !upperParsedHeaders.includes(rh));

    if (missingHeaders.length > 0) {
        alert(`Uploaded .COUNT file is missing essential headers: ${missingHeaders.join(', ')}.\nExpected headers (case-insensitive) are at least: ${requiredHeaders.join(', ')}. The 'DayOffset' header is also recommended.`);
        return false;
    }
    return true;
}

function handleBulkUpdateRouteDestination() {
    if (!currentUser) { alert("Please log in to perform bulk updates."); return; }
    const targetLineName = bulkEditTargetLineNameInput.value.trim().toUpperCase();
    const oldDestination = bulkEditOldDestinationInput.value.trim();
    const newDestination = bulkEditNewDestinationInput.value.trim();

    if (!targetLineName) { alert("Target Line Name is required."); bulkEditTargetLineNameInput.focus(); return; }
    if (!newDestination) { alert("New Destination Name is required."); bulkEditNewDestinationInput.focus(); return; }

    let updatedCount = 0;
    currentWorkingSchedule.forEach(entry => {
        if (entry.lineName && entry.lineName.toUpperCase() === targetLineName) {
            if (oldDestination) {
                if (entry.destinationName && entry.destinationName.toLowerCase() === oldDestination.toLowerCase()) {
                    entry.destinationName = newDestination;
                    updatedCount++;
                }
            } else {
                entry.destinationName = newDestination;
                updatedCount++;
            }
        }
    });

    if (updatedCount > 0) {
        renderUIDependentElements();
        updateStagingStatusDisplay();
        alert(`${updatedCount} entries for Line "${targetLineName}" had their destination updated to "${newDestination}".`);
    } else {
        alert(`No entries found for Line "${targetLineName}"` + (oldDestination ? ` with Old Destination "${oldDestination}"` : "") + " to update.");
    }
}


// --- Firebase Data Interaction ---
async function handleStageSchedule() {
    if (!currentUser) {
        alert("Please log in to stage the schedule.");
        return;
    }
    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        alert("Firebase is not available. Cannot stage schedule.");
        return;
    }

    const { database, dbSet, dbUpdate, dbRef } = window.firebaseOMSI;

    if (currentWorkingSchedule.length === 0) {
        if (!confirm("The working schedule is currently empty. Are you sure you want to stage an empty schedule? This will clear any previously staged data and the live data if applied.")) {
            if (stagingStatusMessage) {
                stagingStatusMessage.textContent = "Staging of empty schedule cancelled.";
                stagingStatusMessage.style.color = "#e74c3c";
            }
            return;
        }
    }

    if (stagingStatusMessage) {
        stagingStatusMessage.textContent = "Preparing to stage schedule... This may take a moment for large schedules.";
        stagingStatusMessage.style.color = "#f1c40f";
    }

    try {
        await dbSet(dbRef(database, FB_PATH_PENDING_SCHEDULE_DATA), null);

        const groupedByRPD = {};
        currentWorkingSchedule.forEach((entry, index) => {
            if (!entry.lineName || !entry.OperatingProfile || !entry.destinationName) {
                return;
            }
            const saneRoute = sanitizeFirebaseKey(entry.lineName);
            const saneProfile = sanitizeFirebaseKey(entry.OperatingProfile);
            const saneDest = sanitizeFirebaseKey(entry.destinationName);
            const pathKey = `${saneRoute}/${saneProfile}/${saneDest}`;

            if (!groupedByRPD[pathKey]) {
                groupedByRPD[pathKey] = [];
            }

            const entryForStaging = { ...entry };
            if (!entryForStaging.internalId || entryForStaging.internalId.includes("_fbload_flat") || entryForStaging.internalId.includes("_countfile")) {
                 entryForStaging.internalId = `${(entry.stopID||'s').toUpperCase()}_${(entry.lineName||'l').toUpperCase()}_${(entry.scheduledTime||"").replace(':','')}_staged_${Date.now()}_${index}`;
            }
            groupedByRPD[pathKey].push(entryForStaging);
        });

        const writePromises = [];
        for (const rpdKey in groupedByRPD) {
            const entriesForThisRPD = groupedByRPD[rpdKey];
            entriesForThisRPD.sort((a, b) => {
                const timeA = (a.scheduledTime || "99:99").replace(':', '');
                const timeB = (b.scheduledTime || "99:99").replace(':', '');
                const timeCompare = timeA.localeCompare(timeB);
                if (timeCompare !== 0) return timeCompare;
                return (a.stopID || "").localeCompare(b.stopID || "");
            });

            const specificFirebasePath = `${FB_PATH_PENDING_SCHEDULE_DATA}/${rpdKey}/entries`;
            writePromises.push(dbSet(dbRef(database, specificFirebasePath), entriesForThisRPD));
        }

        await Promise.all(writePromises);

        const stopsMap = new Map();
        currentWorkingSchedule.forEach(row => {
            if (row.stopID && !stopsMap.has(row.stopID.toUpperCase())) {
                stopsMap.set(row.stopID.toUpperCase(), {
                    stopID: row.stopID, stopName: row.stopName, direction: row.direction
                });
            }
        });
        const finalUniqueStops = Array.from(stopsMap.values()).sort((a,b)=>{
            const nameCompare = (a.stopName||"").localeCompare(b.stopName||"");
            return nameCompare !== 0 ? nameCompare : (a.direction||"").localeCompare(b.direction||"");
        });

        const ancillaryUpdates = {};
        ancillaryUpdates[FB_PATH_PENDING_UNIQUE_STOPS] = finalUniqueStops;
        ancillaryUpdates[FB_PATH_PENDING_TIMESTAMP] = new Date().toISOString();
        ancillaryUpdates[FB_PATH_APPSTATE_STATUS] = 'update_staged';

        await dbUpdate(dbRef(database), ancillaryUpdates);

        alert("Schedule STAGED successfully to Firebase using granular writes. It can now be applied live.");
        updateStagingStatusDisplay();

    } catch (error) {
        alert("Error staging schedule to Firebase: " + error.message + ". Check console for details.");
        if(stagingStatusMessage) {
            stagingStatusMessage.textContent = "Firebase Staging Error. Data might be partially staged. It's advisable to try staging again.";
            stagingStatusMessage.style.color = "#e74c3c";
        }
    }
}

async function handleApplyNow() {
    if (!currentUser) {
        alert("Please log in to apply the staged schedule.");
        return;
    }
    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        alert("Firebase is not available. Cannot apply schedule.");
        return;
    }

    const { database, dbGet, dbSet, dbUpdate, dbRef, dbChild } = window.firebaseOMSI;

    if (stagingStatusMessage) {
        stagingStatusMessage.textContent = "Fetching staged data to apply live...";
        stagingStatusMessage.style.color = "#f1c40f";
    }

    try {
        const pendingSnapshot = await dbGet(dbChild(dbRef(database), '/pendingSchedule'));

        if (!pendingSnapshot.exists()) {
            alert("No Firebase staged schedule found to apply.");
            if (stagingStatusMessage) {
                stagingStatusMessage.textContent = "No Firebase staged schedule available.";
                stagingStatusMessage.style.color = "#e74c3c";
            }
            return;
        }

        const pendingDataContainer = pendingSnapshot.val();
        const pendingSchedulesByRoute = pendingDataContainer[FB_PATH_PENDING_SCHEDULE_DATA.split('/').pop()];
        const pendingUniqueBusStops = pendingDataContainer[FB_PATH_PENDING_UNIQUE_STOPS.split('/').pop()];

        if (!pendingSchedulesByRoute) {
            alert("Staged schedule data (schedulesByRoute object) is missing or in an unexpected format within the pending data. Cannot apply.");
            if (stagingStatusMessage) stagingStatusMessage.textContent = "Error: Staged schedule data missing.";
            return;
        }
        if (!pendingUniqueBusStops) {
            alert("Staged unique bus stops data is missing. Cannot apply.");
            if (stagingStatusMessage) stagingStatusMessage.textContent = "Error: Staged unique stops missing.";
            return;
        }

        if (!confirm("Are you sure you want to apply the STAGED schedule LIVE NOW? This will overwrite the current live data.")) {
            if (stagingStatusMessage) {
                stagingStatusMessage.textContent = "Apply operation cancelled by user.";
                stagingStatusMessage.style.color = "#f1c40f";
            }
            return;
        }

        if (stagingStatusMessage) {
            stagingStatusMessage.textContent = "Applying staged schedule live... This may take a moment.";
            stagingStatusMessage.style.color = "#f1c40f";
        }

        await dbSet(dbRef(database, FB_PATH_LIVE_SCHEDULE_DATA), null);

        const liveWritePromises = [];
        for (const saneRoute in pendingSchedulesByRoute) {
            for (const saneProfile in pendingSchedulesByRoute[saneRoute]) {
                for (const saneDest in pendingSchedulesByRoute[saneRoute][saneProfile]) {
                    const entriesForThisRPD = pendingSchedulesByRoute[saneRoute][saneProfile][saneDest].entries;
                    if (entriesForThisRPD && Array.isArray(entriesForThisRPD)) {
                        const specificLivePath = `${FB_PATH_LIVE_SCHEDULE_DATA}/${saneRoute}/${saneProfile}/${saneDest}/entries`;
                        liveWritePromises.push(dbSet(dbRef(database, specificLivePath), entriesForThisRPD));
                    }
                }
            }
        }

        await Promise.all(liveWritePromises);

        const appUpdates = {};
        appUpdates[FB_PATH_LIVE_UNIQUE_STOPS] = pendingUniqueBusStops;
        appUpdates[FB_PATH_APPSTATE_LAST_UPDATED] = new Date().toISOString();
        appUpdates[FB_PATH_APPSTATE_STATUS] = 'idle';
        appUpdates['/pendingSchedule'] = null;

        await dbUpdate(dbRef(database), appUpdates);

        alert("Staged schedule APPLIED LIVE successfully (using granular writes)!");
        await loadInitialData();

    } catch (error) {
        alert("Error applying schedule live: " + error.message + ". Check console for details.");
        if (stagingStatusMessage) {
            stagingStatusMessage.textContent = "Firebase Apply Error. Live data might be incomplete or old data might not be fully cleared. Please review carefully or try staging and applying again.";
            stagingStatusMessage.style.color = "#e74c3c";
        }
    }
}

async function loadInitialData() {
    let msg = "Loading data from Firebase...";
    if (fileStatusElement) fileStatusElement.textContent = msg;

    currentWorkingSchedule = [];
    closedStopIDs = [];
    globalCustomRouteColours = {};
    stopSpecificRouteColours = {};

    if (!window.firebaseOMSI || !window.firebaseOMSI.database) {
        msg = "Firebase not connected. Cannot load data.";
        if (fileStatusElement) fileStatusElement.textContent = msg;
        renderUIDependentElements();
        return;
    }

    const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
    try {
        const scheduleSnap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_SCHEDULE_DATA));
        const flatScheduleFromDB = [];
        if (scheduleSnap.exists()) {
            const schedulesByRoute = scheduleSnap.val();
            for (const routeKey in schedulesByRoute) {
                const routeData = schedulesByRoute[routeKey];
                for (const profileKey in routeData) {
                    const profileData = routeData[profileKey];
                    for (const destKey in profileData) {
                        const destData = profileData[destKey];
                        if (destData && Array.isArray(destData.entries)) {
                            destData.entries.forEach(entry => {
                                flatScheduleFromDB.push({ ...entry });
                            });
                        }
                    }
                }
            }
        }
        currentWorkingSchedule = flatScheduleFromDB.map((e,i)=>({...e, internalId: e.internalId || `${(e.stopID||'s')}_${(e.lineName||'l')}_${(e.scheduledTime||"").replace(':','')}_${i}_fbload_flat`}));

        const uniqueStopsSnap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_UNIQUE_STOPS));
        const firebaseUniqueStops = uniqueStopsSnap.exists() && Array.isArray(uniqueStopsSnap.val()) ? uniqueStopsSnap.val() : [];

        const stopIDsAlreadyInScheduleFromRoutes = new Set(currentWorkingSchedule.map(e => e.stopID.toUpperCase()));

        firebaseUniqueStops.forEach(fbStop => {
            if (fbStop && fbStop.stopID && !stopIDsAlreadyInScheduleFromRoutes.has(fbStop.stopID.toUpperCase())) {
                currentWorkingSchedule.push({
                    internalId: `${fbStop.stopID}_definition_fbload_${Date.now()}`,
                    stopID: fbStop.stopID,
                    stopName: fbStop.stopName || "Unknown Stop Name",
                    direction: fbStop.direction || ""
                });
            }
        });

        const closedSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_CLOSED_STOPS));
        if (closedSnap.exists()) {
            const fbClosed = closedSnap.val();
            for(const id_key in fbClosed) {
                if(fbClosed[id_key]===true) closedStopIDs.push(id_key.toUpperCase());
            }
        }

        const globalColoursSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS));
        if (globalColoursSnap.exists()) globalCustomRouteColours = globalColoursSnap.val() || {};

        const stopSpecificColoursSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS));
        if (stopSpecificColoursSnap.exists()) stopSpecificRouteColours = stopSpecificColoursSnap.val() || {};

        msg = `Data loaded. Working schedule now contains ${currentWorkingSchedule.length} total items (schedule entries + stop definitions). ${closedStopIDs.length} closed stops identified.`;
    } catch (error) {
        msg = "Error loading data from Firebase: " + error.message;
        currentWorkingSchedule = [];
    }
    if (fileStatusElement) fileStatusElement.textContent = msg;

    if (typeof compileEffectiveRouteColoursForTools === 'function') compileEffectiveRouteColoursForTools();
    renderUIDependentElements();
    updateStagingStatusDisplay();
    if (typeof fetchBankHolidaysForSetup === 'function') fetchBankHolidaysForSetup();
}

async function updateStagingStatusDisplay() {
    let pTime = null;
    let lTime = null;
    let fbStatus = "Checking Firebase status...";
    let currentFbSt = 'unknown';

    if (applyNowButton) applyNowButton.disabled = true;

    if (window.firebaseOMSI && window.firebaseOMSI.database) {
        const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
        try {
            const pSnap = await dbGet(dbChild(dbRef(database), FB_PATH_PENDING_TIMESTAMP));
            if (pSnap.exists()) pTime = pSnap.val();

            const lSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_LAST_UPDATED));
            if (lSnap.exists()) lTime = lSnap.val();

            const sSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_STATUS));
            currentFbSt = sSnap.exists() ? sSnap.val() : 'unknown';
            fbStatus = `Firebase status: ${currentFbSt}.`;

            if (applyNowButton) applyNowButton.disabled = !(currentFbSt === 'update_staged' && pTime);

        } catch (error) {
            fbStatus = "Error checking Firebase Status.";
            if (applyNowButton) applyNowButton.disabled = true;
        }
    } else {
        fbStatus = "Firebase not available.";
        if (applyNowButton) applyNowButton.disabled = true;
    }

    let msg = "";
    if (currentFbSt === 'update_staged' && pTime) {
        msg = `A schedule was STAGED on: ${new Date(pTime).toLocaleString()}.<br>It is ready to 'Apply Staged Live NOW'.`;
        if(stagingStatusMessage) stagingStatusMessage.style.color = "#2ecc71";
    } else {
        msg = "No schedule is currently staged. Any changes made can be staged for future application.";
        if(stagingStatusMessage) stagingStatusMessage.style.color = "#f1c40f";
    }
    msg += lTime ? `<br>The LIVE schedule was last updated: ${new Date(lTime).toLocaleString()}` : "<br>The LIVE schedule has not been set yet.";
    msg += `<br><small>(${fbStatus})</small>`;

    if(stagingStatusMessage) stagingStatusMessage.innerHTML = msg;
}

function saveClosedStopsToFirebase() {
    if (!currentUser) return;
    if (window.firebaseOMSI && window.firebaseOMSI.database) {
        const { database, dbRef, dbUpdate } = window.firebaseOMSI;
        const fbClosedObject = {};
        closedStopIDs.forEach(id => fbClosedObject[id.toUpperCase()] = true);

        const updates = {};
        updates[FB_PATH_APPSTATE_CLOSED_STOPS] = fbClosedObject;
        dbUpdate(dbRef(database), updates)
            .then(() => {
                if (masterStopListStatus_SM && document.getElementById('stop-management-tool-section')?.style.display === 'block') {
                    masterStopListStatus_SM.textContent = "Stop status updated in Firebase.";
                    setTimeout(() => {
                        if(masterStopListStatus_SM && masterStopListUL_SM) masterStopListStatus_SM.textContent = `Showing ${masterStopListUL_SM.children.length} of ${uniqueStopsMasterList_SM.length} unique stops.`;
                    }, 2000);
                }
                populateMasterStopList_SM();
            })
            .catch(error => {
                if (masterStopListStatus_SM) masterStopListStatus_SM.textContent = "Error saving stop status to Firebase.";
            });
    }
}

function saveGlobalCustomRouteColours() {
    if (!currentUser) return;
    if (window.firebaseOMSI && window.firebaseOMSI.database) {
        const { database, dbSet, dbRef } = window.firebaseOMSI;
        dbSet(dbRef(database, FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS), globalCustomRouteColours)
            .catch(e => {});
    }
    if (routeColourStatusMessage) {
        routeColourStatusMessage.textContent = 'Global custom colours saved.';
        setTimeout(() => { if(routeColourStatusMessage) routeColourStatusMessage.textContent = ''; }, 3000);
    }
    compileEffectiveRouteColoursForTools();
    renderGlobalCustomRouteColours();

    if(selectStopForDeparturesView?.value) displayDeparturesForSelectedStop();
    if (selectStopForSpecificRouteColour?.value) displayRoutesForSpecificColouring();
    if (document.getElementById('stop-management-tool-section')?.style.display === 'block') populateMasterStopList_SM();
}

function saveStopSpecificRouteColoursToFirebase() {
    if (!currentUser) {
        if(stopSpecificRouteColourStatusMessage) {stopSpecificRouteColourStatusMessage.textContent="Not logged in. Cannot save."; stopSpecificRouteColourStatusMessage.style.color='#e74c3c';}
        return;
    }
    if (window.firebaseOMSI && window.firebaseOMSI.database) {
        const { database, dbSet, dbRef } = window.firebaseOMSI;
        dbSet(dbRef(database, FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS), stopSpecificRouteColours)
            .then(() => {
                if(stopSpecificRouteColourStatusMessage){
                    stopSpecificRouteColourStatusMessage.textContent='Stop-specific colours saved successfully.';
                    stopSpecificRouteColourStatusMessage.style.color='#2ecc71';
                    setTimeout(()=>{if(stopSpecificRouteColourStatusMessage)stopSpecificRouteColourStatusMessage.textContent='';},3000);
                }
                compileEffectiveRouteColoursForTools();
                renderStopSpecificRouteColours();
                if (selectStopForSpecificRouteColour?.value) displayRoutesForSpecificColouring();
                if (document.getElementById('stop-management-tool-section')?.style.display==='block') populateMasterStopList_SM();
                if (selectStopForDeparturesView?.value) displayDeparturesForSelectedStop();
            })
            .catch(error => {
                if(stopSpecificRouteColourStatusMessage){
                    stopSpecificRouteColourStatusMessage.textContent='Error saving stop-specific colours: ' + error.message;
                    stopSpecificRouteColourStatusMessage.style.color='#e74c3c';
                }
            });
    } else {
        if(stopSpecificRouteColourStatusMessage){
            stopSpecificRouteColourStatusMessage.textContent='Firebase not available. Cannot save.';
            stopSpecificRouteColourStatusMessage.style.color='#e74c3c';
        }
    }
}


// --- UI Population & Rendering ---
function setGlobalRouteColour(colour) { if (inputRouteColour) inputRouteColour.value = colour; }
function setStopSpecificRouteColour(colour) { if (inputStopSpecificRouteColour) inputStopSpecificRouteColour.value = colour; }

function renderUIDependentElements() {
    if(currentUser) {
        populateRouteSelectorForColours();
        populateStopSelectorForSpecificColours();
        populateStopSelectorForDeparturesView();
        renderGlobalCustomRouteColours();
        renderStopSpecificRouteColours();
        populateConsolidateStopSelect();

        const activeSectionId = localStorage.getItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        if (activeSectionId) {
            const sectionElement = document.getElementById(activeSectionId);
            if (sectionElement && sectionElement.style.display === 'block') {
                if (activeSectionId === 'bulk-edit-tools-section') {
                    if (selectStopForSpecificRouteColour?.value) displayRoutesForSpecificColouring();
                } else if (activeSectionId === 'view-departures-section') {
                    if(selectStopForDeparturesView?.value) displayDeparturesForSelectedStop();
                } else if (activeSectionId === 'stop-management-tool-section') {
                    populateMasterStopList_SM();
                }
                else if (activeSectionId === 'operating-profiles-section') {
                    displayUniqueOperatingProfiles();
                    displayReferenceOperatingProfiles();
                }
            }
        }
    } else {
        const allSelects = document.querySelectorAll('select');
        allSelects.forEach(sel => {
            const firstOptionText = sel.options[0] ? sel.options[0].textContent : "-- Select --";
            const firstOptionValue = sel.options[0] ? sel.options[0].value : "";
            sel.innerHTML = `<option value="${firstOptionValue}">${firstOptionText}</option>`;
        });

        if(currentRouteColoursList) currentRouteColoursList.innerHTML = "";
        if(noCustomColoursMessage) noCustomColoursMessage.style.display = 'block';
        if(currentStopSpecificColoursList) currentStopSpecificColoursList.innerHTML = "";
        if(noStopSpecificColoursMessageEl) noStopSpecificColoursMessageEl.style.display = 'block';
        if(stopDeparturesList) stopDeparturesList.innerHTML = "";
        if(noDeparturesForStopMessage) noDeparturesForStopMessage.style.display = 'block';
        if(masterStopListUL_SM) masterStopListUL_SM.innerHTML = "";
        if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = 'Please log in to view stops.';
        if(duplicateEntriesResults) duplicateEntriesResults.innerHTML = '<p>Please log in to detect duplicates.</p>';
    }
}


function compileEffectiveRouteColoursForTools() { /* Placeholder */ }

function renderGlobalCustomRouteColours() {
    if (!currentRouteColoursList || !noCustomColoursMessage) return;
    currentRouteColoursList.innerHTML = '';
    const routes = Object.keys(globalCustomRouteColours).sort(compareLineNames);
    let hasTrueCustoms = routes.length > 0;

    if (!hasTrueCustoms && Object.keys(initialRouteColourMapForTools).every(key => !globalCustomRouteColours[key.toUpperCase()])) {
        noCustomColoursMessage.textContent = 'No global custom colours. Using initial defaults or system default.';
        noCustomColoursMessage.style.display = 'block';
    } else {
        noCustomColoursMessage.style.display = 'none';
    }

    const allDisplayableGlobalRoutes = [...new Set([...Object.keys(initialRouteColourMapForTools).map(k => k.toUpperCase()), ...Object.keys(globalCustomRouteColours).map(k => k.toUpperCase())])].sort(compareLineNames);

    allDisplayableGlobalRoutes.forEach(rName => {
        const isCustom = globalCustomRouteColours.hasOwnProperty(rName);
        let color = globalCustomRouteColours[rName] || initialRouteColourMapForTools[rName] || DEFAULT_ROUTE_COLOUR_TOOLS;

        if (typeof color !== 'string' || !color.startsWith('#')) {
            console.warn(`Route: ${rName} has an invalid color value in globalCustomRouteColours:`, globalCustomRouteColours[rName], "Using default color instead.");
            color = DEFAULT_ROUTE_COLOUR_TOOLS;
        }

        const li = document.createElement('li');
        li.style.display = 'flex';
        li.style.alignItems = 'center';
        li.style.justifyContent = 'space-between';

        const box = document.createElement('span');
        box.className = 'colour-preview-box';
        box.style.backgroundColor = color;

        const info = document.createElement('span');
        info.className = 'route-info';
        let statusText = isCustom ? "" : ` <small style="opacity:0.7;">(Initial Default)</small>`;
        if (!isCustom && !initialRouteColourMapForTools[rName]) {
            statusText = ` <small style="opacity:0.7;">(System Default)</small>`;
        }

        info.innerHTML = `Route: ${rName} - Colour: ${color.toUpperCase()}${statusText}`;

        const actions = document.createElement('div');
        if (isCustom) {
            const btn = document.createElement('button');
            btn.textContent = 'Remove Global';
            btn.classList.add('button', 'small-action', 'secondary');
            btn.addEventListener('click', () => handleRemoveGlobalRouteColour(rName));
            actions.appendChild(btn);
        }
        li.appendChild(box);
        li.appendChild(info);
        li.appendChild(actions);
        currentRouteColoursList.appendChild(li);
    });
}

function populateRouteSelectorForColours() {
    if (!selectRouteNameColour) return;
    const currentVal = selectRouteNameColour.value;
    selectRouteNameColour.innerHTML = '<option value="">-- Select Route --</option>';
    const lines = [...new Set(currentWorkingSchedule.map(e => e.lineName))]
                  .filter(Boolean)
                  .sort(compareLineNames);
    lines.forEach(ln => {
        const opt = document.createElement('option');
        opt.value = ln; opt.textContent = ln;
        selectRouteNameColour.appendChild(opt);
    });
    if (lines.includes(currentVal)) {
        selectRouteNameColour.value = currentVal;
    }
    selectRouteNameColour.dispatchEvent(new Event('change'));
}

function handleSaveGlobalRouteColour() {
    if (!currentUser) return; if (!selectRouteNameColour || !inputRouteColour || !routeColourStatusMessage) return;
    const rName = selectRouteNameColour.value; const color = inputRouteColour.value;
    if (!rName) { routeColourStatusMessage.textContent = 'Select route.'; routeColourStatusMessage.style.color = '#e74c3c'; return; }
    if (!color.match(/^#[0-9a-fA-F]{6}$/)) { routeColourStatusMessage.textContent = 'Invalid hex (e.g., #RRGGBB).'; routeColourStatusMessage.style.color = '#e74c3c'; return; }
    globalCustomRouteColours[rName.toUpperCase()] = color.toUpperCase(); saveGlobalCustomRouteColours();
}
function handleRemoveGlobalRouteColour(key) {
    if (!currentUser) return; if (globalCustomRouteColours.hasOwnProperty(key) && confirm(`Remove GLOBAL custom colour for ${key}?`)) {
        delete globalCustomRouteColours[key]; saveGlobalCustomRouteColours();
        if (selectRouteNameColour.value.toUpperCase() === key) {
            inputRouteColour.value = initialRouteColourMapForTools[key] || DEFAULT_ROUTE_COLOUR_TOOLS;
        }
    }
}

// --- START: Stop-Specific Route Colour Functions ---
function populateStopSelectorForSpecificColours() {
    if (!selectStopForSpecificRouteColour) return; const currentVal = selectStopForSpecificRouteColour.value;
    selectStopForSpecificRouteColour.innerHTML = '<option value="">-- Select Stop --</option>';
    const uniqueStops = getUniqueStopsFromSchedule();
    if (uniqueStops.length === 0) {
        selectStopForSpecificRouteColour.innerHTML = '<option value="">-- No Stops in Schedule --</option>';
        displayRoutesForSpecificColouring();
        return;
    }
    uniqueStops.forEach(stop => {
        const opt=document.createElement('option');
        opt.value=stop.stopID; opt.textContent=`${stop.stopName} (${stop.stopID})`;
        selectStopForSpecificRouteColour.appendChild(opt);
    });
    if (uniqueStops.find(s => s.stopID === currentVal)) {
        selectStopForSpecificRouteColour.value = currentVal;
    }
    displayRoutesForSpecificColouring();
}

function displayRoutesForSpecificColouring() {
    if (!specificRouteColourTilesContainer || !specificRouteColourTilesPlaceholder) return;
    if (deleteRouteFromStopButton) deleteRouteFromStopButton.style.display = 'none';
    if (deleteRouteFromStopStatusMessage) deleteRouteFromStopStatusMessage.textContent = '';

    const selectedStopID = selectStopForSpecificRouteColour.value;
    specificRouteColourTilesContainer.innerHTML = '';

    if (!selectedStopID) {
        specificRouteColourTilesPlaceholder.textContent = 'Select a stop to see its routes.';
        specificRouteColourTilesPlaceholder.style.display = 'block';
        return;
    }

    const servingRoutes = new Set();
    currentWorkingSchedule.forEach(e => {
        if (e.stopID === selectedStopID && e.lineName) servingRoutes.add(e.lineName);
    });
    const sortedRoutes = Array.from(servingRoutes).sort(compareLineNames);

    if (sortedRoutes.length === 0) {
        specificRouteColourTilesPlaceholder.textContent = `No routes found serving stop ${selectedStopID}.`;
        specificRouteColourTilesPlaceholder.style.display = 'block';
    } else {
        specificRouteColourTilesPlaceholder.style.display = 'none';
        sortedRoutes.forEach(lineName => {
            const tile = document.createElement('span');
            tile.classList.add('route-tile-tools-list', 'specific-colour-route-tile');
            tile.textContent=lineName; tile.dataset.lineName=lineName;
            const bgColor = getRouteTileColourForTools(lineName, selectedStopID);
            tile.style.backgroundColor=bgColor;
            tile.style.color=getTextColourForBackgroundTools(bgColor);
            tile.setAttribute('role','checkbox'); tile.setAttribute('aria-checked','false'); tile.setAttribute('tabindex','0');

            tile.addEventListener('click', () => {
                const isSelected = tile.classList.toggle('selected-for-color-edit');
                tile.setAttribute('aria-checked',isSelected.toString());
                const selTiles = specificRouteColourTilesContainer.querySelectorAll('.specific-colour-route-tile.selected-for-color-edit');
                if (deleteRouteFromStopButton) {
                    if(selTiles.length===1){
                        deleteRouteFromStopButton.style.display='inline-block';
                        deleteRouteFromStopButton.dataset.selectedRouteName=selTiles[0].dataset.lineName;
                    } else {
                        deleteRouteFromStopButton.style.display='none';
                        delete deleteRouteFromStopButton.dataset.selectedRouteName;
                    }
                }
                if (deleteRouteFromStopStatusMessage) deleteRouteFromStopStatusMessage.textContent = '';
            });
            tile.addEventListener('keydown', (event) => { if (event.key===' '||event.key==='Enter'){event.preventDefault(); tile.click();}});
            specificRouteColourTilesContainer.appendChild(tile);
        });
    }
}

function handleDeleteRouteFromSpecificStop() {
    if (!currentUser) { alert("Log in."); if(deleteRouteFromStopStatusMessage) deleteRouteFromStopStatusMessage.textContent="Not logged in."; return; }
    const selectedStopID = selectStopForSpecificRouteColour.value;
    const lineNameToDelete = deleteRouteFromStopButton.dataset.selectedRouteName;

    if (!selectedStopID || !lineNameToDelete) {
        if(deleteRouteFromStopStatusMessage){
            deleteRouteFromStopStatusMessage.textContent="No stop/route selected (ensure exactly one route tile is selected for deletion).";
            deleteRouteFromStopStatusMessage.style.color='#f1c40f';
        }
        return;
    }

    if (!confirm(`Are you sure you want to delete ALL schedule entries for route "${lineNameToDelete}" ONLY from stop "${selectedStopID}"?\nThis will also remove any specific colour override for this route at this stop.\nThis action CANNOT BE UNDONE easily.`)) {
        if(deleteRouteFromStopStatusMessage){ deleteRouteFromStopStatusMessage.textContent="Deletion cancelled."; deleteRouteFromStopStatusMessage.style.color='#7f8c8d'; }
        return;
    }

    let originalScheduleLength = currentWorkingSchedule.length;
    currentWorkingSchedule = currentWorkingSchedule.filter(e => !(e.stopID === selectedStopID && e.lineName && e.lineName.toUpperCase() === lineNameToDelete.toUpperCase()));
    let scheduleEntriesRemovedCount = originalScheduleLength - currentWorkingSchedule.length;
    let colourOverrideRemoved = false;

    if (stopSpecificRouteColours[selectedStopID] && stopSpecificRouteColours[selectedStopID][lineNameToDelete.toUpperCase()]) {
        delete stopSpecificRouteColours[selectedStopID][lineNameToDelete.toUpperCase()];
        colourOverrideRemoved = true;
        if (Object.keys(stopSpecificRouteColours[selectedStopID]).length === 0) {
            delete stopSpecificRouteColours[selectedStopID];
        }
        saveStopSpecificRouteColoursToFirebase();
    }

    if (deleteRouteFromStopStatusMessage) {
        deleteRouteFromStopStatusMessage.textContent = `Route "${lineNameToDelete}" deleted from stop "${selectedStopID}". ${scheduleEntriesRemovedCount} schedule entries removed. ${colourOverrideRemoved?'Specific colour override also removed.':''}`;
        deleteRouteFromStopStatusMessage.style.color = '#2ecc71';
    }

    if(deleteRouteFromStopButton) {
        deleteRouteFromStopButton.style.display = 'none';
        delete deleteRouteFromStopButton.dataset.selectedRouteName;
    }
    displayRoutesForSpecificColouring();
    renderUIDependentElements();
    updateStagingStatusDisplay();
}

function handleSaveStopSpecificRouteColour() {
    if (!currentUser) { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent="Not logged in.";stopSpecificRouteColourStatusMessage.style.color='#e74c3c';} return; }
    const selectedStopID = selectStopForSpecificRouteColour.value;
    if (!selectedStopID) { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent="Select stop.";stopSpecificRouteColourStatusMessage.style.color='#f1c40f';} return; }

    const selectedTiles = specificRouteColourTilesContainer.querySelectorAll('.specific-colour-route-tile.selected-for-color-edit');
    if (selectedTiles.length === 0) { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent="Select route tile(s) to apply colour.";stopSpecificRouteColourStatusMessage.style.color='#f1c40f';} return; }

    const newColour = inputStopSpecificRouteColour.value;
    if (!newColour.match(/^#[0-9a-fA-F]{6}$/)) { if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent='Invalid hex colour (e.g., #RRGGBB).';stopSpecificRouteColourStatusMessage.style.color='#e74c3c';} return; }

    if (!stopSpecificRouteColours[selectedStopID]) stopSpecificRouteColours[selectedStopID] = {};

    let routesUpdated = [];
    selectedTiles.forEach(tile => {
        const lineName = tile.dataset.lineName;
        if(lineName){
            stopSpecificRouteColours[selectedStopID][lineName.toUpperCase()]=newColour.toUpperCase();
            routesUpdated.push(lineName);
        }
    });

    if (routesUpdated.length > 0) {
        saveStopSpecificRouteColoursToFirebase();
        selectedTiles.forEach(tile => tile.classList.remove('selected-for-color-edit'));

        const stillSelTiles = specificRouteColourTilesContainer.querySelectorAll('.specific-colour-route-tile.selected-for-color-edit');
        if(deleteRouteFromStopButton){
            if(stillSelTiles.length===1){
                deleteRouteFromStopButton.style.display='inline-block';
                deleteRouteFromStopButton.dataset.selectedRouteName=stillSelTiles[0].dataset.lineName;
            } else {
                deleteRouteFromStopButton.style.display='none';
                delete deleteRouteFromStopButton.dataset.selectedRouteName;
            }
        }
         if(stopSpecificRouteColourStatusMessage) {
            stopSpecificRouteColourStatusMessage.textContent = `Colour ${newColour} applied to ${routesUpdated.join(', ')} at stop ${selectedStopID}.`;
            stopSpecificRouteColourStatusMessage.style.color = '#2ecc71';
        }
    } else {
        if(stopSpecificRouteColourStatusMessage){stopSpecificRouteColourStatusMessage.textContent="No routes were selected or updated.";stopSpecificRouteColourStatusMessage.style.color='#e74c3c';}
    }
}

function renderStopSpecificRouteColours() {
    if (!currentStopSpecificColoursList || !noStopSpecificColoursMessageEl) return; currentStopSpecificColoursList.innerHTML = '';
    const stopIDsWithOverrides = Object.keys(stopSpecificRouteColours).filter(stopID => stopSpecificRouteColours[stopID] && Object.keys(stopSpecificRouteColours[stopID]).length > 0)
        .sort((a,b)=>{
            const stopA=getUniqueStopsFromSchedule().find(s=>s.stopID===a);
            const stopB=getUniqueStopsFromSchedule().find(s=>s.stopID===b);
            const nameA=stopA?stopA.stopName.toLowerCase():a.toLowerCase();
            const nameB=stopB?stopB.stopName.toLowerCase():b.toLowerCase();
            if(nameA<nameB)return -1; if(nameA>nameB)return 1; return 0;
        });

    if (stopIDsWithOverrides.length === 0) {
        noStopSpecificColoursMessageEl.textContent = 'No stop-specific colour overrides are currently set.';
        noStopSpecificColoursMessageEl.style.display = 'block'; return;
    }
    noStopSpecificColoursMessageEl.style.display = 'none';

    stopIDsWithOverrides.forEach(stopID => {
        const stopDetails = getUniqueStopsFromSchedule().find(s => s.stopID === stopID);
        const stopDisplayName = stopDetails ? `${stopDetails.stopName} (${stopID})` : stopID;

        const stopGroupTitle = document.createElement('h4');
        stopGroupTitle.className='stop-group-title'; stopGroupTitle.textContent=`Stop: ${stopDisplayName}`;
        currentStopSpecificColoursList.appendChild(stopGroupTitle);

        const routesListUl = document.createElement('ul');
        const routesForThisStop = stopSpecificRouteColours[stopID];
        Object.keys(routesForThisStop).sort(compareLineNames).forEach(lineName => {
            const color = routesForThisStop[lineName];
            const li = document.createElement('li');
            li.style.display='flex'; li.style.alignItems='center'; li.style.justifyContent='space-between';

            const box = document.createElement('span'); box.className='colour-preview-box'; box.style.backgroundColor=color;
            const info = document.createElement('span'); info.className='route-info';
            info.textContent=`Route: ${lineName} - Colour: ${color.toUpperCase()}`;

            const actions = document.createElement('div');
            const removeBtn = document.createElement('button');
            removeBtn.textContent='Remove Override'; removeBtn.classList.add('button','small-action','secondary');
            removeBtn.addEventListener('click', () => handleRemoveStopSpecificRouteColour(stopID, lineName));
            actions.appendChild(removeBtn);

            li.appendChild(box); li.appendChild(info); li.appendChild(actions);
            routesListUl.appendChild(li);
        });
        currentStopSpecificColoursList.appendChild(routesListUl);
    });
}

function handleRemoveStopSpecificRouteColour(stopID, lineName) {
    if (!currentUser) return;
    if (stopSpecificRouteColours[stopID] && stopSpecificRouteColours[stopID][lineName]) {
        if (confirm(`Remove specific colour override for route ${lineName} at stop ${stopID}?`)) {
            delete stopSpecificRouteColours[stopID][lineName];
            if (Object.keys(stopSpecificRouteColours[stopID]).length === 0) {
                delete stopSpecificRouteColours[stopID];
            }
            saveStopSpecificRouteColoursToFirebase();
        }
    }
}
// --- END: Stop-Specific Route Colour Functions ---

function getRouteTileColourForTools(lineName, stopID = null) {
    const upName = String(lineName || "").toUpperCase();
    if (stopID && stopSpecificRouteColours[stopID.toUpperCase()] && stopSpecificRouteColours[stopID.toUpperCase()][upName]) {
        return stopSpecificRouteColours[stopID.toUpperCase()][upName];
    }
    if (globalCustomRouteColours[upName]) {
        return globalCustomRouteColours[upName];
    }
    if (initialRouteColourMapForTools[upName]) {
        return initialRouteColourMapForTools[upName];
    }
    if (upName.startsWith("N")) return globalCustomRouteColours["NIGHT_DEFAULT"] || initialRouteColourMapForTools["NIGHT_DEFAULT"] || NIGHT_BUS_BLUE_COLOR;
    if (upName.startsWith("SL")) return globalCustomRouteColours["SL_DEFAULT"] || initialRouteColourMapForTools["SL_DEFAULT"] || "#D32F2F";
    return DEFAULT_ROUTE_COLOUR_TOOLS;
}

function getTextColourForBackgroundTools(hex) {
    if(!hex || hex.length < 7) return '#FFFFFF';
    const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
    return ((0.299*r + 0.587*g + 0.114*b)/255) > 0.5 ? '#000000' : '#FFFFFF';
}

function getDaySortOrder(profile) {
    if (!profile) return 9999;
    const p = profile.toUpperCase().replace(/\s+/g, '');
    const has = (keywords) => keywords.some(kw => p.includes(kw));
    let baseScore = 9000;
    if (has(["MONDAY", "MO"])) baseScore = 100;
    else if (has(["TUESDAY", "TU"])) baseScore = 200;
    else if (has(["WEDNESDAY", "WE"])) baseScore = 300;
    else if (has(["THURSDAY", "TH"])) baseScore = 400;
    else if (has(["FRIDAY", "FR"]) && !has(["GOODFRIDAY"])) baseScore = 500;
    else if (has(["MON-FRI", "MONTOFRI", "WEEKDAY", "MF"])) baseScore = 600;
    else if (has(["SATURDAY", "SA"])) baseScore = 700;
    else if (has(["SUNDAY", "SU"])) baseScore = 800;
    if (has(["GOODFRIDAY"])) return 850;
    if (has(["BANKHOLIDAY", "BANKHOL"])) return 910;
    if (has(["CHRISTMAS"])) return 920;
    if (has(["BOXINGDAY"])) return 930;
    if (has(["NEWYEAR"])) return 940;
    if (baseScore < 9000) {
        if (has(["SCH"])) return baseScore + 1;
        if (has(["NSD"])) return baseScore + 2;
        if (has(["SCHOOLHOLIDAY"]) && !has(["SUNDAY","SU"])) return baseScore + 3;
        return baseScore;
    }
    if (has(["SCHOOLHOLIDAY"])) return 950;
    if (profile.includes(',')) {
        const parts = profile.split(',');
        let minScoreForParts = 9999;
        for (const part of parts) {
            minScoreForParts = Math.min(minScoreForParts, getDaySortOrder(part.trim()));
        }
        return minScoreForParts;
    }
    return baseScore;
}

function populateStopSelectorForDeparturesView() {
    if (!selectStopForDeparturesView) return;
    const currentVal = selectStopForDeparturesView.value;
    selectStopForDeparturesView.innerHTML = '<option value="">-- Select Stop --</option>';

    if (currentWorkingSchedule.length === 0) {
        selectStopForDeparturesView.innerHTML = '<option value="">-- No Stops Loaded --</option>';
        displayDeparturesForSelectedStop();
        return;
    }

    const stopsMap = new Map();
    currentWorkingSchedule.forEach(e => {
        if (e.stopID && !stopsMap.has(e.stopID.toUpperCase())) {
            stopsMap.set(e.stopID.toUpperCase(), { stopID: e.stopID, stopName: e.stopName || e.stopID });
        }
    });
    const sorted = Array.from(stopsMap.values()).sort((a,b)=>(a.stopName.toLowerCase()).localeCompare(b.stopName.toLowerCase()));

    sorted.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s.stopID; opt.textContent = `${s.stopName} (${s.stopID})`;
        selectStopForDeparturesView.appendChild(opt);
    });

    if (stopsMap.has(currentVal.toUpperCase())) {
        selectStopForDeparturesView.value = currentVal;
    }
    displayDeparturesForSelectedStop();
}

function displayDeparturesForSelectedStop() {
    if (!selectStopForDeparturesView || !stopDeparturesList || !noDeparturesForStopMessage) return;
    const selStopID = selectStopForDeparturesView.value;
    stopDeparturesList.innerHTML = '';

    if (!selStopID) {
        noDeparturesForStopMessage.textContent = 'Select a stop to view its scheduled departures.';
        noDeparturesForStopMessage.style.display = 'block';
        return;
    }

    const deps = currentWorkingSchedule.filter(e => e.stopID === selStopID).sort((a,b) => {
        const offsetA=parseInt(a.DayOffset||"0",10); const offsetB=parseInt(b.DayOffset||"0",10);
        if(offsetA!==offsetB)return offsetA-offsetB;
        const dayA=getDaySortOrder(a.OperatingProfile); const dayB=getDaySortOrder(b.OperatingProfile);
        if(dayA!==dayB)return dayA-dayB;
        const timeA=(a.scheduledTime||"99:99").replace(':','');
        const timeB=(b.scheduledTime||"99:99").replace(':','');
        if(timeA!==timeB)return timeA.localeCompare(timeB);
        const lineComp=compareLineNames(a.lineName,b.lineName);
        if(lineComp!==0)return lineComp;
        return (a.OperatingProfile||"").localeCompare(b.OperatingProfile||"");
    });

    if (deps.length === 0) {
        noDeparturesForStopMessage.textContent = 'No scheduled departures found for this stop in the current working schedule.';
        noDeparturesForStopMessage.style.display = 'block';
    } else {
        noDeparturesForStopMessage.style.display = 'none';
        deps.forEach(d => {
            const li=document.createElement('li');
            const tile=document.createElement('span');
            tile.className='route-tile-tools-list';
            tile.textContent=d.lineName||'N/A';
            const bg=getRouteTileColourForTools(d.lineName,selStopID);
            tile.style.backgroundColor=bg; tile.style.color=getTextColourForBackgroundTools(bg);
            const span=document.createElement('span');
            span.innerHTML=` to ${d.destinationName||'Unknown Destination'} <strong style="margin-left:0.5em;">at ${d.scheduledTime||'N/A'}</strong> <small style="opacity:0.7;margin-left:0.75em;">(Profile: ${d.OperatingProfile||'N/A'})</small>${d.DayOffset&&d.DayOffset!=="0"?`<small style="opacity:0.7;margin-left:0.3em;color:#FFD700;">(+${d.DayOffset}d)</small>`:''}`;
            li.appendChild(tile); li.appendChild(span);
            stopDeparturesList.appendChild(li);
        });
    }
}


// --- Stop Management Tool Functions (SM) ---
function getUniqueStopsFromSchedule() {
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) return [];
    const stopsMap = new Map();
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && !stopsMap.has(entry.stopID.toUpperCase())) {
            stopsMap.set(entry.stopID.toUpperCase(), {
                stopID: entry.stopID,
                stopName: entry.stopName || "Unknown Name",
                direction: entry.direction || "No Direction"
            });
        }
    });
    return Array.from(stopsMap.values()).sort((a,b)=>(String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase()));
}

// Placeholder functions for SM tool; actual implementation would be more complex and is not fully provided here
// These are simplified based on what was in the original file, but might be part of a larger SM tool not fully included.
const masterStopListUL_SM = null; // Assuming not fully implemented in this context
const masterStopListStatus_SM = null;
const masterStopListFilterInput_SM = null;
const uniqueStopsMasterList_SM = [];
const findStopIdScheduleInput_SM = null;
const replaceStopIdScheduleInput_SM = null;
const findReplaceStatusMessage_SM = null;
const inputNewStopId_ARS = null; // Assuming from an "Add/Remove Stop" section not fully shown
const selectNewStopIdFormat_ARS = null;
const inputNewStopName_ARS = null;
const inputNewStopDirection_ARS = null;
const addNewStopStatus_ARS = null;
const newStopIdAvailability_ARS = null;
const selectStopToRemove_ARS = null;
const removeStopStatus_ARS = null;
const selectGlobalRouteToDelete = null; // For global route deletion tool not fully shown
const deleteEntireRouteStatusMessage = null;


function populateMasterStopList_SM() { /* Placeholder based on original file */ }
function handleEditStop_SM(stopID, currentName, currentDirection) { /* Placeholder */ }
function handleDeleteStop_SM(stopIdToRemove) { /* Placeholder */ }
function handleToggleStopStatus_SM(stopID) { /* Placeholder */ }
function handleFindReplaceStopIdInSchedule_SM() { /* Placeholder */ }


// --- START: Auto Apply Scheduler ---
function initializeAutoApplyScheduler() {
    if(autoApplyIntervalId) clearInterval(autoApplyIntervalId);
    autoApplyIntervalId = setInterval(checkForAutoApply, 60 * 1000);
}

function stopAutoApplyScheduler() {
    if(autoApplyIntervalId){
        clearInterval(autoApplyIntervalId);
        autoApplyIntervalId=null;
    }
}

async function checkForAutoApply() {
    if (!currentUser) return;

    const now=new Date();
    const day=now.getDay();
    const hour=now.getHours();
    const currentISODate=now.toISOString().split('T')[0];

    const AUTO_APPLY_DAY = 6;
    const AUTO_APPLY_HOUR = 3;

    if (day===AUTO_APPLY_DAY && hour===AUTO_APPLY_HOUR) {
        const flagKey = `autoApplied_${AUTO_APPLY_DAY}_${AUTO_APPLY_HOUR}_${currentISODate}`;
        if (sessionStorage.getItem(flagKey)==='true') {
            return;
        }

        if (window.firebaseOMSI && window.firebaseOMSI.database) {
            const {database,dbGet,dbRef,dbChild}=window.firebaseOMSI;
            try {
                const statusSnapshot=await dbGet(dbChild(dbRef(database),FB_PATH_APPSTATE_STATUS));
                const pendingTimestampSnapshot=await dbGet(dbChild(dbRef(database),FB_PATH_PENDING_TIMESTAMP));

                const currentFbStatus = statusSnapshot.exists()?statusSnapshot.val():'unknown';
                const pendingTimestamp = pendingTimestampSnapshot.exists()?pendingTimestampSnapshot.val():null;

                if(currentFbStatus==='update_staged' && pendingTimestamp){
                    const originalConfirm=window.confirm;
                    window.confirm=(message)=>{ return true; };
                    handleApplyNow();
                    window.confirm=originalConfirm;
                    sessionStorage.setItem(flagKey,'true');
                } else {
                    sessionStorage.setItem(flagKey,'true');
                }
            } catch(error){
                // Error during auto apply
            }
        }
    } else {
        const T24_HOURS_AGO=new Date(now.getTime()-(24*60*60*1000));
        const yesterdayISODate=T24_HOURS_AGO.toISOString().split('T')[0];
        const oldFlagKey=`autoApplied_${AUTO_APPLY_DAY}_${AUTO_APPLY_HOUR}_${yesterdayISODate}`;
        if(sessionStorage.getItem(oldFlagKey)){
            sessionStorage.removeItem(oldFlagKey);
        }
    }
}
// --- END: Auto Apply Scheduler ---


// --- Event Listeners & Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    if (adminLoginSection) adminLoginSection.style.display = 'block';
    if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'none';
    if (topMenuBar) topMenuBar.style.display = 'none';
    hideAllToolSections();

    if (refreshOperatingProfilesButton) {
        refreshOperatingProfilesButton.addEventListener('click', () => {
            displayUniqueOperatingProfiles();
            displayReferenceOperatingProfiles();
        });
    }

    const allMainMenuButtons = document.querySelectorAll('#main-menu-buttons .menu-button');
    allMainMenuButtons.forEach(button => {
        button.addEventListener('click', () => {
            const sectionId = button.getAttribute('data-section');
            if (currentUser && sectionId) {
                showSection(sectionId);
            } else if (!currentUser) {
                alert("Please log in to access this section.");
            }
        });
    });

    if(detectDuplicatesButton) detectDuplicatesButton.addEventListener('click', detectDuplicateEntries);
    if(removeDuplicateEntriesButton) removeDuplicateEntriesButton.addEventListener('click', handleRemoveDuplicateEntries);
    if(consolidateOperatingDaysButton) consolidateOperatingDaysButton.addEventListener('click', handleConsolidateOperatingDays);
    if(consolidateStopSelect) consolidateStopSelect.addEventListener('change', populateConsolidateRouteSelect);

    const inputNewStopId_ARS_El = document.getElementById('inputNewStopId_ARS');
    const newStopIdAvailability_ARS_El = document.getElementById('newStopIdAvailability_ARS');
    if (inputNewStopId_ARS_El && newStopIdAvailability_ARS_El) {
        inputNewStopId_ARS_El.addEventListener('input', () => {
            const newStopId = inputNewStopId_ARS_El.value.trim().toUpperCase();
            if (!newStopId) { newStopIdAvailability_ARS_El.textContent=''; newStopIdAvailability_ARS_El.style.color=''; return; }
            if (!/^[A-Z0-9]+$/.test(newStopId)) { newStopIdAvailability_ARS_El.textContent='ID must be alphanumeric uppercase.'; newStopIdAvailability_ARS_El.style.color='#e74c3c'; return; }
            const existingStopIDs = new Set(currentWorkingSchedule.map(e=>e.stopID.toUpperCase()));
            if (existingStopIDs.has(newStopId)) {
                newStopIdAvailability_ARS_El.textContent='This Stop ID already exists.'; newStopIdAvailability_ARS_El.style.color='#e74c3c';
            } else {
                newStopIdAvailability_ARS_El.textContent='This Stop ID is available.'; newStopIdAvailability_ARS_El.style.color='#2ecc71';
            }
        });
    }

    const globalColorPresetButtons = document.querySelectorAll('.route-colour-management-subsection .button[style*="background-color"]');
    globalColorPresetButtons.forEach(button => {
        const colorMatch = button.style.backgroundColor.match(/rgb\((\d+), (\d+), (\d+)\)/);
        if (colorMatch) {
            const r = parseInt(colorMatch[1]).toString(16).padStart(2,'0');
            const g = parseInt(colorMatch[2]).toString(16).padStart(2,'0');
            const b = parseInt(colorMatch[3]).toString(16).padStart(2,'0');
            const color = `#${r}${g}${b}`.toUpperCase();
            if (color !== "#3498DB") { // Exclude the default button color if it's one of them
                 button.addEventListener('click', () => setGlobalRouteColour(color));
            }
        }
    });

    const stopSpecificColorPresetButtons = document.querySelectorAll('.stop-specific-route-colour-subsection .button[style*="background-color"]');
    stopSpecificColorPresetButtons.forEach(button => {
         const colorMatch = button.style.backgroundColor.match(/rgb\((\d+), (\d+), (\d+)\)/);
        if (colorMatch) {
            const r = parseInt(colorMatch[1]).toString(16).padStart(2,'0');
            const g = parseInt(colorMatch[2]).toString(16).padStart(2,'0');
            const b = parseInt(colorMatch[3]).toString(16).padStart(2,'0');
            const color = `#${r}${g}${b}`.toUpperCase();
             if (color !== "#3498DB" && color !== "#F39C12") { // Exclude default and tertiary button colors
                button.addEventListener('click', () => setStopSpecificRouteColour(color));
            }
        }
    });


function initializeMainAppLogic() {
    const { auth, authOnAuthStateChanged, authSignInWithEmailAndPassword, authSignOut } = window.firebaseOMSI;
    authOnAuthStateChanged(auth, (user) => updateAuthUI(user));

    if (loginButton && inputEmail && inputPassword && authStatus) {
        const adminLoginForm = document.getElementById('adminLoginForm');
        if (adminLoginForm) adminLoginForm.addEventListener('submit', (event) => {
            event.preventDefault();
            const email=inputEmail.value; const password=inputPassword.value;
            if(authStatus)authStatus.textContent='Logging in...';
            authSignInWithEmailAndPassword(auth, email, password)
                .catch((error) => {
                    if(authStatus) authStatus.textContent = `Login Error: ${error.message}`;
                });
        });
    }
    if (logoutButton) logoutButton.addEventListener('click', () => {
        localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        authSignOut(auth).catch((e) => {});
    });
}

if (window.firebaseOMSI && window.firebaseOMSI.auth) {
    initializeMainAppLogic();
} else {
    document.addEventListener('firebaseReady', () => {
        if (window.firebaseOMSI && window.firebaseOMSI.auth) {
            initializeMainAppLogic();
        } else {
            updateAuthUI(null);
            if (authStatus) authStatus.textContent = 'Critical Firebase Authentication initialization error.';
        }
    }, { once: true });
}

    if (stageScheduleButton) stageScheduleButton.addEventListener('click', handleStageSchedule);
    if (applyNowButton) applyNowButton.addEventListener('click', handleApplyNow);
    if (viewArrivalsButton) viewArrivalsButton.addEventListener('click', () => { window.location.href = "omsi_arrivals.html"; });
    if (countFileInput) countFileInput.addEventListener('change', handleCountFileUpload);

    if(bulkEditTargetLineNameInput) bulkEditTargetLineNameInput.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); });
    if(bulkUpdateRouteDestinationButton) bulkUpdateRouteDestinationButton.addEventListener('click', handleBulkUpdateRouteDestination);

    if (saveRouteColourButton) saveRouteColourButton.addEventListener('click', handleSaveGlobalRouteColour);
    if (selectRouteNameColour) selectRouteNameColour.addEventListener('change', () => {
        const selectedRoute = selectRouteNameColour.value;
        const upperSelectedRoute = selectedRoute.toUpperCase();
        if (selectedRoute && globalCustomRouteColours[upperSelectedRoute]) {
            inputRouteColour.value = globalCustomRouteColours[upperSelectedRoute];
        } else if (initialRouteColourMapForTools[upperSelectedRoute]) {
            inputRouteColour.value = initialRouteColourMapForTools[upperSelectedRoute];
        } else {
            inputRouteColour.value = DEFAULT_ROUTE_COLOUR_TOOLS;
        }
    });

    if (selectStopForSpecificRouteColour) selectStopForSpecificRouteColour.addEventListener('change', displayRoutesForSpecificColouring);
    if (saveStopSpecificRouteColourButton) saveStopSpecificRouteColourButton.addEventListener('click', handleSaveStopSpecificRouteColour);
    if (deleteRouteFromStopButton) deleteRouteFromStopButton.addEventListener('click', handleDeleteRouteFromSpecificStop);

    if (selectStopForDeparturesView) selectStopForDeparturesView.addEventListener('change', displayDeparturesForSelectedStop);

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/live-tracker/sw-omsi.js')
            .then(registration => {})
            .catch(error => {});
        });
    }
});
</script>
</body>
</html>
