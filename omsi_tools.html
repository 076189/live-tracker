<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMSI Countdown - Tools</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <link rel="manifest" href="/live-tracker/manifest-omsi.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OMSI Tools">
    <meta name="theme-color" content="#2c3e50">
    <link rel="apple-touch-icon" href="/live-tracker/assets/icons/apple-touch-icon-180x180.png">

    <style>
        @font-face {
            font-family: 'NJFont Medium Web';
            src: url('fonts/NJFont-Medium.ttf') format('truetype'); /* Relative path */
            font-weight: normal;font-style: normal;font-display: swap;
        }
        body {
            font-family: 'NJFont Medium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            margin:0;
        }
        .page-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        #top-menu-bar {
            background-color: rgba(0,0,0,0.25);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center;
            display: none; /* Hidden by default, shown after login */
        }
        .menu-button {
            cursor: pointer;
            background-color: #3498db;
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 0.25rem;
            font-size: 0.9rem;
            transition: background-color 0.2s;
            border: none;
            margin: 0.25rem;
        }
        .menu-button:hover {
            background-color: #2980b9;
        }

        .tool-content-section {
            display: none; /* All tool sections hidden by default */
        }

        #auth-section {
             margin-bottom: 1.5rem;
        }
        #current-profile-display-container {
            text-align: center;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background-color: rgba(255,255,255,0.05);
            border-radius: 0.25rem;
            display: none; /* Hidden by default, shown after login */
        }
        #current-profile-display { font-size: 0.9rem; opacity: 0.9; font-style: italic;}


        h1 { font-size: 2rem; margin-bottom: 1.5rem; font-weight: normal; text-align: center; color: #ffffff; }
        h2 { font-size: 1.5rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: normal; border-bottom: 1px solid #7f8c8d; padding-bottom: 0.25rem;}
        h3.subsection-title { font-size: 1.25rem; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: normal; color: #e0e0e0; border-bottom: 1px solid rgba(127,140,141,0.5); padding-bottom: 0.2rem;}


        .section {
            background-color: rgba(0,0,0,0.15);
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .subsection {
            background-color: rgba(0,0,0,0.1);
            padding: 1rem;
            border-radius: 0.375rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
             border: 1px solid rgba(127,140,141,0.2);
        }


        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;}
        .form-field-group { margin-bottom: 1rem; }


        label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.85rem;
            color: #bdc3c7;
        }

        input[type="text"],
        input[type="email"],
        input[type="password"],
        input[type="time"],
        input[type="color"],
        input[type="number"],
        select {
            width: 100%; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size:0.9rem;
        }
        input[type="color"] { height: 2.75rem; padding: 0.25rem; }
        #inputOperatingProfile, #analyticsOperatingProfileSelect { max-width: 100%;}
        #selectDayOffset, #selectRouteNameColour, #selectStopForDeparturesView,
        #selectStopForSpecificRouteColour,
        #selectGlobalRouteToDelete {
            max-width: 100%;
        }
        #editMasterStopIdSelect, #routesForStopSelect_SM { max-width: 100%; }
        #selectNewStopIdFormat_ARS, #selectStopToRemove_ARS {max-width: 100%;}
        #consolidateStopSelect, #consolidateRouteSelect {max-width: 100%;}
        select option { background-color: #34495e; color: #ecf0f1; }


        #inputStopID,
        #bulkEditTargetStopID, #bulkEditTargetLineName,
        #findStopIdScheduleInput, #replaceStopIdScheduleInput,
        #gen_stopId, #inputNewStopId_ARS {
            text-transform: uppercase;
        }
        #gen_lineName, #gen_destinationName, #consolidateNewProfileInput {
            text-transform: none;
        }


        .button {
            cursor: pointer; background-color: #3498db; color: white;
            padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem;
            transition: background-color 0.2s; border: none; margin-right: 0.5rem; margin-top:0.5rem;
        }
        .button:hover { background-color: #2980b9; }
        .button.small-action { padding: 0.2rem 0.4rem; font-size: 0.8rem; margin: 0 0.15rem; line-height: 1; min-width: 20px; text-align:center;}
        .button.secondary { background-color: #e74c3c; }
        .button.secondary:hover { background-color: #c0392b; }
        .button.tertiary { background-color: #f39c12; }
        .button.tertiary:hover { background-color: #e67e22; }
        .button.neutral { background-color: #7f8c8d; }
        .button.neutral:hover { background-color: #95a5a6; color: #2c3e50; }


        .file-upload-label { display: inline-block; cursor: pointer; background-color: #95a5a6; color: #2c3e50; padding: 0.6rem 1.2rem; border-radius: 0.25rem; font-size: 0.9rem; transition: background-color 0.2s; margin-bottom: 0.5rem; }
        .file-upload-label:hover { background-color: #7f8c8d; }
        #file-status { font-size: 0.9rem; margin-top: 0.25rem; margin-bottom:1rem; opacity: 0.9; min-height: 1.2em; }

        .actions-section { margin-top: 1.5rem; }
        #stageScheduleButton { background-color: #27ae60; }
        #stagingStatusMessage { text-align:center; margin-bottom: 1rem; font-size: 0.9em; color: #f1c40f; min-height:1.2em; }


        .info-section { margin-top:2rem; padding:1rem; background-color: rgba(0,0,0,0.1); border-radius:0.25rem; font-size:0.8rem; }
        .info-section h3 { font-size:1rem; margin-bottom:0.5rem; color: #ffffff; }
        .info-section p { line-height:1.6; color:#bdc3c7; }

        .tooltip { position: relative; display: inline-block; cursor: help; margin-left: 4px; font-size:0.8em; background-color:#7f8c8d; color:white; border-radius:50%; width:14px; height:14px; text-align:center; line-height:14px;}
        .tooltip .tooltiptext {
            visibility: hidden; width: 280px; background-color: #34495e; color: #fff;
            text-align: left; border-radius: 6px; padding: 8px; position: absolute;
            z-index: 10; bottom: 135%; left: 50%; margin-left: -140px; opacity: 0; transition: opacity 0.3s;
            font-size: 0.75rem; line-height: 1.4; border: 1px solid #7f8c8d;
        }
        .tooltip .tooltiptext::after {
            content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px;
            border-width: 5px; border-style: solid; border-color: #34495e transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .filter-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; margin-bottom: 1rem; align-items: end;}

        .current-details-display {
            margin-top: 0.5rem;
            font-size: 0.85em;
            background-color: rgba(0,0,0,0.2);
            padding: 0.5rem;
            border-radius: 0.25rem;
            color: #bdc3c7;
        }
        .current-details-display p { margin: 0.2rem 0; }
        .current-details-display span { font-style: italic; color: #ecf0f1; }

        .event-section div, .stop-status-section div,
        .route-colour-management-subsection div,
        .stop-specific-route-colour-subsection div,
        .view-stop-departures div, .analytics-subsection div {
            margin-bottom: 0.75rem;
        }
        .event-section label, .stop-status-section label,
        .route-colour-management-subsection label,
        .stop-specific-route-colour-subsection label,
        .view-stop-departures label, .analytics-subsection label {
             margin-bottom: 0.25rem;
        }


        #currentRouteColoursListContainer,
        #currentStopSpecificColoursListContainer,
        #duplicateEntriesResults {
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            padding: 0.75rem;
            margin-top: 1rem;
            max-height: 300px;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.05);
        }
        #currentRouteColoursList li,
        #currentStopSpecificColoursList ul,
        #currentStopSpecificColoursList li,
        #duplicateEntriesResults li {
            display: block;
            padding: 0.5rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #currentRouteColoursList li:last-child,
        #currentStopSpecificColoursList li:last-child,
        #duplicateEntriesResults li:last-child { border-bottom: none; }

        #currentStopSpecificColoursList .stop-group-title {
            font-weight: bold;
            margin-top: 0.5rem;
            padding-bottom: 0.2rem;
            border-bottom: 1px dashed #566573;
        }
        #currentStopSpecificColoursList .stop-group-title:first-child {
            margin-top: 0;
        }
        #currentStopSpecificColoursList ul {
            list-style-type: none;
            padding-left: 1rem;
            margin:0;
        }


        #duplicateEntriesResults .duplicate-set { margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 1px dashed #4A5568;}
        #duplicateEntriesResults .duplicate-set:last-child { border-bottom: none; }
        #duplicateEntriesResults .entry-detail { display: block; font-size: 0.85rem; margin-left: 1rem; opacity: 0.9;}


        .colour-preview-box {
            width: 20px;
            height: 20px;
            border: 1px solid #ecf0f1;
            margin-right: 10px;
            display: inline-block;
            vertical-align: middle;
        }
        #currentRouteColoursList .route-info,
        #currentStopSpecificColoursList .route-info {
            flex-grow: 1;
            display: inline-flex;
            align-items: center;
        }


        .route-tile-tools-list {
            display: inline-block;
            padding: 0.2em 0.55em;
            margin-right: 0.3em;
            margin-bottom: 0.3em;
            border-radius: 0.25rem;
            font-size: 0.8em;
            font-weight: bold;
            color: white;
            text-align: center;
            line-height: 1.3;
            min-width: 28px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.25);
            vertical-align: middle;
        }
        #stopDeparturesList li {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.1rem;
            border-bottom: 1px solid #34495e;
            font-size: 0.9rem;
        }
        #stopDeparturesList li:last-child {
            border-bottom: none;
        }

        /* Enhanced Master Stop List Styles START */
        #masterStopListUL_SM li {
            padding: 0.75rem 0.5rem; /* Increased padding */
            border-bottom: 1px solid #34495e;
            transition: background-color 0.15s ease-in-out;
        }
        #masterStopListUL_SM li:last-child {
            border-bottom: none;
        }
        #masterStopListUL_SM li .stop-id-master { /* Style for Stop ID - now less prominent */
            font-weight: normal; /* Changed from bold */
            color: #bdc3c7;     /* Swapped color with stop-name-master */
            font-size: 0.95em;  /* Swapped font-size with stop-name-master */
        }
        #masterStopListUL_SM li .stop-name-master { /* Style for Stop Name - now more prominent */
            font-weight: bold;  /* Added bold */
            color: #ecf0f1;      /* Swapped color with stop-id-master */
            font-size: 1.05em; /* Swapped font-size with stop-id-master */
        }
        #masterStopListUL_SM li .stop-direction-master {
            font-style: italic;
            font-size: 0.85em;
            color: #95a5a6;
            margin-bottom: 0.3rem;
        }

        #masterStopListUL_SM li .stop-details-grid {
            display: grid;
            grid-template-columns: auto 1fr; /* For label and value */
            gap: 0.2rem 0.5rem; /* Row and column gap */
            font-size: 0.85em;
            margin-top: 0.4rem;
        }
        #masterStopListUL_SM li .detail-label {
            font-weight: normal; /* Changed from bold to normal */
            color: #bdc3c7;
            opacity: 0.8;
        }
        #masterStopListUL_SM li .detail-value {
            color: #ecf0f1;
        }
        #masterStopListUL_SM li .detail-value.status-closed {
            color: #e74c3c; /* Red for closed */
            font-weight: bold;
        }
        #masterStopListUL_SM li .detail-value.status-open {
            color: #2ecc71; /* Green for open */
        }

        #masterStopListUL_SM li .serving-routes-container {
            margin-top: 0.4rem;
            margin-bottom: 0.2rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3em;
            padding: 0.25rem 0;
        }
        /* Uses existing .route-tile-tools-list for the tiles inside .serving-routes-container */

        #masterStopListUL_SM li .service-times-info { /* This class is not used in the JS provided, keeping it just in case or for future */
            font-size: 0.8em;
            opacity: 0.9;
            margin-top: 0.3rem;
            padding: 0.25rem;
            background-color: rgba(0,0,0,0.1);
            border-radius: 0.2rem;
        }
        /* Action Buttons for Master Stop List */
        #masterStopListUL_SM li .stop-actions {
            margin-top: 0.75rem;
            padding-top: 0.5rem;
            border-top: 1px dashed rgba(127,140,141,0.3);
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        /* Enhanced Master Stop List Styles END */


        #routesServingStopListContainer_SM {
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.05);
            padding:0.75rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
        }
        #routesServingStopList_SM {
            list-style: none;
            padding: 0;
            margin:0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5em;
        }
        #routesServingStopList_SM li {
            padding: 0;
            border-bottom: none;
        }

        #schedule-generator-section h2,
        #schedule-generator-section h3.subsection-title,
        #schedule-generator-section h4 {
            color: #ecf0f1;
            border-bottom-color: #4A5568;
        }

        #schedule-generator-section label {
            display: block;
            color: #bdc3c7;
            margin-top: 10px;
            margin-bottom: 0.35rem;
            font-weight: 500;
            font-size: 0.85rem;
        }

        .schedule-generator-select {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        .schedule-generator-select option {
            background-color: #34495e;
            color: #ecf0f1;
        }

        .schedule-generator-input {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size: 0.9rem;
        }
        #gen_stopId.schedule-generator-input {
             text-transform: uppercase;
        }
        #gen_lineName.schedule-generator-input,
        #gen_destinationName.schedule-generator-input {
            text-transform: none;
        }


        .gen_interval-rule {
            border: 1px solid #4A5568;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 0.375rem;
            background-color: rgba(0,0,0,0.1);
        }

        .gen_input-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }


        #gen_resultsTable {
            width: 100%;
            margin-top: 1.5rem;
            border-collapse: collapse;
            color: #ecf0f1;
        }
        #gen_resultsTable th, #gen_resultsTable td {
            border: 1px solid #4A5568;
            padding: 8px 10px;
            text-align: left;
        }
        #gen_resultsTable th {
            background-color: #34495e;
            color: white;
            font-weight: 500;
        }
        #gen_resultsTable tbody tr:nth-child(odd) {
            background-color: rgba(0,0,0,0.1);
        }
         #gen_resultsTable tbody tr:nth-child(even) {
            background-color: rgba(0,0,0,0.2);
        }

        .gen_action-buttons {
            margin-top: 1.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }
        .gen_footer-note {
            text-align: center;
            margin-top: 1.5rem;
            font-size: 0.85em;
            color: #bdc3c7;
        }

        #newStopIdAvailability_ARS {
            font-size: 0.8em;
            min-height: 1.1em;
            margin-top: 0.25rem;
        }

        #sgCopierSourceRoutesContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5em;
            padding: 0.75rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            background-color: rgba(0,0,0,0.05);
            min-height: 40px;
        }

        .copier-route-tile {
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out, outline 0.1s ease-in-out;
            border: 1px solid transparent;
        }

        .copier-route-tile:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .copier-route-tile.selected-tile {
            outline: 2px solid #3498db;
            box-shadow: 0 0 0 2px #3498db, 0 2px 5px rgba(0,0,0,0.4);
        }

        #sgCopierSourceRoutesPlaceholder {
            width: 100%;
            text-align: center;
            opacity: 0.7;
            padding: 0.5rem;
        }

        #specificRouteColourTilesContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5em;
            padding: 0.75rem;
            border: 1px solid #4A5568;
            border-radius: 0.25rem;
            background-color: rgba(0,0,0,0.05);
            min-height: 40px;
            margin-bottom: 1rem;
        }

        .specific-colour-route-tile {
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out, outline 0.1s ease-in-out;
            border: 1px solid transparent;
            cursor: pointer;
        }
        .specific-colour-route-tile:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .specific-colour-route-tile.selected-for-color-edit {
            outline: 2px solid #f39c12;
            box-shadow: 0 0 0 2px #f39c12, 0 2px 5px rgba(0,0,0,0.4);
        }
        #specificRouteColourTilesPlaceholder {
             width: 100%;
            text-align: center;
            opacity: 0.7;
            padding: 0.5rem;
        }

    </style>
</head>
<body lang="en-GB">
    <div class="page-container">
        <h1>Bus Schedule Setup & Management</h1>

        <div id="auth-section" class="section">
            <h2>Admin Login</h2>
            <div id="login-form-container">
                <form id="adminLoginForm">
                    <div class="form-grid" style="grid-template-columns: 1fr;">
                        <div><label for="inputEmail">Email</label><input type="email" id="inputEmail" autocomplete="email"></div>
                        <div><label for="inputPassword">Password</label><input type="password" id="inputPassword" autocomplete="current-password"></div>
                    </div>
                    <button id="loginButton" type="submit" class="button">Login</button>
                </form>
                <p id="auth-status" style="margin-top: 0.5em; color: #f1c40f;"></p>
            </div>
            <div id="logout-container" style="display:none;">
                <p>Logged in as: <span id="loggedInUserEmail"></span></p>
                <button id="logoutButton" class="button secondary">Logout</button>
            </div>
        </div>

        <div id="current-profile-display-container" class="section">
            <p id="current-profile-display">Today's Auto Profile: (determining...)</p>
        </div>

        <div id="top-menu-bar">
            <div id="main-menu-buttons">
                <button class="menu-button" data-section="bulk-edit-tools-section">Bulk Edit & Colours</button>
                <button class="menu-button" data-section="view-departures-section">View Departures</button>
                <button class="menu-button" data-section="schedule-generator-section">Schedule Generator & Copier</button>
                <button class="menu-button" data-section="deployment-tools-section">Deployment & Upload</button>
                <button class="menu-button" data-section="analytics-validation-section">Analytics & Validation</button>
                <button class="menu-button" data-section="stop-management-tool-section">Stop Management</button>
                <button class="menu-button" data-section="add-remove-stop-section">Add/Remove Stop</button>
                <button class="menu-button" data-section="global-route-deletion-section">Global Route Deletion</button>
            </div>
        </div>

        <div id="tool-sections-wrapper">
            <div id="bulk-edit-tools-section" class="tool-content-section">
                <div class="section bulk-edit-route-destination">
                    <h2>Update Destination for a Route</h2>
                    <div class="form-grid" style="grid-template-columns: 1fr 1.5fr 1.5fr auto; align-items:end; gap: 0.75rem;">
                        <div><label for="bulkEditTargetLineName">Target Line</label><input type="text" id="bulkEditTargetLineName" placeholder="e.g., 186" autocomplete="off"></div>
                        <div><label for="bulkEditOldDestination">Old Destination (optional)</label><input type="text" id="bulkEditOldDestination" placeholder="Blank to update all" autocomplete="off"></div>
                        <div><label for="bulkEditNewDestination">New Destination</label><input type="text" id="bulkEditNewDestination" placeholder="New destination" autocomplete="off"></div>
                        <div style="padding-bottom:0.05rem;"><button id="bulkUpdateRouteDestinationButton" class="button">Update Destination</button></div>
                    </div>
                </div>

                <div class="section route-colour-management-subsection"> <h2>Global Route Tile Colour Management</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">Define global custom colours for routes. These apply unless a stop-specific colour is set.</p>
                    <div class="form-grid" style="grid-template-columns: 1.5fr 1fr auto auto auto auto; align-items: end; gap: 0.75rem;">
                        <div><label for="selectRouteNameColour">Route Name</label><select id="selectRouteNameColour"><option value="">-- Select Route --</option></select></div>
                        <div><label for="inputRouteColour">Select Colour</label><input type="color" id="inputRouteColour" value="#73809C" autocomplete="off"></div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #73809C; color: #FFFFFF;" onclick="setGlobalRouteColour('#73809C')">Day Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #4CDBE6; color: #000000;" onclick="setGlobalRouteColour('#4CDBE6')">24 Hr / Night Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #AC5099; color: #FFFFFF;" onclick="setGlobalRouteColour('#AC5099')">School Bus</button>
                        </div>
                        <div style="padding-bottom:0.05rem;"><button id="saveRouteColourButton" class="button">Save Global Colour</button></div>
                    </div>
                    <div id="currentRouteColoursListContainer"><h3 class="subsection-title" style="font-size: 1.1rem; margin-bottom: 0.5rem;">Current Global Custom Colours</h3><ul id="currentRouteColoursList"></ul><p id="noCustomColoursMessage">No global custom colours set.</p></div>
                    <p id="routeColourStatusMessage" style="min-height:1.2em;"></p>
                </div>

                <div class="section stop-specific-route-colour-subsection"> <h2>Stop-Specific Route Tile Colours</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">Override global route colours for specific stops.</p>
                    <div>
                        <label for="selectStopForSpecificRouteColour">1. Select Stop:</label>
                        <select id="selectStopForSpecificRouteColour" class="schedule-generator-select">
                            <option value="">-- Select Stop --</option>
                        </select>
                    </div>
                    <div>
                        <label>2. Select Route(s) at this stop to colour (click one to enable delete option below):</label>
                        <div id="specificRouteColourTilesContainer">
                            <p id="specificRouteColourTilesPlaceholder">Select a stop to see its routes.</p>
                        </div>
                    </div>
                    <div style="margin-top: 0.5rem; margin-bottom: 1rem;">
                        <button id="deleteRouteFromStopButton" class="button secondary" style="display: none;">Delete Selected Route from This Stop</button>
                        <p id="deleteRouteFromStopStatusMessage" style="min-height:1.2em; margin-top:0.5rem; font-size:0.85em;"></p>
                    </div>

                    <div class="form-grid" style="grid-template-columns: 1fr auto auto auto auto; align-items:end; gap:0.75rem; margin-top:0.5rem;">
                        <div>
                            <label for="inputStopSpecificRouteColour">3. Select Colour:</label>
                            <input type="color" id="inputStopSpecificRouteColour" value="#73809C">
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #73809C; color: #FFFFFF;" onclick="setStopSpecificRouteColour('#73809C')">Day Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #4CDBE6; color: #000000;" onclick="setStopSpecificRouteColour('#4CDBE6')">24 Hr / Night Bus</button>
                        </div>
                        <div>
                            <button class="button" style="padding: 0.5rem 0.8rem; background-color: #AC5099; color: #FFFFFF;" onclick="setStopSpecificRouteColour('#AC5099')">School Bus</button>
                        </div>
                        <div style="padding-bottom:0.05rem;">
                             <button id="saveStopSpecificRouteColourButton" class="button tertiary">Save Colour for Selected Route(s) at this Stop</button>
                        </div>
                    </div>
                    <p id="stopSpecificRouteColourStatusMessage" style="min-height:1.2em; margin-top:0.5rem;"></p>

                    <div id="currentStopSpecificColoursListContainer">
                        <h3 class="subsection-title" style="font-size: 1.1rem; margin-bottom: 0.5rem;">Current Stop-Specific Colour Overrides</h3>
                        <div id="currentStopSpecificColoursList">
                             <p id="noStopSpecificColoursMessage">No stop-specific colours are currently set.</p>
                        </div>
                    </div>
                </div>

            </div>

            <div id="event-generator-section" class="tool-content-section" style="display:none !important;">
                 </div>

            <div id="stop-status-section" class="tool-content-section" style="display:none !important;">
                </div>

            <div id="view-departures-section" class="tool-content-section">
                <div class="section view-stop-departures">
                    <h2>View Scheduled Departures by Stop</h2>
                    <div class="form-grid" style="grid-template-columns: 1fr 2fr; align-items: start; gap: 1.5rem;">
                        <div><label for="selectStopForDeparturesView">Bus Stop</label><select id="selectStopForDeparturesView"><option value="">-- Select Stop --</option></select></div>
                        <div><label>Departures (Sorted by Day Offset -> Profile Day -> Time)</label><div id="stopDeparturesListContainer" style="max-height: 400px; overflow-y: auto; border: 1px solid #4A5568; padding: 0.5rem; border-radius: 0.25rem;"><ul id="stopDeparturesList"></ul><p id="noDeparturesForStopMessage">Select stop to view.</p></div></div>
                    </div>
                </div>
            </div>

            <div id="schedule-generator-section" class="tool-content-section section">
                <h2>Transit Schedule Generator & Copier</h2> <p style="opacity:0.8; margin-bottom:1rem;">Create, export, copy, and adjust transit schedules.</p>
                <div class="subsection">
                    <h3 class="subsection-title">Base Data (First Entry for Generation)</h3>
                    <div class="form-field-group">
                        <label for="gen_stopNameSelect">Select Stop:</label>
                        <select id="gen_stopNameSelect" class="schedule-generator-select">
                            <option value="">-- Loading Stops --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label for="gen_stopId">StopID (auto-filled from selection):</label>
                        <input type="text" id="gen_stopId" class="schedule-generator-input" placeholder="Select stop from list" readonly>
                    </div>
                    <div class="gen_input-group">
                        <div>
                            <label for="gen_stopName">StopName (auto-filled from selection):</label>
                            <input type="text" id="gen_stopName" class="schedule-generator-input" placeholder="Select stop from list" readonly>
                        </div>
                        <div>
                            <label for="gen_direction">Direction (auto-filled from selection):</label>
                            <input type="text" id="gen_direction" class="schedule-generator-input" placeholder="Select stop from list" readonly>
                        </div>
                    </div>
                    <div class="form-field-group">
                        <label for="gen_routeSelect">Select Existing Route (populates Line Name below):</label>
                        <select id="gen_routeSelect" class="schedule-generator-select">
                            <option value="">-- Select Existing Route --</option>
                        </select>
                    </div>
                     <div class="form-field-group">
                        <label for="gen_lineName">Line Name (Route - type new or select above):</label>
                        <input type="text" id="gen_lineName" class="schedule-generator-input" placeholder="e.g., 10A or NEW_ROUTE">
                    </div>
                    <div class="form-field-group">
                        <label for="gen_destinationSelect">Select Existing Destination (for chosen Line Name):</label>
                        <select id="gen_destinationSelect" class="schedule-generator-select">
                            <option value="">-- Enter/Select Route First --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label for="gen_destinationName">Destination Name (type new or select above):</label>
                        <input type="text" id="gen_destinationName" class="schedule-generator-input" placeholder="e.g., City Centre or NEW_DEST">
                    </div>
                    <div class="gen_input-group">
                        <div>
                            <label for="gen_operatingProfile">OperatingProfile:</label>
                            <input type="text" id="gen_operatingProfile" class="schedule-generator-input" placeholder="e.g., Weekday">
                        </div>
                        <div>
                            <label for="gen_initialScheduledTime">ScheduledTime (HHMM):</label>
                            <input type="text" id="gen_initialScheduledTime" class="schedule-generator-input" placeholder="e.g., 0845">
                        </div>
                        <div>
                            <label for="gen_initialDayOffset">DayOffset:</label>
                            <input type="number" id="gen_initialDayOffset" class="schedule-generator-input" min="0" value="0" placeholder="0">
                        </div>
                    </div>
                </div>
                <div class="subsection">
                    <h3 class="subsection-title">Interval Definitions for Additional Entries (Generation)</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.5rem;">
                        <strong>DayOffset Logic for Generated Times:</strong><br>
                        - If an interval rule starts <em>before</em> midnight (e.g., at 22:00) and generates times that cross into the 00:00-03:59 window, those specific post-midnight times get <code>DayOffset = 1</code>.<br>
                        - If an interval rule itself starts <em>at or after</em> midnight (e.g., "00:15", "01:00", up to "03:59"), all times it generates get <code>DayOffset = 0</code>.<br>
                        - All other generated times get <code>DayOffset = 0</code>.
                    </p>
                    <div id="gen_intervalRulesContainer"></div>
                    <button id="gen_addIntervalRuleButton" class="button" style="margin-top:10px;">+ Add Interval Rule</button>
                </div>
                <div class="subsection" id="schedule-copier-subsection-sg">
                    <h3 class="subsection-title">Copy & Adjust Schedules (from Working Schedule)</h3>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        Select a source stop from the current working schedule, choose routes, copy, then select a target stop, adjust times, and paste the new entries back into the main working schedule.
                    </p>
                    <div class="form-field-group">
                        <label for="sgCopierSourceStopSelect">1. Source Stop:</label>
                        <select id="sgCopierSourceStopSelect" class="schedule-generator-select">
                            <option value="">-- Select Source Stop --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label>2. Routes serving Source Stop (click tiles to select/deselect for copying):</label>
                        <div id="sgCopierSourceRoutesContainer">
                            <p id="sgCopierSourceRoutesPlaceholder">Select a source stop to see routes.</p>
                        </div>
                    </div>
                    <button id="sgCopierCopySchedulesButton" class="button" style="margin-top: 0.5rem; margin-bottom:1rem;">Copy Selected Schedules from Source</button>
                    <hr style="margin: 1.5rem 0; border-color: rgba(255,255,255,0.1);">
                    <div class="form-field-group">
                        <label for="sgCopierTargetStopSelect">3. Target Stop:</label>
                        <select id="sgCopierTargetStopSelect" class="schedule-generator-select">
                            <option value="">-- Select Target Stop --</option>
                        </select>
                    </div>
                    <div class="form-field-group">
                        <label for="sgCopierTimeAdjustmentInput">4. Time Adjustment (minutes, e.g., +5 or -10):</label>
                        <input type="text" id="sgCopierTimeAdjustmentInput" class="schedule-generator-input" placeholder="e.g., +3 or -2" value="0">
                    </div>
                    <button id="sgCopierPasteSchedulesButton" class="button tertiary" style="margin-top: 0.5rem;">Paste Schedules to Target Stop (in Working Schedule)</button>
                    <div id="sgCopierStatusMessage" style="margin-top: 1rem; padding: 0.5rem; background-color: rgba(0,0,0,0.08); border-radius: 0.25rem; min-height: 1.5em; text-align: center;">
                        Status will appear here.
                    </div>
                </div>
                <div class="subsection">
                    <div class="gen_action-buttons">
                        <button id="gen_generateScheduleButton" class="button">Generate Schedule</button>
                        <button id="gen_exportToCountButton" class="button" style="background-color: #27ae60;">Export to .COUNT</button>
                        <button id="gen_addToWorkingScheduleButton" class="button" style="background-color: #1abc9c;">Add Generated to Working Schedule</button>
                        <button id="gen_getWorkingScheduleButton" class="button" style="background-color: #9b59b6;">Load Full Schedule to Generator Table</button>
                        <button id="gen_loadStopScheduleButton" class="button" style="background-color: #34495e;">Load Selected Stop's Schedule to Table</button>
                        <button id="gen_clearAllDataButton" class="button secondary">Clear All Generator Data & Table</button>
                    </div>
                    <h3 class="subsection-title" style="margin-top:1.5rem;">Generated Schedule / Loaded Data Table</h3>
                    <div style="max-height: 400px; overflow-y: auto;">
                        <table id="gen_resultsTable">
                             <thead>
                                <tr>
                                    <th>StopID</th><th>StopName</th><th>Direction</th><th>LineName</th><th>DestinationName</th><th>ScheduledTime (HH:MM)</th><th>OperatingProfile</th><th>DayOffset</th><th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
                <div class="gen_footer-note">
                    <p>Generator data (base data, intervals, table content) is saved in your browser's local storage. Copied schedules are added directly to the main "Working Schedule".</p>
                </div>
            </div>

            <div id="deployment-tools-section" class="tool-content-section">
                <div class="section count-file-upload">
                    <h2>Upload Full Schedule</h2>
                    <p style="font-size:0.8em; margin-bottom:0.5em;">Replaces current working schedule. Ensure file has correct headers: StopID, StopName, Direction, LineName, DestinationName, ScheduledTime, OperatingProfile, DayOffset (optional).</p>
                    <label for="count-file-input" class="file-upload-label">Choose .COUNT or .txt File</label>
                    <input type="file" id="count-file-input" accept=".COUNT,.txt" style="display: none;">
                    <p id="file-status">No file selected.</p>
                </div>
                <div class="actions-section section">
                    <h2>Schedule Deployment Actions</h2>
                    <div id="stagingStatusMessage" style="min-height:1.2em;">Checking status...</div>
                    <button id="stageScheduleButton" class="button">Stage Working Schedule</button>
                    <button id="applyNowButton" class="button tertiary">Apply Staged Live NOW</button>
                    <hr style="margin: 1.5rem 0; border-color: rgba(255,255,255,0.1);">
                    <button id="viewArrivalsButton" class="button">View Arrivals Board</button>
                </div>
            </div>

            <div id="analytics-validation-section" class="tool-content-section">
                <div class="section">
                    <h2>Schedule Analytics & Validation</h2>
                    <div class="subsection analytics-subsection">
                        <h3 class="subsection-title">Duplicate Entry Detection</h3>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <button id="detectDuplicatesButton" class="button">Find Duplicate Entries</button>
                            <button id="removeDuplicateEntriesButton" class="button secondary">Remove All Duplicates (Keep First)</button>
                        </div>
                        <p id="removeDuplicatesStatusMessage" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                        <div id="duplicateEntriesResults" style="margin-top: 0.75rem;">
                            <p>Click "Find Duplicate Entries" to scan the current working schedule.</p>
                        </div>
                    </div>
                    <div class="subsection">
                        <h3 class="subsection-title">Consolidate Operating Days for Route at Stop</h3>
                        <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                            Select a stop and a route. This tool will find entries with the same time, destination, and day offset, and consolidate their Operating Profiles into one entry, removing the redundant ones.
                        </p>
                        <div class="form-grid" style="grid-template-columns: 1fr 1fr 1fr auto; align-items: end; gap: 0.75rem;">
                            <div>
                                <label for="consolidateStopSelect">Select Stop ID:</label>
                                <select id="consolidateStopSelect" class="schedule-generator-select"></select>
                            </div>
                            <div>
                                <label for="consolidateRouteSelect">Select Route:</label>
                                <select id="consolidateRouteSelect" class="schedule-generator-select"></select>
                            </div>
                            <div>
                                <label for="consolidateNewProfileInput">New Combined Operating Profile:</label>
                                <input type="text" id="consolidateNewProfileInput" class="schedule-generator-input" placeholder="e.g., MF,Sa,Su">
                            </div>
                            <div style="padding-bottom:0.05rem;">
                                <button id="consolidateOperatingDaysButton" class="button tertiary">Consolidate</button>
                            </div>
                        </div>
                        <p id="consolidateOpDaysStatusMessage" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                    </div>
                </div>
            </div>

            <div id="stop-management-tool-section" class="tool-content-section">
                <div class="section">
                    <h2>Master List of Unique Stops</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.75rem;">
                        This list is generated from the unique Stop IDs in the current working schedule.
                        It shows details for each unique Stop ID.
                    </p>
                    <div class="filter-controls" style="grid-template-columns: 1fr auto; gap: 0.75rem; margin-bottom: 0.5rem;">
                        <input type="text" id="masterStopListFilterInput_SM" placeholder="Filter by Stop ID, Name, Route, Status...">
                        <button id="refreshMasterStopListButton_SM" class="button neutral">Refresh List</button>
                    </div>
                    <div id="masterStopListContainer_SM" class="subsection" style="max-height: 600px; overflow-y: auto; padding: 0.5rem; background-color: rgba(0,0,0,0.05);">
                        <ul id="masterStopListUL_SM" style="list-style: none; padding: 0;">
                            </ul>
                    </div>
                    <p id="masterStopListStatus_SM" style="text-align: center; margin-top: 0.5rem; min-height: 1.2em;">Click "Refresh List" to load stops.</p>
                </div>

                <div class="section">
                    <h2>Find and Replace Stop IDs in Working Schedule</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:0.75rem;">
                        This utility modifies the 'Working Schedule'. It changes all occurrences of an old Stop ID to a new Stop ID.
                        The Stop Name and Direction for entries with the new Stop ID will be updated based on the first found instance of the 'New Stop ID' in the schedule.
                    </p>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr auto; align-items: end; gap: 0.75rem;">
                        <div><label for="findStopIdScheduleInput_SM">Stop ID to Find in Schedule</label><input type="text" id="findStopIdScheduleInput_SM" placeholder="e.g., OLDSTOPID"></div>
                        <div><label for="replaceStopIdScheduleInput_SM">Replace with New Stop ID</label><input type="text" id="replaceStopIdScheduleInput_SM" placeholder="e.g., NEWSTOPID"></div>
                        <div style="padding-bottom:0.05rem;"><button id="findReplaceStopIdScheduleButton_SM" class="button tertiary">Execute Find & Replace</button></div>
                    </div>
                    <p id="findReplaceStatusMessage_SM" style="min-height: 1.2em; margin-top: 0.5rem;">-</p>
                </div>

                <div class="section" style="display:none !important;">
                    <h2>Stop Information: Serving Routes</h2>
                    </div>
            </div>

            <div id="add-remove-stop-section" class="tool-content-section">
                <div class="section">
                    <h2>Add or Remove Stop Details</h2>
                    <div class="subsection">
                        <h3 class="subsection-title">Add New Stop Details</h3>
                        <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                            Define a new stop. A placeholder schedule entry will be added to make it available in selectors.
                            The Stop ID must be unique.
                        </p>
                        <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                            <div> <label for="selectNewStopIdFormat_ARS">Stop ID Format/Prefix</label>
                                <div style="display: flex; align-items: flex-end; gap: 0.5rem;">
                                    <select id="selectNewStopIdFormat_ARS" class="schedule-generator-select" style="flex-grow: 1;">
                                        <option value="NUM">Numeric (e.g., 101-99999)</option>
                                        <option value="BP">BP Prefix (e.g., BP1-BP99999)</option>
                                        <option value="LE">LE Prefix (e.g., LE1-LE99999)</option>
                                        <option value="RO">RO Prefix (e.g., RO1-RO99999)</option>
                                    </select>
                                    <button id="buttonSuggestStopId_ARS" class="button neutral" style="padding: 0.5rem 0.8rem; margin-bottom: 0px; height: calc(0.5rem * 2 + 0.9rem + 2px); line-height: 0.9rem;">Suggest ID</button>
                                </div>
                            </div>
                            <div> <label for="inputNewStopId_ARS">New Stop ID (type or use suggest)</label>
                                <input type="text" id="inputNewStopId_ARS" class="schedule-generator-input" placeholder="e.g., NEWSTOP123" autocomplete="off">
                                <p id="newStopIdAvailability_ARS" style="font-size: 0.8em; min-height: 1.1em; margin-top: 0.25rem;"></p>
                            </div>
                            <div>
                                <label for="inputNewStopName_ARS">New Stop Name</label>
                                <input type="text" id="inputNewStopName_ARS" class="schedule-generator-input" placeholder="e.g., Main Street Library" autocomplete="off">
                            </div>
                            <div>
                                <label for="inputNewStopDirection_ARS">New Stop Direction (Towards)</label>
                                <input type="text" id="inputNewStopDirection_ARS" class="schedule-generator-input" placeholder="e.g., Town Centre" autocomplete="off">
                            </div>
                        </div>
                        <div style="margin-top: 1rem;">
                            <button id="buttonAddNewStop_ARS" class="button">Add New Stop Details</button>
                        </div>
                        <p id="addNewStopStatus_ARS" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                    </div>
                    <hr style="margin: 2rem 0; border-color: rgba(255,255,255,0.1);">
                    <div class="subsection">
                        <h3 class="subsection-title">Remove Stop & All Its Schedule Entries</h3>
                         <div class="form-field-group">
                            <label for="selectStopToRemove_ARS">Select Stop to Remove:</label>
                            <select id="selectStopToRemove_ARS" class="schedule-generator-select">
                                <option value="">-- Select Stop --</option>
                            </select>
                        </div>
                        <button id="buttonRemoveStop_ARS" class="button secondary">Remove Selected Stop & Its Schedule Entries</button>
                        <p id="removeStopStatus_ARS" style="min-height:1.2em; margin-top: 0.75rem;"></p>
                    </div>
                </div>
            </div>

            <div id="global-route-deletion-section" class="tool-content-section">
                <div class="section">
                    <h2>Global Route Deletion</h2>
                    <p style="font-size:0.85em; opacity:0.8; margin-bottom:1rem;">
                        Select a route to remove ALL of its schedule entries from ALL stops.
                        This will also remove its global custom colour and any stop-specific colour overrides for this route.
                        <strong>This action is highly destructive and cannot be easily undone.</strong>
                    </p>
                    <div class="form-field-group">
                        <label for="selectGlobalRouteToDelete">Select Route to Delete Globally:</label>
                        <select id="selectGlobalRouteToDelete" class="schedule-generator-select">
                            <option value="">-- Select Route --</option>
                        </select>
                    </div>
                    <button id="deleteEntireRouteButton" class="button secondary" style="margin-top: 0.5rem;">Delete Entire Selected Route Globally</button>
                    <p id="deleteEntireRouteStatusMessage" style="min-height:1.2em; margin-top:0.75rem;"></p>
                </div>
            </div>

        </div> </div> </body>
<script type="module">
      // Firebase App initialization
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
      import { getDatabase, ref, set, onValue, get, child, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDePDF-kZahjzh9ij6tkuApIhoGePwVQ2s", // Replace with your actual Firebase API Key
        authDomain: "omsi-c5505.firebaseapp.com", // Replace with your actual Firebase Auth Domain
        databaseURL: "https://omsi-c5505-default-rtdb.europe-west1.firebasedatabase.app", // Replace with your actual Firebase Database URL
        projectId: "omsi-c5505", // Replace with your actual Firebase Project ID
        storageBucket: "omsi-c5505.appspot.com", // Replace with your actual Firebase Storage Bucket
        messagingSenderId: "503595375440", // Replace with your actual Firebase Messaging Sender ID
        appId: "1:503595375440:web:356be6684b77ff5909ea55", // Replace with your actual Firebase App ID
        measurementId: "G-VN7X65V3F9" // Replace with your actual Firebase Measurement ID
      };

      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      const auth = getAuth(app);

      window.firebaseOMSI = {
          database: database, auth: auth,
          dbRef: ref, dbSet: set, dbOnValue: onValue, dbGet: get,
          dbChild: child, dbUpdate: update, dbRemove: remove,
          authOnAuthStateChanged: onAuthStateChanged,
          authSignInWithEmailAndPassword: signInWithEmailAndPassword,
          authSignOut: signOut
      };
      console.log("Firebase Initialized for OMSI Tools.");
    </script>

<script>
// --- DOM Elements ---
const countFileInput = document.getElementById('count-file-input');
const fileStatusElement = document.getElementById('file-status');
const currentProfileDisplayContainer = document.getElementById('current-profile-display-container');
const currentProfileDisplayElement = document.getElementById('current-profile-display');

// Elements for "Update Destination for a Route" (kept as it's a separate functionality)
const bulkEditTargetLineNameInput = document.getElementById('bulkEditTargetLineName');
const bulkEditOldDestinationInput = document.getElementById('bulkEditOldDestination');
const bulkEditNewDestinationInput = document.getElementById('bulkEditNewDestination');
const bulkUpdateRouteDestinationButton = document.getElementById('bulkUpdateRouteDestinationButton');

// Staging and Deployment Elements
const stageScheduleButton = document.getElementById('stageScheduleButton');
const applyNowButton = document.getElementById('applyNowButton');
const viewArrivalsButton = document.getElementById('viewArrivalsButton');
const stagingStatusMessage = document.getElementById('stagingStatusMessage');

// Global Route Colour Elements
const selectRouteNameColour = document.getElementById('selectRouteNameColour');
const inputRouteColour = document.getElementById('inputRouteColour');
const saveRouteColourButton = document.getElementById('saveRouteColourButton');
const currentRouteColoursList = document.getElementById('currentRouteColoursList');
const noCustomColoursMessage = document.getElementById('noCustomColoursMessage');
const routeColourStatusMessage = document.getElementById('routeColourStatusMessage');

// Stop-Specific Route Colour Elements
const selectStopForSpecificRouteColour = document.getElementById('selectStopForSpecificRouteColour');
const specificRouteColourTilesContainer = document.getElementById('specificRouteColourTilesContainer');
const specificRouteColourTilesPlaceholder = document.getElementById('specificRouteColourTilesPlaceholder');
const inputStopSpecificRouteColour = document.getElementById('inputStopSpecificRouteColour');
const saveStopSpecificRouteColourButton = document.getElementById('saveStopSpecificRouteColourButton');
const stopSpecificRouteColourStatusMessage = document.getElementById('stopSpecificRouteColourStatusMessage');
const currentStopSpecificColoursListContainer = document.getElementById('currentStopSpecificColoursListContainer');
const currentStopSpecificColoursList = document.getElementById('currentStopSpecificColoursList');
const noStopSpecificColoursMessageEl = document.getElementById('currentStopSpecificColoursListContainer')?.querySelector('#noStopSpecificColoursMessage');

const deleteRouteFromStopButton = document.getElementById('deleteRouteFromStopButton');
const deleteRouteFromStopStatusMessage = document.getElementById('deleteRouteFromStopStatusMessage');

// View Departures Elements
const selectStopForDeparturesView = document.getElementById('selectStopForDeparturesView');
const stopDeparturesList = document.getElementById('stopDeparturesList');
const noDeparturesForStopMessage = document.getElementById('noDeparturesForStopMessage');

// Auth and Menu Elements
const topMenuBar = document.getElementById('top-menu-bar');
const adminLoginSection = document.getElementById('auth-section');
const loginFormContainer = document.getElementById('login-form-container');
const logoutContainer = document.getElementById('logout-container');
const loginButton = document.getElementById('loginButton');
const logoutButton = document.getElementById('logoutButton');
const inputEmail = document.getElementById('inputEmail');
const inputPassword = document.getElementById('inputPassword');
const authStatus = document.getElementById('auth-status');
const loggedInUserEmailDisplay = document.getElementById('loggedInUserEmail');
const mainMenuButtons = document.querySelectorAll('#main-menu-buttons .menu-button');
const allToolContentSections = document.querySelectorAll('.tool-content-section');

// Analytics & Validation Elements
const detectDuplicatesButton = document.getElementById('detectDuplicatesButton');
const duplicateEntriesResults = document.getElementById('duplicateEntriesResults');
const removeDuplicateEntriesButton = document.getElementById('removeDuplicateEntriesButton');
const removeDuplicatesStatusMessage = document.getElementById('removeDuplicatesStatusMessage');

const consolidateStopSelect = document.getElementById('consolidateStopSelect');
const consolidateRouteSelect = document.getElementById('consolidateRouteSelect');
const consolidateNewProfileInput = document.getElementById('consolidateNewProfileInput');
const consolidateOperatingDaysButton = document.getElementById('consolidateOperatingDaysButton');
const consolidateOpDaysStatusMessage = document.getElementById('consolidateOpDaysStatusMessage');

// Stop Management Tool Elements
const masterStopListFilterInput_SM = document.getElementById('masterStopListFilterInput_SM');
const refreshMasterStopListButton_SM = document.getElementById('refreshMasterStopListButton_SM');
const masterStopListUL_SM = document.getElementById('masterStopListUL_SM');
const masterStopListStatus_SM = document.getElementById('masterStopListStatus_SM');

const findStopIdScheduleInput_SM = document.getElementById('findStopIdScheduleInput_SM');
const replaceStopIdScheduleInput_SM = document.getElementById('replaceStopIdScheduleInput_SM');
const findReplaceStopIdScheduleButton_SM = document.getElementById('findReplaceStopIdScheduleButton_SM');
const findReplaceStatusMessage_SM = document.getElementById('findReplaceStatusMessage_SM');

// Add/Remove Stop Section Elements
const selectNewStopIdFormat_ARS = document.getElementById('selectNewStopIdFormat_ARS');
const buttonSuggestStopId_ARS = document.getElementById('buttonSuggestStopId_ARS');
const inputNewStopId_ARS = document.getElementById('inputNewStopId_ARS');
const newStopIdAvailability_ARS = document.getElementById('newStopIdAvailability_ARS');
const inputNewStopName_ARS = document.getElementById('inputNewStopName_ARS');
const inputNewStopDirection_ARS = document.getElementById('inputNewStopDirection_ARS');
const buttonAddNewStop_ARS = document.getElementById('buttonAddNewStop_ARS');
const addNewStopStatus_ARS = document.getElementById('addNewStopStatus_ARS');

const selectStopToRemove_ARS = document.getElementById('selectStopToRemove_ARS');
const buttonRemoveStop_ARS = document.getElementById('buttonRemoveStop_ARS');
const removeStopStatus_ARS = document.getElementById('removeStopStatus_ARS');

// Schedule Copier (within Schedule Generator)
const sgCopierSourceStopSelect = document.getElementById('sgCopierSourceStopSelect');
const sgCopierSourceRoutesContainer = document.getElementById('sgCopierSourceRoutesContainer');
const sgCopierSourceRoutesPlaceholder = document.getElementById('sgCopierSourceRoutesPlaceholder');
const sgCopierCopySchedulesButton = document.getElementById('sgCopierCopySchedulesButton');
const sgCopierTargetStopSelect = document.getElementById('sgCopierTargetStopSelect');
const sgCopierTimeAdjustmentInput = document.getElementById('sgCopierTimeAdjustmentInput');
const sgCopierPasteSchedulesButton = document.getElementById('sgCopierPasteSchedulesButton');
const sgCopierStatusMessage = document.getElementById('sgCopierStatusMessage');

// Global Route Deletion Elements
const selectGlobalRouteToDelete = document.getElementById('selectGlobalRouteToDelete');
const deleteEntireRouteButton = document.getElementById('deleteEntireRouteButton');
const deleteEntireRouteStatusMessage = document.getElementById('deleteEntireRouteStatusMessage');


// --- Global State ---
let currentUser = null;
let currentWorkingSchedule = [];
let ukBankHolidaysData = { dates: [], titles: {} };
const schoolHolidayDateRanges = [ ];
let closedStopIDs = []; // This will store IDs of closed stops, to be synced with Firebase
let globalCustomRouteColours = {};
let stopSpecificRouteColours = {};
let uniqueStopsMasterList_SM = [];
let autoApplyIntervalId = null;
let copiedScheduleEntries = [];

// --- Constants ---
const LOCAL_STORAGE_ACTIVE_SECTION_KEY = 'omsiToolsActiveSection';
const FB_PATH_LIVE_SCHEDULE_DATA = '/liveSchedule/allScheduledBusData';
const FB_PATH_LIVE_UNIQUE_STOPS = '/liveSchedule/uniqueBusStops';
const FB_PATH_PENDING_SCHEDULE_DATA = '/pendingSchedule/allScheduledBusData';
const FB_PATH_PENDING_UNIQUE_STOPS = '/pendingSchedule/uniqueBusStops';
const FB_PATH_PENDING_TIMESTAMP = '/pendingSchedule/uploadTimestamp';
const FB_PATH_APPSTATE_STATUS = '/appState/scheduleStatus';
const FB_PATH_APPSTATE_LAST_UPDATED = '/appState/scheduleLastUpdated';
const FB_PATH_APPSTATE_CLOSED_STOPS = '/appState/closedStopIDs';
const FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS = '/settings/customRouteColours';
const FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS = '/settings/stopSpecificRouteColours';

const initialRouteColourMapForTools = {}; // Base defaults can be added here if needed
const DEFAULT_ROUTE_COLOUR_TOOLS = "#73809C";
const NIGHT_BUS_BLUE_COLOR = (initialRouteColourMapForTools["N35"] || "#4CDBE6").toUpperCase();
const DAY_BUS_GREY_COLOR = DEFAULT_ROUTE_COLOUR_TOOLS.toUpperCase();

// --- START: Schedule Generator (from COUNT_generator.html) ---
let gen_ruleCounter = 0;
let gen_currentScheduleEntries = [];
const GEN_APP_DATA_KEY = 'transitScheduleAppData_tools_v1';
let gen_isInitialized = false;

// --- START: Schedule Generator Population & Interaction ---
function gen_populateStopNameSelect() {
    const selectEl = document.getElementById('gen_stopNameSelect');
    if (!selectEl) return;

    const previouslySelectedStopId = selectEl.value;
    selectEl.innerHTML = '<option value="">-- Select Stop --</option>';

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        selectEl.innerHTML = '<option value="">-- No Stops Loaded --</option>';
        const stopIdEl = document.getElementById('gen_stopId');
        const stopNameEl = document.getElementById('gen_stopName');
        const directionEl = document.getElementById('gen_direction');
        if (stopIdEl) stopIdEl.value = '';
        if (stopNameEl) stopNameEl.value = '';
        if (directionEl) directionEl.value = '';
        gen_populateRouteSelect();
        return;
    }

    const stopMap = new Map();
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && !stopMap.has(entry.stopID.toUpperCase())) {
            stopMap.set(entry.stopID.toUpperCase(), {
                id: entry.stopID,
                name: entry.stopName || entry.stopID,
                direction: entry.direction || ""
            });
        }
    });

    const sortedStops = Array.from(stopMap.values()).sort((a, b) => {
        const nameA = String(a.name || "").toLowerCase();
        const nameB = String(b.name || "").toLowerCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        return 0;
    });

    sortedStops.forEach(stop => {
        const opt = document.createElement('option');
        opt.value = stop.id;
        opt.textContent = `${stop.name} (${stop.id})`;
        opt.dataset.stopname = stop.name;
        opt.dataset.direction = stop.direction;
        selectEl.appendChild(opt);
    });

    if (previouslySelectedStopId && stopMap.has(previouslySelectedStopId.toUpperCase())) {
        selectEl.value = previouslySelectedStopId;
    }
    selectEl.dispatchEvent(new Event('change'));
}

function gen_populateRouteSelect() {
    const routeSelectEl = document.getElementById('gen_routeSelect');
    if (!routeSelectEl) return;

    const previouslySelectedRouteInDropdown = routeSelectEl.value;
    const currentLineNameInInput = document.getElementById('gen_lineName')?.value || "";

    routeSelectEl.innerHTML = '<option value="">-- Select Existing Route --</option>';

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        routeSelectEl.innerHTML = '<option value="">-- No Routes in Schedule --</option>';
        const lineNameInputEl = document.getElementById('gen_lineName');
        if (lineNameInputEl) lineNameInputEl.dispatchEvent(new Event('input'));
        return;
    }

    const uniqueRoutes = [...new Set(currentWorkingSchedule.map(e => e.lineName))]
        .filter(Boolean)
        .sort(compareLineNames);

    uniqueRoutes.forEach(lineName => {
        const opt = document.createElement('option');
        opt.value = lineName;
        opt.textContent = lineName;
        routeSelectEl.appendChild(opt);
    });

    const lineNameInputEl = document.getElementById('gen_lineName');
    if (lineNameInputEl && lineNameInputEl.value && uniqueRoutes.includes(lineNameInputEl.value)) {
        routeSelectEl.value = lineNameInputEl.value;
    } else if (previouslySelectedRouteInDropdown && uniqueRoutes.includes(previouslySelectedRouteInDropdown)) {
        routeSelectEl.value = previouslySelectedRouteInDropdown;
        if (lineNameInputEl) lineNameInputEl.value = routeSelectEl.value;
    } else {
        if (lineNameInputEl) lineNameInputEl.value = routeSelectEl.value;
    }

    if(lineNameInputEl) lineNameInputEl.dispatchEvent(new Event('input', { bubbles:true, cancelable:true }));
}


function gen_populateDestinationSelect() {
    const lineNameInputEl = document.getElementById('gen_lineName');
    const destSelectEl = document.getElementById('gen_destinationSelect');
    if (!lineNameInputEl || !destSelectEl) return;

    const selectedRoute = lineNameInputEl.value;
    const previouslySelectedDestInDropdown = destSelectEl.value;

    destSelectEl.innerHTML = '';

    if (!selectedRoute) {
        destSelectEl.innerHTML = '<option value="">-- Enter/Select Route First --</option>';
        return;
    }

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        destSelectEl.innerHTML = '<option value="">-- No Schedule Data --</option>';
        return;
    }

    const relevantEntries = currentWorkingSchedule.filter(e =>
        e.lineName === selectedRoute && e.destinationName
    );

    const uniqueDestinations = [...new Set(relevantEntries.map(e => e.destinationName))]
        .sort((a, b) => String(a || "").toLowerCase().localeCompare(String(b || "").toLowerCase()));

    if (uniqueDestinations.length === 0) {
        destSelectEl.innerHTML = `<option value="">-- No Known Destinations for Route ${selectedRoute} --</option>`;
    } else {
        destSelectEl.innerHTML = '<option value="">-- Select Existing Destination --</option>';
        uniqueDestinations.forEach(destName => {
            const opt = document.createElement('option');
            opt.value = destName;
            opt.textContent = destName;
            destSelectEl.appendChild(opt);
        });
    }

    const destNameInputEl = document.getElementById('gen_destinationName');
    if (destNameInputEl && destNameInputEl.value && uniqueDestinations.includes(destNameInputEl.value)) {
        destSelectEl.value = destNameInputEl.value;
    } else if (previouslySelectedDestInDropdown && uniqueDestinations.includes(previouslySelectedDestInDropdown)) {
        destSelectEl.value = previouslySelectedDestInDropdown;
        if (destNameInputEl) destNameInputEl.value = destSelectEl.value;
    } else {
         if (destNameInputEl) destNameInputEl.value = destSelectEl.value;
    }
}


function gen_attachEventListenersForGeneratorSelects() {
    const stopNameSelect = document.getElementById('gen_stopNameSelect');
    const routeSelect = document.getElementById('gen_routeSelect');
    const destinationSelect = document.getElementById('gen_destinationSelect');
    const lineNameInputEl = document.getElementById('gen_lineName');
    const destNameInputEl = document.getElementById('gen_destinationName');

    if (stopNameSelect) {
        stopNameSelect.removeEventListener('change', gen_handleStopNameSelectChange);
        stopNameSelect.addEventListener('change', gen_handleStopNameSelectChange);
    }
    if (routeSelect) {
        routeSelect.removeEventListener('change', gen_handleRouteSelectChange);
        routeSelect.addEventListener('change', gen_handleRouteSelectChange);
    }
    if (destinationSelect) {
        destinationSelect.removeEventListener('change', gen_handleDestinationSelectChange);
        destinationSelect.addEventListener('change', gen_handleDestinationSelectChange);
    }

    if (lineNameInputEl) {
        lineNameInputEl.removeEventListener('input', gen_handleLineNameInputChange);
        lineNameInputEl.addEventListener('input', gen_handleLineNameInputChange);
        lineNameInputEl.removeEventListener('change', gen_saveDataToLocalStorage);
        lineNameInputEl.addEventListener('change', gen_saveDataToLocalStorage);
    }
    if (destNameInputEl) {
        destNameInputEl.removeEventListener('input', gen_saveDataToLocalStorage);
        destNameInputEl.addEventListener('input', gen_saveDataToLocalStorage);
        destNameInputEl.removeEventListener('change', gen_saveDataToLocalStorage);
        destNameInputEl.addEventListener('change', gen_saveDataToLocalStorage);
    }
}

function gen_handleLineNameInputChange() {
    gen_populateDestinationSelect();
    const lineNameInputEl = document.getElementById('gen_lineName');
    const routeSelectEl = document.getElementById('gen_routeSelect');
    if (lineNameInputEl && routeSelectEl) {
        const currentLineName = lineNameInputEl.value;
        let optionExists = Array.from(routeSelectEl.options).some(opt => opt.value === currentLineName);
        if(optionExists) {
            routeSelectEl.value = currentLineName;
        } else {
            routeSelectEl.selectedIndex = 0;
        }
    }
    gen_saveDataToLocalStorage();
}


function gen_handleStopNameSelectChange() {
    const stopNameSelect = document.getElementById('gen_stopNameSelect');
    const selectedOption = stopNameSelect.options[stopNameSelect.selectedIndex];
    const stopIdInput = document.getElementById('gen_stopId');
    const stopNameInput = document.getElementById('gen_stopName');
    const directionInput = document.getElementById('gen_direction');

    if (selectedOption && selectedOption.value) {
        if (stopIdInput) stopIdInput.value = selectedOption.value;
        if (stopNameInput) stopNameInput.value = selectedOption.dataset.stopname || '';
        if (directionInput) directionInput.value = selectedOption.dataset.direction || '';
    } else {
        if (stopIdInput) stopIdInput.value = '';
        if (stopNameInput) stopNameInput.value = '';
        if (directionInput) directionInput.value = '';
    }
    gen_saveDataToLocalStorage();
}

function gen_handleRouteSelectChange() {
    const routeSelect = document.getElementById('gen_routeSelect');
    const lineNameInput = document.getElementById('gen_lineName');
    if (lineNameInput) {
        lineNameInput.value = routeSelect.value;
        lineNameInput.dispatchEvent(new Event('input', { bubbles:true, cancelable:true }));
    }
}

function gen_handleDestinationSelectChange() {
    const destinationSelect = document.getElementById('gen_destinationSelect');
    const destNameInput = document.getElementById('gen_destinationName');
    if (destNameInput) {
        destNameInput.value = destinationSelect.value;
         destNameInput.dispatchEvent(new Event('input', { bubbles:true, cancelable:true }));
    }
}
// --- END: Schedule Generator Population & Interaction ---


function gen_addIntervalRule(ruleData = null) {
    gen_ruleCounter++;
    const container = document.getElementById('gen_intervalRulesContainer');
    if (!container) return;
    const ruleDiv = document.createElement('div');
    ruleDiv.className = 'gen_interval-rule';
    ruleDiv.id = `gen_rule-${gen_ruleCounter}`;
    ruleDiv.innerHTML = `
        <h4>Rule ${gen_ruleCounter}</h4>
        <div class="gen_input-group">
            <div>
                <label for="gen_startTime-${gen_ruleCounter}">Start Time (HHMM):</label>
                <input type="text" id="gen_startTime-${gen_ruleCounter}" class="schedule-generator-input" placeholder="e.g., 0900">
            </div>
            <div>
                <label for="gen_endTime-${gen_ruleCounter}">End Time (HHMM):</label>
                <input type="text" id="gen_endTime-${gen_ruleCounter}" class="schedule-generator-input" placeholder="e.g., 1900">
            </div>
            <div>
                <label for="gen_interval-${gen_ruleCounter}">Interval (minutes):</label>
                <input type="number" id="gen_interval-${gen_ruleCounter}" class="schedule-generator-input" min="1" placeholder="15">
            </div>
        </div>
        <button class="button small-action tertiary" onclick="gen_removeIntervalRule('gen_rule-${gen_ruleCounter}')" style="margin-left:0; margin-top:5px;">Remove Rule</button>
    `;
    container.appendChild(ruleDiv);

    if (ruleData) {
        const startTimeEl = document.getElementById(`gen_startTime-${gen_ruleCounter}`);
        const endTimeEl = document.getElementById(`gen_endTime-${gen_ruleCounter}`);
        const intervalEl = document.getElementById(`gen_interval-${gen_ruleCounter}`);
        if(startTimeEl) startTimeEl.value = ruleData.startTime || '';
        if(endTimeEl) endTimeEl.value = ruleData.endTime || '';
        if(intervalEl) intervalEl.value = ruleData.interval || '';
    }
}

function gen_removeIntervalRule(ruleId) {
    const ruleElement = document.getElementById(ruleId);
    if (ruleElement) {
        ruleElement.remove();
        gen_saveDataToLocalStorage();
    }
}

function gen_hhmmToMinutes(hhmmStr) {
    if (!hhmmStr || hhmmStr.length !== 4) return 0;
    const hours = parseInt(hhmmStr.substring(0, 2), 10);
    const minutes = parseInt(hhmmStr.substring(2, 4), 10);
    if (isNaN(hours) || isNaN(minutes)) return 0;
    return hours * 60 + minutes;
}

function gen_minutesToHHMM(totalMinutes) {
    const hours = Math.floor(totalMinutes / 60) % 24;
    const minutes = totalMinutes % 60;
    return String(hours).padStart(2, '0') + String(minutes).padStart(2, '0');
}

function gen_formatTimeToHHMMColon(hhmmStr) {
    const timeStr = String(hhmmStr || "").padStart(4, '0');
    if (timeStr.length === 4 && !isNaN(parseInt(timeStr,10))) {
         return timeStr.substring(0, 2) + ":" + timeStr.substring(2, 4);
    }
    return hhmmStr;
}

function gen_getBaseDataFromForm() {
    return {
        stopId: document.getElementById('gen_stopId')?.value.trim(),
        stopName: document.getElementById('gen_stopName')?.value.trim(),
        direction: document.getElementById('gen_direction')?.value.trim(),
        lineName: document.getElementById('gen_lineName')?.value.trim().toUpperCase(),
        destinationName: document.getElementById('gen_destinationName')?.value.trim(),
        operatingProfile: document.getElementById('gen_operatingProfile')?.value.trim(),
        initialScheduledTime: document.getElementById('gen_initialScheduledTime')?.value.trim(),
        initialDayOffset: document.getElementById('gen_initialDayOffset')?.value.trim() || '0'
    };
}

function gen_getIntervalRulesFromForm() {
    const intervalRulesData = [];
    document.querySelectorAll('#gen_intervalRulesContainer .gen_interval-rule').forEach(ruleElement => {
        const idNum = ruleElement.id.split('-')[1];
        const startTime = document.getElementById(`gen_startTime-${idNum}`)?.value.trim();
        const endTime = document.getElementById(`gen_endTime-${idNum}`)?.value.trim();
        const intervalValue = document.getElementById(`gen_interval-${idNum}`)?.value.trim();
        if (startTime || endTime || intervalValue) {
             intervalRulesData.push({
                startTime: startTime,
                endTime: endTime,
                interval: parseInt(intervalValue, 10) || 15
            });
        }
    });
    return intervalRulesData;
}

function gen_saveDataToLocalStorage() {
    if (document.getElementById('schedule-generator-section')?.style.display !== 'block' && !gen_isInitialized) {
        return;
    }
    try {
        const appData = {
            baseData: gen_getBaseDataFromForm(),
            intervalRules: gen_getIntervalRulesFromForm(),
            generatedSchedule: gen_currentScheduleEntries
        };
        localStorage.setItem(GEN_APP_DATA_KEY, JSON.stringify(appData));
    } catch (e) {
        console.error("Error saving generator data to localStorage:", e);
    }
}


function gen_loadDataFromLocalStorage() {
    const savedDataString = localStorage.getItem(GEN_APP_DATA_KEY);
    if (savedDataString) {
        try {
            const appData = JSON.parse(savedDataString);

            if (appData.baseData) {
                const fieldsToSet = {
                    'gen_stopId': appData.baseData.stopId,
                    'gen_stopName': appData.baseData.stopName,
                    'gen_direction': appData.baseData.direction,
                    'gen_lineName': appData.baseData.lineName,
                    'gen_destinationName': appData.baseData.destinationName,
                    'gen_operatingProfile': appData.baseData.operatingProfile,
                    'gen_initialScheduledTime': appData.baseData.initialScheduledTime,
                    'gen_initialDayOffset': appData.baseData.initialDayOffset || '0',
                };
                for (const id in fieldsToSet) {
                    const el = document.getElementById(id);
                    if (el) el.value = fieldsToSet[id] || '';
                }

                const gen_stopNameSelectEl = document.getElementById('gen_stopNameSelect');
                if (gen_stopNameSelectEl && appData.baseData.stopId) {
                    let optionExists = Array.from(gen_stopNameSelectEl.options).some(opt => opt.value === appData.baseData.stopId);
                    if (optionExists) {
                        gen_stopNameSelectEl.value = appData.baseData.stopId;
                    } else {
                         gen_stopNameSelectEl.selectedIndex = 0;
                    }
                }
                gen_stopNameSelectEl?.dispatchEvent(new Event('change'));

                setTimeout(() => {
                    const lineNameInputEl = document.getElementById('gen_lineName');
                    const routeSelectEl = document.getElementById('gen_routeSelect');
                    if (routeSelectEl && lineNameInputEl && lineNameInputEl.value) {
                        let optionExists = Array.from(routeSelectEl.options).some(opt => opt.value === lineNameInputEl.value);
                        if (optionExists) routeSelectEl.value = lineNameInputEl.value;
                        else routeSelectEl.selectedIndex = 0;
                    }
                    lineNameInputEl?.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));

                    setTimeout(() => {
                        const destNameInputEl = document.getElementById('gen_destinationName');
                        const destSelectEl = document.getElementById('gen_destinationSelect');
                        if (destSelectEl && destNameInputEl && destNameInputEl.value) {
                           let optionExists = Array.from(destSelectEl.options).some(opt => opt.value === destNameInputEl.value);
                           if(optionExists) destSelectEl.value = destNameInputEl.value;
                           else destSelectEl.selectedIndex = 0;
                        }
                    }, 150);
                }, 100);
            }

            const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
            if(intervalRulesContainer) intervalRulesContainer.innerHTML = '';
            gen_ruleCounter = 0;
            (appData.intervalRules || []).forEach(ruleData => gen_addIntervalRule(ruleData));

            gen_currentScheduleEntries = appData.generatedSchedule || [];
            gen_renderScheduleTable();
        } catch (e) {
            console.error("Error loading generator data from localStorage:", e);
            localStorage.removeItem(GEN_APP_DATA_KEY);
        }
    } else {
        const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
        if (intervalRulesContainer && intervalRulesContainer.childElementCount === 0) {
            gen_addIntervalRule();
        }
        document.getElementById('gen_stopNameSelect')?.dispatchEvent(new Event('change'));
    }
}


function gen_clearAllData() {
    if (confirm("Are you sure you want to clear all data for the Schedule Generator? This includes base data, interval rules and the current generated schedule table. This cannot be undone.")) {
        const fieldsToClear = [
            'gen_stopId', 'gen_stopName', 'gen_direction',
            'gen_lineName', 'gen_destinationName',
            'gen_operatingProfile', 'gen_initialScheduledTime', 'gen_initialDayOffset'
        ];
        fieldsToClear.forEach(id => {
            const el = document.getElementById(id);
            if(el) el.value = '';
        });

        ['gen_stopNameSelect', 'gen_routeSelect', 'gen_destinationSelect'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.selectedIndex = 0;
        });
        const initialDayOffsetEl = document.getElementById('gen_initialDayOffset');
        if(initialDayOffsetEl) initialDayOffsetEl.value = '0';

        const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
        if(intervalRulesContainer) intervalRulesContainer.innerHTML = '';
        gen_ruleCounter = 0;
        gen_addIntervalRule();

        gen_currentScheduleEntries = [];
        gen_renderScheduleTable();

        localStorage.removeItem(GEN_APP_DATA_KEY);
        alert("All generator data has been cleared.");

        document.getElementById('gen_stopNameSelect')?.dispatchEvent(new Event('change'));
    }
}

function gen_generateSchedule() {
    gen_currentScheduleEntries = [];
    const addedEntryKeys = new Set();

    const baseFormValues = gen_getBaseDataFromForm();
    const baseDataForGeneration = {
        stopId: baseFormValues.stopId,
        stopName: baseFormValues.stopName,
        direction: baseFormValues.direction,
        lineName: baseFormValues.lineName,
        destinationName: baseFormValues.destinationName,
        operatingProfile: baseFormValues.operatingProfile,
    };

    if (baseFormValues.initialScheduledTime && baseFormValues.initialScheduledTime.match(/^\d{3,4}$/)) {
        const initialEntry = {
            ...baseDataForGeneration,
            scheduledTime: baseFormValues.initialScheduledTime.padStart(4,'0'),
            dayOffset: baseFormValues.initialDayOffset || '0'
        };
        const initialKey = `${initialEntry.stopId}-${initialEntry.lineName}-${initialEntry.scheduledTime}-${initialEntry.operatingProfile}`;
        gen_currentScheduleEntries.push(initialEntry);
        addedEntryKeys.add(initialKey);
    }

    const intervalRules = gen_getIntervalRulesFromForm();
    intervalRules.forEach(rule => {
        const startTimeStr = rule.startTime;
        const endTimeStr = rule.endTime;
        const intervalMins = parseInt(rule.interval, 10);

        if (!startTimeStr || !startTimeStr.match(/^\d{3,4}$/) ||
            !endTimeStr || !endTimeStr.match(/^\d{3,4}$/) ||
            isNaN(intervalMins) || intervalMins <= 0) {
            console.warn(`Generator: Skipping invalid rule: Start-${startTimeStr}, End-${endTimeStr}, Interval-${rule.interval}`);
            return;
        }

        let currentTotalMinutes = gen_hhmmToMinutes(startTimeStr.padStart(4,'0'));
        const endTotalMinutesInput = gen_hhmmToMinutes(endTimeStr.padStart(4,'0'));
        let effectiveEndTotalMinutes = endTotalMinutesInput;

        if (currentTotalMinutes > endTotalMinutesInput && startTimeStr > endTimeStr) {
             effectiveEndTotalMinutes += 24 * 60;
        }

        const ruleStartHourForContext = parseInt(startTimeStr.padStart(4,'0').substring(0, 2), 10);
        const isRuleConsideredNewDayService = (ruleStartHourForContext >= 0 && ruleStartHourForContext <= 3);

        while (currentTotalMinutes <= effectiveEndTotalMinutes) {
            const scheduledTimeHHMM = gen_minutesToHHMM(currentTotalMinutes);
            const entryKey = `${baseDataForGeneration.stopId}-${baseDataForGeneration.lineName}-${scheduledTimeHHMM}-${baseDataForGeneration.operatingProfile}`;

            if (!addedEntryKeys.has(entryKey)) {
                let generatedDayOffset = 0;
                const currentGeneratedHour = parseInt(scheduledTimeHHMM.substring(0,2), 10);

                if (isRuleConsideredNewDayService) {
                    generatedDayOffset = 0;
                } else {
                    if (currentTotalMinutes >= 1440 && (currentGeneratedHour >=0 && currentGeneratedHour <=3)) {
                         generatedDayOffset = 1;
                    } else {
                        generatedDayOffset = 0;
                    }
                }

                gen_currentScheduleEntries.push({
                    ...baseDataForGeneration,
                    scheduledTime: scheduledTimeHHMM,
                    dayOffset: generatedDayOffset
                });
                addedEntryKeys.add(entryKey);
            }

            if (intervalMins === 0) break;
            currentTotalMinutes += intervalMins;
        }
    });
    gen_renderScheduleTable();
    gen_saveDataToLocalStorage();
}

function gen_deleteScheduleEntry(index) {
    if (index < 0 || index >= gen_currentScheduleEntries.length) {
        console.error("Invalid index for deletion:", index);
        return;
    }
    const entryToDelete = gen_currentScheduleEntries[index];
    let timeToDisplay = entryToDelete.scheduledTime || "";
    if (timeToDisplay.length === 4 && !isNaN(timeToDisplay)) {
        timeToDisplay = `${timeToDisplay.substring(0,2)}:${timeToDisplay.substring(2,4)}`;
    } else if (timeToDisplay.length === 3 && !isNaN(timeToDisplay)) {
            timeToDisplay = `0${timeToDisplay.substring(0,1)}:${timeToDisplay.substring(1,3)}`;
    }

    if (confirm(`Are you sure you want to delete this entry from the generator's table?\nStop: ${entryToDelete.stopId} - ${entryToDelete.stopName}\nLine: ${entryToDelete.lineName}\nTime: ${timeToDisplay}\nDest: ${entryToDelete.destinationName}`)) {
        gen_currentScheduleEntries.splice(index, 1);
        gen_renderScheduleTable();
        gen_saveDataToLocalStorage();
        console.log("Entry deleted from generator list and local storage updated.");
    }
}

function gen_renderScheduleTable() {
    const resultsTable = document.getElementById('gen_resultsTable');
    if (!resultsTable) return;
    const resultsBody = resultsTable.getElementsByTagName('tbody')[0];
    const resultsHead = resultsTable.getElementsByTagName('thead')[0];
    if (!resultsBody || !resultsHead) return;

    resultsBody.innerHTML = '';

    if (resultsHead.rows.length > 0) {
        let headerRow = resultsHead.rows[0];
        if (headerRow.cells.length === 8 && headerRow.cells[7].textContent !== "Actions") {
            let th = document.createElement('th');
            th.textContent = 'Actions';
            headerRow.appendChild(th);
        } else if (headerRow.cells.length === 0) {
            headerRow.innerHTML = `<th>StopID</th><th>StopName</th><th>Direction</th><th>LineName</th><th>DestinationName</th><th>ScheduledTime (HH:MM)</th><th>OperatingProfile</th><th>DayOffset</th><th>Actions</th>`;
        } else if (headerRow.cells.length > 0 && headerRow.cells[headerRow.cells.length - 1].textContent !== "Actions") {
            let th = document.createElement('th');
            th.textContent = 'Actions';
            headerRow.appendChild(th);
        }
    } else {
        let header = resultsTable.createTHead();
        let row = header.insertRow(0);
        row.innerHTML = `<th>StopID</th><th>StopName</th><th>Direction</th><th>LineName</th><th>DestinationName</th><th>ScheduledTime (HH:MM)</th><th>OperatingProfile</th><th>DayOffset</th><th>Actions</th>`;
    }


    gen_currentScheduleEntries.forEach((entry, index) => {
        let newRow = resultsBody.insertRow();
        newRow.insertCell().textContent = entry.stopId || '';
        newRow.insertCell().textContent = entry.stopName || '';
        newRow.insertCell().textContent = entry.direction || '';
        newRow.insertCell().textContent = entry.lineName || '';
        newRow.insertCell().textContent = entry.destinationName || '';

        let displayTime = entry.scheduledTime || "";
        if (displayTime.length === 4 && !isNaN(displayTime)) {
            displayTime = `${displayTime.substring(0,2)}:${displayTime.substring(2,4)}`;
        } else if (displayTime.length === 3 && !isNaN(displayTime)) {
             displayTime = `0${displayTime.substring(0,1)}:${displayTime.substring(1,3)}`;
        }
        newRow.insertCell().textContent = displayTime;

        newRow.insertCell().textContent = entry.operatingProfile || '';
        newRow.insertCell().textContent = String(entry.dayOffset || '0');

        let actionCell = newRow.insertCell();
        let deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.classList.add('button', 'small-action', 'secondary');
        deleteButton.style.padding = '0.2rem 0.4rem';
        deleteButton.style.fontSize = '0.8rem';
        deleteButton.onclick = function() { gen_deleteScheduleEntry(index); };
        actionCell.appendChild(deleteButton);
    });
}


function gen_exportToCountFile() {
    if (gen_currentScheduleEntries.length === 0) {
        alert("No schedule data to export from generator. Please generate a schedule first.");
        return;
    }

    const headers = [
        "StopID", "StopName", "Direction", "LineName",
        "DestinationName", "ScheduledTime", "OperatingProfile", "DayOffset"
    ];

    let tabText = headers.join("\t") + "\n";

    gen_currentScheduleEntries.forEach(entry => {
        let formattedTime = entry.scheduledTime;
        if (formattedTime && formattedTime.length === 4 && !formattedTime.includes(':')) {
            formattedTime = `${formattedTime.substring(0,2)}:${formattedTime.substring(2,4)}`;
        } else if (formattedTime && formattedTime.length === 3 && !formattedTime.includes(':')) {
            formattedTime = `0${formattedTime.substring(0,1)}:${formattedTime.substring(1,3)}`;
        }

        const rowValues = [
            entry.stopId, entry.stopName, entry.direction, entry.lineName,
            entry.destinationName, formattedTime, entry.operatingProfile, String(entry.dayOffset || '0')
        ];
        tabText += rowValues.map(val => String(val || '').replace(/\t|\n|\r/g, " ")).join("\t") + "\n";
    });

    const blob = new Blob([tabText], { type: 'text/plain;charset=utf-8;' });
    const link = document.createElement("a");

    if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "schedule_generated.count");
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    } else {
        alert("Your browser does not support automatic file downloading.");
    }
}

function gen_handleAddGeneratedToWorkingSchedule() {
    if (!currentUser) {
        alert("Please log in to modify the working schedule.");
        return;
    }
    if (!gen_currentScheduleEntries || gen_currentScheduleEntries.length === 0) {
        alert("No schedule entries generated/loaded in the generator's table to add. Please generate or load a schedule into the generator table first.");
        return;
    }

    const actionChoice = prompt("Choose action for adding entries from the generator's table to the main working schedule:\n1. OVERWRITE entire working schedule.\n2. APPEND to existing working schedule.\n\nEnter 1 or 2 (or Cancel):");

    if (actionChoice !== "1" && actionChoice !== "2") {
        if (actionChoice !== null) {
            alert("Invalid choice. Operation cancelled.");
        }
        return;
    }

    const isOverwrite = actionChoice === "1";

    if (isOverwrite) {
        if (!confirm(`ARE YOU SURE you want to OVERWRITE the ENTIRE main working schedule with these ${gen_currentScheduleEntries.length} entries from the generator's table? This cannot be undone easily.`)) {
            return;
        }
        currentWorkingSchedule = [];
    } else {
        if (!confirm(`Are you sure you want to APPEND these ${gen_currentScheduleEntries.length} entries from the generator's table to the main working schedule?`)) {
            return;
        }
    }

    let addedCount = 0;
    const newEntriesForWorkingSchedule = gen_currentScheduleEntries.map((genEntry, index) => {
        let scheduledTimeForWorking = genEntry.scheduledTime || "";
        if (scheduledTimeForWorking && scheduledTimeForWorking.length === 4 && !scheduledTimeForWorking.includes(':')) {
            scheduledTimeForWorking = `${scheduledTimeForWorking.substring(0,2)}:${scheduledTimeForWorking.substring(2,4)}`;
        } else if (scheduledTimeForWorking && scheduledTimeForWorking.length === 3 && !scheduledTimeForWorking.includes(':')) {
            scheduledTimeForWorking = `0${scheduledTimeForWorking.substring(0,1)}:${scheduledTimeForWorking.substring(1,3)}`;
        }

        const uniqueSuffix = Date.now() + "_" + index + (isOverwrite ? "_ow_gen" : "_app_gen");
        const internalId = `${(genEntry.stopId||'s').toUpperCase()}_${(genEntry.lineName||'l').toUpperCase()}_${(genEntry.scheduledTime||"").replace(':','')}_${uniqueSuffix}`;

        addedCount++;
        return {
            internalId: internalId,
            stopID: (genEntry.stopId || "").toUpperCase(),
            stopName: genEntry.stopName || "",
            direction: genEntry.direction || "",
            lineName: (genEntry.lineName || "").toUpperCase(),
            destinationName: genEntry.destinationName || "",
            scheduledTime: scheduledTimeForWorking,
            OperatingProfile: genEntry.operatingProfile || "",
            DayOffset: String(genEntry.dayOffset || "0")
        };
    });

    currentWorkingSchedule.push(...newEntriesForWorkingSchedule);
    alert(`${addedCount} entries from the generator's table have been ${isOverwrite ? 'set as (overwritten)' : 'appended to'} the main working schedule.`);
    renderUIDependentElements();
}


function gen_handleGetWorkingSchedule() {
    if (!currentUser) {
        alert("Please log in to access the working schedule.");
        return;
    }

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        alert("The main working schedule is currently empty. Nothing to load into the generator's table.");
        return;
    }

    if (!confirm(`This will replace the current list in the generator's table with all ${currentWorkingSchedule.length} entries from the main working schedule. Are you sure?`)) {
        return;
    }

    let tempSchedule = currentWorkingSchedule.map(entry => {
        let internalGenScheduledTime = entry.scheduledTime || "";
        if (internalGenScheduledTime.includes(':')) {
            internalGenScheduledTime = internalGenScheduledTime.replace(':', '');
        }
        internalGenScheduledTime = internalGenScheduledTime.padStart(4, '0');

        return {
            stopId: entry.stopID || "",
            stopName: entry.stopName || "",
            direction: entry.direction || "",
            lineName: entry.lineName || "",
            destinationName: entry.destinationName || "",
            scheduledTime: internalGenScheduledTime,
            operatingProfile: entry.OperatingProfile || "",
            dayOffset: String(entry.DayOffset || "0")
        };
    });

    tempSchedule.sort((a, b) => {
        const lineCompare = compareLineNames(a.lineName, b.lineName);
        if (lineCompare !== 0) return lineCompare;

        const stopNameA = (a.stopName || "").toLowerCase();
        const stopNameB = (b.stopName || "").toLowerCase();
        if (stopNameA < stopNameB) return -1;
        if (stopNameA > stopNameB) return 1;

        const timeA = a.scheduledTime || "9999";
        const timeB = b.scheduledTime || "9999";
        if (timeA < timeB) return -1;
        if (timeA > timeB) return 1;

        const dayOffsetA = parseInt(a.dayOffset, 10);
        const dayOffsetB = parseInt(b.dayOffset, 10);
        if (dayOffsetA < dayOffsetB) return -1;
        if (dayOffsetA > dayOffsetB) return 1;

        return 0;
    });

    gen_currentScheduleEntries = tempSchedule;

    gen_renderScheduleTable();
    gen_saveDataToLocalStorage();

    alert(`Loaded and sorted ${gen_currentScheduleEntries.length} entries from the main working schedule into the generator's table.`);
}

function gen_handleLoadStopSchedule() {
    if (!currentUser) {
        alert("Please log in to access the working schedule.");
        return;
    }
    const stopSelectEl = document.getElementById('gen_stopNameSelect');
    const selectedStopId = stopSelectEl ? stopSelectEl.value : null;

    if (!selectedStopId) {
        alert("Please select a stop first from the 'Select Stop' dropdown in the 'Base Data' section above.");
        return;
    }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        alert("The main working schedule is currently empty. Nothing to load.");
        return;
    }
    if (!confirm(`This will replace the current list in the generator's table with all schedule entries for stop "${selectedStopId}" from the main working schedule. Are you sure?`)) {
        return;
    }

    const entriesForSelectedStop = currentWorkingSchedule.filter(entry => entry.stopID === selectedStopId);

    if (entriesForSelectedStop.length === 0) {
        alert(`No schedule entries found for stop "${selectedStopId}" in the main working schedule.`);
        gen_currentScheduleEntries = [];
    } else {
        let tempSchedule = entriesForSelectedStop.map(entry => {
            let internalGenScheduledTime = entry.scheduledTime || "";
            if (internalGenScheduledTime.includes(':')) {
                internalGenScheduledTime = internalGenScheduledTime.replace(':', '');
            }
            internalGenScheduledTime = internalGenScheduledTime.padStart(4, '0');
            return {
                stopId: entry.stopID || "", stopName: entry.stopName || "", direction: entry.direction || "",
                lineName: entry.lineName || "", destinationName: entry.destinationName || "",
                scheduledTime: internalGenScheduledTime, operatingProfile: entry.OperatingProfile || "",
                dayOffset: String(entry.DayOffset || "0")
            };
        });
        tempSchedule.sort((a, b) => {
            const lineCompare = compareLineNames(a.lineName, b.lineName);
            if (lineCompare !== 0) return lineCompare;
            const timeA = a.scheduledTime || "9999";
            const timeB = b.scheduledTime || "9999";
            if (timeA < timeB) return -1; if (timeA > timeB) return 1;
            const dayOffsetA = parseInt(a.dayOffset, 10); const dayOffsetB = parseInt(b.dayOffset, 10);
            if (dayOffsetA < dayOffsetB) return -1; if (dayOffsetA > dayOffsetB) return 1;
            return 0;
        });
        gen_currentScheduleEntries = tempSchedule;
    }
    gen_renderScheduleTable();
    gen_saveDataToLocalStorage();
    if (entriesForSelectedStop.length > 0) {
        alert(`Loaded and sorted ${gen_currentScheduleEntries.length} schedule entries for stop "${selectedStopId}" into the generator's table.`);
    }
}


function gen_initializeScheduleGeneratorControls() {
    gen_populateStopNameSelect();
    gen_populateRouteSelect();

    if (gen_isInitialized) {
        const lineNameInputEl = document.getElementById('gen_lineName');
        if (lineNameInputEl) lineNameInputEl.dispatchEvent(new Event('input'));
        return;
    }
    console.log("Initializing Schedule Generator Controls (First Time)...");

    gen_attachEventListenersForGeneratorSelects();
    gen_loadDataFromLocalStorage();

    const gen_baseDataInputsIds = [
        'gen_operatingProfile', 'gen_initialScheduledTime', 'gen_initialDayOffset'
    ];

    gen_baseDataInputsIds.forEach(id => {
        const element = document.getElementById(id);
        if (element && (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'select')) {
            const eventType = element.tagName.toLowerCase() === 'select' ? 'change' : 'input';
            element.removeEventListener(eventType, gen_saveDataToLocalStorage);
            element.addEventListener(eventType, gen_saveDataToLocalStorage);
        }
    });

    const gen_intervalContainer = document.getElementById('gen_intervalRulesContainer');
    if (gen_intervalContainer) {
        gen_intervalContainer.removeEventListener('input', gen_handleIntervalContainerInput);
        gen_intervalContainer.addEventListener('input', gen_handleIntervalContainerInput);
    }
    function gen_handleIntervalContainerInput(event) {
        const target = event.target;
        if (target.tagName.toLowerCase() === 'input' && target.closest('.gen_interval-rule')) {
             gen_saveDataToLocalStorage();
        }
    }

    const intervalRulesContainer = document.getElementById('gen_intervalRulesContainer');
    if (intervalRulesContainer && intervalRulesContainer.childElementCount === 0) {
        gen_addIntervalRule();
    }

    // --- Button Listeners ---
    const btnGenerate = document.getElementById('gen_generateScheduleButton');
    if (btnGenerate) { btnGenerate.removeEventListener('click', gen_generateSchedule); btnGenerate.addEventListener('click', gen_generateSchedule); }

    const btnExport = document.getElementById('gen_exportToCountButton');
    if (btnExport) { btnExport.removeEventListener('click', gen_exportToCountFile); btnExport.addEventListener('click', gen_exportToCountFile); }

    const btnAddToWorking = document.getElementById('gen_addToWorkingScheduleButton');
    if (btnAddToWorking) { btnAddToWorking.removeEventListener('click', gen_handleAddGeneratedToWorkingSchedule); btnAddToWorking.addEventListener('click', gen_handleAddGeneratedToWorkingSchedule); }

    const btnGetWorkingSchedule = document.getElementById('gen_getWorkingScheduleButton');
    if (btnGetWorkingSchedule) { btnGetWorkingSchedule.removeEventListener('click', gen_handleGetWorkingSchedule); btnGetWorkingSchedule.addEventListener('click', gen_handleGetWorkingSchedule); }

    const btnLoadStopSchedule = document.getElementById('gen_loadStopScheduleButton');
    if (btnLoadStopSchedule) { btnLoadStopSchedule.removeEventListener('click', gen_handleLoadStopSchedule); btnLoadStopSchedule.addEventListener('click', gen_handleLoadStopSchedule); }

    const btnClear = document.getElementById('gen_clearAllDataButton');
    if (btnClear) { btnClear.removeEventListener('click', gen_clearAllData); btnClear.addEventListener('click', gen_clearAllData); }

    const btnAddRule = document.getElementById('gen_addIntervalRuleButton');
    function gen_addIntervalRuleHandler() { gen_addIntervalRule(null); }
    if (btnAddRule) { btnAddRule.removeEventListener('click', gen_addIntervalRuleHandler); btnAddRule.addEventListener('click', gen_addIntervalRuleHandler); }

    gen_isInitialized = true;
    console.log("Schedule Generator Controls Initialized/Refreshed.");
}
// --- END: Schedule Generator ---

// --- START: Schedule Copier (within Schedule Generator) Tool Specific Functions ---
function populateCopierStopSelectors() {
    const uniqueStops = getUniqueStopsFromSchedule();

    if (sgCopierSourceStopSelect) {
        const currentSourceVal = sgCopierSourceStopSelect.value;
        sgCopierSourceStopSelect.innerHTML = '<option value="">-- Select Source Stop --</option>';
        uniqueStops.forEach(stop => {
            const opt = document.createElement('option');
            opt.value = stop.stopID;
            opt.textContent = `${stop.stopName} (${stop.stopID})`;
            sgCopierSourceStopSelect.appendChild(opt);
        });
        if (uniqueStops.find(s => s.stopID === currentSourceVal)) {
            sgCopierSourceStopSelect.value = currentSourceVal;
        }
        sgCopierSourceStopSelect.dispatchEvent(new Event('change'));
    }

    if (sgCopierTargetStopSelect) {
        const currentTargetVal = sgCopierTargetStopSelect.value;
        sgCopierTargetStopSelect.innerHTML = '<option value="">-- Select Target Stop --</option>';
        uniqueStops.forEach(stop => {
            const opt = document.createElement('option');
            opt.value = stop.stopID;
            opt.textContent = `${stop.stopName} (${stop.stopID})`;
            sgCopierTargetStopSelect.appendChild(opt);
        });
        if (uniqueStops.find(s => s.stopID === currentTargetVal)) {
            sgCopierTargetStopSelect.value = currentTargetVal;
        }
    }
}

function displayRoutesForCopierSourceStop() {
    if (!sgCopierSourceStopSelect || !sgCopierSourceRoutesContainer || !sgCopierSourceRoutesPlaceholder) return;
    const selectedStopID = sgCopierSourceStopSelect.value;
    sgCopierSourceRoutesContainer.innerHTML = '';

    if (!selectedStopID) {
        sgCopierSourceRoutesPlaceholder.textContent = 'Select a source stop to see routes.';
        sgCopierSourceRoutesPlaceholder.style.display = 'block';
        return;
    }

    const servingRoutes = new Set();
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID === selectedStopID && entry.lineName) {
            servingRoutes.add(entry.lineName);
        }
    });

    const sortedRoutes = Array.from(servingRoutes).sort(compareLineNames);

    if (sortedRoutes.length === 0) {
        sgCopierSourceRoutesPlaceholder.textContent = `No routes found serving stop ${selectedStopID}.`;
        sgCopierSourceRoutesPlaceholder.style.display = 'block';
    } else {
        sgCopierSourceRoutesPlaceholder.style.display = 'none';
        sortedRoutes.forEach(lineName => {
            const tile = document.createElement('span');
            tile.classList.add('route-tile-tools-list', 'copier-route-tile');
            tile.textContent = lineName;
            tile.dataset.lineName = lineName;

            const bgColor = getRouteTileColourForTools(lineName, selectedStopID);
            tile.style.backgroundColor = bgColor;
            tile.style.color = getTextColourForBackgroundTools(bgColor);
            tile.style.cursor = 'pointer';
            tile.style.margin = '0.25em';
            tile.style.padding = '0.4em 0.8em';
            tile.style.display = 'inline-block';
            tile.setAttribute('role', 'checkbox');
            tile.setAttribute('aria-checked', 'false');
            tile.setAttribute('tabindex', '0');

            tile.addEventListener('click', () => {
                const isSelected = tile.classList.toggle('selected-tile');
                tile.setAttribute('aria-checked', isSelected.toString());
                if (isSelected) {
                    tile.style.outline = '2px solid #3498db';
                } else {
                    tile.style.outline = 'none';
                }
            });

            tile.addEventListener('keydown', (event) => {
                if (event.key === ' ' || event.key === 'Enter') {
                    event.preventDefault();
                    tile.click();
                }
            });
            sgCopierSourceRoutesContainer.appendChild(tile);
        });
    }
}

function handleCopySchedules() {
    if (!sgCopierSourceStopSelect || !sgCopierStatusMessage) return;
    const sourceStopID = sgCopierSourceStopSelect.value;
    if (!sourceStopID) {
        sgCopierStatusMessage.textContent = 'Please select a source stop first.';
        sgCopierStatusMessage.style.color = '#f1c40f';
        return;
    }

    const selectedRouteTiles = document.querySelectorAll('#sgCopierSourceRoutesContainer .copier-route-tile.selected-tile');

    if (selectedRouteTiles.length === 0) {
        sgCopierStatusMessage.textContent = 'Please select at least one route to copy.';
        sgCopierStatusMessage.style.color = '#f1c40f';
        return;
    }

    const selectedRoutes = Array.from(selectedRouteTiles).map(tile => tile.dataset.lineName);
    copiedScheduleEntries = [];

    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID === sourceStopID && selectedRoutes.includes(entry.lineName)) {
            copiedScheduleEntries.push(JSON.parse(JSON.stringify(entry)));
        }
    });

    if (copiedScheduleEntries.length > 0) {
        sgCopierStatusMessage.textContent = `${copiedScheduleEntries.length} schedule entries for routes [${selectedRoutes.join(', ')}] from stop ${sourceStopID} copied. Now select a target stop and adjustment.`;
        sgCopierStatusMessage.style.color = '#2ecc71';
    } else {
        sgCopierStatusMessage.textContent = `No schedule entries found for the selected routes at stop ${sourceStopID}.`;
        sgCopierStatusMessage.style.color = '#f1c40f';
    }
}

function adjustScheduledTime(timeStr, adjustmentMinutes) {
    if (!timeStr || !timeStr.match(/^\d{2}:\d{2}$/)) {
        console.warn(`Invalid time format for adjustment: ${timeStr}`);
        return { newTime: timeStr, dayOffsetChange: 0 };
    }
    const [hours, minutes] = timeStr.split(':').map(Number);
    let totalMinutes = (hours * 60) + minutes + adjustmentMinutes;
    const oneDayInMinutes = 24 * 60;
    let dayOffsetChange = 0;

    if (totalMinutes < 0) {
        dayOffsetChange = -1;
        totalMinutes += oneDayInMinutes;
    } else if (totalMinutes >= oneDayInMinutes) {
        dayOffsetChange = 1;
        totalMinutes -= oneDayInMinutes;
    }

    const newHours = Math.floor(totalMinutes / 60);
    const newMinutes = totalMinutes % 60;

    return {
        newTime: `${String(newHours).padStart(2, '0')}:${String(newMinutes).padStart(2, '0')}`,
        dayOffsetChange: dayOffsetChange
    };
}

function handlePasteSchedules() {
    if (!currentUser) {
        sgCopierStatusMessage.textContent = 'Please log in to modify the schedule.';
        sgCopierStatusMessage.style.color = '#e74c3c';
        return;
    }
    if (copiedScheduleEntries.length === 0) {
        sgCopierStatusMessage.textContent = 'No schedules have been copied yet. Please use "Copy Selected Schedules" first.';
        sgCopierStatusMessage.style.color = '#f1c40f';
        return;
    }

    const targetStopID = sgCopierTargetStopSelect.value;
    if (!targetStopID) {
        sgCopierStatusMessage.textContent = 'Please select a target stop.';
        sgCopierStatusMessage.style.color = '#f1c40f';
        return;
    }

    const timeAdjustmentStr = sgCopierTimeAdjustmentInput.value.trim();
    const timeAdjustmentMinutes = parseInt(timeAdjustmentStr, 10);

    if (isNaN(timeAdjustmentMinutes)) {
        sgCopierStatusMessage.textContent = 'Invalid time adjustment. Please enter a number (e.g., +5, -10, or 0).';
        sgCopierStatusMessage.style.color = '#e74c3c';
        return;
    }

    const targetStopDetails = getUniqueStopsFromSchedule().find(s => s.stopID === targetStopID);
    if (!targetStopDetails) {
        sgCopierStatusMessage.textContent = `Could not find details for target stop ID: ${targetStopID}.`;
        sgCopierStatusMessage.style.color = '#e74c3c';
        return;
    }

    const newEntriesForWorkingSchedule = [];
    copiedScheduleEntries.forEach((copiedEntry, index) => {
        const newEntry = JSON.parse(JSON.stringify(copiedEntry));

        newEntry.stopID = targetStopDetails.stopID;
        newEntry.stopName = targetStopDetails.stopName;
        newEntry.direction = targetStopDetails.direction;

        const { newTime, dayOffsetChange } = adjustScheduledTime(newEntry.scheduledTime, timeAdjustmentMinutes);
        newEntry.scheduledTime = newTime;

        let originalDayOffset = parseInt(newEntry.DayOffset || "0", 10);
        newEntry.DayOffset = String(originalDayOffset + dayOffsetChange);

        if (parseInt(newEntry.DayOffset, 10) < 0) {
            newEntry.DayOffset = "0"; // Clamp negative day offsets
        }

        const uniqueSuffix = `_copied_sg_${Date.now()}_${index}`;
        newEntry.internalId = `${targetStopDetails.stopID.toUpperCase()}_${newEntry.lineName.toUpperCase()}_${newEntry.scheduledTime.replace(':', '')}${uniqueSuffix}`;

        newEntriesForWorkingSchedule.push(newEntry);
    });

    if (newEntriesForWorkingSchedule.length > 0) {
        if (confirm(`This will add ${newEntriesForWorkingSchedule.length} new schedule entries to Stop "${targetStopDetails.stopName} (${targetStopDetails.stopID})" with a time adjustment of ${timeAdjustmentMinutes} minutes to the MAIN WORKING SCHEDULE. Proceed?`)) {
            currentWorkingSchedule.push(...newEntriesForWorkingSchedule);
            sgCopierStatusMessage.textContent = `${newEntriesForWorkingSchedule.length} schedule entries pasted to stop ${targetStopDetails.stopID} with adjustment. Added to main working schedule.`;
            sgCopierStatusMessage.style.color = '#2ecc71';
            copiedScheduleEntries = [];
            renderUIDependentElements();
        } else {
            sgCopierStatusMessage.textContent = 'Paste operation cancelled by user.';
            sgCopierStatusMessage.style.color = '#f1c40f';
        }
    } else {
        sgCopierStatusMessage.textContent = 'No valid entries were processed for pasting.';
        sgCopierStatusMessage.style.color = '#e74c3c';
    }
}

function initializeScheduleGeneratorCopierControls() {
    if (!sgCopierSourceStopSelect || !sgCopierCopySchedulesButton || !sgCopierPasteSchedulesButton) {
        console.warn("Schedule Copier (SG) DOM elements not found, cannot initialize.");
        return;
    }
    populateCopierStopSelectors();
    sgCopierSourceStopSelect.removeEventListener('change', displayRoutesForCopierSourceStop);
    sgCopierSourceStopSelect.addEventListener('change', displayRoutesForCopierSourceStop);

    sgCopierCopySchedulesButton.removeEventListener('click', handleCopySchedules);
    sgCopierCopySchedulesButton.addEventListener('click', handleCopySchedules);

    sgCopierPasteSchedulesButton.removeEventListener('click', handlePasteSchedules);
    sgCopierPasteSchedulesButton.addEventListener('click', handlePasteSchedules);
    console.log("Schedule Generator's Copier Controls Initialized.");
}
// --- END: Schedule Copier (within Schedule Generator) Tool Specific Functions ---


// --- UI Navigation & State ---
function showSection(sectionId) {
    allToolContentSections.forEach(section => {
        section.style.display = 'none';
    });
    const sectionToShow = document.getElementById(sectionId);
    if (sectionToShow) {
        sectionToShow.style.display = 'block';
        const isMainButtonSection = Array.from(mainMenuButtons).some(btn => btn.getAttribute('data-section') === sectionId);
        if (isMainButtonSection) {
            localStorage.setItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY, sectionId);
            // Section-specific initializations
            if (sectionId === 'bulk-edit-tools-section') {
                populateRouteSelectorForColours();
                renderGlobalCustomRouteColours();
                populateStopSelectorForSpecificColours();
                renderStopSpecificRouteColours();
                 if (selectStopForSpecificRouteColour && selectStopForSpecificRouteColour.value) {
                    displayRoutesForSpecificColouring();
                }
            }
            if (sectionId === 'stop-management-tool-section') {
                populateMasterStopList_SM();
            }
            // Removed 'event-generator-section' and 'stop-status-section' specific initializations
            if (sectionId === 'view-departures-section') populateStopSelectorForDeparturesView();

            if (sectionId === 'add-remove-stop-section') {
                handleSuggestStopId_ARS();
                populateStopToRemoveSelector_ARS();
            }
            if (sectionId === 'schedule-generator-section') {
                gen_initializeScheduleGeneratorControls();
                initializeScheduleGeneratorCopierControls();
            }
            if (sectionId === 'analytics-validation-section') {
                populateConsolidateStopSelect();
            }
            if (sectionId === 'global-route-deletion-section') {
                populateGlobalRouteToDeleteSelector();
            }
        }
    } else {
        console.warn(`Attempted to show non-existent section: ${sectionId}`);
        localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
    }
}


function hideAllToolSections() {
    allToolContentSections.forEach(section => {
        section.style.display = 'none';
    });
}

function updateAuthUI(user) {
    currentUser = user;
    hideAllToolSections();

    if (user) {
        if (adminLoginSection) adminLoginSection.style.display = 'none';
        if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'block';
        if (topMenuBar) topMenuBar.style.display = 'block';
        if (logoutContainer) logoutContainer.style.display = 'block';
        if (loginFormContainer) loginFormContainer.style.display = 'none';
        if (authStatus) authStatus.textContent = '';
        if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = user.email;
        initializeAutoApplyScheduler();


        const lastActiveSection = localStorage.getItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        let sectionActuallyShown = false;
        if (lastActiveSection) {
            const sectionElement = document.getElementById(lastActiveSection);
            const isKnownMenuSection = Array.from(mainMenuButtons).some(btn => btn.getAttribute('data-section') === lastActiveSection);
            if (sectionElement && isKnownMenuSection) {
                showSection(lastActiveSection);
                sectionActuallyShown = true;
            } else {
                localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
            }
        }

        if (!sectionActuallyShown && mainMenuButtons.length > 0 && mainMenuButtons[0].dataset.section) {
            showSection(mainMenuButtons[0].dataset.section);
        }

    } else {
        if (adminLoginSection) adminLoginSection.style.display = 'block';
        if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'none';
        if (topMenuBar) topMenuBar.style.display = 'none';
        if (logoutContainer) logoutContainer.style.display = 'none';
        if (loginFormContainer) loginFormContainer.style.display = 'block';
        if (authStatus) authStatus.textContent = 'Please log in to use the tools.';
        if (loggedInUserEmailDisplay) loggedInUserEmailDisplay.textContent = '';
        localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        stopAutoApplyScheduler();
    }
}

// --- Analytics Functions ---
function detectDuplicateEntries() {
    if (!currentUser || currentWorkingSchedule.length === 0) {
        if (duplicateEntriesResults) duplicateEntriesResults.innerHTML = '<p>No schedule data loaded or not logged in.</p>';
        return;
    }
    const signatures = new Map();
    const duplicates = [];
    currentWorkingSchedule.forEach((entry, index) => {
        const profileString = (entry.OperatingProfile || "").toLowerCase().split(',').map(s => s.trim()).sort().join(',');
        const signature = [
            (entry.stopID || "").toUpperCase(),
            (entry.lineName || "").toUpperCase(),
            entry.scheduledTime || "00:00",
            profileString,
            entry.DayOffset || "0",
            (entry.destinationName || "").trim()
        ].join('|');

        if (signatures.has(signature)) {
            signatures.get(signature).push(index);
        } else {
            signatures.set(signature, [index]);
        }
    });

    signatures.forEach((indices, sig) => {
        if (indices.length > 1) {
            duplicates.push(indices.map(originalIndex => ({...currentWorkingSchedule[originalIndex], originalIndex})));
        }
    });

    if (duplicateEntriesResults) {
        if (duplicates.length === 0) {
            duplicateEntriesResults.innerHTML = '<p>No duplicate entries found in the current working schedule.</p>';
        } else {
            let html = `<p>Found ${duplicates.length} set(s) of duplicate entries:</p><ul>`;
            duplicates.forEach((set, i) => {
                html += `<li class="duplicate-set"><strong>Set ${i + 1}:</strong> (Appears ${set.length} times)`;
                set.forEach(entry => {
                    html += `<span class="entry-detail"> - Stop: ${entry.stopID}, Line: ${entry.lineName}, Time: ${entry.scheduledTime}, Profile: ${entry.OperatingProfile}, Dest: ${entry.destinationName} (Original Index: ${entry.originalIndex})</span>`;
                });
                html += `</li>`;
            });
            html += `</ul>`;
            duplicateEntriesResults.innerHTML = html;
        }
    }
}

function handleRemoveDuplicateEntries() {
    if (!currentUser) {
        alert("Please log in to modify the schedule.");
        if (removeDuplicatesStatusMessage) removeDuplicatesStatusMessage.textContent = "Not logged in.";
        return;
    }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        alert("Working schedule is empty. Nothing to deduplicate.");
        if (removeDuplicatesStatusMessage) removeDuplicatesStatusMessage.textContent = "Working schedule is empty.";
        return;
    }

    const initialCount = currentWorkingSchedule.length;
    const signaturesEncountered = new Set();
    const deduplicatedSchedule = [];

    currentWorkingSchedule.forEach(entry => {
        const profileString = (entry.OperatingProfile || "").toLowerCase().split(',').map(s => s.trim()).sort().join(',');
        const signature = [
            (entry.stopID || "").toUpperCase(),
            (entry.lineName || "").toUpperCase(),
            entry.scheduledTime || "00:00",
            profileString,
            entry.DayOffset || "0",
            (entry.destinationName || "").trim()
        ].join('|');

        if (!signaturesEncountered.has(signature)) {
            signaturesEncountered.add(signature);
            deduplicatedSchedule.push(entry);
        }
    });

    const removedCount = initialCount - deduplicatedSchedule.length;

    if (removedCount === 0) {
        alert("No duplicate entries found based on the criteria (StopID, Line, Time, Profile, DayOffset, Destination).");
        if (removeDuplicatesStatusMessage) {
            removeDuplicatesStatusMessage.textContent = "No duplicates found.";
            removeDuplicatesStatusMessage.style.color = "";
        }
        return;
    }

    if (confirm(`Found ${removedCount} duplicate schedule entries. Are you sure you want to remove them, keeping only the first occurrence of each?`)) {
        currentWorkingSchedule = deduplicatedSchedule;
        if (removeDuplicatesStatusMessage) {
            removeDuplicatesStatusMessage.textContent = `${removedCount} duplicate entries removed. Working schedule updated.`;
            removeDuplicatesStatusMessage.style.color = '#2ecc71';
        }
        alert(`${removedCount} duplicate entries removed.`);
        renderUIDependentElements();
        detectDuplicateEntries();
    } else {
        if (removeDuplicatesStatusMessage) {
            removeDuplicatesStatusMessage.textContent = "Operation cancelled by user.";
            removeDuplicatesStatusMessage.style.color = '#f1c40f';
        }
    }
}


// --- START: Consolidate Operating Days Functions ---
function populateConsolidateStopSelect() {
    if (!consolidateStopSelect) return;
    const currentVal = consolidateStopSelect.value;
    consolidateStopSelect.innerHTML = '<option value="">-- Select Stop --</option>';
    const uniqueStops = getUniqueStopsFromSchedule();

    if (uniqueStops.length === 0) {
        consolidateStopSelect.innerHTML = '<option value="">-- No Stops --</option>';
        populateConsolidateRouteSelect();
        return;
    }
    uniqueStops.forEach(stop => {
        const opt = document.createElement('option');
        opt.value = stop.stopID;
        opt.textContent = `${stop.stopName} (${stop.stopID})`;
        consolidateStopSelect.appendChild(opt);
    });
    if (uniqueStops.find(s => s.stopID === currentVal)) {
        consolidateStopSelect.value = currentVal;
    }
    populateConsolidateRouteSelect();
}

function populateConsolidateRouteSelect() {
    if (!consolidateRouteSelect || !consolidateStopSelect) return;
    const selectedStopId = consolidateStopSelect.value;
    const currentRouteVal = consolidateRouteSelect.value;
    consolidateRouteSelect.innerHTML = '<option value="">-- Select Route --</option>';

    if (!selectedStopId) {
        consolidateRouteSelect.innerHTML = '<option value="">-- Select Stop First --</option>';
        return;
    }
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        return;
    }

    const routesForStop = [...new Set(
        currentWorkingSchedule
            .filter(entry => entry.stopID === selectedStopId && entry.lineName)
            .map(entry => entry.lineName)
    )].sort(compareLineNames);

    if (routesForStop.length === 0) {
        consolidateRouteSelect.innerHTML = `<option value="">-- No Routes for Stop ${selectedStopId} --</option>`;
    } else {
        routesForStop.forEach(lineName => {
            const opt = document.createElement('option');
            opt.value = lineName;
            opt.textContent = lineName;
            consolidateRouteSelect.appendChild(opt);
        });
        if (routesForStop.includes(currentRouteVal)) {
            consolidateRouteSelect.value = currentRouteVal;
        }
    }
}

function handleConsolidateOperatingDays() {
    if (!currentUser) {
        alert("Please log in.");
        consolidateOpDaysStatusMessage.textContent = "Not logged in."; return;
    }

    const stopId = consolidateStopSelect.value;
    const lineName = consolidateRouteSelect.value;
    const newProfile = consolidateNewProfileInput.value.trim();

    if (!stopId) {
        consolidateOpDaysStatusMessage.textContent = "Please select a Stop ID.";
        consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return;
    }
    if (!lineName) {
        consolidateOpDaysStatusMessage.textContent = "Please select a Route.";
        consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return;
    }
    if (!newProfile) {
        consolidateOpDaysStatusMessage.textContent = "Please enter the new combined Operating Profile.";
        consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return;
    }

    const relevantEntriesForStopRoute = currentWorkingSchedule.filter(
        entry => entry.stopID === stopId && entry.lineName === lineName
    );

    if (relevantEntriesForStopRoute.length === 0) {
        consolidateOpDaysStatusMessage.textContent = `No schedule entries found for Stop ID "${stopId}" and Line "${lineName}".`;
        consolidateOpDaysStatusMessage.style.color = '#f1c40f'; return;
    }

    const groups = new Map();
    relevantEntriesForStopRoute.forEach(entry => {
        const key = `${entry.scheduledTime}|${entry.destinationName || ""}|${entry.DayOffset || "0"}`;
        if (!groups.has(key)) {
            groups.set(key, []);
        }
        groups.get(key).push(entry);
    });

    let consolidatedGroupCount = 0;
    let entriesToRemoveInternalIds = new Set();
    let modifiedEntries = [];

    groups.forEach((group, key) => {
        if (group.length > 1) {
            consolidatedGroupCount++;
            const firstEntry = { ...group[0] };
            firstEntry.OperatingProfile = newProfile;
            modifiedEntries.push(firstEntry);

            for (let i = 1; i < group.length; i++) {
                if (group[i].internalId) {
                    entriesToRemoveInternalIds.add(group[i].internalId);
                } else {
                    console.warn("Entry missing internalId, cannot reliably mark for removal:", group[i]);
                }
            }
        }
    });

    const otherEntries = currentWorkingSchedule.filter(
        entry => entry.stopID !== stopId || entry.lineName !== lineName
    );

    groups.forEach((group, key) => {
        if (group.length === 1) {
            modifiedEntries.push(group[0]);
        }
    });


    if (consolidatedGroupCount === 0) {
        consolidateOpDaysStatusMessage.textContent = "No entries found that could be consolidated for the selected stop/route (i.e., no multiple entries with the same time, destination, and day offset).";
        consolidateOpDaysStatusMessage.style.color = '#f1c40f';
        return;
    }

    const actualRemovedCount = entriesToRemoveInternalIds.size;
    if (!confirm(`Found ${consolidatedGroupCount} group(s) of entries for Stop ${stopId}, Route ${lineName} to consolidate. This will update one entry per group to profile "${newProfile}" and remove ${actualRemovedCount} other entries. Proceed?`)) {
        consolidateOpDaysStatusMessage.textContent = "Consolidation cancelled by user.";
        consolidateOpDaysStatusMessage.style.color = '#f1c40f';
        return;
    }

    currentWorkingSchedule = [
        ...otherEntries,
        ...modifiedEntries.filter(mEntry => !entriesToRemoveInternalIds.has(mEntry.internalId))
    ];


    consolidateOpDaysStatusMessage.textContent = `Consolidated ${consolidatedGroupCount} group(s) for Stop ${stopId}, Route ${lineName}. ${actualRemovedCount} entries removed. Profile updated to "${newProfile}".`;
    consolidateOpDaysStatusMessage.style.color = '#2ecc71';
    alert(`Operating days consolidated. ${actualRemovedCount} entries removed.`);

    renderUIDependentElements();
    detectDuplicateEntries();
}

// --- END: Consolidate Operating Days Functions ---


// --- Utility Functions (Date, Sorting, Parsing etc.) ---
function parseLineName(lineNameStr) { const name = String(lineNameStr || "").toUpperCase().trim(); const numericPrefixRegex = new RegExp(/^(\d+)([A-Z]*)$/); const alphaNumericRegex = new RegExp(/^([A-Z]+)(\d+)?([A-Z]*)$/); const numericPrefixMatch = name.match(numericPrefixRegex); if (numericPrefixMatch) return { type: 'numeric', number: parseInt(numericPrefixMatch[1], 10), suffix: numericPrefixMatch[2] || '', original: name }; const alphaNumericMatch = name.match(alphaNumericRegex); if (alphaNumericMatch) return { type: 'alpha', prefix: alphaNumericMatch[1], number: alphaNumericMatch[2] ? parseInt(alphaNumericMatch[2], 10) : null, suffix: alphaNumericMatch[3] || '', original: name }; return { type: 'other', original: name }; }
function compareLineNames(lineAStr, lineBStr) { const parsedA = parseLineName(lineAStr); const parsedB = parseLineName(lineBStr); if (parsedA.type === 'numeric' && parsedB.type === 'alpha') return -1; if (parsedA.type === 'alpha' && parsedB.type === 'numeric') return 1; if (parsedA.type === 'numeric' && parsedB.type === 'numeric') { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type === 'alpha' && parsedB.type === 'alpha') { const prefixCompare = parsedA.prefix.localeCompare(parsedB.prefix); if (prefixCompare !== 0) return prefixCompare; if (parsedA.number === null && parsedB.number !== null) return -1; if (parsedA.number !== null && parsedB.number === null) return 1; if (parsedA.number !== null && parsedB.number !== null) { if (parsedA.number < parsedB.number) return -1; if (parsedA.number > parsedB.number) return 1; } return parsedA.suffix.localeCompare(parsedB.suffix); } if (parsedA.type !== 'other' && parsedB.type === 'other') return -1; if (parsedA.type === 'other' && parsedB.type !== 'other') return 1; return (parsedA.original || "").localeCompare(parsedB.original || ""); }

function generateUniqueStopId(format) {
    const existingStopIDs = new Set(currentWorkingSchedule.map(entry => entry.stopID.toUpperCase()));
    let nextId = "";
    let currentNum = 0;
    let attempts = 0;
    const maxAttempts = 10000;

    if (format === "NUM") {
        let maxNumeric = 100;
        existingStopIDs.forEach(id => {
            if (/^\d+$/.test(id)) {
                const num = parseInt(id, 10);
                if (num >= 101 && num > maxNumeric) {
                    maxNumeric = num;
                }
            }
        });
        currentNum = maxNumeric + 1;
        while (attempts < maxAttempts) {
            nextId = String(currentNum);
            if (!existingStopIDs.has(nextId)) {
                return nextId;
            }
            currentNum++;
            attempts++;
            if (currentNum > 99999) break;
        }
    } else if (["BP", "LE", "RO"].includes(format)) {
        const prefix = format;
        let maxPrefixNum = 0;
        existingStopIDs.forEach(id => {
            if (id.startsWith(prefix)) {
                const numPart = id.substring(prefix.length);
                if (/^\d+$/.test(numPart)) {
                    const num = parseInt(numPart, 10);
                    if (num > maxPrefixNum) {
                        maxPrefixNum = num;
                    }
                }
            }
        });
        currentNum = maxPrefixNum + 1;
        while (attempts < maxAttempts) {
            nextId = prefix + currentNum;
            if (!existingStopIDs.has(nextId.toUpperCase())) {
                return nextId;
            }
            currentNum++;
            attempts++;
             if (currentNum > 99999) break;
        }
    }
    console.warn("Could not generate a unique Stop ID for format:", format, "- Max limit may be reached or format not handled. Using fallback.");
    return format + String(Date.now()).slice(-5) + String(Math.floor(Math.random()*90)+10);
}


function getOperatingCodesForToday_Tools() {
    const n = new Date();
    const dOW = n.getDay();
    const todayDateString = `${n.getFullYear()}-${String(n.getMonth() + 1).padStart(2, '0')}-${String(n.getDate()).padStart(2, '0')}`;
    let dateCodes = new Set();
    let isBankHolidayToday = false;

    if (ukBankHolidaysData && ukBankHolidaysData.dates && ukBankHolidaysData.dates.includes(todayDateString)) {
        const holidayTitle = ukBankHolidaysData.titles[todayDateString] || "";
        isBankHolidayToday = true;
        if (holidayTitle.toLowerCase().includes("good friday")) {
            dateCodes.add("Sa");
        } else {
            dateCodes.add("Su");
        }
    }

    if (!isBankHolidayToday) {
        const isSchHol = isSchoolHolidayPeriodForSetup(n);
        const schoolSuffix = isSchHol ? "NSD" : "Sch";

        let dayCode = "";
        switch (dOW) {
            case 0: dayCode = "Su"; break;
            case 1: dayCode = "Mo"; break;
            case 2: dayCode = "Tu"; break;
            case 3: dayCode = "We"; break;
            case 4: dayCode = "Th"; break;
            case 5: dayCode = "Fr"; break;
            case 6: dayCode = "Sa"; break;
        }
        dateCodes.add(dayCode);

        if (dOW >= 1 && dOW <= 5) {
            dateCodes.add(dayCode + schoolSuffix);
            dateCodes.add("MF" + schoolSuffix);
            dateCodes.add("Mo-Fr");
            dateCodes.add("MF");
        }
        if ((dOW === 6 || dOW === 0) && isSchHol) {
             dateCodes.add(dayCode + "NSD");
        }

        if (isSchHol) {
            dateCodes.add("SchoolHoliday");
        }
    } else {
        const isSchHolOnBH = isSchoolHolidayPeriodForSetup(n);
        if (isSchHolOnBH) {
            dateCodes.add("SchoolHoliday");
            if (dateCodes.has("Sa")) dateCodes.add("SaNSD");
            if (dateCodes.has("Su") && !dateCodes.has("Sa")) dateCodes.add("SuNSD");
        }
    }
    return Array.from(dateCodes);
}

async function fetchBankHolidaysForSetup() { try { const response = await fetch('https://www.gov.uk/bank-holidays.json'); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); if (data['england-and-wales'] && data['england-and-wales'].events) { const events = data['england-and-wales'].events; ukBankHolidaysData = { dates: events.map(event => event.date), titles: events.reduce((acc, event) => { acc[event.date] = event.title; return acc; }, {}) }; } else { console.warn("Setup: Bank holiday data not in expected format."); ukBankHolidaysData = { dates: [], titles: {} }; } } catch (error) { console.error("Setup: Failed to fetch UK bank holidays:", error); ukBankHolidaysData = { dates: [], titles: {} }; if(currentProfileDisplayElement) currentProfileDisplayElement.textContent = "Today's Auto Profile: (Bank Hol. check failed)"; } updateCurrentProfileDisplayOnSetup(); }
function isSchoolHolidayPeriodForSetup(dateObject) { if (!schoolHolidayDateRanges || schoolHolidayDateRanges.length === 0) return false; const checkTime = dateObject.getTime(); for (const range of schoolHolidayDateRanges) { try { const startTime = new Date(range.start + "T00:00:00").getTime(); const endTime = new Date(range.end + "T23:59:59").getTime(); if (checkTime >= startTime && checkTime <= endTime) return true; } catch (e) { console.error("Invalid date in schoolHolidayDateRanges (setup):", range, e); } } return false; }

function updateCurrentProfileDisplayOnSetup() {
    const now = new Date();
    const dayOfWeek = now.getDay();
    const todayDateString = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
    let profileDisplayText = "";
    let isBankHol = false;
    let serviceTypeDisplay = "";

    if (ukBankHolidaysData.dates && ukBankHolidaysData.dates.includes(todayDateString)) {
        const holidayTitle = ukBankHolidaysData.titles[todayDateString] || "Bank Holiday";
        isBankHol = true;
        if (holidayTitle.toLowerCase().includes("good friday")) {
            profileDisplayText = "Good Friday"; serviceTypeDisplay = "(Sat Service)";
        } else {
            profileDisplayText = holidayTitle; serviceTypeDisplay = "(Sun Service)";
        }
    }

    let dayName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][dayOfWeek];
    if (!isBankHol) {
        profileDisplayText = dayName;
        const isSchHol = isSchoolHolidayPeriodForSetup(now);
        if (isSchHol) profileDisplayText += " (School Hol)";
    } else {
        profileDisplayText += ` ${serviceTypeDisplay} - Observed on a ${dayName}`;
        const isSchHolOnBH = isSchoolHolidayPeriodForSetup(now);
        if (isSchHolOnBH) profileDisplayText += " (School Hol Period)";
    }

    const operatingCodes = getOperatingCodesForToday_Tools();
    if (currentProfileDisplayElement) {
        currentProfileDisplayElement.textContent = `Today's Auto Profile: ${profileDisplayText} [Codes: ${operatingCodes.join(', ')}]`;
    }
}

// --- Form & Data Handling Functions ---
function isValidScheduleDataFromText(jsonData) { if (!jsonData || jsonData.length === 0) return false; const requiredColumns = ['StopID', 'StopName', 'Direction', 'LineName', 'DestinationName', 'ScheduledTime', 'OperatingProfile']; const firstEntry = jsonData[0]; const allColumnsPresent = requiredColumns.every(col => col in firstEntry); if (!allColumnsPresent) { const missingCols = requiredColumns.filter(col => !(col in firstEntry)); alert(`Uploaded .COUNT file is missing expected headers: ${missingCols.join(', ')}.\nExpected: StopID, StopName, Direction, LineName, DestinationName, ScheduledTime, OperatingProfile. Case matters.`); return false; } return true; }
function handleCountFileUpload(event) { const file = event.target.files[0]; if (file) { if (fileStatusElement) fileStatusElement.textContent = `Processing ${file.name}...`; setTimeout(() => { const reader = new FileReader(); reader.onload = function(e) { try { const fileContent = e.target.result; const lines = fileContent.split(/\r?\n/); if (lines.length < 2) { alert("File empty or no data (header + one entry needed)."); if (fileStatusElement) fileStatusElement.textContent = "File processing failed."; if (countFileInput) countFileInput.value = ""; return; } const headers = lines[0].split('\t').map(h => h.trim()); const jsonData = []; for (let i = 1; i < lines.length; i++) { const line = lines[i].trim(); if (line === "") continue; const values = line.split('\t').map(v => v.trim()); if (values.length < headers.length && values.every(v => v === "")) continue; if (values.length < headers.length && values.length > 0) { for(let k = values.length; k < headers.length; k++) { values.push(''); } } let entry = {}; headers.forEach((header, index) => { entry[header] = values[index] !== undefined ? values[index] : ""; }); jsonData.push(entry); } if (isValidScheduleDataFromText(jsonData)) { if (currentWorkingSchedule.length > 0 && !confirm("Replace current working schedule with this file?")) { if (fileStatusElement) fileStatusElement.textContent = "Upload cancelled."; if (countFileInput) countFileInput.value = ""; return; } currentWorkingSchedule = jsonData.map((row, index) => { let scheduledTime = String(row.ScheduledTime || "").trim(); if (scheduledTime.match(/^\d{1,2}:\d{2}(:\d{2})?$/)) { const parts = scheduledTime.split(':'); scheduledTime = `${String(parts[0]).padStart(2, '0')}:${String(parts[1]).padStart(2, '0')}`; } else if (scheduledTime.length === 4 && !scheduledTime.includes(':')) { scheduledTime = `${scheduledTime.substring(0,2)}:${scheduledTime.substring(2,4)}`; } else if (scheduledTime.length === 3 && !scheduledTime.includes(':')) { scheduledTime = `0${scheduledTime.substring(0,1)}:${scheduledTime.substring(1,3)}`; } return { internalId: `${String(row.StopID||'s').trim().toUpperCase()}_${String(row.LineName||'l').trim().toUpperCase()}_${scheduledTime.replace(':','')}_${index}_countfile`, stopID: String(row.StopID || "").trim().toUpperCase(), stopName: String(row.StopName || "").trim(), direction: String(row.Direction || "").trim(), lineName: String(row.LineName || "").trim().toUpperCase(), destinationName: String(row.DestinationName || "").trim(), scheduledTime: scheduledTime, OperatingProfile: String(row.OperatingProfile || "").trim(), DayOffset: String(row.DayOffset || "0").trim() }; }); renderUIDependentElements(); if (fileStatusElement) fileStatusElement.textContent = `${file.name} processed. ${currentWorkingSchedule.length} entries loaded.`; } else { if (fileStatusElement) fileStatusElement.textContent = "File processing failed: Invalid structure/headers."; } } catch (error) { console.error("Error processing .COUNT file:", error); alert(`Error: ${error.message}.`); if (fileStatusElement) fileStatusElement.textContent = "Error loading file."; } if (countFileInput) countFileInput.value = ""; }; reader.onerror = () => { alert("Could not read file."); if (fileStatusElement) fileStatusElement.textContent = "Error reading file."; if (countFileInput) countFileInput.value = ""; }; reader.readAsText(file); }, 50); } }

// Function for "Update Destination for a Route" (kept from original script)
function handleBulkUpdateRouteDestination() {
    if (!currentUser) { alert("Please log in."); return; }
    const targetLineName = bulkEditTargetLineNameInput.value.trim().toUpperCase();
    const oldDestination = bulkEditOldDestinationInput.value.trim(); // Can be blank
    const newDestination = bulkEditNewDestinationInput.value.trim();

    if (!targetLineName) { alert("Target Line Name required."); bulkEditTargetLineNameInput.focus(); return; }
    if (!newDestination) { alert("New Destination Name required."); bulkEditNewDestinationInput.focus(); return; }

    let updatedCount = 0;
    currentWorkingSchedule.forEach(entry => {
        if (entry.lineName && entry.lineName.toUpperCase() === targetLineName) {
            if (oldDestination) { // If old destination is specified, only update matching ones
                if (entry.destinationName && entry.destinationName.toLowerCase() === oldDestination.toLowerCase()) {
                    entry.destinationName = newDestination;
                    updatedCount++;
                }
            } else { // If old destination is blank, update all destinations for that line
                entry.destinationName = newDestination;
                updatedCount++;
            }
        }
    });

    if (updatedCount > 0) {
        renderUIDependentElements(); // Re-render any UI that might depend on this
        alert(`${updatedCount} entries for Line "${targetLineName}" updated to new destination "${newDestination}".`);
    } else {
        alert(`No entries for Line "${targetLineName}"` + (oldDestination ? ` with Old Destination "${oldDestination}"` : "") + " found to update.");
    }
}


// --- Firebase Data Interaction ---
function handleStageSchedule() { if (!currentUser) { alert("Log in to stage."); return; } if (currentWorkingSchedule.length === 0 && !confirm("Working schedule empty. Stage empty schedule?")) { stagingStatusMessage.textContent = "Staging empty schedule cancelled."; stagingStatusMessage.style.color = "#e74c3c"; return; } let dataToStage = JSON.parse(JSON.stringify(currentWorkingSchedule)); dataToStage.sort((a, b) => { const lineCmp = compareLineNames(a.lineName, b.lineName); if (lineCmp !== 0) return lineCmp; const timeA = (a.scheduledTime || "").replace(':', ''); const timeB = (b.scheduledTime || "").replace(':', ''); const timeCmp = timeA.localeCompare(timeB); if (timeCmp !== 0) return timeCmp; return (a.stopID || "").localeCompare(b.stopID || ""); }); const finalScheduleData = dataToStage.map((entry, index) => ({ ...entry, internalId: entry.internalId || `${entry.stopID.toUpperCase()}_${entry.lineName.toUpperCase()}_${(entry.scheduledTime||"").replace(':','')}_${index}_staged` })); const stopsMap = new Map(); finalScheduleData.forEach(row => { if (row.stopID && !stopsMap.has(row.stopID)) { stopsMap.set(row.stopID, { stopID: row.stopID, stopName: row.stopName, direction: row.direction }); } }); const finalUniqueStops = Array.from(stopsMap.values()).sort((a,b)=>{ const nC=(a.stopName||"").localeCompare(b.stopName||""); return nC!==0?nC:(a.direction||"").localeCompare(b.direction||""); }); if (window.firebaseOMSI) { const { database, dbUpdate, dbRef } = window.firebaseOMSI; const updates = {}; updates[FB_PATH_PENDING_SCHEDULE_DATA] = finalScheduleData; updates[FB_PATH_PENDING_UNIQUE_STOPS] = finalUniqueStops; updates[FB_PATH_PENDING_TIMESTAMP] = new Date().toISOString(); updates[FB_PATH_APPSTATE_STATUS] = 'update_staged'; dbUpdate(dbRef(database), updates) .then(() => { alert("Schedule STAGED to Firebase."); updateStagingStatusDisplay(); }) .catch((e) => { console.error("FB Staging Error: ", e); alert("FB Staging Error. Check console."); if(stagingStatusMessage) { stagingStatusMessage.textContent = "FB Staging Error."; stagingStatusMessage.style.color = "#e74c3c"; } }); } else { alert("Firebase not available."); } }
function handleApplyNow() { if (!currentUser) { alert("Log in to apply."); return; } if (window.firebaseOMSI) { const { database, dbGet, dbUpdate, dbRef, dbChild } = window.firebaseOMSI; dbGet(dbChild(dbRef(database), '/pendingSchedule')) .then((snapshot) => { if (snapshot.exists()) { const pendingData = snapshot.val(); if (!confirm("Apply Firebase staged schedule LIVE NOW?")) { if (stagingStatusMessage) { stagingStatusMessage.textContent = "Apply cancelled."; stagingStatusMessage.style.color = "#e74c3c"; } return; } let liveAllScheduledBusData = Array.isArray(pendingData.allScheduledBusData) ? pendingData.allScheduledBusData.filter(item => item != null) : (typeof pendingData.allScheduledBusData === 'object' && pendingData.allScheduledBusData !== null ? Object.values(pendingData.allScheduledBusData).filter(item => item != null) : []); let liveUniqueBusStops = Array.isArray(pendingData.uniqueBusStops) ? pendingData.uniqueBusStops.filter(item => item != null) : (typeof pendingData.uniqueBusStops === 'object' && pendingData.uniqueBusStops !== null ? Object.values(pendingData.uniqueBusStops).filter(item => item != null) : []); let hasInvalidKey = false; function check(obj, path) { if (typeof obj !== 'object' || obj === null) return; for (const key in obj) { if (/[.#$/\[\]]/.test(key)) { console.error(`INVALID KEY at ${path}: key='${key}'`); hasInvalidKey = true; } if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) { check(obj[key], `${path}.${key}`); } } } liveAllScheduledBusData.forEach((item, i) => { if (typeof item !== 'object' || item === null) { hasInvalidKey = true; return; } check(item, `schedule[${i}]`); }); liveUniqueBusStops.forEach((item, i) => { if (typeof item !== 'object' || item === null) { hasInvalidKey = true; return; } check(item, `stops[${i}]`); }); if (hasInvalidKey) { alert("Invalid keys in data. Cannot apply. Check console."); return; } const liveUpdates = {}; liveUpdates[FB_PATH_LIVE_SCHEDULE_DATA] = liveAllScheduledBusData; liveUpdates[FB_PATH_LIVE_UNIQUE_STOPS] = liveUniqueBusStops; dbUpdate(dbRef(database), liveUpdates) .then(() => { const appUpdates = {}; appUpdates[FB_PATH_APPSTATE_LAST_UPDATED] = new Date().toISOString(); appUpdates[FB_PATH_APPSTATE_STATUS] = 'idle'; appUpdates['/pendingSchedule'] = null; return dbUpdate(dbRef(database), appUpdates); }) .then(() => { alert("Staged schedule APPLIED LIVE!"); updateStagingStatusDisplay(); }) .catch(e => { console.error("FB Apply Error: ", e); alert("FB Apply Error. Check console: " + e.message); }); } else { alert("No Firebase staged schedule to apply."); if (stagingStatusMessage) { stagingStatusMessage.textContent = "No FB staged schedule."; stagingStatusMessage.style.color = "#e74c3c"; } } }).catch(e => { console.error("FB Fetch Pending Error: ", e); alert("FB Fetch Pending Error. Check console: " + e.message); }); } else { alert("Firebase not available."); } }
async function loadInitialData() {
    console.log("Tools: Loading initial data from Firebase...");
    let msg = "Loading data...";
    if (fileStatusElement) fileStatusElement.textContent = msg;
    currentWorkingSchedule = [];
    closedStopIDs = [];
    globalCustomRouteColours = {};
    stopSpecificRouteColours = {};

    if (!window.firebaseOMSI) {
        msg = "Firebase not connected.";
    } else {
        const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
        try {
            const liveSnap = await dbGet(dbChild(dbRef(database), FB_PATH_LIVE_SCHEDULE_DATA));
            if (liveSnap.exists() && Array.isArray(liveSnap.val())) {
                currentWorkingSchedule = liveSnap.val().map((e, i) => ({ ...e, internalId: e.internalId || `${(e.stopID||'s')}_${(e.lineName||'l')}_${(e.scheduledTime||"").replace(':','')}_${i}_fb` }));
            }
            const closedSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_CLOSED_STOPS));
            if (closedSnap.exists()) {
                const fbClosed = closedSnap.val();
                for (const id in fbClosed) { if (fbClosed[id] === true) closedStopIDs.push(id); }
            }
            const globalColoursSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS));
            if (globalColoursSnap.exists()) globalCustomRouteColours = globalColoursSnap.val();

            const stopSpecificColoursSnap = await dbGet(dbChild(dbRef(database), FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS));
            if (stopSpecificColoursSnap.exists()) stopSpecificRouteColours = stopSpecificColoursSnap.val();

            msg = `Data loaded from Firebase. ${currentWorkingSchedule.length} entries.`;
        } catch (e) {
            console.error("FB Load Error:", e);
            msg = "FB Load Error. Check console.";
        }
    }
    if (fileStatusElement) fileStatusElement.textContent = msg;
    compileEffectiveRouteColoursForTools();
    renderUIDependentElements();
    updateStagingStatusDisplay();
    fetchBankHolidaysForSetup();
}
async function updateStagingStatusDisplay() { let pTime = null; let lTime = null; let fbStatus = "Checking..."; if (window.firebaseOMSI) { const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI; try { const pSnap = await dbGet(dbChild(dbRef(database), FB_PATH_PENDING_TIMESTAMP)); if (pSnap.exists()) pTime = pSnap.val(); const lSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_LAST_UPDATED)); if (lSnap.exists()) lTime = lSnap.val(); const sSnap = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_STATUS)); const currentFbSt = sSnap.exists() ? sSnap.val() : 'unknown'; fbStatus = `Firebase status: ${currentFbSt}.`; applyNowButton.disabled = !(currentFbSt === 'update_staged' && pTime); } catch (e) { fbStatus = "FB Status Error."; console.error(fbStatus, e); applyNowButton.disabled = true;} } else { fbStatus = "Firebase not available."; applyNowButton.disabled = true;} let msg = ""; if (pTime && applyNowButton.disabled === false) { msg = `STAGED on: ${new Date(pTime).toLocaleString()}.<br>Ready to 'Apply Staged Live NOW'.`; if(stagingStatusMessage) stagingStatusMessage.style.color = "#2ecc71"; } else { msg = "No schedule staged. Changes can be staged."; if(stagingStatusMessage) stagingStatusMessage.style.color = "#f1c40f"; } msg += lTime ? `<br>LIVE schedule last updated: ${new Date(lTime).toLocaleString()}` : "<br>No LIVE schedule set yet."; msg += `<br><small>(${fbStatus})</small>`; if(stagingStatusMessage) stagingStatusMessage.innerHTML = msg; }
function saveClosedStopsToFirebase() { // Renamed to be more specific
    if (!currentUser) return;
    if (window.firebaseOMSI) {
        const { database, dbSet, dbRef, dbUpdate } = window.firebaseOMSI; // Added dbUpdate
        const fbClosedObject = {};
        closedStopIDs.forEach(id => fbClosedObject[id] = true);

        const updates = {};
        updates[FB_PATH_APPSTATE_CLOSED_STOPS] = fbClosedObject;
        updates[FB_PATH_APPSTATE_LAST_UPDATED] = new Date().toISOString(); // Update timestamp

        dbUpdate(dbRef(database), updates) // Use dbUpdate for multiple paths
            .then(() => {
                console.log("Closed stops and timestamp saved to Firebase.");
                // Optionally update UI or provide feedback
                if (masterStopListStatus_SM && document.getElementById('stop-management-tool-section')?.style.display === 'block') {
                    masterStopListStatus_SM.textContent = "Stop status updated.";
                     setTimeout(() => { if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = `Showing ${masterStopListUL_SM.children.length} of ${uniqueStopsMasterList_SM.length} unique stops.`;}, 2000);
                }
                populateMasterStopList_SM(); // Refresh the list to show new status
            })
            .catch(e => console.error("FB Save Closed Stops Error: ", e));
    }
}

function saveGlobalCustomRouteColours() {
    if (!currentUser) return;
    if (window.firebaseOMSI) {
        const { database, dbSet, dbRef } = window.firebaseOMSI;
        dbSet(dbRef(database, FB_PATH_SETTINGS_GLOBAL_CUSTOM_COLOURS), globalCustomRouteColours)
            .then(() => dbSet(dbRef(database, FB_PATH_APPSTATE_LAST_UPDATED), new Date().toISOString()))
            .catch(e => console.error("FB Save Global Colours Error: ", e));
    }
    if (routeColourStatusMessage) {
        routeColourStatusMessage.textContent = 'Global custom colours saved.';
        setTimeout(() => { if(routeColourStatusMessage) routeColourStatusMessage.textContent = ''; }, 3000);
    }
    compileEffectiveRouteColoursForTools();
    if(selectStopForDeparturesView && selectStopForDeparturesView.value) displayDeparturesForSelectedStop();
    renderGlobalCustomRouteColours();
    if (selectStopForSpecificRouteColour && selectStopForSpecificRouteColour.value) {
        displayRoutesForSpecificColouring();
    }
     if (document.getElementById('stop-management-tool-section')?.style.display === 'block') {
        populateMasterStopList_SM();
    }
}

function saveStopSpecificRouteColoursToFirebase() {
    if (!currentUser) {
        if(stopSpecificRouteColourStatusMessage) {
            stopSpecificRouteColourStatusMessage.textContent = "Not logged in. Cannot save.";
            stopSpecificRouteColourStatusMessage.style.color = '#e74c3c';
        }
        return;
    }
    if (window.firebaseOMSI) {
        const { database, dbSet, dbRef } = window.firebaseOMSI;
        dbSet(dbRef(database, FB_PATH_SETTINGS_STOP_SPECIFIC_COLOURS), stopSpecificRouteColours)
            .then(() => {
                dbSet(dbRef(database, FB_PATH_APPSTATE_LAST_UPDATED), new Date().toISOString());
                if (stopSpecificRouteColourStatusMessage) {
                    stopSpecificRouteColourStatusMessage.textContent = 'Stop-specific colours saved to Firebase.';
                    stopSpecificRouteColourStatusMessage.style.color = '#2ecc71';
                    setTimeout(() => { if(stopSpecificRouteColourStatusMessage) stopSpecificRouteColourStatusMessage.textContent = ''; }, 3000);
                }
                compileEffectiveRouteColoursForTools();
                renderStopSpecificRouteColours();
                if (selectStopForSpecificRouteColour && selectStopForSpecificRouteColour.value) {
                    displayRoutesForSpecificColouring();
                }
                if (document.getElementById('stop-management-tool-section')?.style.display === 'block') {
                    populateMasterStopList_SM();
                }
            })
            .catch(e => {
                console.error("FB Save Stop-Specific Colours Error: ", e);
                if (stopSpecificRouteColourStatusMessage) {
                    stopSpecificRouteColourStatusMessage.textContent = 'Error saving stop-specific colours. Check console.';
                    stopSpecificRouteColourStatusMessage.style.color = '#e74c3c';
                }
            });
    } else {
         if (stopSpecificRouteColourStatusMessage) {
            stopSpecificRouteColourStatusMessage.textContent = 'Firebase not available. Cannot save.';
            stopSpecificRouteColourStatusMessage.style.color = '#e74c3c';
        }
    }
}


// --- UI Population & Rendering ---
function setGlobalRouteColour(colour) {
    if (inputRouteColour) {
        inputRouteColour.value = colour;
    }
}

function setStopSpecificRouteColour(colour) {
    if (inputStopSpecificRouteColour) {
        inputStopSpecificRouteColour.value = colour;
    }
}

function renderUIDependentElements() {
    if(currentUser) {
        // Removed populateRouteSelectorForEvents, populateStopStatusSelector as their sections are gone
        populateRouteSelectorForColours();
        populateStopSelectorForSpecificColours();
        populateStopSelectorForDeparturesView();
        renderGlobalCustomRouteColours();
        renderStopSpecificRouteColours();
        populateStopToRemoveSelector_ARS();
        populateConsolidateStopSelect();
        populateCopierStopSelectors();
        populateGlobalRouteToDeleteSelector();

        const activeSection = localStorage.getItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
        if (activeSection) {
            const sectionElement = document.getElementById(activeSection);
            if (sectionElement && sectionElement.style.display === 'block') {
                if (activeSection === 'bulk-edit-tools-section') {
                    renderGlobalCustomRouteColours();
                    renderStopSpecificRouteColours();
                    if (selectStopForSpecificRouteColour.value) displayRoutesForSpecificColouring();
                } else if (activeSection === 'view-departures-section') {
                    if(selectStopForDeparturesView.value) displayDeparturesForSelectedStop();
                } else if (activeSection === 'stop-management-tool-section'){
                    populateMasterStopList_SM();
                } else if (activeSection === 'global-route-deletion-section') {
                    populateGlobalRouteToDeleteSelector();
                }
            }
        }
    }
}

// Removed populateRouteSelectorForEvents and populateImpactStopSelector as Event Generator is removed.
// Removed populateStopStatusSelector as Stop Status section is removed.
// The handleStopStatusChange function is now replaced by handleToggleStopStatus_SM.
// Removed applyRandomEvent as Event Generator is removed.


function compileEffectiveRouteColoursForTools() {
    // This can be simplified or removed if getRouteTileColourForTools always does dynamic lookup
    // For now, keeping it as it might be used elsewhere or for consistency.
    let effectiveMap = { ...initialRouteColourMapForTools }; // Start with base defaults
    for (const route in globalCustomRouteColours) { // Layer global customs
        effectiveMap[route.toUpperCase()] = globalCustomRouteColours[route];
    }
    // Stop-specific colours are applied dynamically in getRouteTileColourForTools,
    // so this effectiveMap mostly reflects global settings.
}
function renderGlobalCustomRouteColours() {
    if (!currentRouteColoursList || !noCustomColoursMessage) return;
    currentRouteColoursList.innerHTML = '';
    const routes = Object.keys(globalCustomRouteColours).sort(compareLineNames);

    if (routes.length === 0 && Object.keys(initialRouteColourMapForTools).every(key => !globalCustomRouteColours[key])) {
        noCustomColoursMessage.textContent = 'No global custom colours set. Using initial defaults.';
        noCustomColoursMessage.style.display = 'block';
    } else {
        noCustomColoursMessage.style.display = 'none';
    }

    const allDisplayableGlobalRoutes = [...new Set([...Object.keys(initialRouteColourMapForTools), ...Object.keys(globalCustomRouteColours)])].sort(compareLineNames);

    allDisplayableGlobalRoutes.forEach(rName => {
        const upName = rName.toUpperCase();
        const isCustom = globalCustomRouteColours.hasOwnProperty(upName);
        const color = globalCustomRouteColours[upName] || initialRouteColourMapForTools[upName] || DEFAULT_ROUTE_COLOUR_TOOLS;

        const li = document.createElement('li');
        li.style.display = 'flex';
        li.style.alignItems = 'center';

        const box = document.createElement('span');
        box.className = 'colour-preview-box';
        box.style.backgroundColor = color;

        const info = document.createElement('span');
        info.className = 'route-info';
        info.innerHTML = `Route: ${rName} - Colour: ${color.toUpperCase()}${isCustom ? "" : ` <small style="opacity:0.7;">(Initial Default)</small>`}`;

        const actions = document.createElement('div');
        actions.style.marginLeft = 'auto';
        if (isCustom) {
            const btn = document.createElement('button');
            btn.textContent = 'Remove Global';
            btn.classList.add('button','small-action','secondary');
            btn.onclick=()=>handleRemoveGlobalRouteColour(upName);
            actions.appendChild(btn);
        }
        li.appendChild(box);
        li.appendChild(info);
        li.appendChild(actions);
        currentRouteColoursList.appendChild(li);
    });
}
function populateRouteSelectorForColours() { if (!selectRouteNameColour) return; const currentVal = selectRouteNameColour.value; selectRouteNameColour.innerHTML = '<option value="">-- Select Route --</option>'; const lines = [...new Set(currentWorkingSchedule.map(e => e.lineName))].filter(Boolean).sort(compareLineNames); lines.forEach(ln => { const opt = document.createElement('option'); opt.value = ln; opt.textContent = ln; selectRouteNameColour.appendChild(opt); }); if (lines.includes(currentVal)) selectRouteNameColour.value = currentVal; selectRouteNameColour.dispatchEvent(new Event('change')); }
function handleSaveGlobalRouteColour() {
    if (!currentUser) return;
    if (!selectRouteNameColour || !inputRouteColour || !routeColourStatusMessage) return;
    const rName = selectRouteNameColour.value;
    const color = inputRouteColour.value;
    if (!rName) { routeColourStatusMessage.textContent = 'Select route name.'; routeColourStatusMessage.style.color = '#e74c3c'; return; }
    if (!color.match(/^#[0-9a-fA-F]{6}$/)) { routeColourStatusMessage.textContent = 'Invalid hex colour (e.g., #RRGGBB).'; routeColourStatusMessage.style.color = '#e74c3c'; return; }
    globalCustomRouteColours[rName.toUpperCase()] = color.toUpperCase();
    saveGlobalCustomRouteColours();
}
function handleRemoveGlobalRouteColour(key) {
    if (!currentUser) return;
    if (globalCustomRouteColours.hasOwnProperty(key) && confirm(`Remove GLOBAL custom colour for route ${key}? This will revert it to an initial default if one exists, or the system default.`)) {
        delete globalCustomRouteColours[key];
        saveGlobalCustomRouteColours();
        if (selectRouteNameColour.value.toUpperCase() === key) {
             inputRouteColour.value = initialRouteColourMapForTools[key] || DEFAULT_ROUTE_COLOUR_TOOLS;
        }
    }
}

// --- START: Stop-Specific Route Colour Functions ---
function populateStopSelectorForSpecificColours() {
    if (!selectStopForSpecificRouteColour) return;
    const currentVal = selectStopForSpecificRouteColour.value;
    selectStopForSpecificRouteColour.innerHTML = '<option value="">-- Select Stop --</option>';
    const uniqueStops = getUniqueStopsFromSchedule();

    if (uniqueStops.length === 0) {
        selectStopForSpecificRouteColour.innerHTML = '<option value="">-- No Stops in Schedule --</option>';
        displayRoutesForSpecificColouring();
        return;
    }
    uniqueStops.forEach(stop => {
        const opt = document.createElement('option');
        opt.value = stop.stopID;
        opt.textContent = `${stop.stopName} (${stop.stopID})`;
        selectStopForSpecificRouteColour.appendChild(opt);
    });

    if (uniqueStops.find(s => s.stopID === currentVal)) {
        selectStopForSpecificRouteColour.value = currentVal;
    }
    displayRoutesForSpecificColouring();
}

function displayRoutesForSpecificColouring() {
    if (!specificRouteColourTilesContainer || !specificRouteColourTilesPlaceholder) return;
    if (deleteRouteFromStopButton) deleteRouteFromStopButton.style.display = 'none';
    if (deleteRouteFromStopStatusMessage) deleteRouteFromStopStatusMessage.textContent = '';

    const selectedStopID = selectStopForSpecificRouteColour.value;
    specificRouteColourTilesContainer.innerHTML = '';

    if (!selectedStopID) {
        specificRouteColourTilesPlaceholder.textContent = 'Select a stop to see its routes.';
        specificRouteColourTilesPlaceholder.style.display = 'block';
        return;
    }

    const servingRoutes = new Set();
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID === selectedStopID && entry.lineName) {
            servingRoutes.add(entry.lineName);
        }
    });

    const sortedRoutes = Array.from(servingRoutes).sort(compareLineNames);

    if (sortedRoutes.length === 0) {
        specificRouteColourTilesPlaceholder.textContent = `No routes found serving stop ${selectedStopID}.`;
        specificRouteColourTilesPlaceholder.style.display = 'block';
    } else {
        specificRouteColourTilesPlaceholder.style.display = 'none';
        sortedRoutes.forEach(lineName => {
            const tile = document.createElement('span');
            tile.classList.add('route-tile-tools-list', 'specific-colour-route-tile');
            tile.textContent = lineName;
            tile.dataset.lineName = lineName;

            const bgColor = getRouteTileColourForTools(lineName, selectedStopID);
            tile.style.backgroundColor = bgColor;
            tile.style.color = getTextColourForBackgroundTools(bgColor);
            tile.setAttribute('role', 'checkbox');
            tile.setAttribute('aria-checked', 'false');
            tile.setAttribute('tabindex', '0');

            tile.addEventListener('click', () => {
                const isSelected = tile.classList.toggle('selected-for-color-edit');
                tile.setAttribute('aria-checked', isSelected.toString());

                const selectedTilesForColorEdit = specificRouteColourTilesContainer.querySelectorAll('.specific-colour-route-tile.selected-for-color-edit');
                if (deleteRouteFromStopButton) {
                    if (selectedTilesForColorEdit.length === 1) {
                        deleteRouteFromStopButton.style.display = 'inline-block';
                        deleteRouteFromStopButton.dataset.selectedRouteName = selectedTilesForColorEdit[0].dataset.lineName;
                    } else {
                        deleteRouteFromStopButton.style.display = 'none';
                        delete deleteRouteFromStopButton.dataset.selectedRouteName;
                    }
                }
                 if (deleteRouteFromStopStatusMessage) deleteRouteFromStopStatusMessage.textContent = '';
            });
            tile.addEventListener('keydown', (event) => {
                if (event.key === ' ' || event.key === 'Enter') {
                    event.preventDefault();
                    tile.click();
                }
            });
            specificRouteColourTilesContainer.appendChild(tile);
        });
    }
}


function handleDeleteRouteFromSpecificStop() {
    if (!currentUser) {
        alert("Please log in to modify the schedule.");
        if (deleteRouteFromStopStatusMessage) deleteRouteFromStopStatusMessage.textContent = "Not logged in.";
        return;
    }

    const selectedStopID = selectStopForSpecificRouteColour.value;
    const lineNameToDelete = deleteRouteFromStopButton.dataset.selectedRouteName;

    if (!selectedStopID || !lineNameToDelete) {
        if (deleteRouteFromStopStatusMessage) {
            deleteRouteFromStopStatusMessage.textContent = "No stop or route selected for deletion.";
            deleteRouteFromStopStatusMessage.style.color = '#f1c40f';
        }
        return;
    }

    if (!confirm(`Are you sure you want to delete all schedule entries for route "${lineNameToDelete}" from stop "${selectedStopID}"?\nThis will also remove any specific colour override for this route at this stop.\nThis action cannot be easily undone.`)) {
        if (deleteRouteFromStopStatusMessage) {
            deleteRouteFromStopStatusMessage.textContent = "Deletion cancelled.";
            deleteRouteFromStopStatusMessage.style.color = '#7f8c8d';
        }
        return;
    }

    let originalScheduleLength = currentWorkingSchedule.length;

    currentWorkingSchedule = currentWorkingSchedule.filter(entry => {
        return !(entry.stopID === selectedStopID && entry.lineName && entry.lineName.toUpperCase() === lineNameToDelete.toUpperCase());
    });

    let scheduleEntriesRemovedCount = originalScheduleLength - currentWorkingSchedule.length;
    let colourOverrideRemoved = false;
    if (stopSpecificRouteColours[selectedStopID] && stopSpecificRouteColours[selectedStopID][lineNameToDelete.toUpperCase()]) {
        delete stopSpecificRouteColours[selectedStopID][lineNameToDelete.toUpperCase()];
        colourOverrideRemoved = true;
        if (Object.keys(stopSpecificRouteColours[selectedStopID]).length === 0) {
            delete stopSpecificRouteColours[selectedStopID];
        }
        saveStopSpecificRouteColoursToFirebase();
    }

    if (deleteRouteFromStopStatusMessage) {
        deleteRouteFromStopStatusMessage.textContent = `Route "${lineNameToDelete}" deleted from stop "${selectedStopID}". ${scheduleEntriesRemovedCount} schedule entries removed. ${colourOverrideRemoved ? 'Specific colour override removed.' : ''}`;
        deleteRouteFromStopStatusMessage.style.color = '#2ecc71';
    }
    if(deleteRouteFromStopButton) {
        deleteRouteFromStopButton.style.display = 'none';
        delete deleteRouteFromStopButton.dataset.selectedRouteName;
    }


    displayRoutesForSpecificColouring();
    renderUIDependentElements();
    updateStagingStatusDisplay();
}


function handleSaveStopSpecificRouteColour() {
    if (!currentUser) {
        if(stopSpecificRouteColourStatusMessage) {
            stopSpecificRouteColourStatusMessage.textContent = "Not logged in.";
            stopSpecificRouteColourStatusMessage.style.color = '#e74c3c';
        }
        return;
    }
    const selectedStopID = selectStopForSpecificRouteColour.value;
    if (!selectedStopID) {
        if(stopSpecificRouteColourStatusMessage) {
            stopSpecificRouteColourStatusMessage.textContent = "Please select a stop first.";
            stopSpecificRouteColourStatusMessage.style.color = '#f1c40f';
        }
        return;
    }

    const selectedTiles = specificRouteColourTilesContainer.querySelectorAll('.specific-colour-route-tile.selected-for-color-edit');
    if (selectedTiles.length === 0) {
        if(stopSpecificRouteColourStatusMessage) {
            stopSpecificRouteColourStatusMessage.textContent = "Please select at least one route tile to apply the colour to.";
            stopSpecificRouteColourStatusMessage.style.color = '#f1c40f';
        }
        return;
    }

    const newColour = inputStopSpecificRouteColour.value;
    if (!newColour.match(/^#[0-9a-fA-F]{6}$/)) {
         if(stopSpecificRouteColourStatusMessage) {
            stopSpecificRouteColourStatusMessage.textContent = 'Invalid hex colour selected (e.g., #RRGGBB).';
            stopSpecificRouteColourStatusMessage.style.color = '#e74c3c';
        }
        return;
    }

    if (!stopSpecificRouteColours[selectedStopID]) {
        stopSpecificRouteColours[selectedStopID] = {};
    }

    let routesUpdated = [];
    selectedTiles.forEach(tile => {
        const lineName = tile.dataset.lineName;
        if (lineName) {
            stopSpecificRouteColours[selectedStopID][lineName.toUpperCase()] = newColour.toUpperCase();
            routesUpdated.push(lineName);
        }
    });

    if (routesUpdated.length > 0) {
        saveStopSpecificRouteColoursToFirebase();
        selectedTiles.forEach(tile => tile.classList.remove('selected-for-color-edit'));

        const stillSelectedTiles = specificRouteColourTilesContainer.querySelectorAll('.specific-colour-route-tile.selected-for-color-edit');
         if (deleteRouteFromStopButton) {
            if (stillSelectedTiles.length === 1) {
                 deleteRouteFromStopButton.style.display = 'inline-block';
                 deleteRouteFromStopButton.dataset.selectedRouteName = stillSelectedTiles[0].dataset.lineName;
            } else {
                deleteRouteFromStopButton.style.display = 'none';
                 delete deleteRouteFromStopButton.dataset.selectedRouteName;
            }
        }

    } else {
        if(stopSpecificRouteColourStatusMessage) {
            stopSpecificRouteColourStatusMessage.textContent = "No routes were actually updated.";
            stopSpecificRouteColourStatusMessage.style.color = '#e74c3c';
        }
    }
}

function renderStopSpecificRouteColours() {
    if (!currentStopSpecificColoursList || !noStopSpecificColoursMessageEl) return;
    currentStopSpecificColoursList.innerHTML = '';

    const stopIDsWithOverrides = Object.keys(stopSpecificRouteColours).filter(stopID =>
        stopSpecificRouteColours[stopID] && Object.keys(stopSpecificRouteColours[stopID]).length > 0
    ).sort();


    if (stopIDsWithOverrides.length === 0) {
        noStopSpecificColoursMessageEl.textContent = 'No stop-specific colour overrides are currently set.';
        noStopSpecificColoursMessageEl.style.display = 'block';
        return;
    }
    noStopSpecificColoursMessageEl.style.display = 'none';

    stopIDsWithOverrides.forEach(stopID => {
        const stopDetails = getUniqueStopsFromSchedule().find(s => s.stopID === stopID);
        const stopDisplayName = stopDetails ? `${stopDetails.stopName} (${stopID})` : stopID;

        const stopGroupTitle = document.createElement('h4');
        stopGroupTitle.className = 'stop-group-title';
        stopGroupTitle.textContent = `Stop: ${stopDisplayName}`;
        currentStopSpecificColoursList.appendChild(stopGroupTitle);

        const routesListUl = document.createElement('ul');
        const routesForThisStop = stopSpecificRouteColours[stopID];
        Object.keys(routesForThisStop).sort(compareLineNames).forEach(lineName => {
            const color = routesForThisStop[lineName];
            const li = document.createElement('li');
            li.style.display = 'flex';
            li.style.alignItems = 'center';

            const box = document.createElement('span');
            box.className = 'colour-preview-box';
            box.style.backgroundColor = color;

            const info = document.createElement('span');
            info.className = 'route-info';
            info.textContent = `Route: ${lineName} - Colour: ${color.toUpperCase()}`;

            const actions = document.createElement('div');
            actions.style.marginLeft = 'auto';
            const removeBtn = document.createElement('button');
            removeBtn.textContent = 'Remove Override';
            removeBtn.classList.add('button', 'small-action', 'secondary');
            removeBtn.onclick = () => handleRemoveStopSpecificRouteColour(stopID, lineName);
            actions.appendChild(removeBtn);

            li.appendChild(box);
            li.appendChild(info);
            li.appendChild(actions);
            routesListUl.appendChild(li);
        });
        currentStopSpecificColoursList.appendChild(routesListUl);
    });
}

function handleRemoveStopSpecificRouteColour(stopID, lineName) {
    if (!currentUser) return;
    if (stopSpecificRouteColours[stopID] && stopSpecificRouteColours[stopID][lineName.toUpperCase()]) {
        if (confirm(`Remove colour override for route ${lineName} at stop ${stopID}?`)) {
            delete stopSpecificRouteColours[stopID][lineName.toUpperCase()];
            if (Object.keys(stopSpecificRouteColours[stopID]).length === 0) {
                delete stopSpecificRouteColours[stopID];
            }
            saveStopSpecificRouteColoursToFirebase();
        }
    }
}
// --- END: Stop-Specific Route Colour Functions ---

// --- START: Global Route Deletion Functions ---
function populateGlobalRouteToDeleteSelector() {
    if (!selectGlobalRouteToDelete) return;
    const currentVal = selectGlobalRouteToDelete.value;
    selectGlobalRouteToDelete.innerHTML = '<option value="">-- Select Route --</option>';

    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) {
        selectGlobalRouteToDelete.innerHTML = '<option value="">-- No Routes in Schedule --</option>';
        return;
    }

    const uniqueRoutes = [...new Set(currentWorkingSchedule.map(entry => entry.lineName).filter(Boolean))].sort(compareLineNames);

    if (uniqueRoutes.length === 0) {
        selectGlobalRouteToDelete.innerHTML = '<option value="">-- No Valid Routes Found --</option>';
    } else {
        uniqueRoutes.forEach(lineName => {
            const opt = document.createElement('option');
            opt.value = lineName;
            opt.textContent = lineName;
            selectGlobalRouteToDelete.appendChild(opt);
        });
        if (uniqueRoutes.includes(currentVal)) {
            selectGlobalRouteToDelete.value = currentVal;
        }
    }
}

function handleDeleteEntireRouteGlobally() {
    if (!currentUser) {
        alert("Please log in to modify the schedule.");
        if (deleteEntireRouteStatusMessage) deleteEntireRouteStatusMessage.textContent = "Not logged in.";
        return;
    }

    const lineNameToDelete = selectGlobalRouteToDelete.value;

    if (!lineNameToDelete) {
        if (deleteEntireRouteStatusMessage) {
            deleteEntireRouteStatusMessage.textContent = "Please select a route to delete.";
            deleteEntireRouteStatusMessage.style.color = '#f1c40f';
        }
        return;
    }

    if (!confirm(`EXTREME CAUTION!\n\nYou are about to delete ALL schedule entries for route "${lineNameToDelete}" from ALL stops.\nThis will also remove its global custom colour and ALL stop-specific colour overrides for this route.\n\nTHIS ACTION CANNOT BE UNDONE EASILY.\n\nAre you absolutely sure you want to proceed?`)) {
        if (deleteEntireRouteStatusMessage) {
            deleteEntireRouteStatusMessage.textContent = "Global deletion cancelled.";
            deleteEntireRouteStatusMessage.style.color = '#7f8c8d';
        }
        return;
    }

    let originalScheduleLength = currentWorkingSchedule.length;

    currentWorkingSchedule = currentWorkingSchedule.filter(entry => {
        return !(entry.lineName && entry.lineName.toUpperCase() === lineNameToDelete.toUpperCase());
    });
    let scheduleEntriesRemovedCount = originalScheduleLength - currentWorkingSchedule.length;

    let globalColourRemoved = false;
    if (globalCustomRouteColours[lineNameToDelete.toUpperCase()]) {
        delete globalCustomRouteColours[lineNameToDelete.toUpperCase()];
        globalColourRemoved = true;
        saveGlobalCustomRouteColours();
    }

    let specificColoursRemovedCount = 0;
    let specificColoursNeedSave = false;
    Object.keys(stopSpecificRouteColours).forEach(stopID => {
        if (stopSpecificRouteColours[stopID] && stopSpecificRouteColours[stopID][lineNameToDelete.toUpperCase()]) {
            delete stopSpecificRouteColours[stopID][lineNameToDelete.toUpperCase()];
            specificColoursRemovedCount++;
            if (Object.keys(stopSpecificRouteColours[stopID]).length === 0) {
                delete stopSpecificRouteColours[stopID];
            }
            specificColoursNeedSave = true;
        }
    });
    if (specificColoursNeedSave) {
        saveStopSpecificRouteColoursToFirebase();
    }

    if (deleteEntireRouteStatusMessage) {
        deleteEntireRouteStatusMessage.textContent = `Route "${lineNameToDelete}" entirely deleted. ${scheduleEntriesRemovedCount} schedule entries removed. ${globalColourRemoved ? 'Global colour removed. ' : ''}${specificColoursRemovedCount > 0 ? specificColoursRemovedCount + ' stop-specific colour override(s) removed.' : ''}`;
        deleteEntireRouteStatusMessage.style.color = '#2ecc71';
    }
    selectGlobalRouteToDelete.value = "";

    renderUIDependentElements();
    updateStagingStatusDisplay();
}
// --- END: Global Route Deletion Functions ---


function getRouteTileColourForTools(lineName, stopID = null) {
    const upName = String(lineName || "").toUpperCase();

    if (stopID && stopSpecificRouteColours[stopID] && stopSpecificRouteColours[stopID][upName]) {
        return stopSpecificRouteColours[stopID][upName];
    }
    if (globalCustomRouteColours[upName]) {
        return globalCustomRouteColours[upName];
    }
    if (initialRouteColourMapForTools[upName]) {
        return initialRouteColourMapForTools[upName];
    }
    if (upName.startsWith("N")) return globalCustomRouteColours["N5"] || initialRouteColourMapForTools["N5"] || DEFAULT_ROUTE_COLOUR_TOOLS;
    if (upName.startsWith("SL")) return globalCustomRouteColours["SL1"] || initialRouteColourMapForTools["SL1"] || DEFAULT_ROUTE_COLOUR_TOOLS;

    return DEFAULT_ROUTE_COLOUR_TOOLS;
}


function getTextColourForBackgroundTools(hex) { if(!hex||hex.length<7)return'#FFFFFF'; const r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16); return((0.299*r+0.587*g+0.114*b)/255)>0.5?'#000000':'#FFFFFF';}
function getDaySortOrder(profile) { if(!profile)return 99;const p=profile.toUpperCase().split(',').map(s=>s.trim());if(p.some(s=>s.startsWith("MO")&&!s.startsWith("MO-FR")))return 1;if(p.some(s=>s.startsWith("TU")))return 2;if(p.some(s=>s.startsWith("WE")))return 3;if(p.some(s=>s.startsWith("TH")))return 4;if(p.some(s=>s.startsWith("FR")&&!s.startsWith("MO-FR")))return 5;if(p.some(s=>s.startsWith("MF")||s.startsWith("MO-FR")))return 6;if(p.some(s=>s.startsWith("SA")))return 7;if(p.some(s=>s.startsWith("SU")))return 8;if(p.includes("GOODFRIDAY"))return 10;if(p.includes("BANKHOLIDAY"))return 11; return 99;}
function populateStopSelectorForDeparturesView() { if (!selectStopForDeparturesView) return; const currentVal = selectStopForDeparturesView.value; selectStopForDeparturesView.innerHTML = '<option value="">-- Select Stop --</option>'; if (currentWorkingSchedule.length === 0) { displayDeparturesForSelectedStop(); return; } const stopsMap = new Map(); currentWorkingSchedule.forEach(e => { if (e.stopID && !stopsMap.has(e.stopID)) stopsMap.set(e.stopID, { stopID: e.stopID, stopName: e.stopName || e.stopID }); }); const sorted = Array.from(stopsMap.values()).sort((a,b)=>(a.stopName.toLowerCase()).localeCompare(b.stopName.toLowerCase())); sorted.forEach(s => { const opt = document.createElement('option'); opt.value = s.stopID; opt.textContent = `${s.stopName} (${s.stopID})`; selectStopForDeparturesView.appendChild(opt); }); if (stopsMap.has(currentVal)) selectStopForDeparturesView.value = currentVal; displayDeparturesForSelectedStop(); }

function displayDeparturesForSelectedStop() {
    if (!selectStopForDeparturesView || !stopDeparturesList || !noDeparturesForStopMessage) return;
    const selStopID = selectStopForDeparturesView.value;
    stopDeparturesList.innerHTML = '';

    if (!selStopID) {
        noDeparturesForStopMessage.textContent = 'Select stop to view.';
        noDeparturesForStopMessage.style.display = 'block';
        return;
    }

    const deps = currentWorkingSchedule
        .filter(e => e.stopID === selStopID)
        .sort((a, b) => {
            const offsetA = parseInt(a.DayOffset || "0", 10);
            const offsetB = parseInt(b.DayOffset || "0", 10);
            if (offsetA !== offsetB) return offsetA - offsetB;

            const dayA = getDaySortOrder(a.OperatingProfile);
            const dayB = getDaySortOrder(b.OperatingProfile);
            if (dayA !== dayB) return dayA - dayB;

            const timeA = (a.scheduledTime || "9999").replace(':', '');
            const timeB = (b.scheduledTime || "9999").replace(':', '');
            if (timeA !== timeB) return timeA.localeCompare(timeB);

            const lineComp = compareLineNames(a.lineName, b.lineName);
            if (lineComp !== 0) return lineComp;

            return (a.OperatingProfile || "").localeCompare(b.OperatingProfile || "");
        });

    if (deps.length === 0) {
        noDeparturesForStopMessage.textContent = 'No departures for this stop.';
        noDeparturesForStopMessage.style.display = 'block';
    } else {
        noDeparturesForStopMessage.style.display = 'none';
        deps.forEach(d => {
            const li = document.createElement('li');
            const tile = document.createElement('span');
            tile.className = 'route-tile-tools-list';
            tile.textContent = d.lineName || 'N/A';
            const bg = getRouteTileColourForTools(d.lineName, selStopID);
            tile.style.backgroundColor = bg;
            tile.style.color = getTextColourForBackgroundTools(bg);

            const span = document.createElement('span');
            span.innerHTML = ` to ${d.destinationName || 'Unknown'} <strong style="margin-left:0.5em;">at ${d.scheduledTime || 'N/A'}</strong> <small style="opacity:0.7;margin-left:0.75em;">(Profile: ${d.OperatingProfile || 'N/A'})</small>${d.DayOffset && d.DayOffset !== "0" ? `<small style="opacity:0.7;margin-left:0.3em;color:#FFD700;">(+${d.DayOffset}d)</small>` : ''}`;

            li.appendChild(tile);
            li.appendChild(span);
            stopDeparturesList.appendChild(li);
        });
    }
}

// --- Stop Management Tool Functions ---
function getUniqueStopsFromSchedule() {
    if (!currentWorkingSchedule || currentWorkingSchedule.length === 0) return [];
    const stopsMap = new Map();
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && !stopsMap.has(entry.stopID.toUpperCase())) {
            stopsMap.set(entry.stopID.toUpperCase(), {
                stopID: entry.stopID,
                stopName: entry.stopName || "Unknown Name",
                direction: entry.direction || "No Direction"
            });
        }
    });
    return Array.from(stopsMap.values()).sort((a, b) => (String(a.stopName||"").toLowerCase()).localeCompare(String(b.stopName||"").toLowerCase()));
}

function populateMasterStopList_SM() {
    if (!masterStopListUL_SM || !masterStopListStatus_SM) return;
    uniqueStopsMasterList_SM = getUniqueStopsFromSchedule();
    const filterText = masterStopListFilterInput_SM.value.toLowerCase();
    masterStopListUL_SM.innerHTML = '';
    let displayedCount = 0;

    const NIGHT_BUS_BLUE_COLOR_CONST = (initialRouteColourMapForTools["N35"] || "#4CDBE6").toUpperCase();
    const DAY_BUS_GREY_COLOR_CONST = DEFAULT_ROUTE_COLOUR_TOOLS.toUpperCase();

    if (uniqueStopsMasterList_SM.length === 0) {
        masterStopListStatus_SM.textContent = 'No unique stops found in the current working schedule.';
        return;
    }

    uniqueStopsMasterList_SM.forEach(stop => {
        if (!stop || !stop.stopID) return;
        const stopIdLower = stop.stopID.toLowerCase();
        const stopNameLower = (stop.stopName || "").toLowerCase();
        const stopDirectionLower = (stop.direction || "").toLowerCase();

        const servingRoutesData = new Map();
        let earliestTimeOverall = null;
        let latestTimeOverall = null;
        let hasNightBusService = false;
        let hasDayBusService = false;

        currentWorkingSchedule.forEach(entry => {
            if (entry.stopID === stop.stopID) {
                if (entry.lineName) {
                    if (!servingRoutesData.has(entry.lineName)) {
                        servingRoutesData.set(entry.lineName, {});
                    }
                    const tileColor = getRouteTileColourForTools(entry.lineName, stop.stopID).toUpperCase();
                    if (tileColor === NIGHT_BUS_BLUE_COLOR_CONST) hasNightBusService = true;
                    if (tileColor === DAY_BUS_GREY_COLOR_CONST) hasDayBusService = true;
                }
                if (entry.scheduledTime) {
                    const entryTimeNumeric = parseInt((entry.scheduledTime || "99:99").replace(":", ""), 10);
                    const entryDayOffset = parseInt(entry.DayOffset || "0", 10);
                    const comparableTime = entryTimeNumeric + (entryDayOffset * 2400);
                    if (earliestTimeOverall === null || comparableTime < (parseInt((earliestTimeOverall.time || "99:99").replace(":", ""), 10) + (earliestTimeOverall.dayOffset * 2400))) {
                        earliestTimeOverall = { time: entry.scheduledTime, dayOffset: entryDayOffset };
                    }
                    if (latestTimeOverall === null || comparableTime > (parseInt((latestTimeOverall.time || "00:00").replace(":", ""), 10) + (latestTimeOverall.dayOffset * 2400))) {
                        latestTimeOverall = { time: entry.scheduledTime, dayOffset: entryDayOffset };
                    }
                }
            }
        });
        const sortedServingRouteNames = Array.from(servingRoutesData.keys()).sort(compareLineNames);
        const isClosed = closedStopIDs.includes(stop.stopID);
        const closureStatus = isClosed ? "Closed" : "Open";
        const is24HourStop = hasNightBusService && hasDayBusService;

        const matchesFilter = !filterText ||
            stopIdLower.includes(filterText) ||
            stopNameLower.includes(filterText) ||
            stopDirectionLower.includes(filterText) ||
            sortedServingRouteNames.some(rn => rn.toLowerCase().includes(filterText)) ||
            closureStatus.toLowerCase().includes(filterText) ||
            (is24HourStop && "24 hours".includes(filterText));

        if (matchesFilter) {
            displayedCount++;
            const li = document.createElement('li');
            li.dataset.stopid = stop.stopID;

            let innerHTML = `
                <span class="stop-name-master">${stop.stopName}</span><br>
                <span class="stop-direction-master">Towards: ${stop.direction}</span><br>
                <span class="stop-id-master">Stop ID: ${stop.stopID}</span><br>
            `;

            if (sortedServingRouteNames.length > 0) {
                innerHTML += `<div class="serving-routes-container">`;
                sortedServingRouteNames.forEach(lineName => {
                    const bgColor = getRouteTileColourForTools(lineName, stop.stopID);
                    const textColor = getTextColourForBackgroundTools(bgColor);
                    innerHTML += `<span class="route-tile-tools-list" style="background-color: ${bgColor}; color: ${textColor};">${lineName}</span>`;
                });
                innerHTML += `</div>`;
            } else {
                innerHTML += `<div class="serving-routes-container"><span style="font-size:0.8em; opacity:0.7;">No routes currently scheduled.</span></div>`;
            }

            innerHTML += `<div class="stop-details-grid">`;
            innerHTML += `<span class="detail-label">Status:</span> <span class="detail-value status-${closureStatus.toLowerCase()}">${closureStatus}</span>`;

            if (is24HourStop) {
                innerHTML += `<span class="detail-label">Service:</span> <span class="detail-value" style="color: ${NIGHT_BUS_BLUE_COLOR_CONST}; font-weight: bold;">24 Hours</span>`;
                innerHTML += `<span class="detail-label">First Bus:</span> <span class="detail-value">-</span>`;
                innerHTML += `<span class="detail-label">Last Bus:</span> <span class="detail-value">-</span>`;
            } else {
                let firstBusText = earliestTimeOverall ? earliestTimeOverall.time + (earliestTimeOverall.dayOffset > 0 ? ` (+${earliestTimeOverall.dayOffset}d)` : '') : "N/A";
                let lastBusText = latestTimeOverall ? latestTimeOverall.time + (latestTimeOverall.dayOffset > 0 ? ` (+${latestTimeOverall.dayOffset}d)` : '') : "N/A";
                innerHTML += `<span class="detail-label">First Bus (approx):</span> <span class="detail-value">${firstBusText}</span>`;
                innerHTML += `<span class="detail-label">Last Bus (approx):</span> <span class="detail-value">${lastBusText}</span>`;
            }
            innerHTML += `</div>`;

            // Action Buttons
            innerHTML += `<div class="stop-actions">`;
            innerHTML += `<button class="button small-action" onclick="handleEditStop_SM('${stop.stopID}', '${stop.stopName}', '${stop.direction}')">Edit</button>`;
            innerHTML += `<button class="button small-action secondary" onclick="handleDeleteStop_SM('${stop.stopID}')">Delete</button>`;
            const closeOpenButtonText = isClosed ? "Open Stop" : "Close Stop";
            const closeOpenButtonClass = isClosed ? "" : "secondary"; // Empty for default blue, secondary for red (close)
            innerHTML += `<button class="button small-action ${closeOpenButtonClass}" onclick="handleToggleStopStatus_SM('${stop.stopID}')">${closeOpenButtonText}</button>`;
            innerHTML += `</div>`;

            li.innerHTML = innerHTML;
            masterStopListUL_SM.appendChild(li);
        }
    });

    if (displayedCount === 0 && uniqueStopsMasterList_SM.length > 0) {
        masterStopListStatus_SM.textContent = 'No stops match your filter.';
    } else {
        masterStopListStatus_SM.textContent = `Showing ${displayedCount} of ${uniqueStopsMasterList_SM.length} unique stops.`;
    }
}

// Placeholder for Edit Stop Modal/Logic
function handleEditStop_SM(stopID, currentName, currentDirection) {
    if (!currentUser) { alert("Please log in."); return; }
    // This is where you would pop up a modal or show a form to edit the stop.
    // For now, we'll use prompts as a placeholder.
    const newStopName = prompt(`Editing Stop: ${stopID}\nEnter new Stop Name (current: ${currentName}):`, currentName);
    if (newStopName === null) { // User cancelled
        masterStopListStatus_SM.textContent = `Edit cancelled for ${stopID}.`; return;
    }

    const newDirection = prompt(`Editing Stop: ${stopID}\nEnter new "Towards" text (current: ${currentDirection}):`, currentDirection);
    if (newDirection === null) { // User cancelled
        masterStopListStatus_SM.textContent = `Edit cancelled for ${stopID}.`; return;
    }

    if (!newStopName.trim() && !newDirection.trim()) {
        masterStopListStatus_SM.textContent = `Edit cancelled: No new name or direction provided for ${stopID}.`;
        return;
    }

    let updatedCount = 0;
    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && entry.stopID.toUpperCase() === stopID.toUpperCase()) {
            let entryChanged = false;
            if (newStopName.trim()) { entry.stopName = newStopName.trim(); entryChanged = true; }
            if (newDirection.trim()) { entry.direction = newDirection.trim(); entryChanged = true; }
            if (entryChanged) updatedCount++;
        }
    });

    if (updatedCount > 0) {
        renderUIDependentElements(); // This calls populateMasterStopList_SM
        masterStopListStatus_SM.textContent = `${updatedCount} entries for Stop ID "${stopID}" updated.`;
        setTimeout(() => populateMasterStopList_SM(), 100); // Refresh list again after short delay
    } else {
        masterStopListStatus_SM.textContent = `No entries found for Stop ID "${stopID}" to update, or no changes made.`;
    }
}

// Delete Stop from Master List
function handleDeleteStop_SM(stopIdToRemove) {
    if (!currentUser) { alert("Please log in."); return; }
    if (!stopIdToRemove) {
        masterStopListStatus_SM.textContent = "Stop ID not provided for deletion."; return;
    }
    if (!confirm(`ARE YOU SURE you want to remove stop "${stopIdToRemove}" and ALL its associated schedule entries from the working schedule? This cannot be undone easily.`)) {
        masterStopListStatus_SM.textContent = `Deletion of ${stopIdToRemove} cancelled.`; return;
    }

    const initialLength = currentWorkingSchedule.length;
    currentWorkingSchedule = currentWorkingSchedule.filter(entry => entry.stopID.toUpperCase() !== stopIdToRemove.toUpperCase());
    const removedCount = initialLength - currentWorkingSchedule.length;

    const closedIndex = closedStopIDs.indexOf(stopIdToRemove);
    if (closedIndex > -1) {
        closedStopIDs.splice(closedIndex, 1);
        // No direct save to Firebase here, rely on overall save or specific sync later
    }
    if (stopSpecificRouteColours[stopIdToRemove.toUpperCase()]) {
        delete stopSpecificRouteColours[stopIdToRemove.toUpperCase()];
        // No direct save to Firebase here
    }

    masterStopListStatus_SM.textContent = `Stop "${stopIdToRemove}" and ${removedCount} schedule entries removed.`;
    saveClosedStopsToFirebase(); // Save changes to closed stops
    saveStopSpecificRouteColoursToFirebase(); // Save changes to route colours
    renderUIDependentElements(); // This will refresh the master list via populateMasterStopList_SM
    updateStagingStatusDisplay(); // If schedule changed, staging status might change
}

// Toggle Stop Status from Master List
function handleToggleStopStatus_SM(stopID) {
    if (!currentUser) { alert("Please log in."); return; }
    if (!stopID) {
        masterStopListStatus_SM.textContent = "Stop ID not provided for status change."; return;
    }
    const stopDetails = uniqueStopsMasterList_SM.find(s => s.stopID === stopID);
    const stopName = stopDetails ? stopDetails.stopName : stopID;

    const idx = closedStopIDs.indexOf(stopID);
    if (idx === -1) { // Stop is currently open, so close it
        closedStopIDs.push(stopID);
        masterStopListStatus_SM.textContent = `Stop '${stopName}' closed.`;
    } else { // Stop is currently closed, so open it
        closedStopIDs.splice(idx, 1);
        masterStopListStatus_SM.textContent = `Stop '${stopName}' reopened.`;
    }
    saveClosedStopsToFirebase(); // This function now saves to Firebase
    // populateMasterStopList_SM will be called by renderUIDependentElements or directly if needed.
    // For immediate feedback, directly call it:
    populateMasterStopList_SM();
}


function handleFindReplaceStopIdInSchedule_SM() {
    if (!currentUser) { alert("Please log in."); return; }
    const findStopID = findStopIdScheduleInput_SM.value.trim().toUpperCase();
    const replaceStopID = replaceStopIdScheduleInput_SM.value.trim().toUpperCase();

    if (!findStopID || !replaceStopID) {
        findReplaceStatusMessage_SM.textContent = "Both 'Stop ID to Find' and 'Replace with New Stop ID' are required.";
        findReplaceStatusMessage_SM.style.color = '#e74c3c';
        return;
    }
    if (findStopID === replaceStopID) {
        findReplaceStatusMessage_SM.textContent = "Find and Replace Stop IDs cannot be the same.";
        findReplaceStatusMessage_SM.style.color = '#f1c40f';
        return;
    }

    if (!confirm(`Are you sure you want to replace ALL occurrences of Stop ID "${findStopID}" with "${replaceStopID}" in the working schedule? This action cannot be undone easily.`)) {
        findReplaceStatusMessage_SM.textContent = "Find and replace operation cancelled.";
        findReplaceStatusMessage_SM.style.color = '#7f8c8d';
        return;
    }

    let replacedCount = 0;
    let newNameForReplaced = "";
    let newDirectionForReplaced = "";

    const existingNewStopEntry = currentWorkingSchedule.find(e => e.stopID.toUpperCase() === replaceStopID);
    if (existingNewStopEntry) {
        newNameForReplaced = existingNewStopEntry.stopName;
        newDirectionForReplaced = existingNewStopEntry.direction;
    } else {
        const oldStopDetails = currentWorkingSchedule.find(e => e.stopID.toUpperCase() === findStopID);
        if (oldStopDetails) {
             newNameForReplaced = oldStopDetails.stopName;
             newDirectionForReplaced = oldStopDetails.direction;
             console.warn(`Details for new Stop ID "${replaceStopID}" not found. Using details from old Stop ID "${findStopID}".`);
        } else {
            console.warn(`Details for both new Stop ID "${replaceStopID}" and old Stop ID "${findStopID}" not found. Replaced entries might require manual name/direction update.`);
        }
    }

    currentWorkingSchedule.forEach(entry => {
        if (entry.stopID && entry.stopID.toUpperCase() === findStopID) {
            entry.stopID = replaceStopID;
            if (newNameForReplaced) entry.stopName = newNameForReplaced;
            if (newDirectionForReplaced) entry.direction = newDirectionForReplaced;
            replacedCount++;
        }
    });

    if (replacedCount > 0) {
        renderUIDependentElements();
        findReplaceStatusMessage_SM.textContent = `Replaced ${replacedCount} occurrences of "${findStopID}" with "${replaceStopID}".`;
        if (newNameForReplaced || newDirectionForReplaced) {
            findReplaceStatusMessage_SM.textContent += ` Name/Direction for "${replaceStopID}" updated to: "${newNameForReplaced || '(name not set)'}" / "${newDirectionForReplaced || '(direction not set)'}".`;
        }
        findReplaceStatusMessage_SM.style.color = '#2ecc71';
        findStopIdScheduleInput_SM.value = '';
        replaceStopIdScheduleInput_SM.value = '';
    } else {
        findReplaceStatusMessage_SM.textContent = `No occurrences of Stop ID "${findStopID}" found in the working schedule.`;
        findReplaceStatusMessage_SM.style.color = '#f1c40f';
    }
}

// Removed populateRoutesForStopSelector_SM and displayRoutesServingSelectedStop_SM as their section is gone.

// --- START: Functions for "Add/Remove Stop Details" section ---
function handleSuggestStopId_ARS() {
    if (!currentUser || !selectNewStopIdFormat_ARS || !inputNewStopId_ARS) return;
    const selectedFormat = selectNewStopIdFormat_ARS.value;
    const suggestedId = generateUniqueStopId(selectedFormat);
    inputNewStopId_ARS.value = suggestedId;
    inputNewStopId_ARS.dispatchEvent(new Event('input', {bubbles:true, cancelable:true}));

    if (addNewStopStatus_ARS) {
        if (suggestedId && !suggestedId.includes(String(Date.now()).slice(-5))) {
            addNewStopStatus_ARS.textContent = `Suggested ID: ${suggestedId}. You can edit this.`;
            addNewStopStatus_ARS.style.color = '#bdc3c7';
        } else if (suggestedId) {
             addNewStopStatus_ARS.textContent = `Suggested fallback ID: ${suggestedId}. Please review.`;
            addNewStopStatus_ARS.style.color = '#f1c40f';
        }else {
            addNewStopStatus_ARS.textContent = 'Could not suggest a unique ID for the selected format.';
            addNewStopStatus_ARS.style.color = '#e74c3c';
        }
    }
}

function handleAddStopDetails_ARS() {
    if (!currentUser) { alert("Please log in."); return; }

    const newStopID = inputNewStopId_ARS.value.trim().toUpperCase();
    const newStopName = inputNewStopName_ARS.value.trim();
    const newStopDirection = inputNewStopDirection_ARS.value.trim();

    if (!newStopID) {
        addNewStopStatus_ARS.textContent = "New Stop ID is required.";
        addNewStopStatus_ARS.style.color = '#e74c3c'; inputNewStopId_ARS.focus(); return;
    }
    if (!newStopName) {
        addNewStopStatus_ARS.textContent = "New Stop Name is required.";
        addNewStopStatus_ARS.style.color = '#e74c3c'; inputNewStopName_ARS.focus(); return;
    }
    if (!newStopDirection) {
        addNewStopStatus_ARS.textContent = "New Stop Direction (Towards) is required.";
        addNewStopStatus_ARS.style.color = '#e74c3c'; inputNewStopDirection_ARS.focus(); return;
    }

    const existingStopIDs = new Set(currentWorkingSchedule.map(entry => entry.stopID.toUpperCase()));
    if (existingStopIDs.has(newStopID)) {
        addNewStopStatus_ARS.textContent = `Stop ID "${newStopID}" already exists. Please choose a unique ID.`;
        if(newStopIdAvailability_ARS) {
            newStopIdAvailability_ARS.textContent = 'Stop ID already exists.';
            newStopIdAvailability_ARS.style.color = '#e74c3c';
        }
        inputNewStopId_ARS.focus(); return;
    }

    const placeholderEntry = {
        internalId: `${newStopID}_placeholder_${Date.now()}`, stopID: newStopID,
        stopName: newStopName, direction: newStopDirection,
        lineName: "INFO_ONLY", destinationName: "Stop Definition Placeholder",
        scheduledTime: "00:00", OperatingProfile: "AllDays", DayOffset: "0"
    };
    currentWorkingSchedule.push(placeholderEntry);

    addNewStopStatus_ARS.textContent = `Stop details for "${newStopID} - ${newStopName}" added with a placeholder schedule entry. You can now use this stop in the generator.`;
    addNewStopStatus_ARS.style.color = '#2ecc71';

    inputNewStopId_ARS.value = ''; inputNewStopName_ARS.value = ''; inputNewStopDirection_ARS.value = '';
    if(newStopIdAvailability_ARS) newStopIdAvailability_ARS.textContent = '';
    selectNewStopIdFormat_ARS.selectedIndex = 0;
    renderUIDependentElements();
}

function populateStopToRemoveSelector_ARS() {
    if (!selectStopToRemove_ARS) return;
    const currentVal = selectStopToRemove_ARS.value;
    selectStopToRemove_ARS.innerHTML = '<option value="">-- Select Stop to Remove --</option>';
    const uniqueStops = getUniqueStopsFromSchedule();

    if (uniqueStops.length === 0) {
        selectStopToRemove_ARS.innerHTML = '<option value="">-- No Stops in Schedule --</option>'; return;
    }
    uniqueStops.forEach(stop => {
        const opt = document.createElement('option'); opt.value = stop.stopID;
        opt.textContent = `${stop.stopName} (${stop.stopID})`;
        selectStopToRemove_ARS.appendChild(opt);
    });
    if (uniqueStops.find(s => s.stopID === currentVal)) {
        selectStopToRemove_ARS.value = currentVal;
    }
}

function handleRemoveStop_ARS() {
    if (!currentUser) { alert("Please log in."); return; }
    const stopIdToRemove = selectStopToRemove_ARS.value;

    if (!stopIdToRemove) {
        removeStopStatus_ARS.textContent = "Please select a stop to remove.";
        removeStopStatus_ARS.style.color = '#f1c40f'; return;
    }
    if (!confirm(`ARE YOU SURE you want to remove stop "${stopIdToRemove}" and ALL its associated schedule entries from the working schedule? This cannot be undone easily.`)) {
        removeStopStatus_ARS.textContent = "Remove operation cancelled.";
        removeStopStatus_ARS.style.color = '#7f8c8d'; return;
    }

    const initialLength = currentWorkingSchedule.length;
    currentWorkingSchedule = currentWorkingSchedule.filter(entry => entry.stopID.toUpperCase() !== stopIdToRemove.toUpperCase());
    const removedCount = initialLength - currentWorkingSchedule.length;

    const closedIndex = closedStopIDs.indexOf(stopIdToRemove);
    if (closedIndex > -1) {
        closedStopIDs.splice(closedIndex, 1);
    }
    if (stopSpecificRouteColours[stopIdToRemove.toUpperCase()]) {
        delete stopSpecificRouteColours[stopIdToRemove.toUpperCase()];
    }

    removeStopStatus_ARS.textContent = `Stop "${stopIdToRemove}" and ${removedCount} schedule entries removed. Closed status and specific colours for this stop also cleared.`;
    removeStopStatus_ARS.style.color = '#2ecc71';

    saveClosedStopsToFirebase();
    saveStopSpecificRouteColoursToFirebase();
    renderUIDependentElements();
    updateStagingStatusDisplay();
}
// --- END: Functions for "Add/Remove Stop Details" section ---

// --- START: Auto Apply Scheduler ---
function initializeAutoApplyScheduler() {
    if (autoApplyIntervalId) { clearInterval(autoApplyIntervalId); }
    autoApplyIntervalId = setInterval(checkForAutoApply, 60 * 1000);
    console.log("Auto-apply scheduler initialized. Will check time every minute.");
}

function stopAutoApplyScheduler() {
    if (autoApplyIntervalId) {
        clearInterval(autoApplyIntervalId);
        autoApplyIntervalId = null;
        console.log("Auto-apply scheduler stopped.");
    }
}

async function checkForAutoApply() {
    if (!currentUser) { return; }

    const now = new Date();
    const day = now.getDay();
    const hour = now.getHours();
    const currentISODate = now.toISOString().split('T')[0];

    if (day === 6 && hour === 3) { // Saturday 3 AM
        const flagKey = 'autoAppliedSat3AM_' + currentISODate;
        if (sessionStorage.getItem(flagKey) === 'true') {
            return;
        }

        console.log(`It's Saturday 3 AM (${currentISODate}). Checking for staged schedule...`);

        if (window.firebaseOMSI) {
            const { database, dbGet, dbRef, dbChild } = window.firebaseOMSI;
            try {
                const statusSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_APPSTATE_STATUS));
                const pendingTimestampSnapshot = await dbGet(dbChild(dbRef(database), FB_PATH_PENDING_TIMESTAMP));
                const currentFbStatus = statusSnapshot.exists() ? statusSnapshot.val() : 'unknown';
                const pendingTimestamp = pendingTimestampSnapshot.exists() ? pendingTimestampSnapshot.val() : null;

                if (currentFbStatus === 'update_staged' && pendingTimestamp) {
                    console.log("Auto-apply: Staged update found. Attempting to apply now...");

                    const originalConfirm = window.confirm;
                    window.confirm = (message) => {
                        console.log(`Auto-apply: Bypassed confirmation for: "${message}"`);
                        return true;
                    };

                    handleApplyNow();

                    window.confirm = originalConfirm;

                    sessionStorage.setItem(flagKey, 'true');
                    console.log(`Auto-apply attempted for ${currentISODate} at 3 AM.`);
                } else {
                    console.log(`Auto-apply: No staged update found or missing timestamp. Status: ${currentFbStatus}`);
                    sessionStorage.setItem(flagKey, 'true'); // Set flag even if not applied to prevent re-check in same hour
                }
            } catch (error) {
                console.error("Auto-apply: Error checking Firebase status:", error);
            }
        } else { console.log("Auto-apply: Firebase not available."); }
    }
}
// --- END: Auto Apply Scheduler ---


// --- Event Listeners & Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    if (adminLoginSection) adminLoginSection.style.display = 'block';
    if (currentProfileDisplayContainer) currentProfileDisplayContainer.style.display = 'none';
    if (topMenuBar) topMenuBar.style.display = 'none';
    hideAllToolSections();

    const allMainMenuButtons = document.querySelectorAll('#main-menu-buttons .menu-button');
    allMainMenuButtons.forEach(button => {
        button.addEventListener('click', () => {
            const sectionId = button.getAttribute('data-section');
            if (currentUser && sectionId) {
                 showSection(sectionId);
            }
        });
    });

    if(detectDuplicatesButton) detectDuplicatesButton.addEventListener('click', detectDuplicateEntries);
    if(removeDuplicateEntriesButton) removeDuplicateEntriesButton.addEventListener('click', handleRemoveDuplicateEntries);
    if(consolidateOperatingDaysButton) consolidateOperatingDaysButton.addEventListener('click', handleConsolidateOperatingDays);
    if(consolidateStopSelect) consolidateStopSelect.addEventListener('change', populateConsolidateRouteSelect);


    const inputNewStopId_ARS_El = document.getElementById('inputNewStopId_ARS');
    const newStopIdAvailability_ARS_El = document.getElementById('newStopIdAvailability_ARS');
    if (inputNewStopId_ARS_El && newStopIdAvailability_ARS_El) {
        inputNewStopId_ARS_El.addEventListener('input', () => {
            const newStopId = inputNewStopId_ARS_El.value.trim().toUpperCase();
            if (!newStopId) {
                newStopIdAvailability_ARS_El.textContent = '';
                newStopIdAvailability_ARS_El.style.color = '';
                return;
            }
            const existingStopIDs = new Set(currentWorkingSchedule.map(entry => entry.stopID.toUpperCase()));
            if (existingStopIDs.has(newStopId)) {
                newStopIdAvailability_ARS_El.textContent = 'Stop ID already exists.';
                newStopIdAvailability_ARS_El.style.color = '#e74c3c';
            } else {
                newStopIdAvailability_ARS_El.textContent = 'Stop ID is available.';
                newStopIdAvailability_ARS_El.style.color = '#2ecc71';
            }
        });
    }


    if (window.firebaseOMSI && window.firebaseOMSI.auth) {
        const { auth, authOnAuthStateChanged, authSignInWithEmailAndPassword, authSignOut } = window.firebaseOMSI;

        authOnAuthStateChanged(auth, (user) => {
            updateAuthUI(user);
            if (user) {
                console.log("Firebase: User is signed in.");
                fetchBankHolidaysForSetup().then(() => {
                    loadInitialData();
                }).catch(error => {
                    console.error("Failed to fetch bank holidays, proceeding with data load.", error);
                    loadInitialData();
                });
            } else {
                console.log("Firebase: User is signed out.");
                currentWorkingSchedule = [];
                closedStopIDs = [];
                globalCustomRouteColours = {};
                stopSpecificRouteColours = {};
                if (currentProfileDisplayElement) currentProfileDisplayElement.textContent = "Today's Auto Profile: (determining...)";
                updateStagingStatusDisplay();
                const selectsToClearOnLogout = [
                    selectRouteNameColour, selectStopForDeparturesView,
                    document.getElementById('gen_stopNameSelect'),
                    document.getElementById('gen_routeSelect'),
                    document.getElementById('gen_destinationSelect'),
                    selectNewStopIdFormat_ARS,
                    selectStopToRemove_ARS,
                    consolidateStopSelect, consolidateRouteSelect,
                    sgCopierSourceStopSelect, sgCopierTargetStopSelect,
                    selectStopForSpecificRouteColour,
                    selectGlobalRouteToDelete
                    // Removed event and stop status selectors
                ];
                selectsToClearOnLogout.forEach(sel => {
                    if (sel) {
                        const firstOptionText = sel.options.length > 0 ? sel.options[0].text : "-- Select --";
                        sel.innerHTML = `<option value="">${firstOptionText.startsWith('--') ? firstOptionText : '-- Select --'}</option>`;
                        if (['gen_stopNameSelect', 'gen_routeSelect', 'gen_destinationSelect',
                             'consolidateStopSelect', 'sgCopierSourceStopSelect',
                             'selectStopForSpecificRouteColour', 'selectGlobalRouteToDelete'].includes(sel.id)) {
                            sel.dispatchEvent(new Event('change'));
                        }
                    }
                });
                 if(sgCopierSourceRoutesContainer) sgCopierSourceRoutesContainer.innerHTML = '<p id="sgCopierSourceRoutesPlaceholder">Select a source stop to see routes.</p>';
                 if(sgCopierStatusMessage) sgCopierStatusMessage.textContent = 'Select source stop to begin.';
                 if(specificRouteColourTilesContainer) specificRouteColourTilesContainer.innerHTML = '<p id="specificRouteColourTilesPlaceholder">Select a stop to see its routes.</p>';

                 if(stopDeparturesList) stopDeparturesList.innerHTML = '';
                 if(noDeparturesForStopMessage) { noDeparturesForStopMessage.textContent = 'Select stop to view.'; noDeparturesForStopMessage.style.display = 'block';}
                 if(masterStopListUL_SM) masterStopListUL_SM.innerHTML = '';
                 if(masterStopListStatus_SM) masterStopListStatus_SM.textContent = 'Please log in and load/refresh data.';
                 // Removed routesServingStopList_SM and routesServingStopStatus_SM clearing as their section is gone
                 if(addNewStopStatus_ARS) addNewStopStatus_ARS.textContent = '';
                 if(newStopIdAvailability_ARS_El) newStopIdAvailability_ARS_El.textContent = '';
                 if(removeStopStatus_ARS) removeStopStatus_ARS.textContent = '';
                 if(removeDuplicatesStatusMessage) removeDuplicatesStatusMessage.textContent = '';
                 if(consolidateOpDaysStatusMessage) consolidateOpDaysStatusMessage.textContent = '';
                 if(consolidateNewProfileInput) consolidateNewProfileInput.value = '';
                 if(currentRouteColoursList) currentRouteColoursList.innerHTML = '';
                 if(noCustomColoursMessage && document.getElementById('bulk-edit-tools-section').contains(noCustomColoursMessage)) noCustomColoursMessage.style.display = 'block';
                 if(currentStopSpecificColoursList) currentStopSpecificColoursList.innerHTML = '';

                const noStopSpecificMsgElQuery = document.getElementById('currentStopSpecificColoursListContainer');
                if(noStopSpecificMsgElQuery){
                    const noStopSpecMsgEl = noStopSpecificMsgElQuery.querySelector('#noStopSpecificColoursMessage'); // Corrected variable name
                     if(noStopSpecMsgEl) noStopSpecMsgEl.style.display = 'block';
                }


                 if (deleteRouteFromStopButton) deleteRouteFromStopButton.style.display = 'none';
                 if (deleteRouteFromStopStatusMessage) deleteRouteFromStopStatusMessage.textContent = '';
                 if (deleteEntireRouteStatusMessage) deleteEntireRouteStatusMessage.textContent = '';

            }
        });

        if (loginButton) {
            loginButton.addEventListener('click', (event) => {
                event.preventDefault();
                const email = inputEmail.value;
                const password = inputPassword.value;
                if(authStatus) authStatus.textContent = 'Logging in...';
                authSignInWithEmailAndPassword(auth, email, password)
                .catch((error) => {
                    console.error("Login Error:", error);
                    if(authStatus) authStatus.textContent = `Login Error: ${error.message}`;
                });
            });
        }
        if (logoutButton) {
            logoutButton.addEventListener('click', () => {
                localStorage.removeItem(LOCAL_STORAGE_ACTIVE_SECTION_KEY);
                authSignOut(auth).catch((e) => console.error("Sign-out Error:", e));
            });
        }
    } else {
        console.warn("Firebase Auth not available on DOMContentLoaded.");
        updateAuthUI(null);
        if (authStatus) authStatus.textContent = 'Firebase not available. Cannot log in.';
    }

    if (stageScheduleButton) stageScheduleButton.addEventListener('click', handleStageSchedule);
    if (applyNowButton) applyNowButton.addEventListener('click', handleApplyNow);
    if (viewArrivalsButton) viewArrivalsButton.addEventListener('click', () => { window.location.href = "omsi_arrivals.html"; });
    if (countFileInput) countFileInput.addEventListener('change', handleCountFileUpload);

    // Removed event listeners for bulkEditTargetStopIDInput and related elements as the section is gone.
    if(bulkEditTargetLineNameInput) { bulkEditTargetLineNameInput.addEventListener('input', (e) => { e.target.value = e.target.value.toUpperCase(); }); }
    if(bulkUpdateRouteDestinationButton) bulkUpdateRouteDestinationButton.addEventListener('click', handleBulkUpdateRouteDestination);

    // Removed event listeners for Event Generator and Stop Status sections.

    if (saveRouteColourButton) saveRouteColourButton.addEventListener('click', handleSaveGlobalRouteColour);
    if (selectRouteNameColour) { selectRouteNameColour.addEventListener('change', () => { const selectedRoute = selectRouteNameColour.value; if (selectedRoute && globalCustomRouteColours[selectedRoute.toUpperCase()]) { inputRouteColour.value = globalCustomRouteColours[selectedRoute.toUpperCase()]; } else if (initialRouteColourMapForTools[selectedRoute.toUpperCase()]) { inputRouteColour.value = initialRouteColourMapForTools[selectedRoute.toUpperCase()]; } else { inputRouteColour.value = DEFAULT_ROUTE_COLOUR_TOOLS; } }); }


    if (selectStopForSpecificRouteColour) {
        selectStopForSpecificRouteColour.addEventListener('change', displayRoutesForSpecificColouring);
    }
    if (saveStopSpecificRouteColourButton) {
        saveStopSpecificRouteColourButton.addEventListener('click', handleSaveStopSpecificRouteColour);
    }
    if (deleteRouteFromStopButton) deleteRouteFromStopButton.addEventListener('click', handleDeleteRouteFromSpecificStop);


    if (selectStopForDeparturesView) { selectStopForDeparturesView.addEventListener('change', displayDeparturesForSelectedStop); }

    if (refreshMasterStopListButton_SM) refreshMasterStopListButton_SM.addEventListener('click', populateMasterStopList_SM);
    if (masterStopListFilterInput_SM) masterStopListFilterInput_SM.addEventListener('input', populateMasterStopList_SM);
    if (findStopIdScheduleInput_SM) findStopIdScheduleInput_SM.addEventListener('input', (e) => e.target.value = e.target.value.toUpperCase());
    if (replaceStopIdScheduleInput_SM) replaceStopIdScheduleInput_SM.addEventListener('input', (e) => e.target.value = e.target.value.toUpperCase());
    if (findReplaceStopIdScheduleButton_SM) findReplaceStopIdScheduleButton_SM.addEventListener('click', handleFindReplaceStopIdInSchedule_SM);
    // Removed event listeners for routesForStopSelect_SM and refreshRoutesForStopSelectButton_SM

    if (buttonSuggestStopId_ARS) {
        buttonSuggestStopId_ARS.addEventListener('click', handleSuggestStopId_ARS);
    }
    if (buttonAddNewStop_ARS) {
        buttonAddNewStop_ARS.addEventListener('click', handleAddStopDetails_ARS);
    }
    if(selectNewStopIdFormat_ARS) {
        selectNewStopIdFormat_ARS.addEventListener('change', handleSuggestStopId_ARS);
    }
    if(buttonRemoveStop_ARS) {
        buttonRemoveStop_ARS.addEventListener('click', handleRemoveStop_ARS);
    }

    if (deleteEntireRouteButton) deleteEntireRouteButton.addEventListener('click', handleDeleteEntireRouteGlobally);

    fetchBankHolidaysForSetup();

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/live-tracker/sw-omsi.js')
            .then(registration => {
                console.log('Service Worker (sw-omsi.js) registered successfully with scope:', registration.scope);
            })
            .catch(error => {
                console.error('Service Worker (sw-omsi.js) registration failed:', error);
            });
        });
    }
});
</script>
</body>
</html>
