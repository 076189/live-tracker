<!DOCTYPE html>
<html>
<head>
    <title>Live Tracker (Tools)</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* --- CSS Styles (Includes Audit/Suspension styles) --- */
        /* Basic Reset & Font */
        body, html { margin: 0; padding: 0; box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }
        body { font-family: Arial, sans-serif; padding: 20px; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; background-color: #f4f4f4; flex-direction: column; }
        /* Containers */
        .login-container, .app-container { background-color: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); text-align: center; margin: 20px auto; width: 90%; max-width: 800px; }
        .login-container { min-width: 300px; max-width: 400px; }
        /* Headings and Text */
        h1, h2, h3, h4 { margin-top: 0; color: #333; }
        h1 { margin-bottom: 20px; } h2 { margin-bottom: 20px; } h3 { margin-bottom: 15px; }
        h4 { margin-top: 25px; border-top: 1px solid #ccc; padding-top: 15px; margin-bottom: 10px; text-align: center; }
        .welcome-message { font-size: 1.2em; color: #555; margin-bottom: 20px; }
        .description-text { font-size: 0.9em; color: #666; margin-top: 5px; margin-bottom: 15px; text-align: center; } /* Default center */
        .status-message { margin-top: 10px; text-align: center; min-height: 1em; font-weight: bold; }
        .export-reminder-message { display: none; padding: 10px 15px; margin-bottom: 20px; border-radius: 4px; border: 1px solid #ffeeba; background-color: #fff3cd; color: #856404; font-weight: bold; text-align: center; }
        .security-warning { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 10px 15px; margin: 15px 0; border-radius: 4px; font-size: 0.9em; text-align: left; }
        /* Button Styles & Grouping */
        .blue-button, .reset-button, .danger-button, .secondary-button { padding: 10px 20px; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; margin-right: 10px; margin-bottom: 10px; display: inline-block; transition: background-color 0.2s ease, opacity 0.2s ease; vertical-align: middle; /* Added */ }
        .blue-button { background-color: #007bff; } .blue-button:hover { background-color: #0056b3; }
        .reset-button { background-color: #ffc107; color: black; border: 1px solid #d39e00; } .reset-button:hover { background-color: #e0a800; }
        .danger-button { background-color: #dc3545; } .danger-button:hover { background-color: #c82333; }
        .secondary-button { background-color: #6c757d; font-size: 0.9em; padding: 6px 12px;} .secondary-button:hover { background-color: #5a6268; }
        .blue-button:last-of-type, .reset-button:last-of-type, .danger-button:last-of-type, .secondary-button:last-of-type { margin-right: 0; }

        /* --- Disabled Button Style --- */
        button:disabled, .blue-button:disabled, .reset-button:disabled, .danger-button:disabled, .secondary-button:disabled {
             background-color: #cccccc; border-color: #cccccc; color: #666666; cursor: not-allowed; opacity: 0.7;
        }
         button:disabled:hover, .blue-button:disabled:hover, .reset-button:disabled:hover, .danger-button:disabled:hover, .secondary-button:disabled:hover {
             background-color: #cccccc; border-color: #cccccc; color: #666666;
         }
        /* --- End Disabled Button Style --- */

        /* --- Prune Button Specific Styles --- */
        .prune-button {
            /* Inherits padding, font-size, border-radius etc. from .blue-button */
            background-color: #dc3545; /* Default to danger color */
            border-color: #dc3545;
        }
        .prune-button:hover:not(:disabled) {
             background-color: #c82333; /* Darker danger color on hover when enabled */
             border-color: #bd2130;
        }
        /* Disabled state is handled by the general button:disabled rule */
        /* --- End Prune Button Styles --- */


        .main-actions-container { margin-bottom: 25px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
        .data-actions-container { margin-bottom: 20px; padding: 20px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9; }
        /* Forms & Inputs */
        .form-group, .settings-group { margin-bottom: 15px; text-align: left; }
        .form-group label, .settings-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        .form-group-inline { display: flex; align-items: center; text-align: left; margin-bottom: 15px;}
        .form-group-inline input[type="checkbox"] { width: auto; margin-right: 8px; height: 1em; margin-bottom: 0;}
        .form-group-inline label { font-weight: normal; margin-bottom: 0; }
        fieldset { border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-bottom: 20px; }
        legend { font-weight: bold; padding: 0 5px; color: #555; }
        input[type="text"], input[type="password"], input[type="time"], input[type="number"], select, textarea { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; margin-bottom: 10px; font-size: 1em; font-family: inherit; }
        /* Reduce specificity for buttons inside sections */
        #add-curtailment-form button, #manual-fleet-form button,
        #settings-form fieldset button, .settings-group button,
        #data-actions .action-group button,
        #manage-curtailments-section button {
              width: auto; display: inline-block; margin: 10px 10px 0 0;
        }
        /* Ensure Backup/Restore buttons are also inline-block for better alignment */
        #data-actions .action-group button {
            display: inline-block; /* Explicitly set */
            margin: 5px; /* Add some spacing */
        }

        /* Section/Form Styles */
        .section { /* Generic class for main content sections */
              margin-top: 20px; padding: 20px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9; text-align: left; margin-bottom: 20px;
        }
        /* Specific section IDs inherit from .section but can override */
        #add-curtailment-form, #manual-fleet-form, #settings-form, #data-actions, #manage-curtailments-section, #view-auto-tmp-section {
              /* Inherits from .section */
        }

        /* Specific Section Headings */
        #add-curtailment-form h3, #manual-fleet-form h3, #settings-form h2, #data-actions h3,
        #manage-curtailments-section h3, #view-auto-tmp-section h2 { /* Use H2 for main section titles */
              margin-top: 0; text-align: center; margin-bottom: 15px; border: none; padding: 0;
        }


        /* Add New User Form Container Styling Update */
        .add-user-form-container {
            padding: 10px 0; /* Adjusted padding */
            margin-bottom: 20px; /* Adjusted margin */
            /* Removed border, background, border-radius */
        }
        .add-user-form-container h4 { /* Keeping previous style for heading inside */
            margin-top: 0;
            text-align: center;
            border: none;
            padding: 0;
            margin-bottom: 15px;
        }
        .add-user-form-container .form-group {
             margin-bottom: 10px; /* Slightly reduce margin within the form */
        }
        .add-user-form-container button {
            display: block; /* Make button block level */
            width: 100%; /* Make button full width of container */
            max-width: 200px; /* Optional: Limit max width */
            margin: 15px auto 0 auto; /* Center button */
        }
         .add-user-form-container .status-message {
             margin-top: 15px;
         }

        /* User Management Table */
        #user-management-table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.9em; table-layout: auto; }
        #user-management-table th, #user-management-table td { border: 1px solid #ddd; padding: 8px; text-align: left; vertical-align: middle; }
        #user-management-table th { background-color: #f2f2f2; white-space: nowrap; }
        #user-management-table td { word-break: break-word; }

        /* -- ADJUSTED USER MANAGEMENT COLUMN WIDTHS -- */
        #user-management-table th:nth-child(1), #user-management-table td:nth-child(1) { /* Username */
            /* No fixed width - let it take remaining space */
        }
        #user-management-table th:nth-child(2), #user-management-table td:nth-child(2) { /* Role */
            width: 90px;
        }
        #user-management-table th:nth-child(3), #user-management-table td:nth-child(3) { /* Status */
            width: 80px; text-align: center;
        }
         #user-management-table th:nth-child(4), #user-management-table td:nth-child(4) { /* New Password */
             /* No fixed width now */
        }
        #user-management-table th:nth-child(5), #user-management-table td:nth-child(5) { /* Permissions */
             /* No fixed width now */
             min-width: 120px; /* Optional: ensure it has some minimum space */
        }
        #user-management-table th:nth-child(6), #user-management-table td:nth-child(6) { /* Actions */
            width: 120px; /* Adjusted width */
            white-space: normal; /* Allow wrapping if needed */
        }
        /* -- END ADJUSTED USER MANAGEMENT COLUMN WIDTHS -- */

        #user-management-table select, #user-management-table input[type="password"] { padding: 5px 8px; font-size: 0.9em; margin: 0; width: 100%; max-width: none; box-sizing: border-box; }
        #user-management-table button { padding: 5px 8px; font-size: 0.9em; margin: 2px 5px 2px 0; width: auto; } /* Base style for buttons in table */

        #user-management-table .delete-user-btn { background-color: #dc3545; color: white; border: none; } #user-management-table .delete-user-btn:hover { background-color: #c82333; }
        #user-management-table .suspend-user-btn { background-color: #ffc107; color: black; border: none; } #user-management-table .suspend-user-btn:hover { background-color: #e0a800; }
        #user-management-table .unsuspend-user-btn { background-color: #28a745; color: white; border: none; } #user-management-table .unsuspend-user-btn:hover { background-color: #218838; }
        .status-active { color: green; font-weight: bold; } .status-suspended { color: orange; font-weight: bold; } .status-blocked { color: red; font-weight: bold; }
        #user-management-table th.permissions-header {} #user-management-table td.permissions-cell { vertical-align: top; } #user-management-table td.permissions-cell div { margin-bottom: 4px; font-size: 0.9em; white-space: nowrap; } #user-management-table td.permissions-cell label { margin-left: 5px; font-weight: normal; cursor: pointer; } #user-management-table td.permissions-cell input[type="checkbox"] { vertical-align: middle; }

        /* --- Stack Action Buttons in User Management Table --- */
        #user-management-table tbody td:last-child { /* Target Actions cell */
            white-space: normal; /* Ensure buttons can stack if cell is narrow */
        }
        #user-management-table tbody td:last-child button {
            display: block;     /* Stack buttons vertically */
            width: 100%;        /* Make buttons fill cell width */
            margin-bottom: 5px; /* Add space between stacked buttons */
            margin-right: 0;    /* Remove horizontal margin */
            margin-left: 0;     /* Remove potential left margin */
            box-sizing: border-box; /* Include padding/border in width */
        }
        #user-management-table tbody td:last-child button:last-child {
            margin-bottom: 0; /* Remove bottom margin from the last button */
        }
        /* --- End Stack Action Buttons --- */

        /* Manual Fleet Specific */
        .revert-section, .reset-all-section { margin-top: 25px; border-top: 1px dashed #ccc; padding-top: 20px; text-align: center; }
        #manual-assignments-display { text-align: left; max-height: 150px; overflow-y: auto; border: 1px solid #eee; padding: 10px; background-color: white; font-size: 0.9em; line-height: 1.4; margin-bottom: 20px; }
        #manual-assignments-display div { padding: 4px 2px; border-bottom: 1px dotted #f0f0f0; }
        #manual-assignments-display div:last-child { border-bottom: none; }
        #manual-assignments-display strong { display: inline-block; min-width: 90px; font-weight: bold; margin-right: 5px;}
        #manual-fleet-form .filter-controls input[type="text"] {
             width: auto; padding: 5px 8px; font-size: 0.9em; margin-bottom: 0; box-sizing: border-box;
        }
        /* Modal Styles (Only Password Modal remains) */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-box { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); text-align: left; width: 90%; max-width: 400px; /* Smaller width often suitable for password confirm */ max-height: 80%; display: flex; flex-direction: column; overflow: hidden; }
        .modal-box h3 { margin-top: 0; text-align: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; flex-shrink: 0; }
        .modal-box label { margin-bottom: 8px; } /* Add margin below label */
        .modal-box input[type="password"] { margin-bottom: 5px;} /* Adjust password input margin */
        .modal-buttons { text-align: right; margin-top: auto; padding-top: 15px; border-top: 1px solid #eee; flex-shrink: 0; }
        .modal-buttons button { margin-left: 10px; } .modal-buttons .cancel-button { background-color: #6c757d; } .modal-buttons .cancel-button:hover { background-color: #5a6268; }
        /* Utility */
        .hidden { display: none; } #app-container > div:has(#logout-button) { text-align: center; } #manual-fleet-form div > .description-text { margin-top: 5px; }
        /* Backup/Restore */
        .action-group { text-align: center; margin-bottom: 20px; border-top: 1px solid #eee; padding-top: 15px; } .action-group:first-of-type { border-top: none; padding-top: 0; } .action-group h4 { margin-top: 0; margin-bottom: 10px; padding: 0; border: none; color: #555; font-size: 1.1em; } .action-group p.description-text { margin-top: 8px; margin-bottom: 0; text-align: center; /* Ensure description text is centered */}

        /* --- Table Styles (Generic) --- */
        .table-container { overflow-x: auto; margin-top: 15px; }
        table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
        table th, table td { border: 1px solid #ddd; padding: 8px; text-align: left; vertical-align: middle; }
        table th { background-color: #f2f2f2; white-space: nowrap; }
        table td { word-break: break-word; }

        /* Manage Curtailments Table Specifics */
        #manage-curtailments-table th:first-child, #manage-curtailments-table td:first-child { text-align: center; width: 40px; visibility: visible; }
        #manage-curtailments-table input[type="checkbox"] { cursor: pointer; }
        .delete-selected-container { text-align: center; margin-top: 20px; }

        /* Auto TMP Table Specifics */
        #auto-tmp-table th:nth-child(1), #auto-tmp-table td:nth-child(1) { width: 80px; } /* Route */
        #auto-tmp-table th:nth-child(2), #auto-tmp-table td:nth-child(2) { width: 120px; } /* Fleet */
        #auto-tmp-table th:nth-child(3), #auto-tmp-table td:nth-child(3) { width: 120px; } /* Reg */
        #auto-tmp-table th:nth-child(4), #auto-tmp-table td:nth-child(4) { width: 120px; } /* Date Logged - Adjusted width */

        /* Audit Log Styles */
        #admin-audit-log { margin-top: 20px; } #audit-log-display { max-height: 400px; overflow-y: auto; border: 1px solid #eee; padding: 10px; background-color: #fff; font-family: monospace; font-size: 0.85em; text-align: left; line-height: 1.4; } #audit-log-display div { border-bottom: 1px dotted #f0f0f0; padding: 4px 2px; } #audit-log-display div:last-child { border-bottom: none; }
        #audit-log-display .log-timestamp { color: #6c757d; display: inline-block; min-width: 150px;}
        #audit-log-display .log-user { color: #007bff; font-weight: bold; margin: 0 5px;}
        #audit-log-display .log-action { color: #28a745; }
        #audit-log-display .log-details { color: #555; margin-left: 10px; font-size: 0.9em; white-space: pre-wrap; word-break: break-all; display: inline; }
        #audit-log-controls { text-align: right; margin-bottom: 10px; } #clear-audit-log-btn { font-size: 0.8em; padding: 4px 8px; }

        /* --- Auto TMP Table Filter Row Styles --- */
        #auto-tmp-table thead tr.filter-row td {
            background-color: #f4f4f4; /* Light grey background */
            position: sticky;
            top: 30px; /* Adjust based on the height of your main header row */
            z-index: 1;
            padding: 4px 8px;
            vertical-align: top;
            text-align: center;
            border-top: 1px solid #ccc;
        }
        #auto-tmp-table thead tr.filter-row select {
            padding: 3px 5px;
            font-size: 0.9em;
            width: 95%; /* Adjust width as needed */
            max-width: 180px; /* Optional max width */
            box-sizing: border-box;
            margin-top: 2px;
        }
        /* --- End Auto TMP Table Filter Row Styles --- */

    </style>
</head>
<body>
    <div id="login-container" class="login-container">
        <h2>Live Tracker Tools Login</h2>
        <form onsubmit="login(); return false;" autocomplete="off">
             <div class="form-group"> <label for="username">Username:</label> <input type="text" id="username" name="username" required autocomplete="off"> </div>
             <div class="form-group"> <label for="password">Password:</label> <input type="password" id="password" name="password" required autocomplete="off"> </div>
             <div class="form-group-inline"> <input type="checkbox" id="stayLoggedInCheckbox" name="stayLoggedIn"> <label for="stayLoggedInCheckbox">Stay logged in</label> </div>
             <div class="form-group" style="text-align: center;"> <button type="submit" class="blue-button">Login</button> <p id="login-error" style="color: red; margin-top: 10px; min-height: 1em;"></p> </div>
        </form>
    </div>

    <div id="app-container" class="app-container hidden">
        <h1>Live Tracker Tools</h1>
        <p id="welcome-message" class="welcome-message"></p>
        <div id="export-reminder" class="export-reminder-message"></div>

        <div class="security-warning">
            <strong>Security Warning:</strong> This application handles sensitive operations (like password management and user roles) directly in the browser. This is insecure and should be implemented with a proper server-side backend for production use.
        </div>

        <div id="main-actions-container" class="main-actions-container">
             <button id="toggle-add-curtailment" onclick="showSection('add-curtailment-form')" class="blue-button hidden">Add New Curtailment</button>
             <button id="toggle-manual-fleet" onclick="showSection('manual-fleet-form')" class="blue-button hidden">Assign / View Manual Fleet</button>
             <button id="view-all-curtailments-btn" onclick="showSection('manage-curtailments-section')" class="blue-button hidden">View / Manage All Curtailments</button>
             <button id="toggle-backup-restore" onclick="showSection('data-actions')" class="blue-button hidden">Backup &amp; Restore</button>
             <button id="toggle-settings" onclick="showSection('settings-form')" class="blue-button hidden">Settings</button>
        </div>

        <div style="text-align: center; margin-bottom: 20px;">
             <button id="go-back-button" class="blue-button secondary-button hidden" onclick="goBackToMainView()">‚Üê Go Back to Menu</button>
        </div>

        <div id="add-curtailment-form" class="section hidden">
             <h3>Add New Curtailment</h3>
             <div class="form-group"> <label for="route">Route Number:</label> <input type="text" id="route" required placeholder="e.g., 184" autocomplete="off"></div>
             <div class="form-group"> <label for="regNumber">Bus Registration:</label> <input type="text" id="regNumber" required placeholder="e.g., AB12CDE" autocomplete="off"></div>
             <div class="form-group"> <label for="curtailedDestination">Curtailed Destination:</label> <input type="text" id="curtailedDestination" required placeholder="e.g., Arnos Grove Station" autocomplete="off"></div>
             <div class="form-group"> <label for="curtailmentTimeInput">Time Logged (HH:MM):</label> <input type="time" id="curtailmentTimeInput" required autocomplete="off"></div>
             <button type="button" onclick="addCurtailment()" class="blue-button">Add Curtailment</button> <p id="add-curtailment-message" class="status-message" style="color: green;"></p>
        </div>

        <div id="manual-fleet-form" class="section hidden">
             <h3>Assign / View Manual Fleet Number</h3>
             <div class="form-group"> <label for="manualRegNumber">Bus Registration:</label> <input type="text" id="manualRegNumber" placeholder="e.g., AB12CDE" autocomplete="off"></div>
             <div class="form-group"> <label for="manualFleetNumber">Real Fleet Number:</label> <input type="text" id="manualFleetNumber" placeholder="e.g., VH45161, 9001" autocomplete="off"></div>
             <button type="button" onclick="assignManualFleetNumber()" class="blue-button">Assign Fleet Number</button> <p id="assign-status" class="status-message" style="color: green;"></p>

             <div style="margin-top: 25px; padding-top: 15px; border-top: 1px solid #eee; text-align: center;">
                 <button id="view-auto-tmp-btn" type="button" onclick="showSection('view-auto-tmp-section')" class="blue-button">View Auto-Generated Assignments</button>
                 <p class="description-text">View a table of registrations with system-assigned TMP / ERR numbers.</p>
             </div>

             <h4>Current Manual Assignments</h4>
             <div class="filter-controls" style="margin-bottom: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                 <input type="text" id="manual-reg-filter" placeholder="Filter by Registration..." style="flex: 1; min-width: 150px; padding: 5px 8px; margin-bottom: 0; font-size: 0.9em;" oninput="displayManualAssignments()" autocomplete="off">
                 <input type="text" id="manual-fleet-filter" placeholder="Filter by Fleet No..." style="flex: 1; min-width: 150px; padding: 5px 8px; margin-bottom: 0; font-size: 0.9em;" oninput="displayManualAssignments()" autocomplete="off">
             </div>
             <div id="manual-assignments-display">Loading...</div>
             <div class="revert-section hidden">
                  <label for="revertRegNumber">Registration to Revert:</label>
                  <input type="text" id="revertRegNumber" placeholder="e.g., AB12CDE" autocomplete="off">
                  <button type="button" onclick="revertToTMP()" class="danger-button">Revert to Auto TMP</button>
                  <p id="revert-status" class="status-message"></p>
             </div>

             <div class="reset-all-section hidden">
                 <h4>Reset All Assignments (Admin Only)</h4>
                 <button type="button" id="reset-tmp-button" onclick="resetTMPMap()" class="reset-button">Reset ALL TMP Assignments</button>
                 <p class="description-text">Clears the stored Registration -> TMP map. Requires password.</p>
             </div>
        </div>

        <div id="manage-curtailments-section" class="section hidden">
           <h3>View / Manage Curtailments</h3>
           <div id="manage-curtailments-controls" style="text-align: right; margin-bottom: 10px;">
               </div>
           <div class="table-container">
               <table id="manage-curtailments-table">
                   <thead>
                       <tr>
                           <th style="visibility: hidden;"> <input type="checkbox" id="select-all-curtailments-checkbox" class="hidden" onchange="handleSelectAllCurtailments()">
                           </th>
                           <th>Route</th>
                           <th>Fleet</th>
                           <th>Registration</th>
                           <th>Destination</th>
                           <th>Time Logged</th>
                       </tr>
                   </thead>
                   <tbody id="manage-curtailments-tbody">
                       <tr><td colspan="6">Loading...</td></tr>
                   </tbody>
               </table>
           </div>
           <div class="delete-selected-container hidden">
               <button type="button" id="delete-selected-curtailments-btn" onclick="deleteSelectedCurtailments()" class="danger-button hidden">Delete Selected</button>
           </div>
           <p id="manage-curtailments-message" class="status-message"></p>
        </div>

        <div id="view-auto-tmp-section" class="section hidden">
            <h2>Auto-Generated Fleet Assignments (TMP/ERR)</h2>
            <p id="auto-tmp-table-message" class="status-message"></p>
            <div class="table-container">
                <table id="auto-tmp-table">
                     <thead>
                        <tr>
                            <th>Route</th>
                            <th>Fleet (TMP/ERR)</th>
                            <th>Registration</th>
                            <th>Date Logged</th>
                        </tr>
                        <tr class="filter-row">
                            <td><select id="auto-tmp-filter-route" onchange="applyAndSaveAutoTmpFilters()"><option value="">All</option></select></td>
                            <td><select id="auto-tmp-filter-fleet" onchange="applyAndSaveAutoTmpFilters()"><option value="">All</option></select></td>
                            <td><select id="auto-tmp-filter-reg" onchange="applyAndSaveAutoTmpFilters()"><option value="">All</option></select></td>
                            <td><select id="auto-tmp-filter-date" onchange="applyAndSaveAutoTmpFilters()"><option value="">All</option></select></td>
                        </tr>
                    </thead>
                    <tbody id="auto-tmp-tbody">
                        </tbody>
                </table>
            </div>
        </div>

        <div id="settings-form" class="section hidden">
             <h2>Settings</h2>
             <fieldset id="change-my-password-section">
                 <legend>Change My Password</legend>
                 <div class="form-group">
                     <label for="current-password">Current Password:</label>
                     <input type="password" id="current-password" required autocomplete="current-password">
                 </div>
                 <div class="form-group">
                     <label for="new-password">New Password:</label>
                     <input type="password" id="new-password" required autocomplete="new-password">
                 </div>
                 <div class="form-group">
                     <label for="confirm-new-password">Confirm New Password:</label>
                     <input type="password" id="confirm-new-password" required autocomplete="new-password">
                 </div>
                 <button type="button" onclick="changeMyPassword()" class="blue-button">Change Password</button>
                 <p id="change-password-message" class="status-message"></p>
             </fieldset>

             <fieldset id="tracker-settings-section" class="hidden">
                 <legend>Tracker Settings (Admin Only)</legend>
                 <div class="settings-group">
                     <label for="setting-debounce">Curtailment Debounce (Minutes):</label>
                     <input type="number" id="setting-debounce" min="0" step="1" value="60">
                     <p class="description-text" style="text-align:left;">Prevents identical curtailments being logged too quickly (currently NOT IMPLEMENTED in JS logic).</p>
                 </div>
                  <div class="settings-group">
                     <label for="setting-timeout">Action Timeout (Minutes):</label>
                     <input type="number" id="setting-timeout" min="1" step="1" value="30">
                     <p class="description-text" style="text-align:left;">General timeout for actions (currently NOT IMPLEMENTED in JS logic).</p>
                 </div>
                 <div class="settings-group">
                     <label for="setting-auto-logout">Auto Logout (Minutes, 0=disable):</label>
                     <input type="number" id="setting-auto-logout" min="0" step="1" value="30">
                      <p class="description-text" style="text-align:left;">Automatically logs out after inactivity (unless 'Stay logged in' is checked).</p>
                 </div>
                 <button type="button" onclick="saveTrackerSettings()" class="blue-button">Save Tracker Settings</button>
                 <p id="tracker-settings-message" class="status-message"></p>
             </fieldset>

             <fieldset id="admin-user-management" class="hidden">
                 <legend>User Management (Admin Only)</legend>

                 <div class="add-user-form-container">
                     <h4>Add New User</h4>
                     <div class="form-group">
                          <label for="add-username">New Username:</label>
                          <input type="text" id="add-username" autocomplete="off">
                     </div>
                     <div class="form-group">
                          <label for="add-user-password">New Password:</label>
                          <input type="password" id="add-user-password" autocomplete="new-password">
                     </div>
                     <div class="form-group">
                          <label for="add-user-role">Role:</label>
                          <select id="add-user-role">
                              <option value="user" selected>User</option>
                              <option value="moderator">Moderator</option>
                              <option value="admin">Admin</option>
                          </select>
                     </div>
                     <button type="button" onclick="addUser()" class="blue-button">Add User</button>
                     <p id="add-user-message" class="status-message"></p>
                 </div>
                 <h4 style="margin-top: 30px;">Manage Existing Users</h4>
                 <div id="user-list-container" style="overflow-x: auto;">
                     <table id="user-management-table">
                         <thead>
                             <tr>
                                 <th>Username</th>
                                 <th>Role</th>
                                 <th>Status</th>
                                 <th>New Password</th>
                                 <th class="permissions-header">Permissions</th>
                                 <th>Actions</th>
                             </tr>
                         </thead>
                         <tbody id="user-management-tbody"></tbody>
                     </table>
                 </div>
                 <p id="user-management-message" class="status-message"></p>
             </fieldset>

             <fieldset id="admin-audit-log" class="hidden">
                 <legend>Admin Audit Log</legend>
                 <div id="audit-log-controls">
                     <button type="button" id="clear-audit-log-btn" onclick="clearAuditLog()" class="danger-button secondary-button">Clear Log</button>
                 </div>
                 <div id="audit-log-display"><p>Loading audit log...</p></div>
                 <p id="audit-log-message" class="status-message"></p>
             </fieldset>
        </div>

        <div id="data-actions" class="section hidden">
             <h3>Backup &amp; Restore</h3>

             <div class="action-group"> <h4>Export All</h4>
                 <button type="button" id="export-all-data-button" onclick="exportAllData()" class="blue-button" data-role="mod-admin">Export ALL Data</button>
                 <p id="export-all-status" class="status-message"></p>
                 <p class="description-text">Exports all data types (Curtailments, Fleet/TMP, Headings, Destinations) as separate files.</p>
             </div>

             <div class="action-group">
                 <h4>Curtailments</h4>
                 <button type="button" id="export-curtailments-button" onclick="exportCurtailments()" class="blue-button" data-role="mod-admin">Export ALL</button>
                 <button type="button" id="import-curtailments-button" onclick="document.getElementById('import-file-curtailments').click()" class="blue-button" data-role="admin-only">Import ALL</button>
                 <input type="file" id="import-file-curtailments" accept=".json" class="hidden">
                 <p class="description-text">Save/load curtailments. Import REPLACES route data.</p>
                 <p id="curtailments-backup-status" class="status-message"></p>
                 <button type="button" id="prune-curtailments-button" onclick="pruneOldCurtailments()" class="blue-button prune-button" disabled data-role="admin-only">Prune Old Curtailments</button> <p id="prune-status-message" class="status-message"></p>
                 <p class="description-text" id="prune-description-text">Permanently delete curtailment records older than approx. 6 months.</p> </div>
             <div class="action-group">
                 <h4>Fleet / TMP</h4>
                  <button type="button" id="export-tmp-button" onclick="exportTmpMap()" class="blue-button" data-role="mod-admin">Export ALL</button>
                 <button type="button" id="import-tmp-button" onclick="document.getElementById('import-file-tmp').click()" class="blue-button" data-role="admin-only">Import ALL</button>
                 <input type="file" id="import-file-tmp" accept=".json" class="hidden">
                 <p class="description-text">Save/load Reg -> Fleet/TMP map. Import REPLACES map.</p>
                 <p id="tmp-backup-status" class="status-message"></p>
             </div>
             <div class="action-group">
                 <h4>Sequence Headings</h4>
                  <button type="button" id="export-seq-headings-button" onclick="exportSequenceHeadings()" class="blue-button" data-role="mod-admin">Export All</button>
                 <button type="button" id="import-seq-headings-button" onclick="document.getElementById('import-file-seq-headings').click()" class="blue-button" data-role="admin-only">Import All</button>
                 <input type="file" id="import-file-seq-headings" accept=".json" class="hidden">
                 <p class="description-text">Save/load manual Route Sequence Headings. Import REPLACES route data.</p>
                 <p id="seq-headings-backup-status" class="status-message"></p>
             </div>
             <div class="action-group">
                 <h4>Final Destinations</h4>
                  <button type="button" id="export-final-dest-button" onclick="exportFinalDestinations()" class="blue-button" data-role="mod-admin">Export</button>
                 <button type="button" id="import-final-dest-button" onclick="document.getElementById('import-file-final-dest').click()" class="blue-button" data-role="admin-only">Import</button>
                 <input type="file" id="import-file-final-dest" accept=".json" class="hidden">
                 <p class="description-text">Save/load official Final Destinations. Import REPLACES list.</p>
                 <p id="final-dest-backup-status" class="status-message"></p>
             </div>
        </div>


        <div style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px; text-align: center;">
             <button type="button" id="logout-button" onclick="logout()" class="blue-button" style="background-color: #6c757d;">Logout</button>
        </div>
    </div>

    <div id="password-modal" class="modal-overlay hidden">
        <div class="modal-box">
            <h3>Confirm Action</h3>
            <label for="confirm-password" id="password-modal-prompt">Please enter your password to confirm:</label>
            <input type="password" id="confirm-password" name="confirm-password" required autocomplete="new-password">
            <p id="password-modal-error" style="color: red; min-height: 1em; margin-top: 5px;"></p>
            <div class="modal-buttons">
                 <button type="button" onclick="cancelModalAction()" class="blue-button cancel-button">Cancel</button>
                 <button type="button" onclick="handleModalConfirm()" class="blue-button">Confirm</button>
            </div>
        </div>
    </div>

    <script>
    // --- Start of JavaScript ---
console.log("DEBUG: Script execution started. (Tools.html - Fixes v3 + Export All + Roles + Prune Countdown)"); // Version tag updated

// --- Constants ---
const usersStorageKey = 'liveTrackerUsers';
const tmpMapKey = "tmpRegistrationMap";
const settingsKey = "trackerGlobalSettings";
const defaultSettings = { debounceMinutes: 60, timeoutMinutes: 30, autoLogoutMinutes: 30 };
const lastExportKey = 'lastCurtailmentExportTimestamp';
const tmpGenerationInfoKey = "tmpGenerationInfo";
const sequenceHeadingOverrideBaseKey = 'sequenceHeadingOverrides_'; // Needed for export/import
const routeDestinationSettingsKey = 'routeDestinationSettings'; // Needed for export/import
const auditLogKey = 'actionAuditLog';
const MAX_AUDIT_LOG_ENTRIES = 500;
// const autoTmpFilterStateKey = 'autoTmpFilterState_tools'; // REMOVED - Filters no longer saved
const lastCurtailmentPruneTimestampKey = 'lastCurtailmentPruneTimestamp'; // Key for prune button state

// --- Global Variables ---
let users = {};
let isLoggedIn = false;
let currentUsername = null;
let sessionTimerId = null;
let currentAutoTmpData = []; // Holds the full, unfiltered data for the Auto TMP table for cascading filters
let currentModalAction = null; // Tracks the action requiring password confirmation ('resetTMP', 'pruneCurtailments')

// --- Storage Helpers ---
function loadFromStorage(key, defaultValue = {}) {
    // console.log(`DEBUG: loadFromStorage called for key: ${key}`); // Can be verbose
    try {
        const data = localStorage.getItem(key);
        if (data) {
            const parsed = JSON.parse(data);
            if (key === auditLogKey && !Array.isArray(parsed)) { console.warn(`Audit log data for key ${key} is not an array...`); return defaultValue; }
            if ((typeof parsed === typeof defaultValue && parsed !== null) || (Array.isArray(parsed) && Array.isArray(defaultValue))) {
                return parsed;
            } else {
                console.warn(`DEBUG: Data type mismatch or unexpected null for key ${key}. Returning default.`);
                 return defaultValue;
            }
        }
        return defaultValue;
    } catch (e) {
        console.error(`DEBUG: Error loading ${key}:`, e);
        if (key === auditLogKey && Array.isArray(defaultValue)) { return []; }
        return defaultValue;
    }
}
function saveToStorage(key, data) {
    // console.log(`DEBUG: saveToStorage called for key: ${key}`); // Can be verbose
    try {
        const stringifiedData = JSON.stringify(data);
        localStorage.setItem(key, stringifiedData);
    } catch (e) {
        console.error(`DEBUG: Error saving ${key}:`, e);
        if (key !== auditLogKey) {
            alert(`Error saving data for ${key}. Data might be lost.`);
        } else {
             console.error("Could not save audit log entry.");
        }
    }
}
function saveUsersToStorage() {
    console.log("DEBUG: saveUsersToStorage function called.");
    try {
        if (typeof users === 'object' && users !== null) {
            localStorage.setItem(usersStorageKey, JSON.stringify(users));
        } else {
            console.error("DEBUG: Attempted to save non-object as users. Resetting to default.");
            setDefaultUsers();
        }
    } catch (e) {
        console.error("DEBUG: Error saving users:", e);
        alert("Error: Could not save user data.");
    }
}

// --- Audit Log Function ---
function logAdminAction(action, details = {}) {
    console.log(`DEBUG: logAdminAction called - Action: ${action}, User: ${currentUsername}, LoggedIn: ${isLoggedIn}`);
    let effectiveUsername = currentUsername;
    let isActionAllowedWhenLoggedOut = ['Login Failed (Password)', 'Login Failed (Suspended)', 'Login Failed (Unknown User)'].includes(action);
    if (!isLoggedIn && !isActionAllowedWhenLoggedOut) {
        console.warn(`DEBUG: logAdminAction - Skipping log for action '${action}' because user is not logged in.`);
        return;
    }
    if (!isLoggedIn && isActionAllowedWhenLoggedOut) {
        effectiveUsername = currentUsername || details?.targetUser || 'Unknown';
        console.warn(`DEBUG: logAdminAction - Logging failed login attempt for user: ${effectiveUsername}`);
    }
    if (!effectiveUsername) {
        console.warn(`DEBUG: logAdminAction - Skipping log for action '${action}' because effective username could not be determined.`);
        return;
    }
    const userRole = users[effectiveUsername]?.role || 'N/A';
    const alwaysLogActions = ['Login Success', 'Login Failed (Password)', 'Login Failed (Suspended)', 'Login Failed (Unknown User)', 'Logout'];
    const requiresPrivilege = !alwaysLogActions.includes(action);
    if (requiresPrivilege && !['admin', 'moderator'].includes(userRole)) {
       // Allow logging specific non-privileged actions if needed later
        const allowedNonPrivilegedActions = ['Curtailment Added', 'Fleet Assigned']; // Example if needed
        if (!allowedNonPrivilegedActions.includes(action)) {
             console.warn(`DEBUG: logAdminAction - Skipping log for action '${action}' by user '${effectiveUsername}' due to insufficient role ('${userRole}').`);
             return;
         }
    }
    try {
        const timestamp = Date.now();
        const logEntry = {
            timestamp,
            user: effectiveUsername,
            action,
            details: typeof details === 'string' ? { message: details } : details
        };
        let log = loadFromStorage(auditLogKey, []);
        if (!Array.isArray(log)) {
            console.warn("Audit log retrieved from storage was not an array. Resetting log.");
            log = [];
        }
        log.unshift(logEntry);
        if (log.length > MAX_AUDIT_LOG_ENTRIES) {
            log = log.slice(0, MAX_AUDIT_LOG_ENTRIES);
        }
        saveToStorage(auditLogKey, log);
        console.log(`AUDIT: User '${logEntry.user}' - Action: '${action}'`, details);
    } catch (error) {
        console.error("Error writing audit log:", error);
    }
}


// --- DOM Element Refs ---
function getElement(id) {
    const el = document.getElementById(id);
    return el;
}

console.log("DEBUG: Getting DOM refs (Tools.html)");
const loginContainer = getElement('login-container');
const appContainer = getElement('app-container');
const loginError = getElement('login-error');
const welcomeMessageElement = getElement('welcome-message');
const logoutButton = getElement('logout-button');
const exportReminderDiv = getElement('export-reminder');

const mainActionsContainer = getElement('main-actions-container');
const goBackButton = getElement('go-back-button');

// Section containers
const addCurtailmentForm = getElement('add-curtailment-form');
const manualFleetForm = getElement('manual-fleet-form');
const settingsForm = getElement('settings-form');
const dataActionsSection = getElement('data-actions');
const manageCurtailmentsSection = getElement('manage-curtailments-section');
const viewAutoTmpSection = getElement('view-auto-tmp-section');

// Main action buttons
const toggleAddCurtailmentButton = getElement('toggle-add-curtailment');
const toggleManualFleetButton = getElement('toggle-manual-fleet');
const viewAllCurtailmentsButton = getElement('view-all-curtailments-btn');
const toggleBackupRestoreButton = getElement('toggle-backup-restore');
const toggleSettingsButton = getElement('toggle-settings');

// Add Curtailment elements
const addCurtailmentMessage = getElement('add-curtailment-message');
const routeInput = getElement('route');
const regNumberInput = getElement('regNumber');
const curtailedDestinationInput = getElement('curtailedDestination');
const curtailmentTimeInput = getElement('curtailmentTimeInput');

// Manual Fleet elements
const manualRegNumberInput = getElement('manualRegNumber');
const manualFleetNumberInput = getElement('manualFleetNumber');
const assignStatusElement = getElement('assign-status');
const manualAssignmentsDisplay = getElement('manual-assignments-display');
const revertRegNumberInput = getElement('revertRegNumber');
const revertStatusElement = getElement('revert-status');
const revertSection = document.querySelector('#manual-fleet-form .revert-section');
const resetTmpButton = getElement('reset-tmp-button');
const resetAllSection = document.querySelector('#manual-fleet-form .reset-all-section');
const viewAutoTmpBtn = getElement('view-auto-tmp-btn');
const manualRegFilterInput = getElement('manual-reg-filter');
const manualFleetFilterInput = getElement('manual-fleet-filter');

// Manage Curtailments elements
const manageCurtailmentsTableBody = getElement('manage-curtailments-tbody');
const selectAllCheckbox = getElement('select-all-curtailments-checkbox');
const deleteSelectedButton = getElement('delete-selected-curtailments-btn');
const manageCurtailmentsMessage = getElement('manage-curtailments-message');
const deleteSelectedContainer = document.querySelector('.delete-selected-container');

// Auto TMP Table elements
const autoTmpTableBody = getElement('auto-tmp-tbody');
const autoTmpTableMessage = getElement('auto-tmp-table-message');
const autoTmpFilterRoute = getElement('auto-tmp-filter-route');
const autoTmpFilterFleet = getElement('auto-tmp-filter-fleet');
const autoTmpFilterReg = getElement('auto-tmp-filter-reg');
const autoTmpFilterDate = getElement('auto-tmp-filter-date');

// Backup/Restore elements
const exportAllDataButton = getElement('export-all-data-button'); // <-- New Ref
const exportAllStatus = getElement('export-all-status'); // <-- New Ref
const importCurtailmentsInput = getElement('import-file-curtailments');
const curtailmentsBackupStatus = getElement('curtailments-backup-status');
const importTmpInput = getElement('import-file-tmp');
const tmpBackupStatus = getElement('tmp-backup-status');
const importSeqHeadingsInput = getElement('import-file-seq-headings');
const seqHeadingsBackupStatus = getElement('seq-headings-backup-status');
const importFinalDestInput = getElement('import-file-final-dest');
const finalDestBackupStatus = getElement('final-dest-backup-status');
const pruneCurtailmentsButton = getElement('prune-curtailments-button');
const pruneStatusMessage = getElement('prune-status-message');
const pruneDescriptionText = getElement('prune-description-text'); // <-- New Ref

// Settings elements
const changeMyPasswordSection = getElement('change-my-password-section');
const trackerSettingsSection = getElement('tracker-settings-section');
const adminUserManagementSection = getElement('admin-user-management');
const adminAuditLogSection = getElement('admin-audit-log');
const settingsDebounceInput = getElement('setting-debounce');
const settingsTimeoutInput = getElement('setting-timeout');
const settingsAutoLogoutInput = getElement('setting-auto-logout');
const trackerSettingsMessage = getElement('tracker-settings-message');
const currentPasswordInput = getElement('current-password');
const newPasswordInput = getElement('new-password');
const confirmNewPasswordInput = getElement('confirm-new-password');
const changePasswordMessage = getElement('change-password-message');
const addUsernameInput = getElement('add-username');
const addUserPasswordInput = getElement('add-user-password');
const addUserRoleSelect = getElement('add-user-role');
const addUserMessage = getElement('add-user-message');
const userManagementTbody = getElement('user-management-tbody');
const userManagementMessage = getElement('user-management-message');
const auditLogDisplay = getElement('audit-log-display');
const auditLogMessage = getElement('audit-log-message');
const clearAuditLogButton = getElement('clear-audit-log-btn');

// Modals
const passwordModal = getElement('password-modal');
const passwordModalInput = getElement('confirm-password');
const passwordModalError = getElement('password-modal-error');
const passwordModalPrompt = getElement('password-modal-prompt');

console.log("DEBUG: DOM refs obtained (Tools.html).");


// --- Auth, Timer, Basic UI ---
function loadUsers() {
    console.log("DEBUG: loadUsers function called.");
    try {
        const storedData = localStorage.getItem(usersStorageKey);
        if (storedData) {
            let parsedUsers = JSON.parse(storedData);
            if (typeof parsedUsers !== 'object' || parsedUsers === null || Array.isArray(parsedUsers)) {
                console.warn("DEBUG: Invalid user data structure in localStorage. Resetting to default.");
                setDefaultUsers(); return;
            }
            if (!parsedUsers.Ryan?.pass || !parsedUsers.Ryan?.role) {
                console.warn("DEBUG: Resetting users: Incomplete default admin user 'Ryan'.");
                setDefaultUsers(); return;
            }
            let structureUpdated = false;
            Object.keys(parsedUsers).forEach(username => {
                const userData = parsedUsers[username];
                if (typeof userData !== 'object' || userData === null) {
                    console.warn(`DEBUG: Removing invalid user entry for key: ${username}`);
                    delete parsedUsers[username]; structureUpdated = true;
                } else {
                    if (userData.permissions === undefined) { userData.permissions = {}; structureUpdated = true; }
                    if (userData.isSuspended === undefined) { userData.isSuspended = false; structureUpdated = true; }
                    if (typeof userData.pass !== 'string' || typeof userData.role !== 'string') {
                        console.warn(`DEBUG: User data for '${username}' is missing pass or role. Keeping entry but potential issue.`);
                    }
                }
            });
            users = parsedUsers;
            if (structureUpdated) {
                console.log("DEBUG: Saving updated user structure after validation.");
                saveUsersToStorage();
            }
        } else {
            console.log("DEBUG: loadUsers - No user data found in localStorage, setting defaults.");
            setDefaultUsers();
        }
    } catch (e) {
        console.error("DEBUG: Error loading or parsing users:", e);
        console.log("DEBUG: Resetting to default users due to error.");
        setDefaultUsers();
    }
    console.log("DEBUG: loadUsers finished.");
}
function setDefaultUsers() {
    console.log("DEBUG: setDefaultUsers called.");
    users = { 'Ryan': { pass: 'password', role: 'admin', permissions: {}, isSuspended: false } };
    saveUsersToStorage();
    console.log("DEBUG: Default users set and saved.");
}
function checkLogin() {
    console.log("DEBUG: --- checkLogin ---");
    loadUsers();
    try {
        const storedUser = localStorage.getItem('loggedInUser');
        const storedLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
        let isLoginStateValid = false;
        if (storedLoggedIn && storedUser && users && users[storedUser]) {
            if (!users[storedUser].isSuspended) {
                isLoginStateValid = true; console.log(`DEBUG: Valid persistent login found for user: ${storedUser}`);
            } else { console.log(`DEBUG: Persistent login found for suspended user: ${storedUser}. Invalidating session.`); }
        } else { console.log(`DEBUG: No valid persistent login state found. StoredUser: ${storedUser}, StoredLoggedIn: ${storedLoggedIn}`); }

        if (isLoginStateValid) {
            isLoggedIn = true; currentUsername = storedUser; showApp();
        } else {
            console.log("DEBUG: Clearing potentially invalid login state from storage.");
            isLoggedIn = false; currentUsername = null;
            localStorage.removeItem('isLoggedIn'); localStorage.removeItem('loggedInUser');
            sessionStorage.removeItem('bypassAutoLogout'); showLogin();
        }
    } catch (e) {
        console.error("DEBUG: Error during checkLogin:", e);
        isLoggedIn = false; currentUsername = null;
        localStorage.removeItem('isLoggedIn'); localStorage.removeItem('loggedInUser');
        sessionStorage.removeItem('bypassAutoLogout'); showLogin();
    }
    console.log("DEBUG: --- checkLogin finished ---");
}
function login() {
    console.log("DEBUG: --- login ---");
    const usernameInputEl = getElement('username');
    const passwordInputEl = getElement('password');
    const stayLoggedInCheckbox = getElement('stayLoggedInCheckbox');
    const loginErrorEl = getElement('login-error');
    if (!usernameInputEl || !passwordInputEl || !stayLoggedInCheckbox || !loginErrorEl) {
        console.error("DEBUG: Login form elements missing.");
        if (loginErrorEl) loginErrorEl.textContent = 'Login UI error.'; return;
    }
    const usernameInput = usernameInputEl.value.trim();
    const passwordInput = passwordInputEl.value;
    const stayLoggedIn = stayLoggedInCheckbox.checked;
    loginErrorEl.textContent = '';
    if (Object.keys(users).length === 0) {
        console.log("DEBUG: Users object empty, attempting reload.");
        loadUsers();
        if (Object.keys(users).length === 0) {
            loginErrorEl.textContent = 'Login service unavailable. Cannot load users.';
            console.error("DEBUG: Cannot login, users object still empty after reload."); return;
        }
    }
    if (!Object.prototype.hasOwnProperty.call(users, usernameInput)) {
        loginErrorEl.textContent = 'Invalid username or password.';
        const tempUsernameForLog = usernameInput || 'Empty Username';
        logAdminAction("Login Failed (Unknown User)", { targetUser: tempUsernameForLog });
        isLoggedIn = false; currentUsername = null; return;
    }
    const userData = users[usernameInput];
    if (userData.pass === passwordInput) {
        if (userData.isSuspended) {
            loginErrorEl.textContent = 'Account suspended. Please contact an administrator.';
            logAdminAction("Login Failed (Suspended)", { targetUser: usernameInput });
            isLoggedIn = false; currentUsername = null; return;
        }
        console.log(`DEBUG: Login successful for user: ${usernameInput}`);
        isLoggedIn = true; currentUsername = usernameInput;
        logAdminAction("Login Success");
        localStorage.setItem('isLoggedIn', 'true'); localStorage.setItem('loggedInUser', usernameInput);
        if (stayLoggedIn) {
            console.log("DEBUG: Setting bypassAutoLogout flag in sessionStorage.");
            sessionStorage.setItem('bypassAutoLogout', 'true');
        } else {
            console.log("DEBUG: Removing bypassAutoLogout flag from sessionStorage.");
            sessionStorage.removeItem('bypassAutoLogout');
        }
        showApp();
    } else {
        loginErrorEl.textContent = 'Invalid username or password.';
        logAdminAction("Login Failed (Password)", { targetUser: usernameInput });
        isLoggedIn = false; currentUsername = null;
        sessionStorage.removeItem('bypassAutoLogout');
    }
    console.log("DEBUG: --- login finished ---");
}
function logout() {
    console.log("DEBUG: --- logout ---");
    if (isLoggedIn && currentUsername) { logAdminAction("Logout"); }
    else { console.log("DEBUG: Logout called but user was not logged in."); }
    if (sessionTimerId) { clearTimeout(sessionTimerId); sessionTimerId = null; console.log("DEBUG: Session timer cleared."); }
    localStorage.setItem('isLoggedIn', 'false'); localStorage.removeItem('loggedInUser');
    isLoggedIn = false; currentUsername = null;
    sessionStorage.removeItem('bypassAutoLogout');
    console.log("DEBUG: Cleared login state from storage and globals.");
    showLogin();
    console.log("DEBUG: --- logout finished ---");
}
function logoutAfterSession() {
    console.log("DEBUG: --- logoutAfterSession Timer Fired ---");
    if (isLoggedIn) {
        const settings = loadFromStorage(settingsKey, defaultSettings);
        const logoutMinutes = settings.autoLogoutMinutes || defaultSettings.autoLogoutMinutes;
        alert(`Session expired due to inactivity after ${logoutMinutes} minutes. Please log in again.`);
        console.log(`DEBUG: Logging out due to session timeout (${logoutMinutes} min).`);
        logout();
    } else { console.log("DEBUG: Session timer fired, but user already logged out."); }
}
function startSessionTimer() {
    if (sessionTimerId) { clearTimeout(sessionTimerId); sessionTimerId = null; console.log("DEBUG: Cleared existing session timer."); }
    if (!isLoggedIn) { console.log("DEBUG: User not logged in, session timer not started."); return; }
    const bypassAutoLogout = sessionStorage.getItem('bypassAutoLogout') === 'true';
    if (bypassAutoLogout) { console.log("DEBUG: 'Stay logged in' is active, session timer bypassed."); return; }
    const settings = loadFromStorage(settingsKey, defaultSettings);
    let logoutMinutes = defaultSettings.autoLogoutMinutes;
    if (typeof settings.autoLogoutMinutes === 'number' && settings.autoLogoutMinutes >= 0) {
        logoutMinutes = settings.autoLogoutMinutes;
    } else { console.warn(`DEBUG: Invalid autoLogoutMinutes setting (${settings.autoLogoutMinutes}). Using default: ${logoutMinutes}`); }
    if (logoutMinutes <= 0) { console.log("DEBUG: Auto logout is disabled (duration <= 0). Timer not started."); return; }
    const logoutMilliseconds = logoutMinutes * 60 * 1000;
    console.log(`DEBUG: Starting session timer for ${logoutMinutes} minutes (${logoutMilliseconds} ms).`);
    sessionTimerId = setTimeout(logoutAfterSession, logoutMilliseconds);
}

// --- SPA Navigation & UI State ---
function showApp() {
    console.log("DEBUG: --- showApp ---");
    try {
        if (!isLoggedIn || !currentUsername || !users || !users[currentUsername] || users[currentUsername].isSuspended) {
            console.warn("DEBUG: showApp called but login state is invalid or user suspended. Forcing logout.");
            logout(); return;
        }
        const currentUserData = users[currentUsername];
        const userRole = currentUserData.role;
        const isModOrAdmin = ['admin', 'moderator'].includes(userRole);
	const isAdmin = userRole === 'admin';
        console.log(`DEBUG: Showing app for user: ${currentUsername}, Role: ${userRole}`);
        if (loginContainer) loginContainer.classList.add('hidden');
        if (appContainer) appContainer.classList.remove('hidden');

        // *** Welcome message updated - Role removed ***
        if (welcomeMessageElement) { welcomeMessageElement.textContent = `Welcome, ${currentUsername}!`; }

        if (exportReminderDiv) {
            try {
                const lastExportTimestamp = localStorage.getItem(lastExportKey);
                const daysThreshold = 7; const millisecondsInDay = 86400000; const now = Date.now();
                let reminderMessage = ''; let showReminder = false;
                if (lastExportTimestamp) {
                    const lastExportTime = parseInt(lastExportTimestamp, 10);
                    if (!isNaN(lastExportTime)) {
                        const daysSinceExport = Math.floor((now - lastExportTime) / millisecondsInDay);
                        if (daysSinceExport >= daysThreshold) {
                            reminderMessage = `Reminder: Last backup was ${daysSinceExport} days ago. Consider exporting data.`; showReminder = true;
                        }
                    } else {
                        reminderMessage = "Reminder: Could not read last backup time. Consider backing up data."; showReminder = true;
                        localStorage.removeItem(lastExportKey);
                    }
                } else { reminderMessage = "Reminder: No backup detected. Consider performing an initial data export."; showReminder = true; }
                exportReminderDiv.textContent = reminderMessage; exportReminderDiv.style.display = showReminder ? 'block' : 'none';
            } catch (e) { console.error("DEBUG: Error processing export reminder:", e); exportReminderDiv.style.display = 'none'; }
        }
        goBackToMainView(false);
        // Update button visibility based on role
        if (toggleAddCurtailmentButton) toggleAddCurtailmentButton.classList.toggle('hidden', !isModOrAdmin);
        if (toggleManualFleetButton) toggleManualFleetButton.classList.toggle('hidden', !isModOrAdmin);
        if (toggleBackupRestoreButton) toggleBackupRestoreButton.classList.toggle('hidden', !isModOrAdmin);
        if (toggleSettingsButton) toggleSettingsButton.classList.remove('hidden'); // All logged in users see Settings
        if (viewAllCurtailmentsButton) {
            viewAllCurtailmentsButton.classList.remove('hidden'); // All logged in users see View All
            viewAllCurtailmentsButton.textContent = isModOrAdmin ? 'View / Manage Curtailments' : 'View All Curtailments';
        }
        startSessionTimer();
    } catch (e) {
        console.error("DEBUG: Critical error in showApp:", e);
        if (welcomeMessageElement) welcomeMessageElement.textContent = 'Application Error. Please reload.';
        if (!isLoggedIn) { logout(); }
    }
    console.log("DEBUG: --- showApp finished ---");
}
function showLogin() {
    console.log("DEBUG: --- showLogin ---");
    try {
        if (sessionTimerId) { clearTimeout(sessionTimerId); sessionTimerId = null; console.log("DEBUG: Session timer cleared on showing login."); }
        sessionStorage.removeItem('bypassAutoLogout');
        if (loginContainer) loginContainer.classList.remove('hidden');
        if (appContainer) appContainer.classList.add('hidden');
        if (welcomeMessageElement) welcomeMessageElement.textContent = '';
        if (loginError) loginError.textContent = '';
        const usernameInputEl = getElement('username');
        const passwordInputEl = getElement('password');
        const stayLoggedInCheckbox = getElement('stayLoggedInCheckbox');
        if (usernameInputEl) usernameInputEl.value = '';
        if (passwordInputEl) passwordInputEl.value = '';
        if (stayLoggedInCheckbox) stayLoggedInCheckbox.checked = false;
        if (passwordModal) passwordModal.classList.add('hidden');
        if (exportReminderDiv) exportReminderDiv.style.display = 'none';
        goBackToMainView(false);
    } catch (e) {
        console.error("DEBUG: Error during showLogin:", e);
        document.body.innerHTML = '<p style="color:red; padding: 20px;">Error loading login screen. Please refresh the page.</p>';
    }
    console.log("DEBUG: --- showLogin finished ---");
}

/**
 * Updates the disabled state and title for elements within a container based on current user role.
 * Handles 'admin-only' and 'mod-admin' roles specified in data-role attribute.
 * @param {HTMLElement} container - The parent element containing elements with data-role attributes.
 */
 function updateElementRoles(container) {
    if (!container) { console.warn("DEBUG: updateElementRoles - Container not found."); return;}
    if (!isLoggedIn || !currentUsername || !users[currentUsername]) { console.warn("DEBUG: updateElementRoles - Cannot update roles, user not logged in."); return; }

    const userRole = users[currentUsername].role;
    const isAdmin = userRole === 'admin';
    const isModOrAdmin = isAdmin || userRole === 'moderator';
    // console.log(`DEBUG: updateElementRoles - Updating roles within container: ${container.id || container.tagName}, UserRole: ${userRole}`);

    const elements = container.querySelectorAll('[data-role]');

    elements.forEach(el => {
        const requiredRole = el.dataset.role; // 'admin-only', 'mod-admin', etc.
        let hasPermission = false;
        let roleNeededText = ""; // Text for tooltip

        // Determine permission based on role
        if (requiredRole === 'admin-only') {
            hasPermission = isAdmin;
            roleNeededText = "Admin privileges required.";
        } else if (requiredRole === 'mod-admin') {
            hasPermission = isModOrAdmin;
             roleNeededText = "Moderator or Admin privileges required.";
        } else {
             hasPermission = true; // Assume accessible if no specific role defined
        }

        // Apply disabled state and title attributes
        if (['BUTTON', 'INPUT', 'TEXTAREA', 'SELECT'].includes(el.tagName)) {
             // Special handling for prune button - let its specific function handle combined logic
            if (el.id === 'prune-curtailments-button') {
                 updatePruneButtonState(); // This handles role AND time logic for prune button
            } else {
                 // Standard enable/disable based purely on role permission
                 const wasPreviouslyDisabled = el.disabled;
                 el.disabled = !hasPermission;

                 // Update title attribute to explain disabled state IF disabled by role
                 if (!hasPermission) {
                     // Add role requirement to title only if it's not already there (avoid duplication)
                     if (el.title?.includes('privileges required') === false) {
                          el.title = el.title ? `${el.title} (${roleNeededText})` : roleNeededText;
                     }
                 } else {
                      // If permission IS granted, remove role-related part from title if present
                      if (el.title?.includes(" privileges required")) {
                          el.title = el.title.replace(/\s*\([^)]*privileges required\)/g, '').trim();
                          if(el.title === "") el.removeAttribute('title'); // Remove title if empty after stripping
                      }
                 }
            }
        } else if (el.tagName === 'FIELDSET' || el.tagName === 'DIV') {
             // Optionally hide entire divs/fieldsets based on role - currently only disabling controls *within* them
             // el.classList.toggle('hidden', !hasPermission);
        }
    });
    // console.log(`DEBUG: updateElementRoles - Finished updating roles within ${container.id || container.tagName}`);
 }


function showSection(sectionId) {
    console.log(`DEBUG: --- showSection called for sectionId: ${sectionId} ---`);
    console.log(`DEBUG: showSection - isLoggedIn: ${isLoggedIn}, currentUsername: ${currentUsername}`);
    if (!isLoggedIn || !currentUsername || !users[currentUsername]) {
        console.warn("DEBUG: showSection called but user not logged in or user data missing. Redirecting to login.");
        alert('Session expired or invalid. Please log in again.'); logout(); return;
    }
    if (users[currentUsername].isSuspended) {
        console.warn(`DEBUG: showSection called by suspended user: ${currentUsername}. Access denied.`);
        alert('Your account is suspended. Access denied.'); logout(); return;
    }
    const currentUserData = users[currentUsername];
    const userRole = currentUserData.role;
    const isModOrAdmin = ['admin', 'moderator'].includes(userRole);
    const isAdmin = userRole === 'admin';
    console.log(`DEBUG: showSection - Checking User: ${currentUsername}, Role: ${userRole}, isModOrAdmin: ${isModOrAdmin}, isAdmin: ${isAdmin}`);
    const sectionElement = getElement(sectionId);
    if (!sectionElement) {
        console.error(`DEBUG: Section element with ID '${sectionId}' not found.`);
        alert(`Error: Could not find the requested section (${sectionId}).`);
        goBackToMainView(); return;
    }

    // Define sections and their access requirements
    const sectionAccessRules = {
        'manage-curtailments-section': () => true, // All logged-in users
        'view-auto-tmp-section': () => true, // All logged-in users
        'add-curtailment-form': () => isModOrAdmin,
        'manual-fleet-form': () => isModOrAdmin,
        'data-actions': () => isModOrAdmin, // Backup/Restore main section visible to Mods/Admins
        'settings-form': () => true // All logged-in users
    };

    let canAccess = false;
    if (sectionAccessRules.hasOwnProperty(sectionId)) {
        canAccess = sectionAccessRules[sectionId](); // Execute the access check function
        console.log(`DEBUG: showSection - Access check for ${sectionId}: Allowed = ${canAccess}`);
    } else {
        console.warn(`DEBUG: Attempted to navigate to unknown sectionId "${sectionId}".`);
        alert(`Error: Unknown section '${sectionId}'.`); goBackToMainView(); return;
    }

    if (!canAccess) {
        alert('Access Denied. You do not have permission to view this section.');
        console.warn(`DEBUG: showSection access DENIED for user '${currentUsername}' (Role: ${userRole}) to section '${sectionId}'.`);
        goBackToMainView(); return;
    }

    console.log(`DEBUG: Access granted. Hiding main menu, showing section '${sectionId}' and back button.`);
    if (mainActionsContainer) mainActionsContainer.classList.add('hidden');

    // Hide all potentially visible sections first
    [addCurtailmentForm, manualFleetForm, settingsForm, dataActionsSection, manageCurtailmentsSection, viewAutoTmpSection].forEach(sec => {
        if (sec) sec.classList.add('hidden');
    });

    sectionElement.classList.remove('hidden'); // Show the target section
    if (goBackButton) goBackButton.classList.remove('hidden'); // Show the 'Go Back' button

    // *** Update element roles/disabled states WITHIN the shown section ***
    updateElementRoles(sectionElement);


    console.log(`DEBUG: Initialising content for section ${sectionId}.`);
    // Clear status messages in all relevant sections
    const statusMessages = [
        addCurtailmentMessage, assignStatusElement, revertStatusElement,
        manageCurtailmentsMessage, autoTmpTableMessage,
        curtailmentsBackupStatus, tmpBackupStatus, seqHeadingsBackupStatus, finalDestBackupStatus, pruneStatusMessage, exportAllStatus, // Added prune/exportall msg
        trackerSettingsMessage, changePasswordMessage, addUserMessage, userManagementMessage, auditLogMessage
    ];
    statusMessages.forEach(el => { if (el) el.textContent = ''; });

    try { // Perform section-specific initialization
        switch (sectionId) {
            case 'add-curtailment-form':
                if (routeInput) routeInput.focus(); if (routeInput) routeInput.value = ''; if (regNumberInput) regNumberInput.value = ''; if (curtailedDestinationInput) curtailedDestinationInput.value = ''; if (curtailmentTimeInput) curtailmentTimeInput.value = ''; break;
            case 'manual-fleet-form':
                displayManualAssignments(); if (manualRegNumberInput) manualRegNumberInput.value = ''; if (manualFleetNumberInput) manualFleetNumberInput.value = ''; if (revertRegNumberInput) revertRegNumberInput.value = '';
                 // Role check for sub-sections already handled by updateElementRoles called above
                break;
            case 'manage-curtailments-section': populateManageCurtailmentsTable(); break;
            case 'view-auto-tmp-section':
                 // Reset filters when section is shown by re-populating
                 populateAutoTmpTable();
                 break;
            case 'data-actions':
                 if (importCurtailmentsInput) importCurtailmentsInput.value = '';
                 if (importTmpInput) importTmpInput.value = '';
                 if (importSeqHeadingsInput) importSeqHeadingsInput.value = '';
                 if (importFinalDestInput) importFinalDestInput.value = '';
                 // updatePruneButtonState() is now called within updateElementRoles for this section
                 break;
            case 'settings-form':
                 // Always show Change Password section
                if (changeMyPasswordSection) {
                    changeMyPasswordSection.classList.remove('hidden');
                    if (currentPasswordInput) currentPasswordInput.value = '';
                    if (newPasswordInput) newPasswordInput.value = '';
                    if (confirmNewPasswordInput) confirmNewPasswordInput.value = '';
                }
                // *** Explicitly show/hide admin fieldsets based on isAdmin ***
                if (trackerSettingsSection) trackerSettingsSection.classList.toggle('hidden', !isAdmin);
                if (adminUserManagementSection) adminUserManagementSection.classList.toggle('hidden', !isAdmin);
                if (adminAuditLogSection) adminAuditLogSection.classList.toggle('hidden', !isAdmin);

                 // If admin, load the data for those sections
                if (isAdmin) {
                    console.log("DEBUG: Loading admin settings data.");
                    loadTrackerSettings();
                    displayUserManagement();
                    displayAuditLog();
                    if (addUsernameInput) addUsernameInput.value = '';
                    if (addUserPasswordInput) addUserPasswordInput.value = '';
                    if (addUserRoleSelect) addUserRoleSelect.value = 'user';
                }
                 // updateElementRoles(sectionElement); // Called at the top now
                 break;
        }
    } catch (initError) { console.error(`DEBUG: Error initializing section ${sectionId}:`, initError); alert(`An error occurred while loading the ${sectionId} section. Please try again or contact support.`); goBackToMainView(); }
    console.log(`DEBUG: --- showSection for ${sectionId} finished successfully ---`);
}

function goBackToMainView(logAction = true) {
    if (logAction) { console.log("DEBUG: goBackToMainView called."); }
    [addCurtailmentForm, manualFleetForm, settingsForm, dataActionsSection, manageCurtailmentsSection, viewAutoTmpSection, goBackButton].forEach(sec => {
        if (sec) sec.classList.add('hidden');
    });
    if (mainActionsContainer) mainActionsContainer.classList.remove('hidden');
    const statusMessages = [ addCurtailmentMessage, assignStatusElement, revertStatusElement, manageCurtailmentsMessage, autoTmpTableMessage, curtailmentsBackupStatus, tmpBackupStatus, seqHeadingsBackupStatus, finalDestBackupStatus, pruneStatusMessage, exportAllStatus, trackerSettingsMessage, changePasswordMessage, addUserMessage, userManagementMessage, auditLogMessage ]; // Added prune/exportall msg
    statusMessages.forEach(el => { if (el) el.textContent = ''; });
    if (logAction) { console.log("DEBUG: Returned to main menu view."); }
}

// --- Curtailment Functions ---
function addCurtailment() {
    console.log("DEBUG: addCurtailment called.");
    if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) { alert('Access Denied.'); console.warn(`DEBUG: addCurtailment denied for user '${currentUsername}'.`); return; }
    if (!routeInput || !regNumberInput || !curtailedDestinationInput || !curtailmentTimeInput || !addCurtailmentMessage) { alert('Error: Could not find necessary form elements.'); console.error("DEBUG: addCurtailment missing required DOM elements."); return; }
    const route = routeInput.value.trim().toUpperCase(); const regNumber = regNumberInput.value.trim().toUpperCase();
    const destination = curtailedDestinationInput.value.trim(); const timeString = curtailmentTimeInput.value.trim();
    addCurtailmentMessage.textContent = '';
    if (!route || !regNumber || !destination || !timeString) { alert('Please fill in all fields: Route, Registration, Destination, and Time.'); addCurtailmentMessage.textContent = 'All fields are required.'; addCurtailmentMessage.style.color = 'red'; return; }
    let logDate = new Date(); const timeParts = timeString.match(/^(\d{2}):(\d{2})$/);
    if (timeParts) {
        const hours = parseInt(timeParts[1], 10); const minutes = parseInt(timeParts[2], 10);
        if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) { logDate.setHours(hours, minutes, 0, 0); }
        else { alert('Invalid Time.'); addCurtailmentMessage.textContent = 'Invalid time format.'; addCurtailmentMessage.style.color = 'red'; return; }
    } else { alert('Invalid Time Format.'); addCurtailmentMessage.textContent = 'Invalid time format (HH:MM).'; addCurtailmentMessage.style.color = 'red'; return; }
    const storageKey = `curtailedBusesArray_${route}`;
    const newEntry = { route: route, regNumber: regNumber, curtailedDestination: destination, curtailmentTime: logDate.toLocaleString('en-GB', {}), timestamp: logDate.getTime() };
    try {
        let curtailments = loadFromStorage(storageKey, []); if (!Array.isArray(curtailments)) { console.warn(`DEBUG: Data for key ${storageKey} was not an array. Resetting.`); curtailments = []; }
        curtailments.push(newEntry); saveToStorage(storageKey, curtailments);
        logAdminAction("Curtailment Added", { route: route, reg: regNumber, dest: destination, time: newEntry.curtailmentTime });
        addCurtailmentMessage.textContent = `Curtailment for ${regNumber} on route ${route} added successfully!`; addCurtailmentMessage.style.color = 'green';
        routeInput.value = ''; regNumberInput.value = ''; curtailedDestinationInput.value = ''; curtailmentTimeInput.value = ''; routeInput.focus();
        setTimeout(() => { if (addCurtailmentMessage) addCurtailmentMessage.textContent = ''; }, 3000);
    } catch (e) { console.error("DEBUG: Error saving curtailment:", e); alert('An error occurred while saving the curtailment.'); addCurtailmentMessage.textContent = 'Error saving curtailment.'; addCurtailmentMessage.style.color = 'red'; }
}

// --- End of Section 1 ---
// --- Start of Section 2 ---

function populateManageCurtailmentsTable() {
    console.log("DEBUG: populateManageCurtailmentsTable called.");
    if (!isLoggedIn || !manageCurtailmentsTableBody) { console.warn("DEBUG: Cannot populate curtailments table - not logged in or table body missing."); if (manageCurtailmentsTableBody) manageCurtailmentsTableBody.innerHTML = '<tr><td colspan="6">Error: Table cannot be loaded.</td></tr>'; return; }
    manageCurtailmentsTableBody.innerHTML = '<tr><td colspan="6">Loading curtailment data...</td></tr>';
    if (manageCurtailmentsMessage) manageCurtailmentsMessage.textContent = '';
    setTimeout(() => {
        try {
            let allCurtailmentEntries = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith("curtailedBusesArray_")) {
                    const routeData = loadFromStorage(key, []);
                    if (Array.isArray(routeData)) {
                        routeData.forEach(item => {
                            if (item && typeof item === 'object' && item.regNumber) {
                                // Ensure timestamp is valid number
                                if (typeof item.timestamp !== 'number' || item.timestamp <= 0) {
                                    try {
                                        if (item.curtailmentTime) { // Attempt to parse from old string format
                                            const parts = item.curtailmentTime.match(/(\d{2})\/(\d{2})\/(\d{4}),?\s*(\d{2}):(\d{2})/);
                                            item.timestamp = parts ? new Date(Date.UTC(parts[3], parts[2] - 1, parts[1], parts[4], parts[5])).getTime() : (Date.parse(item.curtailmentTime) || 0);
                                        } else { item.timestamp = 0; }
                                        if(isNaN(item.timestamp)) item.timestamp = 0; // Ensure it's a number or 0
                                    } catch (parseError) { console.warn(`Error parsing date for curtailment item:`, item, parseError); item.timestamp = 0; }
                                }
                                // Add only if timestamp is valid
                                if (typeof item.timestamp === 'number' && item.timestamp > 0) { allCurtailmentEntries.push({ ...item, originalKey: key }); }
                                else { console.warn("Skipping curtailment entry due to invalid/missing timestamp:", item); }
                            } else { console.warn("Skipping invalid curtailment entry:", item); }
                        });
                    } else { console.warn(`DEBUG: Data for key ${key} was not an array.`); }
                }
            }
            allCurtailmentEntries.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); // Sort newest first, handle potential nulls
            let tableHtml = ''; const canManage = ['admin', 'moderator'].includes(users[currentUsername]?.role);
            const escapeHtml = (unsafe) => { if (unsafe === null || typeof unsafe === 'undefined') return 'N/A'; return String(unsafe).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); };
            if (allCurtailmentEntries.length === 0) { tableHtml = '<tr><td colspan="6">No curtailments recorded.</td></tr>'; }
            else {
                allCurtailmentEntries.forEach(item => {
                    const displayTime = item.timestamp ? new Date(item.timestamp).toLocaleString('en-GB', {}) : 'Invalid Date';
                    let fleetNumber = 'N/A'; if (typeof getTMPForRegistration === 'function') { fleetNumber = getTMPForRegistration(item.regNumber); }
                    const checkboxCell = canManage ? `<td><input type="checkbox" class="curtailment-checkbox" data-key="${escapeHtml(item.originalKey)}" data-timestamp="${item.timestamp}"></td>` : '<td></td>';
                    tableHtml += `<tr>${checkboxCell}<td>${escapeHtml(item.route)}</td><td>${escapeHtml(fleetNumber)}</td><td>${escapeHtml(item.regNumber)}</td><td>${escapeHtml(item.curtailedDestination)}</td><td>${escapeHtml(displayTime)}</td></tr>`;
                });
            }
            manageCurtailmentsTableBody.innerHTML = tableHtml;
            const showManagementControls = canManage && allCurtailmentEntries.length > 0;
            if (selectAllCheckbox) { selectAllCheckbox.classList.toggle('hidden', !showManagementControls); selectAllCheckbox.checked = false; selectAllCheckbox.disabled = !showManagementControls; const headerCell = selectAllCheckbox.closest('th'); if (headerCell) headerCell.style.visibility = showManagementControls ? 'visible' : 'hidden'; }
            if (deleteSelectedButton) { deleteSelectedButton.classList.toggle('hidden', !showManagementControls); deleteSelectedButton.disabled = !showManagementControls; }
            if (deleteSelectedContainer) { deleteSelectedContainer.classList.toggle('hidden', !showManagementControls); }
            manageCurtailmentsTableBody.querySelectorAll('tr td:first-child').forEach(td => { td.style.visibility = canManage ? 'visible' : 'hidden'; });
        } catch (e) { console.error("DEBUG: Error populating curtailments table:", e); manageCurtailmentsTableBody.innerHTML = '<tr><td colspan="6" style="color:red;">Error loading curtailment data. Please try again.</td></tr>'; }
    }, 10);
}
function handleSelectAllCurtailments() { if (!selectAllCheckbox || !manageCurtailmentsTableBody) { console.warn("DEBUG: Cannot handle select all - checkbox or table body missing."); return; } const isChecked = selectAllCheckbox.checked; const checkboxes = manageCurtailmentsTableBody.querySelectorAll('.curtailment-checkbox'); checkboxes.forEach(cb => { if (!cb.disabled) { cb.checked = isChecked; } }); console.log(`DEBUG: Set all curtailment checkboxes to ${isChecked}.`); }
function deleteSelectedCurtailments() {
    console.log("DEBUG: deleteSelectedCurtailments called.");
    if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) { alert('Access Denied.'); console.warn(`DEBUG: deleteSelectedCurtailments denied for user '${currentUsername}'.`); return; }
    if (!manageCurtailmentsTableBody || !manageCurtailmentsMessage) { alert("Error: Cannot perform deletion - UI elements missing."); console.error("DEBUG: deleteSelectedCurtailments missing table body or message element."); return; }
    const selectedCheckboxes = manageCurtailmentsTableBody.querySelectorAll('.curtailment-checkbox:checked');
    if (selectedCheckboxes.length === 0) { alert("No curtailments selected for deletion."); return; }
    if (!confirm(`Are you sure you want to permanently delete the ${selectedCheckboxes.length} selected curtailment entries? This action cannot be undone.`)) { console.log("DEBUG: Deletion cancelled by user."); return; }
    manageCurtailmentsMessage.textContent = 'Deleting selected entries...'; manageCurtailmentsMessage.style.color = 'orange';
    let deletedCount = 0; let errorOccurred = false; const entriesToDelete = {};
    selectedCheckboxes.forEach(cb => { const key = cb.dataset.key; const timestamp = parseInt(cb.dataset.timestamp, 10); if (key && !isNaN(timestamp)) { if (!entriesToDelete[key]) { entriesToDelete[key] = new Set(); } entriesToDelete[key].add(timestamp); } else { console.warn("DEBUG: Skipping checkbox with invalid data:", cb.dataset); errorOccurred = true; } });
    try {
        for (const key in entriesToDelete) {
            if (Object.prototype.hasOwnProperty.call(entriesToDelete, key)) {
                const timestampsToDelete = entriesToDelete[key]; let data = loadFromStorage(key, []);
                if (!Array.isArray(data)) { console.error(`DEBUG: Data for key ${key} is not an array.`); errorOccurred = true; continue; }
                const initialLength = data.length;
                const updatedData = data.filter(item => !(typeof item.timestamp === 'number' && timestampsToDelete.has(item.timestamp)));
                const numDeletedForKey = initialLength - updatedData.length;
                if (numDeletedForKey > 0) { if (updatedData.length === 0) { console.log(`DEBUG: Removing empty storage key: ${key}`); localStorage.removeItem(key); } else { saveToStorage(key, updatedData); } deletedCount += numDeletedForKey; console.log(`DEBUG: Deleted ${numDeletedForKey} entries from key ${key}.`); }
                else if (numDeletedForKey < 0) { console.error(`DEBUG: Negative deletion count for key ${key}.`); errorOccurred = true; }
            }
        }
        if (deletedCount > 0) { logAdminAction("Curtailments Deleted", { count: deletedCount }); }
        if (errorOccurred) { manageCurtailmentsMessage.textContent = `Deletion completed with errors. ${deletedCount} entries removed. Check console log.`; manageCurtailmentsMessage.style.color = 'red'; }
        else { manageCurtailmentsMessage.textContent = `Successfully deleted ${deletedCount} curtailment(s).`; manageCurtailmentsMessage.style.color = 'green'; }
        populateManageCurtailmentsTable(); // Refresh table after deletion
    } catch (e) { console.error("DEBUG: Error during curtailment deletion process:", e); manageCurtailmentsMessage.textContent = 'An unexpected error occurred during deletion.'; manageCurtailmentsMessage.style.color = 'red'; errorOccurred = true; }
    finally { setTimeout(() => { if (manageCurtailmentsMessage) manageCurtailmentsMessage.textContent = ''; }, 5000); if (selectAllCheckbox) selectAllCheckbox.checked = false; }
}

// --- Manual Fleet Functions ---
function displayManualAssignments() {
    console.log("DEBUG: displayManualAssignments called.");
    if (!manualAssignmentsDisplay || !manualRegFilterInput || !manualFleetFilterInput) { console.error("DEBUG: Missing elements required for displayManualAssignments."); if (manualAssignmentsDisplay) manualAssignmentsDisplay.innerHTML = '<p style="color: red;">Error: UI components missing.</p>'; return; }
    if (!isLoggedIn) { manualAssignmentsDisplay.innerHTML = '<p>Please log in to view assignments.</p>'; return; }
    const regFilter = manualRegFilterInput.value.trim().toUpperCase(); const fleetFilter = manualFleetFilterInput.value.trim().toUpperCase();
    manualAssignmentsDisplay.innerHTML = 'Loading...';
    try {
        const tmpMap = loadFromStorage(tmpMapKey, {}); let manualEntries = [];
        if (typeof tmpMap === 'object' && tmpMap !== null) {
            for (const registration in tmpMap) { if (Object.prototype.hasOwnProperty.call(tmpMap, registration)) { const fleetNumber = tmpMap[registration]; if (typeof fleetNumber === 'string' && !fleetNumber.startsWith('TMP') && !fleetNumber.startsWith('ERR')) { manualEntries.push({ reg: registration, fleet: fleetNumber }); } } }
        } else { console.warn("DEBUG: TMP map data retrieved from storage is invalid."); manualAssignmentsDisplay.innerHTML = '<p style="color: red;">Error: Could not load assignment data.</p>'; return; }
        const filteredEntries = manualEntries.filter(entry => { const regMatch = !regFilter || (entry.reg || '').toUpperCase().includes(regFilter); const fleetMatch = !fleetFilter || (entry.fleet || '').toUpperCase().includes(fleetFilter); return regMatch && fleetMatch; });
        filteredEntries.sort((a, b) => (a.fleet || '').localeCompare(b.fleet || '', undefined, { numeric: true, sensitivity: 'base' }));
        if (filteredEntries.length === 0) { if (manualEntries.length === 0) { manualAssignmentsDisplay.innerHTML = '<p>No manual fleet assignments found.</p>'; } else { manualAssignmentsDisplay.innerHTML = '<p>No assignments match the current filter.</p>'; } }
        else { let html = ''; filteredEntries.forEach(entry => { const safeFleet = entry.fleet.replace(/</g, "&lt;").replace(/>/g, "&gt;"); const safeReg = entry.reg.replace(/</g, "&lt;").replace(/>/g, "&gt;"); html += `<div><strong>${safeFleet}:</strong> ${safeReg}</div>`; }); manualAssignmentsDisplay.innerHTML = html; }
    } catch (e) { console.error("DEBUG: Error displaying manual assignments:", e); manualAssignmentsDisplay.innerHTML = '<p style="color: red;">An error occurred while loading assignments.</p>'; }
}
function assignManualFleetNumber() {
    console.log("DEBUG: assignManualFleetNumber called.");
    if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) { alert('Access Denied.'); console.warn(`DEBUG: assignManualFleetNumber denied for user '${currentUsername}'.`); return; }
    if (!manualRegNumberInput || !manualFleetNumberInput || !assignStatusElement) { alert('Error: Could not find necessary form elements.'); console.error("DEBUG: assignManualFleetNumber missing required DOM elements."); return; }
    const registration = manualRegNumberInput.value.trim().toUpperCase(); const fleetNumber = manualFleetNumberInput.value.trim();
    assignStatusElement.textContent = '';
    if (!registration || !fleetNumber) { alert('Please provide both Bus Registration and Real Fleet Number.'); assignStatusElement.textContent = 'Both fields are required.'; assignStatusElement.style.color = 'red'; return; }
    if (fleetNumber.startsWith('TMP') || fleetNumber.startsWith('ERR')) { if (!confirm(`The fleet number "${fleetNumber}" looks like an automatically generated number. Are you sure you want to assign this manually?`)) { console.log("DEBUG: Manual assignment of TMP/ERR cancelled by user."); return; } }
    try {
        let tmpMap = loadFromStorage(tmpMapKey, {}); if (typeof tmpMap !== 'object' || tmpMap === null) { console.warn("DEBUG: TMP map data invalid, resetting to empty object."); tmpMap = {}; }
        const previousValue = tmpMap[registration];
        if (previousValue === fleetNumber) { assignStatusElement.textContent = `No change: ${registration} is already assigned to ${fleetNumber}.`; assignStatusElement.style.color = 'orange'; setTimeout(() => { if (assignStatusElement) assignStatusElement.textContent = ''; }, 4000); return; }
        tmpMap[registration] = fleetNumber; saveToStorage(tmpMapKey, tmpMap);
        logAdminAction("Fleet Assigned", { reg: registration, fleet: fleetNumber, previous: previousValue || 'N/A' });
        assignStatusElement.textContent = `Successfully assigned Fleet Number ${fleetNumber} to Registration ${registration}.`; assignStatusElement.style.color = 'green';
        manualRegNumberInput.value = ''; manualFleetNumberInput.value = ''; displayManualAssignments(); manualRegNumberInput.focus();
        setTimeout(() => { if (assignStatusElement) assignStatusElement.textContent = ''; }, 4000);
    } catch (err) { console.error("DEBUG: Error assigning manual fleet number:", err); alert(`An error occurred: ${err.message}`); assignStatusElement.textContent = `Error saving assignment: ${err.message}`; assignStatusElement.style.color = 'red'; }
}
function getTMPForRegistration(registration) {
    if (!registration || typeof registration !== 'string' || registration.trim() === '') { return 'TMP????'; }
    const cleanReg = registration.trim().toUpperCase();
    try {
        let tmpMap = loadFromStorage(tmpMapKey, {}); if (typeof tmpMap !== 'object' || tmpMap === null) { console.warn("DEBUG: Invalid tmpMap loaded in getTMPForRegistration. Resetting."); tmpMap = {}; }
        if (Object.prototype.hasOwnProperty.call(tmpMap, cleanReg)) { return tmpMap[cleanReg]; }
        let attempt = 0; const maxAttempts = 100; let uniqueTMP = null; let generatedValue;
        while (uniqueTMP === null && attempt < maxAttempts) { const inputForHash = attempt === 0 ? cleanReg : `${cleanReg}_${attempt}`; generatedValue = generateTMPNumber(inputForHash); if (!isTMPValueUsed(tmpMap, generatedValue, cleanReg)) { uniqueTMP = generatedValue; } else { attempt++; } }
        let finalValueToAssign;
        if (uniqueTMP !== null) { finalValueToAssign = uniqueTMP; }
        else { console.warn(`DEBUG: Max TMP generation attempts reached for ${cleanReg}. Assigning fallback ERR number.`); finalValueToAssign = `ERR${Math.floor(1000 + Math.random() * 9000)}`; if (isTMPValueUsed(tmpMap, finalValueToAssign, cleanReg)) { finalValueToAssign = `ERR${Math.floor(1000 + Math.random() * 9000)}`; } }
        tmpMap[cleanReg] = finalValueToAssign; saveToStorage(tmpMapKey, tmpMap);
        try { let generationInfo = loadFromStorage(tmpGenerationInfoKey, {}); if (typeof generationInfo !== 'object' || generationInfo === null) { generationInfo = {}; } generationInfo[cleanReg] = { type: finalValueToAssign.startsWith('TMP') ? 'TMP' : 'ERR', timestamp: Date.now() }; saveToStorage(tmpGenerationInfoKey, generationInfo); } catch (e) { console.error("Error saving TMP generation info:", e); }
        return finalValueToAssign;
    } catch (e) { console.error(`DEBUG: Error in getTMPForRegistration for '${cleanReg}':`, e); return 'ERR????'; }
}
/* jshint bitwise: false */ function generateTMPNumber(reg) { const s = 12345, c = reg + s.toString(); let h = 0; if (c.length === 0) return "TMP0000"; for (let i = 0; i < c.length; i++) { const t = c.charCodeAt(i); h = ((h << 5) - h) + t; h |= 0; } return `TMP${Math.abs(h % 10000).toString().padStart(4, "0")}`; } /* jshint bitwise: true */
function isTMPValueUsed(map, val, currReg) { for (const r in map) { if (Object.prototype.hasOwnProperty.call(map, r) && r !== currReg && map[r] === val) { return true; } } return false; }
function revertToTMP() { if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin Denied.'); return; } if (!revertRegNumberInput || !revertStatusElement) return; const reg = revertRegNumberInput.value.trim().toUpperCase(); if (revertStatusElement) revertStatusElement.textContent = ''; if (!reg) { alert("Enter Reg."); return; } let map = loadFromStorage(tmpMapKey, {}); if (typeof map !== 'object' || map === null) map = {}; if (!Object.prototype.hasOwnProperty.call(map, reg)) { if (revertStatusElement) { revertStatusElement.textContent = `${reg} not found.`; setTimeout(() => revertStatusElement.textContent = '', 4000); } return; } const current = map[reg]; if (typeof current === 'string' && (current.startsWith('TMP') || current.startsWith('ERR'))) { if (revertStatusElement) { revertStatusElement.textContent = `${reg} already auto.`; setTimeout(() => revertStatusElement.textContent = '', 4000); } return; } if (confirm(`Remove manual fleet for ${reg}?`)) { try { const removed = map[reg]; delete map[reg]; saveToStorage(tmpMapKey, map); logAdminAction("Fleet Reverted", { reg, removedValue: removed }); if (revertStatusElement) { revertStatusElement.textContent = `Manual removed.`; revertStatusElement.style.color = 'green'; } if (revertRegNumberInput) revertRegNumberInput.value = ''; displayManualAssignments(); setTimeout(() => revertStatusElement.textContent = '', 4000); } catch (err) { if (revertStatusElement) { revertStatusElement.textContent = `Error: ${err.message}`; revertStatusElement.style.color = 'red'; } } } }

// --- Auto TMP Table Population & Filtering (Cascading Filters) ---

/**
 * Populates the Auto TMP table with data, sorts it, stores it globally,
 * then updates filters and applies them.
 */
function populateAutoTmpTable() {
    console.log("DEBUG: populateAutoTmpTable called.");
    if (!isLoggedIn || !autoTmpTableBody) {
        console.warn("DEBUG: Cannot populate auto TMP table - not logged in or table body missing.");
        if (autoTmpTableBody) autoTmpTableBody.innerHTML = '<tr><td colspan="4">Error: Table cannot be loaded.</td></tr>'; // Colspan 4 now
        return;
    }

    autoTmpTableBody.innerHTML = '<tr><td colspan="4">Loading auto-generated assignments...</td></tr>'; // Colspan 4 now
    if (autoTmpTableMessage) autoTmpTableMessage.textContent = '';
    currentAutoTmpData = []; // Clear previous full dataset

    setTimeout(() => { // Allow UI update
        try {
            const tmpMap = loadFromStorage(tmpMapKey, {});
            const infoMap = loadFromStorage(tmpGenerationInfoKey, {});
            let rawEntries = [];

            if (typeof tmpMap === 'object' && tmpMap !== null) {
                for (const registration in tmpMap) {
                    if (Object.prototype.hasOwnProperty.call(tmpMap, registration)) {
                        const fleetValue = tmpMap[registration];
                        if (typeof fleetValue === 'string' && (fleetValue.startsWith('TMP') || fleetValue.startsWith('ERR'))) {
                            const info = infoMap[registration] || {};
                            const entryTimestamp = info.timestamp || 0;
                            const displayDate = entryTimestamp ? new Date(entryTimestamp).toLocaleDateString('en-GB') : 'N/A'; // DD/MM/YYYY

                            rawEntries.push({
                                registration: registration,
                                fleet: fleetValue,
                                route: info.route || 'N/A',
                                timestamp: entryTimestamp,
                                displayDate: displayDate // Store formatted date
                            });
                        }
                    }
                }
            } else {
                throw new Error("Could not load TMP map data.");
            }

            // Sort the full dataset: Primary: Fleet (numeric asc), Secondary: Reg (alpha asc)
            rawEntries.sort((a, b) => {
                const fleetA = a.fleet || '';
                const fleetB = b.fleet || '';
                const numA = parseInt(fleetA.replace(/[^0-9]/g, ''), 10);
                const numB = parseInt(fleetB.replace(/[^0-9]/g, ''), 10);
                const valA = isNaN(numA) ? Infinity : numA;
                const valB = isNaN(numB) ? Infinity : numB;

                if (valA !== valB) return valA - valB;
                return (a.registration || '').localeCompare(b.registration || '');
            });

            currentAutoTmpData = rawEntries; // Store the fully sorted data globally

            // Initial population of table rows from the full dataset
            let tableHtml = '';
             const escapeHtml = (unsafe) => { if (unsafe === null || typeof unsafe === 'undefined') return 'N/A'; return String(unsafe).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); };
             if (currentAutoTmpData.length === 0) {
                tableHtml = '<tr><td colspan="4">No auto-generated assignments found.</td></tr>';
            } else {
                 currentAutoTmpData.forEach(entry => {
                    tableHtml += `
                        <tr>
                            <td>${escapeHtml(entry.route)}</td>
                            <td>${escapeHtml(entry.fleet)}</td>
                            <td>${escapeHtml(entry.registration)}</td>
                            <td>${escapeHtml(entry.displayDate)}</td>
                        </tr>`;
                });
            }
            autoTmpTableBody.innerHTML = tableHtml;

            // Populate filters based on the full dataset and apply initial view
            // Reset dropdowns before populating options based on potentially filtered data
            [autoTmpFilterRoute, autoTmpFilterFleet, autoTmpFilterReg, autoTmpFilterDate].forEach(sel => { if(sel) sel.value = ""; });
            updateAutoTmpFiltersAndTable();

        } catch (e) {
            console.error("DEBUG: Error populating auto TMP table:", e);
            autoTmpTableBody.innerHTML = '<tr><td colspan="4" style="color:red;">Error loading data. Please check console.</td></tr>'; // Colspan 4
             if (autoTmpTableMessage) { autoTmpTableMessage.textContent = 'Error loading assignments.'; autoTmpTableMessage.style.color = 'red'; }
        }
    }, 10);
}

/**
 * Helper function to populate a single filter dropdown.
 * @param {HTMLSelectElement} selectElement - The select dropdown element.
 * @param {Set<string>} optionsSet - A Set containing the unique string options.
 * @param {string} currentValue - The currently selected value to preserve.
 * @param {string} [sortType='alpha'] - Sorting type ('alpha', 'numeric', 'date-desc').
 */
function populateFilterWithOptions(selectElement, optionsSet, currentValue, sortType = 'alpha') {
    if (!selectElement) return;

    // Clear existing options (keep "All")
    while (selectElement.options.length > 1) { selectElement.remove(1); }

    let sortedOptions = [...optionsSet].filter(opt => opt !== 'N/A'); // Filter out N/A

    // Sort options based on type
    if (sortType === 'numeric') {
         sortedOptions.sort((a, b) => {
             const numA = parseInt(String(a).replace(/[^0-9]/g, ''), 10);
             const numB = parseInt(String(b).replace(/[^0-9]/g, ''), 10);
             const valA = isNaN(numA) ? Infinity : numA;
             const valB = isNaN(numB) ? Infinity : numB;
             return valA - valB;
        });
    } else if (sortType === 'date-desc') {
        sortedOptions.sort((a, b) => {
            try {
                const partsA = String(a).split('/'); // DD/MM/YYYY
                const dateA = new Date(partsA[2], partsA[1] - 1, partsA[0]);
                const partsB = String(b).split('/');
                const dateB = new Date(partsB[2], partsB[1] - 1, partsB[0]);
                if (isNaN(dateA.getTime())) return 1; // Invalid dates last
                if (isNaN(dateB.getTime())) return -1;
                return dateB - dateA; // Sort descending
            } catch (e) { return 0; }
        });
    } else { // Default 'alpha'
        sortedOptions.sort((a, b) => String(a).localeCompare(String(b)));
    }

    // Add new options
    sortedOptions.forEach(optionValue => {
        selectElement.add(new Option(optionValue, optionValue));
    });

    // Restore the intended selection for this dropdown
    if (currentValue && [...selectElement.options].some(opt => opt.value === currentValue)) {
        selectElement.value = currentValue;
    } else {
         selectElement.value = ""; // Default to "All" if value not found or empty
    }
}


/**
 * Updates filter options based on current selections and applies filtering to the table display.
 */
function updateAutoTmpFiltersAndTable() {
    console.log("DEBUG: updateAutoTmpFiltersAndTable called");

    if (!autoTmpFilterRoute || !autoTmpFilterFleet || !autoTmpFilterReg || !autoTmpFilterDate) {
        console.warn("DEBUG: Auto TMP filter elements not all found.");
        return;
    }

    // 1. Get current filter values *before* repopulating
    const currentFilters = {
        route: autoTmpFilterRoute.value,
        fleet: autoTmpFilterFleet.value,
        reg: autoTmpFilterReg.value,
        date: autoTmpFilterDate.value
    };
    console.log("DEBUG: Current filter values:", currentFilters);

    // 2. Define function to get options based on *other* filters
    const getOptionsFor = (columnToPopulate, currentFilters) => {
        const tempFilters = {...currentFilters};
        // When getting options for a column, DON'T filter by that column itself
        delete tempFilters[columnToPopulate];

        const relevantData = currentAutoTmpData.filter(entry => {
            const routeMatch = !tempFilters.route || entry.route === tempFilters.route;
            const fleetMatch = !tempFilters.fleet || entry.fleet === tempFilters.fleet;
            const regMatch = !tempFilters.reg || entry.registration === tempFilters.reg;
            const dateMatch = !tempFilters.date || entry.displayDate === tempFilters.date;
            return routeMatch && fleetMatch && regMatch && dateMatch;
        });

        let key; // Map filter key to data key
        if (columnToPopulate === 'reg') key = 'registration';
        else if (columnToPopulate === 'date') key = 'displayDate';
        else key = columnToPopulate; // route, fleet

        return new Set(relevantData.map(e => e[key]));
    };


    // 3. Extract unique options for *each* column based on *other* filters
    const options = {
        route: getOptionsFor('route', currentFilters),
        fleet: getOptionsFor('fleet', currentFilters),
        reg: getOptionsFor('reg', currentFilters),
        date: getOptionsFor('date', currentFilters)
    };

    // 4. Repopulate *all* filters, preserving the current selection for each
    populateFilterWithOptions(autoTmpFilterRoute, options.route, currentFilters.route);
    populateFilterWithOptions(autoTmpFilterFleet, options.fleet, currentFilters.fleet, 'numeric');
    populateFilterWithOptions(autoTmpFilterReg, options.reg, currentFilters.reg);
    populateFilterWithOptions(autoTmpFilterDate, options.date, currentFilters.date, 'date-desc');

    // 5. Filter the visible table rows based on the final filter values
    filterAutoTmpTable();
}


/**
 * Applies the current filter selections to VISUALLY hide/show Auto TMP table rows.
 * Does not re-query data or repopulate dropdowns here. Also updates the count.
 */
function filterAutoTmpTable() {
    console.log("DEBUG: filterAutoTmpTable (display update) called.");
    const tableBody = autoTmpTableBody;
    const msgElement = autoTmpTableMessage;

    if (!tableBody || !autoTmpFilterRoute || !autoTmpFilterFleet || !autoTmpFilterReg || !autoTmpFilterDate) {
        console.warn("DEBUG: Filter elements or table body missing for filtering auto TMP table display.");
        if(msgElement) msgElement.textContent = 'Error: UI elements missing for filtering.';
        return;
    }

    // Get the definitive filter values currently set in the dropdowns
    const filters = {
        route: autoTmpFilterRoute.value,
        fleet: autoTmpFilterFleet.value,
        reg: autoTmpFilterReg.value,
        date: autoTmpFilterDate.value
    };

    const rows = tableBody.querySelectorAll("tr");
    let visibleCount = 0;
    let hasActiveFilter = !!(filters.route || filters.fleet || filters.reg || filters.date);

    rows.forEach(row => {
        if (row.cells.length === 4) { // Data row
            const routeCell = row.cells[0]?.textContent || '';
            const fleetCell = row.cells[1]?.textContent || '';
            const regCell = row.cells[2]?.textContent || '';
            const dateCell = row.cells[3]?.textContent || '';

            const routeMatch = !filters.route || routeCell === filters.route;
            const fleetMatch = !filters.fleet || fleetCell === filters.fleet;
            const regMatch = !filters.reg || regCell === filters.reg;
            const dateMatch = !filters.date || dateCell === filters.date;

            const showRow = routeMatch && fleetMatch && regMatch && dateMatch;
            row.style.display = showRow ? "" : "none";
            if (showRow) visibleCount++;

        } else if (row.cells.length === 1) { // Placeholder row
             const placeholderText = row.cells[0].textContent;
             const colSpan = row.cells[0].getAttribute('colspan') === "4";
              // Hide placeholders like "Loading..." always if data rows exist or filters applied
             if(placeholderText !== 'No auto-generated assignments found.' && placeholderText !== 'No assignments match current filters.') {
                 row.style.display = 'none';
             } else {
                // Only show "No assignments" if count is 0 *after* filtering
                row.style.display = 'none'; // Hide initially
             }
        }
    });

    // Handle "No results" message specifically
    const noDataRow = Array.from(tableBody.querySelectorAll("tr")).find(r => r.cells.length === 1 && r.cells[0].getAttribute('colspan') === "4");
    if (noDataRow) {
        if (visibleCount === 0 && currentAutoTmpData.length > 0) { // Only show if data existed but filters hide all
            noDataRow.cells[0].textContent = "No assignments match current filters.";
            noDataRow.cells[0].style.color = 'orange';
            noDataRow.style.display = "";
        } else if (visibleCount === 0 && currentAutoTmpData.length === 0) { // Show default if no data ever
             noDataRow.cells[0].textContent = "No auto-generated assignments found.";
             noDataRow.cells[0].style.color = '';
             noDataRow.style.display = "";
        }
         else { // Hide placeholder if rows are visible
            noDataRow.style.display = "none";
        }
    }

    // Update count display
    if (msgElement) {
        msgElement.textContent = `Auto Assignments: ${visibleCount} / 9999 ${hasActiveFilter ? '(Filtered)' : ''}`;
        msgElement.style.color = ''; // Reset color
    }
}


/**
 * Called by the onchange event of the filter selects.
 * Updates the filters and table display.
 */
function applyAndSaveAutoTmpFilters() {
    console.log("DEBUG: applyAndSaveAutoTmpFilters called (will update filters and table).");
    // No longer saves state to localStorage
    updateAutoTmpFiltersAndTable(); // This now handles filtering data, updating options, and filtering display
}


function resetTMPMap() {
    if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin Denied.'); return; }
    if (confirm('DANGER: Reset ALL TMP assignments?')) {
         // Set up and show modal for TMP reset
         if (!passwordModal || !passwordModalInput || !passwordModalError || !passwordModalPrompt) {
             alert("Error: Password dialog UI elements missing."); return;
         }
         currentModalAction = 'resetTMP'; // Set the action
         passwordModalPrompt.textContent = 'Please enter your password to confirm TMP reset:'; // Set prompt
         passwordModalInput.value = '';
         passwordModalError.textContent = '';
         passwordModal.classList.remove('hidden');
         passwordModalInput.focus();
    }
 }

// Updated function to handle multiple actions
function handleModalConfirm() {
    console.log(`DEBUG: handleModalConfirm called for action: ${currentModalAction}`);
    if (!isLoggedIn || !currentUsername || !users[currentUsername]) {
        if (passwordModalError) passwordModalError.textContent = 'Error: Cannot verify user.';
        return;
    }
     if (!passwordModalInput || !passwordModalError || !passwordModal || !passwordModalPrompt) {
        console.error("DEBUG: Password modal elements missing in handleModalConfirm");
        return;
     }
     const enteredPassword = passwordModalInput.value;
     const correctPassword = users[currentUsername].pass;

     if (enteredPassword === correctPassword) {
        console.log("DEBUG: Password correct.");
        passwordModal.classList.add('hidden'); // Hide modal first

        // Execute the stored action
        if (currentModalAction === 'resetTMP') {
            console.log("DEBUG: Executing resetTMP action.");
            try {
                localStorage.removeItem(tmpMapKey);
                localStorage.removeItem(tmpGenerationInfoKey);
                if (localStorage.getItem(tmpMapKey) === null && localStorage.getItem(tmpGenerationInfoKey) === null) {
                    logAdminAction("TMP Map Reset");
                    alert('TMP map cleared successfully.');
                } else {
                    alert('ERROR: Failed to verify TMP map clearance!'); // Should not happen if removeItem worked
                }
                 // Refresh relevant UI if needed
                if (manualFleetForm && !manualFleetForm.classList.contains('hidden')) {
                     displayManualAssignments();
                 }
                if (viewAutoTmpSection && !viewAutoTmpSection.classList.contains('hidden')) {
                     populateAutoTmpTable();
                 }
            } catch (e) {
                alert("An error occurred while clearing the TMP map.");
                console.error("Error executing TMP reset:", e);
            }
        } else if (currentModalAction === 'pruneCurtailments') {
            console.log("DEBUG: Executing pruneCurtailments action.");
            executePruning(); // Call the actual pruning logic function
        } else {
            console.error(`DEBUG: Unknown modal action: ${currentModalAction}`);
        }

        currentModalAction = null; // Clear the action after execution

    } else {
        console.warn("DEBUG: Incorrect password entered.");
        passwordModalError.textContent = 'Incorrect password.';
        passwordModalInput.focus();
        passwordModalInput.select();
    }
}

// Updated function to handle modal cancellation
function cancelModalAction() {
    console.log("DEBUG: cancelModalAction called.");
    if (passwordModal) passwordModal.classList.add('hidden');
    if (passwordModalInput) passwordModalInput.value = '';
    if (passwordModalError) passwordModalError.textContent = '';
    currentModalAction = null; // Clear the pending action
}

// --- Settings Section Logic ---
function loadTrackerSettings() { const s = loadFromStorage(settingsKey, defaultSettings); if (settingsDebounceInput) settingsDebounceInput.value = s.debounceMinutes ?? defaultSettings.debounceMinutes; if (settingsTimeoutInput) settingsTimeoutInput.value = s.timeoutMinutes ?? defaultSettings.timeoutMinutes; if (settingsAutoLogoutInput) settingsAutoLogoutInput.value = s.autoLogoutMinutes ?? defaultSettings.autoLogoutMinutes; }
function saveTrackerSettings() { if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin Denied.'); return; } if (!settingsDebounceInput || !settingsTimeoutInput || !settingsAutoLogoutInput || !trackerSettingsMessage) return; const d = parseInt(settingsDebounceInput.value, 10), t = parseInt(settingsTimeoutInput.value, 10), a = parseInt(settingsAutoLogoutInput.value, 10); trackerSettingsMessage.textContent = ''; if (isNaN(d) || d < 0) { alert("Invalid Debounce"); return; } if (isNaN(t) || t < 1) { alert("Invalid Timeout"); return; } if (isNaN(a) || a < 0) { alert("Invalid Auto Logout"); return; } const oldS = loadFromStorage(settingsKey, defaultSettings); const newS = { debounceMinutes: d, timeoutMinutes: t, autoLogoutMinutes: a }; saveToStorage(settingsKey, newS); logAdminAction("Tracker Settings Saved", { old: oldS, new: newS }); trackerSettingsMessage.textContent = "Saved!"; trackerSettingsMessage.style.color = "green"; startSessionTimer(); setTimeout(() => trackerSettingsMessage.textContent = "", 3000); }
function changeMyPassword() { if (!isLoggedIn || !currentUsername) { alert("Not logged in."); return; } if (!currentPasswordInput || !newPasswordInput || !confirmNewPasswordInput || !changePasswordMessage) return; const curr = currentPasswordInput.value, newP = newPasswordInput.value, conf = confirmNewPasswordInput.value; changePasswordMessage.textContent = ''; if (!curr || !newP || !conf) { changePasswordMessage.textContent = "Fill fields."; return; } if (newP.length < 6) { changePasswordMessage.textContent = "Pass >= 6 chars."; return; } if (newP !== conf) { changePasswordMessage.textContent = "Mismatch."; return; } if (users[currentUsername].pass !== curr) { changePasswordMessage.textContent = "Incorrect current pass."; return; } if (newP === curr) { changePasswordMessage.textContent = "New same as old."; return; } users[currentUsername].pass = newP; saveUsersToStorage(); logAdminAction("Password Changed", { user: currentUsername }); changePasswordMessage.textContent = "Password changed!"; changePasswordMessage.style.color = "green"; currentPasswordInput.value = ''; newPasswordInput.value = ''; confirmNewPasswordInput.value = ''; setTimeout(() => changePasswordMessage.textContent = '', 4000); }
function displayUserManagement() {
    if (!isLoggedIn || users[currentUsername]?.role !== 'admin' || !userManagementTbody) return;
    userManagementTbody.innerHTML = '';
    userManagementMessage.textContent = '';
    Object.keys(users).sort().forEach(un => {
        const uData = users[un];
        const tr = userManagementTbody.insertRow();
        tr.insertCell().textContent = un;
        const roleC = tr.insertCell();
        if (un === 'Ryan') {
            roleC.textContent = uData.role;
        } else {
            const sel = document.createElement('select');
            sel.id = `role-select-${un}`;
            sel.innerHTML = `<option value="user" ${uData.role === 'user' ? 'selected' : ''}>User</option><option value="moderator" ${uData.role === 'moderator' ? 'selected' : ''}>Moderator</option><option value="admin" ${uData.role === 'admin' ? 'selected' : ''}>Admin</option>`;
            sel.onchange = () => changeUserRole(un, sel.value);
            roleC.appendChild(sel);
        }
        const statusC = tr.insertCell();
        const statusT = uData.isSuspended ? 'Suspended' : 'Active';
        const statusCls = uData.isSuspended ? 'status-suspended' : 'status-active';
        statusC.innerHTML = `<span class="${statusCls}">${statusT}</span>`;
        const passC = tr.insertCell();
        if (un !== 'Ryan') {
            const inp = document.createElement('input');
            inp.type = 'password';
            inp.id = `new-pass-${un}`;
            inp.placeholder = "New password";
            inp.autocomplete = "new-password";
            passC.appendChild(inp);
        } else {
            passC.textContent = 'N/A';
        }
        const permC = tr.insertCell();
        permC.className = 'permissions-cell';
        permC.innerHTML = '<div>[Permissions TBD]</div>';
        const actC = tr.insertCell();
        if (un !== 'Ryan') {
            const btnP = document.createElement('button');
            btnP.textContent = 'Set Password'; // Button text updated
            btnP.className = 'blue-button';
            btnP.type = 'button';
            btnP.onclick = () => changeOtherUserPassword(un);
            actC.appendChild(btnP);

            const btnS = document.createElement('button');
            btnS.textContent = uData.isSuspended ? 'Unsuspend' : 'Suspend';
            btnS.className = uData.isSuspended ? 'unsuspend-user-btn' : 'suspend-user-btn';
            btnS.type = 'button';
            btnS.onclick = () => toggleUserSuspension(un);
            actC.appendChild(btnS);

            const btnD = document.createElement('button');
            btnD.textContent = 'Delete';
            btnD.className = 'danger-button delete-user-btn';
            btnD.type = 'button';
            btnD.onclick = () => deleteUser(un);
            actC.appendChild(btnD);
        }
    });
}
function addUser() { if (!isLoggedIn || users[currentUsername]?.role !== 'admin' || !addUsernameInput || !addUserPasswordInput || !addUserRoleSelect || !addUserMessage) return; const newU = addUsernameInput.value.trim(), newP = addUserPasswordInput.value, newR = addUserRoleSelect.value; addUserMessage.textContent = ''; if (!newU || !newP) { addUserMessage.textContent = "User/Pass required."; return; } if (newP.length < 6) { addUserMessage.textContent = "Pass >= 6 chars."; return; } if (Object.prototype.hasOwnProperty.call(users, newU)) { addUserMessage.textContent = "User exists."; return; } if (!['user', 'admin', 'moderator'].includes(newR)) { addUserMessage.textContent = "Invalid role."; return; } users[newU] = { pass: newP, role: newR, permissions: {}, isSuspended: false }; saveUsersToStorage(); logAdminAction("User Added", { newUser: newU, role: newR }); addUserMessage.textContent = `User "${newU}" added.`; addUserMessage.style.color = "green"; addUsernameInput.value = ''; addUserPasswordInput.value = ''; addUserRoleSelect.value = 'user'; displayUserManagement(); setTimeout(() => addUserMessage.textContent = '', 4000); }
function changeUserRole(username, newRole) { if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { return; } if (username === 'Ryan') { alert("Cannot change the default admin role."); displayUserManagement(); return; } if (!Object.prototype.hasOwnProperty.call(users, username)) { alert(`User ${username} not found.`); return; } if (!['user', 'admin', 'moderator'].includes(newRole)) { alert("Invalid role selected."); return; } const oldRole = users[username].role; if (oldRole === newRole) return; if (confirm(`Change role for user '${username}' from ${oldRole} to ${newRole}?`)) { users[username].role = newRole; saveUsersToStorage(); logAdminAction("User Role Changed", { targetUser: username, oldRole, newRole }); userManagementMessage.textContent = `Role for ${username} updated.`; displayUserManagement(); setTimeout(() => userManagementMessage.textContent = '', 4000); } else { displayUserManagement(); } }
function changeOtherUserPassword(username) { if (!isLoggedIn || users[currentUsername]?.role !== 'admin' || username === 'Ryan') { alert("Cannot change password for this user."); return; } if (!Object.prototype.hasOwnProperty.call(users, username)) { alert(`User ${username} not found.`); return; } const passInput = document.getElementById(`new-pass-${username}`); if (!passInput) return; const newPass = passInput.value; userManagementMessage.textContent = ''; if (!newPass) { userManagementMessage.textContent = `Enter a new password for ${username}.`; return; } if (newPass.length < 6) { userManagementMessage.textContent = "Password must be at least 6 characters."; return; } if (confirm(`Set new password for user '${username}'?`)) { users[username].pass = newPass; saveUsersToStorage(); logAdminAction("User Password Set", { targetUser: username }); userManagementMessage.textContent = `Password for ${username} updated.`; passInput.value = ''; setTimeout(() => userManagementMessage.textContent = '', 4000); } }
function deleteUser(username) { if (!isLoggedIn || users[currentUsername]?.role !== 'admin' || username === 'Ryan') { alert("Cannot delete this user."); return; } if (!Object.prototype.hasOwnProperty.call(users, username)) { alert(`User ${username} not found.`); return; } if (confirm(`DELETE user '${username}'? This cannot be undone.`)) { const delData = { role: users[username].role, suspended: users[username].isSuspended }; delete users[username]; saveUsersToStorage(); logAdminAction("User Deleted", { deletedUser: username, details: delData }); userManagementMessage.textContent = `User '${username}' deleted.`; displayUserManagement(); setTimeout(() => userManagementMessage.textContent = '', 4000); } }
function toggleUserSuspension(username) { console.log(`DEBUG: toggleUserSuspension: ${username}`); if (!isLoggedIn || users[currentUsername]?.role !== 'admin' || username === 'Ryan') { console.warn("DEBUG: Suspension toggle denied."); return; } if (!Object.prototype.hasOwnProperty.call(users, username)) { alert(`User ${username} not found.`); return; } const user = users[username]; const action = user.isSuspended ? "unsuspend" : "suspend"; if (confirm(`${action.charAt(0).toUpperCase() + action.slice(1)} user ${username}?`)) { user.isSuspended = !user.isSuspended; saveUsersToStorage(); logAdminAction(`User ${action}ed`, { targetUser: username }); userManagementMessage.textContent = `User "${username}" ${action}ed.`; userManagementMessage.style.color = "green"; displayUserManagement(); setTimeout(() => { if (userManagementMessage) userManagementMessage.textContent = ''; }, 4000); } }

// --- Audit Log Display/Clear ---
function displayAuditLog() {
    console.log("DEBUG: displayAuditLog called.");
    if (!isLoggedIn || users[currentUsername]?.role !== 'admin' || !auditLogDisplay) { console.warn("DEBUG: Cannot display audit log - Permission denied or element missing."); if (auditLogDisplay) auditLogDisplay.innerHTML = '<p>Log cannot be displayed.</p>'; return; }
    auditLogDisplay.innerHTML = ''; if (auditLogMessage) auditLogMessage.textContent = '';
    try {
        const log = loadFromStorage(auditLogKey, []); if (!Array.isArray(log)) { auditLogDisplay.innerHTML = '<p>Log data is corrupted or not an array.</p>'; console.error("DEBUG: Audit log data is not an array:", log); return; }
        if (log.length === 0) { auditLogDisplay.innerHTML = '<p>Audit log is empty.</p>'; }
        else {
            const escapeHtml = (unsafe) => { if (unsafe === null || typeof unsafe === 'undefined') return ''; return String(unsafe).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); };
            log.forEach(entry => {
                const logDiv = document.createElement('div'); const time = new Date(entry.timestamp).toLocaleString('en-GB', {});
                const user = entry.user || 'N/A'; const action = entry.action || '?'; let detailsText = '';
                if (entry.details && typeof entry.details === 'object' && Object.keys(entry.details).length > 0) { try { detailsText = JSON.stringify(entry.details, null, 2); } catch { detailsText = '[Unserializable Details]'; } }
                else if (typeof entry.details === 'string') { detailsText = entry.details; }
                const safeTime = escapeHtml(time); const safeUser = escapeHtml(user); const safeAction = escapeHtml(action); const safeDetails = escapeHtml(detailsText);
                logDiv.innerHTML = `<span class="log-timestamp">[${safeTime}]</span> <span class="log-user">${safeUser}</span> <span class="log-action">${safeAction}</span><span class="log-details">${safeDetails ? ` ${safeDetails}` : ''}</span>`;
                auditLogDisplay.appendChild(logDiv);
            });
        }
    } catch (e) { console.error("DEBUG: Error displaying audit log:", e); auditLogDisplay.innerHTML = '<p style="color:red;">Error displaying log content.</p>'; }
}
function clearAuditLog() { console.log("DEBUG: clearAuditLog."); if (!isLoggedIn || users[currentUsername]?.role !== 'admin') return; if (confirm("Clear ENTIRE Audit Log? This action cannot be undone.")) { try { localStorage.removeItem(auditLogKey); logAdminAction("Audit Log Cleared"); if (auditLogMessage) { auditLogMessage.textContent = "Log cleared."; auditLogMessage.style.color = 'green'; } displayAuditLog(); setTimeout(() => auditLogMessage.textContent = '', 4000); } catch (e) { if (auditLogMessage) { auditLogMessage.textContent = "Error clearing."; auditLogMessage.style.color = 'red'; } } } }

// --- Backup & Restore Section Functions (Including Pruning & Export All) ---

/**
 * Updates the enabled/disabled state and description text of the Prune button.
 */
 function updatePruneButtonState() {
    if (!pruneCurtailmentsButton) {
        console.warn("DEBUG: Prune button not found, cannot update state.");
        return;
    }
    const descElement = pruneDescriptionText; // Use ref defined earlier

    // Always disable and set description if user is not admin
    if (!isLoggedIn || !users[currentUsername] || users[currentUsername].role !== 'admin') {
        pruneCurtailmentsButton.disabled = true;
        pruneCurtailmentsButton.removeAttribute('title'); // Remove any leftover title
        if (descElement) descElement.textContent = 'Admin privileges required for pruning.';
        return;
    }

    const SIX_MONTHS_MS = 182 * 24 * 60 * 60 * 1000; // Approx 6 months (182 days)
    let lastPruneTimestamp = parseInt(loadFromStorage(lastCurtailmentPruneTimestampKey, 0), 10);
    const now = Date.now();

    // Set virtual timestamp if never pruned
    if (lastPruneTimestamp === 0) {
        console.log("DEBUG: Pruning never performed. Setting virtual start date to today to begin 6-month countdown.");
        lastPruneTimestamp = now;
        saveToStorage(lastCurtailmentPruneTimestampKey, lastPruneTimestamp);
    }

    const timeSinceLastPrune = now - lastPruneTimestamp;
    // isEnabled is true ONLY if time since last (real or virtual) is >= 6 months
    const isEnabled = timeSinceLastPrune >= SIX_MONTHS_MS;

    pruneCurtailmentsButton.disabled = !isEnabled;
    pruneCurtailmentsButton.removeAttribute('title'); // Ensure no default browser title

    // Update description text
    if (descElement) {
        if (isEnabled) {
            descElement.textContent = "Permanently delete curtailment records older than 6 months."; // Removed 'approx'
        } else {
            const daysRemaining = Math.ceil((SIX_MONTHS_MS - timeSinceLastPrune) / (24 * 60 * 60 * 1000));
            const displayDays = Math.max(1, daysRemaining); // Show at least 1 day remaining
            const lastDateStr = new Date(lastPruneTimestamp).toLocaleDateString('en-GB');
            // Removed 'approx' from the description text
            descElement.textContent = `Pruning available in ${displayDays} day(s). (Last effective prune date: ${lastDateStr})`;
        }
    }
    console.log(`DEBUG: Prune button state updated. Enabled: ${isEnabled}. Last (real or virtual) prune: ${new Date(lastPruneTimestamp).toISOString()}`);
}


/**
 * Initiates the pruning process by showing the password modal.
 */
function pruneOldCurtailments() {
    console.log("DEBUG: pruneOldCurtailments called.");
    if (!pruneCurtailmentsButton || pruneCurtailmentsButton.disabled) {
        console.warn("DEBUG: Prune button is disabled or not found.");
        return;
    }
     if (!isLoggedIn || !users[currentUsername] || users[currentUsername].role !== 'admin') {
         alert("Admin privileges required for pruning.");
         console.warn(`DEBUG: Pruning denied for user ${currentUsername} (Role: ${users[currentUsername]?.role})`);
         return;
     }

    if (!confirm("DANGER! This will permanently delete all curtailment records older than approximately 6 months.\n\nThis action CANNOT BE UNDONE.\n\nAre you absolutely sure you want to proceed?")) {
        console.log("DEBUG: Pruning cancelled by user.");
        return;
    }

    // Show password modal instead of executing directly
     if (!passwordModal || !passwordModalInput || !passwordModalError || !passwordModalPrompt) {
         alert("Error: Password dialog UI elements missing."); return;
     }
     currentModalAction = 'pruneCurtailments'; // Set the action
     passwordModalPrompt.textContent = 'Please enter your password to confirm data pruning:'; // Set prompt
     passwordModalInput.value = '';
     passwordModalError.textContent = '';
     passwordModal.classList.remove('hidden');
     passwordModalInput.focus();
}

/**
 * Executes the actual pruning logic after password confirmation.
 */
function executePruning() {
     console.log("DEBUG: executePruning called.");
     if (pruneStatusMessage) {
        pruneStatusMessage.textContent = "Pruning old records...";
        pruneStatusMessage.style.color = "orange";
    }
    if (pruneCurtailmentsButton) pruneCurtailmentsButton.disabled = true; // Ensure button is disabled during processing

    const SIX_MONTHS_MS = 182 * 24 * 60 * 60 * 1000;
    const cutoffTimestamp = Date.now() - SIX_MONTHS_MS;
    let totalDeletedCount = 0;
    let totalKeptCount = 0;
    let errorOccurred = false;

    console.log(`DEBUG: Pruning records older than timestamp: ${cutoffTimestamp} (${new Date(cutoffTimestamp).toISOString()})`);

    // Use try...finally to ensure status message clears and button state updates
    try {
        const keysToProcess = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith("curtailedBusesArray_")) {
                keysToProcess.push(key);
            }
        }
        console.log(`DEBUG: Found ${keysToProcess.length} curtailment keys to process.`);

        keysToProcess.forEach(key => {
            try {
                let data = loadFromStorage(key, []);
                if (!Array.isArray(data)) {
                    console.warn(`DEBUG: Invalid data format for key ${key}. Skipping.`);
                    return; // Skip this key
                }
                const initialCount = data.length;
                const keptData = data.filter(item => item && typeof item.timestamp === 'number' && item.timestamp >= cutoffTimestamp);
                const deletedForKey = initialCount - keptData.length;

                if (deletedForKey > 0) {
                    totalDeletedCount += deletedForKey;
                    totalKeptCount += keptData.length;
                    if (keptData.length === 0) {
                        localStorage.removeItem(key);
                        console.log(`DEBUG: Pruned ${deletedForKey} entries from ${key} and removed key.`);
                    } else {
                        saveToStorage(key, keptData);
                         console.log(`DEBUG: Pruned ${deletedForKey} entries from ${key}. Kept ${keptData.length}.`);
                    }
                } else {
                    totalKeptCount += initialCount; // All were kept
                }

            } catch (innerError) {
                console.error(`DEBUG: Error processing key ${key} during prune:`, innerError);
                errorOccurred = true;
            }
        });

        // Log and update UI after processing all keys
        // Update timestamp even if only errors occurred or nothing found, to reset timer
        const pruneTime = Date.now();
        saveToStorage(lastCurtailmentPruneTimestampKey, pruneTime);

        if (totalDeletedCount > 0) {
             logAdminAction("Curtailments Pruned", { deletedCount: totalDeletedCount, cutoff: new Date(cutoffTimestamp).toISOString() });
        }

        if (pruneStatusMessage) {
             if(errorOccurred) {
                 pruneStatusMessage.textContent = `Pruning finished with errors. Removed ${totalDeletedCount} old record(s). Check console.`;
                 pruneStatusMessage.style.color = "red";
             } else if (totalDeletedCount > 0) {
                 pruneStatusMessage.textContent = `Pruning complete. Removed ${totalDeletedCount} old record(s).`;
                 pruneStatusMessage.style.color = "green";
             } else {
                 pruneStatusMessage.textContent = "No old records found to prune.";
                 pruneStatusMessage.style.color = "green";
             }
        }

    } catch (e) {
        console.error("DEBUG: Critical error during pruning process:", e);
        if (pruneStatusMessage) {
            pruneStatusMessage.textContent = "A critical error occurred during pruning.";
            pruneStatusMessage.style.color = "red";
        }
        errorOccurred = true;
    } finally {
         updatePruneButtonState(); // Update button state based on the new timestamp/errors
         setTimeout(() => { if (pruneStatusMessage) pruneStatusMessage.textContent = ''; }, 5000);
    }
}


/**
 * Initiates export for all data types sequentially.
 */
function exportAllData() {
    console.log("DEBUG: exportAllData called.");
    if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) {
         alert('Access Denied. Moderator or Admin required.');
         console.warn(`DEBUG: exportAllData denied for user '${currentUsername}'.`);
         return;
     }

     if (exportAllStatus) {
         exportAllStatus.textContent = 'Initiating all exports...';
         exportAllStatus.style.color = 'orange';
     }

     // Call existing export functions sequentially
     // User will get multiple download prompts and individual status messages/alerts
     try {
         console.log("DEBUG: Exporting Curtailments...");
         exportCurtailments(); // Assumes this function handles its own UI feedback/alerts

         console.log("DEBUG: Exporting Fleet/TMP Map...");
         exportTmpMap();

         console.log("DEBUG: Exporting Sequence Headings...");
         exportSequenceHeadings();

         console.log("DEBUG: Exporting Final Destinations...");
         exportFinalDestinations();

         if (exportAllStatus) {
             exportAllStatus.textContent = 'Export All process initiated. Check downloads/individual status messages.';
             exportAllStatus.style.color = 'green';
             setTimeout(() => { if (exportAllStatus) exportAllStatus.textContent = ''; }, 5000);
         }
         logAdminAction("Data Exported (All Types)");

     } catch (e) {
         console.error("Error during exportAllData sequence:", e);
         if (exportAllStatus) {
             exportAllStatus.textContent = 'Error occurred during Export All sequence. Check console.';
             exportAllStatus.style.color = 'red';
             setTimeout(() => { if (exportAllStatus) exportAllStatus.textContent = ''; }, 5000);
         }
         alert("An error occurred during the Export All process. Some files may not have exported.");
     }
 }


function exportCurtailments() { if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) { alert('Denied.'); return; } if (curtailmentsBackupStatus) curtailmentsBackupStatus.textContent = ''; let all = {}, found = 0; try { for (let i = 0; i < localStorage.length; i++) { const k = localStorage.key(i); if (k?.startsWith("curtailedBusesArray_")) { const r = k.replace("curtailedBusesArray_", ""); const d = loadFromStorage(k, []); if (Array.isArray(d)) { all[r] = d; found++; } } } } catch (e) { if (curtailmentsBackupStatus) curtailmentsBackupStatus.textContent = 'Error gather.'; return; } if (found === 0) { if (curtailmentsBackupStatus) curtailmentsBackupStatus.textContent = 'No data.'; alert("No curtailment data to export."); return; } try {
    const now = new Date(); const day = now.getDate().toString().padStart(2, '0'); const month = (now.getMonth() + 1).toString().padStart(2, '0'); const year = now.getFullYear().toString().slice(-2); const hours = now.getHours().toString().padStart(2, '0'); const minutes = now.getMinutes().toString().padStart(2, '0'); const seconds = now.getSeconds().toString().padStart(2, '0'); const ts = `${day}${month}${year}-${hours}${minutes}${seconds}`;
    const json = JSON.stringify(all, null, 2); const blob = new Blob([json], { type: "application/json" }); const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = `ToolsBackup_Curtailments_${ts}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href); logAdminAction("Data Exported", { type: "Curtailments", keys: found }); if (curtailmentsBackupStatus) { curtailmentsBackupStatus.textContent = 'Exported!'; setTimeout(() => curtailmentsBackupStatus.textContent = '', 4000); } try { localStorage.setItem(lastExportKey, Date.now().toString()); if (exportReminderDiv) exportReminderDiv.style.display = 'none'; } catch (e) { console.warn("Could not save last export timestamp");} } catch (e) { if (curtailmentsBackupStatus) curtailmentsBackupStatus.textContent = 'Error exporting.'; alert("Error exporting."); } }
function handleCurtailmentImport(file) { if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin Denied.'); if (importCurtailmentsInput) importCurtailmentsInput.value = ''; return; } if (!file) { alert("No file selected."); return; } if (curtailmentsBackupStatus) curtailmentsBackupStatus.textContent = ''; if (!file.name.toLowerCase().endsWith('.json')) { alert("Invalid file type. Please select a JSON file."); return; } const r = new FileReader(); r.onload = function (e) { try { const imp = JSON.parse(e.target.result); if (typeof imp !== 'object' || imp === null) throw new Error("Not valid JSON object."); if (!confirm("Importing will REPLACE ALL existing curtailment data for routes found in the file. Continue?")) { if (importCurtailmentsInput) importCurtailmentsInput.value = ''; return; } let impC = 0, skipR = [], skipE = 0; const impKeys = Object.keys(imp); for (const route of impKeys) { const key = `curtailedBusesArray_${route}`; const d = imp[route]; if (Array.isArray(d)) { const v = d.filter(i => i && i.route && i.regNumber && i.curtailedDestination && (i.curtailmentTime || i.timestamp)); if (v.length !== d.length) skipE += (d.length - v.length); v.forEach(i => { if (!i.timestamp && i.curtailmentTime) { try { const p = i.curtailmentTime.match(/(\d{2})\/(\d{2})\/(\d{4}),?\s*(\d{2}):(\d{2})/); i.timestamp = p ? new Date(Date.UTC(p[3], p[2] - 1, p[1], p[4], p[5], 0)).getTime() : (Date.parse(i.curtailmentTime) || 0); if (isNaN(i.timestamp)) i.timestamp = 0; } catch { i.timestamp = 0; } } else if (!i.timestamp) i.timestamp = 0; }); const f = v.filter(i => typeof i.timestamp === 'number' && i.timestamp > 0); if (v.length !== f.length) skipE += (v.length - f.length); if (f.length > 0) { saveToStorage(key, f); impC++; } else { localStorage.removeItem(key); /* Remove key if no valid entries */ console.log(`DEBUG: Removed key ${key} during import as no valid entries remained.`);} } else { skipR.push(route); } } let msg = `${impC} routes imported.\n`; if (skipR.length > 0) msg += `Skipped routes (invalid data): ${skipR.join(', ')}\n`; if (skipE > 0) msg += `Skipped ${skipE} invalid/incomplete entries within routes.`; logAdminAction("Data Imported", { type: "Curtailments", routes: impKeys, successCount: impC, skippedRoutes: skipR.length, skippedEntries: skipE, fileName: file.name }); if (curtailmentsBackupStatus) { curtailmentsBackupStatus.textContent = 'Import complete.'; setTimeout(() => curtailmentsBackupStatus.textContent = '', 4000); } alert(msg); if (manageCurtailmentsSection && !manageCurtailmentsSection.classList.contains('hidden')) populateManageCurtailmentsTable(); } catch (err) { if (curtailmentsBackupStatus) { curtailmentsBackupStatus.textContent = `Import Error: ${err.message}`; } alert("Import Error: " + err.message); } finally { if (importCurtailmentsInput) importCurtailmentsInput.value = ''; } }; r.onerror = function () { if (curtailmentsBackupStatus) { curtailmentsBackupStatus.textContent = 'File Read Error.'; } alert("Error reading file."); if (importCurtailmentsInput) importCurtailmentsInput.value = ''; }; r.readAsText(file); }
function exportTmpMap() { if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) { alert('Admin Denied.'); return; } if (tmpBackupStatus) tmpBackupStatus.textContent = ''; try { const map = loadFromStorage(tmpMapKey, {}); if (typeof map !== 'object' || map === null || Object.keys(map).length === 0) { if (tmpBackupStatus) tmpBackupStatus.textContent = 'No data.'; alert("No TMP data to export."); return; } const count = Object.keys(map).length;
    const now = new Date(); const day = now.getDate().toString().padStart(2, '0'); const month = (now.getMonth() + 1).toString().padStart(2, '0'); const year = now.getFullYear().toString().slice(-2); const hours = now.getHours().toString().padStart(2, '0'); const minutes = now.getMinutes().toString().padStart(2, '0'); const seconds = now.getSeconds().toString().padStart(2, '0'); const ts = `${day}${month}${year}-${hours}${minutes}${seconds}`;
    const json = JSON.stringify(map, null, 2); const blob = new Blob([json], { type: "application/json" }); const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = `ToolsBackup_FleetTMP_${ts}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href); logAdminAction("Data Exported", { type: "Fleet/TMP", count }); if (tmpBackupStatus) { tmpBackupStatus.textContent = 'Exported!'; setTimeout(() => tmpBackupStatus.textContent = '', 4000); } } catch (e) { if (tmpBackupStatus) tmpBackupStatus.textContent = 'Export error.'; alert("Export error: " + e.message); } }
function handleTmpImport(file) { if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin Denied.'); if (importTmpInput) importTmpInput.value = ''; return; } if (!file) { alert("No file selected."); return; } if (tmpBackupStatus) tmpBackupStatus.textContent = ''; if (!file.name.toLowerCase().endsWith('.json')) { alert("Invalid file type. Please select a JSON file."); if (importTmpInput) importTmpInput.value = ''; return; } const r = new FileReader(); r.onload = function (e) { try { let data = JSON.parse(e.target.result); if (typeof data !== 'object' || data === null || Array.isArray(data)) throw new Error("Not valid map/object format."); let invalid = 0; for (const k in data) { if (Object.prototype.hasOwnProperty.call(data, k)) { if (typeof data[k] !== 'string') { console.warn(`Removing invalid value for key ${k} during TMP import.`); delete data[k]; invalid++; } } else { console.warn(`Removing inherited key ${k} during TMP import.`); delete data[k]; invalid++; } } if (invalid > 0) alert(`Warning: Removed ${invalid} invalid entries from the imported file.`); const validCount = Object.keys(data).length; if (validCount === 0) throw new Error("No valid Reg -> Fleet entries found in file."); if (!confirm(`Importing will REPLACE ALL existing Fleet/TMP assignments (${validCount} valid entries found in file). Continue?`)) { if (importTmpInput) importTmpInput.value = ''; return; } saveToStorage(tmpMapKey, data); logAdminAction("Data Imported", { type: "Fleet/TMP", count: validCount, fileName: file.name }); if (tmpBackupStatus) { tmpBackupStatus.textContent = 'Imported!'; setTimeout(() => tmpBackupStatus.textContent = '', 4000); } alert(`Imported ${validCount} assignments.`); if (manualFleetForm && !manualFleetForm.classList.contains('hidden')) displayManualAssignments(); } catch (err) { if (tmpBackupStatus) { tmpBackupStatus.textContent = `Import Error: ${err.message}`; } alert("Import error: " + err.message); } finally { if (importTmpInput) importTmpInput.value = ''; } }; r.onerror = function () { if (tmpBackupStatus) { tmpBackupStatus.textContent = 'File Read Error.'; } alert("Error reading file."); if (importTmpInput) importTmpInput.value = ''; }; r.readAsText(file); }
function exportSequenceHeadings() { if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) { alert('Admin Denied.'); return; } if (seqHeadingsBackupStatus) seqHeadingsBackupStatus.textContent = ''; let all = {}, found = 0; try { for (let i = 0; i < localStorage.length; i++) { const k = localStorage.key(i); if (k?.startsWith(sequenceHeadingOverrideBaseKey)) { const r = k.substring(sequenceHeadingOverrideBaseKey.length); const d = loadFromStorage(k, null); if (d && typeof d === 'object') { all[r] = d; found++; } } } } catch (e) { if (seqHeadingsBackupStatus) seqHeadingsBackupStatus.textContent = 'Error gathering data.'; return; } if (found === 0) { if (seqHeadingsBackupStatus) seqHeadingsBackupStatus.textContent = 'No data.'; alert("No sequence headings found to export."); return; } try {
    const now = new Date(); const day = now.getDate().toString().padStart(2, '0'); const month = (now.getMonth() + 1).toString().padStart(2, '0'); const year = now.getFullYear().toString().slice(-2); const hours = now.getHours().toString().padStart(2, '0'); const minutes = now.getMinutes().toString().padStart(2, '0'); const seconds = now.getSeconds().toString().padStart(2, '0'); const ts = `${day}${month}${year}-${hours}${minutes}${seconds}`;
    const json = JSON.stringify(all, null, 2); const blob = new Blob([json], { type: "application/json" }); const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = `ToolsBackup_SeqHeadings_${ts}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href); logAdminAction("Data Exported", { type: "Sequence Headings", count: found }); if (seqHeadingsBackupStatus) { seqHeadingsBackupStatus.textContent = 'Exported!'; setTimeout(() => seqHeadingsBackupStatus.textContent = '', 4000); } } catch (e) { if (seqHeadingsBackupStatus) seqHeadingsBackupStatus.textContent = 'Export error.'; alert("Export error."); } }
function handleSequenceHeadingsImport(file) { if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin Denied.'); if (importSeqHeadingsInput) importSeqHeadingsInput.value = ''; return; } if (!file) { alert("No file selected."); return; } if (seqHeadingsBackupStatus) seqHeadingsBackupStatus.textContent = ''; if (!file.name.toLowerCase().endsWith('.json')) { alert("Invalid file type. Please select a JSON file."); if (importSeqHeadingsInput) importSeqHeadingsInput.value = ''; return; } const r = new FileReader(); r.onload = function (e) { try { let data = JSON.parse(e.target.result); if (typeof data !== 'object' || data === null || Array.isArray(data)) throw new Error("Not valid map/object format."); let valid = 0, invalid = 0; for (const rt in data) { if (Object.prototype.hasOwnProperty.call(data, rt)) { const d = data[rt]; if (typeof d === 'object' && d !== null && (typeof d.outbound === 'string' || typeof d.inbound === 'string')) { valid++; } else { console.warn(`Removing invalid sequence heading data for route ${rt} during import.`); delete data[rt]; invalid++; } } } if (valid === 0) throw new Error("No valid heading entries found in file."); if (!confirm(`Importing will REPLACE ALL existing Sequence Heading overrides (${valid} valid entries found in file${invalid > 0 ? `, ${invalid} skipped` : ''}). Continue?`)) { if (importSeqHeadingsInput) importSeqHeadingsInput.value = ''; return; } let imported = 0; for (const rt in data) { if (Object.prototype.hasOwnProperty.call(data, rt)) { const key = sequenceHeadingOverrideBaseKey + rt; saveToStorage(key, data[rt]); imported++; } } logAdminAction("Data Imported", { type: "Sequence Headings", count: imported, fileName: file.name }); if (seqHeadingsBackupStatus) { seqHeadingsBackupStatus.textContent = 'Imported!'; setTimeout(() => seqHeadingsBackupStatus.textContent = '', 4000); } alert(`Imported ${imported} sequence headings.`); if (settingsForm && !settingsForm.classList.contains('hidden') && typeof displayActiveSequenceHeadings === 'function') { displayActiveSequenceHeadings(); } } catch (err) { if (seqHeadingsBackupStatus) { seqHeadingsBackupStatus.textContent = `Import Error: ${err.message}`; } alert("Import error: " + err.message); } finally { if (importSeqHeadingsInput) importSeqHeadingsInput.value = ''; } }; r.onerror = function () { if (seqHeadingsBackupStatus) { seqHeadingsBackupStatus.textContent = 'File Read Error.'; } alert("Error reading file."); if (importSeqHeadingsInput) importSeqHeadingsInput.value = ''; }; r.readAsText(file); }
function exportFinalDestinations() { if (!isLoggedIn || !['admin', 'moderator'].includes(users[currentUsername]?.role)) { alert('Admin Denied.'); return; } if (finalDestBackupStatus) finalDestBackupStatus.textContent = ''; try { const data = loadFromStorage(routeDestinationSettingsKey, {}); if (Object.keys(data).length === 0) { if (finalDestBackupStatus) finalDestBackupStatus.textContent = 'No data.'; alert("No final destination data to export."); return; }
    const now = new Date(); const day = now.getDate().toString().padStart(2, '0'); const month = (now.getMonth() + 1).toString().padStart(2, '0'); const year = now.getFullYear().toString().slice(-2); const hours = now.getHours().toString().padStart(2, '0'); const minutes = now.getMinutes().toString().padStart(2, '0'); const seconds = now.getSeconds().toString().padStart(2, '0'); const ts = `${day}${month}${year}-${hours}${minutes}${seconds}`;
    const json = JSON.stringify(data, null, 2); const blob = new Blob([json], { type: "application/json" }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = `ToolsBackup_FinalDests_${ts}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); logAdminAction("Data Exported", { type: "Final Destinations", count: Object.keys(data).length }); if (finalDestBackupStatus) { finalDestBackupStatus.textContent = 'Exported!'; setTimeout(() => finalDestBackupStatus.textContent = '', 4000); } } catch (e) { if (finalDestBackupStatus) finalDestBackupStatus.textContent = 'Export error.'; alert("Error exporting."); } }
function handleFinalDestinationsImport(file) { if (!isLoggedIn || users[currentUsername]?.role !== 'admin') { alert('Admin Denied.'); if (importFinalDestInput) importFinalDestInput.value = ''; return; } if (!file) { alert("No file selected."); return; } if (finalDestBackupStatus) finalDestBackupStatus.textContent = ''; if (!file.name.toLowerCase().endsWith('.json')) { alert("Invalid file type. Please select a JSON file."); if (importFinalDestInput) importFinalDestInput.value = ''; return; } const r = new FileReader(); r.onload = function (e) { try { const data = JSON.parse(e.target.result); if (typeof data !== 'object' || data === null || Array.isArray(data)) throw new Error("Not valid map/object format."); let routes = 0; for (const rt in data) { if (Object.prototype.hasOwnProperty.call(data, rt)) { routes++; if (!Array.isArray(data[rt]) || !data[rt].every(d => typeof d === 'string')) throw new Error(`Invalid data format for route ${rt}. Expecting array of strings.`); } } if (routes === 0) throw new Error("No routes found in the imported file."); if (!confirm(`Importing will REPLACE ALL existing final destinations (${routes} routes found in file). Continue?`)) { if (importFinalDestInput) importFinalDestInput.value = ''; return; } saveToStorage(routeDestinationSettingsKey, data); logAdminAction("Data Imported", { type: "Final Destinations", count: routes, fileName: file.name }); if (finalDestBackupStatus) { finalDestBackupStatus.textContent = 'Imported!'; setTimeout(() => finalDestBackupStatus.textContent = '', 4000); } alert(`Imported final destinations for ${routes} routes.`); if (settingsForm && !settingsForm.classList.contains('hidden') && typeof populateDestEditor === 'function') { populateDestEditor(); } } catch (err) { if (finalDestBackupStatus) { finalDestBackupStatus.textContent = `Import Error: ${err.message}`; } alert("Import error: " + err.message); } finally { if (importFinalDestInput) importFinalDestInput.value = ''; } }; r.onerror = function () { if (finalDestBackupStatus) { finalDestBackupStatus.textContent = 'File Read Error.'; } alert("Error reading file."); if (importFinalDestInput) importFinalDestInput.value = ''; }; r.readAsText(file); }

// --- Event Listeners ---
console.log("DEBUG: Adding event listeners.");
if (importCurtailmentsInput) importCurtailmentsInput.addEventListener('change', function () { if (this.files?.length > 0) handleCurtailmentImport(this.files[0]); });
if (importTmpInput) importTmpInput.addEventListener('change', function () { if (this.files?.length > 0) handleTmpImport(this.files[0]); });
if (importSeqHeadingsInput) importSeqHeadingsInput.addEventListener('change', function () { if (this.files?.length > 0) handleSequenceHeadingsImport(this.files[0]); });
if (importFinalDestInput) importFinalDestInput.addEventListener('change', function () { if (this.files?.length > 0) handleFinalDestinationsImport(this.files[0]); });
if (passwordModalInput) passwordModalInput.addEventListener('keydown', function (e) { if (e.key === 'Enter') { e.preventDefault(); handleModalConfirm(); } });
if (selectAllCheckbox) selectAllCheckbox.addEventListener('change', handleSelectAllCurtailments);
if (clearAuditLogButton) { clearAuditLogButton.addEventListener('click', clearAuditLog); } else { console.error("DEBUG: Clear Audit Log Button not found!"); }

// --- Initial Load ---
console.log("DEBUG: Attempting to add DOMContentLoaded listener...");
document.addEventListener('DOMContentLoaded', () => {
    console.log("DEBUG: DOMContentLoaded event fired.");
    const loginContainerRef = getElement('login-container');
    const appContainerRef = getElement('app-container');
    if (!loginContainerRef || !appContainerRef || !getElement('main-actions-container') || !getElement('go-back-button')) {
        console.error("DEBUG: CRITICAL ERROR: Essential containers or buttons missing.");
        document.body.innerHTML = '<p>Page loading error.</p>';
        return;
    }
    console.log("DEBUG: DOMContentLoaded - Calling checkLogin...");
    checkLogin();
    console.log("DEBUG: DOMContentLoaded - checkLogin finished.");
});
console.log("DEBUG: DOMContentLoaded listener attached.");

console.log('--- DEBUG: SCRIPT END REACHED (Tools.html - Fixes v3 + Export All + Roles + Prune Desc Countdown) ---');
// --- End of JavaScript ---
    </script>
</body>
</html>
